__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pysaml2 documentation build configuration file, created by
# sphinx-quickstart on Mon Aug 24 08:13:41 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
import alabaster

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage', 'sphinx.ext.viewcode',]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pysaml2'
copyright = u'2010-2011, Roland Hedberg'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.2'
# The full version, including alpha/beta/rc tags.
release = '1.2.0beta'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
#html_theme = 'default'
html_theme_path = [alabaster.get_path()]
html_theme = 'alabaster'
html_sidebars = {
   '**': [
       'about.html',
       'navigation.html',
       'searchbox.html',
       'donate.html',
   ]
}

html_theme_options = {
   'description': 'SAML2 implementation',
   'github_button': False,
   'github_user': 'rohe',
   'github_repo': 'pysaml2',
   'github_banner': False,

}

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'pysaml2doc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'pysaml2.tex', u'pysaml2 Documentation',
   u'Roland Hedberg', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True

########NEW FILE########
__FILENAME__ = adfs_v1x
# See http://technet.microsoft.com/en-us/library/cc733065(v=ws.10).aspx
# and http://technet.microsoft.com/en-us/library/ee913589(v=ws.10).aspx
# for information regarding the default claim types supported by
# Microsoft ADFS v1.x.

MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
    "fro": {
        'http://schemas.xmlsoap.org/claims/commonname': 'commonName',
        'http://schemas.xmlsoap.org/claims/emailaddress': 'emailAddress',
        'http://schemas.xmlsoap.org/claims/group': 'group',
        'http://schemas.xmlsoap.org/claims/upn': 'upn',
        },
    "to": {
        'commonName': 'http://schemas.xmlsoap.org/claims/commonname',
        'emailAddress': 'http://schemas.xmlsoap.org/claims/emailaddress',
        'group': 'http://schemas.xmlsoap.org/claims/group',
        'upn': 'http://schemas.xmlsoap.org/claims/upn',
    }
}

########NEW FILE########
__FILENAME__ = adfs_v20
# See http://technet.microsoft.com/en-us/library/ee913589(v=ws.10).aspx
# for information regarding the default claim types supported by
# Microsoft ADFS v2.0.

MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
    "fro": {
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress': 'emailAddress',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname': 'givenName',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name': 'name',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn': 'upn',
        'http://schemas.xmlsoap.org/claims/commonname': 'commonName',
        'http://schemas.xmlsoap.org/claims/group': 'group',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/role': 'role',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname': 'surname',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/privatepersonalidentifier': 'privatePersonalId',
        'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier': 'nameId',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationmethod': 'authenticationMethod',
        'http://schemas.xmlsoap.com/ws/2005/05/identity/claims/denyonlysid': 'denyOnlySid',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarysid': 'denyOnlyPrimarySid',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarygroupsid': 'denyOnlyPrimaryGroupSid',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid': 'groupSid',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/primarygroupsid': 'primaryGroupSid',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/primarysid': 'primarySid',
        'http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname': 'windowsAccountName',
        },
    "to": {
        'emailAddress': 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress',
        'givenName': 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname',
        'name': 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name',
        'upn': 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn',
        'commonName': 'http://schemas.xmlsoap.org/claims/commonname',
        'group': 'http://schemas.xmlsoap.org/claims/group',
        'role': 'http://schemas.microsoft.com/ws/2008/06/identity/claims/role',
        'surname': 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname',
        'privatePersonalId': 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/privatepersonalidentifier',
        'nameId': 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier',
        'authenticationMethod': 'http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationmethod',
        'denyOnlySid': 'http://schemas.xmlsoap.com/ws/2005/05/identity/claims/denyonlysid',
        'denyOnlyPrimarySid': 'http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarysid',
        'denyOnlyPrimaryGroupSid': 'http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarygroupsid',
        'groupSid': 'http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid',
        'primaryGroupSid': 'http://schemas.microsoft.com/ws/2008/06/identity/claims/primarygroupsid',
        'primarySid':  'http://schemas.microsoft.com/ws/2008/06/identity/claims/primarysid',
        'windowsAccountName': 'http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname',
    }
}

########NEW FILE########
__FILENAME__ = basic

MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:basic",
    "fro": {
        'urn:mace:dir:attribute-def:aRecord': 'aRecord',
        'urn:mace:dir:attribute-def:aliasedEntryName': 'aliasedEntryName',
        'urn:mace:dir:attribute-def:aliasedObjectName': 'aliasedObjectName',
        'urn:mace:dir:attribute-def:associatedDomain': 'associatedDomain',
        'urn:mace:dir:attribute-def:associatedName': 'associatedName',
        'urn:mace:dir:attribute-def:audio': 'audio',
        'urn:mace:dir:attribute-def:authorityRevocationList': 'authorityRevocationList',
        'urn:mace:dir:attribute-def:buildingName': 'buildingName',
        'urn:mace:dir:attribute-def:businessCategory': 'businessCategory',
        'urn:mace:dir:attribute-def:c': 'c',
        'urn:mace:dir:attribute-def:cACertificate': 'cACertificate',
        'urn:mace:dir:attribute-def:cNAMERecord': 'cNAMERecord',
        'urn:mace:dir:attribute-def:carLicense': 'carLicense',
        'urn:mace:dir:attribute-def:certificateRevocationList': 'certificateRevocationList',
        'urn:mace:dir:attribute-def:cn': 'cn',
        'urn:mace:dir:attribute-def:co': 'co',
        'urn:mace:dir:attribute-def:commonName': 'commonName',
        'urn:mace:dir:attribute-def:countryName': 'countryName',
        'urn:mace:dir:attribute-def:crossCertificatePair': 'crossCertificatePair',
        'urn:mace:dir:attribute-def:dITRedirect': 'dITRedirect',
        'urn:mace:dir:attribute-def:dSAQuality': 'dSAQuality',
        'urn:mace:dir:attribute-def:dc': 'dc',
        'urn:mace:dir:attribute-def:deltaRevocationList': 'deltaRevocationList',
        'urn:mace:dir:attribute-def:departmentNumber': 'departmentNumber',
        'urn:mace:dir:attribute-def:description': 'description',
        'urn:mace:dir:attribute-def:destinationIndicator': 'destinationIndicator',
        'urn:mace:dir:attribute-def:displayName': 'displayName',
        'urn:mace:dir:attribute-def:distinguishedName': 'distinguishedName',
        'urn:mace:dir:attribute-def:dmdName': 'dmdName',
        'urn:mace:dir:attribute-def:dnQualifier': 'dnQualifier',
        'urn:mace:dir:attribute-def:documentAuthor': 'documentAuthor',
        'urn:mace:dir:attribute-def:documentIdentifier': 'documentIdentifier',
        'urn:mace:dir:attribute-def:documentLocation': 'documentLocation',
        'urn:mace:dir:attribute-def:documentPublisher': 'documentPublisher',
        'urn:mace:dir:attribute-def:documentTitle': 'documentTitle',
        'urn:mace:dir:attribute-def:documentVersion': 'documentVersion',
        'urn:mace:dir:attribute-def:domainComponent': 'domainComponent',
        'urn:mace:dir:attribute-def:drink': 'drink',
        'urn:mace:dir:attribute-def:eduOrgHomePageURI': 'eduOrgHomePageURI',
        'urn:mace:dir:attribute-def:eduOrgIdentityAuthNPolicyURI': 'eduOrgIdentityAuthNPolicyURI',
        'urn:mace:dir:attribute-def:eduOrgLegalName': 'eduOrgLegalName',
        'urn:mace:dir:attribute-def:eduOrgSuperiorURI': 'eduOrgSuperiorURI',
        'urn:mace:dir:attribute-def:eduOrgWhitePagesURI': 'eduOrgWhitePagesURI',
        'urn:mace:dir:attribute-def:eduPersonAffiliation': 'eduPersonAffiliation',
        'urn:mace:dir:attribute-def:eduPersonEntitlement': 'eduPersonEntitlement',
        'urn:mace:dir:attribute-def:eduPersonNickname': 'eduPersonNickname',
        'urn:mace:dir:attribute-def:eduPersonOrgDN': 'eduPersonOrgDN',
        'urn:mace:dir:attribute-def:eduPersonOrgUnitDN': 'eduPersonOrgUnitDN',
        'urn:mace:dir:attribute-def:eduPersonPrimaryAffiliation': 'eduPersonPrimaryAffiliation',
        'urn:mace:dir:attribute-def:eduPersonPrimaryOrgUnitDN': 'eduPersonPrimaryOrgUnitDN',
        'urn:mace:dir:attribute-def:eduPersonPrincipalName': 'eduPersonPrincipalName',
        'urn:mace:dir:attribute-def:eduPersonScopedAffiliation': 'eduPersonScopedAffiliation',
        'urn:mace:dir:attribute-def:eduPersonTargetedID': 'eduPersonTargetedID',
        'urn:mace:dir:attribute-def:email': 'email',
        'urn:mace:dir:attribute-def:emailAddress': 'emailAddress',
        'urn:mace:dir:attribute-def:employeeNumber': 'employeeNumber',
        'urn:mace:dir:attribute-def:employeeType': 'employeeType',
        'urn:mace:dir:attribute-def:enhancedSearchGuide': 'enhancedSearchGuide',
        'urn:mace:dir:attribute-def:facsimileTelephoneNumber': 'facsimileTelephoneNumber',
        'urn:mace:dir:attribute-def:favouriteDrink': 'favouriteDrink',
        'urn:mace:dir:attribute-def:fax': 'fax',
        'urn:mace:dir:attribute-def:federationFeideSchemaVersion': 'federationFeideSchemaVersion',
        'urn:mace:dir:attribute-def:friendlyCountryName': 'friendlyCountryName',
        'urn:mace:dir:attribute-def:generationQualifier': 'generationQualifier',
        'urn:mace:dir:attribute-def:givenName': 'givenName',
        'urn:mace:dir:attribute-def:gn': 'gn',
        'urn:mace:dir:attribute-def:homePhone': 'homePhone',
        'urn:mace:dir:attribute-def:homePostalAddress': 'homePostalAddress',
        'urn:mace:dir:attribute-def:homeTelephoneNumber': 'homeTelephoneNumber',
        'urn:mace:dir:attribute-def:host': 'host',
        'urn:mace:dir:attribute-def:houseIdentifier': 'houseIdentifier',
        'urn:mace:dir:attribute-def:info': 'info',
        'urn:mace:dir:attribute-def:initials': 'initials',
        'urn:mace:dir:attribute-def:internationaliSDNNumber': 'internationaliSDNNumber',
        'urn:mace:dir:attribute-def:janetMailbox': 'janetMailbox',
        'urn:mace:dir:attribute-def:jpegPhoto': 'jpegPhoto',
        'urn:mace:dir:attribute-def:knowledgeInformation': 'knowledgeInformation',
        'urn:mace:dir:attribute-def:l': 'l',
        'urn:mace:dir:attribute-def:labeledURI': 'labeledURI',
        'urn:mace:dir:attribute-def:localityName': 'localityName',
        'urn:mace:dir:attribute-def:mDRecord': 'mDRecord',
        'urn:mace:dir:attribute-def:mXRecord': 'mXRecord',
        'urn:mace:dir:attribute-def:mail': 'mail',
        'urn:mace:dir:attribute-def:mailPreferenceOption': 'mailPreferenceOption',
        'urn:mace:dir:attribute-def:manager': 'manager',
        'urn:mace:dir:attribute-def:member': 'member',
        'urn:mace:dir:attribute-def:mobile': 'mobile',
        'urn:mace:dir:attribute-def:mobileTelephoneNumber': 'mobileTelephoneNumber',
        'urn:mace:dir:attribute-def:nSRecord': 'nSRecord',
        'urn:mace:dir:attribute-def:name': 'name',
        'urn:mace:dir:attribute-def:norEduOrgAcronym': 'norEduOrgAcronym',
        'urn:mace:dir:attribute-def:norEduOrgNIN': 'norEduOrgNIN',
        'urn:mace:dir:attribute-def:norEduOrgSchemaVersion': 'norEduOrgSchemaVersion',
        'urn:mace:dir:attribute-def:norEduOrgUniqueIdentifier': 'norEduOrgUniqueIdentifier',
        'urn:mace:dir:attribute-def:norEduOrgUniqueNumber': 'norEduOrgUniqueNumber',
        'urn:mace:dir:attribute-def:norEduOrgUnitUniqueIdentifier': 'norEduOrgUnitUniqueIdentifier',
        'urn:mace:dir:attribute-def:norEduOrgUnitUniqueNumber': 'norEduOrgUnitUniqueNumber',
        'urn:mace:dir:attribute-def:norEduPersonBirthDate': 'norEduPersonBirthDate',
        'urn:mace:dir:attribute-def:norEduPersonLIN': 'norEduPersonLIN',
        'urn:mace:dir:attribute-def:norEduPersonNIN': 'norEduPersonNIN',
        'urn:mace:dir:attribute-def:o': 'o',
        'urn:mace:dir:attribute-def:objectClass': 'objectClass',
        'urn:mace:dir:attribute-def:organizationName': 'organizationName',
        'urn:mace:dir:attribute-def:organizationalStatus': 'organizationalStatus',
        'urn:mace:dir:attribute-def:organizationalUnitName': 'organizationalUnitName',
        'urn:mace:dir:attribute-def:otherMailbox': 'otherMailbox',
        'urn:mace:dir:attribute-def:ou': 'ou',
        'urn:mace:dir:attribute-def:owner': 'owner',
        'urn:mace:dir:attribute-def:pager': 'pager',
        'urn:mace:dir:attribute-def:pagerTelephoneNumber': 'pagerTelephoneNumber',
        'urn:mace:dir:attribute-def:personalSignature': 'personalSignature',
        'urn:mace:dir:attribute-def:personalTitle': 'personalTitle',
        'urn:mace:dir:attribute-def:photo': 'photo',
        'urn:mace:dir:attribute-def:physicalDeliveryOfficeName': 'physicalDeliveryOfficeName',
        'urn:mace:dir:attribute-def:pkcs9email': 'pkcs9email',
        'urn:mace:dir:attribute-def:postOfficeBox': 'postOfficeBox',
        'urn:mace:dir:attribute-def:postalAddress': 'postalAddress',
        'urn:mace:dir:attribute-def:postalCode': 'postalCode',
        'urn:mace:dir:attribute-def:preferredDeliveryMethod': 'preferredDeliveryMethod',
        'urn:mace:dir:attribute-def:preferredLanguage': 'preferredLanguage',
        'urn:mace:dir:attribute-def:presentationAddress': 'presentationAddress',
        'urn:mace:dir:attribute-def:protocolInformation': 'protocolInformation',
        'urn:mace:dir:attribute-def:pseudonym': 'pseudonym',
        'urn:mace:dir:attribute-def:registeredAddress': 'registeredAddress',
        'urn:mace:dir:attribute-def:rfc822Mailbox': 'rfc822Mailbox',
        'urn:mace:dir:attribute-def:roleOccupant': 'roleOccupant',
        'urn:mace:dir:attribute-def:roomNumber': 'roomNumber',
        'urn:mace:dir:attribute-def:sOARecord': 'sOARecord',
        'urn:mace:dir:attribute-def:searchGuide': 'searchGuide',
        'urn:mace:dir:attribute-def:secretary': 'secretary',
        'urn:mace:dir:attribute-def:seeAlso': 'seeAlso',
        'urn:mace:dir:attribute-def:serialNumber': 'serialNumber',
        'urn:mace:dir:attribute-def:singleLevelQuality': 'singleLevelQuality',
        'urn:mace:dir:attribute-def:sn': 'sn',
        'urn:mace:dir:attribute-def:st': 'st',
        'urn:mace:dir:attribute-def:stateOrProvinceName': 'stateOrProvinceName',
        'urn:mace:dir:attribute-def:street': 'street',
        'urn:mace:dir:attribute-def:streetAddress': 'streetAddress',
        'urn:mace:dir:attribute-def:subtreeMaximumQuality': 'subtreeMaximumQuality',
        'urn:mace:dir:attribute-def:subtreeMinimumQuality': 'subtreeMinimumQuality',
        'urn:mace:dir:attribute-def:supportedAlgorithms': 'supportedAlgorithms',
        'urn:mace:dir:attribute-def:supportedApplicationContext': 'supportedApplicationContext',
        'urn:mace:dir:attribute-def:surname': 'surname',
        'urn:mace:dir:attribute-def:telephoneNumber': 'telephoneNumber',
        'urn:mace:dir:attribute-def:teletexTerminalIdentifier': 'teletexTerminalIdentifier',
        'urn:mace:dir:attribute-def:telexNumber': 'telexNumber',
        'urn:mace:dir:attribute-def:textEncodedORAddress': 'textEncodedORAddress',
        'urn:mace:dir:attribute-def:title': 'title',
        'urn:mace:dir:attribute-def:uid': 'uid',
        'urn:mace:dir:attribute-def:uniqueIdentifier': 'uniqueIdentifier',
        'urn:mace:dir:attribute-def:uniqueMember': 'uniqueMember',
        'urn:mace:dir:attribute-def:userCertificate': 'userCertificate',
        'urn:mace:dir:attribute-def:userClass': 'userClass',
        'urn:mace:dir:attribute-def:userPKCS12': 'userPKCS12',
        'urn:mace:dir:attribute-def:userPassword': 'userPassword',
        'urn:mace:dir:attribute-def:userSMIMECertificate': 'userSMIMECertificate',
        'urn:mace:dir:attribute-def:userid': 'userid',
        'urn:mace:dir:attribute-def:x121Address': 'x121Address',
        'urn:mace:dir:attribute-def:x500UniqueIdentifier': 'x500UniqueIdentifier',
        },
    "to": {
        'aRecord': 'urn:mace:dir:attribute-def:aRecord',
        'aliasedEntryName': 'urn:mace:dir:attribute-def:aliasedEntryName',
        'aliasedObjectName': 'urn:mace:dir:attribute-def:aliasedObjectName',
        'associatedDomain': 'urn:mace:dir:attribute-def:associatedDomain',
        'associatedName': 'urn:mace:dir:attribute-def:associatedName',
        'audio': 'urn:mace:dir:attribute-def:audio',
        'authorityRevocationList': 'urn:mace:dir:attribute-def:authorityRevocationList',
        'buildingName': 'urn:mace:dir:attribute-def:buildingName',
        'businessCategory': 'urn:mace:dir:attribute-def:businessCategory',
        'c': 'urn:mace:dir:attribute-def:c',
        'cACertificate': 'urn:mace:dir:attribute-def:cACertificate',
        'cNAMERecord': 'urn:mace:dir:attribute-def:cNAMERecord',
        'carLicense': 'urn:mace:dir:attribute-def:carLicense',
        'certificateRevocationList': 'urn:mace:dir:attribute-def:certificateRevocationList',
        'cn': 'urn:mace:dir:attribute-def:cn',
        'co': 'urn:mace:dir:attribute-def:co',
        'commonName': 'urn:mace:dir:attribute-def:commonName',
        'countryName': 'urn:mace:dir:attribute-def:countryName',
        'crossCertificatePair': 'urn:mace:dir:attribute-def:crossCertificatePair',
        'dITRedirect': 'urn:mace:dir:attribute-def:dITRedirect',
        'dSAQuality': 'urn:mace:dir:attribute-def:dSAQuality',
        'dc': 'urn:mace:dir:attribute-def:dc',
        'deltaRevocationList': 'urn:mace:dir:attribute-def:deltaRevocationList',
        'departmentNumber': 'urn:mace:dir:attribute-def:departmentNumber',
        'description': 'urn:mace:dir:attribute-def:description',
        'destinationIndicator': 'urn:mace:dir:attribute-def:destinationIndicator',
        'displayName': 'urn:mace:dir:attribute-def:displayName',
        'distinguishedName': 'urn:mace:dir:attribute-def:distinguishedName',
        'dmdName': 'urn:mace:dir:attribute-def:dmdName',
        'dnQualifier': 'urn:mace:dir:attribute-def:dnQualifier',
        'documentAuthor': 'urn:mace:dir:attribute-def:documentAuthor',
        'documentIdentifier': 'urn:mace:dir:attribute-def:documentIdentifier',
        'documentLocation': 'urn:mace:dir:attribute-def:documentLocation',
        'documentPublisher': 'urn:mace:dir:attribute-def:documentPublisher',
        'documentTitle': 'urn:mace:dir:attribute-def:documentTitle',
        'documentVersion': 'urn:mace:dir:attribute-def:documentVersion',
        'domainComponent': 'urn:mace:dir:attribute-def:domainComponent',
        'drink': 'urn:mace:dir:attribute-def:drink',
        'eduOrgHomePageURI': 'urn:mace:dir:attribute-def:eduOrgHomePageURI',
        'eduOrgIdentityAuthNPolicyURI': 'urn:mace:dir:attribute-def:eduOrgIdentityAuthNPolicyURI',
        'eduOrgLegalName': 'urn:mace:dir:attribute-def:eduOrgLegalName',
        'eduOrgSuperiorURI': 'urn:mace:dir:attribute-def:eduOrgSuperiorURI',
        'eduOrgWhitePagesURI': 'urn:mace:dir:attribute-def:eduOrgWhitePagesURI',
        'eduPersonAffiliation': 'urn:mace:dir:attribute-def:eduPersonAffiliation',
        'eduPersonEntitlement': 'urn:mace:dir:attribute-def:eduPersonEntitlement',
        'eduPersonNickname': 'urn:mace:dir:attribute-def:eduPersonNickname',
        'eduPersonOrgDN': 'urn:mace:dir:attribute-def:eduPersonOrgDN',
        'eduPersonOrgUnitDN': 'urn:mace:dir:attribute-def:eduPersonOrgUnitDN',
        'eduPersonPrimaryAffiliation': 'urn:mace:dir:attribute-def:eduPersonPrimaryAffiliation',
        'eduPersonPrimaryOrgUnitDN': 'urn:mace:dir:attribute-def:eduPersonPrimaryOrgUnitDN',
        'eduPersonPrincipalName': 'urn:mace:dir:attribute-def:eduPersonPrincipalName',
        'eduPersonScopedAffiliation': 'urn:mace:dir:attribute-def:eduPersonScopedAffiliation',
        'eduPersonTargetedID': 'urn:mace:dir:attribute-def:eduPersonTargetedID',
        'email': 'urn:mace:dir:attribute-def:email',
        'emailAddress': 'urn:mace:dir:attribute-def:emailAddress',
        'employeeNumber': 'urn:mace:dir:attribute-def:employeeNumber',
        'employeeType': 'urn:mace:dir:attribute-def:employeeType',
        'enhancedSearchGuide': 'urn:mace:dir:attribute-def:enhancedSearchGuide',
        'facsimileTelephoneNumber': 'urn:mace:dir:attribute-def:facsimileTelephoneNumber',
        'favouriteDrink': 'urn:mace:dir:attribute-def:favouriteDrink',
        'fax': 'urn:mace:dir:attribute-def:fax',
        'federationFeideSchemaVersion': 'urn:mace:dir:attribute-def:federationFeideSchemaVersion',
        'friendlyCountryName': 'urn:mace:dir:attribute-def:friendlyCountryName',
        'generationQualifier': 'urn:mace:dir:attribute-def:generationQualifier',
        'givenName': 'urn:mace:dir:attribute-def:givenName',
        'gn': 'urn:mace:dir:attribute-def:gn',
        'homePhone': 'urn:mace:dir:attribute-def:homePhone',
        'homePostalAddress': 'urn:mace:dir:attribute-def:homePostalAddress',
        'homeTelephoneNumber': 'urn:mace:dir:attribute-def:homeTelephoneNumber',
        'host': 'urn:mace:dir:attribute-def:host',
        'houseIdentifier': 'urn:mace:dir:attribute-def:houseIdentifier',
        'info': 'urn:mace:dir:attribute-def:info',
        'initials': 'urn:mace:dir:attribute-def:initials',
        'internationaliSDNNumber': 'urn:mace:dir:attribute-def:internationaliSDNNumber',
        'janetMailbox': 'urn:mace:dir:attribute-def:janetMailbox',
        'jpegPhoto': 'urn:mace:dir:attribute-def:jpegPhoto',
        'knowledgeInformation': 'urn:mace:dir:attribute-def:knowledgeInformation',
        'l': 'urn:mace:dir:attribute-def:l',
        'labeledURI': 'urn:mace:dir:attribute-def:labeledURI',
        'localityName': 'urn:mace:dir:attribute-def:localityName',
        'mDRecord': 'urn:mace:dir:attribute-def:mDRecord',
        'mXRecord': 'urn:mace:dir:attribute-def:mXRecord',
        'mail': 'urn:mace:dir:attribute-def:mail',
        'mailPreferenceOption': 'urn:mace:dir:attribute-def:mailPreferenceOption',
        'manager': 'urn:mace:dir:attribute-def:manager',
        'member': 'urn:mace:dir:attribute-def:member',
        'mobile': 'urn:mace:dir:attribute-def:mobile',
        'mobileTelephoneNumber': 'urn:mace:dir:attribute-def:mobileTelephoneNumber',
        'nSRecord': 'urn:mace:dir:attribute-def:nSRecord',
        'name': 'urn:mace:dir:attribute-def:name',
        'norEduOrgAcronym': 'urn:mace:dir:attribute-def:norEduOrgAcronym',
        'norEduOrgNIN': 'urn:mace:dir:attribute-def:norEduOrgNIN',
        'norEduOrgSchemaVersion': 'urn:mace:dir:attribute-def:norEduOrgSchemaVersion',
        'norEduOrgUniqueIdentifier': 'urn:mace:dir:attribute-def:norEduOrgUniqueIdentifier',
        'norEduOrgUniqueNumber': 'urn:mace:dir:attribute-def:norEduOrgUniqueNumber',
        'norEduOrgUnitUniqueIdentifier': 'urn:mace:dir:attribute-def:norEduOrgUnitUniqueIdentifier',
        'norEduOrgUnitUniqueNumber': 'urn:mace:dir:attribute-def:norEduOrgUnitUniqueNumber',
        'norEduPersonBirthDate': 'urn:mace:dir:attribute-def:norEduPersonBirthDate',
        'norEduPersonLIN': 'urn:mace:dir:attribute-def:norEduPersonLIN',
        'norEduPersonNIN': 'urn:mace:dir:attribute-def:norEduPersonNIN',
        'o': 'urn:mace:dir:attribute-def:o',
        'objectClass': 'urn:mace:dir:attribute-def:objectClass',
        'organizationName': 'urn:mace:dir:attribute-def:organizationName',
        'organizationalStatus': 'urn:mace:dir:attribute-def:organizationalStatus',
        'organizationalUnitName': 'urn:mace:dir:attribute-def:organizationalUnitName',
        'otherMailbox': 'urn:mace:dir:attribute-def:otherMailbox',
        'ou': 'urn:mace:dir:attribute-def:ou',
        'owner': 'urn:mace:dir:attribute-def:owner',
        'pager': 'urn:mace:dir:attribute-def:pager',
        'pagerTelephoneNumber': 'urn:mace:dir:attribute-def:pagerTelephoneNumber',
        'personalSignature': 'urn:mace:dir:attribute-def:personalSignature',
        'personalTitle': 'urn:mace:dir:attribute-def:personalTitle',
        'photo': 'urn:mace:dir:attribute-def:photo',
        'physicalDeliveryOfficeName': 'urn:mace:dir:attribute-def:physicalDeliveryOfficeName',
        'pkcs9email': 'urn:mace:dir:attribute-def:pkcs9email',
        'postOfficeBox': 'urn:mace:dir:attribute-def:postOfficeBox',
        'postalAddress': 'urn:mace:dir:attribute-def:postalAddress',
        'postalCode': 'urn:mace:dir:attribute-def:postalCode',
        'preferredDeliveryMethod': 'urn:mace:dir:attribute-def:preferredDeliveryMethod',
        'preferredLanguage': 'urn:mace:dir:attribute-def:preferredLanguage',
        'presentationAddress': 'urn:mace:dir:attribute-def:presentationAddress',
        'protocolInformation': 'urn:mace:dir:attribute-def:protocolInformation',
        'pseudonym': 'urn:mace:dir:attribute-def:pseudonym',
        'registeredAddress': 'urn:mace:dir:attribute-def:registeredAddress',
        'rfc822Mailbox': 'urn:mace:dir:attribute-def:rfc822Mailbox',
        'roleOccupant': 'urn:mace:dir:attribute-def:roleOccupant',
        'roomNumber': 'urn:mace:dir:attribute-def:roomNumber',
        'sOARecord': 'urn:mace:dir:attribute-def:sOARecord',
        'searchGuide': 'urn:mace:dir:attribute-def:searchGuide',
        'secretary': 'urn:mace:dir:attribute-def:secretary',
        'seeAlso': 'urn:mace:dir:attribute-def:seeAlso',
        'serialNumber': 'urn:mace:dir:attribute-def:serialNumber',
        'singleLevelQuality': 'urn:mace:dir:attribute-def:singleLevelQuality',
        'sn': 'urn:mace:dir:attribute-def:sn',
        'st': 'urn:mace:dir:attribute-def:st',
        'stateOrProvinceName': 'urn:mace:dir:attribute-def:stateOrProvinceName',
        'street': 'urn:mace:dir:attribute-def:street',
        'streetAddress': 'urn:mace:dir:attribute-def:streetAddress',
        'subtreeMaximumQuality': 'urn:mace:dir:attribute-def:subtreeMaximumQuality',
        'subtreeMinimumQuality': 'urn:mace:dir:attribute-def:subtreeMinimumQuality',
        'supportedAlgorithms': 'urn:mace:dir:attribute-def:supportedAlgorithms',
        'supportedApplicationContext': 'urn:mace:dir:attribute-def:supportedApplicationContext',
        'surname': 'urn:mace:dir:attribute-def:surname',
        'telephoneNumber': 'urn:mace:dir:attribute-def:telephoneNumber',
        'teletexTerminalIdentifier': 'urn:mace:dir:attribute-def:teletexTerminalIdentifier',
        'telexNumber': 'urn:mace:dir:attribute-def:telexNumber',
        'textEncodedORAddress': 'urn:mace:dir:attribute-def:textEncodedORAddress',
        'title': 'urn:mace:dir:attribute-def:title',
        'uid': 'urn:mace:dir:attribute-def:uid',
        'uniqueIdentifier': 'urn:mace:dir:attribute-def:uniqueIdentifier',
        'uniqueMember': 'urn:mace:dir:attribute-def:uniqueMember',
        'userCertificate': 'urn:mace:dir:attribute-def:userCertificate',
        'userClass': 'urn:mace:dir:attribute-def:userClass',
        'userPKCS12': 'urn:mace:dir:attribute-def:userPKCS12',
        'userPassword': 'urn:mace:dir:attribute-def:userPassword',
        'userSMIMECertificate': 'urn:mace:dir:attribute-def:userSMIMECertificate',
        'userid': 'urn:mace:dir:attribute-def:userid',
        'x121Address': 'urn:mace:dir:attribute-def:x121Address',
        'x500UniqueIdentifier': 'urn:mace:dir:attribute-def:x500UniqueIdentifier',
    }
}
########NEW FILE########
__FILENAME__ = saml_uri
__author__ = 'rolandh'

EDUPERSON_OID = "urn:oid:1.3.6.1.4.1.5923.1.1.1."
X500ATTR_OID = "urn:oid:2.5.4."
NOREDUPERSON_OID = "urn:oid:1.3.6.1.4.1.2428.90.1."
NETSCAPE_LDAP = "urn:oid:2.16.840.1.113730.3.1."
UCL_DIR_PILOT = 'urn:oid:0.9.2342.19200300.100.1.'
PKCS_9 = "urn:oid:1.2.840.113549.1.9.1."
UMICH = "urn:oid:1.3.6.1.4.1.250.1.57."

MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
    "fro": {
        EDUPERSON_OID+'2': 'eduPersonNickname',
        EDUPERSON_OID+'9': 'eduPersonScopedAffiliation',
        EDUPERSON_OID+'11': 'eduPersonAssurance',
        EDUPERSON_OID+'10': 'eduPersonTargetedID',
        EDUPERSON_OID+'4': 'eduPersonOrgUnitDN',
        NOREDUPERSON_OID+'6': 'norEduOrgAcronym',
        NOREDUPERSON_OID+'7': 'norEduOrgUniqueIdentifier',
        NOREDUPERSON_OID+'4': 'norEduPersonLIN',
        EDUPERSON_OID+'1': 'eduPersonAffiliation',
        NOREDUPERSON_OID+'2': 'norEduOrgUnitUniqueNumber',
        NETSCAPE_LDAP+'40': 'userSMIMECertificate',
        NOREDUPERSON_OID+'1': 'norEduOrgUniqueNumber',
        NETSCAPE_LDAP+'241': 'displayName',
        UCL_DIR_PILOT+'37': 'associatedDomain',
        EDUPERSON_OID+'6': 'eduPersonPrincipalName',
        NOREDUPERSON_OID+'8': 'norEduOrgUnitUniqueIdentifier',
        NOREDUPERSON_OID+'9': 'federationFeideSchemaVersion',
        X500ATTR_OID+'53': 'deltaRevocationList',
        X500ATTR_OID+'52': 'supportedAlgorithms',
        X500ATTR_OID+'51': 'houseIdentifier',
        X500ATTR_OID+'50': 'uniqueMember',
        X500ATTR_OID+'19': 'physicalDeliveryOfficeName',
        X500ATTR_OID+'18': 'postOfficeBox',
        X500ATTR_OID+'17': 'postalCode',
        X500ATTR_OID+'16': 'postalAddress',
        X500ATTR_OID+'15': 'businessCategory',
        X500ATTR_OID+'14': 'searchGuide',
        EDUPERSON_OID+'5': 'eduPersonPrimaryAffiliation',
        X500ATTR_OID+'12': 'title',
        X500ATTR_OID+'11': 'ou',
        X500ATTR_OID+'10': 'o',
        X500ATTR_OID+'37': 'cACertificate',
        X500ATTR_OID+'36': 'userCertificate',
        X500ATTR_OID+'31': 'member',
        X500ATTR_OID+'30': 'supportedApplicationContext',
        X500ATTR_OID+'33': 'roleOccupant',
        X500ATTR_OID+'32': 'owner',
        NETSCAPE_LDAP+'1': 'carLicense',
        PKCS_9+'1': 'email',
        NETSCAPE_LDAP+'3': 'employeeNumber',
        NETSCAPE_LDAP+'2': 'departmentNumber',
        X500ATTR_OID+'39': 'certificateRevocationList',
        X500ATTR_OID+'38': 'authorityRevocationList',
        NETSCAPE_LDAP+'216': 'userPKCS12',
        EDUPERSON_OID+'8': 'eduPersonPrimaryOrgUnitDN',
        X500ATTR_OID+'9': 'street',
        X500ATTR_OID+'8': 'st',
        NETSCAPE_LDAP+'39': 'preferredLanguage',
        EDUPERSON_OID+'7': 'eduPersonEntitlement',
        X500ATTR_OID+'2': 'knowledgeInformation',
        X500ATTR_OID+'7': 'l',
        X500ATTR_OID+'6': 'c',
        X500ATTR_OID+'5': 'serialNumber',
        X500ATTR_OID+'4': 'sn',
        UCL_DIR_PILOT+'60': 'jpegPhoto',
        X500ATTR_OID+'65': 'pseudonym',
        NOREDUPERSON_OID+'5': 'norEduPersonNIN',
        UCL_DIR_PILOT+'3': 'mail',
        UCL_DIR_PILOT+'25': 'dc',
        X500ATTR_OID+'40': 'crossCertificatePair',
        X500ATTR_OID+'42': 'givenName',
        X500ATTR_OID+'43': 'initials',
        X500ATTR_OID+'44': 'generationQualifier',
        X500ATTR_OID+'45': 'x500UniqueIdentifier',
        X500ATTR_OID+'46': 'dnQualifier',
        X500ATTR_OID+'47': 'enhancedSearchGuide',
        X500ATTR_OID+'48': 'protocolInformation',
        X500ATTR_OID+'54': 'dmdName',
        NETSCAPE_LDAP+'4': 'employeeType',
        X500ATTR_OID+'22': 'teletexTerminalIdentifier',
        X500ATTR_OID+'23': 'facsimileTelephoneNumber',
        X500ATTR_OID+'20': 'telephoneNumber',
        X500ATTR_OID+'21': 'telexNumber',
        X500ATTR_OID+'26': 'registeredAddress',
        X500ATTR_OID+'27': 'destinationIndicator',
        X500ATTR_OID+'24': 'x121Address',
        X500ATTR_OID+'25': 'internationaliSDNNumber',
        X500ATTR_OID+'28': 'preferredDeliveryMethod',
        X500ATTR_OID+'29': 'presentationAddress',
        EDUPERSON_OID+'3': 'eduPersonOrgDN',
        NOREDUPERSON_OID+'3': 'norEduPersonBirthDate',
        UMICH+'57': 'labeledURI',
        UCL_DIR_PILOT+'1': 'uid',
    },
    "to": {
        'roleOccupant': X500ATTR_OID+'33',
        'gn': X500ATTR_OID+'42',
        'norEduPersonNIN': NOREDUPERSON_OID+'5',
        'title': X500ATTR_OID+'12',
        'facsimileTelephoneNumber': X500ATTR_OID+'23',
        'mail': UCL_DIR_PILOT+'3',
        'postOfficeBox': X500ATTR_OID+'18',
        'fax': X500ATTR_OID+'23',
        'telephoneNumber': X500ATTR_OID+'20',
        'norEduPersonBirthDate': NOREDUPERSON_OID+'3',
        'rfc822Mailbox': UCL_DIR_PILOT+'3',
        'dc': UCL_DIR_PILOT+'25',
        'countryName': X500ATTR_OID+'6',
        'emailAddress': PKCS_9+'1',
        'employeeNumber': NETSCAPE_LDAP+'3',
        'organizationName': X500ATTR_OID+'10',
        'eduPersonAssurance': EDUPERSON_OID+'11',
        'norEduOrgAcronym': NOREDUPERSON_OID+'6',
        'registeredAddress': X500ATTR_OID+'26',
        'physicalDeliveryOfficeName': X500ATTR_OID+'19',
        'associatedDomain': UCL_DIR_PILOT+'37',
        'l': X500ATTR_OID+'7',
        'stateOrProvinceName': X500ATTR_OID+'8',
        'federationFeideSchemaVersion': NOREDUPERSON_OID+'9',
        'pkcs9email': PKCS_9+'1',
        'givenName': X500ATTR_OID+'42',
        'givenname': X500ATTR_OID+'42',
        'x500UniqueIdentifier': X500ATTR_OID+'45',
        'eduPersonNickname': EDUPERSON_OID+'2',
        'houseIdentifier': X500ATTR_OID+'51',
        'street': X500ATTR_OID+'9',
        'supportedAlgorithms': X500ATTR_OID+'52',
        'preferredLanguage': NETSCAPE_LDAP+'39',
        'postalAddress': X500ATTR_OID+'16',
        'email': PKCS_9+'1',
        'norEduOrgUnitUniqueIdentifier': NOREDUPERSON_OID+'8',
        'eduPersonPrimaryOrgUnitDN': EDUPERSON_OID+'8',
        'c': X500ATTR_OID+'6',
        'teletexTerminalIdentifier': X500ATTR_OID+'22',
        'o': X500ATTR_OID+'10',
        'cACertificate': X500ATTR_OID+'37',
        'telexNumber': X500ATTR_OID+'21',
        'ou': X500ATTR_OID+'11',
        'initials': X500ATTR_OID+'43',
        'eduPersonOrgUnitDN': EDUPERSON_OID+'4',
        'deltaRevocationList': X500ATTR_OID+'53',
        'norEduPersonLIN': NOREDUPERSON_OID+'4',
        'supportedApplicationContext': X500ATTR_OID+'30',
        'eduPersonEntitlement': EDUPERSON_OID+'7',
        'generationQualifier': X500ATTR_OID+'44',
        'eduPersonAffiliation': EDUPERSON_OID+'1',
        'eduPersonPrincipalName': EDUPERSON_OID+'6',
        'edupersonprincipalname': EDUPERSON_OID+'6',
        'localityName': X500ATTR_OID+'7',
        'owner': X500ATTR_OID+'32',
        'norEduOrgUnitUniqueNumber': NOREDUPERSON_OID+'2',
        'searchGuide': X500ATTR_OID+'14',
        'certificateRevocationList': X500ATTR_OID+'39',
        'organizationalUnitName': X500ATTR_OID+'11',
        'userCertificate': X500ATTR_OID+'36',
        'preferredDeliveryMethod': X500ATTR_OID+'28',
        'internationaliSDNNumber': X500ATTR_OID+'25',
        'uniqueMember': X500ATTR_OID+'50',
        'departmentNumber': NETSCAPE_LDAP+'2',
        'enhancedSearchGuide': X500ATTR_OID+'47',
        'userPKCS12': NETSCAPE_LDAP+'216',
        'eduPersonTargetedID': EDUPERSON_OID+'10',
        'norEduOrgUniqueNumber': NOREDUPERSON_OID+'1',
        'x121Address': X500ATTR_OID+'24',
        'destinationIndicator': X500ATTR_OID+'27',
        'eduPersonPrimaryAffiliation': EDUPERSON_OID+'5',
        'surname': X500ATTR_OID+'4',
        'jpegPhoto': UCL_DIR_PILOT+'60',
        'eduPersonScopedAffiliation': EDUPERSON_OID+'9',
        'edupersonscopedaffiliation': EDUPERSON_OID+'9',
        'protocolInformation': X500ATTR_OID+'48',
        'knowledgeInformation': X500ATTR_OID+'2',
        'employeeType': NETSCAPE_LDAP+'4',
        'userSMIMECertificate': NETSCAPE_LDAP+'40',
        'member': X500ATTR_OID+'31',
        'streetAddress': X500ATTR_OID+'9',
        'dmdName': X500ATTR_OID+'54',
        'postalCode': X500ATTR_OID+'17',
        'pseudonym': X500ATTR_OID+'65',
        'dnQualifier': X500ATTR_OID+'46',
        'crossCertificatePair': X500ATTR_OID+'40',
        'eduPersonOrgDN': EDUPERSON_OID+'3',
        'authorityRevocationList': X500ATTR_OID+'38',
        'displayName': NETSCAPE_LDAP+'241',
        'businessCategory': X500ATTR_OID+'15',
        'serialNumber': X500ATTR_OID+'5',
        'norEduOrgUniqueIdentifier': NOREDUPERSON_OID+'7',
        'st': X500ATTR_OID+'8',
        'carLicense': NETSCAPE_LDAP+'1',
        'presentationAddress': X500ATTR_OID+'29',
        'sn': X500ATTR_OID+'4',
        'domainComponent': UCL_DIR_PILOT+'25',
        'labeledURI': UMICH+'57',
        'uid': UCL_DIR_PILOT+'1'
    }
}  
########NEW FILE########
__FILENAME__ = shibboleth_uri
EDUPERSON_OID = "urn:oid:1.3.6.1.4.1.5923.1.1.1."
X500ATTR = "urn:oid:2.5.4."
NOREDUPERSON_OID = "urn:oid:1.3.6.1.4.1.2428.90.1."
NETSCAPE_LDAP = "urn:oid:2.16.840.1.113730.3.1."
UCL_DIR_PILOT = "urn:oid:0.9.2342.19200300.100.1."
PKCS_9 = "urn:oid:1.2.840.113549.1.9."
UMICH = "urn:oid:1.3.6.1.4.1.250.1.57."

MAP = {
    "identifier": "urn:mace:shibboleth:1.0:attributeNamespace:uri",
    "fro": {
        EDUPERSON_OID+'2': 'eduPersonNickname',
        EDUPERSON_OID+'9': 'eduPersonScopedAffiliation',
        EDUPERSON_OID+'11': 'eduPersonAssurance',
        EDUPERSON_OID+'10': 'eduPersonTargetedID',
        EDUPERSON_OID+'4': 'eduPersonOrgUnitDN',
        NOREDUPERSON_OID+'6': 'norEduOrgAcronym',
        NOREDUPERSON_OID+'7': 'norEduOrgUniqueIdentifier',
        NOREDUPERSON_OID+'4': 'norEduPersonLIN',
        EDUPERSON_OID+'1': 'eduPersonAffiliation',
        NOREDUPERSON_OID+'2': 'norEduOrgUnitUniqueNumber',
        NETSCAPE_LDAP+'40': 'userSMIMECertificate',
        NOREDUPERSON_OID+'1': 'norEduOrgUniqueNumber',
        NETSCAPE_LDAP+'241': 'displayName',
        UCL_DIR_PILOT+'37': 'associatedDomain',
        EDUPERSON_OID+'6': 'eduPersonPrincipalName',
        NOREDUPERSON_OID+'8': 'norEduOrgUnitUniqueIdentifier',
        NOREDUPERSON_OID+'9': 'federationFeideSchemaVersion',
        X500ATTR+'53': 'deltaRevocationList',
        X500ATTR+'52': 'supportedAlgorithms',
        X500ATTR+'51': 'houseIdentifier',
        X500ATTR+'50': 'uniqueMember',
        X500ATTR+'19': 'physicalDeliveryOfficeName',
        X500ATTR+'18': 'postOfficeBox',
        X500ATTR+'17': 'postalCode',
        X500ATTR+'16': 'postalAddress',
        X500ATTR+'15': 'businessCategory',
        X500ATTR+'14': 'searchGuide',
        EDUPERSON_OID+'5': 'eduPersonPrimaryAffiliation',
        X500ATTR+'12': 'title',
        X500ATTR+'11': 'ou',
        X500ATTR+'10': 'o',
        X500ATTR+'37': 'cACertificate',
        X500ATTR+'36': 'userCertificate',
        X500ATTR+'31': 'member',
        X500ATTR+'30': 'supportedApplicationContext',
        X500ATTR+'33': 'roleOccupant',
        X500ATTR+'32': 'owner',
        NETSCAPE_LDAP+'1': 'carLicense',
        PKCS_9+'1': 'email',
        NETSCAPE_LDAP+'3': 'employeeNumber',
        NETSCAPE_LDAP+'2': 'departmentNumber',
        X500ATTR+'39': 'certificateRevocationList',
        X500ATTR+'38': 'authorityRevocationList',
        NETSCAPE_LDAP+'216': 'userPKCS12',
        EDUPERSON_OID+'8': 'eduPersonPrimaryOrgUnitDN',
        X500ATTR+'9': 'street',
        X500ATTR+'8': 'st',
        NETSCAPE_LDAP+'39': 'preferredLanguage',
        EDUPERSON_OID+'7': 'eduPersonEntitlement',
        X500ATTR+'2': 'knowledgeInformation',
        X500ATTR+'7': 'l',
        X500ATTR+'6': 'c',
        X500ATTR+'5': 'serialNumber',
        X500ATTR+'4': 'sn',
        UCL_DIR_PILOT+'60': 'jpegPhoto',
        X500ATTR+'65': 'pseudonym',
        NOREDUPERSON_OID+'5': 'norEduPersonNIN',
        UCL_DIR_PILOT+'3': 'mail',
        UCL_DIR_PILOT+'25': 'dc',
        X500ATTR+'40': 'crossCertificatePair',
        X500ATTR+'42': 'givenName',
        X500ATTR+'43': 'initials',
        X500ATTR+'44': 'generationQualifier',
        X500ATTR+'45': 'x500UniqueIdentifier',
        X500ATTR+'46': 'dnQualifier',
        X500ATTR+'47': 'enhancedSearchGuide',
        X500ATTR+'48': 'protocolInformation',
        X500ATTR+'54': 'dmdName',
        NETSCAPE_LDAP+'4': 'employeeType',
        X500ATTR+'22': 'teletexTerminalIdentifier',
        X500ATTR+'23': 'facsimileTelephoneNumber',
        X500ATTR+'20': 'telephoneNumber',
        X500ATTR+'21': 'telexNumber',
        X500ATTR+'26': 'registeredAddress',
        X500ATTR+'27': 'destinationIndicator',
        X500ATTR+'24': 'x121Address',
        X500ATTR+'25': 'internationaliSDNNumber',
        X500ATTR+'28': 'preferredDeliveryMethod',
        X500ATTR+'29': 'presentationAddress',
        EDUPERSON_OID+'3': 'eduPersonOrgDN',
        NOREDUPERSON_OID+'3': 'norEduPersonBirthDate',
    },
    "to":{
        'roleOccupant': X500ATTR+'33',
        'gn': X500ATTR+'42',
        'norEduPersonNIN': NOREDUPERSON_OID+'5',
        'title': X500ATTR+'12',
        'facsimileTelephoneNumber': X500ATTR+'23',
        'mail': UCL_DIR_PILOT+'3',
        'postOfficeBox': X500ATTR+'18',
        'fax': X500ATTR+'23',
        'telephoneNumber': X500ATTR+'20',
        'norEduPersonBirthDate': NOREDUPERSON_OID+'3',
        'rfc822Mailbox': UCL_DIR_PILOT+'3',
        'dc': UCL_DIR_PILOT+'25',
        'countryName': X500ATTR+'6',
        'emailAddress': PKCS_9+'1',
        'employeeNumber': NETSCAPE_LDAP+'3',
        'organizationName': X500ATTR+'10',
        'eduPersonAssurance': EDUPERSON_OID+'11',
        'norEduOrgAcronym': NOREDUPERSON_OID+'6',
        'registeredAddress': X500ATTR+'26',
        'physicalDeliveryOfficeName': X500ATTR+'19',
        'associatedDomain': UCL_DIR_PILOT+'37',
        'l': X500ATTR+'7',
        'stateOrProvinceName': X500ATTR+'8',
        'federationFeideSchemaVersion': NOREDUPERSON_OID+'9',
        'pkcs9email': PKCS_9+'1',
        'givenName': X500ATTR+'42',
        'x500UniqueIdentifier': X500ATTR+'45',
        'eduPersonNickname': EDUPERSON_OID+'2',
        'houseIdentifier': X500ATTR+'51',
        'street': X500ATTR+'9',
        'supportedAlgorithms': X500ATTR+'52',
        'preferredLanguage': NETSCAPE_LDAP+'39',
        'postalAddress': X500ATTR+'16',
        'email': PKCS_9+'1',
        'norEduOrgUnitUniqueIdentifier': NOREDUPERSON_OID+'8',
        'eduPersonPrimaryOrgUnitDN': EDUPERSON_OID+'8',
        'c': X500ATTR+'6',
        'teletexTerminalIdentifier': X500ATTR+'22',
        'o': X500ATTR+'10',
        'cACertificate': X500ATTR+'37',
        'telexNumber': X500ATTR+'21',
        'ou': X500ATTR+'11',
        'initials': X500ATTR+'43',
        'eduPersonOrgUnitDN': EDUPERSON_OID+'4',
        'deltaRevocationList': X500ATTR+'53',
        'norEduPersonLIN': NOREDUPERSON_OID+'4',
        'supportedApplicationContext': X500ATTR+'30',
        'eduPersonEntitlement': EDUPERSON_OID+'7',
        'generationQualifier': X500ATTR+'44',
        'eduPersonAffiliation': EDUPERSON_OID+'1',
        'eduPersonPrincipalName': EDUPERSON_OID+'6',
        'localityName': X500ATTR+'7',
        'owner': X500ATTR+'32',
        'norEduOrgUnitUniqueNumber': NOREDUPERSON_OID+'2',
        'searchGuide': X500ATTR+'14',
        'certificateRevocationList': X500ATTR+'39',
        'organizationalUnitName': X500ATTR+'11',
        'userCertificate': X500ATTR+'36',
        'preferredDeliveryMethod': X500ATTR+'28',
        'internationaliSDNNumber': X500ATTR+'25',
        'uniqueMember': X500ATTR+'50',
        'departmentNumber': NETSCAPE_LDAP+'2',
        'enhancedSearchGuide': X500ATTR+'47',
        'userPKCS12': NETSCAPE_LDAP+'216',
        'eduPersonTargetedID': EDUPERSON_OID+'10',
        'norEduOrgUniqueNumber': NOREDUPERSON_OID+'1',
        'x121Address': X500ATTR+'24',
        'destinationIndicator': X500ATTR+'27',
        'eduPersonPrimaryAffiliation': EDUPERSON_OID+'5',
        'surname': X500ATTR+'4',
        'jpegPhoto': UCL_DIR_PILOT+'60',
        'eduPersonScopedAffiliation': EDUPERSON_OID+'9',
        'protocolInformation': X500ATTR+'48',
        'knowledgeInformation': X500ATTR+'2',
        'employeeType': NETSCAPE_LDAP+'4',
        'userSMIMECertificate': NETSCAPE_LDAP+'40',
        'member': X500ATTR+'31',
        'streetAddress': X500ATTR+'9',
        'dmdName': X500ATTR+'54',
        'postalCode': X500ATTR+'17',
        'pseudonym': X500ATTR+'65',
        'dnQualifier': X500ATTR+'46',
        'crossCertificatePair': X500ATTR+'40',
        'eduPersonOrgDN': EDUPERSON_OID+'3',
        'authorityRevocationList': X500ATTR+'38',
        'displayName': NETSCAPE_LDAP+'241',
        'businessCategory': X500ATTR+'15',
        'serialNumber': X500ATTR+'5',
        'norEduOrgUniqueIdentifier': NOREDUPERSON_OID+'7',
        'st': X500ATTR+'8',
        'carLicense': NETSCAPE_LDAP+'1',
        'presentationAddress': X500ATTR+'29',
        'sn': X500ATTR+'4',
        'domainComponent': UCL_DIR_PILOT+'25',
    }
}
########NEW FILE########
__FILENAME__ = idp
#!/usr/bin/env python
import importlib
import argparse
import base64
import re
import logging
import time
from hashlib import sha1

from urlparse import parse_qs
from Cookie import SimpleCookie
import os
from saml2.profile import ecp

from saml2 import server
from saml2 import BINDING_HTTP_ARTIFACT
from saml2 import BINDING_URI
from saml2 import BINDING_PAOS
from saml2 import BINDING_SOAP
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import time_util

from saml2.authn_context import AuthnBroker
from saml2.authn_context import PASSWORD
from saml2.authn_context import UNSPECIFIED
from saml2.authn_context import authn_context_class_ref
from saml2.httputil import Response
from saml2.httputil import NotFound
from saml2.httputil import geturl
from saml2.httputil import get_post
from saml2.httputil import Redirect
from saml2.httputil import Unauthorized
from saml2.httputil import BadRequest
from saml2.httputil import ServiceError
from saml2.ident import Unknown
from saml2.metadata import create_metadata_string
from saml2.s_utils import rndstr
from saml2.s_utils import exception_trace
from saml2.s_utils import UnknownPrincipal
from saml2.s_utils import UnsupportedBinding
from saml2.s_utils import PolicyError
from saml2.sigver import verify_redirect_signature
from saml2.sigver import encrypt_cert_from_item

logger = logging.getLogger("saml2.idp")


class Cache(object):
    def __init__(self):
        self.user2uid = {}
        self.uid2user = {}


def _expiration(timeout, tformat="%a, %d-%b-%Y %H:%M:%S GMT"):
    """

    :param timeout:
    :param tformat:
    :return:
    """
    if timeout == "now":
        return time_util.instant(tformat)
    elif timeout == "dawn":
        return time.strftime(tformat, time.gmtime(0))
    else:
        # validity time should match lifetime of assertions
        return time_util.in_a_while(minutes=timeout, format=tformat)


def get_eptid(idp, req_info, session):
    return idp.eptid.get(idp.config.entityid,
                         req_info.sender(), session["permanent_id"],
                         session["authn_auth"])

# -----------------------------------------------------------------------------


def dict2list_of_tuples(d):
    return [(k, v) for k, v in d.items()]

# -----------------------------------------------------------------------------


class Service(object):
    def __init__(self, environ, start_response, user=None):
        self.environ = environ
        logger.debug("ENVIRON: %s" % environ)
        self.start_response = start_response
        self.user = user

    def unpack_redirect(self):
        if "QUERY_STRING" in self.environ:
            _qs = self.environ["QUERY_STRING"]
            return dict([(k, v[0]) for k, v in parse_qs(_qs).items()])
        else:
            return None
    
    def unpack_post(self):
        _dict = parse_qs(get_post(self.environ))
        logger.debug("unpack_post:: %s" % _dict)
        try:
            return dict([(k, v[0]) for k, v in _dict.items()])
        except Exception:
            return None
    
    def unpack_soap(self):
        try:
            query = get_post(self.environ)
            return {"SAMLRequest": query, "RelayState": ""}
        except Exception:
            return None
    
    def unpack_either(self):
        if self.environ["REQUEST_METHOD"] == "GET":
            _dict = self.unpack_redirect()
        elif self.environ["REQUEST_METHOD"] == "POST":
            _dict = self.unpack_post()
        else:
            _dict = None
        logger.debug("_dict: %s" % _dict)
        return _dict

    def operation(self, saml_msg, binding):
        logger.debug("_operation: %s" % saml_msg)
        if not saml_msg or not 'SAMLRequest' in saml_msg:
            resp = BadRequest('Error parsing request or no request')
            return resp(self.environ, self.start_response)
        else:
            try:
                _encrypt_cert = encrypt_cert_from_item(
                    saml_msg["req_info"].message)
                return self.do(saml_msg["SAMLRequest"], binding,
                               saml_msg["RelayState"],
                               encrypt_cert=_encrypt_cert)
            except KeyError:
                # Can live with no relay state
                return self.do(saml_msg["SAMLRequest"], binding)

    def artifact_operation(self, saml_msg):
        if not saml_msg:
            resp = BadRequest("Missing query")
            return resp(self.environ, self.start_response)
        else:
            # exchange artifact for request
            request = IDP.artifact2message(saml_msg["SAMLart"], "spsso")
            try:
                return self.do(request, BINDING_HTTP_ARTIFACT,
                               saml_msg["RelayState"])
            except KeyError:
                return self.do(request, BINDING_HTTP_ARTIFACT)

    def response(self, binding, http_args):
        if binding == BINDING_HTTP_ARTIFACT:
            resp = Redirect()
        else:
            resp = Response(http_args["data"], headers=http_args["headers"])
        return resp(self.environ, self.start_response)

    def do(self, query, binding, relay_state="", encrypt_cert=None):
        pass

    def redirect(self):
        """ Expects a HTTP-redirect request """

        _dict = self.unpack_redirect()
        return self.operation(_dict, BINDING_HTTP_REDIRECT)

    def post(self):
        """ Expects a HTTP-POST request """

        _dict = self.unpack_post()
        return self.operation(_dict, BINDING_HTTP_POST)

    def artifact(self):
        # Can be either by HTTP_Redirect or HTTP_POST
        _dict = self.unpack_either()
        return self.artifact_operation(_dict)

    def soap(self):
        """
        Single log out using HTTP_SOAP binding
        """
        logger.debug("- SOAP -")
        _dict = self.unpack_soap()
        logger.debug("_dict: %s" % _dict)
        return self.operation(_dict, BINDING_SOAP)

    def uri(self):
        _dict = self.unpack_either()
        return self.operation(_dict, BINDING_SOAP)

    def not_authn(self, key, requested_authn_context):
        ruri = geturl(self.environ, query=False)
        return do_authentication(self.environ, self.start_response,
                                 authn_context=requested_authn_context,
                                 key=key, redirect_uri=ruri)


# -----------------------------------------------------------------------------

REPOZE_ID_EQUIVALENT = "uid"
FORM_SPEC = """<form name="myform" method="post" action="%s">
   <input type="hidden" name="SAMLResponse" value="%s" />
   <input type="hidden" name="RelayState" value="%s" />
</form>"""

# -----------------------------------------------------------------------------
# === Single log in ====
# -----------------------------------------------------------------------------


class AuthenticationNeeded(Exception):
    def __init__(self, authn_context=None, *args, **kwargs):
        Exception.__init__(*args, **kwargs)
        self.authn_context = authn_context


class SSO(Service):
    def __init__(self, environ, start_response, user=None):
        Service.__init__(self, environ, start_response, user)
        self.binding = ""
        self.response_bindings = None
        self.resp_args = {}
        self.binding_out = None
        self.destination = None
        self.req_info = None
        self.op_type = ""

    def verify_request(self, query, binding):
        """
        :param query: The SAML query, transport encoded
        :param binding: Which binding the query came in over
        """
        resp_args = {}
        if not query:
            logger.info("Missing QUERY")
            resp = Unauthorized('Unknown user')
            return resp_args, resp(self.environ, self.start_response)

        if not self.req_info:
            self.req_info = IDP.parse_authn_request(query, binding)

        logger.info("parsed OK")
        _authn_req = self.req_info.message
        logger.debug("%s" % _authn_req)

        try:
            self.binding_out, self.destination = IDP.pick_binding(
                "assertion_consumer_service",
                bindings=self.response_bindings,
                entity_id=_authn_req.issuer.text)
        except Exception as err:
            logger.error("Couldn't find receiver endpoint: %s" % err)
            raise

        logger.debug("Binding: %s, destination: %s" % (self.binding_out,
                                                       self.destination))

        resp_args = {}
        try:
            resp_args = IDP.response_args(_authn_req)
            _resp = None
        except UnknownPrincipal as excp:
            _resp = IDP.create_error_response(_authn_req.id,
                                              self.destination, excp)
        except UnsupportedBinding as excp:
            _resp = IDP.create_error_response(_authn_req.id,
                                              self.destination, excp)

        return resp_args, _resp

    def do(self, query, binding_in, relay_state="", encrypt_cert=None):
        """

        :param query: The request
        :param binding_in: Which binding was used when receiving the query
        :param relay_state: The relay state provided by the SP
        :param encrypt_cert: Cert to use for encryption
        :return: A response
        """
        try:
            resp_args, _resp = self.verify_request(query, binding_in)
        except UnknownPrincipal as excp:
            logger.error("UnknownPrincipal: %s" % (excp,))
            resp = ServiceError("UnknownPrincipal: %s" % (excp,))
            return resp(self.environ, self.start_response)
        except UnsupportedBinding as excp:
            logger.error("UnsupportedBinding: %s" % (excp,))
            resp = ServiceError("UnsupportedBinding: %s" % (excp,))
            return resp(self.environ, self.start_response)

        if not _resp:
            identity = USERS[self.user].copy()
            #identity["eduPersonTargetedID"] = get_eptid(IDP, query, session)
            logger.info("Identity: %s" % (identity,))

            if REPOZE_ID_EQUIVALENT:
                identity[REPOZE_ID_EQUIVALENT] = self.user
            try:
                try:
                    metod = self.environ["idp.authn"]
                except KeyError:
                    pass
                else:
                    resp_args["authn"] = metod

                _resp = IDP.create_authn_response(
                    identity, userid=self.user,
                    encrypt_cert=encrypt_cert,
                    **resp_args)
            except Exception as excp:
                logging.error(exception_trace(excp))
                resp = ServiceError("Exception: %s" % (excp,))
                return resp(self.environ, self.start_response)

        logger.info("AuthNResponse: %s" % _resp)
        if self.op_type == "ecp":
            kwargs = {"soap_headers": [
                ecp.Response(
                    assertion_consumer_service_url=self.destination)]}
        else:
            kwargs = {}

        http_args = IDP.apply_binding(self.binding_out,
                                      "%s" % _resp, self.destination,
                                      relay_state, response=True, **kwargs)

        logger.debug("HTTPargs: %s" % http_args)
        return self.response(self.binding_out, http_args)

    def _store_request(self, saml_msg):
        logger.debug("_store_request: %s" % saml_msg)
        key = sha1(saml_msg["SAMLRequest"]).hexdigest()
        # store the AuthnRequest
        IDP.ticket[key] = saml_msg
        return key

    def redirect(self):
        """ This is the HTTP-redirect endpoint """

        logger.info("--- In SSO Redirect ---")
        saml_msg = self.unpack_redirect()

        try:
            _key = saml_msg["key"]
            saml_msg = IDP.ticket[_key]
            self.req_info = saml_msg["req_info"]
            del IDP.ticket[_key]
        except KeyError:
            try:
                self.req_info = IDP.parse_authn_request(saml_msg["SAMLRequest"],
                                                        BINDING_HTTP_REDIRECT)
            except KeyError:
                resp = BadRequest("Message signature verification failure")
                return resp(self.environ, self.start_response)

            _req = self.req_info.message

            if "SigAlg" in saml_msg and "Signature" in saml_msg:  # Signed request
                issuer = _req.issuer.text
                _certs = IDP.metadata.certs(issuer, "any", "signing")
                verified_ok = False
                for cert in _certs:
                    if verify_redirect_signature(saml_msg, cert):
                        verified_ok = True
                        break
                if not verified_ok:
                    resp = BadRequest("Message signature verification failure")
                    return resp(self.environ, self.start_response)

            if self.user:
                if _req.force_authn:
                    saml_msg["req_info"] = self.req_info
                    key = self._store_request(saml_msg)
                    return self.not_authn(key, _req.requested_authn_context)
                else:
                    return self.operation(saml_msg, BINDING_HTTP_REDIRECT)
            else:
                saml_msg["req_info"] = self.req_info
                key = self._store_request(saml_msg)
                return self.not_authn(key, _req.requested_authn_context)
        else:
            return self.operation(saml_msg, BINDING_HTTP_REDIRECT)

    def post(self):
        """
        The HTTP-Post endpoint
        """
        logger.info("--- In SSO POST ---")
        saml_msg = self.unpack_either()
        self.req_info = IDP.parse_authn_request(
            saml_msg["SAMLRequest"], BINDING_HTTP_POST)
        _req = self.req_info.message
        if self.user:
            if _req.force_authn:
                saml_msg["req_info"] = self.req_info
                key = self._store_request(saml_msg)
                return self.not_authn(key, _req.requested_authn_context)
            else:
                return self.operation(saml_msg, BINDING_HTTP_POST)
        else:
            saml_msg["req_info"] = self.req_info
            key = self._store_request(saml_msg)
            return self.not_authn(key, _req.requested_authn_context)

    # def artifact(self):
    #     # Can be either by HTTP_Redirect or HTTP_POST
    #     _req = self._store_request(self.unpack_either())
    #     if isinstance(_req, basestring):
    #         return self.not_authn(_req)
    #     return self.artifact_operation(_req)

    def ecp(self):
        # The ECP interface
        logger.info("--- ECP SSO ---")
        resp = None

        try:
            authz_info = self.environ["HTTP_AUTHORIZATION"]
            if authz_info.startswith("Basic "):
                _info = base64.b64decode(authz_info[6:])
                logger.debug("Authz_info: %s" % _info)
                try:
                    (user, passwd) = _info.split(":")
                    if PASSWD[user] != passwd:
                        resp = Unauthorized()
                    self.user = user
                    self.environ[
                        "idp.authn"] = AUTHN_BROKER.get_authn_by_accr(
                            PASSWORD)
                except ValueError:
                    resp = Unauthorized()
            else:
                resp = Unauthorized()
        except KeyError:
            resp = Unauthorized()

        if resp:
            return resp(self.environ, self.start_response)

        _dict = self.unpack_soap()
        self.response_bindings = [BINDING_PAOS]
        # Basic auth ?!
        self.op_type = "ecp"
        return self.operation(_dict, BINDING_SOAP)

# -----------------------------------------------------------------------------
# === Authentication ====
# -----------------------------------------------------------------------------


def do_authentication(environ, start_response, authn_context, key,
                      redirect_uri):
    """
    Display the login form
    """
    logger.debug("Do authentication")
    auth_info = AUTHN_BROKER.pick(authn_context)

    if len(auth_info):
        method, reference = auth_info[0]
        logger.debug("Authn chosen: %s (ref=%s)" % (method, reference))
        return method(environ, start_response, reference, key, redirect_uri)
    else:
        resp = Unauthorized("No usable authentication method")
        return resp(environ, start_response)


# -----------------------------------------------------------------------------

PASSWD = {
          "daev0001": "qwerty",
          "haho0032": "qwerty",
          "roland": "dianakra",
          "babs": "howes",
          "upper": "crust"}


def username_password_authn(environ, start_response, reference, key,
                            redirect_uri):
    """
    Display the login form
    """
    logger.info("The login page")
    headers = []

    resp = Response(mako_template="login.mako", template_lookup=LOOKUP,
                    headers=headers)

    argv = {
        "action": "/verify",
        "login": "",
        "password": "",
        "key": key,
        "authn_reference": reference,
        "redirect_uri": redirect_uri
    }
    logger.info("do_authentication argv: %s" % argv)
    return resp(environ, start_response, **argv)


def verify_username_and_password(dic):
    global PASSWD
    # verify username and password
    if PASSWD[dic["login"][0]] == dic["password"][0]:
        return True, dic["login"][0]
    else:
        return False, ""


def do_verify(environ, start_response, _):
    query = parse_qs(get_post(environ))

    logger.debug("do_verify: %s" % query)

    try:
        _ok, user = verify_username_and_password(query)
    except KeyError:
        _ok = False
        user = None

    if not _ok:
        resp = Unauthorized("Unknown user or wrong password")
    else:
        uid = rndstr(24)
        IDP.cache.uid2user[uid] = user
        IDP.cache.user2uid[user] = uid
        logger.debug("Register %s under '%s'" % (user, uid))

        kaka = set_cookie("idpauthn", "/", uid, query["authn_reference"][0])

        lox = "%s?id=%s&key=%s" % (query["redirect_uri"][0], uid,
                                   query["key"][0])
        logger.debug("Redirect => %s" % lox)
        resp = Redirect(lox, headers=[kaka], content="text/html")

    return resp(environ, start_response)


def not_found(environ, start_response):
    """Called if no URL matches."""
    resp = NotFound()
    return resp(environ, start_response)


# -----------------------------------------------------------------------------
# === Single log out ===
# -----------------------------------------------------------------------------

#def _subject_sp_info(req_info):
#    # look for the subject
#    subject = req_info.subject_id()
#    subject = subject.text.strip()
#    sp_entity_id = req_info.message.issuer.text.strip()
#    return subject, sp_entity_id

class SLO(Service):
    def do(self, request, binding, relay_state="", encrypt_cert=None):
        logger.info("--- Single Log Out Service ---")
        try:
            _, body = request.split("\n")
            logger.debug("req: '%s'" % body)
            req_info = IDP.parse_logout_request(body, binding)
        except Exception as exc:
            logger.error("Bad request: %s" % exc)
            resp = BadRequest("%s" % exc)
            return resp(self.environ, self.start_response)
    
        msg = req_info.message
        if msg.name_id:
            lid = IDP.ident.find_local_id(msg.name_id)
            logger.info("local identifier: %s" % lid)
            if lid in IDP.cache.user2uid:
                uid = IDP.cache.user2uid[lid]
                if uid in IDP.cache.uid2user:
                    del IDP.cache.uid2user[uid]
                del IDP.cache.user2uid[lid]
            # remove the authentication
            try:
                IDP.session_db.remove_authn_statements(msg.name_id)
            except KeyError as exc:
                logger.error("ServiceError: %s" % exc)
                resp = ServiceError("%s" % exc)
                return resp(self.environ, self.start_response)
    
        resp = IDP.create_logout_response(msg, [binding])
    
        try:
            hinfo = IDP.apply_binding(binding, "%s" % resp, "", relay_state)
        except Exception as exc:
            logger.error("ServiceError: %s" % exc)
            resp = ServiceError("%s" % exc)
            return resp(self.environ, self.start_response)
    
        #_tlh = dict2list_of_tuples(hinfo["headers"])
        delco = delete_cookie(self.environ, "idpauthn")
        if delco:
            hinfo["headers"].append(delco)
        logger.info("Header: %s" % (hinfo["headers"],))
        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)
    
# ----------------------------------------------------------------------------
# Manage Name ID service
# ----------------------------------------------------------------------------


class NMI(Service):
    
    def do(self, query, binding, relay_state="", encrypt_cert=None):
        logger.info("--- Manage Name ID Service ---")
        req = IDP.parse_manage_name_id_request(query, binding)
        request = req.message
    
        # Do the necessary stuff
        name_id = IDP.ident.handle_manage_name_id_request(
            request.name_id, request.new_id, request.new_encrypted_id,
            request.terminate)
    
        logger.debug("New NameID: %s" % name_id)
    
        _resp = IDP.create_manage_name_id_response(request)
    
        # It's using SOAP binding
        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % _resp, "",
                                  relay_state, response=True)
    
        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)
    
# ----------------------------------------------------------------------------
# === Assertion ID request ===
# ----------------------------------------------------------------------------


# Only URI binding
class AIDR(Service):
    def do(self, aid, binding, relay_state="", encrypt_cert=None):
        logger.info("--- Assertion ID Service ---")

        try:
            assertion = IDP.create_assertion_id_request_response(aid)
        except Unknown:
            resp = NotFound(aid)
            return resp(self.environ, self.start_response)
    
        hinfo = IDP.apply_binding(BINDING_URI, "%s" % assertion, response=True)
    
        logger.debug("HINFO: %s" % hinfo)
        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)

    def operation(self, _dict, binding, **kwargs):
        logger.debug("_operation: %s" % _dict)
        if not _dict or "ID" not in _dict:
            resp = BadRequest('Error parsing request or no request')
            return resp(self.environ, self.start_response)

        return self.do(_dict["ID"], binding, **kwargs)


# ----------------------------------------------------------------------------
# === Artifact resolve service ===
# ----------------------------------------------------------------------------

class ARS(Service):
    def do(self, request, binding, relay_state="", encrypt_cert=None):
        _req = IDP.parse_artifact_resolve(request, binding)

        msg = IDP.create_artifact_response(_req, _req.artifact.text)

        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % msg, "", "",
                                  response=True)

        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)

# ----------------------------------------------------------------------------
# === Authn query service ===
# ----------------------------------------------------------------------------


# Only SOAP binding
class AQS(Service):
    def do(self, request, binding, relay_state="", encrypt_cert=None):
        logger.info("--- Authn Query Service ---")
        _req = IDP.parse_authn_query(request, binding)
        _query = _req.message

        msg = IDP.create_authn_query_response(_query.subject,
                                              _query.requested_authn_context,
                                              _query.session_index)

        logger.debug("response: %s" % msg)
        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % msg, "", "",
                                  response=True)

        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)


# ----------------------------------------------------------------------------
# === Attribute query service ===
# ----------------------------------------------------------------------------


# Only SOAP binding
class ATTR(Service):
    def do(self, request, binding, relay_state="", encrypt_cert=None):
        logger.info("--- Attribute Query Service ---")

        _req = IDP.parse_attribute_query(request, binding)
        _query = _req.message

        name_id = _query.subject.name_id
        uid = name_id.text
        logger.debug("Local uid: %s" % uid)
        identity = EXTRA[uid]

        # Comes in over SOAP so only need to construct the response
        args = IDP.response_args(_query, [BINDING_SOAP])
        msg = IDP.create_attribute_response(identity,
                                            name_id=name_id, **args)

        logger.debug("response: %s" % msg)
        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % msg, "", "",
                                  response=True)

        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)

# ----------------------------------------------------------------------------
# Name ID Mapping service
# When an entity that shares an identifier for a principal with an identity
# provider wishes to obtain a name identifier for the same principal in a
# particular format or federation namespace, it can send a request to
# the identity provider using this protocol.
# ----------------------------------------------------------------------------


class NIM(Service):
    def do(self, query, binding, relay_state="", encrypt_cert=None):
        req = IDP.parse_name_id_mapping_request(query, binding)
        request = req.message
        # Do the necessary stuff
        try:
            name_id = IDP.ident.handle_name_id_mapping_request(
                request.name_id, request.name_id_policy)
        except Unknown:
            resp = BadRequest("Unknown entity")
            return resp(self.environ, self.start_response)
        except PolicyError:
            resp = BadRequest("Unknown entity")
            return resp(self.environ, self.start_response)
    
        info = IDP.response_args(request)
        _resp = IDP.create_name_id_mapping_response(name_id, **info)
    
        # Only SOAP
        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % _resp, "", "",
                                  response=True)
    
        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)
    

# ----------------------------------------------------------------------------
# Cookie handling
# ----------------------------------------------------------------------------
def info_from_cookie(kaka):
    logger.debug("KAKA: %s" % kaka)
    if kaka:
        cookie_obj = SimpleCookie(kaka)
        morsel = cookie_obj.get("idpauthn", None)
        if morsel:
            try:
                key, ref = base64.b64decode(morsel.value).split(":")
                return IDP.cache.uid2user[key], ref
            except KeyError:
                return None, None
        else:
            logger.debug("No idpauthn cookie")
    return None, None


def delete_cookie(environ, name):
    kaka = environ.get("HTTP_COOKIE", '')
    logger.debug("delete KAKA: %s" % kaka)
    if kaka:
        cookie_obj = SimpleCookie(kaka)
        morsel = cookie_obj.get(name, None)
        cookie = SimpleCookie()
        cookie[name] = ""
        cookie[name]['path'] = "/"
        logger.debug("Expire: %s" % morsel)
        cookie[name]["expires"] = _expiration("dawn")
        return tuple(cookie.output().split(": ", 1))
    return None


def set_cookie(name, _, *args):
    cookie = SimpleCookie()
    cookie[name] = base64.b64encode(":".join(args))
    cookie[name]['path'] = "/"
    cookie[name]["expires"] = _expiration(5)  # 5 minutes from now
    logger.debug("Cookie expires: %s" % cookie[name]["expires"])
    return tuple(cookie.output().split(": ", 1))

# ----------------------------------------------------------------------------

# map urls to functions
AUTHN_URLS = [
    # sso
    (r'sso/post$', (SSO, "post")),
    (r'sso/post/(.*)$', (SSO, "post")),
    (r'sso/redirect$', (SSO, "redirect")),
    (r'sso/redirect/(.*)$', (SSO, "redirect")),
    (r'sso/art$', (SSO, "artifact")),
    (r'sso/art/(.*)$', (SSO, "artifact")),
    # slo
    (r'slo/redirect$', (SLO, "redirect")),
    (r'slo/redirect/(.*)$', (SLO, "redirect")),
    (r'slo/post$', (SLO, "post")),
    (r'slo/post/(.*)$', (SLO, "post")),
    (r'slo/soap$', (SLO, "soap")),
    (r'slo/soap/(.*)$', (SLO, "soap")),
    #
    (r'airs$', (AIDR, "uri")),
    (r'ars$', (ARS, "soap")),
    # mni
    (r'mni/post$', (NMI, "post")),
    (r'mni/post/(.*)$', (NMI, "post")),
    (r'mni/redirect$', (NMI, "redirect")),
    (r'mni/redirect/(.*)$', (NMI, "redirect")),
    (r'mni/art$', (NMI, "artifact")),
    (r'mni/art/(.*)$', (NMI, "artifact")),
    (r'mni/soap$', (NMI, "soap")),
    (r'mni/soap/(.*)$', (NMI, "soap")),
    # nim
    (r'nim$', (NIM, "soap")),
    (r'nim/(.*)$', (NIM, "soap")),
    #
    (r'aqs$', (AQS, "soap")),
    (r'attr$', (ATTR, "soap"))
]

NON_AUTHN_URLS = [
    #(r'login?(.*)$', do_authentication),
    (r'verify?(.*)$', do_verify),
    (r'sso/ecp$', (SSO, "ecp")),
]

# ----------------------------------------------------------------------------


def metadata(environ, start_response):
    try:
        path = args.path
        if path is None or len(path) == 0:
            path = os.path.dirname(os.path.abspath( __file__ ))
        if path[-1] != "/":
            path += "/"
        metadata = create_metadata_string(path+args.config, IDP.config,
                                          args.valid, args.cert, args.keyfile,
                                          args.id, args.name, args.sign)
        start_response('200 OK', [('Content-Type', "text/xml")])
        return metadata
    except Exception as ex:
        logger.error("An error occured while creating metadata:" + ex.message)
        return not_found(environ, start_response)

def staticfile(environ, start_response):
    try:
        path = args.path
        if path is None or len(path) == 0:
            path = os.path.dirname(os.path.abspath(__file__))
        if path[-1] != "/":
            path += "/"
        path += environ.get('PATH_INFO', '').lstrip('/')
        start_response('200 OK', [('Content-Type', "text/xml")])
        return open(path, 'r').read()
    except Exception as ex:
        logger.error("An error occured while creating metadata:" + ex.message)
        return not_found(environ, start_response)

def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above and store the regular expression
    captures in the WSGI environment as  `myapp.url_args` so that
    the functions from above can access the url placeholders.

    If nothing matches, call the `not_found` function.
    
    :param environ: The HTTP application environment
    :param start_response: The application to run when the handling of the 
        request is done
    :return: The response as a list of lines
    """

    path = environ.get('PATH_INFO', '').lstrip('/')

    if path == "metadata":
        return metadata(environ, start_response)

    kaka = environ.get("HTTP_COOKIE", None)
    logger.info("<application> PATH: %s" % path)

    if kaka:
        logger.info("= KAKA =")
        user, authn_ref = info_from_cookie(kaka)
        if authn_ref:
            environ["idp.authn"] = AUTHN_BROKER[authn_ref]
    else:
        try:
            query = parse_qs(environ["QUERY_STRING"])
            logger.debug("QUERY: %s" % query)
            user = IDP.cache.uid2user[query["id"][0]]
        except KeyError:
            user = None


    url_patterns = AUTHN_URLS
    if not user:
        logger.info("-- No USER --")
        # insert NON_AUTHN_URLS first in case there is no user
        url_patterns = NON_AUTHN_URLS + url_patterns

    for regex, callback in url_patterns:
        match = re.search(regex, path)
        if match is not None:
            try:
                environ['myapp.url_args'] = match.groups()[0]
            except IndexError:
                environ['myapp.url_args'] = path

            logger.debug("Callback: %s" % (callback,))
            if isinstance(callback, tuple):
                cls = callback[0](environ, start_response, user)
                func = getattr(cls, callback[1])
                return func()
            return callback(environ, start_response, user)

    if re.search(r'static/.*', path) is not None:
        return staticfile(environ, start_response)
    return not_found(environ, start_response)

# ----------------------------------------------------------------------------

# allow uwsgi or gunicorn mount
# by moving some initialization out of __name__ == '__main__' section.
# uwsgi -s 0.0.0.0:8088 --protocol http --callable application --module idp

args = type('Config', (object,), { })
args.config = 'idp_conf'
args.mako_root = './'
args.path = None

import socket
from idp_user import USERS
from idp_user import EXTRA
from mako.lookup import TemplateLookup

AUTHN_BROKER = AuthnBroker()
AUTHN_BROKER.add(authn_context_class_ref(PASSWORD),
                 username_password_authn, 10,
                 "http://%s" % socket.gethostname())
AUTHN_BROKER.add(authn_context_class_ref(UNSPECIFIED),
                 "", 0, "http://%s" % socket.gethostname())
CONFIG = importlib.import_module(args.config)
IDP = server.Server(args.config, cache=Cache())
IDP.ticket = {}

# ----------------------------------------------------------------------------

if __name__ == '__main__':
    from wsgiref.simple_server import make_server

    parser = argparse.ArgumentParser()
    parser.add_argument('-p', dest='path', help='Path to configuration file.')
    parser.add_argument('-v', dest='valid',
                        help="How long, in days, the metadata is valid from the time of creation")
    parser.add_argument('-c', dest='cert', help='certificate')
    parser.add_argument('-i', dest='id',
                        help="The ID of the entities descriptor")
    parser.add_argument('-k', dest='keyfile',
                        help="A file with a key to sign the metadata with")
    parser.add_argument('-n', dest='name')
    parser.add_argument('-s', dest='sign', action='store_true',
                        help="sign the metadata")
    parser.add_argument('-m', dest='mako_root', default="./")
    parser.add_argument(dest="config")
    args = parser.parse_args()

    _rot = args.mako_root
    LOOKUP = TemplateLookup(directories=[_rot + 'templates', _rot + 'htdocs'],
                            module_directory=_rot + 'modules',
                            input_encoding='utf-8', output_encoding='utf-8')

    HOST = CONFIG.HOST
    PORT = CONFIG.PORT

    SRV = make_server(HOST, PORT, application)
    print "IdP listening on %s:%s" % (HOST, PORT)
    SRV.serve_forever()
else:
    _rot = args.mako_root
    LOOKUP = TemplateLookup(directories=[_rot + 'templates', _rot + 'htdocs'],
                            module_directory=_rot + 'modules',
                            input_encoding='utf-8', output_encoding='utf-8')

########NEW FILE########
__FILENAME__ = idp_user
#from dirg_util.dict import LDAPDict
#ldap_settings = {
#    "ldapuri": "ldaps://ldap.test.umu.se",
#    "base": "dc=umu, dc=se",
#    "filter_pattern": "(uid=%s)",
#    "user": "",
#    "passwd": "",
#    "attr": [
#        "eduPersonScopedAffiliation",
#        "eduPersonAffiliation",
#        "eduPersonPrincipalName",
#        "givenName",
#        "sn",
#        "mail",
#        "uid",
#        "o",
#        "c",
#        "labeledURI",
#        "ou",
#        "displayName",
#        "norEduPersonLIN"
#    ],
#    "keymap": {
#        "mail": "email",
#        "labeledURI": "labeledURL",
#    },
#    "static_values": {
#        "eduPersonTargetedID": "one!for!all",
#    },
#    "exact_match": True,
#    "firstonly_len1": True,
#    "timeout": 15,
#}
#Uncomment to use a LDAP directory instead.
#USERS = LDAPDict(**ldap_settings)

USERS = {
    "haho0032": {
        "sn": "Hoerberg",
        "givenName": "Hasse",
        "eduPersonAffiliation": "student",
        "eduPersonScopedAffiliation": "student@example.com",
        "eduPersonPrincipalName": "haho@example.com",
        "uid": "haho0032",
        "eduPersonTargetedID": "one!for!all",
        "c": "SE",
        "o": "Example Co.",
        "ou": "IT",
        "initials": "P",
        "schacHomeOrganization": "example.com",
        "email": "hans@example.com",
        "displayName": "Hans Hoerberg",
        "labeledURL": "http://www.example.com/haho My homepage",
        "norEduPersonNIN": "SE199012315555"
    },
    "roland": {
        "sn": "Hedberg",
        "givenName": "Roland",
        "eduPersonScopedAffiliation": "staff@example.com",
        "eduPersonPrincipalName": "rohe@example.com",
        "uid": "rohe",
        "eduPersonTargetedID": "one!for!all",
        "c": "SE",
        "o": "Example Co.",
        "ou": "IT",
        "initials": "P",
        #"schacHomeOrganization": "example.com",
        "email": "roland@example.com",
        "displayName": "P. Roland Hedberg",
        "labeledURL": "http://www.example.com/rohe My homepage",
        "norEduPersonNIN": "SE197001012222"
    },
    "babs": {
        "surname": "Babs",
        "givenName": "Ozzie",
        "eduPersonAffiliation": "affiliate"
    },
    "upper": {
        "surname": "Jeter",
        "givenName": "Derek",
        "eduPersonAffiliation": "affiliate"
    },
}

EXTRA = {
    "roland": {
        "eduPersonEntitlement": "urn:mace:swamid.se:foo:bar",
        "schacGender": "male",
        "schacUserPresenceID": "skype:pepe.perez"
    }
}
########NEW FILE########
__FILENAME__ = idp
#!/usr/bin/env python
import argparse
import base64

import re
import logging
import time
from hashlib import sha1

from urlparse import parse_qs
from Cookie import SimpleCookie
import os

from saml2 import server
from saml2 import BINDING_HTTP_ARTIFACT
from saml2 import BINDING_URI
from saml2 import BINDING_PAOS
from saml2 import BINDING_SOAP
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import time_util

from saml2.authn_context import AuthnBroker
from saml2.authn_context import PASSWORD
from saml2.authn_context import UNSPECIFIED
from saml2.authn_context import authn_context_class_ref
from saml2.httputil import Response
from saml2.httputil import NotFound
from saml2.httputil import geturl
from saml2.httputil import get_post
from saml2.httputil import Redirect
from saml2.httputil import Unauthorized
from saml2.httputil import BadRequest
from saml2.httputil import ServiceError
from saml2.ident import Unknown
from saml2.metadata import create_metadata_string
from saml2.s_utils import rndstr, exception_trace
from saml2.s_utils import UnknownPrincipal
from saml2.s_utils import UnsupportedBinding
from saml2.s_utils import PolicyError
from saml2.sigver import verify_redirect_signature

logger = logging.getLogger("saml2.idp")


class Cache(object):
    def __init__(self):
        self.user2uid = {}
        self.uid2user = {}


def _expiration(timeout, tformat="%a, %d-%b-%Y %H:%M:%S GMT"):
    """

    :param timeout:
    :param tformat:
    :return:
    """
    if timeout == "now":
        return time_util.instant(tformat)
    elif timeout == "dawn":
        return time.strftime(tformat, time.gmtime(0))
    else:
        # validity time should match lifetime of assertions
        return time_util.in_a_while(minutes=timeout, format=tformat)


def get_eptid(idp, req_info, session):
    return idp.eptid.get(idp.config.entityid,
                         req_info.sender(), session["permanent_id"],
                         session["authn_auth"])

# -----------------------------------------------------------------------------


def dict2list_of_tuples(d):
    return [(k, v) for k, v in d.items()]

# -----------------------------------------------------------------------------


class Service(object):
    def __init__(self, environ, start_response, user=None):
        self.environ = environ
        logger.debug("ENVIRON: %s" % environ)
        self.start_response = start_response
        self.user = user

    def unpack_redirect(self):
        if "QUERY_STRING" in self.environ:
            _qs = self.environ["QUERY_STRING"]
            return dict([(k, v[0]) for k, v in parse_qs(_qs).items()])
        else:
            return None
    
    def unpack_post(self):
        _dict = parse_qs(get_post(self.environ))
        logger.debug("unpack_post:: %s" % _dict)
        try:
            return dict([(k, v[0]) for k, v in _dict.items()])
        except Exception:
            return None
    
    def unpack_soap(self):
        try:
            query = get_post(self.environ)
            return {"SAMLRequest": query, "RelayState": ""}
        except Exception:
            return None
    
    def unpack_either(self):
        if self.environ["REQUEST_METHOD"] == "GET":
            _dict = self.unpack_redirect()
        elif self.environ["REQUEST_METHOD"] == "POST":
            _dict = self.unpack_post()
        else:
            _dict = None
        logger.debug("_dict: %s" % _dict)
        return _dict

    def operation(self, _dict, binding):
        logger.debug("_operation: %s" % _dict)
        if not _dict or not 'SAMLRequest' in _dict:
            resp = BadRequest('Error parsing request or no request')
            return resp(self.environ, self.start_response)
        else:
            try:
                return self.do(_dict["SAMLRequest"], binding,
                               _dict["RelayState"])
            except KeyError:
                # Can live with no relay state
                return self.do(_dict["SAMLRequest"], binding)

    def artifact_operation(self, _dict):
        if not _dict:
            resp = BadRequest("Missing query")
            return resp(self.environ, self.start_response)
        else:
            # exchange artifact for request
            request = IDP.artifact2message(_dict["SAMLart"], "spsso")
            try:
                return self.do(request, BINDING_HTTP_ARTIFACT,
                               _dict["RelayState"])
            except KeyError:
                return self.do(request, BINDING_HTTP_ARTIFACT)

    def response(self, binding, http_args):
        if binding == BINDING_HTTP_ARTIFACT:
            resp = Redirect()
        else:
            resp = Response(http_args["data"], headers=http_args["headers"])
        return resp(self.environ, self.start_response)

    def do(self, query, binding, relay_state=""):
        pass

    def redirect(self):
        """ Expects a HTTP-redirect request """

        _dict = self.unpack_redirect()
        return self.operation(_dict, BINDING_HTTP_REDIRECT)

    def post(self):
        """ Expects a HTTP-POST request """

        _dict = self.unpack_post()
        return self.operation(_dict, BINDING_HTTP_POST)

    def artifact(self):
        # Can be either by HTTP_Redirect or HTTP_POST
        _dict = self.unpack_either()
        return self.artifact_operation(_dict)

    def soap(self):
        """
        Single log out using HTTP_SOAP binding
        """
        logger.debug("- SOAP -")
        _dict = self.unpack_soap()
        logger.debug("_dict: %s" % _dict)
        return self.operation(_dict, BINDING_SOAP)

    def uri(self):
        _dict = self.unpack_either()
        return self.operation(_dict, BINDING_SOAP)

    # def not_authn(self, key):
    #     """
    #
    #
    #     :return:
    #     """
    #     loc = "http://%s/login" % (self.environ["HTTP_HOST"])
    #     loc += "?%s" % urllib.urlencode({"came_from": self.environ[
    #         "PATH_INFO"], "key": key})
    #     headers = [('Content-Type', 'text/plain')]
    #
    #     logger.debug("location: %s" % loc)
    #     logger.debug("headers: %s" % headers)
    #
    #     resp = Redirect(loc, headers=headers)
    #
    #     return resp(self.environ, self.start_response)

    def not_authn(self, key, requested_authn_context):
        ruri = geturl(self.environ, query=False)
        return do_authentication(self.environ, self.start_response,
                                 authn_context=requested_authn_context,
                                 key=key, redirect_uri=ruri)


# -----------------------------------------------------------------------------

REPOZE_ID_EQUIVALENT = "uid"
FORM_SPEC = """<form name="myform" method="post" action="%s">
   <input type="hidden" name="SAMLResponse" value="%s" />
   <input type="hidden" name="RelayState" value="%s" />
</form>"""

# -----------------------------------------------------------------------------
# === Single log in ====
# -----------------------------------------------------------------------------


class AuthenticationNeeded(Exception):
    def __init__(self, authn_context=None, *args, **kwargs):
        Exception.__init__(*args, **kwargs)
        self.authn_context = authn_context


class SSO(Service):
    def __init__(self, environ, start_response, user=None):
        Service.__init__(self, environ, start_response, user)
        self.binding = ""
        self.response_bindings = None
        self.resp_args = {}
        self.binding_out = None
        self.destination = None
        self.req_info = None

    def verify_request(self, query, binding):
        """
        :param query: The SAML query, transport encoded
        :param binding: Which binding the query came in over
        """
        resp_args = {}
        if not query:
            logger.info("Missing QUERY")
            resp = Unauthorized('Unknown user')
            return resp_args, resp(self.environ, self.start_response)

        if not self.req_info:
            self.req_info = IDP.parse_authn_request(query, binding)

        logger.info("parsed OK")
        _authn_req = self.req_info.message
        logger.debug("%s" % _authn_req)

        self.binding_out, self.destination = IDP.pick_binding(
            "assertion_consumer_service",
            bindings=self.response_bindings,
            entity_id=_authn_req.issuer.text)

        logger.debug("Binding: %s, destination: %s" % (self.binding_out,
                                                       self.destination))

        resp_args = {}
        try:
            resp_args = IDP.response_args(_authn_req)
            _resp = None
        except UnknownPrincipal, excp:
            _resp = IDP.create_error_response(_authn_req.id,
                                              self.destination, excp)
        except UnsupportedBinding, excp:
            _resp = IDP.create_error_response(_authn_req.id,
                                              self.destination, excp)

        return resp_args, _resp

    def do(self, query, binding_in, relay_state=""):
        try:
            resp_args, _resp = self.verify_request(query, binding_in)
        except UnknownPrincipal, excp:
            logger.error("UnknownPrincipal: %s" % (excp,))
            resp = ServiceError("UnknownPrincipal: %s" % (excp,))
            return resp(self.environ, self.start_response)
        except UnsupportedBinding, excp:
            logger.error("UnsupportedBinding: %s" % (excp,))
            resp = ServiceError("UnsupportedBinding: %s" % (excp,))
            return resp(self.environ, self.start_response)

        if not _resp:
            identity = USERS[self.user].copy()
            #identity["eduPersonTargetedID"] = get_eptid(IDP, query, session)
            logger.info("Identity: %s" % (identity,))

            if REPOZE_ID_EQUIVALENT:
                identity[REPOZE_ID_EQUIVALENT] = self.user
            try:
                sign_assertion = IDP.config.getattr("sign_assertion", "idp")
                if sign_assertion is None:
                    sign_assertion = False
                _resp = IDP.create_authn_response(
                    identity, userid=self.user,
                    authn=AUTHN_BROKER[self.environ["idp.authn_ref"]], sign_assertion=sign_assertion,
                    sign_response=False, **resp_args)
            except Exception, excp:
                logging.error(exception_trace(excp))
                resp = ServiceError("Exception: %s" % (excp,))
                return resp(self.environ, self.start_response)

        logger.info("AuthNResponse: %s" % _resp)
        http_args = IDP.apply_binding(self.binding_out,
                                      "%s" % _resp, self.destination,
                                      relay_state, response=True)
        logger.debug("HTTPargs: %s" % http_args)
        return self.response(self.binding_out, http_args)

    def _store_request(self, _dict):
        logger.debug("_store_request: %s" % _dict)
        key = sha1(_dict["SAMLRequest"]).hexdigest()
        # store the AuthnRequest
        IDP.ticket[key] = _dict
        return key

    def redirect(self):
        """ This is the HTTP-redirect endpoint """

        logger.info("--- In SSO Redirect ---")
        _info = self.unpack_redirect()

        try:
            _key = _info["key"]
            _info = IDP.ticket[_key]
            self.req_info = _info["req_info"]
            del IDP.ticket[_key]
        except KeyError:
            try:
                self.req_info = IDP.parse_authn_request(_info["SAMLRequest"],
                                                        BINDING_HTTP_REDIRECT)
            except KeyError:
                resp = BadRequest("Message signature verification failure")
                return resp(self.environ, self.start_response)

            _req = self.req_info.message

            if "SigAlg" in _info and "Signature" in _info:  # Signed request
                issuer = _req.issuer.text
                _certs = IDP.metadata.certs(issuer, "any", "signing")
                verified_ok = False
                for cert in _certs:
                    if verify_redirect_signature(_info, cert):
                        verified_ok = True
                        break
                if not verified_ok:
                    resp = BadRequest("Message signature verification failure")
                    return resp(self.environ, self.start_response)

            if self.user:
                if _req.force_authn:
                    _info["req_info"] = self.req_info
                    key = self._store_request(_info)
                    return self.not_authn(key, _req.requested_authn_context)
                else:
                    return self.operation(_info, BINDING_HTTP_REDIRECT)
            else:
                _info["req_info"] = self.req_info
                key = self._store_request(_info)
                return self.not_authn(key, _req.requested_authn_context)
        else:
            return self.operation(_info, BINDING_HTTP_REDIRECT)

    def post(self):
        """
        The HTTP-Post endpoint
        """
        logger.info("--- In SSO POST ---")
        _info = self.unpack_either()
        self.req_info = IDP.parse_authn_request(
            _info["SAMLRequest"], BINDING_HTTP_POST)
        _req = self.req_info.message
        if self.user:
            if _req.force_authn:
                _info["req_info"] = self.req_info
                key = self._store_request(_info)
                return self.not_authn(key, _req.requested_authn_context)
            else:
                return self.operation(_info, BINDING_HTTP_POST)
        else:
            _info["req_info"] = self.req_info
            key = self._store_request(_info)
            return self.not_authn(key, _req.requested_authn_context)

    # def artifact(self):
    #     # Can be either by HTTP_Redirect or HTTP_POST
    #     _req = self._store_request(self.unpack_either())
    #     if isinstance(_req, basestring):
    #         return self.not_authn(_req)
    #     return self.artifact_operation(_req)

    def ecp(self):
        # The ECP interface
        logger.info("--- ECP SSO ---")
        resp = None

        try:
            authz_info = self.environ["HTTP_AUTHORIZATION"]
            if authz_info.startswith("Basic "):
                _info = base64.b64decode(authz_info[6:])
                logger.debug("Authz_info: %s" % _info)
                try:
                    (user, passwd) = _info.split(":")
                    if PASSWD[user] != passwd:
                        resp = Unauthorized()
                    self.user = user
                except ValueError:
                    resp = Unauthorized()
            else:
                resp = Unauthorized()
        except KeyError:
            resp = Unauthorized()

        if resp:
            return resp(self.environ, self.start_response)

        _dict = self.unpack_soap()
        self.response_bindings = [BINDING_PAOS]
        # Basic auth ?!
        return self.operation(_dict, BINDING_SOAP)

# -----------------------------------------------------------------------------
# === Authentication ====
# -----------------------------------------------------------------------------


def do_authentication(environ, start_response, authn_context, key,
                      redirect_uri):
    """
    Display the login form
    """
    logger.debug("Do authentication")
    auth_info = AUTHN_BROKER.pick(authn_context)

    if len(auth_info):
        method, reference = auth_info[0]
        logger.debug("Authn chosen: %s (ref=%s)" % (method, reference))
        return method(environ, start_response, reference, key, redirect_uri)
    else:
        resp = Unauthorized("No usable authentication method")
        return resp(environ, start_response)


# -----------------------------------------------------------------------------

PASSWD = {"haho0032": "qwerty",
          "roland": "dianakra",
          "babs": "howes",
          "upper": "crust"}


def username_password_authn(environ, start_response, reference, key,
                            redirect_uri):
    """
    Display the login form
    """
    logger.info("The login page")
    headers = []

    resp = Response(mako_template="login.mako", template_lookup=LOOKUP,
                    headers=headers)

    argv = {
        "action": "/verify",
        "login": "",
        "password": "",
        "key": key,
        "authn_reference": reference,
        "redirect_uri": redirect_uri
    }
    logger.info("do_authentication argv: %s" % argv)
    return resp(environ, start_response, **argv)


def verify_username_and_password(dic):
    global PASSWD
    # verify username and password
    if PASSWD[dic["login"][0]] == dic["password"][0]:
        return True, dic["login"][0]
    else:
        return False, ""


def do_verify(environ, start_response, _):
    query = parse_qs(get_post(environ))

    logger.debug("do_verify: %s" % query)

    try:
        _ok, user = verify_username_and_password(query)
    except KeyError:
        _ok = False
        user = None

    if not _ok:
        resp = Unauthorized("Unknown user or wrong password")
    else:
        uid = rndstr(24)
        IDP.cache.uid2user[uid] = user
        IDP.cache.user2uid[user] = uid
        logger.debug("Register %s under '%s'" % (user, uid))

        kaka = set_cookie("idpauthn", "/", uid, query["authn_reference"][0])

        lox = "%s?id=%s&key=%s" % (query["redirect_uri"][0], uid,
                                   query["key"][0])
        logger.debug("Redirect => %s" % lox)
        resp = Redirect(lox, headers=[kaka], content="text/html")

    return resp(environ, start_response)


def not_found(environ, start_response):
    """Called if no URL matches."""
    resp = NotFound()
    return resp(environ, start_response)


# -----------------------------------------------------------------------------
# === Single log out ===
# -----------------------------------------------------------------------------

#def _subject_sp_info(req_info):
#    # look for the subject
#    subject = req_info.subject_id()
#    subject = subject.text.strip()
#    sp_entity_id = req_info.message.issuer.text.strip()
#    return subject, sp_entity_id

class SLO(Service):
    def do(self, request, binding, relay_state=""):
        logger.info("--- Single Log Out Service ---")
        try:
            _, body = request.split("\n")
            logger.debug("req: '%s'" % body)
            req_info = IDP.parse_logout_request(body, binding)
        except Exception, exc:
            logger.error("Bad request: %s" % exc)
            resp = BadRequest("%s" % exc)
            return resp(self.environ, self.start_response)
    
        msg = req_info.message
        if msg.name_id:
            lid = IDP.ident.find_local_id(msg.name_id)
            logger.info("local identifier: %s" % lid)
            if lid in IDP.cache.user2uid:
                uid = IDP.cache.user2uid[lid]
                if uid in IDP.cache.uid2user:
                    del IDP.cache.uid2user[uid]
                del IDP.cache.user2uid[lid]
            # remove the authentication
            try:
                IDP.session_db.remove_authn_statements(msg.name_id)
            except KeyError, exc:
                logger.error("ServiceError: %s" % exc)
                resp = ServiceError("%s" % exc)
                return resp(self.environ, self.start_response)
    
        resp = IDP.create_logout_response(msg, [binding])
    
        try:
            hinfo = IDP.apply_binding(binding, "%s" % resp, "", relay_state)
        except Exception, exc:
            logger.error("ServiceError: %s" % exc)
            resp = ServiceError("%s" % exc)
            return resp(self.environ, self.start_response)
    
        #_tlh = dict2list_of_tuples(hinfo["headers"])
        delco = delete_cookie(self.environ, "idpauthn")
        if delco:
            hinfo["headers"].append(delco)
        logger.info("Header: %s" % (hinfo["headers"],))
        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)
    
# ----------------------------------------------------------------------------
# Manage Name ID service
# ----------------------------------------------------------------------------


class NMI(Service):
    
    def do(self, query, binding, relay_state=""):
        logger.info("--- Manage Name ID Service ---")
        req = IDP.parse_manage_name_id_request(query, binding)
        request = req.message
    
        # Do the necessary stuff
        name_id = IDP.ident.handle_manage_name_id_request(
            request.name_id, request.new_id, request.new_encrypted_id,
            request.terminate)
    
        logger.debug("New NameID: %s" % name_id)
    
        _resp = IDP.create_manage_name_id_response(request)
    
        # It's using SOAP binding
        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % _resp, "",
                                  relay_state, response=True)
    
        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)
    
# ----------------------------------------------------------------------------
# === Assertion ID request ===
# ----------------------------------------------------------------------------


# Only URI binding
class AIDR(Service):
    def do(self, aid, binding, relay_state=""):
        logger.info("--- Assertion ID Service ---")

        try:
            assertion = IDP.create_assertion_id_request_response(aid)
        except Unknown:
            resp = NotFound(aid)
            return resp(self.environ, self.start_response)
    
        hinfo = IDP.apply_binding(BINDING_URI, "%s" % assertion, response=True)
    
        logger.debug("HINFO: %s" % hinfo)
        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)

    def operation(self, _dict, binding, **kwargs):
        logger.debug("_operation: %s" % _dict)
        if not _dict or "ID" not in _dict:
            resp = BadRequest('Error parsing request or no request')
            return resp(self.environ, self.start_response)

        return self.do(_dict["ID"], binding, **kwargs)


# ----------------------------------------------------------------------------
# === Artifact resolve service ===
# ----------------------------------------------------------------------------

class ARS(Service):
    def do(self, request, binding, relay_state=""):
        _req = IDP.parse_artifact_resolve(request, binding)

        msg = IDP.create_artifact_response(_req, _req.artifact.text)

        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % msg, "", "",
                                  response=True)

        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)

# ----------------------------------------------------------------------------
# === Authn query service ===
# ----------------------------------------------------------------------------


# Only SOAP binding
class AQS(Service):
    def do(self, request, binding, relay_state=""):
        logger.info("--- Authn Query Service ---")
        _req = IDP.parse_authn_query(request, binding)
        _query = _req.message

        msg = IDP.create_authn_query_response(_query.subject,
                                              _query.requested_authn_context,
                                              _query.session_index)

        logger.debug("response: %s" % msg)
        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % msg, "", "",
                                  response=True)

        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)


# ----------------------------------------------------------------------------
# === Attribute query service ===
# ----------------------------------------------------------------------------


# Only SOAP binding
class ATTR(Service):
    def do(self, request, binding, relay_state=""):
        logger.info("--- Attribute Query Service ---")

        _req = IDP.parse_attribute_query(request, binding)
        _query = _req.message

        name_id = _query.subject.name_id
        uid = name_id.text
        logger.debug("Local uid: %s" % uid)
        identity = EXTRA[uid]

        # Comes in over SOAP so only need to construct the response
        args = IDP.response_args(_query, [BINDING_SOAP])
        msg = IDP.create_attribute_response(identity,
                                            name_id=name_id, **args)

        logger.debug("response: %s" % msg)
        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % msg, "", "",
                                  response=True)

        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)

# ----------------------------------------------------------------------------
# Name ID Mapping service
# When an entity that shares an identifier for a principal with an identity
# provider wishes to obtain a name identifier for the same principal in a
# particular format or federation namespace, it can send a request to
# the identity provider using this protocol.
# ----------------------------------------------------------------------------


class NIM(Service):
    def do(self, query, binding, relay_state=""):
        req = IDP.parse_name_id_mapping_request(query, binding)
        request = req.message
        # Do the necessary stuff
        try:
            name_id = IDP.ident.handle_name_id_mapping_request(
                request.name_id, request.name_id_policy)
        except Unknown:
            resp = BadRequest("Unknown entity")
            return resp(self.environ, self.start_response)
        except PolicyError:
            resp = BadRequest("Unknown entity")
            return resp(self.environ, self.start_response)
    
        info = IDP.response_args(request)
        _resp = IDP.create_name_id_mapping_response(name_id, **info)
    
        # Only SOAP
        hinfo = IDP.apply_binding(BINDING_SOAP, "%s" % _resp, "", "",
                                  response=True)
    
        resp = Response(hinfo["data"], headers=hinfo["headers"])
        return resp(self.environ, self.start_response)
    

# ----------------------------------------------------------------------------
# Cookie handling
# ----------------------------------------------------------------------------
def info_from_cookie(kaka):
    logger.debug("KAKA: %s" % kaka)
    if kaka:
        cookie_obj = SimpleCookie(kaka)
        morsel = cookie_obj.get("idpauthn", None)
        if morsel:
            try:
                key, ref = base64.b64decode(morsel.value).split(":")
                return IDP.cache.uid2user[key], ref
            except KeyError:
                return None, None
        else:
            logger.debug("No idpauthn cookie")
    return None, None


def delete_cookie(environ, name):
    kaka = environ.get("HTTP_COOKIE", '')
    logger.debug("delete KAKA: %s" % kaka)
    if kaka:
        cookie_obj = SimpleCookie(kaka)
        morsel = cookie_obj.get(name, None)
        cookie = SimpleCookie()
        cookie[name] = ""
        cookie[name]['path'] = "/"
        logger.debug("Expire: %s" % morsel)
        cookie[name]["expires"] = _expiration("dawn")
        return tuple(cookie.output().split(": ", 1))
    return None


def set_cookie(name, _, *args):
    cookie = SimpleCookie()
    cookie[name] = base64.b64encode(":".join(args))
    cookie[name]['path'] = "/"
    cookie[name]["expires"] = _expiration(5)  # 5 minutes from now
    logger.debug("Cookie expires: %s" % cookie[name]["expires"])
    return tuple(cookie.output().split(": ", 1))

# ----------------------------------------------------------------------------

# map urls to functions
AUTHN_URLS = [
    # sso
    (r'sso/post$', (SSO, "post")),
    (r'sso/post/(.*)$', (SSO, "post")),
    (r'sso/redirect$', (SSO, "redirect")),
    (r'sso/redirect/(.*)$', (SSO, "redirect")),
    (r'sso/art$', (SSO, "artifact")),
    (r'sso/art/(.*)$', (SSO, "artifact")),
    # slo
    (r'slo/redirect$', (SLO, "redirect")),
    (r'slo/redirect/(.*)$', (SLO, "redirect")),
    (r'slo/post$', (SLO, "post")),
    (r'slo/post/(.*)$', (SLO, "post")),
    (r'slo/soap$', (SLO, "soap")),
    (r'slo/soap/(.*)$', (SLO, "soap")),
    #
    (r'airs$', (AIDR, "uri")),
    (r'ars$', (ARS, "soap")),
    # mni
    (r'mni/post$', (NMI, "post")),
    (r'mni/post/(.*)$', (NMI, "post")),
    (r'mni/redirect$', (NMI, "redirect")),
    (r'mni/redirect/(.*)$', (NMI, "redirect")),
    (r'mni/art$', (NMI, "artifact")),
    (r'mni/art/(.*)$', (NMI, "artifact")),
    (r'mni/soap$', (NMI, "soap")),
    (r'mni/soap/(.*)$', (NMI, "soap")),
    # nim
    (r'nim$', (NIM, "soap")),
    (r'nim/(.*)$', (NIM, "soap")),
    #
    (r'aqs$', (AQS, "soap")),
    (r'attr$', (ATTR, "soap"))
]

NON_AUTHN_URLS = [
    #(r'login?(.*)$', do_authentication),
    (r'verify?(.*)$', do_verify),
    (r'sso/ecp$', (SSO, "ecp")),
]

# ----------------------------------------------------------------------------


def metadata(environ, start_response):
    try:
        path = args.path
        if path is None or len(path) == 0:
            path = os.path.dirname(os.path.abspath( __file__ ))
        if path[-1] != "/":
            path += "/"
        metadata = create_metadata_string(path+args.config, IDP.config,
                                          args.valid, args.cert, args.keyfile,
                                          args.id, args.name, args.sign)
        start_response('200 OK', [('Content-Type', "text/xml")])
        return metadata
    except Exception as ex:
        logger.error("An error occured while creating metadata:" + ex.message)
        return not_found(environ, start_response)

def staticfile(environ, start_response):
    try:
        path = args.path
        if path is None or len(path) == 0:
            path = os.path.dirname(os.path.abspath(__file__))
        if path[-1] != "/":
            path += "/"
        path += environ.get('PATH_INFO', '').lstrip('/')
        start_response('200 OK', [('Content-Type', "text/xml")])
        return open(path, 'r').read()
    except Exception as ex:
        logger.error("An error occured while creating metadata:" + ex.message)
        return not_found(environ, start_response)

def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above and store the regular expression
    captures in the WSGI environment as `myapp.url_args` so that
    the functions from above can access the url placeholders.

    If nothing matches, call the `not_found` function.
    
    :param environ: The HTTP application environment
    :param start_response: The application to run when the handling of the 
        request is done
    :return: The response as a list of lines
    """

    path = environ.get('PATH_INFO', '').lstrip('/')

    if path == "metadata":
        return metadata(environ, start_response)

    kaka = environ.get("HTTP_COOKIE", None)
    logger.info("<application> PATH: %s" % path)

    if kaka:
        logger.info("= KAKA =")
        user, authn_ref = info_from_cookie(kaka)
        environ["idp.authn_ref"] = authn_ref
    else:
        try:
            query = parse_qs(environ["QUERY_STRING"])
            logger.debug("QUERY: %s" % query)
            user = IDP.cache.uid2user[query["id"][0]]
        except KeyError:
            user = None

    url_patterns = AUTHN_URLS
    if not user:
        logger.info("-- No USER --")
        # insert NON_AUTHN_URLS first in case there is no user
        url_patterns = NON_AUTHN_URLS + url_patterns

    for regex, callback in url_patterns:
        match = re.search(regex, path)
        if match is not None:
            try:
                environ['myapp.url_args'] = match.groups()[0]
            except IndexError:
                environ['myapp.url_args'] = path

            logger.debug("Callback: %s" % (callback,))
            if isinstance(callback, tuple):
                cls = callback[0](environ, start_response, user)
                func = getattr(cls, callback[1])
                return func()
            return callback(environ, start_response, user)

    if re.search(r'static/.*', path) is not None:
        return staticfile(environ, start_response)
    return not_found(environ, start_response)

# ----------------------------------------------------------------------------

# allow uwsgi or gunicorn mount
# by moving some initialization out of __name__ == '__main__' section.
# uwsgi -s 0.0.0.0:8088 --protocol http --callable application --module idp

args = type('Config', (object,), { })
args.config = 'idp_conf'
args.mako_root = './'
args.path = None

import socket
from idp_user import USERS
from idp_user import EXTRA
from mako.lookup import TemplateLookup

AUTHN_BROKER = AuthnBroker()
AUTHN_BROKER.add(authn_context_class_ref(PASSWORD),
             username_password_authn, 10,
             "http://%s" % socket.gethostname())
AUTHN_BROKER.add(authn_context_class_ref(UNSPECIFIED),
             "", 0, "http://%s" % socket.gethostname())

IDP = server.Server(args.config, cache=Cache())
IDP.ticket = {}

# ----------------------------------------------------------------------------

if __name__ == '__main__':
    from wsgiref.simple_server import make_server

    parser = argparse.ArgumentParser()
    parser.add_argument('-p', dest='path', help='Path to configuration file.')
    parser.add_argument('-v', dest='valid',
                        help="How long, in days, the metadata is valid from the time of creation")
    parser.add_argument('-c', dest='cert', help='certificate')
    parser.add_argument('-i', dest='id',
                        help="The ID of the entities descriptor")
    parser.add_argument('-k', dest='keyfile',
                        help="A file with a key to sign the metadata with")
    parser.add_argument('-n', dest='name')
    parser.add_argument('-s', dest='sign', action='store_true',
                        help="sign the metadata")
    parser.add_argument('-m', dest='mako_root', default="./")
    parser.add_argument(dest="config")
    args = parser.parse_args()

    _rot = args.mako_root
    LOOKUP = TemplateLookup(directories=[_rot + 'templates', _rot + 'htdocs'],
                            module_directory=_rot + 'modules',
                            input_encoding='utf-8', output_encoding='utf-8')

    HOST = '127.0.0.1'
    PORT = 8088

    SRV = make_server(HOST, PORT, application)
    print "IdP listening on %s:%s" % (HOST, PORT)
    SRV.serve_forever()
else:
    _rot = args.mako_root
    LOOKUP = TemplateLookup(directories=[_rot + 'templates', _rot + 'htdocs'],
                            module_directory=_rot + 'modules',
                            input_encoding='utf-8', output_encoding='utf-8')

########NEW FILE########
__FILENAME__ = idp_user
USERS = {
    "haho0032": {
        "sn": "Hoerberg",
        "givenName": "Hans",
        "eduPersonScopedAffiliation": "staff@example.com",
        "eduPersonPrincipalName": "haho@example.com",
        "uid": "haho",
        "eduPersonTargetedID": "one!for!all",
        "c": "SE",
        "o": "Example Co.",
        "ou": "IT",
        "initials": "P",
        "schacHomeOrganization": "example.com",
        "email": "hans@example.com",
        "displayName": "Hans Hoerberg",
        "labeledURL": "http://www.example.com/haho My homepage",
        "norEduPersonNIN": "SE199012315555"
    },
    "roland": {
        "sn": "Hedberg",
        "givenName": "Roland",
        "eduPersonScopedAffiliation": "staff@example.com",
        "eduPersonPrincipalName": "rohe@example.com",
        "uid": "rohe",
        "eduPersonTargetedID": "one!for!all",
        "c": "SE",
        "o": "Example Co.",
        "ou": "IT",
        "initials": "P",
        #"schacHomeOrganization": "example.com",
        "email": "roland@example.com",
        "displayName": "P. Roland Hedberg",
        "labeledURL": "http://www.example.com/rohe My homepage",
        "norEduPersonNIN": "SE197001012222"
    },
    "babs": {
        "surname": "Babs",
        "givenName": "Ozzie",
        "eduPersonAffiliation": "affiliate"
    },
    "upper": {
        "surname": "Jeter",
        "givenName": "Derek",
        "eduPersonAffiliation": "affiliate"
    },
}

EXTRA = {
    "roland": {
        "eduPersonEntitlement": "urn:mace:swamid.se:foo:bar",
        "schacGender": "male",
        "schacUserPresenceID": "skype:pepe.perez"
    }
}
########NEW FILE########
__FILENAME__ = login.mako
# -*- encoding:utf-8 -*-
from mako import runtime, filters, cache
UNDEFINED = runtime.UNDEFINED
__M_dict_builtin = dict
__M_locals_builtin = locals
_magic_number = 6
_modified_time = 1367126126.936375
_template_filename='htdocs/login.mako'
_template_uri='login.mako'
_template_cache=cache.Cache(__name__, _modified_time)
_source_encoding='utf-8'
_exports = []


def _mako_get_namespace(context, name):
    try:
        return context.namespaces[(__name__, name)]
    except KeyError:
        _mako_generate_namespaces(context)
        return context.namespaces[(__name__, name)]
def _mako_generate_namespaces(context):
    pass
def _mako_inherit(template, context):
    _mako_generate_namespaces(context)
    return runtime._inherit_from(context, u'root.mako', _template_uri)
def render_body(context,**pageargs):
    context.caller_stack._push_frame()
    try:
        __M_locals = __M_dict_builtin(pageargs=pageargs)
        redirect_uri = context.get('redirect_uri', UNDEFINED)
        key = context.get('key', UNDEFINED)
        action = context.get('action', UNDEFINED)
        authn_reference = context.get('authn_reference', UNDEFINED)
        login = context.get('login', UNDEFINED)
        password = context.get('password', UNDEFINED)
        __M_writer = context.writer()
        # SOURCE LINE 1
        __M_writer(u'\n\n<h1>Please log in</h1>\n<p class="description">\n    To register it\'s quite simple: enter a login and a password\n</p>\n\n<form action="')
        # SOURCE LINE 8
        __M_writer(unicode(action))
        __M_writer(u'" method="post">\n    <input type="hidden" name="key" value="')
        # SOURCE LINE 9
        __M_writer(unicode(key))
        __M_writer(u'"/>\n    <input type="hidden" name="authn_reference" value="')
        # SOURCE LINE 10
        __M_writer(unicode(authn_reference))
        __M_writer(u'"/>\n    <input type="hidden" name="redirect_uri" value="')
        # SOURCE LINE 11
        __M_writer(unicode(redirect_uri))
        __M_writer(u'"/>\n\n    <div class="label">\n        <label for="login">Username</label>\n    </div>\n    <div>\n        <input type="text" name="login" value="')
        # SOURCE LINE 17
        __M_writer(unicode(login))
        __M_writer(u'"/><br/>\n    </div>\n\n    <div class="label">\n        <label for="password">Password</label>\n    </div>\n    <div>\n        <input type="password" name="password"\n               value="')
        # SOURCE LINE 25
        __M_writer(unicode(password))
        __M_writer(u'"/>\n    </div>\n\n    <input class="submit" type="submit" name="form.submitted" value="Log In"/>\n</form>\n')
        return ''
    finally:
        context.caller_stack._pop_frame()



########NEW FILE########
__FILENAME__ = root.mako
# -*- encoding:utf-8 -*-
from mako import runtime, filters, cache
UNDEFINED = runtime.UNDEFINED
__M_dict_builtin = dict
__M_locals_builtin = locals
_magic_number = 6
_modified_time = 1357242050.211483
_template_filename=u'templates/root.mako'
_template_uri=u'root.mako'
_template_cache=cache.Cache(__name__, _modified_time)
_source_encoding='utf-8'
_exports = ['css_link', 'pre', 'post', 'css']


def render_body(context,**pageargs):
    context.caller_stack._push_frame()
    try:
        __M_locals = __M_dict_builtin(pageargs=pageargs)
        def pre():
            return render_pre(context.locals_(__M_locals))
        self = context.get('self', UNDEFINED)
        set = context.get('set', UNDEFINED)
        def post():
            return render_post(context.locals_(__M_locals))
        next = context.get('next', UNDEFINED)
        __M_writer = context.writer()
        # SOURCE LINE 1
        self.seen_css = set() 
        
        __M_writer(u'\n')
        # SOURCE LINE 7
        __M_writer(u'\n')
        # SOURCE LINE 10
        __M_writer(u'\n')
        # SOURCE LINE 15
        __M_writer(u'\n')
        # SOURCE LINE 22
        __M_writer(u'\n')
        # SOURCE LINE 25
        __M_writer(u'<html>\n<head><title>IDP test login</title>\n    ')
        # SOURCE LINE 27
        __M_writer(unicode(self.css()))
        __M_writer(u'\n    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />\n</head>\n<body>\n    ')
        # SOURCE LINE 31
        __M_writer(unicode(pre()))
        __M_writer(u'\n')
        # SOURCE LINE 34
        __M_writer(unicode(next.body()))
        __M_writer(u'\n')
        # SOURCE LINE 35
        __M_writer(unicode(post()))
        __M_writer(u'\n</body>\n</html>\n')
        return ''
    finally:
        context.caller_stack._pop_frame()


def render_css_link(context,path,media=''):
    context.caller_stack._push_frame()
    try:
        context._push_buffer()
        self = context.get('self', UNDEFINED)
        __M_writer = context.writer()
        # SOURCE LINE 2
        __M_writer(u'\n')
        # SOURCE LINE 3
        if path not in self.seen_css:
            # SOURCE LINE 4
            __M_writer(u'        <link rel="stylesheet" type="text/css" href="')
            __M_writer(filters.html_escape(unicode(path)))
            __M_writer(u'" media="')
            __M_writer(unicode(media))
            __M_writer(u'">\n')
            pass
        # SOURCE LINE 6
        __M_writer(u'    ')
        self.seen_css.add(path) 
        
        __M_writer(u'\n')
    finally:
        __M_buf, __M_writer = context._pop_buffer_and_writer()
        context.caller_stack._pop_frame()
    __M_writer(filters.trim(__M_buf.getvalue()))
    return ''


def render_pre(context):
    context.caller_stack._push_frame()
    try:
        context._push_buffer()
        __M_writer = context.writer()
        # SOURCE LINE 11
        __M_writer(u'\n    <div class="header">\n        <h1><a href="/">Login</a></h1>\n    </div>\n')
    finally:
        __M_buf, __M_writer = context._pop_buffer_and_writer()
        context.caller_stack._pop_frame()
    __M_writer(filters.trim(__M_buf.getvalue()))
    return ''


def render_post(context):
    context.caller_stack._push_frame()
    try:
        context._push_buffer()
        __M_writer = context.writer()
        # SOURCE LINE 16
        __M_writer(u'\n    <div>\n        <div class="footer">\n            <p>&#169; Copyright 2011 Ume&#229; Universitet &nbsp;</p>\n        </div>\n    </div>\n')
    finally:
        __M_buf, __M_writer = context._pop_buffer_and_writer()
        context.caller_stack._pop_frame()
    __M_writer(filters.trim(__M_buf.getvalue()))
    return ''


def render_css(context):
    context.caller_stack._push_frame()
    try:
        context._push_buffer()
        def css_link(path,media=''):
            return render_css_link(context,path,media)
        __M_writer = context.writer()
        # SOURCE LINE 8
        __M_writer(u'\n    ')
        # SOURCE LINE 9
        __M_writer(unicode(css_link('/css/main.css', 'screen')))
        __M_writer(u'\n')
    finally:
        __M_buf, __M_writer = context._pop_buffer_and_writer()
        context.caller_stack._pop_frame()
    __M_writer(filters.trim(__M_buf.getvalue()))
    return ''



########NEW FILE########
__FILENAME__ = basic

MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:basic",
    "fro": {
        'urn:mace:dir:attribute-def:aRecord': 'aRecord',
        'urn:mace:dir:attribute-def:aliasedEntryName': 'aliasedEntryName',
        'urn:mace:dir:attribute-def:aliasedObjectName': 'aliasedObjectName',
        'urn:mace:dir:attribute-def:associatedDomain': 'associatedDomain',
        'urn:mace:dir:attribute-def:associatedName': 'associatedName',
        'urn:mace:dir:attribute-def:audio': 'audio',
        'urn:mace:dir:attribute-def:authorityRevocationList': 'authorityRevocationList',
        'urn:mace:dir:attribute-def:buildingName': 'buildingName',
        'urn:mace:dir:attribute-def:businessCategory': 'businessCategory',
        'urn:mace:dir:attribute-def:c': 'c',
        'urn:mace:dir:attribute-def:cACertificate': 'cACertificate',
        'urn:mace:dir:attribute-def:cNAMERecord': 'cNAMERecord',
        'urn:mace:dir:attribute-def:carLicense': 'carLicense',
        'urn:mace:dir:attribute-def:certificateRevocationList': 'certificateRevocationList',
        'urn:mace:dir:attribute-def:cn': 'cn',
        'urn:mace:dir:attribute-def:co': 'co',
        'urn:mace:dir:attribute-def:commonName': 'commonName',
        'urn:mace:dir:attribute-def:countryName': 'countryName',
        'urn:mace:dir:attribute-def:crossCertificatePair': 'crossCertificatePair',
        'urn:mace:dir:attribute-def:dITRedirect': 'dITRedirect',
        'urn:mace:dir:attribute-def:dSAQuality': 'dSAQuality',
        'urn:mace:dir:attribute-def:dc': 'dc',
        'urn:mace:dir:attribute-def:deltaRevocationList': 'deltaRevocationList',
        'urn:mace:dir:attribute-def:departmentNumber': 'departmentNumber',
        'urn:mace:dir:attribute-def:description': 'description',
        'urn:mace:dir:attribute-def:destinationIndicator': 'destinationIndicator',
        'urn:mace:dir:attribute-def:displayName': 'displayName',
        'urn:mace:dir:attribute-def:distinguishedName': 'distinguishedName',
        'urn:mace:dir:attribute-def:dmdName': 'dmdName',
        'urn:mace:dir:attribute-def:dnQualifier': 'dnQualifier',
        'urn:mace:dir:attribute-def:documentAuthor': 'documentAuthor',
        'urn:mace:dir:attribute-def:documentIdentifier': 'documentIdentifier',
        'urn:mace:dir:attribute-def:documentLocation': 'documentLocation',
        'urn:mace:dir:attribute-def:documentPublisher': 'documentPublisher',
        'urn:mace:dir:attribute-def:documentTitle': 'documentTitle',
        'urn:mace:dir:attribute-def:documentVersion': 'documentVersion',
        'urn:mace:dir:attribute-def:domainComponent': 'domainComponent',
        'urn:mace:dir:attribute-def:drink': 'drink',
        'urn:mace:dir:attribute-def:eduOrgHomePageURI': 'eduOrgHomePageURI',
        'urn:mace:dir:attribute-def:eduOrgIdentityAuthNPolicyURI': 'eduOrgIdentityAuthNPolicyURI',
        'urn:mace:dir:attribute-def:eduOrgLegalName': 'eduOrgLegalName',
        'urn:mace:dir:attribute-def:eduOrgSuperiorURI': 'eduOrgSuperiorURI',
        'urn:mace:dir:attribute-def:eduOrgWhitePagesURI': 'eduOrgWhitePagesURI',
        'urn:mace:dir:attribute-def:eduPersonAffiliation': 'eduPersonAffiliation',
        'urn:mace:dir:attribute-def:eduPersonEntitlement': 'eduPersonEntitlement',
        'urn:mace:dir:attribute-def:eduPersonNickname': 'eduPersonNickname',
        'urn:mace:dir:attribute-def:eduPersonOrgDN': 'eduPersonOrgDN',
        'urn:mace:dir:attribute-def:eduPersonOrgUnitDN': 'eduPersonOrgUnitDN',
        'urn:mace:dir:attribute-def:eduPersonPrimaryAffiliation': 'eduPersonPrimaryAffiliation',
        'urn:mace:dir:attribute-def:eduPersonPrimaryOrgUnitDN': 'eduPersonPrimaryOrgUnitDN',
        'urn:mace:dir:attribute-def:eduPersonPrincipalName': 'eduPersonPrincipalName',
        'urn:mace:dir:attribute-def:eduPersonScopedAffiliation': 'eduPersonScopedAffiliation',
        'urn:mace:dir:attribute-def:eduPersonTargetedID': 'eduPersonTargetedID',
        'urn:mace:dir:attribute-def:email': 'email',
        'urn:mace:dir:attribute-def:emailAddress': 'emailAddress',
        'urn:mace:dir:attribute-def:employeeNumber': 'employeeNumber',
        'urn:mace:dir:attribute-def:employeeType': 'employeeType',
        'urn:mace:dir:attribute-def:enhancedSearchGuide': 'enhancedSearchGuide',
        'urn:mace:dir:attribute-def:facsimileTelephoneNumber': 'facsimileTelephoneNumber',
        'urn:mace:dir:attribute-def:favouriteDrink': 'favouriteDrink',
        'urn:mace:dir:attribute-def:fax': 'fax',
        'urn:mace:dir:attribute-def:federationFeideSchemaVersion': 'federationFeideSchemaVersion',
        'urn:mace:dir:attribute-def:friendlyCountryName': 'friendlyCountryName',
        'urn:mace:dir:attribute-def:generationQualifier': 'generationQualifier',
        'urn:mace:dir:attribute-def:givenName': 'givenName',
        'urn:mace:dir:attribute-def:gn': 'gn',
        'urn:mace:dir:attribute-def:homePhone': 'homePhone',
        'urn:mace:dir:attribute-def:homePostalAddress': 'homePostalAddress',
        'urn:mace:dir:attribute-def:homeTelephoneNumber': 'homeTelephoneNumber',
        'urn:mace:dir:attribute-def:host': 'host',
        'urn:mace:dir:attribute-def:houseIdentifier': 'houseIdentifier',
        'urn:mace:dir:attribute-def:info': 'info',
        'urn:mace:dir:attribute-def:initials': 'initials',
        'urn:mace:dir:attribute-def:internationaliSDNNumber': 'internationaliSDNNumber',
        'urn:mace:dir:attribute-def:janetMailbox': 'janetMailbox',
        'urn:mace:dir:attribute-def:jpegPhoto': 'jpegPhoto',
        'urn:mace:dir:attribute-def:knowledgeInformation': 'knowledgeInformation',
        'urn:mace:dir:attribute-def:l': 'l',
        'urn:mace:dir:attribute-def:labeledURI': 'labeledURI',
        'urn:mace:dir:attribute-def:localityName': 'localityName',
        'urn:mace:dir:attribute-def:mDRecord': 'mDRecord',
        'urn:mace:dir:attribute-def:mXRecord': 'mXRecord',
        'urn:mace:dir:attribute-def:mail': 'mail',
        'urn:mace:dir:attribute-def:mailPreferenceOption': 'mailPreferenceOption',
        'urn:mace:dir:attribute-def:manager': 'manager',
        'urn:mace:dir:attribute-def:member': 'member',
        'urn:mace:dir:attribute-def:mobile': 'mobile',
        'urn:mace:dir:attribute-def:mobileTelephoneNumber': 'mobileTelephoneNumber',
        'urn:mace:dir:attribute-def:nSRecord': 'nSRecord',
        'urn:mace:dir:attribute-def:name': 'name',
        'urn:mace:dir:attribute-def:norEduOrgAcronym': 'norEduOrgAcronym',
        'urn:mace:dir:attribute-def:norEduOrgNIN': 'norEduOrgNIN',
        'urn:mace:dir:attribute-def:norEduOrgSchemaVersion': 'norEduOrgSchemaVersion',
        'urn:mace:dir:attribute-def:norEduOrgUniqueIdentifier': 'norEduOrgUniqueIdentifier',
        'urn:mace:dir:attribute-def:norEduOrgUniqueNumber': 'norEduOrgUniqueNumber',
        'urn:mace:dir:attribute-def:norEduOrgUnitUniqueIdentifier': 'norEduOrgUnitUniqueIdentifier',
        'urn:mace:dir:attribute-def:norEduOrgUnitUniqueNumber': 'norEduOrgUnitUniqueNumber',
        'urn:mace:dir:attribute-def:norEduPersonBirthDate': 'norEduPersonBirthDate',
        'urn:mace:dir:attribute-def:norEduPersonLIN': 'norEduPersonLIN',
        'urn:mace:dir:attribute-def:norEduPersonNIN': 'norEduPersonNIN',
        'urn:mace:dir:attribute-def:o': 'o',
        'urn:mace:dir:attribute-def:objectClass': 'objectClass',
        'urn:mace:dir:attribute-def:organizationName': 'organizationName',
        'urn:mace:dir:attribute-def:organizationalStatus': 'organizationalStatus',
        'urn:mace:dir:attribute-def:organizationalUnitName': 'organizationalUnitName',
        'urn:mace:dir:attribute-def:otherMailbox': 'otherMailbox',
        'urn:mace:dir:attribute-def:ou': 'ou',
        'urn:mace:dir:attribute-def:owner': 'owner',
        'urn:mace:dir:attribute-def:pager': 'pager',
        'urn:mace:dir:attribute-def:pagerTelephoneNumber': 'pagerTelephoneNumber',
        'urn:mace:dir:attribute-def:personalSignature': 'personalSignature',
        'urn:mace:dir:attribute-def:personalTitle': 'personalTitle',
        'urn:mace:dir:attribute-def:photo': 'photo',
        'urn:mace:dir:attribute-def:physicalDeliveryOfficeName': 'physicalDeliveryOfficeName',
        'urn:mace:dir:attribute-def:pkcs9email': 'pkcs9email',
        'urn:mace:dir:attribute-def:postOfficeBox': 'postOfficeBox',
        'urn:mace:dir:attribute-def:postalAddress': 'postalAddress',
        'urn:mace:dir:attribute-def:postalCode': 'postalCode',
        'urn:mace:dir:attribute-def:preferredDeliveryMethod': 'preferredDeliveryMethod',
        'urn:mace:dir:attribute-def:preferredLanguage': 'preferredLanguage',
        'urn:mace:dir:attribute-def:presentationAddress': 'presentationAddress',
        'urn:mace:dir:attribute-def:protocolInformation': 'protocolInformation',
        'urn:mace:dir:attribute-def:pseudonym': 'pseudonym',
        'urn:mace:dir:attribute-def:registeredAddress': 'registeredAddress',
        'urn:mace:dir:attribute-def:rfc822Mailbox': 'rfc822Mailbox',
        'urn:mace:dir:attribute-def:roleOccupant': 'roleOccupant',
        'urn:mace:dir:attribute-def:roomNumber': 'roomNumber',
        'urn:mace:dir:attribute-def:sOARecord': 'sOARecord',
        'urn:mace:dir:attribute-def:searchGuide': 'searchGuide',
        'urn:mace:dir:attribute-def:secretary': 'secretary',
        'urn:mace:dir:attribute-def:seeAlso': 'seeAlso',
        'urn:mace:dir:attribute-def:serialNumber': 'serialNumber',
        'urn:mace:dir:attribute-def:singleLevelQuality': 'singleLevelQuality',
        'urn:mace:dir:attribute-def:sn': 'sn',
        'urn:mace:dir:attribute-def:st': 'st',
        'urn:mace:dir:attribute-def:stateOrProvinceName': 'stateOrProvinceName',
        'urn:mace:dir:attribute-def:street': 'street',
        'urn:mace:dir:attribute-def:streetAddress': 'streetAddress',
        'urn:mace:dir:attribute-def:subtreeMaximumQuality': 'subtreeMaximumQuality',
        'urn:mace:dir:attribute-def:subtreeMinimumQuality': 'subtreeMinimumQuality',
        'urn:mace:dir:attribute-def:supportedAlgorithms': 'supportedAlgorithms',
        'urn:mace:dir:attribute-def:supportedApplicationContext': 'supportedApplicationContext',
        'urn:mace:dir:attribute-def:surname': 'surname',
        'urn:mace:dir:attribute-def:telephoneNumber': 'telephoneNumber',
        'urn:mace:dir:attribute-def:teletexTerminalIdentifier': 'teletexTerminalIdentifier',
        'urn:mace:dir:attribute-def:telexNumber': 'telexNumber',
        'urn:mace:dir:attribute-def:textEncodedORAddress': 'textEncodedORAddress',
        'urn:mace:dir:attribute-def:title': 'title',
        'urn:mace:dir:attribute-def:uid': 'uid',
        'urn:mace:dir:attribute-def:uniqueIdentifier': 'uniqueIdentifier',
        'urn:mace:dir:attribute-def:uniqueMember': 'uniqueMember',
        'urn:mace:dir:attribute-def:userCertificate': 'userCertificate',
        'urn:mace:dir:attribute-def:userClass': 'userClass',
        'urn:mace:dir:attribute-def:userPKCS12': 'userPKCS12',
        'urn:mace:dir:attribute-def:userPassword': 'userPassword',
        'urn:mace:dir:attribute-def:userSMIMECertificate': 'userSMIMECertificate',
        'urn:mace:dir:attribute-def:userid': 'userid',
        'urn:mace:dir:attribute-def:x121Address': 'x121Address',
        'urn:mace:dir:attribute-def:x500UniqueIdentifier': 'x500UniqueIdentifier',
        },
    "to": {
        'aRecord': 'urn:mace:dir:attribute-def:aRecord',
        'aliasedEntryName': 'urn:mace:dir:attribute-def:aliasedEntryName',
        'aliasedObjectName': 'urn:mace:dir:attribute-def:aliasedObjectName',
        'associatedDomain': 'urn:mace:dir:attribute-def:associatedDomain',
        'associatedName': 'urn:mace:dir:attribute-def:associatedName',
        'audio': 'urn:mace:dir:attribute-def:audio',
        'authorityRevocationList': 'urn:mace:dir:attribute-def:authorityRevocationList',
        'buildingName': 'urn:mace:dir:attribute-def:buildingName',
        'businessCategory': 'urn:mace:dir:attribute-def:businessCategory',
        'c': 'urn:mace:dir:attribute-def:c',
        'cACertificate': 'urn:mace:dir:attribute-def:cACertificate',
        'cNAMERecord': 'urn:mace:dir:attribute-def:cNAMERecord',
        'carLicense': 'urn:mace:dir:attribute-def:carLicense',
        'certificateRevocationList': 'urn:mace:dir:attribute-def:certificateRevocationList',
        'cn': 'urn:mace:dir:attribute-def:cn',
        'co': 'urn:mace:dir:attribute-def:co',
        'commonName': 'urn:mace:dir:attribute-def:commonName',
        'countryName': 'urn:mace:dir:attribute-def:countryName',
        'crossCertificatePair': 'urn:mace:dir:attribute-def:crossCertificatePair',
        'dITRedirect': 'urn:mace:dir:attribute-def:dITRedirect',
        'dSAQuality': 'urn:mace:dir:attribute-def:dSAQuality',
        'dc': 'urn:mace:dir:attribute-def:dc',
        'deltaRevocationList': 'urn:mace:dir:attribute-def:deltaRevocationList',
        'departmentNumber': 'urn:mace:dir:attribute-def:departmentNumber',
        'description': 'urn:mace:dir:attribute-def:description',
        'destinationIndicator': 'urn:mace:dir:attribute-def:destinationIndicator',
        'displayName': 'urn:mace:dir:attribute-def:displayName',
        'distinguishedName': 'urn:mace:dir:attribute-def:distinguishedName',
        'dmdName': 'urn:mace:dir:attribute-def:dmdName',
        'dnQualifier': 'urn:mace:dir:attribute-def:dnQualifier',
        'documentAuthor': 'urn:mace:dir:attribute-def:documentAuthor',
        'documentIdentifier': 'urn:mace:dir:attribute-def:documentIdentifier',
        'documentLocation': 'urn:mace:dir:attribute-def:documentLocation',
        'documentPublisher': 'urn:mace:dir:attribute-def:documentPublisher',
        'documentTitle': 'urn:mace:dir:attribute-def:documentTitle',
        'documentVersion': 'urn:mace:dir:attribute-def:documentVersion',
        'domainComponent': 'urn:mace:dir:attribute-def:domainComponent',
        'drink': 'urn:mace:dir:attribute-def:drink',
        'eduOrgHomePageURI': 'urn:mace:dir:attribute-def:eduOrgHomePageURI',
        'eduOrgIdentityAuthNPolicyURI': 'urn:mace:dir:attribute-def:eduOrgIdentityAuthNPolicyURI',
        'eduOrgLegalName': 'urn:mace:dir:attribute-def:eduOrgLegalName',
        'eduOrgSuperiorURI': 'urn:mace:dir:attribute-def:eduOrgSuperiorURI',
        'eduOrgWhitePagesURI': 'urn:mace:dir:attribute-def:eduOrgWhitePagesURI',
        'eduPersonAffiliation': 'urn:mace:dir:attribute-def:eduPersonAffiliation',
        'eduPersonEntitlement': 'urn:mace:dir:attribute-def:eduPersonEntitlement',
        'eduPersonNickname': 'urn:mace:dir:attribute-def:eduPersonNickname',
        'eduPersonOrgDN': 'urn:mace:dir:attribute-def:eduPersonOrgDN',
        'eduPersonOrgUnitDN': 'urn:mace:dir:attribute-def:eduPersonOrgUnitDN',
        'eduPersonPrimaryAffiliation': 'urn:mace:dir:attribute-def:eduPersonPrimaryAffiliation',
        'eduPersonPrimaryOrgUnitDN': 'urn:mace:dir:attribute-def:eduPersonPrimaryOrgUnitDN',
        'eduPersonPrincipalName': 'urn:mace:dir:attribute-def:eduPersonPrincipalName',
        'eduPersonScopedAffiliation': 'urn:mace:dir:attribute-def:eduPersonScopedAffiliation',
        'eduPersonTargetedID': 'urn:mace:dir:attribute-def:eduPersonTargetedID',
        'email': 'urn:mace:dir:attribute-def:email',
        'emailAddress': 'urn:mace:dir:attribute-def:emailAddress',
        'employeeNumber': 'urn:mace:dir:attribute-def:employeeNumber',
        'employeeType': 'urn:mace:dir:attribute-def:employeeType',
        'enhancedSearchGuide': 'urn:mace:dir:attribute-def:enhancedSearchGuide',
        'facsimileTelephoneNumber': 'urn:mace:dir:attribute-def:facsimileTelephoneNumber',
        'favouriteDrink': 'urn:mace:dir:attribute-def:favouriteDrink',
        'fax': 'urn:mace:dir:attribute-def:fax',
        'federationFeideSchemaVersion': 'urn:mace:dir:attribute-def:federationFeideSchemaVersion',
        'friendlyCountryName': 'urn:mace:dir:attribute-def:friendlyCountryName',
        'generationQualifier': 'urn:mace:dir:attribute-def:generationQualifier',
        'givenName': 'urn:mace:dir:attribute-def:givenName',
        'gn': 'urn:mace:dir:attribute-def:gn',
        'homePhone': 'urn:mace:dir:attribute-def:homePhone',
        'homePostalAddress': 'urn:mace:dir:attribute-def:homePostalAddress',
        'homeTelephoneNumber': 'urn:mace:dir:attribute-def:homeTelephoneNumber',
        'host': 'urn:mace:dir:attribute-def:host',
        'houseIdentifier': 'urn:mace:dir:attribute-def:houseIdentifier',
        'info': 'urn:mace:dir:attribute-def:info',
        'initials': 'urn:mace:dir:attribute-def:initials',
        'internationaliSDNNumber': 'urn:mace:dir:attribute-def:internationaliSDNNumber',
        'janetMailbox': 'urn:mace:dir:attribute-def:janetMailbox',
        'jpegPhoto': 'urn:mace:dir:attribute-def:jpegPhoto',
        'knowledgeInformation': 'urn:mace:dir:attribute-def:knowledgeInformation',
        'l': 'urn:mace:dir:attribute-def:l',
        'labeledURI': 'urn:mace:dir:attribute-def:labeledURI',
        'localityName': 'urn:mace:dir:attribute-def:localityName',
        'mDRecord': 'urn:mace:dir:attribute-def:mDRecord',
        'mXRecord': 'urn:mace:dir:attribute-def:mXRecord',
        'mail': 'urn:mace:dir:attribute-def:mail',
        'mailPreferenceOption': 'urn:mace:dir:attribute-def:mailPreferenceOption',
        'manager': 'urn:mace:dir:attribute-def:manager',
        'member': 'urn:mace:dir:attribute-def:member',
        'mobile': 'urn:mace:dir:attribute-def:mobile',
        'mobileTelephoneNumber': 'urn:mace:dir:attribute-def:mobileTelephoneNumber',
        'nSRecord': 'urn:mace:dir:attribute-def:nSRecord',
        'name': 'urn:mace:dir:attribute-def:name',
        'norEduOrgAcronym': 'urn:mace:dir:attribute-def:norEduOrgAcronym',
        'norEduOrgNIN': 'urn:mace:dir:attribute-def:norEduOrgNIN',
        'norEduOrgSchemaVersion': 'urn:mace:dir:attribute-def:norEduOrgSchemaVersion',
        'norEduOrgUniqueIdentifier': 'urn:mace:dir:attribute-def:norEduOrgUniqueIdentifier',
        'norEduOrgUniqueNumber': 'urn:mace:dir:attribute-def:norEduOrgUniqueNumber',
        'norEduOrgUnitUniqueIdentifier': 'urn:mace:dir:attribute-def:norEduOrgUnitUniqueIdentifier',
        'norEduOrgUnitUniqueNumber': 'urn:mace:dir:attribute-def:norEduOrgUnitUniqueNumber',
        'norEduPersonBirthDate': 'urn:mace:dir:attribute-def:norEduPersonBirthDate',
        'norEduPersonLIN': 'urn:mace:dir:attribute-def:norEduPersonLIN',
        'norEduPersonNIN': 'urn:mace:dir:attribute-def:norEduPersonNIN',
        'o': 'urn:mace:dir:attribute-def:o',
        'objectClass': 'urn:mace:dir:attribute-def:objectClass',
        'organizationName': 'urn:mace:dir:attribute-def:organizationName',
        'organizationalStatus': 'urn:mace:dir:attribute-def:organizationalStatus',
        'organizationalUnitName': 'urn:mace:dir:attribute-def:organizationalUnitName',
        'otherMailbox': 'urn:mace:dir:attribute-def:otherMailbox',
        'ou': 'urn:mace:dir:attribute-def:ou',
        'owner': 'urn:mace:dir:attribute-def:owner',
        'pager': 'urn:mace:dir:attribute-def:pager',
        'pagerTelephoneNumber': 'urn:mace:dir:attribute-def:pagerTelephoneNumber',
        'personalSignature': 'urn:mace:dir:attribute-def:personalSignature',
        'personalTitle': 'urn:mace:dir:attribute-def:personalTitle',
        'photo': 'urn:mace:dir:attribute-def:photo',
        'physicalDeliveryOfficeName': 'urn:mace:dir:attribute-def:physicalDeliveryOfficeName',
        'pkcs9email': 'urn:mace:dir:attribute-def:pkcs9email',
        'postOfficeBox': 'urn:mace:dir:attribute-def:postOfficeBox',
        'postalAddress': 'urn:mace:dir:attribute-def:postalAddress',
        'postalCode': 'urn:mace:dir:attribute-def:postalCode',
        'preferredDeliveryMethod': 'urn:mace:dir:attribute-def:preferredDeliveryMethod',
        'preferredLanguage': 'urn:mace:dir:attribute-def:preferredLanguage',
        'presentationAddress': 'urn:mace:dir:attribute-def:presentationAddress',
        'protocolInformation': 'urn:mace:dir:attribute-def:protocolInformation',
        'pseudonym': 'urn:mace:dir:attribute-def:pseudonym',
        'registeredAddress': 'urn:mace:dir:attribute-def:registeredAddress',
        'rfc822Mailbox': 'urn:mace:dir:attribute-def:rfc822Mailbox',
        'roleOccupant': 'urn:mace:dir:attribute-def:roleOccupant',
        'roomNumber': 'urn:mace:dir:attribute-def:roomNumber',
        'sOARecord': 'urn:mace:dir:attribute-def:sOARecord',
        'searchGuide': 'urn:mace:dir:attribute-def:searchGuide',
        'secretary': 'urn:mace:dir:attribute-def:secretary',
        'seeAlso': 'urn:mace:dir:attribute-def:seeAlso',
        'serialNumber': 'urn:mace:dir:attribute-def:serialNumber',
        'singleLevelQuality': 'urn:mace:dir:attribute-def:singleLevelQuality',
        'sn': 'urn:mace:dir:attribute-def:sn',
        'st': 'urn:mace:dir:attribute-def:st',
        'stateOrProvinceName': 'urn:mace:dir:attribute-def:stateOrProvinceName',
        'street': 'urn:mace:dir:attribute-def:street',
        'streetAddress': 'urn:mace:dir:attribute-def:streetAddress',
        'subtreeMaximumQuality': 'urn:mace:dir:attribute-def:subtreeMaximumQuality',
        'subtreeMinimumQuality': 'urn:mace:dir:attribute-def:subtreeMinimumQuality',
        'supportedAlgorithms': 'urn:mace:dir:attribute-def:supportedAlgorithms',
        'supportedApplicationContext': 'urn:mace:dir:attribute-def:supportedApplicationContext',
        'surname': 'urn:mace:dir:attribute-def:surname',
        'telephoneNumber': 'urn:mace:dir:attribute-def:telephoneNumber',
        'teletexTerminalIdentifier': 'urn:mace:dir:attribute-def:teletexTerminalIdentifier',
        'telexNumber': 'urn:mace:dir:attribute-def:telexNumber',
        'textEncodedORAddress': 'urn:mace:dir:attribute-def:textEncodedORAddress',
        'title': 'urn:mace:dir:attribute-def:title',
        'uid': 'urn:mace:dir:attribute-def:uid',
        'uniqueIdentifier': 'urn:mace:dir:attribute-def:uniqueIdentifier',
        'uniqueMember': 'urn:mace:dir:attribute-def:uniqueMember',
        'userCertificate': 'urn:mace:dir:attribute-def:userCertificate',
        'userClass': 'urn:mace:dir:attribute-def:userClass',
        'userPKCS12': 'urn:mace:dir:attribute-def:userPKCS12',
        'userPassword': 'urn:mace:dir:attribute-def:userPassword',
        'userSMIMECertificate': 'urn:mace:dir:attribute-def:userSMIMECertificate',
        'userid': 'urn:mace:dir:attribute-def:userid',
        'x121Address': 'urn:mace:dir:attribute-def:x121Address',
        'x500UniqueIdentifier': 'urn:mace:dir:attribute-def:x500UniqueIdentifier',
    }
}
########NEW FILE########
__FILENAME__ = saml_uri
__author__ = 'rolandh'

EDUPERSON_OID = "urn:oid:1.3.6.1.4.1.5923.1.1.1."
X500ATTR_OID = "urn:oid:2.5.4."
NOREDUPERSON_OID = "urn:oid:1.3.6.1.4.1.2428.90.1."
NETSCAPE_LDAP = "urn:oid:2.16.840.1.113730.3.1."
UCL_DIR_PILOT = 'urn:oid:0.9.2342.19200300.100.1.'
PKCS_9 = "urn:oid:1.2.840.113549.1.9.1."
UMICH = "urn:oid:1.3.6.1.4.1.250.1.57."

MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
    "fro": {
        EDUPERSON_OID+'2': 'eduPersonNickname',
        EDUPERSON_OID+'9': 'eduPersonScopedAffiliation',
        EDUPERSON_OID+'11': 'eduPersonAssurance',
        EDUPERSON_OID+'10': 'eduPersonTargetedID',
        EDUPERSON_OID+'4': 'eduPersonOrgUnitDN',
        NOREDUPERSON_OID+'6': 'norEduOrgAcronym',
        NOREDUPERSON_OID+'7': 'norEduOrgUniqueIdentifier',
        NOREDUPERSON_OID+'4': 'norEduPersonLIN',
        EDUPERSON_OID+'1': 'eduPersonAffiliation',
        NOREDUPERSON_OID+'2': 'norEduOrgUnitUniqueNumber',
        NETSCAPE_LDAP+'40': 'userSMIMECertificate',
        NOREDUPERSON_OID+'1': 'norEduOrgUniqueNumber',
        NETSCAPE_LDAP+'241': 'displayName',
        UCL_DIR_PILOT+'37': 'associatedDomain',
        EDUPERSON_OID+'6': 'eduPersonPrincipalName',
        NOREDUPERSON_OID+'8': 'norEduOrgUnitUniqueIdentifier',
        NOREDUPERSON_OID+'9': 'federationFeideSchemaVersion',
        X500ATTR_OID+'53': 'deltaRevocationList',
        X500ATTR_OID+'52': 'supportedAlgorithms',
        X500ATTR_OID+'51': 'houseIdentifier',
        X500ATTR_OID+'50': 'uniqueMember',
        X500ATTR_OID+'19': 'physicalDeliveryOfficeName',
        X500ATTR_OID+'18': 'postOfficeBox',
        X500ATTR_OID+'17': 'postalCode',
        X500ATTR_OID+'16': 'postalAddress',
        X500ATTR_OID+'15': 'businessCategory',
        X500ATTR_OID+'14': 'searchGuide',
        EDUPERSON_OID+'5': 'eduPersonPrimaryAffiliation',
        X500ATTR_OID+'12': 'title',
        X500ATTR_OID+'11': 'ou',
        X500ATTR_OID+'10': 'o',
        X500ATTR_OID+'37': 'cACertificate',
        X500ATTR_OID+'36': 'userCertificate',
        X500ATTR_OID+'31': 'member',
        X500ATTR_OID+'30': 'supportedApplicationContext',
        X500ATTR_OID+'33': 'roleOccupant',
        X500ATTR_OID+'32': 'owner',
        NETSCAPE_LDAP+'1': 'carLicense',
        PKCS_9+'1': 'email',
        NETSCAPE_LDAP+'3': 'employeeNumber',
        NETSCAPE_LDAP+'2': 'departmentNumber',
        X500ATTR_OID+'39': 'certificateRevocationList',
        X500ATTR_OID+'38': 'authorityRevocationList',
        NETSCAPE_LDAP+'216': 'userPKCS12',
        EDUPERSON_OID+'8': 'eduPersonPrimaryOrgUnitDN',
        X500ATTR_OID+'9': 'street',
        X500ATTR_OID+'8': 'st',
        NETSCAPE_LDAP+'39': 'preferredLanguage',
        EDUPERSON_OID+'7': 'eduPersonEntitlement',
        X500ATTR_OID+'2': 'knowledgeInformation',
        X500ATTR_OID+'7': 'l',
        X500ATTR_OID+'6': 'c',
        X500ATTR_OID+'5': 'serialNumber',
        X500ATTR_OID+'4': 'sn',
        UCL_DIR_PILOT+'60': 'jpegPhoto',
        X500ATTR_OID+'65': 'pseudonym',
        NOREDUPERSON_OID+'5': 'norEduPersonNIN',
        UCL_DIR_PILOT+'3': 'mail',
        UCL_DIR_PILOT+'25': 'dc',
        X500ATTR_OID+'40': 'crossCertificatePair',
        X500ATTR_OID+'42': 'givenName',
        X500ATTR_OID+'43': 'initials',
        X500ATTR_OID+'44': 'generationQualifier',
        X500ATTR_OID+'45': 'x500UniqueIdentifier',
        X500ATTR_OID+'46': 'dnQualifier',
        X500ATTR_OID+'47': 'enhancedSearchGuide',
        X500ATTR_OID+'48': 'protocolInformation',
        X500ATTR_OID+'54': 'dmdName',
        NETSCAPE_LDAP+'4': 'employeeType',
        X500ATTR_OID+'22': 'teletexTerminalIdentifier',
        X500ATTR_OID+'23': 'facsimileTelephoneNumber',
        X500ATTR_OID+'20': 'telephoneNumber',
        X500ATTR_OID+'21': 'telexNumber',
        X500ATTR_OID+'26': 'registeredAddress',
        X500ATTR_OID+'27': 'destinationIndicator',
        X500ATTR_OID+'24': 'x121Address',
        X500ATTR_OID+'25': 'internationaliSDNNumber',
        X500ATTR_OID+'28': 'preferredDeliveryMethod',
        X500ATTR_OID+'29': 'presentationAddress',
        EDUPERSON_OID+'3': 'eduPersonOrgDN',
        NOREDUPERSON_OID+'3': 'norEduPersonBirthDate',
        UMICH+'57': 'labeledURI',
        UCL_DIR_PILOT+'1': 'uid',
    },
    "to": {
        'roleOccupant': X500ATTR_OID+'33',
        'gn': X500ATTR_OID+'42',
        'norEduPersonNIN': NOREDUPERSON_OID+'5',
        'title': X500ATTR_OID+'12',
        'facsimileTelephoneNumber': X500ATTR_OID+'23',
        'mail': UCL_DIR_PILOT+'3',
        'postOfficeBox': X500ATTR_OID+'18',
        'fax': X500ATTR_OID+'23',
        'telephoneNumber': X500ATTR_OID+'20',
        'norEduPersonBirthDate': NOREDUPERSON_OID+'3',
        'rfc822Mailbox': UCL_DIR_PILOT+'3',
        'dc': UCL_DIR_PILOT+'25',
        'countryName': X500ATTR_OID+'6',
        'emailAddress': PKCS_9+'1',
        'employeeNumber': NETSCAPE_LDAP+'3',
        'organizationName': X500ATTR_OID+'10',
        'eduPersonAssurance': EDUPERSON_OID+'11',
        'norEduOrgAcronym': NOREDUPERSON_OID+'6',
        'registeredAddress': X500ATTR_OID+'26',
        'physicalDeliveryOfficeName': X500ATTR_OID+'19',
        'associatedDomain': UCL_DIR_PILOT+'37',
        'l': X500ATTR_OID+'7',
        'stateOrProvinceName': X500ATTR_OID+'8',
        'federationFeideSchemaVersion': NOREDUPERSON_OID+'9',
        'pkcs9email': PKCS_9+'1',
        'givenName': X500ATTR_OID+'42',
        'givenname': X500ATTR_OID+'42',
        'x500UniqueIdentifier': X500ATTR_OID+'45',
        'eduPersonNickname': EDUPERSON_OID+'2',
        'houseIdentifier': X500ATTR_OID+'51',
        'street': X500ATTR_OID+'9',
        'supportedAlgorithms': X500ATTR_OID+'52',
        'preferredLanguage': NETSCAPE_LDAP+'39',
        'postalAddress': X500ATTR_OID+'16',
        'email': PKCS_9+'1',
        'norEduOrgUnitUniqueIdentifier': NOREDUPERSON_OID+'8',
        'eduPersonPrimaryOrgUnitDN': EDUPERSON_OID+'8',
        'c': X500ATTR_OID+'6',
        'teletexTerminalIdentifier': X500ATTR_OID+'22',
        'o': X500ATTR_OID+'10',
        'cACertificate': X500ATTR_OID+'37',
        'telexNumber': X500ATTR_OID+'21',
        'ou': X500ATTR_OID+'11',
        'initials': X500ATTR_OID+'43',
        'eduPersonOrgUnitDN': EDUPERSON_OID+'4',
        'deltaRevocationList': X500ATTR_OID+'53',
        'norEduPersonLIN': NOREDUPERSON_OID+'4',
        'supportedApplicationContext': X500ATTR_OID+'30',
        'eduPersonEntitlement': EDUPERSON_OID+'7',
        'generationQualifier': X500ATTR_OID+'44',
        'eduPersonAffiliation': EDUPERSON_OID+'1',
        'eduPersonPrincipalName': EDUPERSON_OID+'6',
        'edupersonprincipalname': EDUPERSON_OID+'6',
        'localityName': X500ATTR_OID+'7',
        'owner': X500ATTR_OID+'32',
        'norEduOrgUnitUniqueNumber': NOREDUPERSON_OID+'2',
        'searchGuide': X500ATTR_OID+'14',
        'certificateRevocationList': X500ATTR_OID+'39',
        'organizationalUnitName': X500ATTR_OID+'11',
        'userCertificate': X500ATTR_OID+'36',
        'preferredDeliveryMethod': X500ATTR_OID+'28',
        'internationaliSDNNumber': X500ATTR_OID+'25',
        'uniqueMember': X500ATTR_OID+'50',
        'departmentNumber': NETSCAPE_LDAP+'2',
        'enhancedSearchGuide': X500ATTR_OID+'47',
        'userPKCS12': NETSCAPE_LDAP+'216',
        'eduPersonTargetedID': EDUPERSON_OID+'10',
        'norEduOrgUniqueNumber': NOREDUPERSON_OID+'1',
        'x121Address': X500ATTR_OID+'24',
        'destinationIndicator': X500ATTR_OID+'27',
        'eduPersonPrimaryAffiliation': EDUPERSON_OID+'5',
        'surname': X500ATTR_OID+'4',
        'jpegPhoto': UCL_DIR_PILOT+'60',
        'eduPersonScopedAffiliation': EDUPERSON_OID+'9',
        'edupersonscopedaffiliation': EDUPERSON_OID+'9',
        'protocolInformation': X500ATTR_OID+'48',
        'knowledgeInformation': X500ATTR_OID+'2',
        'employeeType': NETSCAPE_LDAP+'4',
        'userSMIMECertificate': NETSCAPE_LDAP+'40',
        'member': X500ATTR_OID+'31',
        'streetAddress': X500ATTR_OID+'9',
        'dmdName': X500ATTR_OID+'54',
        'postalCode': X500ATTR_OID+'17',
        'pseudonym': X500ATTR_OID+'65',
        'dnQualifier': X500ATTR_OID+'46',
        'crossCertificatePair': X500ATTR_OID+'40',
        'eduPersonOrgDN': EDUPERSON_OID+'3',
        'authorityRevocationList': X500ATTR_OID+'38',
        'displayName': NETSCAPE_LDAP+'241',
        'businessCategory': X500ATTR_OID+'15',
        'serialNumber': X500ATTR_OID+'5',
        'norEduOrgUniqueIdentifier': NOREDUPERSON_OID+'7',
        'st': X500ATTR_OID+'8',
        'carLicense': NETSCAPE_LDAP+'1',
        'presentationAddress': X500ATTR_OID+'29',
        'sn': X500ATTR_OID+'4',
        'domainComponent': UCL_DIR_PILOT+'25',
        'labeledURI': UMICH+'57',
        'uid': UCL_DIR_PILOT+'1'
    }
}  
########NEW FILE########
__FILENAME__ = shibboleth_uri
EDUPERSON_OID = "urn:oid:1.3.6.1.4.1.5923.1.1.1."
X500ATTR = "urn:oid:2.5.4."
NOREDUPERSON_OID = "urn:oid:1.3.6.1.4.1.2428.90.1."
NETSCAPE_LDAP = "urn:oid:2.16.840.1.113730.3.1."
UCL_DIR_PILOT = "urn:oid:0.9.2342.19200300.100.1."
PKCS_9 = "urn:oid:1.2.840.113549.1.9."
UMICH = "urn:oid:1.3.6.1.4.1.250.1.57."

MAP = {
    "identifier": "urn:mace:shibboleth:1.0:attributeNamespace:uri",
    "fro": {
        EDUPERSON_OID+'2': 'eduPersonNickname',
        EDUPERSON_OID+'9': 'eduPersonScopedAffiliation',
        EDUPERSON_OID+'11': 'eduPersonAssurance',
        EDUPERSON_OID+'10': 'eduPersonTargetedID',
        EDUPERSON_OID+'4': 'eduPersonOrgUnitDN',
        NOREDUPERSON_OID+'6': 'norEduOrgAcronym',
        NOREDUPERSON_OID+'7': 'norEduOrgUniqueIdentifier',
        NOREDUPERSON_OID+'4': 'norEduPersonLIN',
        EDUPERSON_OID+'1': 'eduPersonAffiliation',
        NOREDUPERSON_OID+'2': 'norEduOrgUnitUniqueNumber',
        NETSCAPE_LDAP+'40': 'userSMIMECertificate',
        NOREDUPERSON_OID+'1': 'norEduOrgUniqueNumber',
        NETSCAPE_LDAP+'241': 'displayName',
        UCL_DIR_PILOT+'37': 'associatedDomain',
        EDUPERSON_OID+'6': 'eduPersonPrincipalName',
        NOREDUPERSON_OID+'8': 'norEduOrgUnitUniqueIdentifier',
        NOREDUPERSON_OID+'9': 'federationFeideSchemaVersion',
        X500ATTR+'53': 'deltaRevocationList',
        X500ATTR+'52': 'supportedAlgorithms',
        X500ATTR+'51': 'houseIdentifier',
        X500ATTR+'50': 'uniqueMember',
        X500ATTR+'19': 'physicalDeliveryOfficeName',
        X500ATTR+'18': 'postOfficeBox',
        X500ATTR+'17': 'postalCode',
        X500ATTR+'16': 'postalAddress',
        X500ATTR+'15': 'businessCategory',
        X500ATTR+'14': 'searchGuide',
        EDUPERSON_OID+'5': 'eduPersonPrimaryAffiliation',
        X500ATTR+'12': 'title',
        X500ATTR+'11': 'ou',
        X500ATTR+'10': 'o',
        X500ATTR+'37': 'cACertificate',
        X500ATTR+'36': 'userCertificate',
        X500ATTR+'31': 'member',
        X500ATTR+'30': 'supportedApplicationContext',
        X500ATTR+'33': 'roleOccupant',
        X500ATTR+'32': 'owner',
        NETSCAPE_LDAP+'1': 'carLicense',
        PKCS_9+'1': 'email',
        NETSCAPE_LDAP+'3': 'employeeNumber',
        NETSCAPE_LDAP+'2': 'departmentNumber',
        X500ATTR+'39': 'certificateRevocationList',
        X500ATTR+'38': 'authorityRevocationList',
        NETSCAPE_LDAP+'216': 'userPKCS12',
        EDUPERSON_OID+'8': 'eduPersonPrimaryOrgUnitDN',
        X500ATTR+'9': 'street',
        X500ATTR+'8': 'st',
        NETSCAPE_LDAP+'39': 'preferredLanguage',
        EDUPERSON_OID+'7': 'eduPersonEntitlement',
        X500ATTR+'2': 'knowledgeInformation',
        X500ATTR+'7': 'l',
        X500ATTR+'6': 'c',
        X500ATTR+'5': 'serialNumber',
        X500ATTR+'4': 'sn',
        UCL_DIR_PILOT+'60': 'jpegPhoto',
        X500ATTR+'65': 'pseudonym',
        NOREDUPERSON_OID+'5': 'norEduPersonNIN',
        UCL_DIR_PILOT+'3': 'mail',
        UCL_DIR_PILOT+'25': 'dc',
        X500ATTR+'40': 'crossCertificatePair',
        X500ATTR+'42': 'givenName',
        X500ATTR+'43': 'initials',
        X500ATTR+'44': 'generationQualifier',
        X500ATTR+'45': 'x500UniqueIdentifier',
        X500ATTR+'46': 'dnQualifier',
        X500ATTR+'47': 'enhancedSearchGuide',
        X500ATTR+'48': 'protocolInformation',
        X500ATTR+'54': 'dmdName',
        NETSCAPE_LDAP+'4': 'employeeType',
        X500ATTR+'22': 'teletexTerminalIdentifier',
        X500ATTR+'23': 'facsimileTelephoneNumber',
        X500ATTR+'20': 'telephoneNumber',
        X500ATTR+'21': 'telexNumber',
        X500ATTR+'26': 'registeredAddress',
        X500ATTR+'27': 'destinationIndicator',
        X500ATTR+'24': 'x121Address',
        X500ATTR+'25': 'internationaliSDNNumber',
        X500ATTR+'28': 'preferredDeliveryMethod',
        X500ATTR+'29': 'presentationAddress',
        EDUPERSON_OID+'3': 'eduPersonOrgDN',
        NOREDUPERSON_OID+'3': 'norEduPersonBirthDate',
    },
    "to":{
        'roleOccupant': X500ATTR+'33',
        'gn': X500ATTR+'42',
        'norEduPersonNIN': NOREDUPERSON_OID+'5',
        'title': X500ATTR+'12',
        'facsimileTelephoneNumber': X500ATTR+'23',
        'mail': UCL_DIR_PILOT+'3',
        'postOfficeBox': X500ATTR+'18',
        'fax': X500ATTR+'23',
        'telephoneNumber': X500ATTR+'20',
        'norEduPersonBirthDate': NOREDUPERSON_OID+'3',
        'rfc822Mailbox': UCL_DIR_PILOT+'3',
        'dc': UCL_DIR_PILOT+'25',
        'countryName': X500ATTR+'6',
        'emailAddress': PKCS_9+'1',
        'employeeNumber': NETSCAPE_LDAP+'3',
        'organizationName': X500ATTR+'10',
        'eduPersonAssurance': EDUPERSON_OID+'11',
        'norEduOrgAcronym': NOREDUPERSON_OID+'6',
        'registeredAddress': X500ATTR+'26',
        'physicalDeliveryOfficeName': X500ATTR+'19',
        'associatedDomain': UCL_DIR_PILOT+'37',
        'l': X500ATTR+'7',
        'stateOrProvinceName': X500ATTR+'8',
        'federationFeideSchemaVersion': NOREDUPERSON_OID+'9',
        'pkcs9email': PKCS_9+'1',
        'givenName': X500ATTR+'42',
        'x500UniqueIdentifier': X500ATTR+'45',
        'eduPersonNickname': EDUPERSON_OID+'2',
        'houseIdentifier': X500ATTR+'51',
        'street': X500ATTR+'9',
        'supportedAlgorithms': X500ATTR+'52',
        'preferredLanguage': NETSCAPE_LDAP+'39',
        'postalAddress': X500ATTR+'16',
        'email': PKCS_9+'1',
        'norEduOrgUnitUniqueIdentifier': NOREDUPERSON_OID+'8',
        'eduPersonPrimaryOrgUnitDN': EDUPERSON_OID+'8',
        'c': X500ATTR+'6',
        'teletexTerminalIdentifier': X500ATTR+'22',
        'o': X500ATTR+'10',
        'cACertificate': X500ATTR+'37',
        'telexNumber': X500ATTR+'21',
        'ou': X500ATTR+'11',
        'initials': X500ATTR+'43',
        'eduPersonOrgUnitDN': EDUPERSON_OID+'4',
        'deltaRevocationList': X500ATTR+'53',
        'norEduPersonLIN': NOREDUPERSON_OID+'4',
        'supportedApplicationContext': X500ATTR+'30',
        'eduPersonEntitlement': EDUPERSON_OID+'7',
        'generationQualifier': X500ATTR+'44',
        'eduPersonAffiliation': EDUPERSON_OID+'1',
        'eduPersonPrincipalName': EDUPERSON_OID+'6',
        'localityName': X500ATTR+'7',
        'owner': X500ATTR+'32',
        'norEduOrgUnitUniqueNumber': NOREDUPERSON_OID+'2',
        'searchGuide': X500ATTR+'14',
        'certificateRevocationList': X500ATTR+'39',
        'organizationalUnitName': X500ATTR+'11',
        'userCertificate': X500ATTR+'36',
        'preferredDeliveryMethod': X500ATTR+'28',
        'internationaliSDNNumber': X500ATTR+'25',
        'uniqueMember': X500ATTR+'50',
        'departmentNumber': NETSCAPE_LDAP+'2',
        'enhancedSearchGuide': X500ATTR+'47',
        'userPKCS12': NETSCAPE_LDAP+'216',
        'eduPersonTargetedID': EDUPERSON_OID+'10',
        'norEduOrgUniqueNumber': NOREDUPERSON_OID+'1',
        'x121Address': X500ATTR+'24',
        'destinationIndicator': X500ATTR+'27',
        'eduPersonPrimaryAffiliation': EDUPERSON_OID+'5',
        'surname': X500ATTR+'4',
        'jpegPhoto': UCL_DIR_PILOT+'60',
        'eduPersonScopedAffiliation': EDUPERSON_OID+'9',
        'protocolInformation': X500ATTR+'48',
        'knowledgeInformation': X500ATTR+'2',
        'employeeType': NETSCAPE_LDAP+'4',
        'userSMIMECertificate': NETSCAPE_LDAP+'40',
        'member': X500ATTR+'31',
        'streetAddress': X500ATTR+'9',
        'dmdName': X500ATTR+'54',
        'postalCode': X500ATTR+'17',
        'pseudonym': X500ATTR+'65',
        'dnQualifier': X500ATTR+'46',
        'crossCertificatePair': X500ATTR+'40',
        'eduPersonOrgDN': EDUPERSON_OID+'3',
        'authorityRevocationList': X500ATTR+'38',
        'displayName': NETSCAPE_LDAP+'241',
        'businessCategory': X500ATTR+'15',
        'serialNumber': X500ATTR+'5',
        'norEduOrgUniqueIdentifier': NOREDUPERSON_OID+'7',
        'st': X500ATTR+'8',
        'carLicense': NETSCAPE_LDAP+'1',
        'presentationAddress': X500ATTR+'29',
        'sn': X500ATTR+'4',
        'domainComponent': UCL_DIR_PILOT+'25',
    }
}
########NEW FILE########
__FILENAME__ = certgeneration
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from saml2.cert import OpenSSLWrapper

__author__ = 'haho0032'


cert_info_ca = {
    "cn": "localhost.ca",
    "country_code": "se",
    "state": "ac",
    "city": "umea",
    "organization": "ITS Umea University",
    "organization_unit": "DIRG"
}

osw = OpenSSLWrapper()

ca_cert, ca_key = osw.create_certificate(cert_info_ca, request=False, write_to_file=True,
                                                cert_dir="./")
########NEW FILE########
__FILENAME__ = sp
#!/usr/bin/env python
from Cookie import SimpleCookie
import logging
import os
import sp_conf
from sp_conf import CONFIG
import re
import subprocess
from urlparse import parse_qs
import argparse
from saml2 import BINDING_HTTP_REDIRECT, time_util
from saml2.httputil import Response
from saml2.httputil import Unauthorized
from saml2.httputil import NotFound
from saml2.httputil import Redirect
#from saml2.httputil import ServiceError
from saml2.metadata import create_metadata_string
from saml2.metadata import entities_descriptor
from saml2.config import Config
from saml2.sigver import security_context

logger = logging.getLogger("saml2.SP")

args = None
# -----------------------------------------------------------------------------


def dict_to_table(ava, lev=0, width=1):
    txt = ['<table border=%s bordercolor="black">\n' % width]
    for prop, valarr in ava.items():
        txt.append("<tr>\n")
        if isinstance(valarr, basestring):
            txt.append("<th>%s</th>\n" % str(prop))
            try:
                txt.append("<td>%s</td>\n" % valarr.encode("utf8"))
            except AttributeError:
                txt.append("<td>%s</td>\n" % valarr)
        elif isinstance(valarr, list):
            i = 0
            n = len(valarr)       
            for val in valarr:
                if not i:
                    txt.append("<th rowspan=%d>%s</td>\n" % (len(valarr), prop))
                else:
                    txt.append("<tr>\n")
                if isinstance(val, dict):
                    txt.append("<td>\n")
                    txt.extend(dict_to_table(val, lev + 1, width - 1))
                    txt.append("</td>\n")
                else:
                    try:
                        txt.append("<td>%s</td>\n" % val.encode("utf8"))
                    except AttributeError:
                        txt.append("<td>%s</td>\n" % val)
                if n > 1:
                    txt.append("</tr>\n")
                n -= 1
                i += 1
        elif isinstance(valarr, dict):
            txt.append("<th>%s</th>\n" % prop)
            txt.append("<td>\n")
            txt.extend(dict_to_table(valarr, lev + 1, width - 1))
            txt.append("</td>\n")
        txt.append("</tr>\n")
    txt.append('</table>\n')
    return txt


def _expiration(timeout, tformat=None):
    if timeout == "now":
        return time_util.instant(tformat)
    else:
        # validity time should match lifetime of assertions
        return time_util.in_a_while(minutes=timeout, format=tformat)


def delete_cookie(environ, name):
    kaka = environ.get("HTTP_COOKIE", '')
    if kaka:
        cookie_obj = SimpleCookie(kaka)
        morsel = cookie_obj.get(name, None)
        cookie = SimpleCookie()
        cookie[name] = morsel
        cookie[name]["expires"] = _expiration("now",
                                              "%a, %d-%b-%Y %H:%M:%S CET")
        return tuple(cookie.output().split(": ", 1))
    return None

# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def whoami(environ, start_response, user):
    nameid = environ["repoze.who.identity"]["login"]
    ava = environ["repoze.who.identity"]["user"]
    if not nameid:
        return not_authn(environ, start_response)
    if ava:
        response = ["<h2>Your identity is supposed to be</h2>"]
        response.extend(dict_to_table(ava))
    else:
        response = [
            "<h2>The system did not return any information about you</h2>"]

    response.extend("<a href='logout'>Logout</a>")
    resp = Response(response)
    return resp(environ, start_response)
    

#noinspection PyUnusedLocal
def not_found(environ, start_response):
    """Called if no URL matches."""
    resp = NotFound('Not Found')
    return resp(environ, start_response)


#noinspection PyUnusedLocal
def not_authn(environ, start_response):
    resp = Unauthorized('Unknown user')
    return resp(environ, start_response)


#noinspection PyUnusedLocal
def slo(environ, start_response, user):
    # so here I might get either a LogoutResponse or a LogoutRequest
    client = environ['repoze.who.plugins']["saml2auth"]
    sc = client.saml_client

    if "QUERY_STRING" in environ:
        query = parse_qs(environ["QUERY_STRING"])
        logger.info("query: %s" % query)
        try:
            response = sc.parse_logout_request_response(
                query["SAMLResponse"][0], binding=BINDING_HTTP_REDIRECT)
            if response:
                logger.info("LOGOUT response parsed OK")
        except KeyError:
            # return error reply
            response = None

        if response is None:
            request = sc.lo

    headers = []
    delco = delete_cookie(environ, "pysaml2")
    if delco:
        headers.append(delco)
    resp = Redirect("/done", headers=headers)
    return resp(environ, start_response)
    

#noinspection PyUnusedLocal
def logout(environ, start_response, user):
    # This is where it starts when a user wants to log out
    client = environ['repoze.who.plugins']["saml2auth"]
    subject_id = environ["repoze.who.identity"]['repoze.who.userid']
    logger.info("[logout] subject_id: '%s'" % (subject_id,))
    target = "/done"

    # What if more than one
    _dict = client.saml_client.global_logout(subject_id)
    logger.info("[logout] global_logout > %s" % (_dict,))
    rem = environ['repoze.who.plugins'][client.rememberer_name]
    rem.forget(environ, subject_id)

    for key, item in _dict.items():
        if isinstance(item, tuple):
            binding, htargs = item
        else:  # result from logout, should be OK
            pass

    resp = Redirect("Successful Logout", headers=[("Location", target)])
    return resp(environ, start_response)
    # else:
    #     resp = ServiceError("Failed to logout from identity services")
    #     start_response("500 Internal Server Error")
    #     return []


#noinspection PyUnusedLocal
def done(environ, start_response, user):
    # remove cookie and stored info
    logger.info("[done] environ: %s" % environ)
    subject_id = environ["repoze.who.identity"]['repoze.who.userid']
    client = environ['repoze.who.plugins']["saml2auth"]
    logger.info("[logout done] remaining subjects: %s" % (
        client.saml_client.users.subjects(),))

    start_response('200 OK', [('Content-Type', 'text/html')])
    return ["<h3>You are now logged out from this service</h3>"]
        
# ----------------------------------------------------------------------------

# map urls to functions
urls = [
    (r'whoami$', whoami),
    (r'logout$', logout),
    (r'done$', done),
    (r'slo$', slo),
    (r'^$', whoami),
]

# ----------------------------------------------------------------------------

def metadata(environ, start_response):
    try:
        path = args.path
        if path is None or len(path) == 0:
            path = os.path.dirname(os.path.abspath( __file__ ))
        if path[-1] != "/":
            path += "/"
        metadata = create_metadata_string(path+"sp_conf.py", None,
                                          args.valid, args.cert, args.keyfile,
                                          args.id, args.name, args.sign)
        start_response('200 OK', [('Content-Type', "text/xml")])
        return metadata
    except Exception as ex:
        logger.error("An error occured while creating metadata:" + ex.message)
        return not_found(environ, start_response)

def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above and store the regular expression
    captures in the WSGI environment as `myapp.url_args` so that
    the functions from above can access the url placeholders.

    If nothing matches, call the `not_found` function.
    
    :param environ: The HTTP application environment
    :param start_response: The application to run when the handling of the 
        request is done
    :return: The response as a list of lines
    """
    path = environ.get('PATH_INFO', '').lstrip('/')
    logger.info("<application> PATH: %s" % path)

    if path == "metadata":
        return metadata(environ, start_response)

    user = environ.get("REMOTE_USER", "")
    if not user:
        user = environ.get("repoze.who.identity", "")
        logger.info("repoze.who.identity: '%s'" % user)
    else:
        logger.info("REMOTE_USER: '%s'" % user)
    #logger.info(logging.Logger.manager.loggerDict)
    for regex, callback in urls:
        if user:
            match = re.search(regex, path)
            if match is not None:
                try:
                    environ['myapp.url_args'] = match.groups()[0]
                except IndexError:
                    environ['myapp.url_args'] = path
                return callback(environ, start_response, user)
        else:
            return not_authn(environ, start_response)

    return not_found(environ, start_response)

# ----------------------------------------------------------------------------

from repoze.who.config import make_middleware_with_config

app_with_auth = make_middleware_with_config(application, {"here": "."},
                                            './who.ini',
                                            log_file="repoze_who.log")

# ----------------------------------------------------------------------------
HOST = sp_conf.HOST
PORT = sp_conf.PORT

# allow uwsgi or gunicorn mount
# by moving some initialization out of __name__ == '__main__' section.
# uwsgi -s 0.0.0.0:8087 --protocol http --callable app_with_auth --module idp

if __name__ == '__main__':
    #make_metadata arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', dest='path', help='Path to configuration file.')
    parser.add_argument('-v', dest='valid', default="4",
                        help="How long, in days, the metadata is valid from the time of creation")
    parser.add_argument('-c', dest='cert', help='certificate')
    parser.add_argument('-i', dest='id',
                        help="The ID of the entities descriptor in the metadata")
    parser.add_argument('-k', dest='keyfile',
                        help="A file with a key to sign the metadata with")
    parser.add_argument('-n', dest='name')
    parser.add_argument('-s', dest='sign', action='store_true',
                        help="sign the metadata")
    args = parser.parse_args()

    from wsgiref.simple_server import make_server
    srv = make_server(HOST, PORT, app_with_auth)
    print "SP listening on %s:%s" % (HOST, PORT)
    srv.serve_forever()

########NEW FILE########
__FILENAME__ = service_conf
from saml2.assertion import Policy

HOST = '127.0.0.1'
PORT = 8087
HTTPS = False

# Which groups of entity categories to use
POLICY = Policy(
    {
        "default": {"entity_categories": ["swamid", "edugain"]}
    }
)

# HTTPS cert information
SERVER_CERT = "pki/mycert.pem"
SERVER_KEY = "pki/mykey.pem"
CERT_CHAIN = ""

########NEW FILE########
__FILENAME__ = sp
#!/usr/bin/env python
import logging
import re
import argparse
import service_conf

from Cookie import SimpleCookie
from urlparse import parse_qs
import sys

from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_SOAP
from saml2 import time_util
from saml2 import ecp
from saml2 import BINDING_HTTP_ARTIFACT
from saml2 import BINDING_HTTP_POST
from saml2.client import Saml2Client
from saml2.ecp_client import PAOS_HEADER_INFO
from saml2.httputil import geturl, make_cookie, parse_cookie
from saml2.httputil import get_post
from saml2.httputil import Response
from saml2.httputil import BadRequest
from saml2.httputil import ServiceError
from saml2.httputil import SeeOther
from saml2.httputil import Unauthorized
from saml2.httputil import NotFound
from saml2.httputil import Redirect
from saml2.httputil import NotImplemented
from saml2.response import StatusError
from saml2.response import VerificationError
from saml2.s_utils import UnknownPrincipal
from saml2.s_utils import UnsupportedBinding
from saml2.s_utils import sid
from saml2.s_utils import rndstr
#from srtest import exception_trace

logger = logging.getLogger("")
hdlr = logging.FileHandler('spx.log')
base_formatter = logging.Formatter(
    "%(asctime)s %(name)s:%(levelname)s %(message)s")

hdlr.setFormatter(base_formatter)
logger.addHandler(hdlr)
logger.setLevel(logging.INFO)


SP = None
SEED = ""
POLICY = None


def dict_to_table(ava, lev=0, width=1):
    txt = ['<table border=%s bordercolor="black">\n' % width]
    for prop, valarr in ava.items():
        txt.append("<tr>\n")
        if isinstance(valarr, basestring):
            txt.append("<th>%s</th>\n" % str(prop))
            try:
                txt.append("<td>%s</td>\n" % valarr.encode("utf8"))
            except AttributeError:
                txt.append("<td>%s</td>\n" % valarr)
        elif isinstance(valarr, list):
            i = 0
            n = len(valarr)
            for val in valarr:
                if not i:
                    txt.append("<th rowspan=%d>%s</td>\n" % (len(valarr), prop))
                else:
                    txt.append("<tr>\n")
                if isinstance(val, dict):
                    txt.append("<td>\n")
                    txt.extend(dict_to_table(val, lev + 1, width - 1))
                    txt.append("</td>\n")
                else:
                    try:
                        txt.append("<td>%s</td>\n" % val.encode("utf8"))
                    except AttributeError:
                        txt.append("<td>%s</td>\n" % val)
                if n > 1:
                    txt.append("</tr>\n")
                n -= 1
                i += 1
        elif isinstance(valarr, dict):
            txt.append("<th>%s</th>\n" % prop)
            txt.append("<td>\n")
            txt.extend(dict_to_table(valarr, lev + 1, width - 1))
            txt.append("</td>\n")
        txt.append("</tr>\n")
    txt.append('</table>\n')
    return txt


def handle_static(environ, start_response, path):
    """
    Creates a response for a static file. There might be a longer path
    then just /static/... - if so strip the path leading up to static.

    :param environ: wsgi enviroment
    :param start_response: wsgi start response
    :param path: the static file and path to the file.
    :return: wsgi response for the static file.
    """
    try:
        text = open(path).read()
        if path.endswith(".ico"):
            resp = Response(text, headers=[('Content-Type', "image/x-icon")])
        elif path.endswith(".html"):
            resp = Response(text, headers=[('Content-Type', 'text/html')])
        elif path.endswith(".txt"):
            resp = Response(text, headers=[('Content-Type', 'text/plain')])
        elif path.endswith(".css"):
            resp = Response(text, headers=[('Content-Type', 'text/css')])
        elif path.endswith(".js"):
            resp = Response(text, headers=[('Content-Type', 'text/javascript')])
        elif path.endswith(".png"):
            resp = Response(text, headers=[('Content-Type', 'image/png')])
        else:
            resp = Response(text)
    except IOError:
        resp = NotFound()
    return resp(environ, start_response)


class ECPResponse(object):
    code = 200
    title = 'OK'

    def __init__(self, content):
        self.content = content

    #noinspection PyUnusedLocal
    def __call__(self, environ, start_response):
        start_response('%s %s' % (self.code, self.title),
                       [('Content-Type', "text/xml")])
        return [self.content]


def _expiration(timeout, tformat=None):
    # Wed, 06-Jun-2012 01:34:34 GMT
    if not tformat:
        tformat = '%a, %d-%b-%Y %T GMT'

    if timeout == "now":
        return time_util.instant(tformat)
    else:
        # validity time should match lifetime of assertions
        return time_util.in_a_while(minutes=timeout, format=tformat)


class Cache(object):
    def __init__(self):
        self.uid2user = {}
        self.cookie_name = "spauthn"
        self.outstanding_queries = {}
        self.relay_state = {}
        self.user = {}
        self.result = {}

    def kaka2user(self, kaka):
        logger.debug("KAKA: %s" % kaka)
        if kaka:
            cookie_obj = SimpleCookie(kaka)
            morsel = cookie_obj.get(self.cookie_name, None)
            if morsel:
                try:
                    return self.uid2user[morsel.value]
                except KeyError:
                    return None
            else:
                logger.debug("No spauthn cookie")
        return None

    def delete_cookie(self, environ=None, kaka=None):
        if not kaka:
            kaka = environ.get("HTTP_COOKIE", '')
        logger.debug("delete KAKA: %s" % kaka)
        if kaka:
            _name = self.cookie_name
            cookie_obj = SimpleCookie(kaka)
            morsel = cookie_obj.get(_name, None)
            cookie = SimpleCookie()
            cookie[_name] = ""
            cookie[_name]['path'] = "/"
            logger.debug("Expire: %s" % morsel)
            cookie[_name]["expires"] = _expiration("dawn")
            return tuple(cookie.output().split(": ", 1))
        return None

    def user2kaka(self, user):
        uid = rndstr(32)
        self.uid2user[uid] = user
        cookie = SimpleCookie()
        cookie[self.cookie_name] = uid
        cookie[self.cookie_name]['path'] = "/"
        cookie[self.cookie_name]["expires"] = _expiration(480)
        logger.debug("Cookie expires: %s" % cookie[self.cookie_name]["expires"])
        return tuple(cookie.output().split(": ", 1))


# -----------------------------------------------------------------------------
# RECEIVERS
# -----------------------------------------------------------------------------


class Service(object):
    def __init__(self, environ, start_response, user=None):
        self.environ = environ
        logger.debug("ENVIRON: %s" % environ)
        self.start_response = start_response
        self.user = user
        self.sp = None
        
    def unpack_redirect(self):
        if "QUERY_STRING" in self.environ:
            _qs = self.environ["QUERY_STRING"]
            return dict([(k, v[0]) for k, v in parse_qs(_qs).items()])
        else:
            return None

    def unpack_post(self):
        _dict = parse_qs(get_post(self.environ))
        logger.debug("unpack_post:: %s" % _dict)
        try:
            return dict([(k, v[0]) for k, v in _dict.items()])
        except Exception:
            return None

    def unpack_soap(self):
        try:
            query = get_post(self.environ)
            return {"SAMLResponse": query, "RelayState": ""}
        except Exception:
            return None

    def unpack_either(self):
        if self.environ["REQUEST_METHOD"] == "GET":
            _dict = self.unpack_redirect()
        elif self.environ["REQUEST_METHOD"] == "POST":
            _dict = self.unpack_post()
        else:
            _dict = None
        logger.debug("_dict: %s" % _dict)
        return _dict

    def operation(self, _dict, binding):
        logger.debug("_operation: %s" % _dict)
        if not _dict:
            resp = BadRequest('Error parsing request or no request')
            return resp(self.environ, self.start_response)
        else:
            try:
                _relay_state = _dict["RelayState"]
            except KeyError:
                _relay_state = ""
            if "SAMLResponse" in _dict:
                return self.do(_dict["SAMLResponse"], binding,
                               _relay_state, mtype="response")
            elif "SAMLRequest" in _dict:
                return self.do(_dict["SAMLRequest"], binding,
                               _relay_state, mtype="request")

    def artifact_operation(self, _dict):
        if not _dict:
            resp = BadRequest("Missing query")
            return resp(self.environ, self.start_response)
        else:
            # exchange artifact for response
            request = self.sp.artifact2message(_dict["SAMLart"], "spsso")
            return self.do(request, BINDING_HTTP_ARTIFACT, _dict["RelayState"])

    def response(self, binding, http_args):
        if binding == BINDING_HTTP_ARTIFACT:
            resp = Redirect()
        else:
            resp = Response(http_args["data"], headers=http_args["headers"])
        return resp(self.environ, self.start_response)

    def do(self, query, binding, relay_state="", mtype="response"):
        pass

    def redirect(self):
        """ Expects a HTTP-redirect response """

        _dict = self.unpack_redirect()
        return self.operation(_dict, BINDING_HTTP_REDIRECT)

    def post(self):
        """ Expects a HTTP-POST response """

        _dict = self.unpack_post()
        return self.operation(_dict, BINDING_HTTP_POST)

    def artifact(self):
        # Can be either by HTTP_Redirect or HTTP_POST
        _dict = self.unpack_either()
        return self.artifact_operation(_dict)

    def soap(self):
        """
        Single log out using HTTP_SOAP binding
        """
        logger.debug("- SOAP -")
        _dict = self.unpack_soap()
        logger.debug("_dict: %s" % _dict)
        return self.operation(_dict, BINDING_SOAP)

    def uri(self):
        _dict = self.unpack_either()
        return self.operation(_dict, BINDING_SOAP)

    def not_authn(self):
        resp = Unauthorized('Unknown user')
        return resp(self.environ, self.start_response)


# -----------------------------------------------------------------------------
#  Attribute Consuming service
# -----------------------------------------------------------------------------


class ACS(Service):
    def __init__(self, sp, environ, start_response, cache=None, **kwargs):
        Service.__init__(self, environ, start_response)
        self.sp = sp
        self.outstanding_queries = cache.outstanding_queries
        self.cache = cache
        self.response = None
        self.kwargs = kwargs

    def do(self, response, binding, relay_state="", mtype="response"):
        """
        :param response: The SAML response, transport encoded
        :param binding: Which binding the query came in over
        """
        #tmp_outstanding_queries = dict(self.outstanding_queries)
        if not response:
            logger.info("Missing Response")
            resp = Unauthorized('Unknown user')
            return resp(self.environ, self.start_response)

        try:
            self.response = self.sp.parse_authn_request_response(
                response, binding, self.outstanding_queries)
        except UnknownPrincipal, excp:
            logger.error("UnknownPrincipal: %s" % (excp,))
            resp = ServiceError("UnknownPrincipal: %s" % (excp,))
            return resp(self.environ, self.start_response)
        except UnsupportedBinding, excp:
            logger.error("UnsupportedBinding: %s" % (excp,))
            resp = ServiceError("UnsupportedBinding: %s" % (excp,))
            return resp(self.environ, self.start_response)
        except VerificationError, err:
            resp = ServiceError("Verification error: %s" % (err,))
            return resp(self.environ, self.start_response)
        except Exception, err:
            resp = ServiceError("Other error: %s" % (err,))
            return resp(self.environ, self.start_response)

        logger.info("AVA: %s" % self.response.ava)
        resp = Response(dict_to_table(self.response.ava))
        return resp(self.environ, self.start_response)

    def verify_attributes(self, ava):
        logger.info("SP: %s" % self.sp.config.entityid)
        rest = POLICY.get_entity_categories(
            self.sp.config.entityid, self.sp.metadata)

        akeys = [k.lower() for k in ava.keys()]

        res = {"less": [], "more": []}
        for key, attr in rest.items():
            if key not in ava:
                if key not in akeys:
                    res["less"].append(key)

        for key, attr in ava.items():
            _key = key.lower()
            if _key not in rest:
                res["more"].append(key)

        return res

# -----------------------------------------------------------------------------
# REQUESTERS
# -----------------------------------------------------------------------------


class SSO(object):
    def __init__(self, sp, environ, start_response, cache=None,
                 wayf=None, discosrv=None, bindings=None):
        self.sp = sp
        self.environ = environ
        self.start_response = start_response
        self.cache = cache
        self.idp_query_param = "IdpQuery"
        self.wayf = wayf
        self.discosrv = discosrv
        if bindings:
            self.bindings = bindings
        else:
            self.bindings = [BINDING_HTTP_REDIRECT, BINDING_HTTP_POST,
                             BINDING_HTTP_ARTIFACT]
        logger.debug("--- SSO ---")

    def response(self, binding, http_args, do_not_start_response=False):
        if binding == BINDING_HTTP_ARTIFACT:
            resp = Redirect()
        elif binding == BINDING_HTTP_REDIRECT:
            for param, value in http_args["headers"]:
                if param == "Location":
                    resp = SeeOther(str(value))
                    break
            else:
                resp = ServiceError("Parameter error")
        else:
            resp = Response(http_args["data"], headers=http_args["headers"])

        if do_not_start_response:
            return resp
        else:
            return resp(self.environ, self.start_response)

    def _wayf_redirect(self, came_from):
        sid_ = sid()
        self.cache.outstanding_queries[sid_] = came_from
        logger.debug("Redirect to WAYF function: %s" % self.wayf)
        return -1, SeeOther(headers=[('Location', "%s?%s" % (self.wayf, sid_))])

    def _pick_idp(self, came_from):
        """
        If more than one idp and if none is selected, I have to do wayf or
        disco
        """

        _cli = self.sp

        logger.debug("[_pick_idp] %s" % self.environ)
        if "HTTP_PAOS" in self.environ:
            if self.environ["HTTP_PAOS"] == PAOS_HEADER_INFO:
                if 'application/vnd.paos+xml' in self.environ["HTTP_ACCEPT"]:
                    # Where should I redirect the user to
                    # entityid -> the IdP to use
                    # relay_state -> when back from authentication

                    logger.debug("- ECP client detected -")

                    _rstate = rndstr()
                    self.cache.relay_state[_rstate] = geturl(self.environ)
                    _entityid = _cli.config.ecp_endpoint(
                        self.environ["REMOTE_ADDR"])

                    if not _entityid:
                        return -1, ServiceError("No IdP to talk to")
                    logger.debug("IdP to talk to: %s" % _entityid)
                    return ecp.ecp_auth_request(_cli, _entityid, _rstate)
                else:
                    return -1, ServiceError('Faulty Accept header')
            else:
                return -1, ServiceError('unknown ECP version')

        # Find all IdPs
        idps = self.sp.metadata.with_descriptor("idpsso")

        idp_entity_id = None

        kaka = self.environ.get("HTTP_COOKIE", '')
        if kaka:
            try:
                (idp_entity_id, _) = parse_cookie("ve_disco", "SEED_SAW", kaka)
            except ValueError:
                pass
            except TypeError:
                pass

        # Any specific IdP specified in a query part
        query = self.environ.get("QUERY_STRING")
        if not idp_entity_id and query:
            try:
                _idp_entity_id = dict(parse_qs(query))[
                    self.idp_query_param][0]
                if _idp_entity_id in idps:
                    idp_entity_id = _idp_entity_id
            except KeyError:
                logger.debug("No IdP entity ID in query: %s" % query)
                pass

        if not idp_entity_id:

            if self.wayf:
                if query:
                    try:
                        wayf_selected = dict(parse_qs(query))[
                            "wayf_selected"][0]
                    except KeyError:
                        return self._wayf_redirect(came_from)
                    idp_entity_id = wayf_selected
                else:
                    return self._wayf_redirect(came_from)
            elif self.discosrv:
                if query:
                    idp_entity_id = _cli.parse_discovery_service_response(
                        query=self.environ.get("QUERY_STRING"))
                if not idp_entity_id:
                    sid_ = sid()
                    self.cache.outstanding_queries[sid_] = came_from
                    logger.debug("Redirect to Discovery Service function")
                    eid = _cli.config.entityid
                    ret = _cli.config.getattr("endpoints",
                                              "sp")["discovery_response"][0][0]
                    ret += "?sid=%s" % sid_
                    loc = _cli.create_discovery_service_request(
                        self.discosrv, eid, **{"return": ret})
                    return -1, SeeOther(loc)
            elif len(idps) == 1:
                # idps is a dictionary
                idp_entity_id = idps.keys()[0]
            elif not len(idps):
                return -1, ServiceError('Misconfiguration')
            else:
                return -1, NotImplemented("No WAYF or DS present!")

        logger.info("Chosen IdP: '%s'" % idp_entity_id)
        return 0, idp_entity_id

    def redirect_to_auth(self, _cli, entity_id, came_from, vorg_name=""):
        try:
            _binding, destination = _cli.pick_binding(
                "single_sign_on_service", self.bindings, "idpsso",
                entity_id=entity_id)
            logger.debug("binding: %s, destination: %s" % (_binding,
                                                           destination))
            req_id, req = _cli.create_authn_request(destination, vorg=vorg_name)
            _rstate = rndstr()
            self.cache.relay_state[_rstate] = came_from
            ht_args = _cli.apply_binding(_binding, "%s" % req, destination,
                                         relay_state=_rstate)
            _sid = req_id
            logger.debug("ht_args: %s" % ht_args)
        except Exception, exc:
            logger.exception(exc)
            resp = ServiceError(
                "Failed to construct the AuthnRequest: %s" % exc)
            return resp(self.environ, self.start_response)

        # remember the request
        self.cache.outstanding_queries[_sid] = came_from
        return self.response(_binding, ht_args, do_not_start_response=True)

    def do(self):
        _cli = self.sp

        # Which page was accessed to get here
        came_from = geturl(self.environ)
        logger.debug("[sp.challenge] RelayState >> '%s'" % came_from)

        # Am I part of a virtual organization or more than one ?
        try:
            vorg_name = _cli.vorg._name
        except AttributeError:
            vorg_name = ""

        logger.debug("[sp.challenge] VO: %s" % vorg_name)

        # If more than one idp and if none is selected, I have to do wayf
        (done, response) = self._pick_idp(came_from)
        # Three cases: -1 something went wrong or Discovery service used
        #               0 I've got an IdP to send a request to
        #               >0 ECP in progress
        logger.debug("_idp_pick returned: %s" % done)
        if done == -1:
            return response(self.environ, self.start_response)
        elif done > 0:
            self.cache.outstanding_queries[done] = came_from
            return ECPResponse(response)
        else:
            entity_id = response
            # Do the AuthnRequest
            resp = self.redirect_to_auth(_cli, entity_id, came_from, vorg_name)
            return resp(self.environ, self.start_response)


# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def not_found(environ, start_response):
    """Called if no URL matches."""
    resp = NotFound('Not Found')
    return resp(environ, start_response)


# ----------------------------------------------------------------------------


#noinspection PyUnusedLocal
def main(environ, start_response, _sp):
    _sso = SSO(_sp, environ, start_response, cache=CACHE, **ARGS)
    return _sso.do()


#noinspection PyUnusedLocal
def verify_login_cookie(environ, start_response, _sp):
    _sso = SSO(_sp, environ, start_response, cache=CACHE, **ARGS)
    return _sso.do()


def disco(environ, start_response, _sp):
    query = parse_qs(environ["QUERY_STRING"])
    entity_id = query["entityID"][0]
    _sid = query["sid"][0]
    came_from = CACHE.outstanding_queries[_sid]
    _sso = SSO(_sp, environ, start_response, cache=CACHE, **ARGS)
    resp = _sso.redirect_to_auth(_sso.sp, entity_id, came_from)

    # Add cookie
    kaka = make_cookie("ve_disco", entity_id, "SEED_SAW")
    resp.headers.append(kaka)
    return resp(environ, start_response)

# ----------------------------------------------------------------------------

# map urls to functions
urls = [
    # Hmm, place holder, NOT used
    ('place', ("holder", None)),
    (r'^$', main),
    (r'^login', verify_login_cookie),
    (r'^disco', disco)
]


def add_urls():
    base = "acs"

    urls.append(("%s/post$" % base, (ACS, "post", SP)))
    urls.append(("%s/post/(.*)$" % base, (ACS, "post", SP)))
    urls.append(("%s/redirect$" % base, (ACS, "redirect", SP)))
    urls.append(("%s/redirect/(.*)$" % base, (ACS, "redirect", SP)))

# ----------------------------------------------------------------------------


def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above.

    If nothing matches, call the `not_found` function.
    
    :param environ: The HTTP application environment
    :param start_response: The application to run when the handling of the 
        request is done
    :return: The response as a list of lines
    """
    path = environ.get('PATH_INFO', '').lstrip('/')
    logger.debug("<application> PATH: '%s'" % path)

    logger.debug("Finding callback to run")
    try:
        for regex, spec in urls:
            match = re.search(regex, path)
            if match is not None:
                if isinstance(spec, tuple):
                    callback, func_name, _sp = spec
                    cls = callback(_sp, environ, start_response, cache=CACHE)
                    func = getattr(cls, func_name)
                    return func()
                else:
                    return spec(environ, start_response, SP)
        if re.match(".*static/.*", path):
            return handle_static(environ, start_response, path)
        return not_found(environ, start_response)
    except StatusError, err:
        logging.error("StatusError: %s" % err)
        resp = BadRequest("%s" % err)
        return resp(environ, start_response)
    except Exception, err:
        #_err = exception_trace("RUN", err)
        #logging.error(exception_trace("RUN", _err))
        print >> sys.stderr, err
        resp = ServiceError("%s" % err)
        return resp(environ, start_response)

# ----------------------------------------------------------------------------

HOST = service_conf.HOST
PORT = service_conf.PORT
# ------- HTTPS -------
# These should point to relevant files
SERVER_CERT = service_conf.SERVER_CERT
SERVER_KEY = service_conf.SERVER_KEY
# This is of course the certificate chain for the CA that signed
# your cert and all the way up to the top
CERT_CHAIN = service_conf.CERT_CHAIN

if __name__ == '__main__':
    from cherrypy import wsgiserver
    from cherrypy.wsgiserver import ssl_pyopenssl

    _parser = argparse.ArgumentParser()
    _parser.add_argument('-d', dest='debug', action='store_true',
                         help="Print debug information")
    _parser.add_argument('-D', dest='discosrv',
                         help="Which disco server to use")
    _parser.add_argument('-s', dest='seed',
                         help="Cookie seed")
    _parser.add_argument('-W', dest='wayf', action='store_true',
                         help="Which WAYF url to use")
    _parser.add_argument("config", help="SAML client config")

    ARGS = {}
    _args = _parser.parse_args()
    if _args.discosrv:
        ARGS["discosrv"] = _args.discosrv
    if _args.wayf:
        ARGS["wayf"] = _args.wayf

    CACHE = Cache()
    CNFBASE = _args.config
    if _args.seed:
        SEED = _args.seed
    else:
        SEED = "SnabbtInspel"

    SP = Saml2Client(config_file="%s" % CNFBASE)

    POLICY = service_conf.POLICY

    add_urls()

    SRV = wsgiserver.CherryPyWSGIServer((HOST, PORT), application)

    if service_conf.HTTPS:
        SRV.ssl_adapter = ssl_pyopenssl.pyOpenSSLAdapter(SERVER_CERT,
                                                         SERVER_KEY, CERT_CHAIN)
    logger.info("Server starting")
    print "SP listening on %s:%s" % (HOST, PORT)
    try:
        SRV.start()
    except KeyboardInterrupt:
        SRV.stop()

########NEW FILE########
__FILENAME__ = challenge_decider
from paste.request import construct_url
import zope.interface
from repoze.who.interfaces import IRequestClassifier

from paste.httpheaders import REQUEST_METHOD
from paste.httpheaders import CONTENT_TYPE
from paste.httpheaders import USER_AGENT

import re 

_DAV_METHODS = (
    'OPTIONS',
    'PROPFIND',
    'PROPPATCH',
    'MKCOL',
    'LOCK',
    'UNLOCK',
    'TRACE',
    'DELETE',
    'COPY',
    'MOVE'
    )

_DAV_USERAGENTS = (
    'Microsoft Data Access Internet Publishing Provider',
    'WebDrive',
    'Zope External Editor',
    'WebDAVFS',
    'Goliath',
    'neon',
    'davlib',
    'wsAPI',
    'Microsoft-WebDAV'
    )

def my_request_classifier(environ):
    """ Returns one of the classifiers 'dav', 'xmlpost', or 'browser',
    depending on the imperative logic below"""
    request_method = REQUEST_METHOD(environ)
    if request_method in _DAV_METHODS:
        return 'dav'
    useragent = USER_AGENT(environ)
    if useragent:
        for agent in _DAV_USERAGENTS:
            if useragent.find(agent) != -1:
                return 'dav'
    if request_method == 'POST':
        if CONTENT_TYPE(environ) == 'text/xml':
            return 'xmlpost'
        elif CONTENT_TYPE(environ) == "application/soap+xml":
            return 'soap'
    return 'browser'

zope.interface.directlyProvides(my_request_classifier, IRequestClassifier)

class MyChallengeDecider:
    def __init__(self, path_login="", path_logout=""):
        self.path_login = path_login
        self.path_logout = path_logout
    def __call__(self, environ, status, _headers):
        if status.startswith('401 '):
            return True
        else:
            if environ.has_key('samlsp.pending'):
                return True

            uri = environ.get('REQUEST_URI', None)
            if uri is None:
                uri = construct_url(environ)

            # require and challenge for logout and inform the challenge plugin that it is a logout we want
            for regex in self.path_logout:
                if regex.match(uri) is not None:
                    environ['samlsp.logout'] = True
                    return True

            # If the user is already authent, whatever happens(except logout), 
            #   don't make a challenge
            if environ.has_key('repoze.who.identity'): 
                return False

            # require a challenge for login
            for regex in self.path_login:
                if regex.match(uri) is not None:
                    return True

        return False



def make_plugin(path_login = None, path_logout = None):
    if path_login is None:
        raise ValueError(
            'must include path_login in configuration')

# make regexp out of string passed via the config file
    list_login = []
    for arg in path_login.splitlines():
        carg = arg.lstrip()
        if carg != '':
            list_login.append(re.compile(carg))

    list_logout = []
    if path_logout is not None:
        for arg in path_logout.splitlines():
            carg = arg.lstrip()
            if carg != '':
                list_logout.append(re.compile(carg))

    plugin = MyChallengeDecider(list_login, list_logout)

    return plugin


########NEW FILE########
__FILENAME__ = entitlement
#!/usr/bin/env python
import shelve

from zope.interface import implements

#from repoze.who.interfaces import IChallenger, IIdentifier, IAuthenticator
from repoze.who.interfaces import IMetadataProvider

class EntitlementMetadataProvider(object):
    
    implements(IMetadataProvider)
    
    def __init__(self, filename, key_attribute):
        # Means I have to do explicit syncs on writes, but also
        # that it's faster on reads since it will cache data
        self._store = shelve.open(filename, writeback=True)
        self.key_attribute = key_attribute
        
    def keys(self):
        return self._store.keys()
        
    def get(self, user, attribute):
        return self._store[user][attribute]

    def set(self, user, attribute, value):
        if user not in self._store:
            self._store[user] = {}

        self._store[user][attribute] = value
        self._store.sync()
        
    def part_of(self, user, virtualorg):
        if virtualorg in self._store[user]["entitlement"]:
            return True
        else:
            return False
            
    def get_entitlement(self, user, virtualorg):
        try:
            return self._store[user]["entitlement"][virtualorg]
        except KeyError:
            return []
            
    def store_entitlement(self, user, virtualorg, entitlement=None):
        if user not in self._store:
            self._store[user] = {"entitlement":{}}
        elif "entitlement" not in self._store[user]:
            self._store[user]["entitlement"] = {}

        if entitlement is None:
            entitlement = []
        self._store[user]["entitlement"][virtualorg] = entitlement
        self._store.sync()
            
    def add_metadata(self, environ, identity):
        #logger = environ.get('repoze.who.logger','')
        try:
            user = self._store[identity.get('repoze.who.userid')]
        except KeyError:
            return
            
        try:
            vorg = environ["myapp.vo"]
            try:
                ents = user["entitlement"][vorg]
                identity["user"] = {
                            "entitlement": ["%s:%s" % (vorg,e) for e in ents]}
            except KeyError:
                pass
        except KeyError:
            res = []
            for vorg, ents in user["entitlement"].items():
                res.extend(["%s:%s" % (vorg, e) for e in ents])
            identity["user"] = res
        
def make_plugin(filename, key_attribute=""):
    return EntitlementMetadataProvider(filename, key_attribute)

########NEW FILE########
__FILENAME__ = formswithhidden
import urllib

from paste.httpheaders import CONTENT_LENGTH
from paste.httpheaders import CONTENT_TYPE
from paste.httpheaders import LOCATION
from paste.httpexceptions import HTTPFound

from paste.request import parse_dict_querystring
from paste.request import parse_formvars
from paste.request import construct_url

from zope.interface import implements

from repoze.who.interfaces import IChallenger
from repoze.who.interfaces import IIdentifier
from repoze.who.plugins.form import FormPlugin

_DEFAULT_FORM = """<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" >
<html>
<head>
    <title>Demo Organization Log In</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
    <div>
        <strong>Demo Organization Log In</strong>
    </div>
    <form name="foo" method=POST action="?__do_login=true">
        <input type="text" name="login">
        <input type="password" name="password">
        <input name="submit" type="submit" value="Logga in">
        %s
    </form>
</body>
</html>
"""

HIDDEN_PRE_LINE = """<input type=hidden name="%s" value="%s">"""

class FormHiddenPlugin(FormPlugin):

    implements(IChallenger, IIdentifier)
    
    # IIdentifier
    def identify(self, environ):
        logger = environ.get('repoze.who.logger','')
        logger.info("formplugin identify")
        #logger and logger.info("environ keys: %s" % environ.keys())
        query = parse_dict_querystring(environ)
        # If the extractor finds a special query string on any request,
        # it will attempt to find the values in the input body.
        if query.get(self.login_form_qs): 
            form = parse_formvars(environ)
            from StringIO import StringIO
            # we need to replace wsgi.input because we've read it
            # this smells funny
            environ['wsgi.input'] = StringIO()
            form.update(query)
            qinfo = {}
            for key, val in form.items():
                if key.startswith("_") and key.endswith("_"):
                    qinfo[key[1:-1]] = val
            if qinfo:
                environ["s2repoze.qinfo"] = qinfo
            try:
                login = form['login']
                password = form['password']
            except KeyError:
                return None
            del query[self.login_form_qs]
            query.update(qinfo)
            environ['QUERY_STRING'] = urllib.urlencode(query)
            environ['repoze.who.application'] = HTTPFound(
                                                    construct_url(environ))
            credentials = {'login':login, 'password':password}
            max_age = form.get('max_age', None)
            if max_age is not None:
                credentials['max_age'] = max_age
            return credentials

        return None

    # IChallenger
    def challenge(self, environ, status, app_headers, forget_headers):
        logger = environ.get('repoze.who.logger','')
        logger.info("formplugin challenge")
        if app_headers:
            location = LOCATION(app_headers)
            if location:
                headers = list(app_headers) + list(forget_headers)
                return HTTPFound(headers = headers)
                
        query = parse_dict_querystring(environ)
        hidden = []
        for key, val in query.items():
            hidden.append(HIDDEN_PRE_LINE % ("_%s_" % key, val))

        logger.info("hidden: %s" % (hidden,))
        form = self.formbody or _DEFAULT_FORM
        form = form % "\n".join(hidden)
            
        if self.formcallable is not None:
            form = self.formcallable(environ)
        def auth_form(environ, start_response):
            content_length = CONTENT_LENGTH.tuples(str(len(form)))
            content_type = CONTENT_TYPE.tuples('text/html')
            headers = content_length + content_type + forget_headers
            start_response('200 OK', headers)
            return [form]

        return auth_form


def make_plugin(login_form_qs='__do_login', rememberer_name=None, form=None):
    if rememberer_name is None:
        raise ValueError(
            'must include rememberer key (name of another IIdentifier plugin)')
    if form is not None:
        form = open(form).read()
    plugin = FormHiddenPlugin(login_form_qs, rememberer_name, form)
    return plugin


########NEW FILE########
__FILENAME__ = ini
import ConfigParser

from zope.interface import implements

#from repoze.who.interfaces import IChallenger, IIdentifier, IAuthenticator
from repoze.who.interfaces import IMetadataProvider

class INIMetadataProvider(object):
    
    implements(IMetadataProvider)
    
    def __init__(self, ini_file, key_attribute):

        self.users = ConfigParser.ConfigParser()
        self.users.readfp(open(ini_file))
        self.key_attribute = key_attribute
        
    def add_metadata(self, _environ, identity):
        #logger = environ.get('repoze.who.logger','')

        key = identity.get('repoze.who.userid')
        try:
            if self.key_attribute:
                for sec in self.users.sections():
                    if self.users.has_option(sec, self.key_attribute):
                        if key in self.users.get(sec, self.key_attribute):
                            identity["user"] = dict(self.users.items(sec))
                            break
            else:
                identity["user"] = dict(self.users.items(key))
        except ValueError:
            pass
        
def make_plugin(ini_file, key_attribute=""):
    return INIMetadataProvider(ini_file, key_attribute)

########NEW FILE########
__FILENAME__ = sp
# Copyright (C) 2009 Umea University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""" 
A plugin that allows you to use SAML2 SSO as authentication 
and SAML2 attribute aggregations as metadata collector in your
WSGI application.

"""
import cgi
import logging
import sys
import platform
import shelve
import traceback
import saml2
from urlparse import parse_qs, urlparse
from saml2.md import Extensions
import xmldsig as ds

from StringIO import StringIO

from paste.httpexceptions import HTTPSeeOther, HTTPRedirection
from paste.httpexceptions import HTTPNotImplemented
from paste.httpexceptions import HTTPInternalServerError
from paste.request import parse_dict_querystring
from paste.request import construct_url
from saml2.extension.pefim import SPCertEnc
from saml2.httputil import SeeOther
from saml2.client_base import ECP_SERVICE
from zope.interface import implements

from repoze.who.interfaces import IChallenger, IIdentifier, IAuthenticator
from repoze.who.interfaces import IMetadataProvider

from saml2 import ecp, BINDING_HTTP_REDIRECT, element_to_extension_element
from saml2 import BINDING_HTTP_POST

from saml2.client import Saml2Client
from saml2.ident import code, decode
from saml2.s_utils import sid
from saml2.config import config_factory
from saml2.profile import paos

#from saml2.population import Population
#from saml2.attribute_resolver import AttributeResolver

logger = logging.getLogger(__name__)

PAOS_HEADER_INFO = 'ver="%s";"%s"' % (paos.NAMESPACE, ECP_SERVICE)


def construct_came_from(environ):
    """ The URL that the user used when the process where interupted 
    for single-sign-on processing. """
    
    came_from = environ.get("PATH_INFO") 
    qstr = environ.get("QUERY_STRING", "")
    if qstr:
        came_from += '?' + qstr
    return came_from
    

def cgi_field_storage_to_dict(field_storage):
    """Get a plain dictionary, rather than the '.value' system used by the
    cgi module."""
    
    params = {}
    for key in field_storage.keys():
        try:
            params[key] = field_storage[key].value
        except AttributeError:
            if isinstance(field_storage[key], basestring):
                params[key] = field_storage[key]
                
    return params


def get_body(environ):
    length = int(environ["CONTENT_LENGTH"])
    try:
        body = environ["wsgi.input"].read(length)
    except Exception, excp:
        logger.exception("Exception while reading post: %s" % (excp,))
        raise

    # restore what I might have upset
    from StringIO import StringIO
    environ['wsgi.input'] = StringIO(body)
    environ['s2repoze.body'] = body

    return body


def exception_trace(tag, exc, log):
    message = traceback.format_exception(*sys.exc_info())
    log.error("[%s] ExcList: %s" % (tag, "".join(message),))
    log.error("[%s] Exception: %s" % (tag, exc))


class ECP_response(object):
    code = 200
    title = 'OK'

    def __init__(self, content):
        self.content = content

    #noinspection PyUnusedLocal
    def __call__(self, environ, start_response):
        start_response('%s %s' % (self.code, self.title),
                       [('Content-Type', "text/xml")])
        return [self.content]


class SAML2Plugin(object):

    implements(IChallenger, IIdentifier, IAuthenticator, IMetadataProvider)
    
    def __init__(self, rememberer_name, config, saml_client, wayf, cache,
                 sid_store=None, discovery="", idp_query_param="",
                 sid_store_cert=None,):
        self.rememberer_name = rememberer_name
        self.wayf = wayf
        self.saml_client = saml_client
        self.conf = config
        self.cache = cache
        self.discosrv = discovery
        self.idp_query_param = idp_query_param
        self.logout_endpoints = [urlparse(ep)[2] for ep in config.endpoint(
            "single_logout_service")]
        try:
            self.metadata = self.conf.metadata
        except KeyError:
            self.metadata = None
        if sid_store:
            self.outstanding_queries = shelve.open(sid_store, writeback=True)
        else:
            self.outstanding_queries = {}
        if sid_store_cert:
            self.outstanding_certs = shelve.open(sid_store_cert, writeback=True)
        else:
            self.outstanding_certs = {}

        self.iam = platform.node()

    def _get_rememberer(self, environ):
        rememberer = environ['repoze.who.plugins'][self.rememberer_name]
        return rememberer

    #### IIdentifier ####
    def remember(self, environ, identity):
        rememberer = self._get_rememberer(environ)
        return rememberer.remember(environ, identity)

    #### IIdentifier ####
    def forget(self, environ, identity):
        rememberer = self._get_rememberer(environ)
        return rememberer.forget(environ, identity)

    def _get_post(self, environ):
        """
        Get the posted information
    
        :param environ: A dictionary with environment variables
        """
    
        post_env = environ.copy()
        post_env['QUERY_STRING'] = ''
    
        _ = get_body(environ)
        
        try:
            post = cgi.FieldStorage(
                fp=environ['wsgi.input'],
                environ=post_env,
                keep_blank_values=True
            )
        except Exception, excp:
            logger.debug("Exception (II): %s" % (excp,))
            raise
    
        logger.debug('identify post: %s' % (post,))
    
        return post

    def _wayf_redirect(self, came_from):
        sid_ = sid()
        self.outstanding_queries[sid_] = came_from
        logger.info("Redirect to WAYF function: %s" % self.wayf)
        return -1, HTTPSeeOther(headers=[('Location',
                                          "%s?%s" % (self.wayf, sid_))])

    #noinspection PyUnusedLocal
    def _pick_idp(self, environ, came_from):
        """ 
        If more than one idp and if none is selected, I have to do wayf or 
        disco
        """

        # check headers to see if it's an ECP request
#        headers = {
#                    'Accept' : 'text/html; application/vnd.paos+xml',
#                    'PAOS'   : 'ver="%s";"%s"' % (paos.NAMESPACE, SERVICE)
#                    }

        _cli = self.saml_client

        logger.info("[_pick_idp] %s" % environ)
        if "HTTP_PAOS" in environ:
            if environ["HTTP_PAOS"] == PAOS_HEADER_INFO:
                if 'application/vnd.paos+xml' in environ["HTTP_ACCEPT"]:
                    # Where should I redirect the user to
                    # entityid -> the IdP to use
                    # relay_state -> when back from authentication

                    logger.info("- ECP client detected -")

                    _relay_state = construct_came_from(environ)
                    _entityid = _cli.config.ecp_endpoint(environ["REMOTE_ADDR"])

                    if not _entityid:
                        return -1, HTTPInternalServerError(
                            detail="No IdP to talk to")
                    logger.info("IdP to talk to: %s" % _entityid)
                    return ecp.ecp_auth_request(_cli, _entityid,
                                                _relay_state)
                else:
                    return -1, HTTPInternalServerError(
                        detail='Faulty Accept header')
            else:
                return -1, HTTPInternalServerError(
                    detail='unknown ECP version')

        idps = self.metadata.with_descriptor("idpsso")
        
        logger.info("IdP URL: %s" % idps)

        idp_entity_id = query = None

        for key in ['s2repoze.body', "QUERY_STRING"]:
            query = environ.get(key)
            if query:
                try:
                    _idp_entity_id = dict(parse_qs(query))[
                        self.idp_query_param][0]
                    if _idp_entity_id in idps:
                        idp_entity_id = _idp_entity_id
                    break
                except KeyError:
                    logger.debug("No IdP entity ID in query: %s" % query)
                    pass

        if idp_entity_id is None:
            if len(idps) == 1:
                # idps is a dictionary
                idp_entity_id = idps.keys()[0]
            elif not len(idps):
                return -1, HTTPInternalServerError(detail='Misconfiguration')
            else:
                idp_entity_id = ""
                logger.info("ENVIRON: %s" % environ)

                if self.wayf:
                    if query:
                        try:
                            wayf_selected = dict(parse_qs(query))[
                                "wayf_selected"][0]
                        except KeyError:
                            return self._wayf_redirect(came_from)
                        idp_entity_id = wayf_selected
                    else:
                        return self._wayf_redirect(came_from)
                elif self.discosrv:
                    if query:
                        idp_entity_id = _cli.parse_discovery_service_response(
                            query=environ.get("QUERY_STRING"))
                    else:
                        sid_ = sid()
                        self.outstanding_queries[sid_] = came_from
                        logger.debug("Redirect to Discovery Service function")
                        eid = _cli.config.entityid
                        ret = _cli.config.getattr(
                            "endpoints", "sp")["discovery_response"][0][0]
                        ret += "?sid=%s" % sid_
                        loc = _cli.create_discovery_service_request(
                            self.discosrv, eid, **{"return": ret})
                        return -1, SeeOther(loc)

                else:
                    return -1, HTTPNotImplemented(
                        detail='No WAYF or DJ present!')

        logger.info("Chosen IdP: '%s'" % idp_entity_id)
        return 0, idp_entity_id
        
    #### IChallenger ####
    #noinspection PyUnusedLocal
    def challenge(self, environ, _status, _app_headers, _forget_headers):

        _cli = self.saml_client


        if 'REMOTE_USER' in environ:
            name_id = decode(environ["REMOTE_USER"])

            _cli = self.saml_client
            path_info = environ['PATH_INFO']

            if 'samlsp.logout' in environ:
                responses = _cli.global_logout(name_id)
                return self._handle_logout(responses)

        if 'samlsp.pending' in environ:
            response = environ['samlsp.pending']
            if isinstance(response, HTTPRedirection):
                response.headers += _forget_headers
            return response

        #logger = environ.get('repoze.who.logger','')

        # Which page was accessed to get here
        came_from = construct_came_from(environ)
        environ["myapp.came_from"] = came_from
        logger.debug("[sp.challenge] RelayState >> '%s'" % came_from)
        
        # Am I part of a virtual organization or more than one ?
        try:
            vorg_name = environ["myapp.vo"]
        except KeyError:
            try:
                vorg_name = _cli.vorg._name
            except AttributeError:
                vorg_name = ""
            
        logger.info("[sp.challenge] VO: %s" % vorg_name)

        # If more than one idp and if none is selected, I have to do wayf
        (done, response) = self._pick_idp(environ, came_from)
        # Three cases: -1 something went wrong or Discovery service used
        #               0 I've got an IdP to send a request to
        #               >0 ECP in progress
        logger.debug("_idp_pick returned: %s" % done)
        if done == -1:
            return response
        elif done > 0:
            self.outstanding_queries[done] = came_from
            return ECP_response(response)
        else:
            entity_id = response
            logger.info("[sp.challenge] entity_id: %s" % entity_id)
            # Do the AuthnRequest
            _binding = BINDING_HTTP_REDIRECT
            try:
                srvs = _cli.metadata.single_sign_on_service(entity_id, _binding)
                logger.debug("srvs: %s" % srvs)
                dest = srvs[0]["location"]
                logger.debug("destination: %s" % dest)

                extensions = None
                cert = None

                if _cli.config.generate_cert_func is not None:
                    cert_str, req_key_str = _cli.config.generate_cert_func()
                    cert = {
                        "cert": cert_str,
                        "key": req_key_str
                    }
                    spcertenc = SPCertEnc(x509_data=ds.X509Data(
                        x509_certificate=ds.X509Certificate(text=cert_str)))
                    extensions = Extensions(extension_elements=[
                        element_to_extension_element(spcertenc)])

                if _cli.authn_requests_signed:
                    _sid = saml2.s_utils.sid(_cli.seed)
                    req_id, msg_str = _cli.create_authn_request(
                        dest, vorg=vorg_name, sign=_cli.authn_requests_signed,
                        message_id=_sid, extensions=extensions)
                    _sid = req_id 
                else:
                    req_id, req = _cli.create_authn_request(
                        dest, vorg=vorg_name, sign=False, extensions=extensions)
                    msg_str = "%s" % req
                    _sid = req_id

                if cert is not None:
                    self.outstanding_certs[_sid] = cert

                ht_args = _cli.apply_binding(_binding, msg_str,
                                             destination=dest,
                                             relay_state=came_from)

                logger.debug("ht_args: %s" % ht_args)
            except Exception, exc:
                logger.exception(exc)
                raise Exception(
                    "Failed to construct the AuthnRequest: %s" % exc)

            try:
                ret = _cli.config.getattr(
                    "endpoints","sp")["discovery_response"][0][0]
                if (environ["PATH_INFO"]) in ret and ret.split(
                        environ["PATH_INFO"])[1] == "":
                    query = parse_qs(environ["QUERY_STRING"])
                    sid = query["sid"][0]
                    came_from = self.outstanding_queries[sid]
            except:
                pass
            # remember the request
            self.outstanding_queries[_sid] = came_from

            if not ht_args["data"] and ht_args["headers"][0][0] == "Location":
                logger.debug('redirect to: %s' % ht_args["headers"][0][1])
                return HTTPSeeOther(headers=ht_args["headers"])
            else:
                return ht_args["data"]

    def _construct_identity(self, session_info):
        cni = code(session_info["name_id"])
        identity = {
            "login": cni,
            "password": "",
            'repoze.who.userid': cni,
            "user": session_info["ava"],
        }
        logger.debug("Identity: %s" % identity)

        return identity
        
    def _eval_authn_response(self, environ, post, binding=BINDING_HTTP_POST):
        logger.info("Got AuthN response, checking..")
        logger.info("Outstanding: %s" % (self.outstanding_queries,))

        try:
            # Evaluate the response, returns a AuthnResponse instance
            try:
                authresp = self.saml_client.parse_authn_request_response(
                    post["SAMLResponse"], binding, self.outstanding_queries,
                    self.outstanding_certs)

            except Exception, excp:
                logger.exception("Exception: %s" % (excp,))
                raise
                
            session_info = authresp.session_info()
        except TypeError, excp:
            logger.exception("Exception: %s" % (excp,))
            return None
                                        
        if session_info["came_from"]:
            logger.debug("came_from << %s" % session_info["came_from"])
            try:
                path, query = session_info["came_from"].split('?')
                environ["PATH_INFO"] = path
                environ["QUERY_STRING"] = query
            except ValueError:
                environ["PATH_INFO"] = session_info["came_from"]

        logger.info("Session_info: %s" % session_info)
        return session_info

    def do_ecp_response(self, body, environ):
        response, _relay_state = ecp.handle_ecp_authn_response(self.saml_client,
                                                               body)

        environ["s2repoze.relay_state"] = _relay_state.text
        session_info = response.session_info()
        logger.info("Session_info: %s" % session_info)

        return session_info

    #### IIdentifier ####
    def identify(self, environ):
        """
        Tries to do the identification
        """
        #logger = environ.get('repoze.who.logger', '')

        query = parse_dict_querystring(environ)
        if ("CONTENT_LENGTH" not in environ or not environ["CONTENT_LENGTH"]) and \
                        "SAMLResponse" not in query and "SAMLRequest" not in query:
            logger.debug('[identify] get or empty post')
            return None
        
        # if logger:
        #     logger.info("ENVIRON: %s" % environ)
        #     logger.info("self: %s" % (self.__dict__,))
        
        uri = environ.get('REQUEST_URI', construct_url(environ))
        
        logger.debug('[sp.identify] uri: %s' % (uri,))

        query = parse_dict_querystring(environ)
        logger.debug('[sp.identify] query: %s' % (query,))

        if "SAMLResponse" in query or "SAMLRequest" in query:
            post = query
            binding = BINDING_HTTP_REDIRECT
        else:
            post = self._get_post(environ)
            if post.list is None:
                post.list = []
            binding = BINDING_HTTP_POST

        try:
            logger.debug('[sp.identify] post keys: %s' % (post.keys(),))
        except (TypeError, IndexError):
            pass
            
        try:
            path_info = environ['PATH_INFO']
            logout = False
            if path_info in self.logout_endpoints:
                logout = True

            if logout and "SAMLRequest" in post:
                print("logout request received")
                try:
                    response = self.saml_client.handle_logout_request(
                        post["SAMLRequest"],
                        self.saml_client.users.subjects()[0], binding)
                    environ['samlsp.pending'] = self._handle_logout(response)
                    return {}
                except:
                    import traceback
                    traceback.print_exc()
            elif "SAMLResponse" not in post:
                logger.info("[sp.identify] --- NOT SAMLResponse ---")
                # Not for me, put the post back where next in line can
                # find it
                environ["post.fieldstorage"] = post
                # restore wsgi.input incase that is needed
                environ['wsgi.input'] = StringIO(environ['s2repoze.body'])
                return {}
            else:
                logger.info("[sp.identify] --- SAMLResponse ---")
                # check for SAML2 authN response
                #if self.debug:
                try:
                    if logout:
                        response = self.saml_client.parse_logout_request_response(
                            post["SAMLResponse"], binding)
                        if response:
                            action = self.saml_client.handle_logout_response(
                                response)

                            if type(action) == dict:
                                request = self._handle_logout(action)
                            else:
                                #logout complete
                                request = HTTPSeeOther(headers=[
                                    ('Location', "/")])
                            if request:
                                environ['samlsp.pending'] = request
                            return {}
                    else:
                        session_info = self._eval_authn_response(
                            environ, cgi_field_storage_to_dict(post),
                            binding=binding)
                except Exception, err:
                    environ["s2repoze.saml_error"] = err
                    return {}
        except TypeError, exc:
            # might be a ECP (=SOAP) response
            body = environ.get('s2repoze.body', None)
            if body:
                # might be a ECP response
                try:
                    session_info = self.do_ecp_response(body, environ)
                except Exception, err:
                    environ["post.fieldstorage"] = post
                    environ["s2repoze.saml_error"] = err
                    return {}
            else:
                exception_trace("sp.identity", exc, logger)
                environ["post.fieldstorage"] = post
                return {}
            
        if session_info:        
            environ["s2repoze.sessioninfo"] = session_info
            return self._construct_identity(session_info)
        else:
            return None

    # IMetadataProvider
    def add_metadata(self, environ, identity):
        """ Add information to the knowledge I have about the user """
        name_id = identity['repoze.who.userid']
        if isinstance(name_id, basestring):
            try:
                # Make sure that userids authenticated by another plugin don't cause problems here.
                name_id = decode(name_id)
            except:
                pass

        _cli = self.saml_client
        logger.debug("[add_metadata] for %s" % name_id)
        try:
            logger.debug("Issuers: %s" % _cli.users.sources(name_id))
        except KeyError:
            pass
            
        if "user" not in identity:
            identity["user"] = {}
        try:
            (ava, _) = _cli.users.get_identity(name_id)
            #now = time.gmtime()        
            logger.debug("[add_metadata] adds: %s" % ava)
            identity["user"].update(ava)
        except KeyError:
            pass

        if "pysaml2_vo_expanded" not in identity and _cli.vorg:
            # is this a Virtual Organization situation
            for vo in _cli.vorg.values():
                try:
                    if vo.do_aggregation(name_id):
                        # Get the extended identity
                        identity["user"] = _cli.users.get_identity(name_id)[0]
                        # Only do this once, mark that the identity has been
                        # expanded
                        identity["pysaml2_vo_expanded"] = 1
                except KeyError:
                    logger.exception("Failed to do attribute aggregation, "
                                     "missing common attribute")
        logger.debug("[add_metadata] returns: %s" % (dict(identity),))

        if not identity["user"]:
            # remove cookie and demand re-authentication
            pass
        
    # used 2 times : one to get the ticket, the other to validate it
    @staticmethod
    def _service_url(environ, qstr=None):
        if qstr is not None:
            url = construct_url(environ, querystring=qstr)
        else:
            url = construct_url(environ)
        return url

    #### IAuthenticatorPlugin #### 
    #noinspection PyUnusedLocal
    def authenticate(self, environ, identity=None):
        if identity:
            if identity.get('user') and environ.get('s2repoze.sessioninfo') and identity.get('user') == environ.get('s2repoze.sessioninfo').get('ava'):
                return identity.get('login')
            tktuser = identity.get('repoze.who.plugins.auth_tkt.userid', None)
            if tktuser and self.saml_client.is_logged_in(decode(tktuser)):
                return tktuser
            return None
        else:
            return None

    @staticmethod
    def _handle_logout(responses):
        if 'data' in responses:
            ht_args = responses
        else:
            ht_args = responses[responses.keys()[0]][1]
        if not ht_args["data"] and ht_args["headers"][0][0] == "Location":
            logger.debug('redirect to: %s' % ht_args["headers"][0][1])
            return HTTPSeeOther(headers=ht_args["headers"])
        else:
            return ht_args["data"]


def make_plugin(remember_name=None,  # plugin for remember
                cache="",  # cache
                # Which virtual organization to support
                virtual_organization="",
                saml_conf="",
                wayf="",
                sid_store="",
                identity_cache="",
                discovery="",
                idp_query_param=""
                ):
    
    if saml_conf is "":
        raise ValueError(
            'must include saml_conf in configuration')

    if remember_name is None:
        raise ValueError('must include remember_name in configuration')

    conf = config_factory("sp", saml_conf)

    scl = Saml2Client(config=conf, identity_cache=identity_cache,
                      virtual_organization=virtual_organization)

    plugin = SAML2Plugin(remember_name, conf, scl, wayf, cache, sid_store,
                         discovery, idp_query_param)
    return plugin

########NEW FILE########
__FILENAME__ = aes
#!/usr/bin/env python
import os
from Crypto import Random
from Crypto.Cipher import AES
from base64 import b64encode, b64decode

__author__ = 'rolandh'

POSTFIX_MODE = {
    "cbc": AES.MODE_CBC,
    "cfb": AES.MODE_CFB,
    "ecb": AES.MODE_CFB,
}

BLOCK_SIZE = 16


class AESCipher(object):
    def __init__(self, key, iv=""):
        """

        :param key: The encryption key
        :param iv: Init vector
        :return: AESCipher instance
        """
        self.key = key
        self.iv = iv

    def build_cipher(self, iv="", alg="aes_128_cbc"):
        """
        :param iv: init vector
        :param alg: cipher algorithm
        :return: A Cipher instance
        """
        typ, bits, cmode = alg.split("_")

        if not iv:
            if self.iv:
                iv = self.iv
            else:
                iv = Random.new().read(AES.block_size)
        else:
            assert len(iv) == AES.block_size

        if bits not in ["128", "192", "256"]:
            raise Exception("Unsupported key length")
        try:
            assert len(self.key) == int(bits) >> 3
        except AssertionError:
            raise Exception("Wrong Key length")

        try:
            return AES.new(self.key, POSTFIX_MODE[cmode], iv), iv
        except KeyError:
            raise Exception("Unsupported chaining mode")


    def encrypt(self, msg, iv=None, alg="aes_128_cbc", padding="PKCS#7",
                b64enc=True, block_size=BLOCK_SIZE):
        """
        :param key: The encryption key
        :param iv: init vector
        :param msg: Message to be encrypted
        :param padding: Which padding that should be used
        :param b64enc: Whether the result should be base64encoded
        :param block_size: If PKCS#7 padding which block size to use
        :return: The encrypted message
        """

        if padding == "PKCS#7":
            _block_size = block_size
        elif padding == "PKCS#5":
            _block_size = 8
        else:
            _block_size = 0

        if _block_size:
            plen = _block_size - (len(msg) % _block_size)
            c = chr(plen)
            msg += c*plen

        cipher, iv = self.build_cipher(iv, alg)
        cmsg = iv + cipher.encrypt(msg)
        if b64enc:
            return b64encode(cmsg)
        else:
            return cmsg


    def decrypt(self, msg, iv=None, padding="PKCS#7", b64dec=True):
        """
        :param key: The encryption key
        :param iv: init vector
        :param msg: Base64 encoded message to be decrypted
        :return: The decrypted message
        """
        if b64dec:
            data = b64decode(msg)
        else:
            data = msg

        _iv = data[:AES.block_size]
        if iv:
            assert iv == _iv
        cipher, iv = self.build_cipher(iv)
        res = cipher.decrypt(data)[AES.block_size:]
        if padding in ["PKCS#5", "PKCS#7"]:
            res = res[:-ord(res[-1])]
        return res

if __name__ == "__main__":
    key_ = "1234523451234545"  # 16 byte key
    # Iff padded, the message doesn't have to be multiple of 16 in length
    msg_ = "ToBeOrNotTobe W.S."
    aes = AESCipher(key_)
    iv_ = os.urandom(16)
    encrypted_msg = aes.encrypt(key_, msg_, iv_)
    txt = aes.decrypt(key_, encrypted_msg, iv_)
    assert txt == msg_

    encrypted_msg = aes.encrypt(key_, msg_, 0)
    txt = aes.decrypt(key_, encrypted_msg, 0)
    assert txt == msg_

########NEW FILE########
__FILENAME__ = assertion
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import importlib
import logging

import re
from saml2.saml import NAME_FORMAT_URI
import xmlenc

from saml2 import saml

from saml2.time_util import instant, in_a_while
from saml2.attribute_converter import from_local, get_local_name
from saml2.s_utils import sid, MissingValue
from saml2.s_utils import factory
from saml2.s_utils import assertion_factory


logger = logging.getLogger(__name__)


def _filter_values(vals, vlist=None, must=False):
    """ Removes values from *vals* that does not appear in vlist
    
    :param vals: The values that are to be filtered
    :param vlist: required or optional value
    :param must: Whether the allowed values must appear
    :return: The set of values after filtering
    """
    
    if not vlist:  # No value specified equals any value
        return vals
    
    if isinstance(vlist, basestring):
        vlist = [vlist]
        
    res = []
    
    for val in vlist:
        if val in vals:
            res.append(val)
    
    if must:
        if res:
            return res
        else:
            raise MissingValue("Required attribute value missing")
    else:
        return res


def _match(attr, ava):
    if attr in ava:
        return attr

    _la = attr.lower()
    if _la in ava:
        return _la

    for _at in ava.keys():
        if _at.lower() == _la:
            return _at

    return None


def filter_on_attributes(ava, required=None, optional=None, acs=None,
                         fail_on_unfulfilled_requirements=True):
    """ Filter
    
    :param ava: An attribute value assertion as a dictionary
    :param required: list of RequestedAttribute instances defined to be 
        required
    :param optional: list of RequestedAttribute instances defined to be
        optional
    :param fail_on_unfulfilled_requirements: If required attributes
        are missing fail or fail not depending on this parameter.
    :return: The modified attribute value assertion
    """
    res = {}
    
    if required is None:
        required = []

    nform = "friendly_name"
    for attr in required:
        try:
            _name = attr[nform]
        except KeyError:
            if nform == "friendly_name":
                _name = get_local_name(acs, attr["name"],
                                       attr["name_format"])
            else:
                continue

        _fn = _match(_name, ava)
        if not _fn:  # In the unlikely case that someone has provided us
                     # with URIs as attribute names
            _fn = _match(attr["name"], ava)

        if _fn:
            try:
                values = [av["text"] for av in attr["attribute_value"]]
            except KeyError:
                values = []
            res[_fn] = _filter_values(ava[_fn], values, True)
            continue
        elif fail_on_unfulfilled_requirements:
            desc = "Required attribute missing: '%s' (%s)" % (attr["name"],
                                                              _name)
            raise MissingValue(desc)

    if optional is None:
        optional = []

    for attr in optional:
        for nform in ["friendly_name", "name"]:
            if nform in attr:
                _fn = _match(attr[nform], ava)
                if _fn:
                    try:
                        values = [av["text"] for av in attr["attribute_value"]]
                    except KeyError:
                        values = []
                    try:
                        res[_fn].extend(_filter_values(ava[_fn], values))
                    except KeyError:
                        res[_fn] = _filter_values(ava[_fn], values)
    
    return res


def filter_on_demands(ava, required=None, optional=None):
    """ Never return more than is needed. Filters out everything
    the server is prepared to return but the receiver doesn't ask for
    
    :param ava: Attribute value assertion as a dictionary
    :param required: Required attributes
    :param optional: Optional attributes
    :return: The possibly reduced assertion
    """
    
    # Is all what's required there:
    if required is None:
        required = {}

    lava = dict([(k.lower(), k) for k in ava.keys()])

    for attr, vals in required.items():
        attr = attr.lower()
        if attr in lava:
            if vals:
                for val in vals:
                    if val not in ava[lava[attr]]:
                        raise MissingValue(
                            "Required attribute value missing: %s,%s" % (attr,
                                                                         val))
        else:
            raise MissingValue("Required attribute missing: %s" % (attr,))

    if optional is None:
        optional = {}

    oka = [k.lower() for k in required.keys()]
    oka.extend([k.lower() for k in optional.keys()])

    # OK, so I can imaging releasing values that are not absolutely necessary
    # but not attributes that are not asked for.
    for attr in lava.keys():
        if attr not in oka:
            del ava[lava[attr]]
    
    return ava


def filter_on_wire_representation(ava, acs, required=None, optional=None):
    """
    :param ava: A dictionary with attributes and values
    :param acs: List of tuples (Attribute Converter name,
        Attribute Converter instance)
    :param required: A list of saml.Attributes
    :param optional: A list of saml.Attributes
    :return: Dictionary of expected/wanted attributes and values
    """
    acsdic = dict([(ac.name_format, ac) for ac in acs])

    if required is None:
        required = []
    if optional is None:
        optional = []

    res = {}
    for attr, val in ava.items():
        done = False
        for req in required:
            try:
                _name = acsdic[req.name_format]._to[attr]
                if _name == req.name:
                    res[attr] = val
                    done = True
            except KeyError:
                pass
        if done:
            continue
        for opt in optional:
            try:
                _name = acsdic[opt.name_format]._to[attr]
                if _name == opt.name:
                    res[attr] = val
                    break
            except KeyError:
                pass

    return res


def filter_attribute_value_assertions(ava, attribute_restrictions=None):
    """ Will weed out attribute values and values according to the
    rules defined in the attribute restrictions. If filtering results in
    an attribute without values, then the attribute is removed from the
    assertion.
    
    :param ava: The incoming attribute value assertion (dictionary)
    :param attribute_restrictions: The rules that govern which attributes
        and values that are allowed. (dictionary)
    :return: The modified attribute value assertion
    """
    if not attribute_restrictions:
        return ava
    
    for attr, vals in ava.items():
        _attr = attr.lower()
        try:
            _rests = attribute_restrictions[_attr]
        except KeyError:
            del ava[attr]
        else:
            if _rests is None:
                continue
            if isinstance(vals, basestring):
                vals = [vals]
            rvals = []
            for restr in _rests:
                for val in vals:
                    if restr.match(val):
                        rvals.append(val)

            if rvals:
                ava[attr] = list(set(rvals))
            else:
                del ava[attr]
    return ava


def restriction_from_attribute_spec(attributes):
    restr = {}
    for attribute in attributes:
        restr[attribute.name] = {}
        for val in attribute.attribute_value:
            if not val.text:
                restr[attribute.name] = None
                break
            else:
                restr[attribute.name] = re.compile(val.text)
    return restr


def post_entity_categories(maps, **kwargs):
    restrictions = {}
    if kwargs["mds"]:
        try:
            ecs = kwargs["mds"].entity_categories(kwargs["sp_entity_id"])
        except KeyError:
            for ec_map in maps:
                for attr in ec_map[""]:
                    restrictions[attr] = None
        else:
            for ec_map in maps:
                for key, val in ec_map.items():
                    if key == "":  # always released
                        attrs = val
                    elif isinstance(key, tuple):
                        attrs = val
                        for _key in key:
                            try:
                                assert _key in ecs
                            except AssertionError:
                                attrs = []
                                break
                    elif key in ecs:
                        attrs = val
                    else:
                        attrs = []

                    for attr in attrs:
                        restrictions[attr] = None

    return restrictions


class Policy(object):
    """ handles restrictions on assertions """
    
    def __init__(self, restrictions=None):
        if restrictions:
            self.compile(restrictions)
        else:
            self._restrictions = None
        self.acs = []

    def compile(self, restrictions):
        """ This is only for IdPs or AAs, and it's about limiting what
        is returned to the SP.
        In the configuration file, restrictions on which values that
        can be returned are specified with the help of regular expressions.
        This function goes through and pre-compiles the regular expressions.
        
        :param restrictions:
        :return: The assertion with the string specification replaced with
            a compiled regular expression.
        """
        
        self._restrictions = restrictions.copy()
        
        for who, spec in self._restrictions.items():
            if spec is None:
                continue
            try:
                items = spec["entity_categories"]
            except KeyError:
                pass
            else:
                ecs = []
                for cat in items:
                    _mod = importlib.import_module(
                        "saml2.entity_category.%s" % cat)
                    _ec = {}
                    for key, items in _mod.RELEASE.items():
                        _ec[key] = [k.lower() for k in items]
                    ecs.append(_ec)
                spec["entity_categories"] = ecs
            try:
                restr = spec["attribute_restrictions"]
            except KeyError:
                continue

            if restr is None:
                continue

            _are = {}
            for key, values in restr.items():
                if not values:
                    _are[key.lower()] = None
                    continue

                _are[key.lower()] = [re.compile(value) for value in values]
            spec["attribute_restrictions"] = _are
        logger.debug("policy restrictions: %s" % self._restrictions)

        return self._restrictions

    def get(self, attribute, sp_entity_id, default=None, post_func=None,
            **kwargs):
        """

        :param attribute:
        :param sp_entity_id:
        :param default:
        :param post_func:
        :return:
        """
        if not self._restrictions:
            return default

        try:
            try:
                val = self._restrictions[sp_entity_id][attribute]
            except KeyError:
                try:
                    val = self._restrictions["default"][attribute]
                except KeyError:
                    val = None
        except KeyError:
            val = None

        if val is None:
            return default
        elif post_func:
            return post_func(val, sp_entity_id=sp_entity_id, **kwargs)
        else:
            return val

    def get_nameid_format(self, sp_entity_id):
        """ Get the NameIDFormat to used for the entity id 
        :param: The SP entity ID
        :retur: The format
        """
        return self.get("nameid_format", sp_entity_id,
                        saml.NAMEID_FORMAT_TRANSIENT)

    def get_name_form(self, sp_entity_id):
        """ Get the NameFormat to used for the entity id 
        :param: The SP entity ID
        :retur: The format
        """

        return self.get("name_format", sp_entity_id, NAME_FORMAT_URI)

    def get_lifetime(self, sp_entity_id):
        """ The lifetime of the assertion 
        :param sp_entity_id: The SP entity ID
        :param: lifetime as a dictionary 
        """
        # default is a hour
        return self.get("lifetime", sp_entity_id, {"hours": 1})

    def get_attribute_restrictions(self, sp_entity_id):
        """ Return the attribute restriction for SP that want the information
        
        :param sp_entity_id: The SP entity ID
        :return: The restrictions
        """

        return self.get("attribute_restrictions", sp_entity_id)

    def get_fail_on_missing_requested(self, sp_entity_id):
        """ Return the whether the IdP should should fail if the SPs
        requested attributes could not be found.

        :param sp_entity_id: The SP entity ID
        :return: The restrictions
        """

        return self.get("fail_on_missing_requested", sp_entity_id, True)

    def entity_category_attributes(self, ec):
        if not self._restrictions:
            return None

        ec_maps = self._restrictions["default"]["entity_categories"]
        for ec_map in ec_maps:
            try:
                return ec_map[ec]
            except KeyError:
                pass
        return []

    def get_entity_categories(self, sp_entity_id, mds):
        """

        :param sp_entity_id:
        :param mds: MetadataStore instance
        :return: A dictionary with restrictions
        """

        kwargs = {"mds": mds}

        return self.get("entity_categories", sp_entity_id, default={},
                        post_func=post_entity_categories, **kwargs)

    def not_on_or_after(self, sp_entity_id):
        """ When the assertion stops being valid, should not be
        used after this time.
        
        :param sp_entity_id: The SP entity ID
        :return: String representation of the time
        """
        
        return in_a_while(**self.get_lifetime(sp_entity_id))
    
    def filter(self, ava, sp_entity_id, mdstore, required=None, optional=None):
        """ What attribute and attribute values returns depends on what
        the SP has said it wants in the request or in the metadata file and
        what the IdP/AA wants to release. An assumption is that what the SP
        asks for overrides whatever is in the metadata. But of course the
        IdP never releases anything it doesn't want to.
        
        :param ava: The information about the subject as a dictionary
        :param sp_entity_id: The entity ID of the SP
        :param mdstore: A Metadata store
        :param required: Attributes that the SP requires in the assertion
        :param optional: Attributes that the SP regards as optional
        :return: A possibly modified AVA
        """

        _rest = self.get_attribute_restrictions(sp_entity_id)
        if _rest is None:
            _rest = self.get_entity_categories(sp_entity_id, mdstore)
        logger.debug("filter based on: %s" % _rest)
        _ava = filter_attribute_value_assertions(ava.copy(), _rest)
        
        if required or optional:
            logger.debug("required: %s, optional: %s" % (required, optional))
            ava1 = filter_on_attributes(
                ava.copy(), required, optional, self.acs,
                self.get_fail_on_missing_requested(sp_entity_id))
            _ava.update(ava1)

        return _ava
    
    def restrict(self, ava, sp_entity_id, metadata=None):
        """ Identity attribute names are expected to be expressed in
        the local lingo (== friendlyName)
        
        :return: A filtered ava according to the IdPs/AAs rules and
            the list of required/optional attributes according to the SP.
            If the requirements can't be met an exception is raised.
        """
        if metadata:
            spec = metadata.attribute_requirement(sp_entity_id)
            if spec:
                ava = self.filter(ava, sp_entity_id, metadata,
                                  spec["required"], spec["optional"])

        return self.filter(ava, sp_entity_id, metadata, [], [])

    def conditions(self, sp_entity_id):
        """ Return a saml.Condition instance
        
        :param sp_entity_id: The SP entity ID
        :return: A saml.Condition instance
        """
        return factory(saml.Conditions,
                       not_before=instant(),
                       # How long might depend on who's getting it
                       not_on_or_after=self.not_on_or_after(sp_entity_id),
                       audience_restriction=[factory(
                           saml.AudienceRestriction,
                           audience=[factory(saml.Audience,
                                             text=sp_entity_id)])])

    def get_sign(self, sp_entity_id):
        """
        Possible choices
        "sign": ["response", "assertion", "on_demand"]

        :param sp_entity_id:
        :return:
        """

        return self.get("sign", sp_entity_id, [])


class EntityCategories(object):
    pass


def _authn_context_class_ref(authn_class, authn_auth=None):
    """
    Construct the authn context with a authn context class reference
    :param authn_class: The authn context class reference
    :param authn_auth: Authenticating Authority
    :return: An AuthnContext instance
    """
    cntx_class = factory(saml.AuthnContextClassRef, text=authn_class)
    if authn_auth:
        return factory(saml.AuthnContext,
                       authn_context_class_ref=cntx_class,
                       authenticating_authority=factory(
                           saml.AuthenticatingAuthority, text=authn_auth))
    else:
        return factory(saml.AuthnContext,
                       authn_context_class_ref=cntx_class)


def _authn_context_decl(decl, authn_auth=None):
    """
    Construct the authn context with a authn context declaration
    :param decl: The authn context declaration
    :param authn_auth: Authenticating Authority
    :return: An AuthnContext instance
    """
    return factory(saml.AuthnContext,
                   authn_context_decl=decl,
                   authenticating_authority=factory(
                       saml.AuthenticatingAuthority, text=authn_auth))


def _authn_context_decl_ref(decl_ref, authn_auth=None):
    """
    Construct the authn context with a authn context declaration reference
    :param decl_ref: The authn context declaration reference
    :param authn_auth: Authenticating Authority
    :return: An AuthnContext instance
    """
    return factory(saml.AuthnContext,
                   authn_context_decl_ref=decl_ref,
                   authenticating_authority=factory(
                       saml.AuthenticatingAuthority, text=authn_auth))


def authn_statement(authn_class=None, authn_auth=None,
                    authn_decl=None, authn_decl_ref=None, authn_instant="",
                    subject_locality=""):
    """
    Construct the AuthnStatement
    :param authn_class: Authentication Context Class reference
    :param authn_auth: Authenticating Authority
    :param authn_decl: Authentication Context Declaration
    :param authn_decl_ref: Authentication Context Declaration reference
    :param authn_instant: When the Authentication was performed.
        Assumed to be seconds since the Epoch.
    :param subject_locality: Specifies the DNS domain name and IP address
        for the system from which the assertion subject was apparently
        authenticated.
    :return: An AuthnContext instance
    """
    if authn_instant:
        _instant = instant(time_stamp=authn_instant)
    else:
        _instant = instant()

    if authn_class:
        res = factory(
            saml.AuthnStatement,
            authn_instant=_instant,
            session_index=sid(),
            authn_context=_authn_context_class_ref(
                authn_class, authn_auth))
    elif authn_decl:
        res = factory(
            saml.AuthnStatement,
            authn_instant=_instant,
            session_index=sid(),
            authn_context=_authn_context_decl(authn_decl, authn_auth))
    elif authn_decl_ref:
        res = factory(
            saml.AuthnStatement,
            authn_instant=_instant,
            session_index=sid(),
            authn_context=_authn_context_decl_ref(authn_decl_ref,
                                                       authn_auth))
    else:
        res = factory(
            saml.AuthnStatement,
            authn_instant=_instant,
            session_index=sid())

    if subject_locality:
        res.subject_locality = saml.SubjectLocality(text=subject_locality)

    return res


class Assertion(dict):
    """ Handles assertions about subjects """
    
    def __init__(self, dic=None):
        dict.__init__(self, dic)
        self.acs = []

    def construct(self, sp_entity_id, in_response_to, consumer_url,
                  name_id, attrconvs, policy, issuer, authn_class=None,
                  authn_auth=None, authn_decl=None, encrypt=None,
                  sec_context=None, authn_decl_ref=None, authn_instant="",
                  subject_locality=""):
        """ Construct the Assertion 
        
        :param sp_entity_id: The entityid of the SP
        :param in_response_to: An identifier of the message, this message is 
            a response to
        :param consumer_url: The intended consumer of the assertion
        :param name_id: An NameID instance
        :param attrconvs: AttributeConverters
        :param policy: The policy that should be adhered to when replying
        :param issuer: Who is issuing the statement
        :param authn_class: The authentication class
        :param authn_auth: The authentication instance
        :param authn_decl: An Authentication Context declaration
        :param encrypt: Whether to encrypt parts or all of the Assertion
        :param sec_context: The security context used when encrypting
        :param authn_decl_ref: An Authentication Context declaration reference
        :param authn_instant: When the Authentication was performed
        :param subject_locality: Specifies the DNS domain name and IP address
            for the system from which the assertion subject was apparently
            authenticated.
        :return: An Assertion instance
        """

        if policy:
            _name_format = policy.get_name_form(sp_entity_id)
        else:
            _name_format = NAME_FORMAT_URI

        attr_statement = saml.AttributeStatement(attribute=from_local(
            attrconvs, self, _name_format))

        if encrypt == "attributes":
            for attr in attr_statement.attribute:
                enc = sec_context.encrypt(text="%s" % attr)

                encd = xmlenc.encrypted_data_from_string(enc)
                encattr = saml.EncryptedAttribute(encrypted_data=encd)
                attr_statement.encrypted_attribute.append(encattr)

            attr_statement.attribute = []

        # start using now and for some time
        conds = policy.conditions(sp_entity_id)

        if authn_auth or authn_class or authn_decl or authn_decl_ref:
            _authn_statement = authn_statement(authn_class, authn_auth,
                                               authn_decl, authn_decl_ref,
                                               authn_instant,
                                               subject_locality)
        else:
            _authn_statement = None


        _ass = assertion_factory(
            issuer=issuer,
            conditions=conds,
            subject=factory(
                saml.Subject,
                name_id=name_id,
                subject_confirmation=[factory(
                    saml.SubjectConfirmation,
                    method=saml.SCM_BEARER,
                    subject_confirmation_data=factory(
                        saml.SubjectConfirmationData,
                        in_response_to=in_response_to,
                        recipient=consumer_url,
                        not_on_or_after=policy.not_on_or_after(sp_entity_id)))]
            ),
        )

        if _authn_statement:
            _ass.authn_statement = [_authn_statement]

        if not attr_statement.empty():
            _ass.attribute_statement=[attr_statement]

        return _ass
    
    def apply_policy(self, sp_entity_id, policy, metadata=None):
        """ Apply policy to the assertion I'm representing 
        
        :param sp_entity_id: The SP entity ID
        :param policy: The policy
        :param metadata: Metadata to use
        :return: The resulting AVA after the policy is applied
        """

        policy.acs = self.acs
        ava = policy.restrict(self, sp_entity_id, metadata)
        self.update(ava)
        return ava
########NEW FILE########
__FILENAME__ = adfs_v1x
CLAIMS = 'http://schemas.xmlsoap.org/claims/'


MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
    'fro': {
        CLAIMS+'commonname': 'commonName',
        CLAIMS+'emailaddress': 'emailAddress',
        CLAIMS+'group': 'group',
        CLAIMS+'upn': 'upn',
    },
    'to': {
        'commonName': CLAIMS+'commonname',
        'emailAddress': CLAIMS+'emailaddress',
        'group': CLAIMS+'group',
        'upn': CLAIMS+'upn',
    }
}

########NEW FILE########
__FILENAME__ = adfs_v20
CLAIMS = 'http://schemas.xmlsoap.org/claims/'
COM_WS_CLAIMS = 'http://schemas.xmlsoap.com/ws/2005/05/identity/claims/'
MS_CLAIMS = 'http://schemas.microsoft.com/ws/2008/06/identity/claims/'
ORG_WS_CLAIMS = 'http://schemas.xmlsoap.org/ws/2005/05/identity/claims/'


MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
    'fro': {
        CLAIMS+'commonname': 'commonName',
        CLAIMS+'group': 'group',
        COM_WS_CLAIMS+'denyonlysid': 'denyOnlySid',
        MS_CLAIMS+'authenticationmethod': 'authenticationMethod',
        MS_CLAIMS+'denyonlyprimarygroupsid': 'denyOnlyPrimaryGroupSid',
        MS_CLAIMS+'denyonlyprimarysid': 'denyOnlyPrimarySid',
        MS_CLAIMS+'groupsid': 'groupSid',
        MS_CLAIMS+'primarygroupsid': 'primaryGroupSid',
        MS_CLAIMS+'primarysid': 'primarySid',
        MS_CLAIMS+'role': 'role',
        MS_CLAIMS+'windowsaccountname': 'windowsAccountName',
        ORG_WS_CLAIMS+'emailaddress': 'emailAddress',
        ORG_WS_CLAIMS+'givenname': 'givenName',
        ORG_WS_CLAIMS+'name': 'name',
        ORG_WS_CLAIMS+'nameidentifier': 'nameId',
        ORG_WS_CLAIMS+'privatepersonalidentifier': 'privatePersonalId',
        ORG_WS_CLAIMS+'surname': 'surname',
        ORG_WS_CLAIMS+'upn': 'upn',
    },
    'to': {
        'authenticationMethod': MS_CLAIMS+'authenticationmethod',
        'commonName': CLAIMS+'commonname',
        'denyOnlyPrimaryGroupSid': MS_CLAIMS+'denyonlyprimarygroupsid',
        'denyOnlyPrimarySid': MS_CLAIMS+'denyonlyprimarysid',
        'denyOnlySid': COM_WS_CLAIMS+'denyonlysid',
        'emailAddress': ORG_WS_CLAIMS+'emailaddress',
        'givenName': ORG_WS_CLAIMS+'givenname',
        'group': CLAIMS+'group',
        'groupSid': MS_CLAIMS+'groupsid',
        'name': ORG_WS_CLAIMS+'name',
        'nameId': ORG_WS_CLAIMS+'nameidentifier',
        'primaryGroupSid': MS_CLAIMS+'primarygroupsid',
        'primarySid': MS_CLAIMS+'primarysid',
        'privatePersonalId': ORG_WS_CLAIMS+'privatepersonalidentifier',
        'role': MS_CLAIMS+'role',
        'surname': ORG_WS_CLAIMS+'surname',
        'upn': ORG_WS_CLAIMS+'upn',
        'windowsAccountName': MS_CLAIMS+'windowsaccountname',
    }
}

########NEW FILE########
__FILENAME__ = basic
DEF = 'urn:mace:dir:attribute-def:'


MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:basic",
    'fro': {
        DEF+'aRecord': 'aRecord',
        DEF+'aliasedEntryName': 'aliasedEntryName',
        DEF+'aliasedObjectName': 'aliasedObjectName',
        DEF+'associatedDomain': 'associatedDomain',
        DEF+'associatedName': 'associatedName',
        DEF+'audio': 'audio',
        DEF+'authorityRevocationList': 'authorityRevocationList',
        DEF+'buildingName': 'buildingName',
        DEF+'businessCategory': 'businessCategory',
        DEF+'c': 'c',
        DEF+'cACertificate': 'cACertificate',
        DEF+'cNAMERecord': 'cNAMERecord',
        DEF+'carLicense': 'carLicense',
        DEF+'certificateRevocationList': 'certificateRevocationList',
        DEF+'cn': 'cn',
        DEF+'co': 'co',
        DEF+'commonName': 'commonName',
        DEF+'countryName': 'countryName',
        DEF+'crossCertificatePair': 'crossCertificatePair',
        DEF+'dITRedirect': 'dITRedirect',
        DEF+'dSAQuality': 'dSAQuality',
        DEF+'dc': 'dc',
        DEF+'deltaRevocationList': 'deltaRevocationList',
        DEF+'departmentNumber': 'departmentNumber',
        DEF+'description': 'description',
        DEF+'destinationIndicator': 'destinationIndicator',
        DEF+'displayName': 'displayName',
        DEF+'distinguishedName': 'distinguishedName',
        DEF+'dmdName': 'dmdName',
        DEF+'dnQualifier': 'dnQualifier',
        DEF+'documentAuthor': 'documentAuthor',
        DEF+'documentIdentifier': 'documentIdentifier',
        DEF+'documentLocation': 'documentLocation',
        DEF+'documentPublisher': 'documentPublisher',
        DEF+'documentTitle': 'documentTitle',
        DEF+'documentVersion': 'documentVersion',
        DEF+'domainComponent': 'domainComponent',
        DEF+'drink': 'drink',
        DEF+'eduOrgHomePageURI': 'eduOrgHomePageURI',
        DEF+'eduOrgIdentityAuthNPolicyURI': 'eduOrgIdentityAuthNPolicyURI',
        DEF+'eduOrgLegalName': 'eduOrgLegalName',
        DEF+'eduOrgSuperiorURI': 'eduOrgSuperiorURI',
        DEF+'eduOrgWhitePagesURI': 'eduOrgWhitePagesURI',
        DEF+'eduPersonAffiliation': 'eduPersonAffiliation',
        DEF+'eduPersonEntitlement': 'eduPersonEntitlement',
        DEF+'eduPersonNickname': 'eduPersonNickname',
        DEF+'eduPersonOrgDN': 'eduPersonOrgDN',
        DEF+'eduPersonOrgUnitDN': 'eduPersonOrgUnitDN',
        DEF+'eduPersonPrimaryAffiliation': 'eduPersonPrimaryAffiliation',
        DEF+'eduPersonPrimaryOrgUnitDN': 'eduPersonPrimaryOrgUnitDN',
        DEF+'eduPersonPrincipalName': 'eduPersonPrincipalName',
        DEF+'eduPersonScopedAffiliation': 'eduPersonScopedAffiliation',
        DEF+'eduPersonTargetedID': 'eduPersonTargetedID',
        DEF+'email': 'email',
        DEF+'emailAddress': 'emailAddress',
        DEF+'employeeNumber': 'employeeNumber',
        DEF+'employeeType': 'employeeType',
        DEF+'enhancedSearchGuide': 'enhancedSearchGuide',
        DEF+'facsimileTelephoneNumber': 'facsimileTelephoneNumber',
        DEF+'favouriteDrink': 'favouriteDrink',
        DEF+'fax': 'fax',
        DEF+'federationFeideSchemaVersion': 'federationFeideSchemaVersion',
        DEF+'friendlyCountryName': 'friendlyCountryName',
        DEF+'generationQualifier': 'generationQualifier',
        DEF+'givenName': 'givenName',
        DEF+'gn': 'gn',
        DEF+'homePhone': 'homePhone',
        DEF+'homePostalAddress': 'homePostalAddress',
        DEF+'homeTelephoneNumber': 'homeTelephoneNumber',
        DEF+'host': 'host',
        DEF+'houseIdentifier': 'houseIdentifier',
        DEF+'info': 'info',
        DEF+'initials': 'initials',
        DEF+'internationaliSDNNumber': 'internationaliSDNNumber',
        DEF+'janetMailbox': 'janetMailbox',
        DEF+'jpegPhoto': 'jpegPhoto',
        DEF+'knowledgeInformation': 'knowledgeInformation',
        DEF+'l': 'l',
        DEF+'labeledURI': 'labeledURI',
        DEF+'localityName': 'localityName',
        DEF+'mDRecord': 'mDRecord',
        DEF+'mXRecord': 'mXRecord',
        DEF+'mail': 'mail',
        DEF+'mailPreferenceOption': 'mailPreferenceOption',
        DEF+'manager': 'manager',
        DEF+'member': 'member',
        DEF+'mobile': 'mobile',
        DEF+'mobileTelephoneNumber': 'mobileTelephoneNumber',
        DEF+'nSRecord': 'nSRecord',
        DEF+'name': 'name',
        DEF+'norEduOrgAcronym': 'norEduOrgAcronym',
        DEF+'norEduOrgNIN': 'norEduOrgNIN',
        DEF+'norEduOrgSchemaVersion': 'norEduOrgSchemaVersion',
        DEF+'norEduOrgUniqueIdentifier': 'norEduOrgUniqueIdentifier',
        DEF+'norEduOrgUniqueNumber': 'norEduOrgUniqueNumber',
        DEF+'norEduOrgUnitUniqueIdentifier': 'norEduOrgUnitUniqueIdentifier',
        DEF+'norEduOrgUnitUniqueNumber': 'norEduOrgUnitUniqueNumber',
        DEF+'norEduPersonBirthDate': 'norEduPersonBirthDate',
        DEF+'norEduPersonLIN': 'norEduPersonLIN',
        DEF+'norEduPersonNIN': 'norEduPersonNIN',
        DEF+'o': 'o',
        DEF+'objectClass': 'objectClass',
        DEF+'organizationName': 'organizationName',
        DEF+'organizationalStatus': 'organizationalStatus',
        DEF+'organizationalUnitName': 'organizationalUnitName',
        DEF+'otherMailbox': 'otherMailbox',
        DEF+'ou': 'ou',
        DEF+'owner': 'owner',
        DEF+'pager': 'pager',
        DEF+'pagerTelephoneNumber': 'pagerTelephoneNumber',
        DEF+'personalSignature': 'personalSignature',
        DEF+'personalTitle': 'personalTitle',
        DEF+'photo': 'photo',
        DEF+'physicalDeliveryOfficeName': 'physicalDeliveryOfficeName',
        DEF+'pkcs9email': 'pkcs9email',
        DEF+'postOfficeBox': 'postOfficeBox',
        DEF+'postalAddress': 'postalAddress',
        DEF+'postalCode': 'postalCode',
        DEF+'preferredDeliveryMethod': 'preferredDeliveryMethod',
        DEF+'preferredLanguage': 'preferredLanguage',
        DEF+'presentationAddress': 'presentationAddress',
        DEF+'protocolInformation': 'protocolInformation',
        DEF+'pseudonym': 'pseudonym',
        DEF+'registeredAddress': 'registeredAddress',
        DEF+'rfc822Mailbox': 'rfc822Mailbox',
        DEF+'roleOccupant': 'roleOccupant',
        DEF+'roomNumber': 'roomNumber',
        DEF+'sOARecord': 'sOARecord',
        DEF+'searchGuide': 'searchGuide',
        DEF+'secretary': 'secretary',
        DEF+'seeAlso': 'seeAlso',
        DEF+'serialNumber': 'serialNumber',
        DEF+'singleLevelQuality': 'singleLevelQuality',
        DEF+'sn': 'sn',
        DEF+'st': 'st',
        DEF+'stateOrProvinceName': 'stateOrProvinceName',
        DEF+'street': 'street',
        DEF+'streetAddress': 'streetAddress',
        DEF+'subtreeMaximumQuality': 'subtreeMaximumQuality',
        DEF+'subtreeMinimumQuality': 'subtreeMinimumQuality',
        DEF+'supportedAlgorithms': 'supportedAlgorithms',
        DEF+'supportedApplicationContext': 'supportedApplicationContext',
        DEF+'surname': 'surname',
        DEF+'telephoneNumber': 'telephoneNumber',
        DEF+'teletexTerminalIdentifier': 'teletexTerminalIdentifier',
        DEF+'telexNumber': 'telexNumber',
        DEF+'textEncodedORAddress': 'textEncodedORAddress',
        DEF+'title': 'title',
        DEF+'uid': 'uid',
        DEF+'uniqueIdentifier': 'uniqueIdentifier',
        DEF+'uniqueMember': 'uniqueMember',
        DEF+'userCertificate': 'userCertificate',
        DEF+'userClass': 'userClass',
        DEF+'userPKCS12': 'userPKCS12',
        DEF+'userPassword': 'userPassword',
        DEF+'userSMIMECertificate': 'userSMIMECertificate',
        DEF+'userid': 'userid',
        DEF+'x121Address': 'x121Address',
        DEF+'x500UniqueIdentifier': 'x500UniqueIdentifier',
    },
    'to': {
        'aRecord': DEF+'aRecord',
        'aliasedEntryName': DEF+'aliasedEntryName',
        'aliasedObjectName': DEF+'aliasedObjectName',
        'associatedDomain': DEF+'associatedDomain',
        'associatedName': DEF+'associatedName',
        'audio': DEF+'audio',
        'authorityRevocationList': DEF+'authorityRevocationList',
        'buildingName': DEF+'buildingName',
        'businessCategory': DEF+'businessCategory',
        'c': DEF+'c',
        'cACertificate': DEF+'cACertificate',
        'cNAMERecord': DEF+'cNAMERecord',
        'carLicense': DEF+'carLicense',
        'certificateRevocationList': DEF+'certificateRevocationList',
        'cn': DEF+'cn',
        'co': DEF+'co',
        'commonName': DEF+'commonName',
        'countryName': DEF+'countryName',
        'crossCertificatePair': DEF+'crossCertificatePair',
        'dITRedirect': DEF+'dITRedirect',
        'dSAQuality': DEF+'dSAQuality',
        'dc': DEF+'dc',
        'deltaRevocationList': DEF+'deltaRevocationList',
        'departmentNumber': DEF+'departmentNumber',
        'description': DEF+'description',
        'destinationIndicator': DEF+'destinationIndicator',
        'displayName': DEF+'displayName',
        'distinguishedName': DEF+'distinguishedName',
        'dmdName': DEF+'dmdName',
        'dnQualifier': DEF+'dnQualifier',
        'documentAuthor': DEF+'documentAuthor',
        'documentIdentifier': DEF+'documentIdentifier',
        'documentLocation': DEF+'documentLocation',
        'documentPublisher': DEF+'documentPublisher',
        'documentTitle': DEF+'documentTitle',
        'documentVersion': DEF+'documentVersion',
        'domainComponent': DEF+'domainComponent',
        'drink': DEF+'drink',
        'eduOrgHomePageURI': DEF+'eduOrgHomePageURI',
        'eduOrgIdentityAuthNPolicyURI': DEF+'eduOrgIdentityAuthNPolicyURI',
        'eduOrgLegalName': DEF+'eduOrgLegalName',
        'eduOrgSuperiorURI': DEF+'eduOrgSuperiorURI',
        'eduOrgWhitePagesURI': DEF+'eduOrgWhitePagesURI',
        'eduPersonAffiliation': DEF+'eduPersonAffiliation',
        'eduPersonEntitlement': DEF+'eduPersonEntitlement',
        'eduPersonNickname': DEF+'eduPersonNickname',
        'eduPersonOrgDN': DEF+'eduPersonOrgDN',
        'eduPersonOrgUnitDN': DEF+'eduPersonOrgUnitDN',
        'eduPersonPrimaryAffiliation': DEF+'eduPersonPrimaryAffiliation',
        'eduPersonPrimaryOrgUnitDN': DEF+'eduPersonPrimaryOrgUnitDN',
        'eduPersonPrincipalName': DEF+'eduPersonPrincipalName',
        'eduPersonScopedAffiliation': DEF+'eduPersonScopedAffiliation',
        'eduPersonTargetedID': DEF+'eduPersonTargetedID',
        'email': DEF+'email',
        'emailAddress': DEF+'emailAddress',
        'employeeNumber': DEF+'employeeNumber',
        'employeeType': DEF+'employeeType',
        'enhancedSearchGuide': DEF+'enhancedSearchGuide',
        'facsimileTelephoneNumber': DEF+'facsimileTelephoneNumber',
        'favouriteDrink': DEF+'favouriteDrink',
        'fax': DEF+'fax',
        'federationFeideSchemaVersion': DEF+'federationFeideSchemaVersion',
        'friendlyCountryName': DEF+'friendlyCountryName',
        'generationQualifier': DEF+'generationQualifier',
        'givenName': DEF+'givenName',
        'gn': DEF+'gn',
        'homePhone': DEF+'homePhone',
        'homePostalAddress': DEF+'homePostalAddress',
        'homeTelephoneNumber': DEF+'homeTelephoneNumber',
        'host': DEF+'host',
        'houseIdentifier': DEF+'houseIdentifier',
        'info': DEF+'info',
        'initials': DEF+'initials',
        'internationaliSDNNumber': DEF+'internationaliSDNNumber',
        'janetMailbox': DEF+'janetMailbox',
        'jpegPhoto': DEF+'jpegPhoto',
        'knowledgeInformation': DEF+'knowledgeInformation',
        'l': DEF+'l',
        'labeledURI': DEF+'labeledURI',
        'localityName': DEF+'localityName',
        'mDRecord': DEF+'mDRecord',
        'mXRecord': DEF+'mXRecord',
        'mail': DEF+'mail',
        'mailPreferenceOption': DEF+'mailPreferenceOption',
        'manager': DEF+'manager',
        'member': DEF+'member',
        'mobile': DEF+'mobile',
        'mobileTelephoneNumber': DEF+'mobileTelephoneNumber',
        'nSRecord': DEF+'nSRecord',
        'name': DEF+'name',
        'norEduOrgAcronym': DEF+'norEduOrgAcronym',
        'norEduOrgNIN': DEF+'norEduOrgNIN',
        'norEduOrgSchemaVersion': DEF+'norEduOrgSchemaVersion',
        'norEduOrgUniqueIdentifier': DEF+'norEduOrgUniqueIdentifier',
        'norEduOrgUniqueNumber': DEF+'norEduOrgUniqueNumber',
        'norEduOrgUnitUniqueIdentifier': DEF+'norEduOrgUnitUniqueIdentifier',
        'norEduOrgUnitUniqueNumber': DEF+'norEduOrgUnitUniqueNumber',
        'norEduPersonBirthDate': DEF+'norEduPersonBirthDate',
        'norEduPersonLIN': DEF+'norEduPersonLIN',
        'norEduPersonNIN': DEF+'norEduPersonNIN',
        'o': DEF+'o',
        'objectClass': DEF+'objectClass',
        'organizationName': DEF+'organizationName',
        'organizationalStatus': DEF+'organizationalStatus',
        'organizationalUnitName': DEF+'organizationalUnitName',
        'otherMailbox': DEF+'otherMailbox',
        'ou': DEF+'ou',
        'owner': DEF+'owner',
        'pager': DEF+'pager',
        'pagerTelephoneNumber': DEF+'pagerTelephoneNumber',
        'personalSignature': DEF+'personalSignature',
        'personalTitle': DEF+'personalTitle',
        'photo': DEF+'photo',
        'physicalDeliveryOfficeName': DEF+'physicalDeliveryOfficeName',
        'pkcs9email': DEF+'pkcs9email',
        'postOfficeBox': DEF+'postOfficeBox',
        'postalAddress': DEF+'postalAddress',
        'postalCode': DEF+'postalCode',
        'preferredDeliveryMethod': DEF+'preferredDeliveryMethod',
        'preferredLanguage': DEF+'preferredLanguage',
        'presentationAddress': DEF+'presentationAddress',
        'protocolInformation': DEF+'protocolInformation',
        'pseudonym': DEF+'pseudonym',
        'registeredAddress': DEF+'registeredAddress',
        'rfc822Mailbox': DEF+'rfc822Mailbox',
        'roleOccupant': DEF+'roleOccupant',
        'roomNumber': DEF+'roomNumber',
        'sOARecord': DEF+'sOARecord',
        'searchGuide': DEF+'searchGuide',
        'secretary': DEF+'secretary',
        'seeAlso': DEF+'seeAlso',
        'serialNumber': DEF+'serialNumber',
        'singleLevelQuality': DEF+'singleLevelQuality',
        'sn': DEF+'sn',
        'st': DEF+'st',
        'stateOrProvinceName': DEF+'stateOrProvinceName',
        'street': DEF+'street',
        'streetAddress': DEF+'streetAddress',
        'subtreeMaximumQuality': DEF+'subtreeMaximumQuality',
        'subtreeMinimumQuality': DEF+'subtreeMinimumQuality',
        'supportedAlgorithms': DEF+'supportedAlgorithms',
        'supportedApplicationContext': DEF+'supportedApplicationContext',
        'surname': DEF+'surname',
        'telephoneNumber': DEF+'telephoneNumber',
        'teletexTerminalIdentifier': DEF+'teletexTerminalIdentifier',
        'telexNumber': DEF+'telexNumber',
        'textEncodedORAddress': DEF+'textEncodedORAddress',
        'title': DEF+'title',
        'uid': DEF+'uid',
        'uniqueIdentifier': DEF+'uniqueIdentifier',
        'uniqueMember': DEF+'uniqueMember',
        'userCertificate': DEF+'userCertificate',
        'userClass': DEF+'userClass',
        'userPKCS12': DEF+'userPKCS12',
        'userPassword': DEF+'userPassword',
        'userSMIMECertificate': DEF+'userSMIMECertificate',
        'userid': DEF+'userid',
        'x121Address': DEF+'x121Address',
        'x500UniqueIdentifier': DEF+'x500UniqueIdentifier',
    }
}

########NEW FILE########
__FILENAME__ = saml_uri
EDUCOURSE_OID = 'urn:oid:1.3.6.1.4.1.5923.1.6.1.'
EDUPERSON_OID = 'urn:oid:1.3.6.1.4.1.5923.1.1.1.'
NETSCAPE_LDAP = 'urn:oid:2.16.840.1.113730.3.1.'
NOREDUPERSON_OID = 'urn:oid:1.3.6.1.4.1.2428.90.1.'
PKCS_9 = 'urn:oid:1.2.840.113549.1.9.1.'
SCHAC = 'urn:oid:1.3.6.1.4.1.25178.1.2.'
SIS = 'urn:oid:1.2.752.194.10.2.'
UCL_DIR_PILOT = 'urn:oid:0.9.2342.19200300.100.1.'
UMICH = 'urn:oid:1.3.6.1.4.1.250.1.57.'
X500ATTR_OID = 'urn:oid:2.5.4.'


MAP = {
    'identifier': 'urn:oasis:names:tc:SAML:2.0:attrname-format:uri',
    'fro': {
        EDUCOURSE_OID+'1': 'eduCourseOffering',
        EDUCOURSE_OID+'2': 'eduCourseMember',
        EDUPERSON_OID+'1': 'eduPersonAffiliation',
        EDUPERSON_OID+'2': 'eduPersonNickname',
        EDUPERSON_OID+'3': 'eduPersonOrgDN',
        EDUPERSON_OID+'4': 'eduPersonOrgUnitDN',
        EDUPERSON_OID+'5': 'eduPersonPrimaryAffiliation',
        EDUPERSON_OID+'6': 'eduPersonPrincipalName',
        EDUPERSON_OID+'7': 'eduPersonEntitlement',
        EDUPERSON_OID+'8': 'eduPersonPrimaryOrgUnitDN',
        EDUPERSON_OID+'9': 'eduPersonScopedAffiliation',
        EDUPERSON_OID+'10': 'eduPersonTargetedID',
        EDUPERSON_OID+'11': 'eduPersonAssurance',
        NETSCAPE_LDAP+'1': 'carLicense',
        NETSCAPE_LDAP+'2': 'departmentNumber',
        NETSCAPE_LDAP+'3': 'employeeNumber',
        NETSCAPE_LDAP+'4': 'employeeType',
        NETSCAPE_LDAP+'39': 'preferredLanguage',
        NETSCAPE_LDAP+'40': 'userSMIMECertificate',
        NETSCAPE_LDAP+'216': 'userPKCS12',
        NETSCAPE_LDAP+'241': 'displayName',
        NOREDUPERSON_OID+'1': 'norEduOrgUniqueNumber',
        NOREDUPERSON_OID+'2': 'norEduOrgUnitUniqueNumber',
        NOREDUPERSON_OID+'3': 'norEduPersonBirthDate',
        NOREDUPERSON_OID+'4': 'norEduPersonLIN',
        NOREDUPERSON_OID+'5': 'norEduPersonNIN',
        NOREDUPERSON_OID+'6': 'norEduOrgAcronym',
        NOREDUPERSON_OID+'7': 'norEduOrgUniqueIdentifier',
        NOREDUPERSON_OID+'8': 'norEduOrgUnitUniqueIdentifier',
        NOREDUPERSON_OID+'9': 'federationFeideSchemaVersion',
        NOREDUPERSON_OID+'10': 'norEduPersonLegalName',
        NOREDUPERSON_OID+'11': 'norEduOrgSchemaVersion',
        NOREDUPERSON_OID+'12': 'norEduOrgNIN',
        PKCS_9+'1': 'email',
        SCHAC+'1': 'schacMotherTongue',
        SCHAC+'2': 'schacGender',
        SCHAC+'3': 'schacDateOfBirth',
        SCHAC+'4': 'schacPlaceOfBirth',
        SCHAC+'5': 'schacCountryOfCitizenship',
        SCHAC+'6': 'schacSn1',
        SCHAC+'7': 'schacSn2',
        SCHAC+'8': 'schacPersonalTitle',
        SCHAC+'9': 'schacHomeOrganization',
        SCHAC+'10': 'schacHomeOrganizationType',
        SCHAC+'11': 'schacCountryOfResidence',
        SCHAC+'12': 'schacUserPresenceID',
        SCHAC+'13': 'schacPersonalPosition',
        SCHAC+'14': 'schacPersonalUniqueCode',
        SCHAC+'15': 'schacPersonalUniqueID',
        SCHAC+'17': 'schacExpiryDate',
        SCHAC+'18': 'schacUserPrivateAttribute',
        SCHAC+'19': 'schacUserStatus',
        SCHAC+'20': 'schacProjectMembership',
        SCHAC+'21': 'schacProjectSpecificRole',
        SIS+'1': 'sisLegalGuardianFor',
        SIS+'2': 'sisSchoolGrade',
        UCL_DIR_PILOT+'1': 'uid',
        UCL_DIR_PILOT+'3': 'mail',
        UCL_DIR_PILOT+'25': 'dc',
        UCL_DIR_PILOT+'37': 'associatedDomain',
        UCL_DIR_PILOT+'43': 'co',
        UCL_DIR_PILOT+'60': 'jpegPhoto',
        UMICH+'57': 'labeledURI',
        X500ATTR_OID+'2': 'knowledgeInformation',
        X500ATTR_OID+'3': 'cn',
        X500ATTR_OID+'4': 'sn',
        X500ATTR_OID+'5': 'serialNumber',
        X500ATTR_OID+'6': 'c',
        X500ATTR_OID+'7': 'l',
        X500ATTR_OID+'8': 'st',
        X500ATTR_OID+'9': 'street',
        X500ATTR_OID+'10': 'o',
        X500ATTR_OID+'11': 'ou',
        X500ATTR_OID+'12': 'title',
        X500ATTR_OID+'14': 'searchGuide',
        X500ATTR_OID+'15': 'businessCategory',
        X500ATTR_OID+'16': 'postalAddress',
        X500ATTR_OID+'17': 'postalCode',
        X500ATTR_OID+'18': 'postOfficeBox',
        X500ATTR_OID+'19': 'physicalDeliveryOfficeName',
        X500ATTR_OID+'20': 'telephoneNumber',
        X500ATTR_OID+'21': 'telexNumber',
        X500ATTR_OID+'22': 'teletexTerminalIdentifier',
        X500ATTR_OID+'23': 'facsimileTelephoneNumber',
        X500ATTR_OID+'24': 'x121Address',
        X500ATTR_OID+'25': 'internationaliSDNNumber',
        X500ATTR_OID+'26': 'registeredAddress',
        X500ATTR_OID+'27': 'destinationIndicator',
        X500ATTR_OID+'28': 'preferredDeliveryMethod',
        X500ATTR_OID+'29': 'presentationAddress',
        X500ATTR_OID+'30': 'supportedApplicationContext',
        X500ATTR_OID+'31': 'member',
        X500ATTR_OID+'32': 'owner',
        X500ATTR_OID+'33': 'roleOccupant',
        X500ATTR_OID+'36': 'userCertificate',
        X500ATTR_OID+'37': 'cACertificate',
        X500ATTR_OID+'38': 'authorityRevocationList',
        X500ATTR_OID+'39': 'certificateRevocationList',
        X500ATTR_OID+'40': 'crossCertificatePair',
        X500ATTR_OID+'42': 'givenName',
        X500ATTR_OID+'43': 'initials',
        X500ATTR_OID+'44': 'generationQualifier',
        X500ATTR_OID+'45': 'x500UniqueIdentifier',
        X500ATTR_OID+'46': 'dnQualifier',
        X500ATTR_OID+'47': 'enhancedSearchGuide',
        X500ATTR_OID+'48': 'protocolInformation',
        X500ATTR_OID+'50': 'uniqueMember',
        X500ATTR_OID+'51': 'houseIdentifier',
        X500ATTR_OID+'52': 'supportedAlgorithms',
        X500ATTR_OID+'53': 'deltaRevocationList',
        X500ATTR_OID+'54': 'dmdName',
        X500ATTR_OID+'65': 'pseudonym',
    },
    'to': {
        'associatedDomain': UCL_DIR_PILOT+'37',
        'authorityRevocationList': X500ATTR_OID+'38',
        'businessCategory': X500ATTR_OID+'15',
        'c': X500ATTR_OID+'6',
        'cACertificate': X500ATTR_OID+'37',
        'carLicense': NETSCAPE_LDAP+'1',
        'certificateRevocationList': X500ATTR_OID+'39',
        'cn': X500ATTR_OID+'3',
        'co': UCL_DIR_PILOT+'43',
        'crossCertificatePair': X500ATTR_OID+'40',
        'dc': UCL_DIR_PILOT+'25',
        'deltaRevocationList': X500ATTR_OID+'53',
        'departmentNumber': NETSCAPE_LDAP+'2',
        'destinationIndicator': X500ATTR_OID+'27',
        'displayName': NETSCAPE_LDAP+'241',
        'dmdName': X500ATTR_OID+'54',
        'dnQualifier': X500ATTR_OID+'46',
        'eduCourseMember': EDUCOURSE_OID+'2',
        'eduCourseOffering': EDUCOURSE_OID+'1',
        'eduPersonAffiliation': EDUPERSON_OID+'1',
        'eduPersonAssurance': EDUPERSON_OID+'11',
        'eduPersonEntitlement': EDUPERSON_OID+'7',
        'eduPersonNickname': EDUPERSON_OID+'2',
        'eduPersonOrgDN': EDUPERSON_OID+'3',
        'eduPersonOrgUnitDN': EDUPERSON_OID+'4',
        'eduPersonPrimaryAffiliation': EDUPERSON_OID+'5',
        'eduPersonPrimaryOrgUnitDN': EDUPERSON_OID+'8',
        'eduPersonPrincipalName': EDUPERSON_OID+'6',
        'eduPersonScopedAffiliation': EDUPERSON_OID+'9',
        'eduPersonTargetedID': EDUPERSON_OID+'10',
        'email': PKCS_9+'1',
        'employeeNumber': NETSCAPE_LDAP+'3',
        'employeeType': NETSCAPE_LDAP+'4',
        'enhancedSearchGuide': X500ATTR_OID+'47',
        'facsimileTelephoneNumber': X500ATTR_OID+'23',
        'federationFeideSchemaVersion': NOREDUPERSON_OID+'9',
        'generationQualifier': X500ATTR_OID+'44',
        'givenName': X500ATTR_OID+'42',
        'houseIdentifier': X500ATTR_OID+'51',
        'initials': X500ATTR_OID+'43',
        'internationaliSDNNumber': X500ATTR_OID+'25',
        'jpegPhoto': UCL_DIR_PILOT+'60',
        'knowledgeInformation': X500ATTR_OID+'2',
        'l': X500ATTR_OID+'7',
        'labeledURI': UMICH+'57',
        'mail': UCL_DIR_PILOT+'3',
        'member': X500ATTR_OID+'31',
        'norEduOrgAcronym': NOREDUPERSON_OID+'6',
        'norEduOrgNIN': NOREDUPERSON_OID+'12',
        'norEduOrgSchemaVersion': NOREDUPERSON_OID+'11',
        'norEduOrgUniqueIdentifier': NOREDUPERSON_OID+'7',
        'norEduOrgUniqueNumber': NOREDUPERSON_OID+'1',
        'norEduOrgUnitUniqueIdentifier': NOREDUPERSON_OID+'8',
        'norEduOrgUnitUniqueNumber': NOREDUPERSON_OID+'2',
        'norEduPersonBirthDate': NOREDUPERSON_OID+'3',
        'norEduPersonLIN': NOREDUPERSON_OID+'4',
        'norEduPersonLegalName': NOREDUPERSON_OID+'10',
        'norEduPersonNIN': NOREDUPERSON_OID+'5',
        'o': X500ATTR_OID+'10',
        'ou': X500ATTR_OID+'11',
        'owner': X500ATTR_OID+'32',
        'physicalDeliveryOfficeName': X500ATTR_OID+'19',
        'postOfficeBox': X500ATTR_OID+'18',
        'postalAddress': X500ATTR_OID+'16',
        'postalCode': X500ATTR_OID+'17',
        'preferredDeliveryMethod': X500ATTR_OID+'28',
        'preferredLanguage': NETSCAPE_LDAP+'39',
        'presentationAddress': X500ATTR_OID+'29',
        'protocolInformation': X500ATTR_OID+'48',
        'pseudonym': X500ATTR_OID+'65',
        'registeredAddress': X500ATTR_OID+'26',
        'roleOccupant': X500ATTR_OID+'33',
        'schacCountryOfCitizenship': SCHAC+'5',
        'schacCountryOfResidence': SCHAC+'11',
        'schacDateOfBirth': SCHAC+'3',
        'schacExpiryDate': SCHAC+'17',
        'schacGender': SCHAC+'2',
        'schacHomeOrganization': SCHAC+'9',
        'schacHomeOrganizationType': SCHAC+'10',
        'schacMotherTongue': SCHAC+'1',
        'schacPersonalPosition': SCHAC+'13',
        'schacPersonalTitle': SCHAC+'8',
        'schacPersonalUniqueCode': SCHAC+'14',
        'schacPersonalUniqueID': SCHAC+'15',
        'schacPlaceOfBirth': SCHAC+'4',
        'schacProjectMembership': SCHAC+'20',
        'schacProjectSpecificRole': SCHAC+'21',
        'schacSn1': SCHAC+'6',
        'schacSn2': SCHAC+'7',
        'schacUserPresenceID': SCHAC+'12',
        'schacUserPrivateAttribute': SCHAC+'18',
        'schacUserStatus': SCHAC+'19',
        'searchGuide': X500ATTR_OID+'14',
        'serialNumber': X500ATTR_OID+'5',
        'sisLegalGuardianFor': SIS+'1',
        'sisSchoolGrade': SIS+'2',
        'sn': X500ATTR_OID+'4',
        'st': X500ATTR_OID+'8',
        'street': X500ATTR_OID+'9',
        'supportedAlgorithms': X500ATTR_OID+'52',
        'supportedApplicationContext': X500ATTR_OID+'30',
        'telephoneNumber': X500ATTR_OID+'20',
        'teletexTerminalIdentifier': X500ATTR_OID+'22',
        'telexNumber': X500ATTR_OID+'21',
        'title': X500ATTR_OID+'12',
        'uid': UCL_DIR_PILOT+'1',
        'uniqueMember': X500ATTR_OID+'50',
        'userCertificate': X500ATTR_OID+'36',
        'userPKCS12': NETSCAPE_LDAP+'216',
        'userSMIMECertificate': NETSCAPE_LDAP+'40',
        'x121Address': X500ATTR_OID+'24',
        'x500UniqueIdentifier': X500ATTR_OID+'45',
    }
}

########NEW FILE########
__FILENAME__ = shibboleth_uri
EDUPERSON_OID = 'urn:oid:1.3.6.1.4.1.5923.1.1.1.'
NETSCAPE_LDAP = 'urn:oid:2.16.840.1.113730.3.1.'
NOREDUPERSON_OID = 'urn:oid:1.3.6.1.4.1.2428.90.1.'
PKCS_9 = 'urn:oid:1.2.840.113549.1.9.'
UCL_DIR_PILOT = 'urn:oid:0.9.2342.19200300.100.1.'
UMICH = 'urn:oid:1.3.6.1.4.1.250.1.57.'
X500ATTR = 'urn:oid:2.5.4.'


MAP = {
    "identifier": "urn:mace:shibboleth:1.0:attributeNamespace:uri",
    'fro': {
        EDUPERSON_OID+'1': 'eduPersonAffiliation',
        EDUPERSON_OID+'2': 'eduPersonNickname',
        EDUPERSON_OID+'3': 'eduPersonOrgDN',
        EDUPERSON_OID+'4': 'eduPersonOrgUnitDN',
        EDUPERSON_OID+'5': 'eduPersonPrimaryAffiliation',
        EDUPERSON_OID+'6': 'eduPersonPrincipalName',
        EDUPERSON_OID+'7': 'eduPersonEntitlement',
        EDUPERSON_OID+'8': 'eduPersonPrimaryOrgUnitDN',
        EDUPERSON_OID+'9': 'eduPersonScopedAffiliation',
        EDUPERSON_OID+'10': 'eduPersonTargetedID',
        EDUPERSON_OID+'11': 'eduPersonAssurance',
        NETSCAPE_LDAP+'1': 'carLicense',
        NETSCAPE_LDAP+'2': 'departmentNumber',
        NETSCAPE_LDAP+'3': 'employeeNumber',
        NETSCAPE_LDAP+'4': 'employeeType',
        NETSCAPE_LDAP+'39': 'preferredLanguage',
        NETSCAPE_LDAP+'40': 'userSMIMECertificate',
        NETSCAPE_LDAP+'216': 'userPKCS12',
        NETSCAPE_LDAP+'241': 'displayName',
        NOREDUPERSON_OID+'1': 'norEduOrgUniqueNumber',
        NOREDUPERSON_OID+'2': 'norEduOrgUnitUniqueNumber',
        NOREDUPERSON_OID+'3': 'norEduPersonBirthDate',
        NOREDUPERSON_OID+'4': 'norEduPersonLIN',
        NOREDUPERSON_OID+'5': 'norEduPersonNIN',
        NOREDUPERSON_OID+'6': 'norEduOrgAcronym',
        NOREDUPERSON_OID+'7': 'norEduOrgUniqueIdentifier',
        NOREDUPERSON_OID+'8': 'norEduOrgUnitUniqueIdentifier',
        NOREDUPERSON_OID+'9': 'federationFeideSchemaVersion',
        PKCS_9+'1': 'email',
        UCL_DIR_PILOT+'3': 'mail',
        UCL_DIR_PILOT+'25': 'dc',
        UCL_DIR_PILOT+'37': 'associatedDomain',
        UCL_DIR_PILOT+'60': 'jpegPhoto',
        X500ATTR+'2': 'knowledgeInformation',
        X500ATTR+'4': 'sn',
        X500ATTR+'5': 'serialNumber',
        X500ATTR+'6': 'c',
        X500ATTR+'7': 'l',
        X500ATTR+'8': 'st',
        X500ATTR+'9': 'street',
        X500ATTR+'10': 'o',
        X500ATTR+'11': 'ou',
        X500ATTR+'12': 'title',
        X500ATTR+'14': 'searchGuide',
        X500ATTR+'15': 'businessCategory',
        X500ATTR+'16': 'postalAddress',
        X500ATTR+'17': 'postalCode',
        X500ATTR+'18': 'postOfficeBox',
        X500ATTR+'19': 'physicalDeliveryOfficeName',
        X500ATTR+'20': 'telephoneNumber',
        X500ATTR+'21': 'telexNumber',
        X500ATTR+'22': 'teletexTerminalIdentifier',
        X500ATTR+'23': 'facsimileTelephoneNumber',
        X500ATTR+'24': 'x121Address',
        X500ATTR+'25': 'internationaliSDNNumber',
        X500ATTR+'26': 'registeredAddress',
        X500ATTR+'27': 'destinationIndicator',
        X500ATTR+'28': 'preferredDeliveryMethod',
        X500ATTR+'29': 'presentationAddress',
        X500ATTR+'30': 'supportedApplicationContext',
        X500ATTR+'31': 'member',
        X500ATTR+'32': 'owner',
        X500ATTR+'33': 'roleOccupant',
        X500ATTR+'36': 'userCertificate',
        X500ATTR+'37': 'cACertificate',
        X500ATTR+'38': 'authorityRevocationList',
        X500ATTR+'39': 'certificateRevocationList',
        X500ATTR+'40': 'crossCertificatePair',
        X500ATTR+'42': 'givenName',
        X500ATTR+'43': 'initials',
        X500ATTR+'44': 'generationQualifier',
        X500ATTR+'45': 'x500UniqueIdentifier',
        X500ATTR+'46': 'dnQualifier',
        X500ATTR+'47': 'enhancedSearchGuide',
        X500ATTR+'48': 'protocolInformation',
        X500ATTR+'50': 'uniqueMember',
        X500ATTR+'51': 'houseIdentifier',
        X500ATTR+'52': 'supportedAlgorithms',
        X500ATTR+'53': 'deltaRevocationList',
        X500ATTR+'54': 'dmdName',
        X500ATTR+'65': 'pseudonym',
    },
    'to': {
        'associatedDomain': UCL_DIR_PILOT+'37',
        'authorityRevocationList': X500ATTR+'38',
        'businessCategory': X500ATTR+'15',
        'c': X500ATTR+'6',
        'cACertificate': X500ATTR+'37',
        'carLicense': NETSCAPE_LDAP+'1',
        'certificateRevocationList': X500ATTR+'39',
        'countryName': X500ATTR+'6',
        'crossCertificatePair': X500ATTR+'40',
        'dc': UCL_DIR_PILOT+'25',
        'deltaRevocationList': X500ATTR+'53',
        'departmentNumber': NETSCAPE_LDAP+'2',
        'destinationIndicator': X500ATTR+'27',
        'displayName': NETSCAPE_LDAP+'241',
        'dmdName': X500ATTR+'54',
        'dnQualifier': X500ATTR+'46',
        'domainComponent': UCL_DIR_PILOT+'25',
        'eduPersonAffiliation': EDUPERSON_OID+'1',
        'eduPersonAssurance': EDUPERSON_OID+'11',
        'eduPersonEntitlement': EDUPERSON_OID+'7',
        'eduPersonNickname': EDUPERSON_OID+'2',
        'eduPersonOrgDN': EDUPERSON_OID+'3',
        'eduPersonOrgUnitDN': EDUPERSON_OID+'4',
        'eduPersonPrimaryAffiliation': EDUPERSON_OID+'5',
        'eduPersonPrimaryOrgUnitDN': EDUPERSON_OID+'8',
        'eduPersonPrincipalName': EDUPERSON_OID+'6',
        'eduPersonScopedAffiliation': EDUPERSON_OID+'9',
        'eduPersonTargetedID': EDUPERSON_OID+'10',
        'email': PKCS_9+'1',
        'emailAddress': PKCS_9+'1',
        'employeeNumber': NETSCAPE_LDAP+'3',
        'employeeType': NETSCAPE_LDAP+'4',
        'enhancedSearchGuide': X500ATTR+'47',
        'facsimileTelephoneNumber': X500ATTR+'23',
        'fax': X500ATTR+'23',
        'federationFeideSchemaVersion': NOREDUPERSON_OID+'9',
        'generationQualifier': X500ATTR+'44',
        'givenName': X500ATTR+'42',
        'gn': X500ATTR+'42',
        'houseIdentifier': X500ATTR+'51',
        'initials': X500ATTR+'43',
        'internationaliSDNNumber': X500ATTR+'25',
        'jpegPhoto': UCL_DIR_PILOT+'60',
        'knowledgeInformation': X500ATTR+'2',
        'l': X500ATTR+'7',
        'localityName': X500ATTR+'7',
        'mail': UCL_DIR_PILOT+'3',
        'member': X500ATTR+'31',
        'norEduOrgAcronym': NOREDUPERSON_OID+'6',
        'norEduOrgUniqueIdentifier': NOREDUPERSON_OID+'7',
        'norEduOrgUniqueNumber': NOREDUPERSON_OID+'1',
        'norEduOrgUnitUniqueIdentifier': NOREDUPERSON_OID+'8',
        'norEduOrgUnitUniqueNumber': NOREDUPERSON_OID+'2',
        'norEduPersonBirthDate': NOREDUPERSON_OID+'3',
        'norEduPersonLIN': NOREDUPERSON_OID+'4',
        'norEduPersonNIN': NOREDUPERSON_OID+'5',
        'o': X500ATTR+'10',
        'organizationName': X500ATTR+'10',
        'organizationalUnitName': X500ATTR+'11',
        'ou': X500ATTR+'11',
        'owner': X500ATTR+'32',
        'physicalDeliveryOfficeName': X500ATTR+'19',
        'pkcs9email': PKCS_9+'1',
        'postOfficeBox': X500ATTR+'18',
        'postalAddress': X500ATTR+'16',
        'postalCode': X500ATTR+'17',
        'preferredDeliveryMethod': X500ATTR+'28',
        'preferredLanguage': NETSCAPE_LDAP+'39',
        'presentationAddress': X500ATTR+'29',
        'protocolInformation': X500ATTR+'48',
        'pseudonym': X500ATTR+'65',
        'registeredAddress': X500ATTR+'26',
        'rfc822Mailbox': UCL_DIR_PILOT+'3',
        'roleOccupant': X500ATTR+'33',
        'searchGuide': X500ATTR+'14',
        'serialNumber': X500ATTR+'5',
        'sn': X500ATTR+'4',
        'st': X500ATTR+'8',
        'stateOrProvinceName': X500ATTR+'8',
        'street': X500ATTR+'9',
        'streetAddress': X500ATTR+'9',
        'supportedAlgorithms': X500ATTR+'52',
        'supportedApplicationContext': X500ATTR+'30',
        'surname': X500ATTR+'4',
        'telephoneNumber': X500ATTR+'20',
        'teletexTerminalIdentifier': X500ATTR+'22',
        'telexNumber': X500ATTR+'21',
        'title': X500ATTR+'12',
        'uniqueMember': X500ATTR+'50',
        'userCertificate': X500ATTR+'36',
        'userPKCS12': NETSCAPE_LDAP+'216',
        'userSMIMECertificate': NETSCAPE_LDAP+'40',
        'x121Address': X500ATTR+'24',
        'x500UniqueIdentifier': X500ATTR+'45',
    }
}

########NEW FILE########
__FILENAME__ = attribute_converter
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) s2010-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sys
from importlib import import_module

from saml2.s_utils import factory
from saml2.s_utils import do_ava
from saml2 import saml
from saml2 import extension_elements_to_elements
from saml2 import SAMLError
from saml2.saml import NAME_FORMAT_UNSPECIFIED

import logging
logger = logging.getLogger(__name__)


class UnknownNameFormat(SAMLError):
    pass


class ConverterError(SAMLError):
    pass


def load_maps(dirspec):
    """ load the attribute maps

    :param dirspec: a directory specification
    :return: a dictionary with the name of the map as key and the
        map as value. The map itself is a dictionary with two keys:
        "to" and "fro". The values for those keys are the actual mapping.
    """
    mapd = {}
    if dirspec not in sys.path:
        sys.path.insert(0, dirspec)

    for fil in os.listdir(dirspec):
        if fil.endswith(".py"):
            mod = import_module(fil[:-3])
            for key, item in mod.__dict__.items():
                if key.startswith("__"):
                    continue
                if isinstance(item, dict) and "to" in item and "fro" in item:
                    mapd[item["identifier"]] = item

    return mapd


def ac_factory(path=""):
    """Attribute Converter factory

    :param path: The path to a directory where the attribute maps are expected
        to reside.
    :return: A AttributeConverter instance
    """
    acs = []

    if path:
        if path not in sys.path:
            sys.path.insert(0, path)

        for fil in os.listdir(path):
            if fil.endswith(".py"):
                mod = import_module(fil[:-3])
                for key, item in mod.__dict__.items():
                    if key.startswith("__"):
                        continue
                    if isinstance(item,
                                  dict) and "to" in item and "fro" in item:
                        atco = AttributeConverter(item["identifier"])
                        atco.from_dict(item)
                        acs.append(atco)
    else:
        from saml2 import attributemaps

        for typ in attributemaps.__all__:
            mod = import_module(".%s" % typ, "saml2.attributemaps")
            for key, item in mod.__dict__.items():
                if key.startswith("__"):
                    continue
                if isinstance(item, dict) and "to" in item and "fro" in item:
                    atco = AttributeConverter(item["identifier"])
                    atco.from_dict(item)
                    acs.append(atco)

    return acs


def ac_factory_II(path):
    return ac_factory(path)


# def ava_fro(acs, statement):
#     """  Translates attributes according to their name_formats into the local
#      names.
#
#     :param acs: AttributeConverter instances
#     :param statement: A SAML statement
#     :return: A dictionary with attribute names replaced with local names.
#     """
#     if not statement:
#         return {}
#
#     acsdic = dict([(ac.name_format, ac) for ac in acs])
#     acsdic[None] = acsdic[NAME_FORMAT_URI]
#     return dict([acsdic[a.name_format].ava_from(a) for a in statement])


def to_local(acs, statement, allow_unknown_attributes=False):
    """ Replaces the attribute names in a attribute value assertion with the
    equivalent name from a local name format.

    :param acs: List of Attribute Converters
    :param statement: The Attribute Statement
    :param allow_unknown_attributes: If unknown attributes are allowed
    :return: A key,values dictionary
    """
    if not acs:
        acs = [AttributeConverter()]
        acsd = {"": acs}
    else:
        acsd = dict([(a.name_format, a) for a in acs])

    ava = {}
    for attr in statement.attribute:
        try:
            _func = acsd[attr.name_format].ava_from
        except KeyError:
            if attr.name_format == NAME_FORMAT_UNSPECIFIED or \
                    allow_unknown_attributes:
                _func = acs[0].lcd_ava_from
            else:
                logger.info("Unsupported attribute name format: %s" % (
                    attr.name_format,))
                continue

        try:
            key, val = _func(attr)
        except KeyError:
            if allow_unknown_attributes:
                key, val = acs[0].lcd_ava_from(attr)
            else:
                logger.info("Unknown attribute name: %s" % (attr,))
                continue
        except AttributeError:
            continue

        try:
            ava[key].extend(val)
        except KeyError:
            ava[key] = val

    return ava


def list_to_local(acs, attrlist, allow_unknown_attributes=False):
    """ Replaces the attribute names in a attribute value assertion with the
    equivalent name from a local name format.

    :param acs: List of Attribute Converters
    :param attrlist: List of Attributes
    :param allow_unknown_attributes: If unknown attributes are allowed
    :return: A key,values dictionary
    """
    if not acs:
        acs = [AttributeConverter()]
        acsd = {"": acs}
    else:
        acsd = dict([(a.name_format, a) for a in acs])

    ava = {}
    for attr in attrlist:
        try:
            _func = acsd[attr.name_format].ava_from
        except KeyError:
            if attr.name_format == NAME_FORMAT_UNSPECIFIED or \
                    allow_unknown_attributes:
                _func = acs[0].lcd_ava_from
            else:
                logger.info("Unsupported attribute name format: %s" % (
                    attr.name_format,))
                continue

        try:
            key, val = _func(attr)
        except KeyError:
            if allow_unknown_attributes:
                key, val = acs[0].lcd_ava_from(attr)
            else:
                logger.info("Unknown attribute name: %s" % (attr,))
                continue
        except AttributeError:
            continue

        try:
            ava[key].extend(val)
        except KeyError:
            ava[key] = val

    return ava


def from_local(acs, ava, name_format):
    for aconv in acs:
        #print ac.format, name_format
        if aconv.name_format == name_format:
            #print "Found a name_form converter"
            return aconv.to_(ava)

    return None


def from_local_name(acs, attr, name_format):
    """
    :param acs: List of AttributeConverter instances
    :param attr: attribute name as string
    :param name_format: Which name-format it should be translated to
    :return: An Attribute instance
    """
    for aconv in acs:
        #print ac.format, name_format
        if aconv.name_format == name_format:
            #print "Found a name_form converter"
            return aconv.to_format(attr)
    return attr


def to_local_name(acs, attr):
    """
    :param acs: List of AttributeConverter instances
    :param attr: an Attribute instance
    :return: The local attribute name
    """
    for aconv in acs:
        lattr = aconv.from_format(attr)
        if lattr:
            return lattr

    return attr.friendly_name


def get_local_name(acs, attr, name_format):
    for aconv in acs:
        #print ac.format, name_format
        if aconv.name_format == name_format:
            return aconv._fro[attr]


def d_to_local_name(acs, attr):
    """
    :param acs: List of AttributeConverter instances
    :param attr: an Attribute dictionary
    :return: The local attribute name
    """
    for aconv in acs:
        lattr = aconv.d_from_format(attr)
        if lattr:
            return lattr

    # if everything else fails this might be good enough
    try:
        return attr["friendly_name"]
    except KeyError:
        raise ConverterError("Could not find local name for %s" % attr)


class AttributeConverter(object):
    """ Converts from an attribute statement to a key,value dictionary and
        vice-versa """

    def __init__(self, name_format=""):
        self.name_format = name_format
        self._to = None
        self._fro = None

    def adjust(self):
        """ If one of the transformations is not defined it is expected to
        be the mirror image of the other.
        """

        if self._fro is None and self._to is not None:
            self._fro = dict(
                [(value.lower(), key) for key, value in self._to.items()])
        if self._to is None and self.fro is not None:
            self._to = dict(
                [(value.lower, key) for key, value in self._fro.items()])

    def from_dict(self, mapdict):
        """ Import the attribute map from  a dictionary

        :param mapdict: The dictionary
        """

        self.name_format = mapdict["identifier"]
        try:
            self._fro = dict(
                [(k.lower(), v) for k, v in mapdict["fro"].items()])
        except KeyError:
            pass
        try:
            self._to = dict([(k.lower(), v) for k, v in mapdict["to"].items()])
        except KeyError:
            pass

        if self._fro is None and self._to is None:
            raise ConverterError("Missing specifications")

        if self._fro is None or self._to is None:
            self.adjust()

    def lcd_ava_from(self, attribute):
        """
        In nothing else works, this should

        :param attribute: An Attribute Instance
        :return:
        """
        try:
            name = attribute.friendly_name.strip()
        except AttributeError:
            name = attribute.name.strip()

        values = []
        for value in attribute.attribute_value:
            if not value.text:
                values.append('')
            else:
                values.append(value.text.strip())

        return name, values

    def fail_safe_fro(self, statement):
        """ In case there is not formats defined or if the name format is
        undefined

        :param statement: AttributeStatement instance
        :return: A dictionary with names and values
        """
        result = {}
        for attribute in statement.attribute:
            if attribute.name_format and \
                    attribute.name_format != NAME_FORMAT_UNSPECIFIED:
                continue
            try:
                name = attribute.friendly_name.strip()
            except AttributeError:
                name = attribute.name.strip()

            result[name] = []
            for value in attribute.attribute_value:
                if not value.text:
                    result[name].append('')
                else:
                    result[name].append(value.text.strip())
        return result

    def ava_from(self, attribute, allow_unknown=False):
        try:
            attr = self._fro[attribute.name.strip().lower()]
        except AttributeError:
            attr = attribute.friendly_name.strip().lower()
        except KeyError:
            if allow_unknown:
                try:
                    attr = attribute.name.strip().lower()
                except AttributeError:
                    attr = attribute.friendly_name.strip().lower()
            else:
                raise

        val = []
        for value in attribute.attribute_value:
            if value.extension_elements:
                ext = extension_elements_to_elements(value.extension_elements,
                                                     [saml])
                for ex in ext:
                    cval = {}
                    for key, (name, typ, mul) in ex.c_attributes.items():
                        exv = getattr(ex, name)
                        if exv:
                            cval[name] = exv
                    if ex.text:
                        cval["value"] = ex.text.strip()
                    val.append({ex.c_tag: cval})
            elif not value.text:
                val.append('')
            else:
                val.append(value.text.strip())

        return attr, val

    def fro(self, statement):
        """ Get the attributes and the attribute values.

        :param statement: The AttributeStatement.
        :return: A dictionary containing attributes and values
        """

        if not self.name_format:
            return self.fail_safe_fro(statement)

        result = {}
        for attribute in statement.attribute:
            if attribute.name_format and self.name_format and \
                    attribute.name_format != self.name_format:
                continue

            try:
                (key, val) = self.ava_from(attribute)
            except (KeyError, AttributeError):
                pass
            else:
                result[key] = val

        return result

    def to_format(self, attr):
        """ Creates an Attribute instance with name, name_format and
        friendly_name

        :param attr: The local name of the attribute
        :return: An Attribute instance
        """
        try:
            return factory(saml.Attribute,
                           name=self._to[attr],
                           name_format=self.name_format,
                           friendly_name=attr)
        except KeyError:
            return factory(saml.Attribute, name=attr)

    def from_format(self, attr):
        """ Find out the local name of an attribute
         
        :param attr: An saml.Attribute instance
        :return: The local attribute name or "" if no mapping could be made
        """
        if attr.name_format:
            if self.name_format == attr.name_format:
                try:
                    return self._fro[attr.name.lower()]
                except KeyError:
                    pass
        else:  # don't know the name format so try all I have
            try:
                return self._fro[attr.name.lower()]
            except KeyError:
                pass

        return ""

    def d_from_format(self, attr):
        """ Find out the local name of an attribute

        :param attr: An Attribute dictionary
        :return: The local attribute name or "" if no mapping could be made
        """
        if attr["name_format"]:
            if self.name_format == attr["name_format"]:
                try:
                    return self._fro[attr["name"].lower()]
                except KeyError:
                    pass
        else:  # don't know the name format so try all I have
            try:
                return self._fro[attr["name"].lower()]
            except KeyError:
                pass

        return ""

    def to_(self, attrvals):
        """ Create a list of Attribute instances.

        :param attrvals: A dictionary of attributes and values
        :return: A list of Attribute instances
        """
        attributes = []
        for key, value in attrvals.items():
            key = key.lower()
            try:
                attributes.append(factory(saml.Attribute,
                                          name=self._to[key],
                                          name_format=self.name_format,
                                          friendly_name=key,
                                          attribute_value=do_ava(value)))
            except KeyError:
                attributes.append(factory(saml.Attribute,
                                          name=key,
                                          attribute_value=do_ava(value)))

        return attributes


class AttributeConverterNOOP(AttributeConverter):
    """ Does a NOOP conversion, that is no conversion is made """

    def __init__(self, name_format=""):
        AttributeConverter.__init__(self, name_format)

    def to_(self, attrvals):
        """ Create a list of Attribute instances.

        :param attrvals: A dictionary of attributes and values
        :return: A list of Attribute instances
        """
        attributes = []
        for key, value in attrvals.items():
            key = key.lower()
            attributes.append(factory(saml.Attribute,
                                      name=key,
                                      name_format=self.name_format,
                                      attribute_value=do_ava(value)))

        return attributes

########NEW FILE########
__FILENAME__ = attribute_resolver
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Contains classes and functions that a SAML2.0 Service Provider (SP) may use
to do attribute aggregation.
"""
import logging
#from saml2 import client
from saml2 import BINDING_SOAP

logger = logging.getLogger(__name__)

DEFAULT_BINDING = BINDING_SOAP

class AttributeResolver(object):

    def __init__(self, saml2client, metadata=None, config=None):
        self.metadata = metadata

        self.saml2client = saml2client
        self.metadata = saml2client.config.metadata

    def extend(self, name_id, issuer, vo_members):
        """ 
        :param name_id: The identifier by which the subject is know
            among all the participents of the VO
        :param issuer: Who am I the poses the query
        :param vo_members: The entity IDs of the IdP who I'm going to ask
            for extra attributes
        :return: A dictionary with all the collected information about the
            subject
        """
        result = []
        for member in vo_members:            
            for ass in self.metadata.attribute_consuming_service(member):
                for attr_serv in ass.attribute_service:
                    logger.info(
                        "Send attribute request to %s" % attr_serv.location)
                    if attr_serv.binding != BINDING_SOAP:
                        continue
                    # attribute query assumes SOAP binding
                    session_info = self.saml2client.attribute_query(
                        name_id, attr_serv.location, issuer_id=issuer,
)
                    if session_info:
                        result.append(session_info)
        return result

########NEW FILE########
__FILENAME__ = authn
import logging
from urllib import urlencode
from urlparse import parse_qs
from urlparse import urlsplit
import time
import ldap
from saml2 import SAMLError
from saml2.aes import AESCipher
from saml2.httputil import Response
from saml2.httputil import make_cookie
from saml2.httputil import Redirect
from saml2.httputil import Unauthorized
from saml2.httputil import parse_cookie

__author__ = 'rolandh'

logger = logging.getLogger(__name__)


class AuthnFailure(SAMLError):
    pass


class EncodeError(SAMLError):
    pass


class UserAuthnMethod(object):
    def __init__(self, srv):
        self.srv = srv

    def __call__(self, *args, **kwargs):
        raise NotImplemented

    def authenticated_as(self, **kwargs):
        raise NotImplemented

    def verify(self, **kwargs):
        raise NotImplemented


def url_encode_params(params=None):
    if not isinstance(params, dict):
        raise EncodeError("You must pass in a dictionary!")
    params_list = []
    for k, v in params.items():
        if isinstance(v, list):
            params_list.extend([(k, x) for x in v])
        else:
            params_list.append((k, v))
    return urlencode(params_list)


def create_return_url(base, query, **kwargs):
    """
    Add a query string plus extra parameters to a base URL which may contain
    a query part already.

    :param base: redirect_uri may contain a query part, no fragment allowed.
    :param query: Old query part as a string
    :param kwargs: extra query parameters
    :return:
    """
    part = urlsplit(base)
    if part.fragment:
        raise ValueError("Base URL contained parts it shouldn't")

    for key, values in parse_qs(query).items():
        if key in kwargs:
            if isinstance(kwargs[key], basestring):
                kwargs[key] = [kwargs[key]]
            kwargs[key].extend(values)
        else:
            kwargs[key] = values

    if part.query:
        for key, values in parse_qs(part.query).items():
            if key in kwargs:
                if isinstance(kwargs[key], basestring):
                    kwargs[key] = [kwargs[key]]
                kwargs[key].extend(values)
            else:
                kwargs[key] = values

        _pre = base.split("?")[0]
    else:
        _pre = base

    logger.debug("kwargs: %s" % kwargs)

    return "%s?%s" % (_pre, url_encode_params(kwargs))


class UsernamePasswordMako(UserAuthnMethod):
    """Do user authentication using the normal username password form
    using Mako as template system"""
    cookie_name = "userpassmako"

    def __init__(self, srv, mako_template, template_lookup, pwd, return_to):
        """
        :param srv: The server instance
        :param mako_template: Which Mako template to use
        :param pwd: Username/password dictionary like database
        :param return_to: Where to send the user after authentication
        :return:
        """
        UserAuthnMethod.__init__(self, srv)
        self.mako_template = mako_template
        self.template_lookup = template_lookup
        self.passwd = pwd
        self.return_to = return_to
        self.active = {}
        self.query_param = "upm_answer"
        self.aes = AESCipher(self.srv.symkey, srv.iv)

    def __call__(self, cookie=None, policy_url=None, logo_url=None,
                 query="", **kwargs):
        """
        Put up the login form
        """
        if cookie:
            headers = [cookie]
        else:
            headers = []

        resp = Response(headers=headers)

        argv = {"login": "",
                "password": "",
                "action": "verify",
                "policy_url": policy_url,
                "logo_url": logo_url,
                "query": query}
        logger.info("do_authentication argv: %s" % argv)
        mte = self.template_lookup.get_template(self.mako_template)
        resp.message = mte.render(**argv)
        return resp

    def _verify(self, pwd, user):
        assert pwd == self.passwd[user]

    def verify(self, request, **kwargs):
        """
        Verifies that the given username and password was correct
        :param request: Either the query part of a URL a urlencoded
            body of a HTTP message or a parse such.
        :param kwargs: Catch whatever else is sent.
        :return: redirect back to where ever the base applications
            wants the user after authentication.
        """

        logger.debug("verify(%s)" % request)
        if isinstance(request, basestring):
            _dict = parse_qs(request)
        elif isinstance(request, dict):
            _dict = request
        else:
            raise ValueError("Wrong type of input")

        logger.debug("dict: %s" % _dict)
        logger.debug("passwd: %s" % self.passwd)
        # verify username and password
        try:
            self._verify(_dict["password"][0], _dict["login"][0])
            timestamp = str(int(time.mktime(time.gmtime())))
            info = self.aes.encrypt("::".join([_dict["login"][0], timestamp]))
            self.active[info] = timestamp
            cookie = make_cookie(self.cookie_name, info, self.srv.seed)
            return_to = create_return_url(self.return_to, _dict["query"][0],
                                          **{self.query_param: "true"})
            resp = Redirect(return_to, headers=[cookie])
        except (AssertionError, KeyError):
            resp = Unauthorized("Unknown user or wrong password")

        return resp

    def authenticated_as(self, cookie=None, **kwargs):
        if cookie is None:
            return None
        else:
            logger.debug("kwargs: %s" % kwargs)
            try:
                info, timestamp = parse_cookie(self.cookie_name,
                                               self.srv.seed, cookie)
                if self.active[info] == timestamp:
                    uid, _ts = self.aes.decrypt(info).split("::")
                    if timestamp == _ts:
                        return {"uid": uid}
            except Exception:
                pass

        return None

    def done(self, areq):
        try:
            _ = areq[self.query_param]
            return False
        except KeyError:
            return True


class SocialService(UserAuthnMethod):
    def __init__(self, social):
        UserAuthnMethod.__init__(self, None)
        self.social = social

    def __call__(self, server_env, cookie=None, sid="", query="", **kwargs):
        return self.social.begin(server_env, cookie, sid, query)

    def callback(self, server_env, cookie=None, sid="", query="", **kwargs):
        return self.social.callback(server_env, cookie, sid, query, **kwargs)


class AuthnMethodChooser(object):
    def __init__(self, methods=None):
        self.methods = methods

    def __call__(self, **kwargs):
        if not self.methods:
            raise SAMLError("No authentication methods defined")
        elif len(self.methods) == 1:
            return self.methods[0]
        else:
            pass  # TODO


class LDAPAuthn(UsernamePasswordMako):
    def __init__(self, srv, ldapsrv, return_to,
                 dn_pattern, mako_template, template_lookup):
        """
        :param srv: The server instance
        :param ldapsrv: Which LDAP server to us
        :param return_to: Where to send the user after authentication
        :return:
        """
        UsernamePasswordMako.__init__(self, srv, mako_template, template_lookup,
                                      None, return_to)

        self.ldap = ldap.initialize(ldapsrv)
        self.ldap.protocol_version = 3
        self.ldap.set_option(ldap.OPT_REFERRALS, 0)
        self.dn_pattern = dn_pattern

    def _verify(self, pwd, user):
        """
        Verifies the username and password agains a LDAP server
        :param pwd: The password
        :param user: The username
        :return: AssertionError if the LDAP verification failed.
        """
        _dn = self.dn_pattern % user
        try:
            self.ldap.simple_bind_s(_dn, pwd)
        except Exception:
            raise AssertionError()

########NEW FILE########
__FILENAME__ = ippword
#!/usr/bin/env python

#
# Generated Sun Apr 21 10:04:52 2013 by parse_xsd.py version 0.5.
#

"""
The Internet Protocol Password class is applicable when a principal is
authenticated through the use of a provided IP address, in addition to a
username/password.
"""

import saml2
from saml2 import SamlBase


NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword'


class PhysicalVerification(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PhysicalVerification element """

    c_tag = 'PhysicalVerification'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['credentialLevel'] = ('credential_level', 'None', False)

    def __init__(self,
                 credential_level=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.credential_level = credential_level


def physical_verification_from_string(xml_string):
    return saml2.create_class_from_xml_string(PhysicalVerification, xml_string)


class Generation(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Generation element """

    c_tag = 'Generation'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['mechanism'] = ('mechanism', 'None', True)

    def __init__(self,
                 mechanism=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.mechanism = mechanism


def generation_from_string(xml_string):
    return saml2.create_class_from_xml_string(Generation, xml_string)


class NymType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:nymType element """

    c_tag = 'nymType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['anonymity', 'verinymity', 'pseudonymity']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def nym_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NymType_, xml_string)


class GoverningAgreementRefType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:GoverningAgreementRefType element """

    c_tag = 'GoverningAgreementRefType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['governingAgreementRef'] = (
        'governing_agreement_ref', 'anyURI', True)

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref


def governing_agreement_ref_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRefType_,
                                              xml_string)


class KeySharingType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:KeySharingType element """

    c_tag = 'KeySharingType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['sharing'] = ('sharing', 'boolean', True)

    def __init__(self,
                 sharing=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.sharing = sharing


def key_sharing_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharingType_, xml_string)


class RestrictedLengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:RestrictedLengthType element """

    c_tag = 'RestrictedLengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'None', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def restricted_length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedLengthType_, xml_string)


class AlphabetType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AlphabetType element """

    c_tag = 'AlphabetType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['requiredChars'] = ('required_chars', 'string', True)
    c_attributes['excludedChars'] = ('excluded_chars', 'string', False)
    c_attributes['case'] = ('case', 'string', False)

    def __init__(self,
                 required_chars=None,
                 excluded_chars=None,
                 case=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.required_chars = required_chars
        self.excluded_chars = excluded_chars
        self.case = case


def alphabet_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AlphabetType_, xml_string)


class DeviceTypeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:DeviceTypeType element """

    c_tag = 'DeviceTypeType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['hardware', 'software']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def device_type_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DeviceTypeType_, xml_string)


class BooleanType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:booleanType element """

    c_tag = 'booleanType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN', 'enumeration': ['true', 'false']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def boolean_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(BooleanType_, xml_string)


class TimeSyncTokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:TimeSyncTokenType element """

    c_tag = 'TimeSyncTokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['DeviceType'] = ('device_type', DeviceTypeType_, True)
    c_attributes['SeedLength'] = ('seed_length', 'integer', True)
    c_attributes['DeviceInHand'] = ('device_in_hand', BooleanType_, True)

    def __init__(self,
                 device_type=None,
                 seed_length=None,
                 device_in_hand=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.device_type = device_type
        self.seed_length = seed_length
        self.device_in_hand = device_in_hand


def time_sync_token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncTokenType_, xml_string)


class ActivationLimitDurationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationLimitDurationType element """

    c_tag = 'ActivationLimitDurationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['duration'] = ('duration', 'duration', True)

    def __init__(self,
                 duration=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.duration = duration


def activation_limit_duration_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDurationType_,
                                              xml_string)


class ActivationLimitUsagesType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationLimitUsagesType element """

    c_tag = 'ActivationLimitUsagesType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['number'] = ('number', 'integer', True)

    def __init__(self,
                 number=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.number = number


def activation_limit_usages_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsagesType_,
                                              xml_string)


class ActivationLimitSessionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationLimitSessionType element """

    c_tag = 'ActivationLimitSessionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def activation_limit_session_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSessionType_,
                                              xml_string)


class LengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:LengthType element """

    c_tag = 'LengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'integer', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LengthType_, xml_string)


class MediumType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:mediumType element """

    c_tag = 'mediumType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['memory', 'smartcard', 'token',
                                    'MobileDevice', 'MobileAuthCard']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def medium_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(MediumType_, xml_string)


class KeyStorageType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:KeyStorageType element """

    c_tag = 'KeyStorageType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['medium'] = ('medium', MediumType_, True)

    def __init__(self,
                 medium=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.medium = medium


def key_storage_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorageType_, xml_string)


class ExtensionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ExtensionType element """

    c_tag = 'ExtensionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def extension_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionType_, xml_string)


class KeySharing(KeySharingType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:KeySharing element """

    c_tag = 'KeySharing'
    c_namespace = NAMESPACE
    c_children = KeySharingType_.c_children.copy()
    c_attributes = KeySharingType_.c_attributes.copy()
    c_child_order = KeySharingType_.c_child_order[:]
    c_cardinality = KeySharingType_.c_cardinality.copy()


def key_sharing_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharing, xml_string)


class KeyStorage(KeyStorageType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:KeyStorage element """

    c_tag = 'KeyStorage'
    c_namespace = NAMESPACE
    c_children = KeyStorageType_.c_children.copy()
    c_attributes = KeyStorageType_.c_attributes.copy()
    c_child_order = KeyStorageType_.c_child_order[:]
    c_cardinality = KeyStorageType_.c_cardinality.copy()


def key_storage_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorage, xml_string)


class TimeSyncToken(TimeSyncTokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:TimeSyncToken element """

    c_tag = 'TimeSyncToken'
    c_namespace = NAMESPACE
    c_children = TimeSyncTokenType_.c_children.copy()
    c_attributes = TimeSyncTokenType_.c_attributes.copy()
    c_child_order = TimeSyncTokenType_.c_child_order[:]
    c_cardinality = TimeSyncTokenType_.c_cardinality.copy()


def time_sync_token_from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncToken, xml_string)


class Length(LengthType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Length element """

    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = LengthType_.c_children.copy()
    c_attributes = LengthType_.c_attributes.copy()
    c_child_order = LengthType_.c_child_order[:]
    c_cardinality = LengthType_.c_cardinality.copy()


def length_from_string(xml_string):
    return saml2.create_class_from_xml_string(Length, xml_string)


class GoverningAgreementRef(GoverningAgreementRefType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:GoverningAgreementRef element """

    c_tag = 'GoverningAgreementRef'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementRefType_.c_children.copy()
    c_attributes = GoverningAgreementRefType_.c_attributes.copy()
    c_child_order = GoverningAgreementRefType_.c_child_order[:]
    c_cardinality = GoverningAgreementRefType_.c_cardinality.copy()


def governing_agreement_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRef, xml_string)


class GoverningAgreementsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:GoverningAgreementsType element """

    c_tag = 'GoverningAgreementsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}GoverningAgreementRef'] = (
        'governing_agreement_ref', [GoverningAgreementRef])
    c_cardinality['governing_agreement_ref'] = {"min": 1}
    c_child_order.extend(['governing_agreement_ref'])

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref or []


def governing_agreements_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementsType_,
                                              xml_string)


class RestrictedPasswordType_Length(RestrictedLengthType_):
    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = RestrictedLengthType_.c_children.copy()
    c_attributes = RestrictedLengthType_.c_attributes.copy()
    c_child_order = RestrictedLengthType_.c_child_order[:]
    c_cardinality = RestrictedLengthType_.c_cardinality.copy()


def restricted_password_type__length_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_Length,
                                              xml_string)


class Alphabet(AlphabetType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Alphabet element """

    c_tag = 'Alphabet'
    c_namespace = NAMESPACE
    c_children = AlphabetType_.c_children.copy()
    c_attributes = AlphabetType_.c_attributes.copy()
    c_child_order = AlphabetType_.c_child_order[:]
    c_cardinality = AlphabetType_.c_cardinality.copy()


def alphabet_from_string(xml_string):
    return saml2.create_class_from_xml_string(Alphabet, xml_string)


class ActivationLimitDuration(ActivationLimitDurationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationLimitDuration element """

    c_tag = 'ActivationLimitDuration'
    c_namespace = NAMESPACE
    c_children = ActivationLimitDurationType_.c_children.copy()
    c_attributes = ActivationLimitDurationType_.c_attributes.copy()
    c_child_order = ActivationLimitDurationType_.c_child_order[:]
    c_cardinality = ActivationLimitDurationType_.c_cardinality.copy()


def activation_limit_duration_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDuration,
                                              xml_string)


class ActivationLimitUsages(ActivationLimitUsagesType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationLimitUsages element """

    c_tag = 'ActivationLimitUsages'
    c_namespace = NAMESPACE
    c_children = ActivationLimitUsagesType_.c_children.copy()
    c_attributes = ActivationLimitUsagesType_.c_attributes.copy()
    c_child_order = ActivationLimitUsagesType_.c_child_order[:]
    c_cardinality = ActivationLimitUsagesType_.c_cardinality.copy()


def activation_limit_usages_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsages, xml_string)


class ActivationLimitSession(ActivationLimitSessionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationLimitSession element """

    c_tag = 'ActivationLimitSession'
    c_namespace = NAMESPACE
    c_children = ActivationLimitSessionType_.c_children.copy()
    c_attributes = ActivationLimitSessionType_.c_attributes.copy()
    c_child_order = ActivationLimitSessionType_.c_child_order[:]
    c_cardinality = ActivationLimitSessionType_.c_cardinality.copy()


def activation_limit_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSession,
                                              xml_string)


class Extension(ExtensionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Extension element """

    c_tag = 'Extension'
    c_namespace = NAMESPACE
    c_children = ExtensionType_.c_children.copy()
    c_attributes = ExtensionType_.c_attributes.copy()
    c_child_order = ExtensionType_.c_child_order[:]
    c_cardinality = ExtensionType_.c_cardinality.copy()


def extension_from_string(xml_string):
    return saml2.create_class_from_xml_string(Extension, xml_string)


class SharedSecretChallengeResponseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SharedSecretChallengeResponseType element """

    c_tag = 'SharedSecretChallengeResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['method'] = ('method', 'anyURI', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 method=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.method = method


def shared_secret_challenge_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        SharedSecretChallengeResponseType_, xml_string)


class PublicKeyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PublicKeyType element """

    c_tag = 'PublicKeyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['keyValidation'] = ('key_validation', 'None', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 key_validation=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.key_validation = key_validation


def public_key_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicKeyType_, xml_string)


class GoverningAgreements(GoverningAgreementsType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:GoverningAgreements element """

    c_tag = 'GoverningAgreements'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementsType_.c_children.copy()
    c_attributes = GoverningAgreementsType_.c_attributes.copy()
    c_child_order = GoverningAgreementsType_.c_child_order[:]
    c_cardinality = GoverningAgreementsType_.c_cardinality.copy()


def governing_agreements_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreements, xml_string)


class PasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PasswordType element """

    c_tag = 'PasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'alphabet', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PasswordType_, xml_string)


class RestrictedPasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:RestrictedPasswordType element """

    c_tag = 'RestrictedPasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Length'] = (
        'length', RestrictedPasswordType_Length)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def restricted_password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_,
                                              xml_string)


class TokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:TokenType element """

    c_tag = 'TokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}TimeSyncToken'] = (
        'time_sync_token', TimeSyncToken)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['time_sync_token', 'extension'])

    def __init__(self,
                 time_sync_token=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.time_sync_token = time_sync_token
        self.extension = extension or []


def token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TokenType_, xml_string)


class ActivationLimitType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationLimitType element """

    c_tag = 'ActivationLimitType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ActivationLimitDuration'] = (
        'activation_limit_duration', ActivationLimitDuration)
    c_cardinality['activation_limit_duration'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ActivationLimitUsages'] = (
        'activation_limit_usages', ActivationLimitUsages)
    c_cardinality['activation_limit_usages'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ActivationLimitSession'] = (
        'activation_limit_session', ActivationLimitSession)
    c_cardinality['activation_limit_session'] = {"min": 0, "max": 1}
    c_child_order.extend(
        ['activation_limit_duration', 'activation_limit_usages',
         'activation_limit_session'])

    def __init__(self,
                 activation_limit_duration=None,
                 activation_limit_usages=None,
                 activation_limit_session=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_limit_duration = activation_limit_duration
        self.activation_limit_usages = activation_limit_usages
        self.activation_limit_session = activation_limit_session


def activation_limit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitType_, xml_string)


class ExtensionOnlyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ExtensionOnlyType element """

    c_tag = 'ExtensionOnlyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []


def extension_only_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionOnlyType_, xml_string)


class WrittenConsent(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:WrittenConsent element """

    c_tag = 'WrittenConsent'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def written_consent_from_string(xml_string):
    return saml2.create_class_from_xml_string(WrittenConsent, xml_string)


class SubscriberLineNumber(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SubscriberLineNumber element """

    c_tag = 'SubscriberLineNumber'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def subscriber_line_number_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubscriberLineNumber, xml_string)


class UserSuffix(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:UserSuffix element """

    c_tag = 'UserSuffix'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def user_suffix_from_string(xml_string):
    return saml2.create_class_from_xml_string(UserSuffix, xml_string)


class Password(PasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Password element """

    c_tag = 'Password'
    c_namespace = NAMESPACE
    c_children = PasswordType_.c_children.copy()
    c_attributes = PasswordType_.c_attributes.copy()
    c_child_order = PasswordType_.c_child_order[:]
    c_cardinality = PasswordType_.c_cardinality.copy()


def password_from_string(xml_string):
    return saml2.create_class_from_xml_string(Password, xml_string)


class Token(TokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Token element """

    c_tag = 'Token'
    c_namespace = NAMESPACE
    c_children = TokenType_.c_children.copy()
    c_attributes = TokenType_.c_attributes.copy()
    c_child_order = TokenType_.c_child_order[:]
    c_cardinality = TokenType_.c_cardinality.copy()


def token_from_string(xml_string):
    return saml2.create_class_from_xml_string(Token, xml_string)


class Smartcard(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Smartcard element """

    c_tag = 'Smartcard'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def smartcard_from_string(xml_string):
    return saml2.create_class_from_xml_string(Smartcard, xml_string)


class ActivationLimit(ActivationLimitType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationLimit element """

    c_tag = 'ActivationLimit'
    c_namespace = NAMESPACE
    c_children = ActivationLimitType_.c_children.copy()
    c_attributes = ActivationLimitType_.c_attributes.copy()
    c_child_order = ActivationLimitType_.c_child_order[:]
    c_cardinality = ActivationLimitType_.c_cardinality.copy()


def activation_limit_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimit, xml_string)


class PreviousSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PreviousSession element """

    c_tag = 'PreviousSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def previous_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(PreviousSession, xml_string)


class ResumeSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ResumeSession element """

    c_tag = 'ResumeSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def resume_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ResumeSession, xml_string)


class ZeroKnowledge(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ZeroKnowledge element """

    c_tag = 'ZeroKnowledge'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def zero_knowledge_from_string(xml_string):
    return saml2.create_class_from_xml_string(ZeroKnowledge, xml_string)


class SharedSecretChallengeResponse(SharedSecretChallengeResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SharedSecretChallengeResponse element """

    c_tag = 'SharedSecretChallengeResponse'
    c_namespace = NAMESPACE
    c_children = SharedSecretChallengeResponseType_.c_children.copy()
    c_attributes = SharedSecretChallengeResponseType_.c_attributes.copy()
    c_child_order = SharedSecretChallengeResponseType_.c_child_order[:]
    c_cardinality = SharedSecretChallengeResponseType_.c_cardinality.copy()


def shared_secret_challenge_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretChallengeResponse,
                                              xml_string)


class DigSig(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:DigSig element """

    c_tag = 'DigSig'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def dig_sig_from_string(xml_string):
    return saml2.create_class_from_xml_string(DigSig, xml_string)


class AsymmetricDecryption(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AsymmetricDecryption element """

    c_tag = 'AsymmetricDecryption'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_decryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricDecryption, xml_string)


class AsymmetricKeyAgreement(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AsymmetricKeyAgreement element """

    c_tag = 'AsymmetricKeyAgreement'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_key_agreement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricKeyAgreement,
                                              xml_string)


class IPAddress(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:IPAddress element """

    c_tag = 'IPAddress'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_address_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPAddress, xml_string)


class SharedSecretDynamicPlaintext(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SharedSecretDynamicPlaintext element """

    c_tag = 'SharedSecretDynamicPlaintext'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def shared_secret_dynamic_plaintext_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretDynamicPlaintext,
                                              xml_string)


class HTTP(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:HTTP element """

    c_tag = 'HTTP'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def http_from_string(xml_string):
    return saml2.create_class_from_xml_string(HTTP, xml_string)


class IPSec(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:IPSec element """

    c_tag = 'IPSec'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_sec_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPSec, xml_string)


class WTLS(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:WTLS element """

    c_tag = 'WTLS'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def wtls_from_string(xml_string):
    return saml2.create_class_from_xml_string(WTLS, xml_string)


class MobileNetworkNoEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:MobileNetworkNoEncryption element """

    c_tag = 'MobileNetworkNoEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_no_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkNoEncryption,
                                              xml_string)


class MobileNetworkRadioEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:MobileNetworkRadioEncryption element """

    c_tag = 'MobileNetworkRadioEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_radio_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkRadioEncryption,
                                              xml_string)


class MobileNetworkEndToEndEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:MobileNetworkEndToEndEncryption element """

    c_tag = 'MobileNetworkEndToEndEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_end_to_end_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkEndToEndEncryption,
                                              xml_string)


class SSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SSL element """

    c_tag = 'SSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ssl_from_string(xml_string):
    return saml2.create_class_from_xml_string(SSL, xml_string)


class PSTN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PSTN element """

    c_tag = 'PSTN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def pstn_from_string(xml_string):
    return saml2.create_class_from_xml_string(PSTN, xml_string)


class ISDN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ISDN element """

    c_tag = 'ISDN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def isdn_from_string(xml_string):
    return saml2.create_class_from_xml_string(ISDN, xml_string)


class ADSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ADSL element """

    c_tag = 'ADSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def adsl_from_string(xml_string):
    return saml2.create_class_from_xml_string(ADSL, xml_string)


class SwitchAudit(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SwitchAudit element """

    c_tag = 'SwitchAudit'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def switch_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SwitchAudit, xml_string)


class DeactivationCallCenter(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:DeactivationCallCenter element """

    c_tag = 'DeactivationCallCenter'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def deactivation_call_center_from_string(xml_string):
    return saml2.create_class_from_xml_string(DeactivationCallCenter,
                                              xml_string)


class IdentificationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:IdentificationType element """

    c_tag = 'IdentificationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}PhysicalVerification'] = (
        'physical_verification', PhysicalVerification)
    c_cardinality['physical_verification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}WrittenConsent'] = (
        'written_consent', WrittenConsent)
    c_cardinality['written_consent'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['nym'] = ('nym', NymType_, False)
    c_child_order.extend(
        ['physical_verification', 'written_consent', 'governing_agreements',
         'extension'])

    def __init__(self,
                 physical_verification=None,
                 written_consent=None,
                 governing_agreements=None,
                 extension=None,
                 nym=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.physical_verification = physical_verification
        self.written_consent = written_consent
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.nym = nym


def identification_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IdentificationType_, xml_string)


class AuthenticatorTransportProtocolType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AuthenticatorTransportProtocolType element """

    c_tag = 'AuthenticatorTransportProtocolType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}HTTP'] = (
        'http', HTTP)
    c_cardinality['http'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}SSL'] = (
        'ssl', SSL)
    c_cardinality['ssl'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}MobileNetworkNoEncryption'] = (
        'mobile_network_no_encryption', MobileNetworkNoEncryption)
    c_cardinality['mobile_network_no_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}MobileNetworkRadioEncryption'] = (
        'mobile_network_radio_encryption', MobileNetworkRadioEncryption)
    c_cardinality['mobile_network_radio_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}MobileNetworkEndToEndEncryption'] = (
        'mobile_network_end_to_end_encryption', MobileNetworkEndToEndEncryption)
    c_cardinality['mobile_network_end_to_end_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}WTLS'] = (
        'wtls', WTLS)
    c_cardinality['wtls'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}IPSec'] = (
        'ip_sec', IPSec)
    c_cardinality['ip_sec'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}PSTN'] = (
        'pstn', PSTN)
    c_cardinality['pstn'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ISDN'] = (
        'isdn', ISDN)
    c_cardinality['isdn'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ADSL'] = (
        'adsl', ADSL)
    c_cardinality['adsl'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['http', 'ssl', 'mobile_network_no_encryption',
                          'mobile_network_radio_encryption',
                          'mobile_network_end_to_end_encryption', 'wtls',
                          'ip_sec', 'pstn', 'isdn', 'adsl', 'extension'])

    def __init__(self,
                 http=None,
                 ssl=None,
                 mobile_network_no_encryption=None,
                 mobile_network_radio_encryption=None,
                 mobile_network_end_to_end_encryption=None,
                 wtls=None,
                 ip_sec=None,
                 pstn=None,
                 isdn=None,
                 adsl=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.http = http
        self.ssl = ssl
        self.mobile_network_no_encryption = mobile_network_no_encryption
        self.mobile_network_radio_encryption = mobile_network_radio_encryption
        self.mobile_network_end_to_end_encryption = mobile_network_end_to_end_encryption
        self.wtls = wtls
        self.ip_sec = ip_sec
        self.pstn = pstn
        self.isdn = isdn
        self.adsl = adsl
        self.extension = extension or []


def authenticator_transport_protocol_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        AuthenticatorTransportProtocolType_, xml_string)


class RestrictedPassword(RestrictedPasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:RestrictedPassword element """

    c_tag = 'RestrictedPassword'
    c_namespace = NAMESPACE
    c_children = RestrictedPasswordType_.c_children.copy()
    c_attributes = RestrictedPasswordType_.c_attributes.copy()
    c_child_order = RestrictedPasswordType_.c_child_order[:]
    c_cardinality = RestrictedPasswordType_.c_cardinality.copy()


def restricted_password_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPassword, xml_string)


class ActivationPinType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationPinType element """

    c_tag = 'ActivationPinType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ActivationLimit'] = (
        'activation_limit', ActivationLimit)
    c_cardinality['activation_limit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['length', 'alphabet', 'generation', 'activation_limit', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 activation_limit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.activation_limit = activation_limit
        self.extension = extension or []


def activation_pin_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPinType_, xml_string)


class SecurityAuditType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SecurityAuditType element """

    c_tag = 'SecurityAuditType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}SwitchAudit'] = (
        'switch_audit', SwitchAudit)
    c_cardinality['switch_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['switch_audit', 'extension'])

    def __init__(self,
                 switch_audit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.switch_audit = switch_audit
        self.extension = extension or []


def security_audit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAuditType_, xml_string)


class AuthenticatorBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AuthenticatorBaseType element """

    c_tag = 'AuthenticatorBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Password'] = (
        'password', Password)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}IPAddress'] = (
        'ip_address', IPAddress)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['password', 'ip_address', 'extension'])

    def __init__(self,
                 password=None,
                 ip_address=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.password = password
        self.ip_address = ip_address
        self.extension = extension or []


def authenticator_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorBaseType_,
                                              xml_string)


class Identification(IdentificationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Identification element """

    c_tag = 'Identification'
    c_namespace = NAMESPACE
    c_children = IdentificationType_.c_children.copy()
    c_attributes = IdentificationType_.c_attributes.copy()
    c_child_order = IdentificationType_.c_child_order[:]
    c_cardinality = IdentificationType_.c_cardinality.copy()


def identification_from_string(xml_string):
    return saml2.create_class_from_xml_string(Identification, xml_string)


class ActivationPin(ActivationPinType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ActivationPin element """

    c_tag = 'ActivationPin'
    c_namespace = NAMESPACE
    c_children = ActivationPinType_.c_children.copy()
    c_attributes = ActivationPinType_.c_attributes.copy()
    c_child_order = ActivationPinType_.c_child_order[:]
    c_cardinality = ActivationPinType_.c_cardinality.copy()


def activation_pin_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPin, xml_string)


class Authenticator(AuthenticatorBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:Authenticator element """

    c_tag = 'Authenticator'
    c_namespace = NAMESPACE
    c_children = AuthenticatorBaseType_.c_children.copy()
    c_attributes = AuthenticatorBaseType_.c_attributes.copy()
    c_child_order = AuthenticatorBaseType_.c_child_order[:]
    c_cardinality = AuthenticatorBaseType_.c_cardinality.copy()


def authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(Authenticator, xml_string)


class AuthenticatorTransportProtocol(AuthenticatorTransportProtocolType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AuthenticatorTransportProtocol element """

    c_tag = 'AuthenticatorTransportProtocol'
    c_namespace = NAMESPACE
    c_children = AuthenticatorTransportProtocolType_.c_children.copy()
    c_attributes = AuthenticatorTransportProtocolType_.c_attributes.copy()
    c_child_order = AuthenticatorTransportProtocolType_.c_child_order[:]
    c_cardinality = AuthenticatorTransportProtocolType_.c_cardinality.copy()


def authenticator_transport_protocol_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorTransportProtocol,
                                              xml_string)


class SecurityAudit(SecurityAuditType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SecurityAudit element """

    c_tag = 'SecurityAudit'
    c_namespace = NAMESPACE
    c_children = SecurityAuditType_.c_children.copy()
    c_attributes = SecurityAuditType_.c_attributes.copy()
    c_child_order = SecurityAuditType_.c_child_order[:]
    c_cardinality = SecurityAuditType_.c_cardinality.copy()


def security_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAudit, xml_string)


class OperationalProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:OperationalProtectionType element """

    c_tag = 'OperationalProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}SecurityAudit'] = (
        'security_audit', SecurityAudit)
    c_cardinality['security_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}DeactivationCallCenter'] = (
        'deactivation_call_center', DeactivationCallCenter)
    c_cardinality['deactivation_call_center'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['security_audit', 'deactivation_call_center', 'extension'])

    def __init__(self,
                 security_audit=None,
                 deactivation_call_center=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.security_audit = security_audit
        self.deactivation_call_center = deactivation_call_center
        self.extension = extension or []


def operational_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtectionType_,
                                              xml_string)


class PrincipalAuthenticationMechanismType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PrincipalAuthenticationMechanismType element """

    c_tag = 'PrincipalAuthenticationMechanismType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Token'] = (
        'token', Token)
    c_cardinality['token'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Smartcard'] = (
        'smartcard', Smartcard)
    c_cardinality['smartcard'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['preauth'] = ('preauth', 'integer', False)
    c_child_order.extend(
        ['password', 'restricted_password', 'token', 'smartcard',
         'activation_pin', 'extension'])

    def __init__(self,
                 password=None,
                 restricted_password=None,
                 token=None,
                 smartcard=None,
                 activation_pin=None,
                 extension=None,
                 preauth=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.password = password
        self.restricted_password = restricted_password
        self.token = token
        self.smartcard = smartcard
        self.activation_pin = activation_pin
        self.extension = extension or []
        self.preauth = preauth


def principal_authentication_mechanism_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        PrincipalAuthenticationMechanismType_, xml_string)


class KeyActivationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:KeyActivationType element """

    c_tag = 'KeyActivationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword' \
        '}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['activation_pin', 'extension'])

    def __init__(self,
                 activation_pin=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_pin = activation_pin
        self.extension = extension or []


def key_activation_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivationType_, xml_string)


class KeyActivation(KeyActivationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:KeyActivation element """

    c_tag = 'KeyActivation'
    c_namespace = NAMESPACE
    c_children = KeyActivationType_.c_children.copy()
    c_attributes = KeyActivationType_.c_attributes.copy()
    c_child_order = KeyActivationType_.c_child_order[:]
    c_cardinality = KeyActivationType_.c_cardinality.copy()


def key_activation_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivation, xml_string)


class PrincipalAuthenticationMechanism(PrincipalAuthenticationMechanismType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PrincipalAuthenticationMechanism element """

    c_tag = 'PrincipalAuthenticationMechanism'
    c_namespace = NAMESPACE
    c_children = PrincipalAuthenticationMechanismType_.c_children.copy()
    c_attributes = PrincipalAuthenticationMechanismType_.c_attributes.copy()
    c_child_order = PrincipalAuthenticationMechanismType_.c_child_order[:]
    c_cardinality = PrincipalAuthenticationMechanismType_.c_cardinality.copy()


def principal_authentication_mechanism_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrincipalAuthenticationMechanism,
                                              xml_string)


class OperationalProtection(OperationalProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:OperationalProtection element """

    c_tag = 'OperationalProtection'
    c_namespace = NAMESPACE
    c_children = OperationalProtectionType_.c_children.copy()
    c_attributes = OperationalProtectionType_.c_attributes.copy()
    c_child_order = OperationalProtectionType_.c_child_order[:]
    c_cardinality = OperationalProtectionType_.c_cardinality.copy()


def operational_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtection, xml_string)


class PrivateKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PrivateKeyProtectionType element """

    c_tag = 'PrivateKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}KeySharing'] = (
        'key_sharing', KeySharing)
    c_cardinality['key_sharing'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['key_activation', 'key_storage', 'key_sharing', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 key_sharing=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.key_sharing = key_sharing
        self.extension = extension or []


def private_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtectionType_,
                                              xml_string)


class SecretKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SecretKeyProtectionType element """

    c_tag = 'SecretKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['key_activation', 'key_storage', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.extension = extension or []


def secret_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtectionType_,
                                              xml_string)


class AuthnMethodBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AuthnMethodBaseType element """

    c_tag = 'AuthnMethodBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}PrincipalAuthenticationMechanism'] = (
        'principal_authentication_mechanism', PrincipalAuthenticationMechanism)
    c_cardinality['principal_authentication_mechanism'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Authenticator'] = (
        'authenticator', Authenticator)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}AuthenticatorTransportProtocol'] = (
        'authenticator_transport_protocol', AuthenticatorTransportProtocol)
    c_cardinality['authenticator_transport_protocol'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword' \
        '}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['principal_authentication_mechanism', 'authenticator',
                          'authenticator_transport_protocol', 'extension'])

    def __init__(self,
                 principal_authentication_mechanism=None,
                 authenticator=None,
                 authenticator_transport_protocol=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.principal_authentication_mechanism = principal_authentication_mechanism
        self.authenticator = authenticator
        self.authenticator_transport_protocol = authenticator_transport_protocol
        self.extension = extension or []


def authn_method_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethodBaseType_, xml_string)


class SecretKeyProtection(SecretKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:SecretKeyProtection element """

    c_tag = 'SecretKeyProtection'
    c_namespace = NAMESPACE
    c_children = SecretKeyProtectionType_.c_children.copy()
    c_attributes = SecretKeyProtectionType_.c_attributes.copy()
    c_child_order = SecretKeyProtectionType_.c_child_order[:]
    c_cardinality = SecretKeyProtectionType_.c_cardinality.copy()


def secret_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtection, xml_string)


class PrivateKeyProtection(PrivateKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:PrivateKeyProtection element """

    c_tag = 'PrivateKeyProtection'
    c_namespace = NAMESPACE
    c_children = PrivateKeyProtectionType_.c_children.copy()
    c_attributes = PrivateKeyProtectionType_.c_attributes.copy()
    c_child_order = PrivateKeyProtectionType_.c_child_order[:]
    c_cardinality = PrivateKeyProtectionType_.c_cardinality.copy()


def private_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtection, xml_string)


class AuthnMethod(AuthnMethodBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AuthnMethod element """

    c_tag = 'AuthnMethod'
    c_namespace = NAMESPACE
    c_children = AuthnMethodBaseType_.c_children.copy()
    c_attributes = AuthnMethodBaseType_.c_attributes.copy()
    c_child_order = AuthnMethodBaseType_.c_child_order[:]
    c_cardinality = AuthnMethodBaseType_.c_cardinality.copy()


def authn_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethod, xml_string)


class TechnicalProtectionBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:TechnicalProtectionBaseType element """

    c_tag = 'TechnicalProtectionBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}PrivateKeyProtection'] = (
        'private_key_protection', PrivateKeyProtection)
    c_cardinality['private_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}SecretKeyProtection'] = (
        'secret_key_protection', SecretKeyProtection)
    c_cardinality['secret_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['private_key_protection', 'secret_key_protection', 'extension'])

    def __init__(self,
                 private_key_protection=None,
                 secret_key_protection=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.private_key_protection = private_key_protection
        self.secret_key_protection = secret_key_protection
        self.extension = extension or []


def technical_protection_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtectionBaseType_,
                                              xml_string)


class TechnicalProtection(TechnicalProtectionBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:TechnicalProtection element """

    c_tag = 'TechnicalProtection'
    c_namespace = NAMESPACE
    c_children = TechnicalProtectionBaseType_.c_children.copy()
    c_attributes = TechnicalProtectionBaseType_.c_attributes.copy()
    c_child_order = TechnicalProtectionBaseType_.c_child_order[:]
    c_cardinality = TechnicalProtectionBaseType_.c_cardinality.copy()


def technical_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtection, xml_string)


class AuthnContextDeclarationBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AuthnContextDeclarationBaseType element """

    c_tag = 'AuthnContextDeclarationBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Identification'] = (
        'identification', Identification)
    c_cardinality['identification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}TechnicalProtection'] = (
        'technical_protection', TechnicalProtection)
    c_cardinality['technical_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}OperationalProtection'] = (
        'operational_protection', OperationalProtection)
    c_cardinality['operational_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}AuthnMethod'] = (
        'authn_method', AuthnMethod)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ID'] = ('id', 'ID', False)
    c_child_order.extend(
        ['identification', 'technical_protection', 'operational_protection',
         'authn_method', 'governing_agreements', 'extension'])

    def __init__(self,
                 identification=None,
                 technical_protection=None,
                 operational_protection=None,
                 authn_method=None,
                 governing_agreements=None,
                 extension=None,
                 id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.identification = identification
        self.technical_protection = technical_protection
        self.operational_protection = operational_protection
        self.authn_method = authn_method
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.id = id


def authn_context_declaration_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextDeclarationBaseType_,
                                              xml_string)


class AuthenticationContextDeclaration(AuthnContextDeclarationBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:AuthenticationContextDeclaration element """

    c_tag = 'AuthenticationContextDeclaration'
    c_namespace = NAMESPACE
    c_children = AuthnContextDeclarationBaseType_.c_children.copy()
    c_attributes = AuthnContextDeclarationBaseType_.c_attributes.copy()
    c_child_order = AuthnContextDeclarationBaseType_.c_child_order[:]
    c_cardinality = AuthnContextDeclarationBaseType_.c_cardinality.copy()


def authentication_context_declaration_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticationContextDeclaration,
                                              xml_string)


#..................
# ['ComplexAuthenticator', 'ComplexAuthenticatorType']
class ComplexAuthenticatorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ComplexAuthenticatorType element """

    c_tag = 'ComplexAuthenticatorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}PreviousSession'] = (
        'previous_session', PreviousSession)
    c_cardinality['previous_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ResumeSession'] = (
        'resume_session', ResumeSession)
    c_cardinality['resume_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}DigSig'] = (
        'dig_sig', DigSig)
    c_cardinality['dig_sig'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ZeroKnowledge'] = (
        'zero_knowledge', ZeroKnowledge)
    c_cardinality['zero_knowledge'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}SharedSecretChallengeResponse'] = (
        'shared_secret_challenge_response', SharedSecretChallengeResponse)
    c_cardinality['shared_secret_challenge_response'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}SharedSecretDynamicPlaintext'] = (
        'shared_secret_dynamic_plaintext', SharedSecretDynamicPlaintext)
    c_cardinality['shared_secret_dynamic_plaintext'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}IPAddress'] = (
        'ip_address', IPAddress)
    c_cardinality['ip_address'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}AsymmetricDecryption'] = (
        'asymmetric_decryption', AsymmetricDecryption)
    c_cardinality['asymmetric_decryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}AsymmetricKeyAgreement'] = (
        'asymmetric_key_agreement', AsymmetricKeyAgreement)
    c_cardinality['asymmetric_key_agreement'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}SubscriberLineNumber'] = (
        'subscriber_line_number', SubscriberLineNumber)
    c_cardinality['subscriber_line_number'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}UserSuffix'] = (
        'user_suffix', UserSuffix)
    c_cardinality['user_suffix'] = {"min": 0, "max": 1}
    c_cardinality['complex_authenticator'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['previous_session', 'resume_session', 'dig_sig', 'password',
         'restricted_password', 'zero_knowledge',
         'shared_secret_challenge_response', 'shared_secret_dynamic_plaintext',
         'ip_address', 'asymmetric_decryption', 'asymmetric_key_agreement',
         'subscriber_line_number', 'user_suffix', 'complex_authenticator',
         'extension'])

    def __init__(self,
                 previous_session=None,
                 resume_session=None,
                 dig_sig=None,
                 password=None,
                 restricted_password=None,
                 zero_knowledge=None,
                 shared_secret_challenge_response=None,
                 shared_secret_dynamic_plaintext=None,
                 ip_address=None,
                 asymmetric_decryption=None,
                 asymmetric_key_agreement=None,
                 subscriber_line_number=None,
                 user_suffix=None,
                 complex_authenticator=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.previous_session = previous_session
        self.resume_session = resume_session
        self.dig_sig = dig_sig
        self.password = password
        self.restricted_password = restricted_password
        self.zero_knowledge = zero_knowledge
        self.shared_secret_challenge_response = shared_secret_challenge_response
        self.shared_secret_dynamic_plaintext = shared_secret_dynamic_plaintext
        self.ip_address = ip_address
        self.asymmetric_decryption = asymmetric_decryption
        self.asymmetric_key_agreement = asymmetric_key_agreement
        self.subscriber_line_number = subscriber_line_number
        self.user_suffix = user_suffix
        self.complex_authenticator = complex_authenticator
        self.extension = extension or []


def complex_authenticator_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticatorType_,
                                              xml_string)


class ComplexAuthenticator(ComplexAuthenticatorType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword:ComplexAuthenticator element """

    c_tag = 'ComplexAuthenticator'
    c_namespace = NAMESPACE
    c_children = ComplexAuthenticatorType_.c_children.copy()
    c_attributes = ComplexAuthenticatorType_.c_attributes.copy()
    c_child_order = ComplexAuthenticatorType_.c_child_order[:]
    c_cardinality = ComplexAuthenticatorType_.c_cardinality.copy()


def complex_authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticator, xml_string)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ComplexAuthenticatorType_.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
ComplexAuthenticator.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:InternetProtocolPassword}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ELEMENT_FROM_STRING = {
    AuthenticationContextDeclaration.c_tag: authentication_context_declaration_from_string,
    Identification.c_tag: identification_from_string,
    PhysicalVerification.c_tag: physical_verification_from_string,
    WrittenConsent.c_tag: written_consent_from_string,
    TechnicalProtection.c_tag: technical_protection_from_string,
    SecretKeyProtection.c_tag: secret_key_protection_from_string,
    PrivateKeyProtection.c_tag: private_key_protection_from_string,
    KeyActivation.c_tag: key_activation_from_string,
    KeySharing.c_tag: key_sharing_from_string,
    KeyStorage.c_tag: key_storage_from_string,
    SubscriberLineNumber.c_tag: subscriber_line_number_from_string,
    UserSuffix.c_tag: user_suffix_from_string,
    Password.c_tag: password_from_string,
    ActivationPin.c_tag: activation_pin_from_string,
    Token.c_tag: token_from_string,
    TimeSyncToken.c_tag: time_sync_token_from_string,
    Smartcard.c_tag: smartcard_from_string,
    Length.c_tag: length_from_string,
    ActivationLimit.c_tag: activation_limit_from_string,
    Generation.c_tag: generation_from_string,
    AuthnMethod.c_tag: authn_method_from_string,
    PrincipalAuthenticationMechanism.c_tag: principal_authentication_mechanism_from_string,
    Authenticator.c_tag: authenticator_from_string,
    ComplexAuthenticator.c_tag: complex_authenticator_from_string,
    PreviousSession.c_tag: previous_session_from_string,
    ResumeSession.c_tag: resume_session_from_string,
    ZeroKnowledge.c_tag: zero_knowledge_from_string,
    SharedSecretChallengeResponse.c_tag: shared_secret_challenge_response_from_string,
    SharedSecretChallengeResponseType_.c_tag: shared_secret_challenge_response_type__from_string,
    DigSig.c_tag: dig_sig_from_string,
    AsymmetricDecryption.c_tag: asymmetric_decryption_from_string,
    AsymmetricKeyAgreement.c_tag: asymmetric_key_agreement_from_string,
    PublicKeyType_.c_tag: public_key_type__from_string,
    IPAddress.c_tag: ip_address_from_string,
    SharedSecretDynamicPlaintext.c_tag: shared_secret_dynamic_plaintext_from_string,
    AuthenticatorTransportProtocol.c_tag: authenticator_transport_protocol_from_string,
    HTTP.c_tag: http_from_string,
    IPSec.c_tag: ip_sec_from_string,
    WTLS.c_tag: wtls_from_string,
    MobileNetworkNoEncryption.c_tag: mobile_network_no_encryption_from_string,
    MobileNetworkRadioEncryption.c_tag: mobile_network_radio_encryption_from_string,
    MobileNetworkEndToEndEncryption.c_tag: mobile_network_end_to_end_encryption_from_string,
    SSL.c_tag: ssl_from_string,
    PSTN.c_tag: pstn_from_string,
    ISDN.c_tag: isdn_from_string,
    ADSL.c_tag: adsl_from_string,
    OperationalProtection.c_tag: operational_protection_from_string,
    SecurityAudit.c_tag: security_audit_from_string,
    SwitchAudit.c_tag: switch_audit_from_string,
    DeactivationCallCenter.c_tag: deactivation_call_center_from_string,
    GoverningAgreements.c_tag: governing_agreements_from_string,
    GoverningAgreementRef.c_tag: governing_agreement_ref_from_string,
    NymType_.c_tag: nym_type__from_string,
    IdentificationType_.c_tag: identification_type__from_string,
    TechnicalProtectionBaseType_.c_tag: technical_protection_base_type__from_string,
    OperationalProtectionType_.c_tag: operational_protection_type__from_string,
    GoverningAgreementsType_.c_tag: governing_agreements_type__from_string,
    GoverningAgreementRefType_.c_tag: governing_agreement_ref_type__from_string,
    PrincipalAuthenticationMechanismType_.c_tag: principal_authentication_mechanism_type__from_string,
    ComplexAuthenticatorType_.c_tag: complex_authenticator_type__from_string,
    AuthenticatorTransportProtocolType_.c_tag: authenticator_transport_protocol_type__from_string,
    KeyActivationType_.c_tag: key_activation_type__from_string,
    KeySharingType_.c_tag: key_sharing_type__from_string,
    PrivateKeyProtectionType_.c_tag: private_key_protection_type__from_string,
    PasswordType_.c_tag: password_type__from_string,
    RestrictedPassword.c_tag: restricted_password_from_string,
    RestrictedPasswordType_.c_tag: restricted_password_type__from_string,
    RestrictedLengthType_.c_tag: restricted_length_type__from_string,
    ActivationPinType_.c_tag: activation_pin_type__from_string,
    Alphabet.c_tag: alphabet_from_string,
    AlphabetType_.c_tag: alphabet_type__from_string,
    TokenType_.c_tag: token_type__from_string,
    DeviceTypeType_.c_tag: device_type_type__from_string,
    BooleanType_.c_tag: boolean_type__from_string,
    TimeSyncTokenType_.c_tag: time_sync_token_type__from_string,
    ActivationLimitType_.c_tag: activation_limit_type__from_string,
    ActivationLimitDuration.c_tag: activation_limit_duration_from_string,
    ActivationLimitUsages.c_tag: activation_limit_usages_from_string,
    ActivationLimitSession.c_tag: activation_limit_session_from_string,
    ActivationLimitDurationType_.c_tag: activation_limit_duration_type__from_string,
    ActivationLimitUsagesType_.c_tag: activation_limit_usages_type__from_string,
    ActivationLimitSessionType_.c_tag: activation_limit_session_type__from_string,
    LengthType_.c_tag: length_type__from_string,
    MediumType_.c_tag: medium_type__from_string,
    KeyStorageType_.c_tag: key_storage_type__from_string,
    SecretKeyProtectionType_.c_tag: secret_key_protection_type__from_string,
    SecurityAuditType_.c_tag: security_audit_type__from_string,
    ExtensionOnlyType_.c_tag: extension_only_type__from_string,
    Extension.c_tag: extension_from_string,
    ExtensionType_.c_tag: extension_type__from_string,
    AuthnContextDeclarationBaseType_.c_tag: authn_context_declaration_base_type__from_string,
    AuthnMethodBaseType_.c_tag: authn_method_base_type__from_string,
    AuthenticatorBaseType_.c_tag: authenticator_base_type__from_string,
}

ELEMENT_BY_TAG = {
    'AuthenticationContextDeclaration': AuthenticationContextDeclaration,
    'Identification': Identification,
    'PhysicalVerification': PhysicalVerification,
    'WrittenConsent': WrittenConsent,
    'TechnicalProtection': TechnicalProtection,
    'SecretKeyProtection': SecretKeyProtection,
    'PrivateKeyProtection': PrivateKeyProtection,
    'KeyActivation': KeyActivation,
    'KeySharing': KeySharing,
    'KeyStorage': KeyStorage,
    'SubscriberLineNumber': SubscriberLineNumber,
    'UserSuffix': UserSuffix,
    'Password': Password,
    'ActivationPin': ActivationPin,
    'Token': Token,
    'TimeSyncToken': TimeSyncToken,
    'Smartcard': Smartcard,
    'Length': Length,
    'ActivationLimit': ActivationLimit,
    'Generation': Generation,
    'AuthnMethod': AuthnMethod,
    'PrincipalAuthenticationMechanism': PrincipalAuthenticationMechanism,
    'Authenticator': Authenticator,
    'ComplexAuthenticator': ComplexAuthenticator,
    'PreviousSession': PreviousSession,
    'ResumeSession': ResumeSession,
    'ZeroKnowledge': ZeroKnowledge,
    'SharedSecretChallengeResponse': SharedSecretChallengeResponse,
    'SharedSecretChallengeResponseType': SharedSecretChallengeResponseType_,
    'DigSig': DigSig,
    'AsymmetricDecryption': AsymmetricDecryption,
    'AsymmetricKeyAgreement': AsymmetricKeyAgreement,
    'PublicKeyType': PublicKeyType_,
    'IPAddress': IPAddress,
    'SharedSecretDynamicPlaintext': SharedSecretDynamicPlaintext,
    'AuthenticatorTransportProtocol': AuthenticatorTransportProtocol,
    'HTTP': HTTP,
    'IPSec': IPSec,
    'WTLS': WTLS,
    'MobileNetworkNoEncryption': MobileNetworkNoEncryption,
    'MobileNetworkRadioEncryption': MobileNetworkRadioEncryption,
    'MobileNetworkEndToEndEncryption': MobileNetworkEndToEndEncryption,
    'SSL': SSL,
    'PSTN': PSTN,
    'ISDN': ISDN,
    'ADSL': ADSL,
    'OperationalProtection': OperationalProtection,
    'SecurityAudit': SecurityAudit,
    'SwitchAudit': SwitchAudit,
    'DeactivationCallCenter': DeactivationCallCenter,
    'GoverningAgreements': GoverningAgreements,
    'GoverningAgreementRef': GoverningAgreementRef,
    'nymType': NymType_,
    'IdentificationType': IdentificationType_,
    'TechnicalProtectionBaseType': TechnicalProtectionBaseType_,
    'OperationalProtectionType': OperationalProtectionType_,
    'GoverningAgreementsType': GoverningAgreementsType_,
    'GoverningAgreementRefType': GoverningAgreementRefType_,
    'PrincipalAuthenticationMechanismType': PrincipalAuthenticationMechanismType_,
    'ComplexAuthenticatorType': ComplexAuthenticatorType_,
    'AuthenticatorTransportProtocolType': AuthenticatorTransportProtocolType_,
    'KeyActivationType': KeyActivationType_,
    'KeySharingType': KeySharingType_,
    'PrivateKeyProtectionType': PrivateKeyProtectionType_,
    'PasswordType': PasswordType_,
    'RestrictedPassword': RestrictedPassword,
    'RestrictedPasswordType': RestrictedPasswordType_,
    'RestrictedLengthType': RestrictedLengthType_,
    'ActivationPinType': ActivationPinType_,
    'Alphabet': Alphabet,
    'AlphabetType': AlphabetType_,
    'TokenType': TokenType_,
    'DeviceTypeType': DeviceTypeType_,
    'booleanType': BooleanType_,
    'TimeSyncTokenType': TimeSyncTokenType_,
    'ActivationLimitType': ActivationLimitType_,
    'ActivationLimitDuration': ActivationLimitDuration,
    'ActivationLimitUsages': ActivationLimitUsages,
    'ActivationLimitSession': ActivationLimitSession,
    'ActivationLimitDurationType': ActivationLimitDurationType_,
    'ActivationLimitUsagesType': ActivationLimitUsagesType_,
    'ActivationLimitSessionType': ActivationLimitSessionType_,
    'LengthType': LengthType_,
    'mediumType': MediumType_,
    'KeyStorageType': KeyStorageType_,
    'SecretKeyProtectionType': SecretKeyProtectionType_,
    'SecurityAuditType': SecurityAuditType_,
    'ExtensionOnlyType': ExtensionOnlyType_,
    'Extension': Extension,
    'ExtensionType': ExtensionType_,
    'AuthnContextDeclarationBaseType': AuthnContextDeclarationBaseType_,
    'AuthnMethodBaseType': AuthnMethodBaseType_,
    'AuthenticatorBaseType': AuthenticatorBaseType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = mobiletwofactor
#!/usr/bin/env python

#
# Generated Sun Apr 21 10:04:52 2013 by parse_xsd.py version 0.5.
#

"""
Reflects mobile contract customer registration procedures and a two-factor
based authentication. For example, a digital signing device with tamper
resistant memory for key storage, such as a GSM SIM, that
requires explicit proof of user identity and intent, such as a PIN or biometric.
"""

import saml2
from saml2 import SamlBase


NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract'


class PhysicalVerification(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PhysicalVerification element """

    c_tag = 'PhysicalVerification'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['credentialLevel'] = ('credential_level', 'None', False)

    def __init__(self,
                 credential_level=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.credential_level = credential_level


def physical_verification_from_string(xml_string):
    return saml2.create_class_from_xml_string(PhysicalVerification, xml_string)


class Generation(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Generation element """

    c_tag = 'Generation'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['mechanism'] = ('mechanism', 'None', True)

    def __init__(self,
                 mechanism=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.mechanism = mechanism


def generation_from_string(xml_string):
    return saml2.create_class_from_xml_string(Generation, xml_string)


class NymType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:nymType element """

    c_tag = 'nymType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['anonymity', 'verinymity', 'pseudonymity']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def nym_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NymType_, xml_string)


class GoverningAgreementRefType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:GoverningAgreementRefType element """

    c_tag = 'GoverningAgreementRefType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['governingAgreementRef'] = (
        'governing_agreement_ref', 'anyURI', True)

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref


def governing_agreement_ref_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRefType_,
                                              xml_string)


class KeySharingType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:KeySharingType element """

    c_tag = 'KeySharingType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['sharing'] = ('sharing', 'boolean', True)

    def __init__(self,
                 sharing=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.sharing = sharing


def key_sharing_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharingType_, xml_string)


class RestrictedLengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:RestrictedLengthType element """

    c_tag = 'RestrictedLengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'None', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def restricted_length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedLengthType_, xml_string)


class AlphabetType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AlphabetType element """

    c_tag = 'AlphabetType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['requiredChars'] = ('required_chars', 'string', True)
    c_attributes['excludedChars'] = ('excluded_chars', 'string', False)
    c_attributes['case'] = ('case', 'string', False)

    def __init__(self,
                 required_chars=None,
                 excluded_chars=None,
                 case=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.required_chars = required_chars
        self.excluded_chars = excluded_chars
        self.case = case


def alphabet_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AlphabetType_, xml_string)


class DeviceTypeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:DeviceTypeType element """

    c_tag = 'DeviceTypeType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['hardware', 'software']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def device_type_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DeviceTypeType_, xml_string)


class BooleanType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:booleanType element """

    c_tag = 'booleanType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN', 'enumeration': ['true', 'false']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def boolean_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(BooleanType_, xml_string)


class TimeSyncTokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:TimeSyncTokenType element """

    c_tag = 'TimeSyncTokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['DeviceType'] = ('device_type', DeviceTypeType_, True)
    c_attributes['SeedLength'] = ('seed_length', 'integer', True)
    c_attributes['DeviceInHand'] = ('device_in_hand', BooleanType_, True)

    def __init__(self,
                 device_type=None,
                 seed_length=None,
                 device_in_hand=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.device_type = device_type
        self.seed_length = seed_length
        self.device_in_hand = device_in_hand


def time_sync_token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncTokenType_, xml_string)


class ActivationLimitDurationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationLimitDurationType element """

    c_tag = 'ActivationLimitDurationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['duration'] = ('duration', 'duration', True)

    def __init__(self,
                 duration=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.duration = duration


def activation_limit_duration_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDurationType_,
                                              xml_string)


class ActivationLimitUsagesType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationLimitUsagesType element """

    c_tag = 'ActivationLimitUsagesType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['number'] = ('number', 'integer', True)

    def __init__(self,
                 number=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.number = number


def activation_limit_usages_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsagesType_,
                                              xml_string)


class ActivationLimitSessionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationLimitSessionType element """

    c_tag = 'ActivationLimitSessionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def activation_limit_session_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSessionType_,
                                              xml_string)


class LengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:LengthType element """

    c_tag = 'LengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'integer', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LengthType_, xml_string)


class MediumType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:mediumType element """

    c_tag = 'mediumType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['memory', 'smartcard', 'token',
                                    'MobileDevice', 'MobileAuthCard']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def medium_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(MediumType_, xml_string)


class ExtensionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ExtensionType element """

    c_tag = 'ExtensionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def extension_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionType_, xml_string)


class KeyStorageType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:KeyStorageType element """

    c_tag = 'KeyStorageType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['medium'] = ('medium', 'None', True)

    def __init__(self,
                 medium=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.medium = medium


def key_storage_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorageType_, xml_string)


class KeySharing(KeySharingType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:KeySharing element """

    c_tag = 'KeySharing'
    c_namespace = NAMESPACE
    c_children = KeySharingType_.c_children.copy()
    c_attributes = KeySharingType_.c_attributes.copy()
    c_child_order = KeySharingType_.c_child_order[:]
    c_cardinality = KeySharingType_.c_cardinality.copy()


def key_sharing_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharing, xml_string)


class KeyStorage(KeyStorageType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:KeyStorage element """

    c_tag = 'KeyStorage'
    c_namespace = NAMESPACE
    c_children = KeyStorageType_.c_children.copy()
    c_attributes = KeyStorageType_.c_attributes.copy()
    c_child_order = KeyStorageType_.c_child_order[:]
    c_cardinality = KeyStorageType_.c_cardinality.copy()


def key_storage_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorage, xml_string)


class TimeSyncToken(TimeSyncTokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:TimeSyncToken element """

    c_tag = 'TimeSyncToken'
    c_namespace = NAMESPACE
    c_children = TimeSyncTokenType_.c_children.copy()
    c_attributes = TimeSyncTokenType_.c_attributes.copy()
    c_child_order = TimeSyncTokenType_.c_child_order[:]
    c_cardinality = TimeSyncTokenType_.c_cardinality.copy()


def time_sync_token_from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncToken, xml_string)


class Length(LengthType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Length element """

    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = LengthType_.c_children.copy()
    c_attributes = LengthType_.c_attributes.copy()
    c_child_order = LengthType_.c_child_order[:]
    c_cardinality = LengthType_.c_cardinality.copy()


def length_from_string(xml_string):
    return saml2.create_class_from_xml_string(Length, xml_string)


class GoverningAgreementRef(GoverningAgreementRefType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:GoverningAgreementRef element """

    c_tag = 'GoverningAgreementRef'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementRefType_.c_children.copy()
    c_attributes = GoverningAgreementRefType_.c_attributes.copy()
    c_child_order = GoverningAgreementRefType_.c_child_order[:]
    c_cardinality = GoverningAgreementRefType_.c_cardinality.copy()


def governing_agreement_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRef, xml_string)


class GoverningAgreementsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:GoverningAgreementsType element """

    c_tag = 'GoverningAgreementsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}GoverningAgreementRef'] = (
        'governing_agreement_ref', [GoverningAgreementRef])
    c_cardinality['governing_agreement_ref'] = {"min": 1}
    c_child_order.extend(['governing_agreement_ref'])

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref or []


def governing_agreements_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementsType_,
                                              xml_string)


class RestrictedPasswordType_Length(RestrictedLengthType_):
    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = RestrictedLengthType_.c_children.copy()
    c_attributes = RestrictedLengthType_.c_attributes.copy()
    c_child_order = RestrictedLengthType_.c_child_order[:]
    c_cardinality = RestrictedLengthType_.c_cardinality.copy()


def restricted_password_type__length_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_Length,
                                              xml_string)


class Alphabet(AlphabetType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Alphabet element """

    c_tag = 'Alphabet'
    c_namespace = NAMESPACE
    c_children = AlphabetType_.c_children.copy()
    c_attributes = AlphabetType_.c_attributes.copy()
    c_child_order = AlphabetType_.c_child_order[:]
    c_cardinality = AlphabetType_.c_cardinality.copy()


def alphabet_from_string(xml_string):
    return saml2.create_class_from_xml_string(Alphabet, xml_string)


class ActivationLimitDuration(ActivationLimitDurationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationLimitDuration element """

    c_tag = 'ActivationLimitDuration'
    c_namespace = NAMESPACE
    c_children = ActivationLimitDurationType_.c_children.copy()
    c_attributes = ActivationLimitDurationType_.c_attributes.copy()
    c_child_order = ActivationLimitDurationType_.c_child_order[:]
    c_cardinality = ActivationLimitDurationType_.c_cardinality.copy()


def activation_limit_duration_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDuration,
                                              xml_string)


class ActivationLimitUsages(ActivationLimitUsagesType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationLimitUsages element """

    c_tag = 'ActivationLimitUsages'
    c_namespace = NAMESPACE
    c_children = ActivationLimitUsagesType_.c_children.copy()
    c_attributes = ActivationLimitUsagesType_.c_attributes.copy()
    c_child_order = ActivationLimitUsagesType_.c_child_order[:]
    c_cardinality = ActivationLimitUsagesType_.c_cardinality.copy()


def activation_limit_usages_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsages, xml_string)


class ActivationLimitSession(ActivationLimitSessionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationLimitSession element """

    c_tag = 'ActivationLimitSession'
    c_namespace = NAMESPACE
    c_children = ActivationLimitSessionType_.c_children.copy()
    c_attributes = ActivationLimitSessionType_.c_attributes.copy()
    c_child_order = ActivationLimitSessionType_.c_child_order[:]
    c_cardinality = ActivationLimitSessionType_.c_cardinality.copy()


def activation_limit_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSession,
                                              xml_string)


class Extension(ExtensionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Extension element """

    c_tag = 'Extension'
    c_namespace = NAMESPACE
    c_children = ExtensionType_.c_children.copy()
    c_attributes = ExtensionType_.c_attributes.copy()
    c_child_order = ExtensionType_.c_child_order[:]
    c_cardinality = ExtensionType_.c_cardinality.copy()


def extension_from_string(xml_string):
    return saml2.create_class_from_xml_string(Extension, xml_string)


class SharedSecretChallengeResponseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SharedSecretChallengeResponseType element """

    c_tag = 'SharedSecretChallengeResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['method'] = ('method', 'anyURI', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 method=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.method = method


def shared_secret_challenge_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        SharedSecretChallengeResponseType_, xml_string)


class PublicKeyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PublicKeyType element """

    c_tag = 'PublicKeyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['keyValidation'] = ('key_validation', 'None', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 key_validation=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.key_validation = key_validation


def public_key_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicKeyType_, xml_string)


class GoverningAgreements(GoverningAgreementsType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:GoverningAgreements element """

    c_tag = 'GoverningAgreements'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementsType_.c_children.copy()
    c_attributes = GoverningAgreementsType_.c_attributes.copy()
    c_child_order = GoverningAgreementsType_.c_child_order[:]
    c_cardinality = GoverningAgreementsType_.c_cardinality.copy()


def governing_agreements_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreements, xml_string)


class PasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PasswordType element """

    c_tag = 'PasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'alphabet', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PasswordType_, xml_string)


class RestrictedPasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:RestrictedPasswordType element """

    c_tag = 'RestrictedPasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Length'] = (
        'length', RestrictedPasswordType_Length)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def restricted_password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_,
                                              xml_string)


class TokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:TokenType element """

    c_tag = 'TokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}TimeSyncToken'] = (
        'time_sync_token', TimeSyncToken)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['time_sync_token', 'extension'])

    def __init__(self,
                 time_sync_token=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.time_sync_token = time_sync_token
        self.extension = extension or []


def token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TokenType_, xml_string)


class ActivationLimitType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationLimitType element """

    c_tag = 'ActivationLimitType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}ActivationLimitDuration'] = (
        'activation_limit_duration', ActivationLimitDuration)
    c_cardinality['activation_limit_duration'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}ActivationLimitUsages'] = (
        'activation_limit_usages', ActivationLimitUsages)
    c_cardinality['activation_limit_usages'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}ActivationLimitSession'] = (
        'activation_limit_session', ActivationLimitSession)
    c_cardinality['activation_limit_session'] = {"min": 0, "max": 1}
    c_child_order.extend(
        ['activation_limit_duration', 'activation_limit_usages',
         'activation_limit_session'])

    def __init__(self,
                 activation_limit_duration=None,
                 activation_limit_usages=None,
                 activation_limit_session=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_limit_duration = activation_limit_duration
        self.activation_limit_usages = activation_limit_usages
        self.activation_limit_session = activation_limit_session


def activation_limit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitType_, xml_string)


class ExtensionOnlyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ExtensionOnlyType element """

    c_tag = 'ExtensionOnlyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []


def extension_only_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionOnlyType_, xml_string)


class WrittenConsent(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:WrittenConsent element """

    c_tag = 'WrittenConsent'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def written_consent_from_string(xml_string):
    return saml2.create_class_from_xml_string(WrittenConsent, xml_string)


class SubscriberLineNumber(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SubscriberLineNumber element """

    c_tag = 'SubscriberLineNumber'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def subscriber_line_number_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubscriberLineNumber, xml_string)


class UserSuffix(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:UserSuffix element """

    c_tag = 'UserSuffix'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def user_suffix_from_string(xml_string):
    return saml2.create_class_from_xml_string(UserSuffix, xml_string)


class Password(PasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Password element """

    c_tag = 'Password'
    c_namespace = NAMESPACE
    c_children = PasswordType_.c_children.copy()
    c_attributes = PasswordType_.c_attributes.copy()
    c_child_order = PasswordType_.c_child_order[:]
    c_cardinality = PasswordType_.c_cardinality.copy()


def password_from_string(xml_string):
    return saml2.create_class_from_xml_string(Password, xml_string)


class Token(TokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Token element """

    c_tag = 'Token'
    c_namespace = NAMESPACE
    c_children = TokenType_.c_children.copy()
    c_attributes = TokenType_.c_attributes.copy()
    c_child_order = TokenType_.c_child_order[:]
    c_cardinality = TokenType_.c_cardinality.copy()


def token_from_string(xml_string):
    return saml2.create_class_from_xml_string(Token, xml_string)


class Smartcard(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Smartcard element """

    c_tag = 'Smartcard'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def smartcard_from_string(xml_string):
    return saml2.create_class_from_xml_string(Smartcard, xml_string)


class ActivationLimit(ActivationLimitType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationLimit element """

    c_tag = 'ActivationLimit'
    c_namespace = NAMESPACE
    c_children = ActivationLimitType_.c_children.copy()
    c_attributes = ActivationLimitType_.c_attributes.copy()
    c_child_order = ActivationLimitType_.c_child_order[:]
    c_cardinality = ActivationLimitType_.c_cardinality.copy()


def activation_limit_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimit, xml_string)


class PreviousSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PreviousSession element """

    c_tag = 'PreviousSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def previous_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(PreviousSession, xml_string)


class ResumeSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ResumeSession element """

    c_tag = 'ResumeSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def resume_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ResumeSession, xml_string)


class ZeroKnowledge(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ZeroKnowledge element """

    c_tag = 'ZeroKnowledge'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def zero_knowledge_from_string(xml_string):
    return saml2.create_class_from_xml_string(ZeroKnowledge, xml_string)


class SharedSecretChallengeResponse(SharedSecretChallengeResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SharedSecretChallengeResponse element """

    c_tag = 'SharedSecretChallengeResponse'
    c_namespace = NAMESPACE
    c_children = SharedSecretChallengeResponseType_.c_children.copy()
    c_attributes = SharedSecretChallengeResponseType_.c_attributes.copy()
    c_child_order = SharedSecretChallengeResponseType_.c_child_order[:]
    c_cardinality = SharedSecretChallengeResponseType_.c_cardinality.copy()


def shared_secret_challenge_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretChallengeResponse,
                                              xml_string)


class DigSig(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:DigSig element """

    c_tag = 'DigSig'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def dig_sig_from_string(xml_string):
    return saml2.create_class_from_xml_string(DigSig, xml_string)


class AsymmetricDecryption(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AsymmetricDecryption element """

    c_tag = 'AsymmetricDecryption'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_decryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricDecryption, xml_string)


class AsymmetricKeyAgreement(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AsymmetricKeyAgreement element """

    c_tag = 'AsymmetricKeyAgreement'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_key_agreement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricKeyAgreement,
                                              xml_string)


class IPAddress(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:IPAddress element """

    c_tag = 'IPAddress'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_address_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPAddress, xml_string)


class SharedSecretDynamicPlaintext(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SharedSecretDynamicPlaintext element """

    c_tag = 'SharedSecretDynamicPlaintext'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def shared_secret_dynamic_plaintext_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretDynamicPlaintext,
                                              xml_string)


class HTTP(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:HTTP element """

    c_tag = 'HTTP'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def http_from_string(xml_string):
    return saml2.create_class_from_xml_string(HTTP, xml_string)


class IPSec(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:IPSec element """

    c_tag = 'IPSec'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_sec_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPSec, xml_string)


class WTLS(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:WTLS element """

    c_tag = 'WTLS'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def wtls_from_string(xml_string):
    return saml2.create_class_from_xml_string(WTLS, xml_string)


class MobileNetworkNoEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:MobileNetworkNoEncryption element """

    c_tag = 'MobileNetworkNoEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_no_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkNoEncryption,
                                              xml_string)


class MobileNetworkRadioEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:MobileNetworkRadioEncryption element """

    c_tag = 'MobileNetworkRadioEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_radio_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkRadioEncryption,
                                              xml_string)


class MobileNetworkEndToEndEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:MobileNetworkEndToEndEncryption element """

    c_tag = 'MobileNetworkEndToEndEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_end_to_end_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkEndToEndEncryption,
                                              xml_string)


class SSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SSL element """

    c_tag = 'SSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ssl_from_string(xml_string):
    return saml2.create_class_from_xml_string(SSL, xml_string)


class PSTN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PSTN element """

    c_tag = 'PSTN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def pstn_from_string(xml_string):
    return saml2.create_class_from_xml_string(PSTN, xml_string)


class ISDN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ISDN element """

    c_tag = 'ISDN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def isdn_from_string(xml_string):
    return saml2.create_class_from_xml_string(ISDN, xml_string)


class ADSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ADSL element """

    c_tag = 'ADSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def adsl_from_string(xml_string):
    return saml2.create_class_from_xml_string(ADSL, xml_string)


class SwitchAudit(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SwitchAudit element """

    c_tag = 'SwitchAudit'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def switch_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SwitchAudit, xml_string)


class DeactivationCallCenter(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:DeactivationCallCenter element """

    c_tag = 'DeactivationCallCenter'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def deactivation_call_center_from_string(xml_string):
    return saml2.create_class_from_xml_string(DeactivationCallCenter,
                                              xml_string)


class RestrictedPassword(RestrictedPasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:RestrictedPassword element """

    c_tag = 'RestrictedPassword'
    c_namespace = NAMESPACE
    c_children = RestrictedPasswordType_.c_children.copy()
    c_attributes = RestrictedPasswordType_.c_attributes.copy()
    c_child_order = RestrictedPasswordType_.c_child_order[:]
    c_cardinality = RestrictedPasswordType_.c_cardinality.copy()


def restricted_password_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPassword, xml_string)


class ActivationPinType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationPinType element """

    c_tag = 'ActivationPinType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}ActivationLimit'] = (
        'activation_limit', ActivationLimit)
    c_cardinality['activation_limit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['length', 'alphabet', 'generation', 'activation_limit', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 activation_limit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.activation_limit = activation_limit
        self.extension = extension or []


def activation_pin_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPinType_, xml_string)


class ComplexAuthenticatorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ComplexAuthenticatorType element """

    c_tag = 'ComplexAuthenticatorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}SharedSecretChallengeResponse'] = (
        'shared_secret_challenge_response', SharedSecretChallengeResponse)
    c_cardinality['shared_secret_challenge_response'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}SharedSecretDynamicPlaintext'] = (
        'shared_secret_dynamic_plaintext', SharedSecretDynamicPlaintext)
    c_cardinality['shared_secret_dynamic_plaintext'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Password'] = (
        'password', Password)
    c_child_order.extend(
        ['shared_secret_challenge_response', 'shared_secret_dynamic_plaintext',
         'password'])

    def __init__(self,
                 shared_secret_challenge_response=None,
                 shared_secret_dynamic_plaintext=None,
                 password=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.shared_secret_challenge_response = shared_secret_challenge_response
        self.shared_secret_dynamic_plaintext = shared_secret_dynamic_plaintext
        self.password = password


def complex_authenticator_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticatorType_,
                                              xml_string)


class AuthenticatorTransportProtocolType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AuthenticatorTransportProtocolType element """

    c_tag = 'AuthenticatorTransportProtocolType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}SSL'] = (
        'ssl', SSL)
    c_cardinality['ssl'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}MobileNetworkNoEncryption'] = (
        'mobile_network_no_encryption', MobileNetworkNoEncryption)
    c_cardinality['mobile_network_no_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}MobileNetworkRadioEncryption'] = (
        'mobile_network_radio_encryption', MobileNetworkRadioEncryption)
    c_cardinality['mobile_network_radio_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}MobileNetworkEndToEndEncryption'] = (
        'mobile_network_end_to_end_encryption', MobileNetworkEndToEndEncryption)
    c_cardinality['mobile_network_end_to_end_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}WTLS'] = (
        'wtls', WTLS)
    c_cardinality['wtls'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['ssl', 'mobile_network_no_encryption',
                          'mobile_network_radio_encryption',
                          'mobile_network_end_to_end_encryption', 'wtls',
                          'extension'])

    def __init__(self,
                 ssl=None,
                 mobile_network_no_encryption=None,
                 mobile_network_radio_encryption=None,
                 mobile_network_end_to_end_encryption=None,
                 wtls=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.ssl = ssl
        self.mobile_network_no_encryption = mobile_network_no_encryption
        self.mobile_network_radio_encryption = mobile_network_radio_encryption
        self.mobile_network_end_to_end_encryption = mobile_network_end_to_end_encryption
        self.wtls = wtls
        self.extension = extension or []


def authenticator_transport_protocol_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        AuthenticatorTransportProtocolType_, xml_string)


class SecurityAuditType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SecurityAuditType element """

    c_tag = 'SecurityAuditType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}SwitchAudit'] = (
        'switch_audit', SwitchAudit)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['switch_audit', 'extension'])

    def __init__(self,
                 switch_audit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.switch_audit = switch_audit
        self.extension = extension or []


def security_audit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAuditType_, xml_string)


class IdentificationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:IdentificationType element """

    c_tag = 'IdentificationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}PhysicalVerification'] = (
        'physical_verification', PhysicalVerification)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}WrittenConsent'] = (
        'written_consent', WrittenConsent)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['nym'] = ('nym', 'None', False)
    c_child_order.extend(
        ['physical_verification', 'written_consent', 'governing_agreements',
         'extension'])

    def __init__(self,
                 physical_verification=None,
                 written_consent=None,
                 governing_agreements=None,
                 extension=None,
                 nym=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.physical_verification = physical_verification
        self.written_consent = written_consent
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.nym = nym


def identification_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IdentificationType_, xml_string)


class Identification(IdentificationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Identification element """

    c_tag = 'Identification'
    c_namespace = NAMESPACE
    c_children = IdentificationType_.c_children.copy()
    c_attributes = IdentificationType_.c_attributes.copy()
    c_child_order = IdentificationType_.c_child_order[:]
    c_cardinality = IdentificationType_.c_cardinality.copy()


def identification_from_string(xml_string):
    return saml2.create_class_from_xml_string(Identification, xml_string)


class ActivationPin(ActivationPinType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ActivationPin element """

    c_tag = 'ActivationPin'
    c_namespace = NAMESPACE
    c_children = ActivationPinType_.c_children.copy()
    c_attributes = ActivationPinType_.c_attributes.copy()
    c_child_order = ActivationPinType_.c_child_order[:]
    c_cardinality = ActivationPinType_.c_cardinality.copy()


def activation_pin_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPin, xml_string)


class ComplexAuthenticator(ComplexAuthenticatorType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:ComplexAuthenticator element """

    c_tag = 'ComplexAuthenticator'
    c_namespace = NAMESPACE
    c_children = ComplexAuthenticatorType_.c_children.copy()
    c_attributes = ComplexAuthenticatorType_.c_attributes.copy()
    c_child_order = ComplexAuthenticatorType_.c_child_order[:]
    c_cardinality = ComplexAuthenticatorType_.c_cardinality.copy()


def complex_authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticator, xml_string)


class AuthenticatorTransportProtocol(AuthenticatorTransportProtocolType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AuthenticatorTransportProtocol element """

    c_tag = 'AuthenticatorTransportProtocol'
    c_namespace = NAMESPACE
    c_children = AuthenticatorTransportProtocolType_.c_children.copy()
    c_attributes = AuthenticatorTransportProtocolType_.c_attributes.copy()
    c_child_order = AuthenticatorTransportProtocolType_.c_child_order[:]
    c_cardinality = AuthenticatorTransportProtocolType_.c_cardinality.copy()


def authenticator_transport_protocol_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorTransportProtocol,
                                              xml_string)


class SecurityAudit(SecurityAuditType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SecurityAudit element """

    c_tag = 'SecurityAudit'
    c_namespace = NAMESPACE
    c_children = SecurityAuditType_.c_children.copy()
    c_attributes = SecurityAuditType_.c_attributes.copy()
    c_child_order = SecurityAuditType_.c_child_order[:]
    c_cardinality = SecurityAuditType_.c_cardinality.copy()


def security_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAudit, xml_string)


class PrincipalAuthenticationMechanismType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PrincipalAuthenticationMechanismType element """

    c_tag = 'PrincipalAuthenticationMechanismType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Token'] = (
        'token', Token)
    c_cardinality['token'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Smartcard'] = (
        'smartcard', Smartcard)
    c_cardinality['smartcard'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['preauth'] = ('preauth', 'integer', False)
    c_child_order.extend(
        ['password', 'restricted_password', 'token', 'smartcard',
         'activation_pin', 'extension'])

    def __init__(self,
                 password=None,
                 restricted_password=None,
                 token=None,
                 smartcard=None,
                 activation_pin=None,
                 extension=None,
                 preauth=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.password = password
        self.restricted_password = restricted_password
        self.token = token
        self.smartcard = smartcard
        self.activation_pin = activation_pin
        self.extension = extension or []
        self.preauth = preauth


def principal_authentication_mechanism_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        PrincipalAuthenticationMechanismType_, xml_string)


class KeyActivationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:KeyActivationType element """

    c_tag = 'KeyActivationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['activation_pin', 'extension'])

    def __init__(self,
                 activation_pin=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_pin = activation_pin
        self.extension = extension or []


def key_activation_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivationType_, xml_string)


class AuthenticatorBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AuthenticatorBaseType element """

    c_tag = 'AuthenticatorBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}DigSig'] = (
        'dig_sig', DigSig)
    c_cardinality['dig_sig'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}ZeroKnowledge'] = (
        'zero_knowledge', ZeroKnowledge)
    c_cardinality['zero_knowledge'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}SharedSecretChallengeResponse'] = (
        'shared_secret_challenge_response', SharedSecretChallengeResponse)
    c_cardinality['shared_secret_challenge_response'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}SharedSecretDynamicPlaintext'] = (
        'shared_secret_dynamic_plaintext', SharedSecretDynamicPlaintext)
    c_cardinality['shared_secret_dynamic_plaintext'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}AsymmetricDecryption'] = (
        'asymmetric_decryption', AsymmetricDecryption)
    c_cardinality['asymmetric_decryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}AsymmetricKeyAgreement'] = (
        'asymmetric_key_agreement', AsymmetricKeyAgreement)
    c_cardinality['asymmetric_key_agreement'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}ComplexAuthenticator'] = (
        'complex_authenticator', ComplexAuthenticator)
    c_cardinality['complex_authenticator'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['dig_sig', 'zero_knowledge', 'shared_secret_challenge_response',
         'shared_secret_dynamic_plaintext', 'asymmetric_decryption',
         'asymmetric_key_agreement', 'complex_authenticator', 'extension'])

    def __init__(self,
                 dig_sig=None,
                 zero_knowledge=None,
                 shared_secret_challenge_response=None,
                 shared_secret_dynamic_plaintext=None,
                 asymmetric_decryption=None,
                 asymmetric_key_agreement=None,
                 complex_authenticator=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.dig_sig = dig_sig
        self.zero_knowledge = zero_knowledge
        self.shared_secret_challenge_response = shared_secret_challenge_response
        self.shared_secret_dynamic_plaintext = shared_secret_dynamic_plaintext
        self.asymmetric_decryption = asymmetric_decryption
        self.asymmetric_key_agreement = asymmetric_key_agreement
        self.complex_authenticator = complex_authenticator
        self.extension = extension or []


def authenticator_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorBaseType_,
                                              xml_string)


class OperationalProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:OperationalProtectionType element """

    c_tag = 'OperationalProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}SecurityAudit'] = (
        'security_audit', SecurityAudit)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}DeactivationCallCenter'] = (
        'deactivation_call_center', DeactivationCallCenter)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['security_audit', 'deactivation_call_center', 'extension'])

    def __init__(self,
                 security_audit=None,
                 deactivation_call_center=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.security_audit = security_audit
        self.deactivation_call_center = deactivation_call_center
        self.extension = extension or []


def operational_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtectionType_,
                                              xml_string)


class KeyActivation(KeyActivationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:KeyActivation element """

    c_tag = 'KeyActivation'
    c_namespace = NAMESPACE
    c_children = KeyActivationType_.c_children.copy()
    c_attributes = KeyActivationType_.c_attributes.copy()
    c_child_order = KeyActivationType_.c_child_order[:]
    c_cardinality = KeyActivationType_.c_cardinality.copy()


def key_activation_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivation, xml_string)


class PrincipalAuthenticationMechanism(PrincipalAuthenticationMechanismType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PrincipalAuthenticationMechanism element """

    c_tag = 'PrincipalAuthenticationMechanism'
    c_namespace = NAMESPACE
    c_children = PrincipalAuthenticationMechanismType_.c_children.copy()
    c_attributes = PrincipalAuthenticationMechanismType_.c_attributes.copy()
    c_child_order = PrincipalAuthenticationMechanismType_.c_child_order[:]
    c_cardinality = PrincipalAuthenticationMechanismType_.c_cardinality.copy()


def principal_authentication_mechanism_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrincipalAuthenticationMechanism,
                                              xml_string)


class Authenticator(AuthenticatorBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:Authenticator element """

    c_tag = 'Authenticator'
    c_namespace = NAMESPACE
    c_children = AuthenticatorBaseType_.c_children.copy()
    c_attributes = AuthenticatorBaseType_.c_attributes.copy()
    c_child_order = AuthenticatorBaseType_.c_child_order[:]
    c_cardinality = AuthenticatorBaseType_.c_cardinality.copy()


def authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(Authenticator, xml_string)


class OperationalProtection(OperationalProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:OperationalProtection element """

    c_tag = 'OperationalProtection'
    c_namespace = NAMESPACE
    c_children = OperationalProtectionType_.c_children.copy()
    c_attributes = OperationalProtectionType_.c_attributes.copy()
    c_child_order = OperationalProtectionType_.c_child_order[:]
    c_cardinality = OperationalProtectionType_.c_cardinality.copy()


def operational_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtection, xml_string)


class AuthnMethodBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AuthnMethodBaseType element """

    c_tag = 'AuthnMethodBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}PrincipalAuthenticationMechanism'] = (
        'principal_authentication_mechanism', PrincipalAuthenticationMechanism)
    c_cardinality['principal_authentication_mechanism'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Authenticator'] = (
        'authenticator', Authenticator)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}AuthenticatorTransportProtocol'] = (
        'authenticator_transport_protocol', AuthenticatorTransportProtocol)
    c_cardinality['authenticator_transport_protocol'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['principal_authentication_mechanism', 'authenticator',
                          'authenticator_transport_protocol', 'extension'])

    def __init__(self,
                 principal_authentication_mechanism=None,
                 authenticator=None,
                 authenticator_transport_protocol=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.principal_authentication_mechanism = principal_authentication_mechanism
        self.authenticator = authenticator
        self.authenticator_transport_protocol = authenticator_transport_protocol
        self.extension = extension or []


def authn_method_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethodBaseType_, xml_string)


class PrivateKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PrivateKeyProtectionType element """

    c_tag = 'PrivateKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['key_activation', 'key_storage', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.extension = extension or []


def private_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtectionType_,
                                              xml_string)


class SecretKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SecretKeyProtectionType element """

    c_tag = 'SecretKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract' \
        '}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['key_activation', 'key_storage', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.extension = extension or []


def secret_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtectionType_,
                                              xml_string)


class SecretKeyProtection(SecretKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:SecretKeyProtection element """

    c_tag = 'SecretKeyProtection'
    c_namespace = NAMESPACE
    c_children = SecretKeyProtectionType_.c_children.copy()
    c_attributes = SecretKeyProtectionType_.c_attributes.copy()
    c_child_order = SecretKeyProtectionType_.c_child_order[:]
    c_cardinality = SecretKeyProtectionType_.c_cardinality.copy()


def secret_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtection, xml_string)


class PrivateKeyProtection(PrivateKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:PrivateKeyProtection element """

    c_tag = 'PrivateKeyProtection'
    c_namespace = NAMESPACE
    c_children = PrivateKeyProtectionType_.c_children.copy()
    c_attributes = PrivateKeyProtectionType_.c_attributes.copy()
    c_child_order = PrivateKeyProtectionType_.c_child_order[:]
    c_cardinality = PrivateKeyProtectionType_.c_cardinality.copy()


def private_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtection, xml_string)


class AuthnMethod(AuthnMethodBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AuthnMethod element """

    c_tag = 'AuthnMethod'
    c_namespace = NAMESPACE
    c_children = AuthnMethodBaseType_.c_children.copy()
    c_attributes = AuthnMethodBaseType_.c_attributes.copy()
    c_child_order = AuthnMethodBaseType_.c_child_order[:]
    c_cardinality = AuthnMethodBaseType_.c_cardinality.copy()


def authn_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethod, xml_string)


class TechnicalProtectionBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:TechnicalProtectionBaseType element """

    c_tag = 'TechnicalProtectionBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}PrivateKeyProtection'] = (
        'private_key_protection', PrivateKeyProtection)
    c_cardinality['private_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}SecretKeyProtection'] = (
        'secret_key_protection', SecretKeyProtection)
    c_cardinality['secret_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['private_key_protection', 'secret_key_protection', 'extension'])

    def __init__(self,
                 private_key_protection=None,
                 secret_key_protection=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.private_key_protection = private_key_protection
        self.secret_key_protection = secret_key_protection
        self.extension = extension or []


def technical_protection_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtectionBaseType_,
                                              xml_string)


class TechnicalProtection(TechnicalProtectionBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:TechnicalProtection element """

    c_tag = 'TechnicalProtection'
    c_namespace = NAMESPACE
    c_children = TechnicalProtectionBaseType_.c_children.copy()
    c_attributes = TechnicalProtectionBaseType_.c_attributes.copy()
    c_child_order = TechnicalProtectionBaseType_.c_child_order[:]
    c_cardinality = TechnicalProtectionBaseType_.c_cardinality.copy()


def technical_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtection, xml_string)


class AuthnContextDeclarationBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AuthnContextDeclarationBaseType element """

    c_tag = 'AuthnContextDeclarationBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Identification'] = (
        'identification', Identification)
    c_cardinality['identification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}TechnicalProtection'] = (
        'technical_protection', TechnicalProtection)
    c_cardinality['technical_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}OperationalProtection'] = (
        'operational_protection', OperationalProtection)
    c_cardinality['operational_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}AuthnMethod'] = (
        'authn_method', AuthnMethod)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ID'] = ('id', 'ID', False)
    c_child_order.extend(
        ['identification', 'technical_protection', 'operational_protection',
         'authn_method', 'governing_agreements', 'extension'])

    def __init__(self,
                 identification=None,
                 technical_protection=None,
                 operational_protection=None,
                 authn_method=None,
                 governing_agreements=None,
                 extension=None,
                 id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.identification = identification
        self.technical_protection = technical_protection
        self.operational_protection = operational_protection
        self.authn_method = authn_method
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.id = id


def authn_context_declaration_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextDeclarationBaseType_,
                                              xml_string)


class AuthenticationContextDeclaration(AuthnContextDeclarationBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:MobileTwoFactorContract:AuthenticationContextDeclaration element """

    c_tag = 'AuthenticationContextDeclaration'
    c_namespace = NAMESPACE
    c_children = AuthnContextDeclarationBaseType_.c_children.copy()
    c_attributes = AuthnContextDeclarationBaseType_.c_attributes.copy()
    c_child_order = AuthnContextDeclarationBaseType_.c_child_order[:]
    c_cardinality = AuthnContextDeclarationBaseType_.c_cardinality.copy()


def authentication_context_declaration_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticationContextDeclaration,
                                              xml_string)


ELEMENT_FROM_STRING = {
    AuthenticationContextDeclaration.c_tag: authentication_context_declaration_from_string,
    Identification.c_tag: identification_from_string,
    PhysicalVerification.c_tag: physical_verification_from_string,
    WrittenConsent.c_tag: written_consent_from_string,
    TechnicalProtection.c_tag: technical_protection_from_string,
    SecretKeyProtection.c_tag: secret_key_protection_from_string,
    PrivateKeyProtection.c_tag: private_key_protection_from_string,
    KeyActivation.c_tag: key_activation_from_string,
    KeySharing.c_tag: key_sharing_from_string,
    KeyStorage.c_tag: key_storage_from_string,
    SubscriberLineNumber.c_tag: subscriber_line_number_from_string,
    UserSuffix.c_tag: user_suffix_from_string,
    Password.c_tag: password_from_string,
    ActivationPin.c_tag: activation_pin_from_string,
    Token.c_tag: token_from_string,
    TimeSyncToken.c_tag: time_sync_token_from_string,
    Smartcard.c_tag: smartcard_from_string,
    Length.c_tag: length_from_string,
    ActivationLimit.c_tag: activation_limit_from_string,
    Generation.c_tag: generation_from_string,
    AuthnMethod.c_tag: authn_method_from_string,
    PrincipalAuthenticationMechanism.c_tag: principal_authentication_mechanism_from_string,
    Authenticator.c_tag: authenticator_from_string,
    ComplexAuthenticator.c_tag: complex_authenticator_from_string,
    PreviousSession.c_tag: previous_session_from_string,
    ResumeSession.c_tag: resume_session_from_string,
    ZeroKnowledge.c_tag: zero_knowledge_from_string,
    SharedSecretChallengeResponse.c_tag: shared_secret_challenge_response_from_string,
    SharedSecretChallengeResponseType_.c_tag: shared_secret_challenge_response_type__from_string,
    DigSig.c_tag: dig_sig_from_string,
    AsymmetricDecryption.c_tag: asymmetric_decryption_from_string,
    AsymmetricKeyAgreement.c_tag: asymmetric_key_agreement_from_string,
    PublicKeyType_.c_tag: public_key_type__from_string,
    IPAddress.c_tag: ip_address_from_string,
    SharedSecretDynamicPlaintext.c_tag: shared_secret_dynamic_plaintext_from_string,
    AuthenticatorTransportProtocol.c_tag: authenticator_transport_protocol_from_string,
    HTTP.c_tag: http_from_string,
    IPSec.c_tag: ip_sec_from_string,
    WTLS.c_tag: wtls_from_string,
    MobileNetworkNoEncryption.c_tag: mobile_network_no_encryption_from_string,
    MobileNetworkRadioEncryption.c_tag: mobile_network_radio_encryption_from_string,
    MobileNetworkEndToEndEncryption.c_tag: mobile_network_end_to_end_encryption_from_string,
    SSL.c_tag: ssl_from_string,
    PSTN.c_tag: pstn_from_string,
    ISDN.c_tag: isdn_from_string,
    ADSL.c_tag: adsl_from_string,
    OperationalProtection.c_tag: operational_protection_from_string,
    SecurityAudit.c_tag: security_audit_from_string,
    SwitchAudit.c_tag: switch_audit_from_string,
    DeactivationCallCenter.c_tag: deactivation_call_center_from_string,
    GoverningAgreements.c_tag: governing_agreements_from_string,
    GoverningAgreementRef.c_tag: governing_agreement_ref_from_string,
    NymType_.c_tag: nym_type__from_string,
    GoverningAgreementsType_.c_tag: governing_agreements_type__from_string,
    GoverningAgreementRefType_.c_tag: governing_agreement_ref_type__from_string,
    PrincipalAuthenticationMechanismType_.c_tag: principal_authentication_mechanism_type__from_string,
    KeyActivationType_.c_tag: key_activation_type__from_string,
    KeySharingType_.c_tag: key_sharing_type__from_string,
    PasswordType_.c_tag: password_type__from_string,
    RestrictedPassword.c_tag: restricted_password_from_string,
    RestrictedPasswordType_.c_tag: restricted_password_type__from_string,
    RestrictedLengthType_.c_tag: restricted_length_type__from_string,
    ActivationPinType_.c_tag: activation_pin_type__from_string,
    Alphabet.c_tag: alphabet_from_string,
    AlphabetType_.c_tag: alphabet_type__from_string,
    TokenType_.c_tag: token_type__from_string,
    DeviceTypeType_.c_tag: device_type_type__from_string,
    BooleanType_.c_tag: boolean_type__from_string,
    TimeSyncTokenType_.c_tag: time_sync_token_type__from_string,
    ActivationLimitType_.c_tag: activation_limit_type__from_string,
    ActivationLimitDuration.c_tag: activation_limit_duration_from_string,
    ActivationLimitUsages.c_tag: activation_limit_usages_from_string,
    ActivationLimitSession.c_tag: activation_limit_session_from_string,
    ActivationLimitDurationType_.c_tag: activation_limit_duration_type__from_string,
    ActivationLimitUsagesType_.c_tag: activation_limit_usages_type__from_string,
    ActivationLimitSessionType_.c_tag: activation_limit_session_type__from_string,
    LengthType_.c_tag: length_type__from_string,
    MediumType_.c_tag: medium_type__from_string,
    ExtensionOnlyType_.c_tag: extension_only_type__from_string,
    Extension.c_tag: extension_from_string,
    ExtensionType_.c_tag: extension_type__from_string,
    AuthnContextDeclarationBaseType_.c_tag: authn_context_declaration_base_type__from_string,
    AuthnMethodBaseType_.c_tag: authn_method_base_type__from_string,
    AuthenticatorBaseType_.c_tag: authenticator_base_type__from_string,
    ComplexAuthenticatorType_.c_tag: complex_authenticator_type__from_string,
    AuthenticatorTransportProtocolType_.c_tag: authenticator_transport_protocol_type__from_string,
    OperationalProtectionType_.c_tag: operational_protection_type__from_string,
    TechnicalProtectionBaseType_.c_tag: technical_protection_base_type__from_string,
    PrivateKeyProtectionType_.c_tag: private_key_protection_type__from_string,
    SecretKeyProtectionType_.c_tag: secret_key_protection_type__from_string,
    KeyStorageType_.c_tag: key_storage_type__from_string,
    SecurityAuditType_.c_tag: security_audit_type__from_string,
    IdentificationType_.c_tag: identification_type__from_string,
}

ELEMENT_BY_TAG = {
    'AuthenticationContextDeclaration': AuthenticationContextDeclaration,
    'Identification': Identification,
    'PhysicalVerification': PhysicalVerification,
    'WrittenConsent': WrittenConsent,
    'TechnicalProtection': TechnicalProtection,
    'SecretKeyProtection': SecretKeyProtection,
    'PrivateKeyProtection': PrivateKeyProtection,
    'KeyActivation': KeyActivation,
    'KeySharing': KeySharing,
    'KeyStorage': KeyStorage,
    'SubscriberLineNumber': SubscriberLineNumber,
    'UserSuffix': UserSuffix,
    'Password': Password,
    'ActivationPin': ActivationPin,
    'Token': Token,
    'TimeSyncToken': TimeSyncToken,
    'Smartcard': Smartcard,
    'Length': Length,
    'ActivationLimit': ActivationLimit,
    'Generation': Generation,
    'AuthnMethod': AuthnMethod,
    'PrincipalAuthenticationMechanism': PrincipalAuthenticationMechanism,
    'Authenticator': Authenticator,
    'ComplexAuthenticator': ComplexAuthenticator,
    'PreviousSession': PreviousSession,
    'ResumeSession': ResumeSession,
    'ZeroKnowledge': ZeroKnowledge,
    'SharedSecretChallengeResponse': SharedSecretChallengeResponse,
    'SharedSecretChallengeResponseType': SharedSecretChallengeResponseType_,
    'DigSig': DigSig,
    'AsymmetricDecryption': AsymmetricDecryption,
    'AsymmetricKeyAgreement': AsymmetricKeyAgreement,
    'PublicKeyType': PublicKeyType_,
    'IPAddress': IPAddress,
    'SharedSecretDynamicPlaintext': SharedSecretDynamicPlaintext,
    'AuthenticatorTransportProtocol': AuthenticatorTransportProtocol,
    'HTTP': HTTP,
    'IPSec': IPSec,
    'WTLS': WTLS,
    'MobileNetworkNoEncryption': MobileNetworkNoEncryption,
    'MobileNetworkRadioEncryption': MobileNetworkRadioEncryption,
    'MobileNetworkEndToEndEncryption': MobileNetworkEndToEndEncryption,
    'SSL': SSL,
    'PSTN': PSTN,
    'ISDN': ISDN,
    'ADSL': ADSL,
    'OperationalProtection': OperationalProtection,
    'SecurityAudit': SecurityAudit,
    'SwitchAudit': SwitchAudit,
    'DeactivationCallCenter': DeactivationCallCenter,
    'GoverningAgreements': GoverningAgreements,
    'GoverningAgreementRef': GoverningAgreementRef,
    'nymType': NymType_,
    'GoverningAgreementsType': GoverningAgreementsType_,
    'GoverningAgreementRefType': GoverningAgreementRefType_,
    'PrincipalAuthenticationMechanismType': PrincipalAuthenticationMechanismType_,
    'KeyActivationType': KeyActivationType_,
    'KeySharingType': KeySharingType_,
    'PasswordType': PasswordType_,
    'RestrictedPassword': RestrictedPassword,
    'RestrictedPasswordType': RestrictedPasswordType_,
    'RestrictedLengthType': RestrictedLengthType_,
    'ActivationPinType': ActivationPinType_,
    'Alphabet': Alphabet,
    'AlphabetType': AlphabetType_,
    'TokenType': TokenType_,
    'DeviceTypeType': DeviceTypeType_,
    'booleanType': BooleanType_,
    'TimeSyncTokenType': TimeSyncTokenType_,
    'ActivationLimitType': ActivationLimitType_,
    'ActivationLimitDuration': ActivationLimitDuration,
    'ActivationLimitUsages': ActivationLimitUsages,
    'ActivationLimitSession': ActivationLimitSession,
    'ActivationLimitDurationType': ActivationLimitDurationType_,
    'ActivationLimitUsagesType': ActivationLimitUsagesType_,
    'ActivationLimitSessionType': ActivationLimitSessionType_,
    'LengthType': LengthType_,
    'mediumType': MediumType_,
    'ExtensionOnlyType': ExtensionOnlyType_,
    'Extension': Extension,
    'ExtensionType': ExtensionType_,
    'AuthnContextDeclarationBaseType': AuthnContextDeclarationBaseType_,
    'AuthnMethodBaseType': AuthnMethodBaseType_,
    'AuthenticatorBaseType': AuthenticatorBaseType_,
    'ComplexAuthenticatorType': ComplexAuthenticatorType_,
    'AuthenticatorTransportProtocolType': AuthenticatorTransportProtocolType_,
    'OperationalProtectionType': OperationalProtectionType_,
    'TechnicalProtectionBaseType': TechnicalProtectionBaseType_,
    'PrivateKeyProtectionType': PrivateKeyProtectionType_,
    'SecretKeyProtectionType': SecretKeyProtectionType_,
    'KeyStorageType': KeyStorageType_,
    'SecurityAuditType': SecurityAuditType_,
    'IdentificationType': IdentificationType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = ppt
#!/usr/bin/env python

#
# Generated Sun Apr 21 10:23:51 2013 by parse_xsd.py version 0.5.
#

"""The PasswordProtectedTransport class is applicable when a principal
authenticates to an authentication authority through the presentation of a
password over a protected session."""

import saml2
from saml2 import SamlBase


NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport'


class PhysicalVerification(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PhysicalVerification element """

    c_tag = 'PhysicalVerification'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['credentialLevel'] = ('credential_level', 'None', False)

    def __init__(self,
                 credential_level=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.credential_level = credential_level


def physical_verification_from_string(xml_string):
    return saml2.create_class_from_xml_string(PhysicalVerification, xml_string)


class Generation(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Generation element """

    c_tag = 'Generation'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['mechanism'] = ('mechanism', 'None', True)

    def __init__(self,
                 mechanism=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.mechanism = mechanism


def generation_from_string(xml_string):
    return saml2.create_class_from_xml_string(Generation, xml_string)


class NymType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:nymType element """

    c_tag = 'nymType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['anonymity', 'verinymity', 'pseudonymity']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def nym_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NymType_, xml_string)


class GoverningAgreementRefType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:GoverningAgreementRefType element """

    c_tag = 'GoverningAgreementRefType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['governingAgreementRef'] = (
        'governing_agreement_ref', 'anyURI', True)

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref


def governing_agreement_ref_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRefType_,
                                              xml_string)


class KeySharingType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:KeySharingType element """

    c_tag = 'KeySharingType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['sharing'] = ('sharing', 'boolean', True)

    def __init__(self,
                 sharing=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.sharing = sharing


def key_sharing_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharingType_, xml_string)


class RestrictedLengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:RestrictedLengthType element """

    c_tag = 'RestrictedLengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'None', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def restricted_length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedLengthType_, xml_string)


class AlphabetType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AlphabetType element """

    c_tag = 'AlphabetType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['requiredChars'] = ('required_chars', 'string', True)
    c_attributes['excludedChars'] = ('excluded_chars', 'string', False)
    c_attributes['case'] = ('case', 'string', False)

    def __init__(self,
                 required_chars=None,
                 excluded_chars=None,
                 case=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.required_chars = required_chars
        self.excluded_chars = excluded_chars
        self.case = case


def alphabet_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AlphabetType_, xml_string)


class DeviceTypeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:DeviceTypeType element """

    c_tag = 'DeviceTypeType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['hardware', 'software']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def device_type_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DeviceTypeType_, xml_string)


class BooleanType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:booleanType element """

    c_tag = 'booleanType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN', 'enumeration': ['true', 'false']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def boolean_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(BooleanType_, xml_string)


class TimeSyncTokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:TimeSyncTokenType element """

    c_tag = 'TimeSyncTokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['DeviceType'] = ('device_type', DeviceTypeType_, True)
    c_attributes['SeedLength'] = ('seed_length', 'integer', True)
    c_attributes['DeviceInHand'] = ('device_in_hand', BooleanType_, True)

    def __init__(self,
                 device_type=None,
                 seed_length=None,
                 device_in_hand=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.device_type = device_type
        self.seed_length = seed_length
        self.device_in_hand = device_in_hand


def time_sync_token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncTokenType_, xml_string)


class ActivationLimitDurationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationLimitDurationType element """

    c_tag = 'ActivationLimitDurationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['duration'] = ('duration', 'duration', True)

    def __init__(self,
                 duration=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.duration = duration


def activation_limit_duration_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDurationType_,
                                              xml_string)


class ActivationLimitUsagesType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationLimitUsagesType element """

    c_tag = 'ActivationLimitUsagesType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['number'] = ('number', 'integer', True)

    def __init__(self,
                 number=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.number = number


def activation_limit_usages_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsagesType_,
                                              xml_string)


class ActivationLimitSessionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationLimitSessionType element """

    c_tag = 'ActivationLimitSessionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def activation_limit_session_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSessionType_,
                                              xml_string)


class LengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:LengthType element """

    c_tag = 'LengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'integer', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LengthType_, xml_string)


class MediumType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:mediumType element """

    c_tag = 'mediumType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['memory', 'smartcard', 'token',
                                    'MobileDevice', 'MobileAuthCard']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def medium_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(MediumType_, xml_string)


class KeyStorageType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:KeyStorageType element """

    c_tag = 'KeyStorageType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['medium'] = ('medium', MediumType_, True)

    def __init__(self,
                 medium=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.medium = medium


def key_storage_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorageType_, xml_string)


class ExtensionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ExtensionType element """

    c_tag = 'ExtensionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def extension_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionType_, xml_string)


class KeySharing(KeySharingType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:KeySharing element """

    c_tag = 'KeySharing'
    c_namespace = NAMESPACE
    c_children = KeySharingType_.c_children.copy()
    c_attributes = KeySharingType_.c_attributes.copy()
    c_child_order = KeySharingType_.c_child_order[:]
    c_cardinality = KeySharingType_.c_cardinality.copy()


def key_sharing_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharing, xml_string)


class KeyStorage(KeyStorageType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:KeyStorage element """

    c_tag = 'KeyStorage'
    c_namespace = NAMESPACE
    c_children = KeyStorageType_.c_children.copy()
    c_attributes = KeyStorageType_.c_attributes.copy()
    c_child_order = KeyStorageType_.c_child_order[:]
    c_cardinality = KeyStorageType_.c_cardinality.copy()


def key_storage_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorage, xml_string)


class TimeSyncToken(TimeSyncTokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:TimeSyncToken element """

    c_tag = 'TimeSyncToken'
    c_namespace = NAMESPACE
    c_children = TimeSyncTokenType_.c_children.copy()
    c_attributes = TimeSyncTokenType_.c_attributes.copy()
    c_child_order = TimeSyncTokenType_.c_child_order[:]
    c_cardinality = TimeSyncTokenType_.c_cardinality.copy()


def time_sync_token_from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncToken, xml_string)


class Length(LengthType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Length element """

    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = LengthType_.c_children.copy()
    c_attributes = LengthType_.c_attributes.copy()
    c_child_order = LengthType_.c_child_order[:]
    c_cardinality = LengthType_.c_cardinality.copy()


def length_from_string(xml_string):
    return saml2.create_class_from_xml_string(Length, xml_string)


class GoverningAgreementRef(GoverningAgreementRefType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:GoverningAgreementRef element """

    c_tag = 'GoverningAgreementRef'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementRefType_.c_children.copy()
    c_attributes = GoverningAgreementRefType_.c_attributes.copy()
    c_child_order = GoverningAgreementRefType_.c_child_order[:]
    c_cardinality = GoverningAgreementRefType_.c_cardinality.copy()


def governing_agreement_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRef, xml_string)


class GoverningAgreementsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:GoverningAgreementsType element """

    c_tag = 'GoverningAgreementsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}GoverningAgreementRef'] = (
        'governing_agreement_ref', [GoverningAgreementRef])
    c_cardinality['governing_agreement_ref'] = {"min": 1}
    c_child_order.extend(['governing_agreement_ref'])

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref or []


def governing_agreements_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementsType_,
                                              xml_string)


class RestrictedPasswordType_Length(RestrictedLengthType_):
    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = RestrictedLengthType_.c_children.copy()
    c_attributes = RestrictedLengthType_.c_attributes.copy()
    c_child_order = RestrictedLengthType_.c_child_order[:]
    c_cardinality = RestrictedLengthType_.c_cardinality.copy()


def restricted_password_type__length_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_Length,
                                              xml_string)


class Alphabet(AlphabetType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Alphabet element """

    c_tag = 'Alphabet'
    c_namespace = NAMESPACE
    c_children = AlphabetType_.c_children.copy()
    c_attributes = AlphabetType_.c_attributes.copy()
    c_child_order = AlphabetType_.c_child_order[:]
    c_cardinality = AlphabetType_.c_cardinality.copy()


def alphabet_from_string(xml_string):
    return saml2.create_class_from_xml_string(Alphabet, xml_string)


class ActivationLimitDuration(ActivationLimitDurationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationLimitDuration element """

    c_tag = 'ActivationLimitDuration'
    c_namespace = NAMESPACE
    c_children = ActivationLimitDurationType_.c_children.copy()
    c_attributes = ActivationLimitDurationType_.c_attributes.copy()
    c_child_order = ActivationLimitDurationType_.c_child_order[:]
    c_cardinality = ActivationLimitDurationType_.c_cardinality.copy()


def activation_limit_duration_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDuration,
                                              xml_string)


class ActivationLimitUsages(ActivationLimitUsagesType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationLimitUsages element """

    c_tag = 'ActivationLimitUsages'
    c_namespace = NAMESPACE
    c_children = ActivationLimitUsagesType_.c_children.copy()
    c_attributes = ActivationLimitUsagesType_.c_attributes.copy()
    c_child_order = ActivationLimitUsagesType_.c_child_order[:]
    c_cardinality = ActivationLimitUsagesType_.c_cardinality.copy()


def activation_limit_usages_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsages, xml_string)


class ActivationLimitSession(ActivationLimitSessionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationLimitSession element """

    c_tag = 'ActivationLimitSession'
    c_namespace = NAMESPACE
    c_children = ActivationLimitSessionType_.c_children.copy()
    c_attributes = ActivationLimitSessionType_.c_attributes.copy()
    c_child_order = ActivationLimitSessionType_.c_child_order[:]
    c_cardinality = ActivationLimitSessionType_.c_cardinality.copy()


def activation_limit_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSession,
                                              xml_string)


class Extension(ExtensionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Extension element """

    c_tag = 'Extension'
    c_namespace = NAMESPACE
    c_children = ExtensionType_.c_children.copy()
    c_attributes = ExtensionType_.c_attributes.copy()
    c_child_order = ExtensionType_.c_child_order[:]
    c_cardinality = ExtensionType_.c_cardinality.copy()


def extension_from_string(xml_string):
    return saml2.create_class_from_xml_string(Extension, xml_string)


class SharedSecretChallengeResponseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SharedSecretChallengeResponseType element """

    c_tag = 'SharedSecretChallengeResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['method'] = ('method', 'anyURI', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 method=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.method = method


def shared_secret_challenge_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        SharedSecretChallengeResponseType_, xml_string)


class PublicKeyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PublicKeyType element """

    c_tag = 'PublicKeyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['keyValidation'] = ('key_validation', 'None', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 key_validation=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.key_validation = key_validation


def public_key_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicKeyType_, xml_string)


class GoverningAgreements(GoverningAgreementsType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:GoverningAgreements element """

    c_tag = 'GoverningAgreements'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementsType_.c_children.copy()
    c_attributes = GoverningAgreementsType_.c_attributes.copy()
    c_child_order = GoverningAgreementsType_.c_child_order[:]
    c_cardinality = GoverningAgreementsType_.c_cardinality.copy()


def governing_agreements_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreements, xml_string)


class PasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PasswordType element """

    c_tag = 'PasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'alphabet', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PasswordType_, xml_string)


class RestrictedPasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:RestrictedPasswordType element """

    c_tag = 'RestrictedPasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Length'] = (
        'length', RestrictedPasswordType_Length)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def restricted_password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_,
                                              xml_string)


class TokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:TokenType element """

    c_tag = 'TokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}TimeSyncToken'] = (
        'time_sync_token', TimeSyncToken)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['time_sync_token', 'extension'])

    def __init__(self,
                 time_sync_token=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.time_sync_token = time_sync_token
        self.extension = extension or []


def token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TokenType_, xml_string)


class ActivationLimitType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationLimitType element """

    c_tag = 'ActivationLimitType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ActivationLimitDuration'] = (
        'activation_limit_duration', ActivationLimitDuration)
    c_cardinality['activation_limit_duration'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ActivationLimitUsages'] = (
        'activation_limit_usages', ActivationLimitUsages)
    c_cardinality['activation_limit_usages'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ActivationLimitSession'] = (
        'activation_limit_session', ActivationLimitSession)
    c_cardinality['activation_limit_session'] = {"min": 0, "max": 1}
    c_child_order.extend(
        ['activation_limit_duration', 'activation_limit_usages',
         'activation_limit_session'])

    def __init__(self,
                 activation_limit_duration=None,
                 activation_limit_usages=None,
                 activation_limit_session=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_limit_duration = activation_limit_duration
        self.activation_limit_usages = activation_limit_usages
        self.activation_limit_session = activation_limit_session


def activation_limit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitType_, xml_string)


class ExtensionOnlyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ExtensionOnlyType element """

    c_tag = 'ExtensionOnlyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []


def extension_only_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionOnlyType_, xml_string)


class WrittenConsent(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:WrittenConsent element """

    c_tag = 'WrittenConsent'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def written_consent_from_string(xml_string):
    return saml2.create_class_from_xml_string(WrittenConsent, xml_string)


class SubscriberLineNumber(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SubscriberLineNumber element """

    c_tag = 'SubscriberLineNumber'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def subscriber_line_number_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubscriberLineNumber, xml_string)


class UserSuffix(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:UserSuffix element """

    c_tag = 'UserSuffix'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def user_suffix_from_string(xml_string):
    return saml2.create_class_from_xml_string(UserSuffix, xml_string)


class Password(PasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Password element """

    c_tag = 'Password'
    c_namespace = NAMESPACE
    c_children = PasswordType_.c_children.copy()
    c_attributes = PasswordType_.c_attributes.copy()
    c_child_order = PasswordType_.c_child_order[:]
    c_cardinality = PasswordType_.c_cardinality.copy()


def password_from_string(xml_string):
    return saml2.create_class_from_xml_string(Password, xml_string)


class Token(TokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Token element """

    c_tag = 'Token'
    c_namespace = NAMESPACE
    c_children = TokenType_.c_children.copy()
    c_attributes = TokenType_.c_attributes.copy()
    c_child_order = TokenType_.c_child_order[:]
    c_cardinality = TokenType_.c_cardinality.copy()


def token_from_string(xml_string):
    return saml2.create_class_from_xml_string(Token, xml_string)


class Smartcard(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Smartcard element """

    c_tag = 'Smartcard'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def smartcard_from_string(xml_string):
    return saml2.create_class_from_xml_string(Smartcard, xml_string)


class ActivationLimit(ActivationLimitType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationLimit element """

    c_tag = 'ActivationLimit'
    c_namespace = NAMESPACE
    c_children = ActivationLimitType_.c_children.copy()
    c_attributes = ActivationLimitType_.c_attributes.copy()
    c_child_order = ActivationLimitType_.c_child_order[:]
    c_cardinality = ActivationLimitType_.c_cardinality.copy()


def activation_limit_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimit, xml_string)


class PreviousSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PreviousSession element """

    c_tag = 'PreviousSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def previous_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(PreviousSession, xml_string)


class ResumeSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ResumeSession element """

    c_tag = 'ResumeSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def resume_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ResumeSession, xml_string)


class ZeroKnowledge(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ZeroKnowledge element """

    c_tag = 'ZeroKnowledge'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def zero_knowledge_from_string(xml_string):
    return saml2.create_class_from_xml_string(ZeroKnowledge, xml_string)


class SharedSecretChallengeResponse(SharedSecretChallengeResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SharedSecretChallengeResponse element """

    c_tag = 'SharedSecretChallengeResponse'
    c_namespace = NAMESPACE
    c_children = SharedSecretChallengeResponseType_.c_children.copy()
    c_attributes = SharedSecretChallengeResponseType_.c_attributes.copy()
    c_child_order = SharedSecretChallengeResponseType_.c_child_order[:]
    c_cardinality = SharedSecretChallengeResponseType_.c_cardinality.copy()


def shared_secret_challenge_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretChallengeResponse,
                                              xml_string)


class DigSig(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:DigSig element """

    c_tag = 'DigSig'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def dig_sig_from_string(xml_string):
    return saml2.create_class_from_xml_string(DigSig, xml_string)


class AsymmetricDecryption(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AsymmetricDecryption element """

    c_tag = 'AsymmetricDecryption'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_decryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricDecryption, xml_string)


class AsymmetricKeyAgreement(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AsymmetricKeyAgreement element """

    c_tag = 'AsymmetricKeyAgreement'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_key_agreement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricKeyAgreement,
                                              xml_string)


class IPAddress(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:IPAddress element """

    c_tag = 'IPAddress'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_address_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPAddress, xml_string)


class SharedSecretDynamicPlaintext(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SharedSecretDynamicPlaintext element """

    c_tag = 'SharedSecretDynamicPlaintext'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def shared_secret_dynamic_plaintext_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretDynamicPlaintext,
                                              xml_string)


class HTTP(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:HTTP element """

    c_tag = 'HTTP'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def http_from_string(xml_string):
    return saml2.create_class_from_xml_string(HTTP, xml_string)


class IPSec(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:IPSec element """

    c_tag = 'IPSec'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_sec_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPSec, xml_string)


class WTLS(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:WTLS element """

    c_tag = 'WTLS'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def wtls_from_string(xml_string):
    return saml2.create_class_from_xml_string(WTLS, xml_string)


class MobileNetworkNoEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:MobileNetworkNoEncryption element """

    c_tag = 'MobileNetworkNoEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_no_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkNoEncryption,
                                              xml_string)


class MobileNetworkRadioEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:MobileNetworkRadioEncryption element """

    c_tag = 'MobileNetworkRadioEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_radio_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkRadioEncryption,
                                              xml_string)


class MobileNetworkEndToEndEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:MobileNetworkEndToEndEncryption element """

    c_tag = 'MobileNetworkEndToEndEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_end_to_end_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkEndToEndEncryption,
                                              xml_string)


class SSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SSL element """

    c_tag = 'SSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ssl_from_string(xml_string):
    return saml2.create_class_from_xml_string(SSL, xml_string)


class PSTN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PSTN element """

    c_tag = 'PSTN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def pstn_from_string(xml_string):
    return saml2.create_class_from_xml_string(PSTN, xml_string)


class ISDN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ISDN element """

    c_tag = 'ISDN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def isdn_from_string(xml_string):
    return saml2.create_class_from_xml_string(ISDN, xml_string)


class ADSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ADSL element """

    c_tag = 'ADSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def adsl_from_string(xml_string):
    return saml2.create_class_from_xml_string(ADSL, xml_string)


class SwitchAudit(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SwitchAudit element """

    c_tag = 'SwitchAudit'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def switch_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SwitchAudit, xml_string)


class DeactivationCallCenter(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:DeactivationCallCenter element """

    c_tag = 'DeactivationCallCenter'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def deactivation_call_center_from_string(xml_string):
    return saml2.create_class_from_xml_string(DeactivationCallCenter,
                                              xml_string)


class IdentificationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:IdentificationType element """

    c_tag = 'IdentificationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}PhysicalVerification'] = (
        'physical_verification', PhysicalVerification)
    c_cardinality['physical_verification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}WrittenConsent'] = (
        'written_consent', WrittenConsent)
    c_cardinality['written_consent'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['nym'] = ('nym', NymType_, False)
    c_child_order.extend(
        ['physical_verification', 'written_consent', 'governing_agreements',
         'extension'])

    def __init__(self,
                 physical_verification=None,
                 written_consent=None,
                 governing_agreements=None,
                 extension=None,
                 nym=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.physical_verification = physical_verification
        self.written_consent = written_consent
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.nym = nym


def identification_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IdentificationType_, xml_string)


class RestrictedPassword(RestrictedPasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:RestrictedPassword element """

    c_tag = 'RestrictedPassword'
    c_namespace = NAMESPACE
    c_children = RestrictedPasswordType_.c_children.copy()
    c_attributes = RestrictedPasswordType_.c_attributes.copy()
    c_child_order = RestrictedPasswordType_.c_child_order[:]
    c_cardinality = RestrictedPasswordType_.c_cardinality.copy()


def restricted_password_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPassword, xml_string)


class ActivationPinType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationPinType element """

    c_tag = 'ActivationPinType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ActivationLimit'] = (
        'activation_limit', ActivationLimit)
    c_cardinality['activation_limit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['length', 'alphabet', 'generation', 'activation_limit', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 activation_limit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.activation_limit = activation_limit
        self.extension = extension or []


def activation_pin_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPinType_, xml_string)


class SecurityAuditType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SecurityAuditType element """

    c_tag = 'SecurityAuditType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}SwitchAudit'] = (
        'switch_audit', SwitchAudit)
    c_cardinality['switch_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['switch_audit', 'extension'])

    def __init__(self,
                 switch_audit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.switch_audit = switch_audit
        self.extension = extension or []


def security_audit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAuditType_, xml_string)


class AuthenticatorBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AuthenticatorBaseType element """

    c_tag = 'AuthenticatorBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_child_order.extend(['restricted_password'])

    def __init__(self,
                 restricted_password=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.restricted_password = restricted_password


def authenticator_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorBaseType_,
                                              xml_string)


class AuthenticatorTransportProtocolType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AuthenticatorTransportProtocolType element """

    c_tag = 'AuthenticatorTransportProtocolType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}SSL'] = (
        'ssl', SSL)
    c_cardinality['ssl'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}MobileNetworkRadioEncryption'] = (
        'mobile_network_radio_encryption', MobileNetworkRadioEncryption)
    c_cardinality['mobile_network_radio_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}MobileNetworkEndToEndEncryption'] = (
        'mobile_network_end_to_end_encryption', MobileNetworkEndToEndEncryption)
    c_cardinality['mobile_network_end_to_end_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}WTLS'] = (
        'wtls', WTLS)
    c_cardinality['wtls'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}IPSec'] = (
        'ip_sec', IPSec)
    c_cardinality['ip_sec'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['ssl', 'mobile_network_radio_encryption',
                          'mobile_network_end_to_end_encryption', 'wtls',
                          'ip_sec', 'extension'])

    def __init__(self,
                 ssl=None,
                 mobile_network_radio_encryption=None,
                 mobile_network_end_to_end_encryption=None,
                 wtls=None,
                 ip_sec=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.ssl = ssl
        self.mobile_network_radio_encryption = mobile_network_radio_encryption
        self.mobile_network_end_to_end_encryption = mobile_network_end_to_end_encryption
        self.wtls = wtls
        self.ip_sec = ip_sec
        self.extension = extension or []


def authenticator_transport_protocol_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        AuthenticatorTransportProtocolType_, xml_string)


class Identification(IdentificationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Identification element """

    c_tag = 'Identification'
    c_namespace = NAMESPACE
    c_children = IdentificationType_.c_children.copy()
    c_attributes = IdentificationType_.c_attributes.copy()
    c_child_order = IdentificationType_.c_child_order[:]
    c_cardinality = IdentificationType_.c_cardinality.copy()


def identification_from_string(xml_string):
    return saml2.create_class_from_xml_string(Identification, xml_string)


class ActivationPin(ActivationPinType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ActivationPin element """

    c_tag = 'ActivationPin'
    c_namespace = NAMESPACE
    c_children = ActivationPinType_.c_children.copy()
    c_attributes = ActivationPinType_.c_attributes.copy()
    c_child_order = ActivationPinType_.c_child_order[:]
    c_cardinality = ActivationPinType_.c_cardinality.copy()


def activation_pin_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPin, xml_string)


class Authenticator(AuthenticatorBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:Authenticator element """

    c_tag = 'Authenticator'
    c_namespace = NAMESPACE
    c_children = AuthenticatorBaseType_.c_children.copy()
    c_attributes = AuthenticatorBaseType_.c_attributes.copy()
    c_child_order = AuthenticatorBaseType_.c_child_order[:]
    c_cardinality = AuthenticatorBaseType_.c_cardinality.copy()


def authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(Authenticator, xml_string)


class AuthenticatorTransportProtocol(AuthenticatorTransportProtocolType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AuthenticatorTransportProtocol element """

    c_tag = 'AuthenticatorTransportProtocol'
    c_namespace = NAMESPACE
    c_children = AuthenticatorTransportProtocolType_.c_children.copy()
    c_attributes = AuthenticatorTransportProtocolType_.c_attributes.copy()
    c_child_order = AuthenticatorTransportProtocolType_.c_child_order[:]
    c_cardinality = AuthenticatorTransportProtocolType_.c_cardinality.copy()


def authenticator_transport_protocol_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorTransportProtocol,
                                              xml_string)


class SecurityAudit(SecurityAuditType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SecurityAudit element """

    c_tag = 'SecurityAudit'
    c_namespace = NAMESPACE
    c_children = SecurityAuditType_.c_children.copy()
    c_attributes = SecurityAuditType_.c_attributes.copy()
    c_child_order = SecurityAuditType_.c_child_order[:]
    c_cardinality = SecurityAuditType_.c_cardinality.copy()


def security_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAudit, xml_string)


class OperationalProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:OperationalProtectionType element """

    c_tag = 'OperationalProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}SecurityAudit'] = (
        'security_audit', SecurityAudit)
    c_cardinality['security_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}DeactivationCallCenter'] = (
        'deactivation_call_center', DeactivationCallCenter)
    c_cardinality['deactivation_call_center'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['security_audit', 'deactivation_call_center', 'extension'])

    def __init__(self,
                 security_audit=None,
                 deactivation_call_center=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.security_audit = security_audit
        self.deactivation_call_center = deactivation_call_center
        self.extension = extension or []


def operational_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtectionType_,
                                              xml_string)


class PrincipalAuthenticationMechanismType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PrincipalAuthenticationMechanismType element """

    c_tag = 'PrincipalAuthenticationMechanismType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Token'] = (
        'token', Token)
    c_cardinality['token'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Smartcard'] = (
        'smartcard', Smartcard)
    c_cardinality['smartcard'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['preauth'] = ('preauth', 'integer', False)
    c_child_order.extend(
        ['password', 'restricted_password', 'token', 'smartcard',
         'activation_pin', 'extension'])

    def __init__(self,
                 password=None,
                 restricted_password=None,
                 token=None,
                 smartcard=None,
                 activation_pin=None,
                 extension=None,
                 preauth=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.password = password
        self.restricted_password = restricted_password
        self.token = token
        self.smartcard = smartcard
        self.activation_pin = activation_pin
        self.extension = extension or []
        self.preauth = preauth


def principal_authentication_mechanism_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        PrincipalAuthenticationMechanismType_, xml_string)


class KeyActivationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:KeyActivationType element """

    c_tag = 'KeyActivationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['activation_pin', 'extension'])

    def __init__(self,
                 activation_pin=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_pin = activation_pin
        self.extension = extension or []


def key_activation_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivationType_, xml_string)


class KeyActivation(KeyActivationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:KeyActivation element """

    c_tag = 'KeyActivation'
    c_namespace = NAMESPACE
    c_children = KeyActivationType_.c_children.copy()
    c_attributes = KeyActivationType_.c_attributes.copy()
    c_child_order = KeyActivationType_.c_child_order[:]
    c_cardinality = KeyActivationType_.c_cardinality.copy()


def key_activation_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivation, xml_string)


class PrincipalAuthenticationMechanism(PrincipalAuthenticationMechanismType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PrincipalAuthenticationMechanism element """

    c_tag = 'PrincipalAuthenticationMechanism'
    c_namespace = NAMESPACE
    c_children = PrincipalAuthenticationMechanismType_.c_children.copy()
    c_attributes = PrincipalAuthenticationMechanismType_.c_attributes.copy()
    c_child_order = PrincipalAuthenticationMechanismType_.c_child_order[:]
    c_cardinality = PrincipalAuthenticationMechanismType_.c_cardinality.copy()


def principal_authentication_mechanism_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrincipalAuthenticationMechanism,
                                              xml_string)


class OperationalProtection(OperationalProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:OperationalProtection element """

    c_tag = 'OperationalProtection'
    c_namespace = NAMESPACE
    c_children = OperationalProtectionType_.c_children.copy()
    c_attributes = OperationalProtectionType_.c_attributes.copy()
    c_child_order = OperationalProtectionType_.c_child_order[:]
    c_cardinality = OperationalProtectionType_.c_cardinality.copy()


def operational_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtection, xml_string)


class PrivateKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PrivateKeyProtectionType element """

    c_tag = 'PrivateKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}KeyStorage'] = (

        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}KeySharing'] = (
        'key_sharing', KeySharing)
    c_cardinality['key_sharing'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport' \
        '}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['key_activation', 'key_storage', 'key_sharing', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 key_sharing=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.key_sharing = key_sharing
        self.extension = extension or []


def private_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtectionType_,
                                              xml_string)


class SecretKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SecretKeyProtectionType element """

    c_tag = 'SecretKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['key_activation', 'key_storage', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.extension = extension or []


def secret_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtectionType_,
                                              xml_string)


class AuthnMethodBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AuthnMethodBaseType element """

    c_tag = 'AuthnMethodBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}PrincipalAuthenticationMechanism'] = (
        'principal_authentication_mechanism', PrincipalAuthenticationMechanism)
    c_cardinality['principal_authentication_mechanism'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Authenticator'] = (
        'authenticator', Authenticator)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}AuthenticatorTransportProtocol'] = (
        'authenticator_transport_protocol', AuthenticatorTransportProtocol)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['principal_authentication_mechanism', 'authenticator',
                          'authenticator_transport_protocol', 'extension'])

    def __init__(self,
                 principal_authentication_mechanism=None,
                 authenticator=None,
                 authenticator_transport_protocol=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.principal_authentication_mechanism = principal_authentication_mechanism
        self.authenticator = authenticator
        self.authenticator_transport_protocol = authenticator_transport_protocol
        self.extension = extension or []


def authn_method_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethodBaseType_, xml_string)


class SecretKeyProtection(SecretKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:SecretKeyProtection element """

    c_tag = 'SecretKeyProtection'
    c_namespace = NAMESPACE
    c_children = SecretKeyProtectionType_.c_children.copy()
    c_attributes = SecretKeyProtectionType_.c_attributes.copy()
    c_child_order = SecretKeyProtectionType_.c_child_order[:]
    c_cardinality = SecretKeyProtectionType_.c_cardinality.copy()


def secret_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtection, xml_string)


class PrivateKeyProtection(PrivateKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:PrivateKeyProtection element """

    c_tag = 'PrivateKeyProtection'
    c_namespace = NAMESPACE
    c_children = PrivateKeyProtectionType_.c_children.copy()
    c_attributes = PrivateKeyProtectionType_.c_attributes.copy()
    c_child_order = PrivateKeyProtectionType_.c_child_order[:]
    c_cardinality = PrivateKeyProtectionType_.c_cardinality.copy()


def private_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtection, xml_string)


class AuthnMethod(AuthnMethodBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AuthnMethod element """

    c_tag = 'AuthnMethod'
    c_namespace = NAMESPACE
    c_children = AuthnMethodBaseType_.c_children.copy()
    c_attributes = AuthnMethodBaseType_.c_attributes.copy()
    c_child_order = AuthnMethodBaseType_.c_child_order[:]
    c_cardinality = AuthnMethodBaseType_.c_cardinality.copy()


def authn_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethod, xml_string)


class TechnicalProtectionBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:TechnicalProtectionBaseType element """

    c_tag = 'TechnicalProtectionBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}PrivateKeyProtection'] = (
        'private_key_protection', PrivateKeyProtection)
    c_cardinality['private_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}SecretKeyProtection'] = (
        'secret_key_protection', SecretKeyProtection)
    c_cardinality['secret_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport' \
        '}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['private_key_protection', 'secret_key_protection', 'extension'])

    def __init__(self,
                 private_key_protection=None,
                 secret_key_protection=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.private_key_protection = private_key_protection
        self.secret_key_protection = secret_key_protection
        self.extension = extension or []


def technical_protection_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtectionBaseType_,
                                              xml_string)


class TechnicalProtection(TechnicalProtectionBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:TechnicalProtection element """

    c_tag = 'TechnicalProtection'
    c_namespace = NAMESPACE
    c_children = TechnicalProtectionBaseType_.c_children.copy()
    c_attributes = TechnicalProtectionBaseType_.c_attributes.copy()
    c_child_order = TechnicalProtectionBaseType_.c_child_order[:]
    c_cardinality = TechnicalProtectionBaseType_.c_cardinality.copy()


def technical_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtection, xml_string)


class AuthnContextDeclarationBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AuthnContextDeclarationBaseType element """

    c_tag = 'AuthnContextDeclarationBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Identification'] = (
        'identification', Identification)
    c_cardinality['identification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}TechnicalProtection'] = (
        'technical_protection', TechnicalProtection)
    c_cardinality['technical_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}OperationalProtection'] = (
        'operational_protection', OperationalProtection)
    c_cardinality['operational_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}AuthnMethod'] = (
        'authn_method', AuthnMethod)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ID'] = ('id', 'ID', False)
    c_child_order.extend(
        ['identification', 'technical_protection', 'operational_protection',
         'authn_method', 'governing_agreements', 'extension'])

    def __init__(self,
                 identification=None,
                 technical_protection=None,
                 operational_protection=None,
                 authn_method=None,
                 governing_agreements=None,
                 extension=None,
                 id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.identification = identification
        self.technical_protection = technical_protection
        self.operational_protection = operational_protection
        self.authn_method = authn_method
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.id = id


def authn_context_declaration_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextDeclarationBaseType_,
                                              xml_string)


class AuthenticationContextDeclaration(AuthnContextDeclarationBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:AuthenticationContextDeclaration element """

    c_tag = 'AuthenticationContextDeclaration'
    c_namespace = NAMESPACE
    c_children = AuthnContextDeclarationBaseType_.c_children.copy()
    c_attributes = AuthnContextDeclarationBaseType_.c_attributes.copy()
    c_child_order = AuthnContextDeclarationBaseType_.c_child_order[:]
    c_cardinality = AuthnContextDeclarationBaseType_.c_cardinality.copy()


def authentication_context_declaration_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticationContextDeclaration,
                                              xml_string)


class ComplexAuthenticatorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ComplexAuthenticatorType element """

    c_tag = 'ComplexAuthenticatorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}PreviousSession'] = (

        'previous_session', PreviousSession)
    c_cardinality['previous_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ResumeSession'] = (
        'resume_session', ResumeSession)
    c_cardinality['resume_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}DigSig'] = (
        'dig_sig', DigSig)
    c_cardinality['dig_sig'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ZeroKnowledge'] = (
        'zero_knowledge', ZeroKnowledge)
    c_cardinality['zero_knowledge'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}SharedSecretChallengeResponse'] = (
        'shared_secret_challenge_response', SharedSecretChallengeResponse)
    c_cardinality['shared_secret_challenge_response'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}SharedSecretDynamicPlaintext'] = (
        'shared_secret_dynamic_plaintext', SharedSecretDynamicPlaintext)
    c_cardinality['shared_secret_dynamic_plaintext'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}IPAddress'] = (
        'ip_address', IPAddress)
    c_cardinality['ip_address'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}AsymmetricDecryption'] = (
        'asymmetric_decryption', AsymmetricDecryption)
    c_cardinality['asymmetric_decryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}AsymmetricKeyAgreement'] = (
        'asymmetric_key_agreement', AsymmetricKeyAgreement)
    c_cardinality['asymmetric_key_agreement'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}SubscriberLineNumber'] = (
        'subscriber_line_number', SubscriberLineNumber)
    c_cardinality['subscriber_line_number'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}UserSuffix'] = (
        'user_suffix', UserSuffix)
    c_cardinality['user_suffix'] = {"min": 0, "max": 1}
    c_cardinality['complex_authenticator'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['previous_session', 'resume_session', 'dig_sig', 'password',
         'restricted_password', 'zero_knowledge',
         'shared_secret_challenge_response', 'shared_secret_dynamic_plaintext',
         'ip_address', 'asymmetric_decryption', 'asymmetric_key_agreement',
         'subscriber_line_number', 'user_suffix', 'complex_authenticator',
         'extension'])

    def __init__(self,
                 previous_session=None,
                 resume_session=None,
                 dig_sig=None,
                 password=None,
                 restricted_password=None,
                 zero_knowledge=None,
                 shared_secret_challenge_response=None,
                 shared_secret_dynamic_plaintext=None,
                 ip_address=None,
                 asymmetric_decryption=None,
                 asymmetric_key_agreement=None,
                 subscriber_line_number=None,
                 user_suffix=None,
                 complex_authenticator=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.previous_session = previous_session
        self.resume_session = resume_session
        self.dig_sig = dig_sig
        self.password = password
        self.restricted_password = restricted_password
        self.zero_knowledge = zero_knowledge
        self.shared_secret_challenge_response = shared_secret_challenge_response
        self.shared_secret_dynamic_plaintext = shared_secret_dynamic_plaintext
        self.ip_address = ip_address
        self.asymmetric_decryption = asymmetric_decryption
        self.asymmetric_key_agreement = asymmetric_key_agreement
        self.subscriber_line_number = subscriber_line_number
        self.user_suffix = user_suffix
        self.complex_authenticator = complex_authenticator
        self.extension = extension or []


def complex_authenticator_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticatorType_,
                                              xml_string)


class ComplexAuthenticator(ComplexAuthenticatorType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport:ComplexAuthenticator element """

    c_tag = 'ComplexAuthenticator'
    c_namespace = NAMESPACE
    c_children = ComplexAuthenticatorType_.c_children.copy()
    c_attributes = ComplexAuthenticatorType_.c_attributes.copy()
    c_child_order = ComplexAuthenticatorType_.c_child_order[:]
    c_cardinality = ComplexAuthenticatorType_.c_cardinality.copy()


def complex_authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticator, xml_string)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ComplexAuthenticatorType_.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
ComplexAuthenticator.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ELEMENT_FROM_STRING = {
    AuthenticationContextDeclaration.c_tag: authentication_context_declaration_from_string,
    Identification.c_tag: identification_from_string,
    PhysicalVerification.c_tag: physical_verification_from_string,
    WrittenConsent.c_tag: written_consent_from_string,
    TechnicalProtection.c_tag: technical_protection_from_string,
    SecretKeyProtection.c_tag: secret_key_protection_from_string,
    PrivateKeyProtection.c_tag: private_key_protection_from_string,
    KeyActivation.c_tag: key_activation_from_string,
    KeySharing.c_tag: key_sharing_from_string,
    KeyStorage.c_tag: key_storage_from_string,
    SubscriberLineNumber.c_tag: subscriber_line_number_from_string,
    UserSuffix.c_tag: user_suffix_from_string,
    Password.c_tag: password_from_string,
    ActivationPin.c_tag: activation_pin_from_string,
    Token.c_tag: token_from_string,
    TimeSyncToken.c_tag: time_sync_token_from_string,
    Smartcard.c_tag: smartcard_from_string,
    Length.c_tag: length_from_string,
    ActivationLimit.c_tag: activation_limit_from_string,
    Generation.c_tag: generation_from_string,
    AuthnMethod.c_tag: authn_method_from_string,
    PrincipalAuthenticationMechanism.c_tag: principal_authentication_mechanism_from_string,
    Authenticator.c_tag: authenticator_from_string,
    ComplexAuthenticator.c_tag: complex_authenticator_from_string,
    PreviousSession.c_tag: previous_session_from_string,
    ResumeSession.c_tag: resume_session_from_string,
    ZeroKnowledge.c_tag: zero_knowledge_from_string,
    SharedSecretChallengeResponse.c_tag: shared_secret_challenge_response_from_string,
    SharedSecretChallengeResponseType_.c_tag: shared_secret_challenge_response_type__from_string,
    DigSig.c_tag: dig_sig_from_string,
    AsymmetricDecryption.c_tag: asymmetric_decryption_from_string,
    AsymmetricKeyAgreement.c_tag: asymmetric_key_agreement_from_string,
    PublicKeyType_.c_tag: public_key_type__from_string,
    IPAddress.c_tag: ip_address_from_string,
    SharedSecretDynamicPlaintext.c_tag: shared_secret_dynamic_plaintext_from_string,
    AuthenticatorTransportProtocol.c_tag: authenticator_transport_protocol_from_string,
    HTTP.c_tag: http_from_string,
    IPSec.c_tag: ip_sec_from_string,
    WTLS.c_tag: wtls_from_string,
    MobileNetworkNoEncryption.c_tag: mobile_network_no_encryption_from_string,
    MobileNetworkRadioEncryption.c_tag: mobile_network_radio_encryption_from_string,
    MobileNetworkEndToEndEncryption.c_tag: mobile_network_end_to_end_encryption_from_string,
    SSL.c_tag: ssl_from_string,
    PSTN.c_tag: pstn_from_string,
    ISDN.c_tag: isdn_from_string,
    ADSL.c_tag: adsl_from_string,
    OperationalProtection.c_tag: operational_protection_from_string,
    SecurityAudit.c_tag: security_audit_from_string,
    SwitchAudit.c_tag: switch_audit_from_string,
    DeactivationCallCenter.c_tag: deactivation_call_center_from_string,
    GoverningAgreements.c_tag: governing_agreements_from_string,
    GoverningAgreementRef.c_tag: governing_agreement_ref_from_string,
    NymType_.c_tag: nym_type__from_string,
    IdentificationType_.c_tag: identification_type__from_string,
    TechnicalProtectionBaseType_.c_tag: technical_protection_base_type__from_string,
    OperationalProtectionType_.c_tag: operational_protection_type__from_string,
    GoverningAgreementsType_.c_tag: governing_agreements_type__from_string,
    GoverningAgreementRefType_.c_tag: governing_agreement_ref_type__from_string,
    PrincipalAuthenticationMechanismType_.c_tag: principal_authentication_mechanism_type__from_string,
    ComplexAuthenticatorType_.c_tag: complex_authenticator_type__from_string,
    KeyActivationType_.c_tag: key_activation_type__from_string,
    KeySharingType_.c_tag: key_sharing_type__from_string,
    PrivateKeyProtectionType_.c_tag: private_key_protection_type__from_string,
    PasswordType_.c_tag: password_type__from_string,
    RestrictedPassword.c_tag: restricted_password_from_string,
    RestrictedPasswordType_.c_tag: restricted_password_type__from_string,
    RestrictedLengthType_.c_tag: restricted_length_type__from_string,
    ActivationPinType_.c_tag: activation_pin_type__from_string,
    Alphabet.c_tag: alphabet_from_string,
    AlphabetType_.c_tag: alphabet_type__from_string,
    TokenType_.c_tag: token_type__from_string,
    DeviceTypeType_.c_tag: device_type_type__from_string,
    BooleanType_.c_tag: boolean_type__from_string,
    TimeSyncTokenType_.c_tag: time_sync_token_type__from_string,
    ActivationLimitType_.c_tag: activation_limit_type__from_string,
    ActivationLimitDuration.c_tag: activation_limit_duration_from_string,
    ActivationLimitUsages.c_tag: activation_limit_usages_from_string,
    ActivationLimitSession.c_tag: activation_limit_session_from_string,
    ActivationLimitDurationType_.c_tag: activation_limit_duration_type__from_string,
    ActivationLimitUsagesType_.c_tag: activation_limit_usages_type__from_string,
    ActivationLimitSessionType_.c_tag: activation_limit_session_type__from_string,
    LengthType_.c_tag: length_type__from_string,
    MediumType_.c_tag: medium_type__from_string,
    KeyStorageType_.c_tag: key_storage_type__from_string,
    SecretKeyProtectionType_.c_tag: secret_key_protection_type__from_string,
    SecurityAuditType_.c_tag: security_audit_type__from_string,
    ExtensionOnlyType_.c_tag: extension_only_type__from_string,
    Extension.c_tag: extension_from_string,
    ExtensionType_.c_tag: extension_type__from_string,
    AuthnContextDeclarationBaseType_.c_tag: authn_context_declaration_base_type__from_string,
    AuthnMethodBaseType_.c_tag: authn_method_base_type__from_string,
    AuthenticatorBaseType_.c_tag: authenticator_base_type__from_string,
    AuthenticatorTransportProtocolType_.c_tag: authenticator_transport_protocol_type__from_string,
}

ELEMENT_BY_TAG = {
    'AuthenticationContextDeclaration': AuthenticationContextDeclaration,
    'Identification': Identification,
    'PhysicalVerification': PhysicalVerification,
    'WrittenConsent': WrittenConsent,
    'TechnicalProtection': TechnicalProtection,
    'SecretKeyProtection': SecretKeyProtection,
    'PrivateKeyProtection': PrivateKeyProtection,
    'KeyActivation': KeyActivation,
    'KeySharing': KeySharing,
    'KeyStorage': KeyStorage,
    'SubscriberLineNumber': SubscriberLineNumber,
    'UserSuffix': UserSuffix,
    'Password': Password,
    'ActivationPin': ActivationPin,
    'Token': Token,
    'TimeSyncToken': TimeSyncToken,
    'Smartcard': Smartcard,
    'Length': Length,
    'ActivationLimit': ActivationLimit,
    'Generation': Generation,
    'AuthnMethod': AuthnMethod,
    'PrincipalAuthenticationMechanism': PrincipalAuthenticationMechanism,
    'Authenticator': Authenticator,
    'ComplexAuthenticator': ComplexAuthenticator,
    'PreviousSession': PreviousSession,
    'ResumeSession': ResumeSession,
    'ZeroKnowledge': ZeroKnowledge,
    'SharedSecretChallengeResponse': SharedSecretChallengeResponse,
    'SharedSecretChallengeResponseType': SharedSecretChallengeResponseType_,
    'DigSig': DigSig,
    'AsymmetricDecryption': AsymmetricDecryption,
    'AsymmetricKeyAgreement': AsymmetricKeyAgreement,
    'PublicKeyType': PublicKeyType_,
    'IPAddress': IPAddress,
    'SharedSecretDynamicPlaintext': SharedSecretDynamicPlaintext,
    'AuthenticatorTransportProtocol': AuthenticatorTransportProtocol,
    'HTTP': HTTP,
    'IPSec': IPSec,
    'WTLS': WTLS,
    'MobileNetworkNoEncryption': MobileNetworkNoEncryption,
    'MobileNetworkRadioEncryption': MobileNetworkRadioEncryption,
    'MobileNetworkEndToEndEncryption': MobileNetworkEndToEndEncryption,
    'SSL': SSL,
    'PSTN': PSTN,
    'ISDN': ISDN,
    'ADSL': ADSL,
    'OperationalProtection': OperationalProtection,
    'SecurityAudit': SecurityAudit,
    'SwitchAudit': SwitchAudit,
    'DeactivationCallCenter': DeactivationCallCenter,
    'GoverningAgreements': GoverningAgreements,
    'GoverningAgreementRef': GoverningAgreementRef,
    'nymType': NymType_,
    'IdentificationType': IdentificationType_,
    'TechnicalProtectionBaseType': TechnicalProtectionBaseType_,
    'OperationalProtectionType': OperationalProtectionType_,
    'GoverningAgreementsType': GoverningAgreementsType_,
    'GoverningAgreementRefType': GoverningAgreementRefType_,
    'PrincipalAuthenticationMechanismType': PrincipalAuthenticationMechanismType_,
    'ComplexAuthenticatorType': ComplexAuthenticatorType_,
    'KeyActivationType': KeyActivationType_,
    'KeySharingType': KeySharingType_,
    'PrivateKeyProtectionType': PrivateKeyProtectionType_,
    'PasswordType': PasswordType_,
    'RestrictedPassword': RestrictedPassword,
    'RestrictedPasswordType': RestrictedPasswordType_,
    'RestrictedLengthType': RestrictedLengthType_,
    'ActivationPinType': ActivationPinType_,
    'Alphabet': Alphabet,
    'AlphabetType': AlphabetType_,
    'TokenType': TokenType_,
    'DeviceTypeType': DeviceTypeType_,
    'booleanType': BooleanType_,
    'TimeSyncTokenType': TimeSyncTokenType_,
    'ActivationLimitType': ActivationLimitType_,
    'ActivationLimitDuration': ActivationLimitDuration,
    'ActivationLimitUsages': ActivationLimitUsages,
    'ActivationLimitSession': ActivationLimitSession,
    'ActivationLimitDurationType': ActivationLimitDurationType_,
    'ActivationLimitUsagesType': ActivationLimitUsagesType_,
    'ActivationLimitSessionType': ActivationLimitSessionType_,
    'LengthType': LengthType_,
    'mediumType': MediumType_,
    'KeyStorageType': KeyStorageType_,
    'SecretKeyProtectionType': SecretKeyProtectionType_,
    'SecurityAuditType': SecurityAuditType_,
    'ExtensionOnlyType': ExtensionOnlyType_,
    'Extension': Extension,
    'ExtensionType': ExtensionType_,
    'AuthnContextDeclarationBaseType': AuthnContextDeclarationBaseType_,
    'AuthnMethodBaseType': AuthnMethodBaseType_,
    'AuthenticatorBaseType': AuthenticatorBaseType_,
    'AuthenticatorTransportProtocolType': AuthenticatorTransportProtocolType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = pword
#!/usr/bin/env python

#
# Generated Sun Apr 21 10:04:52 2013 by parse_xsd.py version 0.5.
#

"""
The Password class is applicable when a principal authenticates to an
authentication authority through the presentation of a password over an
unprotected HTTP session.
"""

import saml2
from saml2 import SamlBase


NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:ac:classes:Password'


class PhysicalVerification(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PhysicalVerification element """

    c_tag = 'PhysicalVerification'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['credentialLevel'] = ('credential_level', 'None', False)

    def __init__(self,
                 credential_level=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.credential_level = credential_level


def physical_verification_from_string(xml_string):
    return saml2.create_class_from_xml_string(PhysicalVerification, xml_string)


class Generation(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Generation element """

    c_tag = 'Generation'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['mechanism'] = ('mechanism', 'None', True)

    def __init__(self,
                 mechanism=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.mechanism = mechanism


def generation_from_string(xml_string):
    return saml2.create_class_from_xml_string(Generation, xml_string)


class NymType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:nymType element """

    c_tag = 'nymType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['anonymity', 'verinymity', 'pseudonymity']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def nym_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NymType_, xml_string)


class GoverningAgreementRefType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:GoverningAgreementRefType element """

    c_tag = 'GoverningAgreementRefType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['governingAgreementRef'] = (
        'governing_agreement_ref', 'anyURI', True)

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref


def governing_agreement_ref_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRefType_,
                                              xml_string)


class KeySharingType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:KeySharingType element """

    c_tag = 'KeySharingType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['sharing'] = ('sharing', 'boolean', True)

    def __init__(self,
                 sharing=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.sharing = sharing


def key_sharing_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharingType_, xml_string)


class RestrictedLengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:RestrictedLengthType element """

    c_tag = 'RestrictedLengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'None', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def restricted_length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedLengthType_, xml_string)


class AlphabetType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AlphabetType element """

    c_tag = 'AlphabetType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['requiredChars'] = ('required_chars', 'string', True)
    c_attributes['excludedChars'] = ('excluded_chars', 'string', False)
    c_attributes['case'] = ('case', 'string', False)

    def __init__(self,
                 required_chars=None,
                 excluded_chars=None,
                 case=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.required_chars = required_chars
        self.excluded_chars = excluded_chars
        self.case = case


def alphabet_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AlphabetType_, xml_string)


class DeviceTypeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:DeviceTypeType element """

    c_tag = 'DeviceTypeType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['hardware', 'software']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def device_type_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DeviceTypeType_, xml_string)


class BooleanType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:booleanType element """

    c_tag = 'booleanType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN', 'enumeration': ['true', 'false']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def boolean_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(BooleanType_, xml_string)


class TimeSyncTokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:TimeSyncTokenType element """

    c_tag = 'TimeSyncTokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['DeviceType'] = ('device_type', DeviceTypeType_, True)
    c_attributes['SeedLength'] = ('seed_length', 'integer', True)
    c_attributes['DeviceInHand'] = ('device_in_hand', BooleanType_, True)

    def __init__(self,
                 device_type=None,
                 seed_length=None,
                 device_in_hand=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.device_type = device_type
        self.seed_length = seed_length
        self.device_in_hand = device_in_hand


def time_sync_token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncTokenType_, xml_string)


class ActivationLimitDurationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationLimitDurationType element """

    c_tag = 'ActivationLimitDurationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['duration'] = ('duration', 'duration', True)

    def __init__(self,
                 duration=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.duration = duration


def activation_limit_duration_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDurationType_,
                                              xml_string)


class ActivationLimitUsagesType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationLimitUsagesType element """

    c_tag = 'ActivationLimitUsagesType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['number'] = ('number', 'integer', True)

    def __init__(self,
                 number=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.number = number


def activation_limit_usages_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsagesType_,
                                              xml_string)


class ActivationLimitSessionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationLimitSessionType element """

    c_tag = 'ActivationLimitSessionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def activation_limit_session_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSessionType_,
                                              xml_string)


class LengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:LengthType element """

    c_tag = 'LengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'integer', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LengthType_, xml_string)


class MediumType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:mediumType element """

    c_tag = 'mediumType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['memory', 'smartcard', 'token',
                                    'MobileDevice', 'MobileAuthCard']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def medium_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(MediumType_, xml_string)


class KeyStorageType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:KeyStorageType element """

    c_tag = 'KeyStorageType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['medium'] = ('medium', MediumType_, True)

    def __init__(self,
                 medium=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.medium = medium


def key_storage_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorageType_, xml_string)


class ExtensionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ExtensionType element """

    c_tag = 'ExtensionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def extension_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionType_, xml_string)


class KeySharing(KeySharingType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:KeySharing element """

    c_tag = 'KeySharing'
    c_namespace = NAMESPACE
    c_children = KeySharingType_.c_children.copy()
    c_attributes = KeySharingType_.c_attributes.copy()
    c_child_order = KeySharingType_.c_child_order[:]
    c_cardinality = KeySharingType_.c_cardinality.copy()


def key_sharing_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharing, xml_string)


class KeyStorage(KeyStorageType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:KeyStorage element """

    c_tag = 'KeyStorage'
    c_namespace = NAMESPACE
    c_children = KeyStorageType_.c_children.copy()
    c_attributes = KeyStorageType_.c_attributes.copy()
    c_child_order = KeyStorageType_.c_child_order[:]
    c_cardinality = KeyStorageType_.c_cardinality.copy()


def key_storage_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorage, xml_string)


class TimeSyncToken(TimeSyncTokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:TimeSyncToken element """

    c_tag = 'TimeSyncToken'
    c_namespace = NAMESPACE
    c_children = TimeSyncTokenType_.c_children.copy()
    c_attributes = TimeSyncTokenType_.c_attributes.copy()
    c_child_order = TimeSyncTokenType_.c_child_order[:]
    c_cardinality = TimeSyncTokenType_.c_cardinality.copy()


def time_sync_token_from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncToken, xml_string)


class Length(LengthType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Length element """

    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = LengthType_.c_children.copy()
    c_attributes = LengthType_.c_attributes.copy()
    c_child_order = LengthType_.c_child_order[:]
    c_cardinality = LengthType_.c_cardinality.copy()


def length_from_string(xml_string):
    return saml2.create_class_from_xml_string(Length, xml_string)


class GoverningAgreementRef(GoverningAgreementRefType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:GoverningAgreementRef element """

    c_tag = 'GoverningAgreementRef'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementRefType_.c_children.copy()
    c_attributes = GoverningAgreementRefType_.c_attributes.copy()
    c_child_order = GoverningAgreementRefType_.c_child_order[:]
    c_cardinality = GoverningAgreementRefType_.c_cardinality.copy()


def governing_agreement_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRef, xml_string)


class GoverningAgreementsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:GoverningAgreementsType element """

    c_tag = 'GoverningAgreementsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}GoverningAgreementRef'] = (
        'governing_agreement_ref', [GoverningAgreementRef])
    c_cardinality['governing_agreement_ref'] = {"min": 1}
    c_child_order.extend(['governing_agreement_ref'])

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref or []


def governing_agreements_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementsType_,
                                              xml_string)


class RestrictedPasswordType_Length(RestrictedLengthType_):
    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = RestrictedLengthType_.c_children.copy()
    c_attributes = RestrictedLengthType_.c_attributes.copy()
    c_child_order = RestrictedLengthType_.c_child_order[:]
    c_cardinality = RestrictedLengthType_.c_cardinality.copy()


def restricted_password_type__length_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_Length,
                                              xml_string)


class Alphabet(AlphabetType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Alphabet element """

    c_tag = 'Alphabet'
    c_namespace = NAMESPACE
    c_children = AlphabetType_.c_children.copy()
    c_attributes = AlphabetType_.c_attributes.copy()
    c_child_order = AlphabetType_.c_child_order[:]
    c_cardinality = AlphabetType_.c_cardinality.copy()


def alphabet_from_string(xml_string):
    return saml2.create_class_from_xml_string(Alphabet, xml_string)


class ActivationLimitDuration(ActivationLimitDurationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationLimitDuration element """

    c_tag = 'ActivationLimitDuration'
    c_namespace = NAMESPACE
    c_children = ActivationLimitDurationType_.c_children.copy()
    c_attributes = ActivationLimitDurationType_.c_attributes.copy()
    c_child_order = ActivationLimitDurationType_.c_child_order[:]
    c_cardinality = ActivationLimitDurationType_.c_cardinality.copy()


def activation_limit_duration_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDuration,
                                              xml_string)


class ActivationLimitUsages(ActivationLimitUsagesType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationLimitUsages element """

    c_tag = 'ActivationLimitUsages'
    c_namespace = NAMESPACE
    c_children = ActivationLimitUsagesType_.c_children.copy()
    c_attributes = ActivationLimitUsagesType_.c_attributes.copy()
    c_child_order = ActivationLimitUsagesType_.c_child_order[:]
    c_cardinality = ActivationLimitUsagesType_.c_cardinality.copy()


def activation_limit_usages_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsages, xml_string)


class ActivationLimitSession(ActivationLimitSessionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationLimitSession element """

    c_tag = 'ActivationLimitSession'
    c_namespace = NAMESPACE
    c_children = ActivationLimitSessionType_.c_children.copy()
    c_attributes = ActivationLimitSessionType_.c_attributes.copy()
    c_child_order = ActivationLimitSessionType_.c_child_order[:]
    c_cardinality = ActivationLimitSessionType_.c_cardinality.copy()


def activation_limit_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSession,
                                              xml_string)


class Extension(ExtensionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Extension element """

    c_tag = 'Extension'
    c_namespace = NAMESPACE
    c_children = ExtensionType_.c_children.copy()
    c_attributes = ExtensionType_.c_attributes.copy()
    c_child_order = ExtensionType_.c_child_order[:]
    c_cardinality = ExtensionType_.c_cardinality.copy()


def extension_from_string(xml_string):
    return saml2.create_class_from_xml_string(Extension, xml_string)


class SharedSecretChallengeResponseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SharedSecretChallengeResponseType element """

    c_tag = 'SharedSecretChallengeResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['method'] = ('method', 'anyURI', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 method=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.method = method


def shared_secret_challenge_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        SharedSecretChallengeResponseType_, xml_string)


class PublicKeyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PublicKeyType element """

    c_tag = 'PublicKeyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['keyValidation'] = ('key_validation', 'None', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 key_validation=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.key_validation = key_validation


def public_key_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicKeyType_, xml_string)


class GoverningAgreements(GoverningAgreementsType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:GoverningAgreements element """

    c_tag = 'GoverningAgreements'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementsType_.c_children.copy()
    c_attributes = GoverningAgreementsType_.c_attributes.copy()
    c_child_order = GoverningAgreementsType_.c_child_order[:]
    c_cardinality = GoverningAgreementsType_.c_cardinality.copy()


def governing_agreements_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreements, xml_string)


class PasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PasswordType element """

    c_tag = 'PasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'alphabet', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PasswordType_, xml_string)


class RestrictedPasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:RestrictedPasswordType element """

    c_tag = 'RestrictedPasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Length'] = (
        'length', RestrictedPasswordType_Length)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def restricted_password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_,
                                              xml_string)


class TokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:TokenType element """

    c_tag = 'TokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}TimeSyncToken'] = (
        'time_sync_token', TimeSyncToken)
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['time_sync_token', 'extension'])

    def __init__(self,
                 time_sync_token=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.time_sync_token = time_sync_token
        self.extension = extension or []


def token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TokenType_, xml_string)


class ActivationLimitType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationLimitType element """

    c_tag = 'ActivationLimitType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ActivationLimitDuration'] = (
        'activation_limit_duration', ActivationLimitDuration)
    c_cardinality['activation_limit_duration'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ActivationLimitUsages'] = (
        'activation_limit_usages', ActivationLimitUsages)
    c_cardinality['activation_limit_usages'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ActivationLimitSession'] = (
        'activation_limit_session', ActivationLimitSession)
    c_cardinality['activation_limit_session'] = {"min": 0, "max": 1}
    c_child_order.extend(
        ['activation_limit_duration', 'activation_limit_usages',
         'activation_limit_session'])

    def __init__(self,
                 activation_limit_duration=None,
                 activation_limit_usages=None,
                 activation_limit_session=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_limit_duration = activation_limit_duration
        self.activation_limit_usages = activation_limit_usages
        self.activation_limit_session = activation_limit_session


def activation_limit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitType_, xml_string)


class ExtensionOnlyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ExtensionOnlyType element """

    c_tag = 'ExtensionOnlyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []


def extension_only_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionOnlyType_, xml_string)


class WrittenConsent(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:WrittenConsent element """

    c_tag = 'WrittenConsent'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def written_consent_from_string(xml_string):
    return saml2.create_class_from_xml_string(WrittenConsent, xml_string)


class SubscriberLineNumber(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SubscriberLineNumber element """

    c_tag = 'SubscriberLineNumber'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def subscriber_line_number_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubscriberLineNumber, xml_string)


class UserSuffix(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:UserSuffix element """

    c_tag = 'UserSuffix'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def user_suffix_from_string(xml_string):
    return saml2.create_class_from_xml_string(UserSuffix, xml_string)


class Password(PasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Password element """

    c_tag = 'Password'
    c_namespace = NAMESPACE
    c_children = PasswordType_.c_children.copy()
    c_attributes = PasswordType_.c_attributes.copy()
    c_child_order = PasswordType_.c_child_order[:]
    c_cardinality = PasswordType_.c_cardinality.copy()


def password_from_string(xml_string):
    return saml2.create_class_from_xml_string(Password, xml_string)


class Token(TokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Token element """

    c_tag = 'Token'
    c_namespace = NAMESPACE
    c_children = TokenType_.c_children.copy()
    c_attributes = TokenType_.c_attributes.copy()
    c_child_order = TokenType_.c_child_order[:]
    c_cardinality = TokenType_.c_cardinality.copy()


def token_from_string(xml_string):
    return saml2.create_class_from_xml_string(Token, xml_string)


class Smartcard(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Smartcard element """

    c_tag = 'Smartcard'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def smartcard_from_string(xml_string):
    return saml2.create_class_from_xml_string(Smartcard, xml_string)


class ActivationLimit(ActivationLimitType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationLimit element """

    c_tag = 'ActivationLimit'
    c_namespace = NAMESPACE
    c_children = ActivationLimitType_.c_children.copy()
    c_attributes = ActivationLimitType_.c_attributes.copy()
    c_child_order = ActivationLimitType_.c_child_order[:]
    c_cardinality = ActivationLimitType_.c_cardinality.copy()


def activation_limit_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimit, xml_string)


class PreviousSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PreviousSession element """

    c_tag = 'PreviousSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def previous_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(PreviousSession, xml_string)


class ResumeSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ResumeSession element """

    c_tag = 'ResumeSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def resume_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ResumeSession, xml_string)


class ZeroKnowledge(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ZeroKnowledge element """

    c_tag = 'ZeroKnowledge'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def zero_knowledge_from_string(xml_string):
    return saml2.create_class_from_xml_string(ZeroKnowledge, xml_string)


class SharedSecretChallengeResponse(SharedSecretChallengeResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SharedSecretChallengeResponse element """

    c_tag = 'SharedSecretChallengeResponse'
    c_namespace = NAMESPACE
    c_children = SharedSecretChallengeResponseType_.c_children.copy()
    c_attributes = SharedSecretChallengeResponseType_.c_attributes.copy()
    c_child_order = SharedSecretChallengeResponseType_.c_child_order[:]
    c_cardinality = SharedSecretChallengeResponseType_.c_cardinality.copy()


def shared_secret_challenge_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretChallengeResponse,
                                              xml_string)


class DigSig(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:DigSig element """

    c_tag = 'DigSig'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def dig_sig_from_string(xml_string):
    return saml2.create_class_from_xml_string(DigSig, xml_string)


class AsymmetricDecryption(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AsymmetricDecryption element """

    c_tag = 'AsymmetricDecryption'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_decryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricDecryption, xml_string)


class AsymmetricKeyAgreement(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AsymmetricKeyAgreement element """

    c_tag = 'AsymmetricKeyAgreement'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_key_agreement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricKeyAgreement,
                                              xml_string)


class IPAddress(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:IPAddress element """

    c_tag = 'IPAddress'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_address_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPAddress, xml_string)


class SharedSecretDynamicPlaintext(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SharedSecretDynamicPlaintext element """

    c_tag = 'SharedSecretDynamicPlaintext'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def shared_secret_dynamic_plaintext_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretDynamicPlaintext,
                                              xml_string)


class HTTP(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:HTTP element """

    c_tag = 'HTTP'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def http_from_string(xml_string):
    return saml2.create_class_from_xml_string(HTTP, xml_string)


class IPSec(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:IPSec element """

    c_tag = 'IPSec'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_sec_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPSec, xml_string)


class WTLS(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:WTLS element """

    c_tag = 'WTLS'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def wtls_from_string(xml_string):
    return saml2.create_class_from_xml_string(WTLS, xml_string)


class MobileNetworkNoEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:MobileNetworkNoEncryption element """

    c_tag = 'MobileNetworkNoEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_no_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkNoEncryption,
                                              xml_string)


class MobileNetworkRadioEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:MobileNetworkRadioEncryption element """

    c_tag = 'MobileNetworkRadioEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_radio_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkRadioEncryption,
                                              xml_string)


class MobileNetworkEndToEndEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:MobileNetworkEndToEndEncryption element """

    c_tag = 'MobileNetworkEndToEndEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_end_to_end_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkEndToEndEncryption,
                                              xml_string)


class SSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SSL element """

    c_tag = 'SSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ssl_from_string(xml_string):
    return saml2.create_class_from_xml_string(SSL, xml_string)


class PSTN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PSTN element """

    c_tag = 'PSTN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def pstn_from_string(xml_string):
    return saml2.create_class_from_xml_string(PSTN, xml_string)


class ISDN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ISDN element """

    c_tag = 'ISDN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def isdn_from_string(xml_string):
    return saml2.create_class_from_xml_string(ISDN, xml_string)


class ADSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ADSL element """

    c_tag = 'ADSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def adsl_from_string(xml_string):
    return saml2.create_class_from_xml_string(ADSL, xml_string)


class SwitchAudit(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SwitchAudit element """

    c_tag = 'SwitchAudit'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def switch_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SwitchAudit, xml_string)


class DeactivationCallCenter(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:DeactivationCallCenter element """

    c_tag = 'DeactivationCallCenter'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def deactivation_call_center_from_string(xml_string):
    return saml2.create_class_from_xml_string(DeactivationCallCenter,
                                              xml_string)


class IdentificationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:IdentificationType element """

    c_tag = 'IdentificationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}PhysicalVerification'] = (
        'physical_verification', PhysicalVerification)
    c_cardinality['physical_verification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}WrittenConsent'] = (
        'written_consent', WrittenConsent)
    c_cardinality['written_consent'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['nym'] = ('nym', NymType_, False)
    c_child_order.extend(
        ['physical_verification', 'written_consent', 'governing_agreements',
         'extension'])

    def __init__(self,
                 physical_verification=None,
                 written_consent=None,
                 governing_agreements=None,
                 extension=None,
                 nym=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.physical_verification = physical_verification
        self.written_consent = written_consent
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.nym = nym


def identification_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IdentificationType_, xml_string)


class AuthenticatorTransportProtocolType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AuthenticatorTransportProtocolType element """

    c_tag = 'AuthenticatorTransportProtocolType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}HTTP'] = (
        'http', HTTP)
    c_cardinality['http'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}SSL'] = (
        'ssl', SSL)
    c_cardinality['ssl'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}MobileNetworkNoEncryption'] = (
        'mobile_network_no_encryption', MobileNetworkNoEncryption)
    c_cardinality['mobile_network_no_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}MobileNetworkRadioEncryption'] = (
        'mobile_network_radio_encryption', MobileNetworkRadioEncryption)
    c_cardinality['mobile_network_radio_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}MobileNetworkEndToEndEncryption'] = (
        'mobile_network_end_to_end_encryption', MobileNetworkEndToEndEncryption)
    c_cardinality['mobile_network_end_to_end_encryption'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}WTLS'] = (
        'wtls', WTLS)
    c_cardinality['wtls'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}IPSec'] = (
        'ip_sec', IPSec)
    c_cardinality['ip_sec'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}PSTN'] = (
        'pstn', PSTN)
    c_cardinality['pstn'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ISDN'] = (
        'isdn', ISDN)
    c_cardinality['isdn'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ADSL'] = (
        'adsl', ADSL)
    c_cardinality['adsl'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['http', 'ssl', 'mobile_network_no_encryption',
                          'mobile_network_radio_encryption',
                          'mobile_network_end_to_end_encryption', 'wtls',
                          'ip_sec', 'pstn', 'isdn', 'adsl', 'extension'])

    def __init__(self,
                 http=None,
                 ssl=None,
                 mobile_network_no_encryption=None,
                 mobile_network_radio_encryption=None,
                 mobile_network_end_to_end_encryption=None,
                 wtls=None,
                 ip_sec=None,
                 pstn=None,
                 isdn=None,
                 adsl=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.http = http
        self.ssl = ssl
        self.mobile_network_no_encryption = mobile_network_no_encryption
        self.mobile_network_radio_encryption = mobile_network_radio_encryption
        self.mobile_network_end_to_end_encryption = mobile_network_end_to_end_encryption
        self.wtls = wtls
        self.ip_sec = ip_sec
        self.pstn = pstn
        self.isdn = isdn
        self.adsl = adsl
        self.extension = extension or []


def authenticator_transport_protocol_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        AuthenticatorTransportProtocolType_, xml_string)


class RestrictedPassword(RestrictedPasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:RestrictedPassword element """

    c_tag = 'RestrictedPassword'
    c_namespace = NAMESPACE
    c_children = RestrictedPasswordType_.c_children.copy()
    c_attributes = RestrictedPasswordType_.c_attributes.copy()
    c_child_order = RestrictedPasswordType_.c_child_order[:]
    c_cardinality = RestrictedPasswordType_.c_cardinality.copy()


def restricted_password_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPassword, xml_string)


class ActivationPinType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationPinType element """

    c_tag = 'ActivationPinType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ActivationLimit'] = (
        'activation_limit', ActivationLimit)
    c_cardinality['activation_limit'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['length', 'alphabet', 'generation', 'activation_limit', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 activation_limit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.activation_limit = activation_limit
        self.extension = extension or []


def activation_pin_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPinType_, xml_string)


class SecurityAuditType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SecurityAuditType element """

    c_tag = 'SecurityAuditType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}SwitchAudit'] = (
        'switch_audit', SwitchAudit)
    c_cardinality['switch_audit'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['switch_audit', 'extension'])

    def __init__(self,
                 switch_audit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.switch_audit = switch_audit
        self.extension = extension or []


def security_audit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAuditType_, xml_string)


class AuthenticatorBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AuthenticatorBaseType element """

    c_tag = 'AuthenticatorBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}RestrictedPassword'] = (

        'restricted_password', RestrictedPassword)
    c_child_order.extend(['restricted_password'])

    def __init__(self,
                 restricted_password=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.restricted_password = restricted_password


def authenticator_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorBaseType_,
                                              xml_string)


class Identification(IdentificationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Identification element """

    c_tag = 'Identification'
    c_namespace = NAMESPACE
    c_children = IdentificationType_.c_children.copy()
    c_attributes = IdentificationType_.c_attributes.copy()
    c_child_order = IdentificationType_.c_child_order[:]
    c_cardinality = IdentificationType_.c_cardinality.copy()


def identification_from_string(xml_string):
    return saml2.create_class_from_xml_string(Identification, xml_string)


class ActivationPin(ActivationPinType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ActivationPin element """

    c_tag = 'ActivationPin'
    c_namespace = NAMESPACE
    c_children = ActivationPinType_.c_children.copy()
    c_attributes = ActivationPinType_.c_attributes.copy()
    c_child_order = ActivationPinType_.c_child_order[:]
    c_cardinality = ActivationPinType_.c_cardinality.copy()


def activation_pin_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPin, xml_string)


class Authenticator(AuthenticatorBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:Authenticator element """

    c_tag = 'Authenticator'
    c_namespace = NAMESPACE
    c_children = AuthenticatorBaseType_.c_children.copy()
    c_attributes = AuthenticatorBaseType_.c_attributes.copy()
    c_child_order = AuthenticatorBaseType_.c_child_order[:]
    c_cardinality = AuthenticatorBaseType_.c_cardinality.copy()


def authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(Authenticator, xml_string)


class AuthenticatorTransportProtocol(AuthenticatorTransportProtocolType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AuthenticatorTransportProtocol element """

    c_tag = 'AuthenticatorTransportProtocol'
    c_namespace = NAMESPACE
    c_children = AuthenticatorTransportProtocolType_.c_children.copy()
    c_attributes = AuthenticatorTransportProtocolType_.c_attributes.copy()
    c_child_order = AuthenticatorTransportProtocolType_.c_child_order[:]
    c_cardinality = AuthenticatorTransportProtocolType_.c_cardinality.copy()


def authenticator_transport_protocol_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorTransportProtocol,
                                              xml_string)


class SecurityAudit(SecurityAuditType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SecurityAudit element """

    c_tag = 'SecurityAudit'
    c_namespace = NAMESPACE
    c_children = SecurityAuditType_.c_children.copy()
    c_attributes = SecurityAuditType_.c_attributes.copy()
    c_child_order = SecurityAuditType_.c_child_order[:]
    c_cardinality = SecurityAuditType_.c_cardinality.copy()


def security_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAudit, xml_string)


class OperationalProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:OperationalProtectionType element """

    c_tag = 'OperationalProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}SecurityAudit'] = (
        'security_audit', SecurityAudit)
    c_cardinality['security_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}DeactivationCallCenter'] = (
        'deactivation_call_center', DeactivationCallCenter)
    c_cardinality['deactivation_call_center'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['security_audit', 'deactivation_call_center', 'extension'])

    def __init__(self,
                 security_audit=None,
                 deactivation_call_center=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.security_audit = security_audit
        self.deactivation_call_center = deactivation_call_center
        self.extension = extension or []


def operational_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtectionType_,
                                              xml_string)


class PrincipalAuthenticationMechanismType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PrincipalAuthenticationMechanismType element """

    c_tag = 'PrincipalAuthenticationMechanismType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Token'] = (
        'token', Token)
    c_cardinality['token'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Smartcard'] = (
        'smartcard', Smartcard)
    c_cardinality['smartcard'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['preauth'] = ('preauth', 'integer', False)
    c_child_order.extend(
        ['password', 'restricted_password', 'token', 'smartcard',
         'activation_pin', 'extension'])

    def __init__(self,
                 password=None,
                 restricted_password=None,
                 token=None,
                 smartcard=None,
                 activation_pin=None,
                 extension=None,
                 preauth=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.password = password
        self.restricted_password = restricted_password
        self.token = token
        self.smartcard = smartcard
        self.activation_pin = activation_pin
        self.extension = extension or []
        self.preauth = preauth


def principal_authentication_mechanism_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        PrincipalAuthenticationMechanismType_, xml_string)


class KeyActivationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:KeyActivationType element """

    c_tag = 'KeyActivationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['activation_pin', 'extension'])

    def __init__(self,
                 activation_pin=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_pin = activation_pin
        self.extension = extension or []


def key_activation_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivationType_, xml_string)


class KeyActivation(KeyActivationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:KeyActivation element """

    c_tag = 'KeyActivation'
    c_namespace = NAMESPACE
    c_children = KeyActivationType_.c_children.copy()
    c_attributes = KeyActivationType_.c_attributes.copy()
    c_child_order = KeyActivationType_.c_child_order[:]
    c_cardinality = KeyActivationType_.c_cardinality.copy()


def key_activation_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivation, xml_string)


class PrincipalAuthenticationMechanism(PrincipalAuthenticationMechanismType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PrincipalAuthenticationMechanism element """

    c_tag = 'PrincipalAuthenticationMechanism'
    c_namespace = NAMESPACE
    c_children = PrincipalAuthenticationMechanismType_.c_children.copy()
    c_attributes = PrincipalAuthenticationMechanismType_.c_attributes.copy()
    c_child_order = PrincipalAuthenticationMechanismType_.c_child_order[:]
    c_cardinality = PrincipalAuthenticationMechanismType_.c_cardinality.copy()


def principal_authentication_mechanism_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrincipalAuthenticationMechanism,
                                              xml_string)


class OperationalProtection(OperationalProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:OperationalProtection element """

    c_tag = 'OperationalProtection'
    c_namespace = NAMESPACE
    c_children = OperationalProtectionType_.c_children.copy()
    c_attributes = OperationalProtectionType_.c_attributes.copy()
    c_child_order = OperationalProtectionType_.c_child_order[:]
    c_cardinality = OperationalProtectionType_.c_cardinality.copy()


def operational_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtection, xml_string)


class PrivateKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PrivateKeyProtectionType element """

    c_tag = 'PrivateKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}KeySharing'] = (
        'key_sharing', KeySharing)
    c_cardinality['key_sharing'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['key_activation', 'key_storage', 'key_sharing', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 key_sharing=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.key_sharing = key_sharing
        self.extension = extension or []


def private_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtectionType_,
                                              xml_string)


class SecretKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SecretKeyProtectionType element """

    c_tag = 'SecretKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['key_activation', 'key_storage', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.extension = extension or []


def secret_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtectionType_,
                                              xml_string)


class AuthnMethodBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AuthnMethodBaseType element """

    c_tag = 'AuthnMethodBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}PrincipalAuthenticationMechanism'] = (

        'principal_authentication_mechanism', PrincipalAuthenticationMechanism)
    c_cardinality['principal_authentication_mechanism'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Authenticator'] = (
        'authenticator', Authenticator)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}AuthenticatorTransportProtocol'] = (
        'authenticator_transport_protocol', AuthenticatorTransportProtocol)
    c_cardinality['authenticator_transport_protocol'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['principal_authentication_mechanism', 'authenticator',
                          'authenticator_transport_protocol', 'extension'])

    def __init__(self,
                 principal_authentication_mechanism=None,
                 authenticator=None,
                 authenticator_transport_protocol=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.principal_authentication_mechanism = principal_authentication_mechanism
        self.authenticator = authenticator
        self.authenticator_transport_protocol = authenticator_transport_protocol
        self.extension = extension or []


def authn_method_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethodBaseType_, xml_string)


class SecretKeyProtection(SecretKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:SecretKeyProtection element """

    c_tag = 'SecretKeyProtection'
    c_namespace = NAMESPACE
    c_children = SecretKeyProtectionType_.c_children.copy()
    c_attributes = SecretKeyProtectionType_.c_attributes.copy()
    c_child_order = SecretKeyProtectionType_.c_child_order[:]
    c_cardinality = SecretKeyProtectionType_.c_cardinality.copy()


def secret_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtection, xml_string)


class PrivateKeyProtection(PrivateKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:PrivateKeyProtection element """

    c_tag = 'PrivateKeyProtection'
    c_namespace = NAMESPACE
    c_children = PrivateKeyProtectionType_.c_children.copy()
    c_attributes = PrivateKeyProtectionType_.c_attributes.copy()
    c_child_order = PrivateKeyProtectionType_.c_child_order[:]
    c_cardinality = PrivateKeyProtectionType_.c_cardinality.copy()


def private_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtection, xml_string)


class AuthnMethod(AuthnMethodBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AuthnMethod element """

    c_tag = 'AuthnMethod'
    c_namespace = NAMESPACE
    c_children = AuthnMethodBaseType_.c_children.copy()
    c_attributes = AuthnMethodBaseType_.c_attributes.copy()
    c_child_order = AuthnMethodBaseType_.c_child_order[:]
    c_cardinality = AuthnMethodBaseType_.c_cardinality.copy()


def authn_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethod, xml_string)


class TechnicalProtectionBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:TechnicalProtectionBaseType element """

    c_tag = 'TechnicalProtectionBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}PrivateKeyProtection'] = (
        'private_key_protection', PrivateKeyProtection)
    c_cardinality['private_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}SecretKeyProtection'] = (
        'secret_key_protection', SecretKeyProtection)
    c_cardinality['secret_key_protection'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['private_key_protection', 'secret_key_protection', 'extension'])

    def __init__(self,
                 private_key_protection=None,
                 secret_key_protection=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.private_key_protection = private_key_protection
        self.secret_key_protection = secret_key_protection
        self.extension = extension or []


def technical_protection_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtectionBaseType_,
                                              xml_string)


class TechnicalProtection(TechnicalProtectionBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:TechnicalProtection element """

    c_tag = 'TechnicalProtection'
    c_namespace = NAMESPACE
    c_children = TechnicalProtectionBaseType_.c_children.copy()
    c_attributes = TechnicalProtectionBaseType_.c_attributes.copy()
    c_child_order = TechnicalProtectionBaseType_.c_child_order[:]
    c_cardinality = TechnicalProtectionBaseType_.c_cardinality.copy()


def technical_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtection, xml_string)


class AuthnContextDeclarationBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AuthnContextDeclarationBaseType element """

    c_tag = 'AuthnContextDeclarationBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Identification'] = (
        'identification', Identification)
    c_cardinality['identification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}TechnicalProtection'] = (
        'technical_protection', TechnicalProtection)
    c_cardinality['technical_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}OperationalProtection'] = (
        'operational_protection', OperationalProtection)
    c_cardinality['operational_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}AuthnMethod'] = (
        'authn_method', AuthnMethod)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ID'] = ('id', 'ID', False)
    c_child_order.extend(
        ['identification', 'technical_protection', 'operational_protection',
         'authn_method', 'governing_agreements', 'extension'])

    def __init__(self,
                 identification=None,
                 technical_protection=None,
                 operational_protection=None,
                 authn_method=None,
                 governing_agreements=None,
                 extension=None,
                 id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.identification = identification
        self.technical_protection = technical_protection
        self.operational_protection = operational_protection
        self.authn_method = authn_method
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.id = id


def authn_context_declaration_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextDeclarationBaseType_,
                                              xml_string)


class AuthenticationContextDeclaration(AuthnContextDeclarationBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:AuthenticationContextDeclaration element """

    c_tag = 'AuthenticationContextDeclaration'
    c_namespace = NAMESPACE
    c_children = AuthnContextDeclarationBaseType_.c_children.copy()
    c_attributes = AuthnContextDeclarationBaseType_.c_attributes.copy()
    c_child_order = AuthnContextDeclarationBaseType_.c_child_order[:]
    c_cardinality = AuthnContextDeclarationBaseType_.c_cardinality.copy()


def authentication_context_declaration_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticationContextDeclaration,
                                              xml_string)


#..................
# ['ComplexAuthenticator', 'ComplexAuthenticatorType']
class ComplexAuthenticatorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ComplexAuthenticatorType element """

    c_tag = 'ComplexAuthenticatorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}PreviousSession'] = (
        'previous_session', PreviousSession)
    c_cardinality['previous_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ResumeSession'] = (
        'resume_session', ResumeSession)
    c_cardinality['resume_session'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}DigSig'] = (
        'dig_sig', DigSig)
    c_cardinality['dig_sig'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}RestrictedPassword' \
        ''] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ZeroKnowledge'] = (
        'zero_knowledge', ZeroKnowledge)
    c_cardinality['zero_knowledge'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}SharedSecretChallengeResponse'] = (
        'shared_secret_challenge_response', SharedSecretChallengeResponse)
    c_cardinality['shared_secret_challenge_response'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}SharedSecretDynamicPlaintext'] = (
        'shared_secret_dynamic_plaintext', SharedSecretDynamicPlaintext)
    c_cardinality['shared_secret_dynamic_plaintext'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}IPAddress'] = (
        'ip_address', IPAddress)
    c_cardinality['ip_address'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}AsymmetricDecryption'] = (
        'asymmetric_decryption', AsymmetricDecryption)
    c_cardinality['asymmetric_decryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}AsymmetricKeyAgreement'] = (
        'asymmetric_key_agreement', AsymmetricKeyAgreement)
    c_cardinality['asymmetric_key_agreement'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}SubscriberLineNumber'] = (
        'subscriber_line_number', SubscriberLineNumber)
    c_cardinality['subscriber_line_number'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}UserSuffix'] = (
        'user_suffix', UserSuffix)
    c_cardinality['user_suffix'] = {"min": 0, "max": 1}
    c_cardinality['complex_authenticator'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['previous_session', 'resume_session', 'dig_sig', 'password',
         'restricted_password', 'zero_knowledge',
         'shared_secret_challenge_response', 'shared_secret_dynamic_plaintext',
         'ip_address', 'asymmetric_decryption', 'asymmetric_key_agreement',
         'subscriber_line_number', 'user_suffix', 'complex_authenticator',
         'extension'])

    def __init__(self,
                 previous_session=None,
                 resume_session=None,
                 dig_sig=None,
                 password=None,
                 restricted_password=None,
                 zero_knowledge=None,
                 shared_secret_challenge_response=None,
                 shared_secret_dynamic_plaintext=None,
                 ip_address=None,
                 asymmetric_decryption=None,
                 asymmetric_key_agreement=None,
                 subscriber_line_number=None,
                 user_suffix=None,
                 complex_authenticator=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.previous_session = previous_session
        self.resume_session = resume_session
        self.dig_sig = dig_sig
        self.password = password
        self.restricted_password = restricted_password
        self.zero_knowledge = zero_knowledge
        self.shared_secret_challenge_response = shared_secret_challenge_response
        self.shared_secret_dynamic_plaintext = shared_secret_dynamic_plaintext
        self.ip_address = ip_address
        self.asymmetric_decryption = asymmetric_decryption
        self.asymmetric_key_agreement = asymmetric_key_agreement
        self.subscriber_line_number = subscriber_line_number
        self.user_suffix = user_suffix
        self.complex_authenticator = complex_authenticator
        self.extension = extension or []


def complex_authenticator_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticatorType_,
                                              xml_string)


class ComplexAuthenticator(ComplexAuthenticatorType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:Password:ComplexAuthenticator element """

    c_tag = 'ComplexAuthenticator'
    c_namespace = NAMESPACE
    c_children = ComplexAuthenticatorType_.c_children.copy()
    c_attributes = ComplexAuthenticatorType_.c_attributes.copy()
    c_child_order = ComplexAuthenticatorType_.c_child_order[:]
    c_cardinality = ComplexAuthenticatorType_.c_cardinality.copy()


def complex_authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticator, xml_string)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ComplexAuthenticatorType_.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
ComplexAuthenticator.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:Password}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ELEMENT_FROM_STRING = {
    AuthenticationContextDeclaration.c_tag: authentication_context_declaration_from_string,
    Identification.c_tag: identification_from_string,
    PhysicalVerification.c_tag: physical_verification_from_string,
    WrittenConsent.c_tag: written_consent_from_string,
    TechnicalProtection.c_tag: technical_protection_from_string,
    SecretKeyProtection.c_tag: secret_key_protection_from_string,
    PrivateKeyProtection.c_tag: private_key_protection_from_string,
    KeyActivation.c_tag: key_activation_from_string,
    KeySharing.c_tag: key_sharing_from_string,
    KeyStorage.c_tag: key_storage_from_string,
    SubscriberLineNumber.c_tag: subscriber_line_number_from_string,
    UserSuffix.c_tag: user_suffix_from_string,
    Password.c_tag: password_from_string,
    ActivationPin.c_tag: activation_pin_from_string,
    Token.c_tag: token_from_string,
    TimeSyncToken.c_tag: time_sync_token_from_string,
    Smartcard.c_tag: smartcard_from_string,
    Length.c_tag: length_from_string,
    ActivationLimit.c_tag: activation_limit_from_string,
    Generation.c_tag: generation_from_string,
    AuthnMethod.c_tag: authn_method_from_string,
    PrincipalAuthenticationMechanism.c_tag: principal_authentication_mechanism_from_string,
    Authenticator.c_tag: authenticator_from_string,
    ComplexAuthenticator.c_tag: complex_authenticator_from_string,
    PreviousSession.c_tag: previous_session_from_string,
    ResumeSession.c_tag: resume_session_from_string,
    ZeroKnowledge.c_tag: zero_knowledge_from_string,
    SharedSecretChallengeResponse.c_tag: shared_secret_challenge_response_from_string,
    SharedSecretChallengeResponseType_.c_tag: shared_secret_challenge_response_type__from_string,
    DigSig.c_tag: dig_sig_from_string,
    AsymmetricDecryption.c_tag: asymmetric_decryption_from_string,
    AsymmetricKeyAgreement.c_tag: asymmetric_key_agreement_from_string,
    PublicKeyType_.c_tag: public_key_type__from_string,
    IPAddress.c_tag: ip_address_from_string,
    SharedSecretDynamicPlaintext.c_tag: shared_secret_dynamic_plaintext_from_string,
    AuthenticatorTransportProtocol.c_tag: authenticator_transport_protocol_from_string,
    HTTP.c_tag: http_from_string,
    IPSec.c_tag: ip_sec_from_string,
    WTLS.c_tag: wtls_from_string,
    MobileNetworkNoEncryption.c_tag: mobile_network_no_encryption_from_string,
    MobileNetworkRadioEncryption.c_tag: mobile_network_radio_encryption_from_string,
    MobileNetworkEndToEndEncryption.c_tag: mobile_network_end_to_end_encryption_from_string,
    SSL.c_tag: ssl_from_string,
    PSTN.c_tag: pstn_from_string,
    ISDN.c_tag: isdn_from_string,
    ADSL.c_tag: adsl_from_string,
    OperationalProtection.c_tag: operational_protection_from_string,
    SecurityAudit.c_tag: security_audit_from_string,
    SwitchAudit.c_tag: switch_audit_from_string,
    DeactivationCallCenter.c_tag: deactivation_call_center_from_string,
    GoverningAgreements.c_tag: governing_agreements_from_string,
    GoverningAgreementRef.c_tag: governing_agreement_ref_from_string,
    NymType_.c_tag: nym_type__from_string,
    IdentificationType_.c_tag: identification_type__from_string,
    TechnicalProtectionBaseType_.c_tag: technical_protection_base_type__from_string,
    OperationalProtectionType_.c_tag: operational_protection_type__from_string,
    GoverningAgreementsType_.c_tag: governing_agreements_type__from_string,
    GoverningAgreementRefType_.c_tag: governing_agreement_ref_type__from_string,
    PrincipalAuthenticationMechanismType_.c_tag: principal_authentication_mechanism_type__from_string,
    ComplexAuthenticatorType_.c_tag: complex_authenticator_type__from_string,
    AuthenticatorTransportProtocolType_.c_tag: authenticator_transport_protocol_type__from_string,
    KeyActivationType_.c_tag: key_activation_type__from_string,
    KeySharingType_.c_tag: key_sharing_type__from_string,
    PrivateKeyProtectionType_.c_tag: private_key_protection_type__from_string,
    PasswordType_.c_tag: password_type__from_string,
    RestrictedPassword.c_tag: restricted_password_from_string,
    RestrictedPasswordType_.c_tag: restricted_password_type__from_string,
    RestrictedLengthType_.c_tag: restricted_length_type__from_string,
    ActivationPinType_.c_tag: activation_pin_type__from_string,
    Alphabet.c_tag: alphabet_from_string,
    AlphabetType_.c_tag: alphabet_type__from_string,
    TokenType_.c_tag: token_type__from_string,
    DeviceTypeType_.c_tag: device_type_type__from_string,
    BooleanType_.c_tag: boolean_type__from_string,
    TimeSyncTokenType_.c_tag: time_sync_token_type__from_string,
    ActivationLimitType_.c_tag: activation_limit_type__from_string,
    ActivationLimitDuration.c_tag: activation_limit_duration_from_string,
    ActivationLimitUsages.c_tag: activation_limit_usages_from_string,
    ActivationLimitSession.c_tag: activation_limit_session_from_string,
    ActivationLimitDurationType_.c_tag: activation_limit_duration_type__from_string,
    ActivationLimitUsagesType_.c_tag: activation_limit_usages_type__from_string,
    ActivationLimitSessionType_.c_tag: activation_limit_session_type__from_string,
    LengthType_.c_tag: length_type__from_string,
    MediumType_.c_tag: medium_type__from_string,
    KeyStorageType_.c_tag: key_storage_type__from_string,
    SecretKeyProtectionType_.c_tag: secret_key_protection_type__from_string,
    SecurityAuditType_.c_tag: security_audit_type__from_string,
    ExtensionOnlyType_.c_tag: extension_only_type__from_string,
    Extension.c_tag: extension_from_string,
    ExtensionType_.c_tag: extension_type__from_string,
    AuthnContextDeclarationBaseType_.c_tag: authn_context_declaration_base_type__from_string,
    AuthnMethodBaseType_.c_tag: authn_method_base_type__from_string,
    AuthenticatorBaseType_.c_tag: authenticator_base_type__from_string,
}

ELEMENT_BY_TAG = {
    'AuthenticationContextDeclaration': AuthenticationContextDeclaration,
    'Identification': Identification,
    'PhysicalVerification': PhysicalVerification,
    'WrittenConsent': WrittenConsent,
    'TechnicalProtection': TechnicalProtection,
    'SecretKeyProtection': SecretKeyProtection,
    'PrivateKeyProtection': PrivateKeyProtection,
    'KeyActivation': KeyActivation,
    'KeySharing': KeySharing,
    'KeyStorage': KeyStorage,
    'SubscriberLineNumber': SubscriberLineNumber,
    'UserSuffix': UserSuffix,
    'Password': Password,
    'ActivationPin': ActivationPin,
    'Token': Token,
    'TimeSyncToken': TimeSyncToken,
    'Smartcard': Smartcard,
    'Length': Length,
    'ActivationLimit': ActivationLimit,
    'Generation': Generation,
    'AuthnMethod': AuthnMethod,
    'PrincipalAuthenticationMechanism': PrincipalAuthenticationMechanism,
    'Authenticator': Authenticator,
    'ComplexAuthenticator': ComplexAuthenticator,
    'PreviousSession': PreviousSession,
    'ResumeSession': ResumeSession,
    'ZeroKnowledge': ZeroKnowledge,
    'SharedSecretChallengeResponse': SharedSecretChallengeResponse,
    'SharedSecretChallengeResponseType': SharedSecretChallengeResponseType_,
    'DigSig': DigSig,
    'AsymmetricDecryption': AsymmetricDecryption,
    'AsymmetricKeyAgreement': AsymmetricKeyAgreement,
    'PublicKeyType': PublicKeyType_,
    'IPAddress': IPAddress,
    'SharedSecretDynamicPlaintext': SharedSecretDynamicPlaintext,
    'AuthenticatorTransportProtocol': AuthenticatorTransportProtocol,
    'HTTP': HTTP,
    'IPSec': IPSec,
    'WTLS': WTLS,
    'MobileNetworkNoEncryption': MobileNetworkNoEncryption,
    'MobileNetworkRadioEncryption': MobileNetworkRadioEncryption,
    'MobileNetworkEndToEndEncryption': MobileNetworkEndToEndEncryption,
    'SSL': SSL,
    'PSTN': PSTN,
    'ISDN': ISDN,
    'ADSL': ADSL,
    'OperationalProtection': OperationalProtection,
    'SecurityAudit': SecurityAudit,
    'SwitchAudit': SwitchAudit,
    'DeactivationCallCenter': DeactivationCallCenter,
    'GoverningAgreements': GoverningAgreements,
    'GoverningAgreementRef': GoverningAgreementRef,
    'nymType': NymType_,
    'IdentificationType': IdentificationType_,
    'TechnicalProtectionBaseType': TechnicalProtectionBaseType_,
    'OperationalProtectionType': OperationalProtectionType_,
    'GoverningAgreementsType': GoverningAgreementsType_,
    'GoverningAgreementRefType': GoverningAgreementRefType_,
    'PrincipalAuthenticationMechanismType': PrincipalAuthenticationMechanismType_,
    'ComplexAuthenticatorType': ComplexAuthenticatorType_,
    'AuthenticatorTransportProtocolType': AuthenticatorTransportProtocolType_,
    'KeyActivationType': KeyActivationType_,
    'KeySharingType': KeySharingType_,
    'PrivateKeyProtectionType': PrivateKeyProtectionType_,
    'PasswordType': PasswordType_,
    'RestrictedPassword': RestrictedPassword,
    'RestrictedPasswordType': RestrictedPasswordType_,
    'RestrictedLengthType': RestrictedLengthType_,
    'ActivationPinType': ActivationPinType_,
    'Alphabet': Alphabet,
    'AlphabetType': AlphabetType_,
    'TokenType': TokenType_,
    'DeviceTypeType': DeviceTypeType_,
    'booleanType': BooleanType_,
    'TimeSyncTokenType': TimeSyncTokenType_,
    'ActivationLimitType': ActivationLimitType_,
    'ActivationLimitDuration': ActivationLimitDuration,
    'ActivationLimitUsages': ActivationLimitUsages,
    'ActivationLimitSession': ActivationLimitSession,
    'ActivationLimitDurationType': ActivationLimitDurationType_,
    'ActivationLimitUsagesType': ActivationLimitUsagesType_,
    'ActivationLimitSessionType': ActivationLimitSessionType_,
    'LengthType': LengthType_,
    'mediumType': MediumType_,
    'KeyStorageType': KeyStorageType_,
    'SecretKeyProtectionType': SecretKeyProtectionType_,
    'SecurityAuditType': SecurityAuditType_,
    'ExtensionOnlyType': ExtensionOnlyType_,
    'Extension': Extension,
    'ExtensionType': ExtensionType_,
    'AuthnContextDeclarationBaseType': AuthnContextDeclarationBaseType_,
    'AuthnMethodBaseType': AuthnMethodBaseType_,
    'AuthenticatorBaseType': AuthenticatorBaseType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = sslcert
#!/usr/bin/env python

#
# Generated Sun Apr 21 10:44:16 2013 by parse_xsd.py version 0.5.
#

"""
This class indicates that the principal authenticated by means of a client
certificate, secured with the SSL/TLS transport.
"""

import saml2
from saml2 import SamlBase


NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient'


class PhysicalVerification(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PhysicalVerification element """

    c_tag = 'PhysicalVerification'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['credentialLevel'] = ('credential_level', 'None', False)

    def __init__(self,
                 credential_level=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.credential_level = credential_level


def physical_verification_from_string(xml_string):
    return saml2.create_class_from_xml_string(PhysicalVerification, xml_string)


class Generation(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Generation element """

    c_tag = 'Generation'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['mechanism'] = ('mechanism', 'None', True)

    def __init__(self,
                 mechanism=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.mechanism = mechanism


def generation_from_string(xml_string):
    return saml2.create_class_from_xml_string(Generation, xml_string)


class NymType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:nymType element """

    c_tag = 'nymType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['anonymity', 'verinymity', 'pseudonymity']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def nym_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NymType_, xml_string)


class GoverningAgreementRefType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:GoverningAgreementRefType element """

    c_tag = 'GoverningAgreementRefType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['governingAgreementRef'] = (
        'governing_agreement_ref', 'anyURI', True)

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref


def governing_agreement_ref_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRefType_,
                                              xml_string)


class KeySharingType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:KeySharingType element """

    c_tag = 'KeySharingType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['sharing'] = ('sharing', 'boolean', True)

    def __init__(self,
                 sharing=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.sharing = sharing


def key_sharing_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharingType_, xml_string)


class RestrictedLengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:RestrictedLengthType element """

    c_tag = 'RestrictedLengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'None', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def restricted_length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedLengthType_, xml_string)


class AlphabetType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AlphabetType element """

    c_tag = 'AlphabetType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['requiredChars'] = ('required_chars', 'string', True)
    c_attributes['excludedChars'] = ('excluded_chars', 'string', False)
    c_attributes['case'] = ('case', 'string', False)

    def __init__(self,
                 required_chars=None,
                 excluded_chars=None,
                 case=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.required_chars = required_chars
        self.excluded_chars = excluded_chars
        self.case = case


def alphabet_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AlphabetType_, xml_string)


class DeviceTypeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:DeviceTypeType element """

    c_tag = 'DeviceTypeType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['hardware', 'software']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def device_type_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DeviceTypeType_, xml_string)


class BooleanType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:booleanType element """

    c_tag = 'booleanType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN', 'enumeration': ['true', 'false']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def boolean_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(BooleanType_, xml_string)


class TimeSyncTokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:TimeSyncTokenType element """

    c_tag = 'TimeSyncTokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['DeviceType'] = ('device_type', DeviceTypeType_, True)
    c_attributes['SeedLength'] = ('seed_length', 'integer', True)
    c_attributes['DeviceInHand'] = ('device_in_hand', BooleanType_, True)

    def __init__(self,
                 device_type=None,
                 seed_length=None,
                 device_in_hand=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.device_type = device_type
        self.seed_length = seed_length
        self.device_in_hand = device_in_hand


def time_sync_token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncTokenType_, xml_string)


class ActivationLimitDurationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationLimitDurationType element """

    c_tag = 'ActivationLimitDurationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['duration'] = ('duration', 'duration', True)

    def __init__(self,
                 duration=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.duration = duration


def activation_limit_duration_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDurationType_,
                                              xml_string)


class ActivationLimitUsagesType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationLimitUsagesType element """

    c_tag = 'ActivationLimitUsagesType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['number'] = ('number', 'integer', True)

    def __init__(self,
                 number=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.number = number


def activation_limit_usages_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsagesType_,
                                              xml_string)


class ActivationLimitSessionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationLimitSessionType element """

    c_tag = 'ActivationLimitSessionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def activation_limit_session_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSessionType_,
                                              xml_string)


class LengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:LengthType element """

    c_tag = 'LengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'integer', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.min = min
        self.max = max


def length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LengthType_, xml_string)


class MediumType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:mediumType element """

    c_tag = 'mediumType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['memory', 'smartcard', 'token',
                                    'MobileDevice', 'MobileAuthCard']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def medium_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(MediumType_, xml_string)


class KeyStorageType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:KeyStorageType element """

    c_tag = 'KeyStorageType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['medium'] = ('medium', MediumType_, True)

    def __init__(self,
                 medium=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.medium = medium


def key_storage_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorageType_, xml_string)


class ExtensionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ExtensionType element """

    c_tag = 'ExtensionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def extension_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionType_, xml_string)


class PublicKeyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PublicKeyType element """

    c_tag = 'PublicKeyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['keyValidation'] = ('key_validation', 'anyURI', False)

    def __init__(self,
                 key_validation="urn:oasis:names:tc:SAML:2.0:ac:classes:X509",
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)


def public_key_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicKeyType_, xml_string)


class KeySharing(KeySharingType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:KeySharing element """

    c_tag = 'KeySharing'
    c_namespace = NAMESPACE
    c_children = KeySharingType_.c_children.copy()
    c_attributes = KeySharingType_.c_attributes.copy()
    c_child_order = KeySharingType_.c_child_order[:]
    c_cardinality = KeySharingType_.c_cardinality.copy()


def key_sharing_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharing, xml_string)


class KeyStorage(KeyStorageType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:KeyStorage element """

    c_tag = 'KeyStorage'
    c_namespace = NAMESPACE
    c_children = KeyStorageType_.c_children.copy()
    c_attributes = KeyStorageType_.c_attributes.copy()
    c_child_order = KeyStorageType_.c_child_order[:]
    c_cardinality = KeyStorageType_.c_cardinality.copy()


def key_storage_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorage, xml_string)


class TimeSyncToken(TimeSyncTokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:TimeSyncToken element """

    c_tag = 'TimeSyncToken'
    c_namespace = NAMESPACE
    c_children = TimeSyncTokenType_.c_children.copy()
    c_attributes = TimeSyncTokenType_.c_attributes.copy()
    c_child_order = TimeSyncTokenType_.c_child_order[:]
    c_cardinality = TimeSyncTokenType_.c_cardinality.copy()


def time_sync_token_from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncToken, xml_string)


class Length(LengthType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Length element """

    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = LengthType_.c_children.copy()
    c_attributes = LengthType_.c_attributes.copy()
    c_child_order = LengthType_.c_child_order[:]
    c_cardinality = LengthType_.c_cardinality.copy()


def length_from_string(xml_string):
    return saml2.create_class_from_xml_string(Length, xml_string)


class DigSig(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:DigSig element """

    c_tag = 'DigSig'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def dig_sig_from_string(xml_string):
    return saml2.create_class_from_xml_string(DigSig, xml_string)


class AsymmetricDecryption(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AsymmetricDecryption element """

    c_tag = 'AsymmetricDecryption'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_decryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricDecryption, xml_string)


class AsymmetricKeyAgreement(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AsymmetricKeyAgreement element """

    c_tag = 'AsymmetricKeyAgreement'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_key_agreement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricKeyAgreement,
                                              xml_string)


class GoverningAgreementRef(GoverningAgreementRefType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:GoverningAgreementRef element """

    c_tag = 'GoverningAgreementRef'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementRefType_.c_children.copy()
    c_attributes = GoverningAgreementRefType_.c_attributes.copy()
    c_child_order = GoverningAgreementRefType_.c_child_order[:]
    c_cardinality = GoverningAgreementRefType_.c_cardinality.copy()


def governing_agreement_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRef, xml_string)


class GoverningAgreementsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:GoverningAgreementsType element """

    c_tag = 'GoverningAgreementsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}GoverningAgreementRef'] = (
        'governing_agreement_ref', [GoverningAgreementRef])
    c_cardinality['governing_agreement_ref'] = {"min": 1}
    c_child_order.extend(['governing_agreement_ref'])

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref or []


def governing_agreements_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementsType_,
                                              xml_string)


class RestrictedPasswordType_Length(RestrictedLengthType_):
    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = RestrictedLengthType_.c_children.copy()
    c_attributes = RestrictedLengthType_.c_attributes.copy()
    c_child_order = RestrictedLengthType_.c_child_order[:]
    c_cardinality = RestrictedLengthType_.c_cardinality.copy()


def restricted_password_type__length_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_Length,
                                              xml_string)


class Alphabet(AlphabetType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Alphabet element """

    c_tag = 'Alphabet'
    c_namespace = NAMESPACE
    c_children = AlphabetType_.c_children.copy()
    c_attributes = AlphabetType_.c_attributes.copy()
    c_child_order = AlphabetType_.c_child_order[:]
    c_cardinality = AlphabetType_.c_cardinality.copy()


def alphabet_from_string(xml_string):
    return saml2.create_class_from_xml_string(Alphabet, xml_string)


class ActivationLimitDuration(ActivationLimitDurationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationLimitDuration element """

    c_tag = 'ActivationLimitDuration'
    c_namespace = NAMESPACE
    c_children = ActivationLimitDurationType_.c_children.copy()
    c_attributes = ActivationLimitDurationType_.c_attributes.copy()
    c_child_order = ActivationLimitDurationType_.c_child_order[:]
    c_cardinality = ActivationLimitDurationType_.c_cardinality.copy()


def activation_limit_duration_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDuration,
                                              xml_string)


class ActivationLimitUsages(ActivationLimitUsagesType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationLimitUsages element """

    c_tag = 'ActivationLimitUsages'
    c_namespace = NAMESPACE
    c_children = ActivationLimitUsagesType_.c_children.copy()
    c_attributes = ActivationLimitUsagesType_.c_attributes.copy()
    c_child_order = ActivationLimitUsagesType_.c_child_order[:]
    c_cardinality = ActivationLimitUsagesType_.c_cardinality.copy()


def activation_limit_usages_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsages, xml_string)


class ActivationLimitSession(ActivationLimitSessionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationLimitSession element """

    c_tag = 'ActivationLimitSession'
    c_namespace = NAMESPACE
    c_children = ActivationLimitSessionType_.c_children.copy()
    c_attributes = ActivationLimitSessionType_.c_attributes.copy()
    c_child_order = ActivationLimitSessionType_.c_child_order[:]
    c_cardinality = ActivationLimitSessionType_.c_cardinality.copy()


def activation_limit_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSession,
                                              xml_string)


class Extension(ExtensionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Extension element """

    c_tag = 'Extension'
    c_namespace = NAMESPACE
    c_children = ExtensionType_.c_children.copy()
    c_attributes = ExtensionType_.c_attributes.copy()
    c_child_order = ExtensionType_.c_child_order[:]
    c_cardinality = ExtensionType_.c_cardinality.copy()


def extension_from_string(xml_string):
    return saml2.create_class_from_xml_string(Extension, xml_string)


class AuthenticatorBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AuthenticatorBaseType element """

    c_tag = 'AuthenticatorBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}DigSig'] = (
        'dig_sig', DigSig)
    c_child_order.extend(['dig_sig'])

    def __init__(self,
                 dig_sig=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.dig_sig = dig_sig


def authenticator_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorBaseType_,
                                              xml_string)


class Authenticator(AuthenticatorBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Authenticator element """

    c_tag = 'Authenticator'
    c_namespace = NAMESPACE
    c_children = AuthenticatorBaseType_.c_children.copy()
    c_attributes = AuthenticatorBaseType_.c_attributes.copy()
    c_child_order = AuthenticatorBaseType_.c_child_order[:]
    c_cardinality = AuthenticatorBaseType_.c_cardinality.copy()


def authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(Authenticator, xml_string)


class SharedSecretChallengeResponseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SharedSecretChallengeResponseType element """

    c_tag = 'SharedSecretChallengeResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['method'] = ('method', 'anyURI', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 method=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.method = method


def shared_secret_challenge_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        SharedSecretChallengeResponseType_, xml_string)


class GoverningAgreements(GoverningAgreementsType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:GoverningAgreements element """

    c_tag = 'GoverningAgreements'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementsType_.c_children.copy()
    c_attributes = GoverningAgreementsType_.c_attributes.copy()
    c_child_order = GoverningAgreementsType_.c_child_order[:]
    c_cardinality = GoverningAgreementsType_.c_cardinality.copy()


def governing_agreements_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreements, xml_string)


class PasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PasswordType element """

    c_tag = 'PasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'alphabet', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PasswordType_, xml_string)


class RestrictedPasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:RestrictedPasswordType element """

    c_tag = 'RestrictedPasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Length'] = (
        'length', RestrictedPasswordType_Length)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def restricted_password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_,
                                              xml_string)


class TokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:TokenType element """

    c_tag = 'TokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}TimeSyncToken'] = (
        'time_sync_token', TimeSyncToken)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['time_sync_token', 'extension'])

    def __init__(self,
                 time_sync_token=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.time_sync_token = time_sync_token
        self.extension = extension or []


def token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TokenType_, xml_string)


class ActivationLimitType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationLimitType element """

    c_tag = 'ActivationLimitType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ActivationLimitDuration'] = (
        'activation_limit_duration', ActivationLimitDuration)
    c_cardinality['activation_limit_duration'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ActivationLimitUsages'] = (
        'activation_limit_usages', ActivationLimitUsages)
    c_cardinality['activation_limit_usages'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ActivationLimitSession'] = (
        'activation_limit_session', ActivationLimitSession)
    c_cardinality['activation_limit_session'] = {"min": 0, "max": 1}
    c_child_order.extend(
        ['activation_limit_duration', 'activation_limit_usages',
         'activation_limit_session'])

    def __init__(self,
                 activation_limit_duration=None,
                 activation_limit_usages=None,
                 activation_limit_session=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_limit_duration = activation_limit_duration
        self.activation_limit_usages = activation_limit_usages
        self.activation_limit_session = activation_limit_session


def activation_limit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitType_, xml_string)


class ExtensionOnlyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ExtensionOnlyType element """

    c_tag = 'ExtensionOnlyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []


def extension_only_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionOnlyType_, xml_string)


class WrittenConsent(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:WrittenConsent element """

    c_tag = 'WrittenConsent'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def written_consent_from_string(xml_string):
    return saml2.create_class_from_xml_string(WrittenConsent, xml_string)


class SubscriberLineNumber(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SubscriberLineNumber element """

    c_tag = 'SubscriberLineNumber'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def subscriber_line_number_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubscriberLineNumber, xml_string)


class UserSuffix(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:UserSuffix element """

    c_tag = 'UserSuffix'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def user_suffix_from_string(xml_string):
    return saml2.create_class_from_xml_string(UserSuffix, xml_string)


class Password(PasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Password element """

    c_tag = 'Password'
    c_namespace = NAMESPACE
    c_children = PasswordType_.c_children.copy()
    c_attributes = PasswordType_.c_attributes.copy()
    c_child_order = PasswordType_.c_child_order[:]
    c_cardinality = PasswordType_.c_cardinality.copy()


def password_from_string(xml_string):
    return saml2.create_class_from_xml_string(Password, xml_string)


class Token(TokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Token element """

    c_tag = 'Token'
    c_namespace = NAMESPACE
    c_children = TokenType_.c_children.copy()
    c_attributes = TokenType_.c_attributes.copy()
    c_child_order = TokenType_.c_child_order[:]
    c_cardinality = TokenType_.c_cardinality.copy()


def token_from_string(xml_string):
    return saml2.create_class_from_xml_string(Token, xml_string)


class Smartcard(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Smartcard element """

    c_tag = 'Smartcard'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def smartcard_from_string(xml_string):
    return saml2.create_class_from_xml_string(Smartcard, xml_string)


class ActivationLimit(ActivationLimitType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationLimit element """

    c_tag = 'ActivationLimit'
    c_namespace = NAMESPACE
    c_children = ActivationLimitType_.c_children.copy()
    c_attributes = ActivationLimitType_.c_attributes.copy()
    c_child_order = ActivationLimitType_.c_child_order[:]
    c_cardinality = ActivationLimitType_.c_cardinality.copy()


def activation_limit_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimit, xml_string)


class PreviousSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PreviousSession element """

    c_tag = 'PreviousSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def previous_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(PreviousSession, xml_string)


class ResumeSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ResumeSession element """

    c_tag = 'ResumeSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def resume_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ResumeSession, xml_string)


class ZeroKnowledge(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ZeroKnowledge element """

    c_tag = 'ZeroKnowledge'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def zero_knowledge_from_string(xml_string):
    return saml2.create_class_from_xml_string(ZeroKnowledge, xml_string)


class SharedSecretChallengeResponse(SharedSecretChallengeResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SharedSecretChallengeResponse element """

    c_tag = 'SharedSecretChallengeResponse'
    c_namespace = NAMESPACE
    c_children = SharedSecretChallengeResponseType_.c_children.copy()
    c_attributes = SharedSecretChallengeResponseType_.c_attributes.copy()
    c_child_order = SharedSecretChallengeResponseType_.c_child_order[:]
    c_cardinality = SharedSecretChallengeResponseType_.c_cardinality.copy()


def shared_secret_challenge_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretChallengeResponse,
                                              xml_string)


class IPAddress(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:IPAddress element """

    c_tag = 'IPAddress'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_address_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPAddress, xml_string)


class SharedSecretDynamicPlaintext(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SharedSecretDynamicPlaintext element """

    c_tag = 'SharedSecretDynamicPlaintext'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def shared_secret_dynamic_plaintext_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretDynamicPlaintext,
                                              xml_string)


class HTTP(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:HTTP element """

    c_tag = 'HTTP'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def http_from_string(xml_string):
    return saml2.create_class_from_xml_string(HTTP, xml_string)


class IPSec(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:IPSec element """

    c_tag = 'IPSec'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_sec_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPSec, xml_string)


class WTLS(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:WTLS element """

    c_tag = 'WTLS'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def wtls_from_string(xml_string):
    return saml2.create_class_from_xml_string(WTLS, xml_string)


class MobileNetworkNoEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:MobileNetworkNoEncryption element """

    c_tag = 'MobileNetworkNoEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_no_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkNoEncryption,
                                              xml_string)


class MobileNetworkRadioEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:MobileNetworkRadioEncryption element """

    c_tag = 'MobileNetworkRadioEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_radio_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkRadioEncryption,
                                              xml_string)


class MobileNetworkEndToEndEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:MobileNetworkEndToEndEncryption element """

    c_tag = 'MobileNetworkEndToEndEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_end_to_end_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkEndToEndEncryption,
                                              xml_string)


class SSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SSL element """

    c_tag = 'SSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ssl_from_string(xml_string):
    return saml2.create_class_from_xml_string(SSL, xml_string)


class PSTN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PSTN element """

    c_tag = 'PSTN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def pstn_from_string(xml_string):
    return saml2.create_class_from_xml_string(PSTN, xml_string)


class ISDN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ISDN element """

    c_tag = 'ISDN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def isdn_from_string(xml_string):
    return saml2.create_class_from_xml_string(ISDN, xml_string)


class ADSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ADSL element """

    c_tag = 'ADSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def adsl_from_string(xml_string):
    return saml2.create_class_from_xml_string(ADSL, xml_string)


class SwitchAudit(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SwitchAudit element """

    c_tag = 'SwitchAudit'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def switch_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SwitchAudit, xml_string)


class DeactivationCallCenter(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:DeactivationCallCenter element """

    c_tag = 'DeactivationCallCenter'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def deactivation_call_center_from_string(xml_string):
    return saml2.create_class_from_xml_string(DeactivationCallCenter,
                                              xml_string)


class IdentificationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:IdentificationType element """

    c_tag = 'IdentificationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}PhysicalVerification'] = (
        'physical_verification', PhysicalVerification)
    c_cardinality['physical_verification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}WrittenConsent'] = (
        'written_consent', WrittenConsent)
    c_cardinality['written_consent'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['nym'] = ('nym', NymType_, False)
    c_child_order.extend(
        ['physical_verification', 'written_consent', 'governing_agreements',
         'extension'])

    def __init__(self,
                 physical_verification=None,
                 written_consent=None,
                 governing_agreements=None,
                 extension=None,
                 nym=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.physical_verification = physical_verification
        self.written_consent = written_consent
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.nym = nym


def identification_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IdentificationType_, xml_string)


class RestrictedPassword(RestrictedPasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:RestrictedPassword element """

    c_tag = 'RestrictedPassword'
    c_namespace = NAMESPACE
    c_children = RestrictedPasswordType_.c_children.copy()
    c_attributes = RestrictedPasswordType_.c_attributes.copy()
    c_child_order = RestrictedPasswordType_.c_child_order[:]
    c_cardinality = RestrictedPasswordType_.c_cardinality.copy()


def restricted_password_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPassword, xml_string)


class ActivationPinType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationPinType element """

    c_tag = 'ActivationPinType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ActivationLimit'] = (
        'activation_limit', ActivationLimit)
    c_cardinality['activation_limit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['length', 'alphabet', 'generation', 'activation_limit', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 activation_limit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.activation_limit = activation_limit
        self.extension = extension or []


def activation_pin_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPinType_, xml_string)


class SecurityAuditType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SecurityAuditType element """

    c_tag = 'SecurityAuditType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}SwitchAudit'] = (
        'switch_audit', SwitchAudit)
    c_cardinality['switch_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['switch_audit', 'extension'])

    def __init__(self,
                 switch_audit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.switch_audit = switch_audit
        self.extension = extension or []


def security_audit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAuditType_, xml_string)


class PrincipalAuthenticationMechanismType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PrincipalAuthenticationMechanismType element """

    c_tag = 'PrincipalAuthenticationMechanismType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_attributes['preauth'] = ('preauth', 'integer', False)
    c_child_order.extend(['restricted_password'])

    def __init__(self,
                 restricted_password=None,
                 preauth=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.restricted_password = restricted_password
        self.preauth = preauth


def principal_authentication_mechanism_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        PrincipalAuthenticationMechanismType_, xml_string)


class AuthenticatorTransportProtocolType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AuthenticatorTransportProtocolType element """

    c_tag = 'AuthenticatorTransportProtocolType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}SSL'] = (
        'ssl', SSL)
    c_cardinality['ssl'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}WTLS'] = (
        'wtls', WTLS)
    c_cardinality['wtls'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['ssl', 'wtls', 'extension'])

    def __init__(self,
                 ssl=None,
                 wtls=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.ssl = ssl
        self.wtls = wtls
        self.extension = extension or []


def authenticator_transport_protocol_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        AuthenticatorTransportProtocolType_, xml_string)


class Identification(IdentificationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:Identification element """

    c_tag = 'Identification'
    c_namespace = NAMESPACE
    c_children = IdentificationType_.c_children.copy()
    c_attributes = IdentificationType_.c_attributes.copy()
    c_child_order = IdentificationType_.c_child_order[:]
    c_cardinality = IdentificationType_.c_cardinality.copy()


def identification_from_string(xml_string):
    return saml2.create_class_from_xml_string(Identification, xml_string)


class ActivationPin(ActivationPinType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ActivationPin element """

    c_tag = 'ActivationPin'
    c_namespace = NAMESPACE
    c_children = ActivationPinType_.c_children.copy()
    c_attributes = ActivationPinType_.c_attributes.copy()
    c_child_order = ActivationPinType_.c_child_order[:]
    c_cardinality = ActivationPinType_.c_cardinality.copy()


def activation_pin_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPin, xml_string)


class PrincipalAuthenticationMechanism(PrincipalAuthenticationMechanismType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PrincipalAuthenticationMechanism element """

    c_tag = 'PrincipalAuthenticationMechanism'
    c_namespace = NAMESPACE
    c_children = PrincipalAuthenticationMechanismType_.c_children.copy()
    c_attributes = PrincipalAuthenticationMechanismType_.c_attributes.copy()
    c_child_order = PrincipalAuthenticationMechanismType_.c_child_order[:]
    c_cardinality = PrincipalAuthenticationMechanismType_.c_cardinality.copy()


def principal_authentication_mechanism_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrincipalAuthenticationMechanism,
                                              xml_string)


class AuthenticatorTransportProtocol(AuthenticatorTransportProtocolType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AuthenticatorTransportProtocol element """

    c_tag = 'AuthenticatorTransportProtocol'
    c_namespace = NAMESPACE
    c_children = AuthenticatorTransportProtocolType_.c_children.copy()
    c_attributes = AuthenticatorTransportProtocolType_.c_attributes.copy()
    c_child_order = AuthenticatorTransportProtocolType_.c_child_order[:]
    c_cardinality = AuthenticatorTransportProtocolType_.c_cardinality.copy()


def authenticator_transport_protocol_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorTransportProtocol,
                                              xml_string)


class SecurityAudit(SecurityAuditType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SecurityAudit element """

    c_tag = 'SecurityAudit'
    c_namespace = NAMESPACE
    c_children = SecurityAuditType_.c_children.copy()
    c_attributes = SecurityAuditType_.c_attributes.copy()
    c_child_order = SecurityAuditType_.c_child_order[:]
    c_cardinality = SecurityAuditType_.c_cardinality.copy()


def security_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAudit, xml_string)


class OperationalProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:OperationalProtectionType element """

    c_tag = 'OperationalProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}SecurityAudit'] = (
        'security_audit', SecurityAudit)
    c_cardinality['security_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}DeactivationCallCenter'] = (
        'deactivation_call_center', DeactivationCallCenter)
    c_cardinality['deactivation_call_center'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['security_audit', 'deactivation_call_center', 'extension'])

    def __init__(self,
                 security_audit=None,
                 deactivation_call_center=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.security_audit = security_audit
        self.deactivation_call_center = deactivation_call_center
        self.extension = extension or []


def operational_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtectionType_,
                                              xml_string)


class KeyActivationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:KeyActivationType element """

    c_tag = 'KeyActivationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['activation_pin', 'extension'])

    def __init__(self,
                 activation_pin=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_pin = activation_pin
        self.extension = extension or []


def key_activation_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivationType_, xml_string)


class AuthnMethodBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AuthnMethodBaseType element """

    c_tag = 'AuthnMethodBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}PrincipalAuthenticationMechanism'] = (
        'principal_authentication_mechanism', PrincipalAuthenticationMechanism)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Authenticator'] = (
        'authenticator', Authenticator)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}AuthenticatorTransportProtocol'] = (
        'authenticator_transport_protocol', AuthenticatorTransportProtocol)
    c_cardinality['authenticator_transport_protocol'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['principal_authentication_mechanism', 'authenticator',
                          'authenticator_transport_protocol', 'extension'])

    def __init__(self,
                 principal_authentication_mechanism=None,
                 authenticator=None,
                 authenticator_transport_protocol=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.principal_authentication_mechanism = principal_authentication_mechanism
        self.authenticator = authenticator
        self.authenticator_transport_protocol = authenticator_transport_protocol
        self.extension = extension or []


def authn_method_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethodBaseType_, xml_string)


class KeyActivation(KeyActivationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:KeyActivation element """

    c_tag = 'KeyActivation'
    c_namespace = NAMESPACE
    c_children = KeyActivationType_.c_children.copy()
    c_attributes = KeyActivationType_.c_attributes.copy()
    c_child_order = KeyActivationType_.c_child_order[:]
    c_cardinality = KeyActivationType_.c_cardinality.copy()


def key_activation_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivation, xml_string)


class AuthnMethod(AuthnMethodBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AuthnMethod element """

    c_tag = 'AuthnMethod'
    c_namespace = NAMESPACE
    c_children = AuthnMethodBaseType_.c_children.copy()
    c_attributes = AuthnMethodBaseType_.c_attributes.copy()
    c_child_order = AuthnMethodBaseType_.c_child_order[:]
    c_cardinality = AuthnMethodBaseType_.c_cardinality.copy()


def authn_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethod, xml_string)


class OperationalProtection(OperationalProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:OperationalProtection element """

    c_tag = 'OperationalProtection'
    c_namespace = NAMESPACE
    c_children = OperationalProtectionType_.c_children.copy()
    c_attributes = OperationalProtectionType_.c_attributes.copy()
    c_child_order = OperationalProtectionType_.c_child_order[:]
    c_cardinality = OperationalProtectionType_.c_cardinality.copy()


def operational_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtection, xml_string)


class PrivateKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PrivateKeyProtectionType element """

    c_tag = 'PrivateKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}KeySharing'] = (
        'key_sharing', KeySharing)
    c_cardinality['key_sharing'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['key_activation', 'key_storage', 'key_sharing', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 key_sharing=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.key_sharing = key_sharing
        self.extension = extension or []


def private_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtectionType_,
                                              xml_string)


class SecretKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SecretKeyProtectionType element """

    c_tag = 'SecretKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['key_activation', 'key_storage', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.extension = extension or []


def secret_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtectionType_,
                                              xml_string)


class SecretKeyProtection(SecretKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:SecretKeyProtection element """

    c_tag = 'SecretKeyProtection'
    c_namespace = NAMESPACE
    c_children = SecretKeyProtectionType_.c_children.copy()
    c_attributes = SecretKeyProtectionType_.c_attributes.copy()
    c_child_order = SecretKeyProtectionType_.c_child_order[:]
    c_cardinality = SecretKeyProtectionType_.c_cardinality.copy()


def secret_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtection, xml_string)


class PrivateKeyProtection(PrivateKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:PrivateKeyProtection element """

    c_tag = 'PrivateKeyProtection'
    c_namespace = NAMESPACE
    c_children = PrivateKeyProtectionType_.c_children.copy()
    c_attributes = PrivateKeyProtectionType_.c_attributes.copy()
    c_child_order = PrivateKeyProtectionType_.c_child_order[:]
    c_cardinality = PrivateKeyProtectionType_.c_cardinality.copy()


def private_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtection, xml_string)


class TechnicalProtectionBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:TechnicalProtectionBaseType element """

    c_tag = 'TechnicalProtectionBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}PrivateKeyProtection'] = (
        'private_key_protection', PrivateKeyProtection)
    c_cardinality['private_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}SecretKeyProtection'] = (
        'secret_key_protection', SecretKeyProtection)
    c_cardinality['secret_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['private_key_protection', 'secret_key_protection', 'extension'])

    def __init__(self,
                 private_key_protection=None,
                 secret_key_protection=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.private_key_protection = private_key_protection
        self.secret_key_protection = secret_key_protection
        self.extension = extension or []


def technical_protection_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtectionBaseType_,
                                              xml_string)


class TechnicalProtection(TechnicalProtectionBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:TechnicalProtection element """

    c_tag = 'TechnicalProtection'
    c_namespace = NAMESPACE
    c_children = TechnicalProtectionBaseType_.c_children.copy()
    c_attributes = TechnicalProtectionBaseType_.c_attributes.copy()
    c_child_order = TechnicalProtectionBaseType_.c_child_order[:]
    c_cardinality = TechnicalProtectionBaseType_.c_cardinality.copy()


def technical_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtection, xml_string)


class AuthnContextDeclarationBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AuthnContextDeclarationBaseType element """

    c_tag = 'AuthnContextDeclarationBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Identification'] = (
        'identification', Identification)
    c_cardinality['identification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}TechnicalProtection'] = (
        'technical_protection', TechnicalProtection)
    c_cardinality['technical_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}OperationalProtection'] = (
        'operational_protection', OperationalProtection)
    c_cardinality['operational_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}AuthnMethod'] = (
        'authn_method', AuthnMethod)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ID'] = ('id', 'ID', False)
    c_child_order.extend(
        ['identification', 'technical_protection', 'operational_protection',
         'authn_method', 'governing_agreements', 'extension'])

    def __init__(self,
                 identification=None,
                 technical_protection=None,
                 operational_protection=None,
                 authn_method=None,
                 governing_agreements=None,
                 extension=None,
                 id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.identification = identification
        self.technical_protection = technical_protection
        self.operational_protection = operational_protection
        self.authn_method = authn_method
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.id = id


def authn_context_declaration_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextDeclarationBaseType_,
                                              xml_string)


class AuthenticationContextDeclaration(AuthnContextDeclarationBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:AuthenticationContextDeclaration element """

    c_tag = 'AuthenticationContextDeclaration'
    c_namespace = NAMESPACE
    c_children = AuthnContextDeclarationBaseType_.c_children.copy()
    c_attributes = AuthnContextDeclarationBaseType_.c_attributes.copy()
    c_child_order = AuthnContextDeclarationBaseType_.c_child_order[:]
    c_cardinality = AuthnContextDeclarationBaseType_.c_cardinality.copy()


def authentication_context_declaration_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticationContextDeclaration,
                                              xml_string)


#..................
# ['ComplexAuthenticatorType', 'ComplexAuthenticator']
class ComplexAuthenticatorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ComplexAuthenticatorType element """

    c_tag = 'ComplexAuthenticatorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}PreviousSession'] = (
        'previous_session', PreviousSession)
    c_cardinality['previous_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ResumeSession'] = (
        'resume_session', ResumeSession)
    c_cardinality['resume_session'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}DigSig'] = (
        'dig_sig', DigSig)
    c_cardinality['dig_sig'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ZeroKnowledge'] = (
        'zero_knowledge', ZeroKnowledge)
    c_cardinality['zero_knowledge'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}SharedSecretChallengeResponse'] = (
        'shared_secret_challenge_response', SharedSecretChallengeResponse)
    c_cardinality['shared_secret_challenge_response'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}SharedSecretDynamicPlaintext'] = (
        'shared_secret_dynamic_plaintext', SharedSecretDynamicPlaintext)
    c_cardinality['shared_secret_dynamic_plaintext'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}IPAddress'] = (
        'ip_address', IPAddress)
    c_cardinality['ip_address'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}AsymmetricDecryption'] = (
        'asymmetric_decryption', AsymmetricDecryption)
    c_cardinality['asymmetric_decryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}AsymmetricKeyAgreement'] = (
        'asymmetric_key_agreement', AsymmetricKeyAgreement)
    c_cardinality['asymmetric_key_agreement'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}SubscriberLineNumber'] = (
        'subscriber_line_number', SubscriberLineNumber)
    c_cardinality['subscriber_line_number'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}UserSuffix'] = (
        'user_suffix', UserSuffix)
    c_cardinality['user_suffix'] = {"min": 0, "max": 1}
    c_cardinality['complex_authenticator'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['previous_session', 'resume_session', 'dig_sig', 'password',
         'restricted_password', 'zero_knowledge',
         'shared_secret_challenge_response', 'shared_secret_dynamic_plaintext',
         'ip_address', 'asymmetric_decryption', 'asymmetric_key_agreement',
         'subscriber_line_number', 'user_suffix', 'complex_authenticator',
         'extension'])

    def __init__(self,
                 previous_session=None,
                 resume_session=None,
                 dig_sig=None,
                 password=None,
                 restricted_password=None,
                 zero_knowledge=None,
                 shared_secret_challenge_response=None,
                 shared_secret_dynamic_plaintext=None,
                 ip_address=None,
                 asymmetric_decryption=None,
                 asymmetric_key_agreement=None,
                 subscriber_line_number=None,
                 user_suffix=None,
                 complex_authenticator=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.previous_session = previous_session
        self.resume_session = resume_session
        self.dig_sig = dig_sig
        self.password = password
        self.restricted_password = restricted_password
        self.zero_knowledge = zero_knowledge
        self.shared_secret_challenge_response = shared_secret_challenge_response
        self.shared_secret_dynamic_plaintext = shared_secret_dynamic_plaintext
        self.ip_address = ip_address
        self.asymmetric_decryption = asymmetric_decryption
        self.asymmetric_key_agreement = asymmetric_key_agreement
        self.subscriber_line_number = subscriber_line_number
        self.user_suffix = user_suffix
        self.complex_authenticator = complex_authenticator
        self.extension = extension or []


def complex_authenticator_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticatorType_,
                                              xml_string)


class ComplexAuthenticator(ComplexAuthenticatorType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient:ComplexAuthenticator element """

    c_tag = 'ComplexAuthenticator'
    c_namespace = NAMESPACE
    c_children = ComplexAuthenticatorType_.c_children.copy()
    c_attributes = ComplexAuthenticatorType_.c_attributes.copy()
    c_child_order = ComplexAuthenticatorType_.c_child_order[:]
    c_cardinality = ComplexAuthenticatorType_.c_cardinality.copy()


def complex_authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticator, xml_string)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ComplexAuthenticatorType_.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
ComplexAuthenticator.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:TLSClient}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ELEMENT_FROM_STRING = {
    AuthenticationContextDeclaration.c_tag: authentication_context_declaration_from_string,
    Identification.c_tag: identification_from_string,
    PhysicalVerification.c_tag: physical_verification_from_string,
    WrittenConsent.c_tag: written_consent_from_string,
    TechnicalProtection.c_tag: technical_protection_from_string,
    SecretKeyProtection.c_tag: secret_key_protection_from_string,
    PrivateKeyProtection.c_tag: private_key_protection_from_string,
    KeyActivation.c_tag: key_activation_from_string,
    KeySharing.c_tag: key_sharing_from_string,
    KeyStorage.c_tag: key_storage_from_string,
    SubscriberLineNumber.c_tag: subscriber_line_number_from_string,
    UserSuffix.c_tag: user_suffix_from_string,
    Password.c_tag: password_from_string,
    ActivationPin.c_tag: activation_pin_from_string,
    Token.c_tag: token_from_string,
    TimeSyncToken.c_tag: time_sync_token_from_string,
    Smartcard.c_tag: smartcard_from_string,
    Length.c_tag: length_from_string,
    ActivationLimit.c_tag: activation_limit_from_string,
    Generation.c_tag: generation_from_string,
    AuthnMethod.c_tag: authn_method_from_string,
    PrincipalAuthenticationMechanism.c_tag: principal_authentication_mechanism_from_string,
    Authenticator.c_tag: authenticator_from_string,
    ComplexAuthenticator.c_tag: complex_authenticator_from_string,
    PreviousSession.c_tag: previous_session_from_string,
    ResumeSession.c_tag: resume_session_from_string,
    ZeroKnowledge.c_tag: zero_knowledge_from_string,
    SharedSecretChallengeResponse.c_tag: shared_secret_challenge_response_from_string,
    SharedSecretChallengeResponseType_.c_tag: shared_secret_challenge_response_type__from_string,
    DigSig.c_tag: dig_sig_from_string,
    AsymmetricDecryption.c_tag: asymmetric_decryption_from_string,
    AsymmetricKeyAgreement.c_tag: asymmetric_key_agreement_from_string,
    IPAddress.c_tag: ip_address_from_string,
    SharedSecretDynamicPlaintext.c_tag: shared_secret_dynamic_plaintext_from_string,
    AuthenticatorTransportProtocol.c_tag: authenticator_transport_protocol_from_string,
    HTTP.c_tag: http_from_string,
    IPSec.c_tag: ip_sec_from_string,
    WTLS.c_tag: wtls_from_string,
    MobileNetworkNoEncryption.c_tag: mobile_network_no_encryption_from_string,
    MobileNetworkRadioEncryption.c_tag: mobile_network_radio_encryption_from_string,
    MobileNetworkEndToEndEncryption.c_tag: mobile_network_end_to_end_encryption_from_string,
    SSL.c_tag: ssl_from_string,
    PSTN.c_tag: pstn_from_string,
    ISDN.c_tag: isdn_from_string,
    ADSL.c_tag: adsl_from_string,
    OperationalProtection.c_tag: operational_protection_from_string,
    SecurityAudit.c_tag: security_audit_from_string,
    SwitchAudit.c_tag: switch_audit_from_string,
    DeactivationCallCenter.c_tag: deactivation_call_center_from_string,
    GoverningAgreements.c_tag: governing_agreements_from_string,
    GoverningAgreementRef.c_tag: governing_agreement_ref_from_string,
    NymType_.c_tag: nym_type__from_string,
    IdentificationType_.c_tag: identification_type__from_string,
    TechnicalProtectionBaseType_.c_tag: technical_protection_base_type__from_string,
    OperationalProtectionType_.c_tag: operational_protection_type__from_string,
    GoverningAgreementsType_.c_tag: governing_agreements_type__from_string,
    GoverningAgreementRefType_.c_tag: governing_agreement_ref_type__from_string,
    ComplexAuthenticatorType_.c_tag: complex_authenticator_type__from_string,
    KeyActivationType_.c_tag: key_activation_type__from_string,
    KeySharingType_.c_tag: key_sharing_type__from_string,
    PrivateKeyProtectionType_.c_tag: private_key_protection_type__from_string,
    PasswordType_.c_tag: password_type__from_string,
    RestrictedPassword.c_tag: restricted_password_from_string,
    RestrictedPasswordType_.c_tag: restricted_password_type__from_string,
    RestrictedLengthType_.c_tag: restricted_length_type__from_string,
    ActivationPinType_.c_tag: activation_pin_type__from_string,
    Alphabet.c_tag: alphabet_from_string,
    AlphabetType_.c_tag: alphabet_type__from_string,
    TokenType_.c_tag: token_type__from_string,
    DeviceTypeType_.c_tag: device_type_type__from_string,
    BooleanType_.c_tag: boolean_type__from_string,
    TimeSyncTokenType_.c_tag: time_sync_token_type__from_string,
    ActivationLimitType_.c_tag: activation_limit_type__from_string,
    ActivationLimitDuration.c_tag: activation_limit_duration_from_string,
    ActivationLimitUsages.c_tag: activation_limit_usages_from_string,
    ActivationLimitSession.c_tag: activation_limit_session_from_string,
    ActivationLimitDurationType_.c_tag: activation_limit_duration_type__from_string,
    ActivationLimitUsagesType_.c_tag: activation_limit_usages_type__from_string,
    ActivationLimitSessionType_.c_tag: activation_limit_session_type__from_string,
    LengthType_.c_tag: length_type__from_string,
    MediumType_.c_tag: medium_type__from_string,
    KeyStorageType_.c_tag: key_storage_type__from_string,
    SecretKeyProtectionType_.c_tag: secret_key_protection_type__from_string,
    SecurityAuditType_.c_tag: security_audit_type__from_string,
    ExtensionOnlyType_.c_tag: extension_only_type__from_string,
    Extension.c_tag: extension_from_string,
    ExtensionType_.c_tag: extension_type__from_string,
    AuthnContextDeclarationBaseType_.c_tag: authn_context_declaration_base_type__from_string,
    AuthnMethodBaseType_.c_tag: authn_method_base_type__from_string,
    PrincipalAuthenticationMechanismType_.c_tag: principal_authentication_mechanism_type__from_string,
    AuthenticatorBaseType_.c_tag: authenticator_base_type__from_string,
    PublicKeyType_.c_tag: public_key_type__from_string,
    AuthenticatorTransportProtocolType_.c_tag: authenticator_transport_protocol_type__from_string,
}

ELEMENT_BY_TAG = {
    'AuthenticationContextDeclaration': AuthenticationContextDeclaration,
    'Identification': Identification,
    'PhysicalVerification': PhysicalVerification,
    'WrittenConsent': WrittenConsent,
    'TechnicalProtection': TechnicalProtection,
    'SecretKeyProtection': SecretKeyProtection,
    'PrivateKeyProtection': PrivateKeyProtection,
    'KeyActivation': KeyActivation,
    'KeySharing': KeySharing,
    'KeyStorage': KeyStorage,
    'SubscriberLineNumber': SubscriberLineNumber,
    'UserSuffix': UserSuffix,
    'Password': Password,
    'ActivationPin': ActivationPin,
    'Token': Token,
    'TimeSyncToken': TimeSyncToken,
    'Smartcard': Smartcard,
    'Length': Length,
    'ActivationLimit': ActivationLimit,
    'Generation': Generation,
    'AuthnMethod': AuthnMethod,
    'PrincipalAuthenticationMechanism': PrincipalAuthenticationMechanism,
    'Authenticator': Authenticator,
    'ComplexAuthenticator': ComplexAuthenticator,
    'PreviousSession': PreviousSession,
    'ResumeSession': ResumeSession,
    'ZeroKnowledge': ZeroKnowledge,
    'SharedSecretChallengeResponse': SharedSecretChallengeResponse,
    'SharedSecretChallengeResponseType': SharedSecretChallengeResponseType_,
    'DigSig': DigSig,
    'AsymmetricDecryption': AsymmetricDecryption,
    'AsymmetricKeyAgreement': AsymmetricKeyAgreement,
    'IPAddress': IPAddress,
    'SharedSecretDynamicPlaintext': SharedSecretDynamicPlaintext,
    'AuthenticatorTransportProtocol': AuthenticatorTransportProtocol,
    'HTTP': HTTP,
    'IPSec': IPSec,
    'WTLS': WTLS,
    'MobileNetworkNoEncryption': MobileNetworkNoEncryption,
    'MobileNetworkRadioEncryption': MobileNetworkRadioEncryption,
    'MobileNetworkEndToEndEncryption': MobileNetworkEndToEndEncryption,
    'SSL': SSL,
    'PSTN': PSTN,
    'ISDN': ISDN,
    'ADSL': ADSL,
    'OperationalProtection': OperationalProtection,
    'SecurityAudit': SecurityAudit,
    'SwitchAudit': SwitchAudit,
    'DeactivationCallCenter': DeactivationCallCenter,
    'GoverningAgreements': GoverningAgreements,
    'GoverningAgreementRef': GoverningAgreementRef,
    'nymType': NymType_,
    'IdentificationType': IdentificationType_,
    'TechnicalProtectionBaseType': TechnicalProtectionBaseType_,
    'OperationalProtectionType': OperationalProtectionType_,
    'GoverningAgreementsType': GoverningAgreementsType_,
    'GoverningAgreementRefType': GoverningAgreementRefType_,
    'ComplexAuthenticatorType': ComplexAuthenticatorType_,
    'KeyActivationType': KeyActivationType_,
    'KeySharingType': KeySharingType_,
    'PrivateKeyProtectionType': PrivateKeyProtectionType_,
    'PasswordType': PasswordType_,
    'RestrictedPassword': RestrictedPassword,
    'RestrictedPasswordType': RestrictedPasswordType_,
    'RestrictedLengthType': RestrictedLengthType_,
    'ActivationPinType': ActivationPinType_,
    'Alphabet': Alphabet,
    'AlphabetType': AlphabetType_,
    'TokenType': TokenType_,
    'DeviceTypeType': DeviceTypeType_,
    'booleanType': BooleanType_,
    'TimeSyncTokenType': TimeSyncTokenType_,
    'ActivationLimitType': ActivationLimitType_,
    'ActivationLimitDuration': ActivationLimitDuration,
    'ActivationLimitUsages': ActivationLimitUsages,
    'ActivationLimitSession': ActivationLimitSession,
    'ActivationLimitDurationType': ActivationLimitDurationType_,
    'ActivationLimitUsagesType': ActivationLimitUsagesType_,
    'ActivationLimitSessionType': ActivationLimitSessionType_,
    'LengthType': LengthType_,
    'mediumType': MediumType_,
    'KeyStorageType': KeyStorageType_,
    'SecretKeyProtectionType': SecretKeyProtectionType_,
    'SecurityAuditType': SecurityAuditType_,
    'ExtensionOnlyType': ExtensionOnlyType_,
    'Extension': Extension,
    'ExtensionType': ExtensionType_,
    'AuthnContextDeclarationBaseType': AuthnContextDeclarationBaseType_,
    'AuthnMethodBaseType': AuthnMethodBaseType_,
    'PrincipalAuthenticationMechanismType': PrincipalAuthenticationMechanismType_,
    'AuthenticatorBaseType': AuthenticatorBaseType_,
    'PublicKeyType': PublicKeyType_,
    'AuthenticatorTransportProtocolType': AuthenticatorTransportProtocolType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = timesync
#!/usr/bin/env python

#
# Generated Thu May 16 21:05:38 2013 by parse_xsd.py version 0.5.
#

import saml2
from saml2 import SamlBase


NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken'


class PhysicalVerification(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:
    PhysicalVerification element """

    c_tag = 'PhysicalVerification'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['credentialLevel'] = ('credential_level', 'None', False)

    def __init__(self,
                 credential_level=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.credential_level = credential_level


def physical_verification_from_string(xml_string):
    return saml2.create_class_from_xml_string(PhysicalVerification, xml_string)


class Generation(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Generation
    element """

    c_tag = 'Generation'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['mechanism'] = ('mechanism', 'None', True)

    def __init__(self,
                 mechanism=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.mechanism = mechanism


def generation_from_string(xml_string):
    return saml2.create_class_from_xml_string(Generation, xml_string)


class NymType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:nymType
    element """

    c_tag = 'nymType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['anonymity', 'verinymity', 'pseudonymity']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def nym_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NymType_, xml_string)


class GoverningAgreementRefType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:
    GoverningAgreementRefType element """

    c_tag = 'GoverningAgreementRefType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['governingAgreementRef'] = (
        'governing_agreement_ref', 'anyURI', True)

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.governing_agreement_ref = governing_agreement_ref


def governing_agreement_ref_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRefType_,
                                              xml_string)


class KeySharingType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:KeySharingType
    element """

    c_tag = 'KeySharingType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['sharing'] = ('sharing', 'boolean', True)

    def __init__(self,
                 sharing=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.sharing = sharing


def key_sharing_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharingType_, xml_string)


class RestrictedLengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:
    RestrictedLengthType element """

    c_tag = 'RestrictedLengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'None', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.min = min
        self.max = max


def restricted_length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedLengthType_, xml_string)


class AlphabetType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AlphabetType
    element """

    c_tag = 'AlphabetType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['requiredChars'] = ('required_chars', 'string', True)
    c_attributes['excludedChars'] = ('excluded_chars', 'string', False)
    c_attributes['case'] = ('case', 'string', False)

    def __init__(self,
                 required_chars=None,
                 excluded_chars=None,
                 case=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.required_chars = required_chars
        self.excluded_chars = excluded_chars
        self.case = case


def alphabet_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AlphabetType_, xml_string)


class DeviceTypeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:DeviceTypeType
    element """

    c_tag = 'DeviceTypeType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['hardware', 'software']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def device_type_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DeviceTypeType_, xml_string)


class BooleanType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:booleanType
    element """

    c_tag = 'booleanType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN', 'enumeration': ['true', 'false']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def boolean_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(BooleanType_, xml_string)


class ActivationLimitDurationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:
    ActivationLimitDurationType element """

    c_tag = 'ActivationLimitDurationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['duration'] = ('duration', 'duration', True)

    def __init__(self,
                 duration=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.duration = duration


def activation_limit_duration_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDurationType_,
                                              xml_string)


class ActivationLimitUsagesType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:
    ActivationLimitUsagesType element """

    c_tag = 'ActivationLimitUsagesType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['number'] = ('number', 'integer', True)

    def __init__(self,
                 number=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.number = number


def activation_limit_usages_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsagesType_,
                                              xml_string)


class ActivationLimitSessionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:
    ActivationLimitSessionType element """

    c_tag = 'ActivationLimitSessionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def activation_limit_session_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSessionType_,
                                              xml_string)


class LengthType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:LengthType
    element """

    c_tag = 'LengthType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['min'] = ('min', 'integer', True)
    c_attributes['max'] = ('max', 'integer', False)

    def __init__(self,
                 min=None,
                 max=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.min = min
        self.max = max


def length_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LengthType_, xml_string)


class MediumType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:mediumType
    element """

    c_tag = 'mediumType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:NMTOKEN',
                    'enumeration': ['memory', 'smartcard', 'token',
                                    'MobileDevice', 'MobileAuthCard']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def medium_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(MediumType_, xml_string)


class KeyStorageType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:KeyStorageType
    element """

    c_tag = 'KeyStorageType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['medium'] = ('medium', MediumType_, True)

    def __init__(self,
                 medium=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.medium = medium


def key_storage_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorageType_, xml_string)


class ExtensionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ExtensionType
    element """

    c_tag = 'ExtensionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def extension_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionType_, xml_string)


class TimeSyncTokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:
    TimeSyncTokenType element """

    c_tag = 'TimeSyncTokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['DeviceType'] = ('device_type', 'None', True)
    c_attributes['SeedLength'] = ('seed_length', 'None', True)
    c_attributes['DeviceInHand'] = ('device_in_hand', 'None', True)

    def __init__(self,
                 device_type=None,
                 seed_length=None,
                 device_in_hand=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.device_type = device_type
        self.seed_length = seed_length
        self.device_in_hand = device_in_hand


def time_sync_token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncTokenType_, xml_string)


class KeySharing(KeySharingType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:KeySharing
    element """

    c_tag = 'KeySharing'
    c_namespace = NAMESPACE
    c_children = KeySharingType_.c_children.copy()
    c_attributes = KeySharingType_.c_attributes.copy()
    c_child_order = KeySharingType_.c_child_order[:]
    c_cardinality = KeySharingType_.c_cardinality.copy()


def key_sharing_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeySharing, xml_string)


class KeyStorage(KeyStorageType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:KeyStorage
    element """

    c_tag = 'KeyStorage'
    c_namespace = NAMESPACE
    c_children = KeyStorageType_.c_children.copy()
    c_attributes = KeyStorageType_.c_attributes.copy()
    c_child_order = KeyStorageType_.c_child_order[:]
    c_cardinality = KeyStorageType_.c_cardinality.copy()


def key_storage_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyStorage, xml_string)


class TimeSyncToken(TimeSyncTokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:TimeSyncToken
    element """

    c_tag = 'TimeSyncToken'
    c_namespace = NAMESPACE
    c_children = TimeSyncTokenType_.c_children.copy()
    c_attributes = TimeSyncTokenType_.c_attributes.copy()
    c_child_order = TimeSyncTokenType_.c_child_order[:]
    c_cardinality = TimeSyncTokenType_.c_cardinality.copy()


def time_sync_token_from_string(xml_string):
    return saml2.create_class_from_xml_string(TimeSyncToken, xml_string)


class Length(LengthType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Length element """

    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = LengthType_.c_children.copy()
    c_attributes = LengthType_.c_attributes.copy()
    c_child_order = LengthType_.c_child_order[:]
    c_cardinality = LengthType_.c_cardinality.copy()


def length_from_string(xml_string):
    return saml2.create_class_from_xml_string(Length, xml_string)


class GoverningAgreementRef(GoverningAgreementRefType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:GoverningAgreementRef element """

    c_tag = 'GoverningAgreementRef'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementRefType_.c_children.copy()
    c_attributes = GoverningAgreementRefType_.c_attributes.copy()
    c_child_order = GoverningAgreementRefType_.c_child_order[:]
    c_cardinality = GoverningAgreementRefType_.c_cardinality.copy()


def governing_agreement_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementRef, xml_string)


class GoverningAgreementsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:
    GoverningAgreementsType element """

    c_tag = 'GoverningAgreementsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}GoverningAgreementRef'] = (
            'governing_agreement_ref', [GoverningAgreementRef])
    c_cardinality['governing_agreement_ref'] = {"min": 1}
    c_child_order.extend(['governing_agreement_ref'])

    def __init__(self,
                 governing_agreement_ref=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.governing_agreement_ref = governing_agreement_ref or []


def governing_agreements_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreementsType_,
                                              xml_string)


class RestrictedPasswordType_Length(RestrictedLengthType_):
    c_tag = 'Length'
    c_namespace = NAMESPACE
    c_children = RestrictedLengthType_.c_children.copy()
    c_attributes = RestrictedLengthType_.c_attributes.copy()
    c_child_order = RestrictedLengthType_.c_child_order[:]
    c_cardinality = RestrictedLengthType_.c_cardinality.copy()


def restricted_password_type__length_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_Length,
                                              xml_string)


class Alphabet(AlphabetType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Alphabet element """

    c_tag = 'Alphabet'
    c_namespace = NAMESPACE
    c_children = AlphabetType_.c_children.copy()
    c_attributes = AlphabetType_.c_attributes.copy()
    c_child_order = AlphabetType_.c_child_order[:]
    c_cardinality = AlphabetType_.c_cardinality.copy()


def alphabet_from_string(xml_string):
    return saml2.create_class_from_xml_string(Alphabet, xml_string)


class ActivationLimitDuration(ActivationLimitDurationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ActivationLimitDuration element """

    c_tag = 'ActivationLimitDuration'
    c_namespace = NAMESPACE
    c_children = ActivationLimitDurationType_.c_children.copy()
    c_attributes = ActivationLimitDurationType_.c_attributes.copy()
    c_child_order = ActivationLimitDurationType_.c_child_order[:]
    c_cardinality = ActivationLimitDurationType_.c_cardinality.copy()


def activation_limit_duration_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitDuration,
                                              xml_string)


class ActivationLimitUsages(ActivationLimitUsagesType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ActivationLimitUsages element """

    c_tag = 'ActivationLimitUsages'
    c_namespace = NAMESPACE
    c_children = ActivationLimitUsagesType_.c_children.copy()
    c_attributes = ActivationLimitUsagesType_.c_attributes.copy()
    c_child_order = ActivationLimitUsagesType_.c_child_order[:]
    c_cardinality = ActivationLimitUsagesType_.c_cardinality.copy()


def activation_limit_usages_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitUsages, xml_string)


class ActivationLimitSession(ActivationLimitSessionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ActivationLimitSession element """

    c_tag = 'ActivationLimitSession'
    c_namespace = NAMESPACE
    c_children = ActivationLimitSessionType_.c_children.copy()
    c_attributes = ActivationLimitSessionType_.c_attributes.copy()
    c_child_order = ActivationLimitSessionType_.c_child_order[:]
    c_cardinality = ActivationLimitSessionType_.c_cardinality.copy()


def activation_limit_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitSession,
                                              xml_string)


class Extension(ExtensionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Extension element """

    c_tag = 'Extension'
    c_namespace = NAMESPACE
    c_children = ExtensionType_.c_children.copy()
    c_attributes = ExtensionType_.c_attributes.copy()
    c_child_order = ExtensionType_.c_child_order[:]
    c_cardinality = ExtensionType_.c_cardinality.copy()


def extension_from_string(xml_string):
    return saml2.create_class_from_xml_string(Extension, xml_string)


class TokenType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:TokenType element """

    c_tag = 'TokenType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}TimeSyncToken'] = (
        'time_sync_token', TimeSyncToken)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['time_sync_token', 'extension'])

    def __init__(self,
                 time_sync_token=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.time_sync_token = time_sync_token
        self.extension = extension or []


def token_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TokenType_, xml_string)


class Token(TokenType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Token element """

    c_tag = 'Token'
    c_namespace = NAMESPACE
    c_children = TokenType_.c_children.copy()
    c_attributes = TokenType_.c_attributes.copy()
    c_child_order = TokenType_.c_child_order[:]
    c_cardinality = TokenType_.c_cardinality.copy()


def token_from_string(xml_string):
    return saml2.create_class_from_xml_string(Token, xml_string)


class SharedSecretChallengeResponseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SharedSecretChallengeResponseType element """

    c_tag = 'SharedSecretChallengeResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['method'] = ('method', 'anyURI', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 method=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.method = method


def shared_secret_challenge_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        SharedSecretChallengeResponseType_, xml_string)


class PublicKeyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:PublicKeyType element """

    c_tag = 'PublicKeyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['keyValidation'] = ('key_validation', 'None', False)
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 key_validation=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []
        self.key_validation = key_validation


def public_key_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicKeyType_, xml_string)


class GoverningAgreements(GoverningAgreementsType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:GoverningAgreements element """

    c_tag = 'GoverningAgreements'
    c_namespace = NAMESPACE
    c_children = GoverningAgreementsType_.c_children.copy()
    c_attributes = GoverningAgreementsType_.c_attributes.copy()
    c_child_order = GoverningAgreementsType_.c_child_order[:]
    c_cardinality = GoverningAgreementsType_.c_cardinality.copy()


def governing_agreements_from_string(xml_string):
    return saml2.create_class_from_xml_string(GoverningAgreements, xml_string)


class PasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:PasswordType element """

    c_tag = 'PasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'alphabet', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PasswordType_, xml_string)


class RestrictedPasswordType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:RestrictedPasswordType element """

    c_tag = 'RestrictedPasswordType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Length'] = (
        'length', RestrictedPasswordType_Length)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ExternalVerification'] = (
        'external_verification', 'anyURI', False)
    c_child_order.extend(['length', 'generation', 'extension'])

    def __init__(self,
                 length=None,
                 generation=None,
                 extension=None,
                 external_verification=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.generation = generation
        self.extension = extension or []
        self.external_verification = external_verification


def restricted_password_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPasswordType_,
                                              xml_string)


class ActivationLimitType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ActivationLimitType element """

    c_tag = 'ActivationLimitType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ActivationLimitDuration'] = (
        'activation_limit_duration', ActivationLimitDuration)
    c_cardinality['activation_limit_duration'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ActivationLimitUsages'] = (
        'activation_limit_usages', ActivationLimitUsages)
    c_cardinality['activation_limit_usages'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ActivationLimitSession'] = (
        'activation_limit_session', ActivationLimitSession)
    c_cardinality['activation_limit_session'] = {"min": 0, "max": 1}
    c_child_order.extend(
        ['activation_limit_duration', 'activation_limit_usages',
         'activation_limit_session'])

    def __init__(self,
                 activation_limit_duration=None,
                 activation_limit_usages=None,
                 activation_limit_session=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_limit_duration = activation_limit_duration
        self.activation_limit_usages = activation_limit_usages
        self.activation_limit_session = activation_limit_session


def activation_limit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimitType_, xml_string)


class ExtensionOnlyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ExtensionOnlyType element """

    c_tag = 'ExtensionOnlyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['extension'])

    def __init__(self,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extension = extension or []


def extension_only_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionOnlyType_, xml_string)


class PrincipalAuthenticationMechanismType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:PrincipalAuthenticationMechanismType element """

    c_tag = 'PrincipalAuthenticationMechanismType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Token'] = (
        'token', Token)
    c_child_order.extend(['token'])

    def __init__(self,
                 token=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.token = token


def principal_authentication_mechanism_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        PrincipalAuthenticationMechanismType_, xml_string)


class WrittenConsent(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:WrittenConsent element """

    c_tag = 'WrittenConsent'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def written_consent_from_string(xml_string):
    return saml2.create_class_from_xml_string(WrittenConsent, xml_string)


class SubscriberLineNumber(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SubscriberLineNumber element """

    c_tag = 'SubscriberLineNumber'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def subscriber_line_number_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubscriberLineNumber, xml_string)


class UserSuffix(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:UserSuffix element """

    c_tag = 'UserSuffix'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def user_suffix_from_string(xml_string):
    return saml2.create_class_from_xml_string(UserSuffix, xml_string)


class Password(PasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Password element """

    c_tag = 'Password'
    c_namespace = NAMESPACE
    c_children = PasswordType_.c_children.copy()
    c_attributes = PasswordType_.c_attributes.copy()
    c_child_order = PasswordType_.c_child_order[:]
    c_cardinality = PasswordType_.c_cardinality.copy()


def password_from_string(xml_string):
    return saml2.create_class_from_xml_string(Password, xml_string)


class Smartcard(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Smartcard element """

    c_tag = 'Smartcard'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def smartcard_from_string(xml_string):
    return saml2.create_class_from_xml_string(Smartcard, xml_string)


class ActivationLimit(ActivationLimitType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ActivationLimit element """

    c_tag = 'ActivationLimit'
    c_namespace = NAMESPACE
    c_children = ActivationLimitType_.c_children.copy()
    c_attributes = ActivationLimitType_.c_attributes.copy()
    c_child_order = ActivationLimitType_.c_child_order[:]
    c_cardinality = ActivationLimitType_.c_cardinality.copy()


def activation_limit_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationLimit, xml_string)


class PrincipalAuthenticationMechanism(PrincipalAuthenticationMechanismType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:PrincipalAuthenticationMechanism element """

    c_tag = 'PrincipalAuthenticationMechanism'
    c_namespace = NAMESPACE
    c_children = PrincipalAuthenticationMechanismType_.c_children.copy()
    c_attributes = PrincipalAuthenticationMechanismType_.c_attributes.copy()
    c_child_order = PrincipalAuthenticationMechanismType_.c_child_order[:]
    c_cardinality = PrincipalAuthenticationMechanismType_.c_cardinality.copy()


def principal_authentication_mechanism_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrincipalAuthenticationMechanism,
                                              xml_string)


class PreviousSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:PreviousSession element """

    c_tag = 'PreviousSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def previous_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(PreviousSession, xml_string)


class ResumeSession(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ResumeSession element """

    c_tag = 'ResumeSession'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def resume_session_from_string(xml_string):
    return saml2.create_class_from_xml_string(ResumeSession, xml_string)


class ZeroKnowledge(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ZeroKnowledge element """

    c_tag = 'ZeroKnowledge'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def zero_knowledge_from_string(xml_string):
    return saml2.create_class_from_xml_string(ZeroKnowledge, xml_string)


class SharedSecretChallengeResponse(SharedSecretChallengeResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SharedSecretChallengeResponse element """

    c_tag = 'SharedSecretChallengeResponse'
    c_namespace = NAMESPACE
    c_children = SharedSecretChallengeResponseType_.c_children.copy()
    c_attributes = SharedSecretChallengeResponseType_.c_attributes.copy()
    c_child_order = SharedSecretChallengeResponseType_.c_child_order[:]
    c_cardinality = SharedSecretChallengeResponseType_.c_cardinality.copy()


def shared_secret_challenge_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretChallengeResponse,
                                              xml_string)


class DigSig(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:DigSig element """

    c_tag = 'DigSig'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def dig_sig_from_string(xml_string):
    return saml2.create_class_from_xml_string(DigSig, xml_string)


class AsymmetricDecryption(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AsymmetricDecryption element """

    c_tag = 'AsymmetricDecryption'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_decryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricDecryption, xml_string)


class AsymmetricKeyAgreement(PublicKeyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AsymmetricKeyAgreement element """

    c_tag = 'AsymmetricKeyAgreement'
    c_namespace = NAMESPACE
    c_children = PublicKeyType_.c_children.copy()
    c_attributes = PublicKeyType_.c_attributes.copy()
    c_child_order = PublicKeyType_.c_child_order[:]
    c_cardinality = PublicKeyType_.c_cardinality.copy()


def asymmetric_key_agreement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AsymmetricKeyAgreement,
                                              xml_string)


class IPAddress(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:IPAddress element """

    c_tag = 'IPAddress'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_address_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPAddress, xml_string)


class SharedSecretDynamicPlaintext(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SharedSecretDynamicPlaintext element """

    c_tag = 'SharedSecretDynamicPlaintext'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def shared_secret_dynamic_plaintext_from_string(xml_string):
    return saml2.create_class_from_xml_string(SharedSecretDynamicPlaintext,
                                              xml_string)


class HTTP(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:HTTP element """

    c_tag = 'HTTP'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def http_from_string(xml_string):
    return saml2.create_class_from_xml_string(HTTP, xml_string)


class IPSec(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:IPSec element """

    c_tag = 'IPSec'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ip_sec_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPSec, xml_string)


class WTLS(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:WTLS element """

    c_tag = 'WTLS'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def wtls_from_string(xml_string):
    return saml2.create_class_from_xml_string(WTLS, xml_string)


class MobileNetworkNoEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:MobileNetworkNoEncryption element """

    c_tag = 'MobileNetworkNoEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_no_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkNoEncryption,
                                              xml_string)


class MobileNetworkRadioEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:MobileNetworkRadioEncryption element """

    c_tag = 'MobileNetworkRadioEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_radio_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkRadioEncryption,
                                              xml_string)


class MobileNetworkEndToEndEncryption(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:MobileNetworkEndToEndEncryption element """

    c_tag = 'MobileNetworkEndToEndEncryption'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def mobile_network_end_to_end_encryption_from_string(xml_string):
    return saml2.create_class_from_xml_string(MobileNetworkEndToEndEncryption,
                                              xml_string)


class SSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SSL element """

    c_tag = 'SSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def ssl_from_string(xml_string):
    return saml2.create_class_from_xml_string(SSL, xml_string)


class PSTN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:PSTN element """

    c_tag = 'PSTN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def pstn_from_string(xml_string):
    return saml2.create_class_from_xml_string(PSTN, xml_string)


class ISDN(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ISDN element """

    c_tag = 'ISDN'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def isdn_from_string(xml_string):
    return saml2.create_class_from_xml_string(ISDN, xml_string)


class ADSL(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ADSL element """

    c_tag = 'ADSL'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def adsl_from_string(xml_string):
    return saml2.create_class_from_xml_string(ADSL, xml_string)


class SwitchAudit(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SwitchAudit element """

    c_tag = 'SwitchAudit'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def switch_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SwitchAudit, xml_string)


class DeactivationCallCenter(ExtensionOnlyType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:DeactivationCallCenter element """

    c_tag = 'DeactivationCallCenter'
    c_namespace = NAMESPACE
    c_children = ExtensionOnlyType_.c_children.copy()
    c_attributes = ExtensionOnlyType_.c_attributes.copy()
    c_child_order = ExtensionOnlyType_.c_child_order[:]
    c_cardinality = ExtensionOnlyType_.c_cardinality.copy()


def deactivation_call_center_from_string(xml_string):
    return saml2.create_class_from_xml_string(DeactivationCallCenter,
                                              xml_string)


class IdentificationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:IdentificationType element """

    c_tag = 'IdentificationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}PhysicalVerification'] = (
        'physical_verification', PhysicalVerification)
    c_cardinality['physical_verification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}WrittenConsent'] = (
        'written_consent', WrittenConsent)
    c_cardinality['written_consent'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['nym'] = ('nym', NymType_, False)
    c_child_order.extend(
        ['physical_verification', 'written_consent', 'governing_agreements',
         'extension'])

    def __init__(self,
                 physical_verification=None,
                 written_consent=None,
                 governing_agreements=None,
                 extension=None,
                 nym=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.physical_verification = physical_verification
        self.written_consent = written_consent
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.nym = nym


def identification_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IdentificationType_, xml_string)


class AuthenticatorTransportProtocolType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AuthenticatorTransportProtocolType element """

    c_tag = 'AuthenticatorTransportProtocolType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}HTTP'] = (
        'http', HTTP)
    c_cardinality['http'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SSL'] = (
        'ssl', SSL)
    c_cardinality['ssl'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}MobileNetworkNoEncryption'] = (
        'mobile_network_no_encryption', MobileNetworkNoEncryption)
    c_cardinality['mobile_network_no_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}MobileNetworkRadioEncryption'] = (
        'mobile_network_radio_encryption', MobileNetworkRadioEncryption)
    c_cardinality['mobile_network_radio_encryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}MobileNetworkEndToEndEncryption'] = (
        'mobile_network_end_to_end_encryption', MobileNetworkEndToEndEncryption)
    c_cardinality['mobile_network_end_to_end_encryption'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}WTLS'] = (
        'wtls', WTLS)
    c_cardinality['wtls'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}IPSec'] = (
        'ip_sec', IPSec)
    c_cardinality['ip_sec'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}PSTN'] = (
        'pstn', PSTN)
    c_cardinality['pstn'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ISDN'] = (
        'isdn', ISDN)
    c_cardinality['isdn'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ADSL'] = (
        'adsl', ADSL)
    c_cardinality['adsl'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['http', 'ssl', 'mobile_network_no_encryption',
                          'mobile_network_radio_encryption',
                          'mobile_network_end_to_end_encryption', 'wtls',
                          'ip_sec', 'pstn', 'isdn', 'adsl', 'extension'])

    def __init__(self,
                 http=None,
                 ssl=None,
                 mobile_network_no_encryption=None,
                 mobile_network_radio_encryption=None,
                 mobile_network_end_to_end_encryption=None,
                 wtls=None,
                 ip_sec=None,
                 pstn=None,
                 isdn=None,
                 adsl=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.http = http
        self.ssl = ssl
        self.mobile_network_no_encryption = mobile_network_no_encryption
        self.mobile_network_radio_encryption = mobile_network_radio_encryption
        self.mobile_network_end_to_end_encryption = mobile_network_end_to_end_encryption
        self.wtls = wtls
        self.ip_sec = ip_sec
        self.pstn = pstn
        self.isdn = isdn
        self.adsl = adsl
        self.extension = extension or []


def authenticator_transport_protocol_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(
        AuthenticatorTransportProtocolType_, xml_string)


class RestrictedPassword(RestrictedPasswordType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:RestrictedPassword element """

    c_tag = 'RestrictedPassword'
    c_namespace = NAMESPACE
    c_children = RestrictedPasswordType_.c_children.copy()
    c_attributes = RestrictedPasswordType_.c_attributes.copy()
    c_child_order = RestrictedPasswordType_.c_child_order[:]
    c_cardinality = RestrictedPasswordType_.c_cardinality.copy()


def restricted_password_from_string(xml_string):
    return saml2.create_class_from_xml_string(RestrictedPassword, xml_string)


class ActivationPinType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ActivationPinType element """

    c_tag = 'ActivationPinType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Length'] = (
        'length', Length)
    c_cardinality['length'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Alphabet'] = (
        'alphabet', Alphabet)
    c_cardinality['alphabet'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Generation'] = (
        'generation', Generation)
    c_cardinality['generation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ActivationLimit'] = (
        'activation_limit', ActivationLimit)
    c_cardinality['activation_limit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['length', 'alphabet', 'generation', 'activation_limit', 'extension'])

    def __init__(self,
                 length=None,
                 alphabet=None,
                 generation=None,
                 activation_limit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.length = length
        self.alphabet = alphabet
        self.generation = generation
        self.activation_limit = activation_limit
        self.extension = extension or []


def activation_pin_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPinType_, xml_string)


class SecurityAuditType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SecurityAuditType element """

    c_tag = 'SecurityAuditType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SwitchAudit'] = (
        'switch_audit', SwitchAudit)
    c_cardinality['switch_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['switch_audit', 'extension'])

    def __init__(self,
                 switch_audit=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.switch_audit = switch_audit
        self.extension = extension or []


def security_audit_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAuditType_, xml_string)


class Identification(IdentificationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Identification element """

    c_tag = 'Identification'
    c_namespace = NAMESPACE
    c_children = IdentificationType_.c_children.copy()
    c_attributes = IdentificationType_.c_attributes.copy()
    c_child_order = IdentificationType_.c_child_order[:]
    c_cardinality = IdentificationType_.c_cardinality.copy()


def identification_from_string(xml_string):
    return saml2.create_class_from_xml_string(Identification, xml_string)


class ActivationPin(ActivationPinType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ActivationPin element """

    c_tag = 'ActivationPin'
    c_namespace = NAMESPACE
    c_children = ActivationPinType_.c_children.copy()
    c_attributes = ActivationPinType_.c_attributes.copy()
    c_child_order = ActivationPinType_.c_child_order[:]
    c_cardinality = ActivationPinType_.c_cardinality.copy()


def activation_pin_from_string(xml_string):
    return saml2.create_class_from_xml_string(ActivationPin, xml_string)


class AuthenticatorTransportProtocol(AuthenticatorTransportProtocolType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AuthenticatorTransportProtocol element """

    c_tag = 'AuthenticatorTransportProtocol'
    c_namespace = NAMESPACE
    c_children = AuthenticatorTransportProtocolType_.c_children.copy()
    c_attributes = AuthenticatorTransportProtocolType_.c_attributes.copy()
    c_child_order = AuthenticatorTransportProtocolType_.c_child_order[:]
    c_cardinality = AuthenticatorTransportProtocolType_.c_cardinality.copy()


def authenticator_transport_protocol_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorTransportProtocol,
                                              xml_string)


class SecurityAudit(SecurityAuditType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SecurityAudit element """

    c_tag = 'SecurityAudit'
    c_namespace = NAMESPACE
    c_children = SecurityAuditType_.c_children.copy()
    c_attributes = SecurityAuditType_.c_attributes.copy()
    c_child_order = SecurityAuditType_.c_child_order[:]
    c_cardinality = SecurityAuditType_.c_cardinality.copy()


def security_audit_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecurityAudit, xml_string)


class OperationalProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:OperationalProtectionType element """

    c_tag = 'OperationalProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SecurityAudit'] = (
        'security_audit', SecurityAudit)
    c_cardinality['security_audit'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}DeactivationCallCenter'] = (
        'deactivation_call_center', DeactivationCallCenter)
    c_cardinality['deactivation_call_center'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['security_audit', 'deactivation_call_center', 'extension'])

    def __init__(self,
                 security_audit=None,
                 deactivation_call_center=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.security_audit = security_audit
        self.deactivation_call_center = deactivation_call_center
        self.extension = extension or []


def operational_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtectionType_,
                                              xml_string)


class KeyActivationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:KeyActivationType element """

    c_tag = 'KeyActivationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ActivationPin'] = (
        'activation_pin', ActivationPin)
    c_cardinality['activation_pin'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['activation_pin', 'extension'])

    def __init__(self,
                 activation_pin=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.activation_pin = activation_pin
        self.extension = extension or []


def key_activation_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivationType_, xml_string)


class KeyActivation(KeyActivationType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:KeyActivation element """

    c_tag = 'KeyActivation'
    c_namespace = NAMESPACE
    c_children = KeyActivationType_.c_children.copy()
    c_attributes = KeyActivationType_.c_attributes.copy()
    c_child_order = KeyActivationType_.c_child_order[:]
    c_cardinality = KeyActivationType_.c_cardinality.copy()


def key_activation_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyActivation, xml_string)


class OperationalProtection(OperationalProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:OperationalProtection element """

    c_tag = 'OperationalProtection'
    c_namespace = NAMESPACE
    c_children = OperationalProtectionType_.c_children.copy()
    c_attributes = OperationalProtectionType_.c_attributes.copy()
    c_child_order = OperationalProtectionType_.c_child_order[:]
    c_cardinality = OperationalProtectionType_.c_cardinality.copy()


def operational_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(OperationalProtection, xml_string)


class PrivateKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:PrivateKeyProtectionType element """

    c_tag = 'PrivateKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}KeySharing'] = (
        'key_sharing', KeySharing)
    c_cardinality['key_sharing'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['key_activation', 'key_storage', 'key_sharing', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 key_sharing=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.key_sharing = key_sharing
        self.extension = extension or []


def private_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtectionType_,
                                              xml_string)


class SecretKeyProtectionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SecretKeyProtectionType element """

    c_tag = 'SecretKeyProtectionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}KeyActivation'] = (
        'key_activation', KeyActivation)
    c_cardinality['key_activation'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}KeyStorage'] = (
        'key_storage', KeyStorage)
    c_cardinality['key_storage'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['key_activation', 'key_storage', 'extension'])

    def __init__(self,
                 key_activation=None,
                 key_storage=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.key_activation = key_activation
        self.key_storage = key_storage
        self.extension = extension or []


def secret_key_protection_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtectionType_,
                                              xml_string)


class SecretKeyProtection(SecretKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:SecretKeyProtection element """

    c_tag = 'SecretKeyProtection'
    c_namespace = NAMESPACE
    c_children = SecretKeyProtectionType_.c_children.copy()
    c_attributes = SecretKeyProtectionType_.c_attributes.copy()
    c_child_order = SecretKeyProtectionType_.c_child_order[:]
    c_cardinality = SecretKeyProtectionType_.c_cardinality.copy()


def secret_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(SecretKeyProtection, xml_string)


class PrivateKeyProtection(PrivateKeyProtectionType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:PrivateKeyProtection element """

    c_tag = 'PrivateKeyProtection'
    c_namespace = NAMESPACE
    c_children = PrivateKeyProtectionType_.c_children.copy()
    c_attributes = PrivateKeyProtectionType_.c_attributes.copy()
    c_child_order = PrivateKeyProtectionType_.c_child_order[:]
    c_cardinality = PrivateKeyProtectionType_.c_cardinality.copy()


def private_key_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivateKeyProtection, xml_string)


class TechnicalProtectionBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:TechnicalProtectionBaseType element """

    c_tag = 'TechnicalProtectionBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}PrivateKeyProtection'] = (
        'private_key_protection', PrivateKeyProtection)
    c_cardinality['private_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SecretKeyProtection'] = (
        'secret_key_protection', SecretKeyProtection)
    c_cardinality['secret_key_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['private_key_protection', 'secret_key_protection', 'extension'])

    def __init__(self,
                 private_key_protection=None,
                 secret_key_protection=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.private_key_protection = private_key_protection
        self.secret_key_protection = secret_key_protection
        self.extension = extension or []


def technical_protection_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtectionBaseType_,
                                              xml_string)


class TechnicalProtection(TechnicalProtectionBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:TechnicalProtection element """

    c_tag = 'TechnicalProtection'
    c_namespace = NAMESPACE
    c_children = TechnicalProtectionBaseType_.c_children.copy()
    c_attributes = TechnicalProtectionBaseType_.c_attributes.copy()
    c_child_order = TechnicalProtectionBaseType_.c_child_order[:]
    c_cardinality = TechnicalProtectionBaseType_.c_cardinality.copy()


def technical_protection_from_string(xml_string):
    return saml2.create_class_from_xml_string(TechnicalProtection, xml_string)


#..................
# ['ComplexAuthenticator', 'Authenticator', 'AuthnMethod', 'ComplexAuthenticatorType', 'AuthenticatorBaseType', 'AuthnContextDeclarationBaseType', 'AuthnMethodBaseType', 'AuthenticationContextDeclaration']
class ComplexAuthenticatorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ComplexAuthenticatorType element """

    c_tag = 'ComplexAuthenticatorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}PreviousSession'] = (
        'previous_session', PreviousSession)
    c_cardinality['previous_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ResumeSession'] = (
        'resume_session', ResumeSession)
    c_cardinality['resume_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}DigSig'] = (
        'dig_sig', DigSig)
    c_cardinality['dig_sig'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Password'] = (
        'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}RestrictedPassword'] = (
        'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ZeroKnowledge'] = (
        'zero_knowledge', ZeroKnowledge)
    c_cardinality['zero_knowledge'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SharedSecretChallengeResponse'] = (
        'shared_secret_challenge_response', SharedSecretChallengeResponse)
    c_cardinality['shared_secret_challenge_response'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SharedSecretDynamicPlaintext'] = (
        'shared_secret_dynamic_plaintext', SharedSecretDynamicPlaintext)
    c_cardinality['shared_secret_dynamic_plaintext'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}IPAddress'] = (
        'ip_address', IPAddress)
    c_cardinality['ip_address'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}AsymmetricDecryption'] = (
        'asymmetric_decryption', AsymmetricDecryption)
    c_cardinality['asymmetric_decryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}AsymmetricKeyAgreement'] = (
        'asymmetric_key_agreement', AsymmetricKeyAgreement)
    c_cardinality['asymmetric_key_agreement'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SubscriberLineNumber'] = (
        'subscriber_line_number', SubscriberLineNumber)
    c_cardinality['subscriber_line_number'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}UserSuffix'] = (
        'user_suffix', UserSuffix)
    c_cardinality['user_suffix'] = {"min": 0, "max": 1}
    c_cardinality['complex_authenticator'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['previous_session', 'resume_session', 'dig_sig', 'password',
         'restricted_password', 'zero_knowledge',
         'shared_secret_challenge_response', 'shared_secret_dynamic_plaintext',
         'ip_address', 'asymmetric_decryption', 'asymmetric_key_agreement',
         'subscriber_line_number', 'user_suffix', 'complex_authenticator',
         'extension'])

    def __init__(self,
                 previous_session=None,
                 resume_session=None,
                 dig_sig=None,
                 password=None,
                 restricted_password=None,
                 zero_knowledge=None,
                 shared_secret_challenge_response=None,
                 shared_secret_dynamic_plaintext=None,
                 ip_address=None,
                 asymmetric_decryption=None,
                 asymmetric_key_agreement=None,
                 subscriber_line_number=None,
                 user_suffix=None,
                 complex_authenticator=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.previous_session = previous_session
        self.resume_session = resume_session
        self.dig_sig = dig_sig
        self.password = password
        self.restricted_password = restricted_password
        self.zero_knowledge = zero_knowledge
        self.shared_secret_challenge_response = shared_secret_challenge_response
        self.shared_secret_dynamic_plaintext = shared_secret_dynamic_plaintext
        self.ip_address = ip_address
        self.asymmetric_decryption = asymmetric_decryption
        self.asymmetric_key_agreement = asymmetric_key_agreement
        self.subscriber_line_number = subscriber_line_number
        self.user_suffix = user_suffix
        self.complex_authenticator = complex_authenticator
        self.extension = extension or []


def complex_authenticator_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticatorType_,
                                              xml_string)


class ComplexAuthenticator(ComplexAuthenticatorType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:ComplexAuthenticator element """

    c_tag = 'ComplexAuthenticator'
    c_namespace = NAMESPACE
    c_children = ComplexAuthenticatorType_.c_children.copy()
    c_attributes = ComplexAuthenticatorType_.c_attributes.copy()
    c_child_order = ComplexAuthenticatorType_.c_child_order[:]
    c_cardinality = ComplexAuthenticatorType_.c_cardinality.copy()


def complex_authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(ComplexAuthenticator, xml_string)


class AuthenticatorBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AuthenticatorBaseType element """

    c_tag = 'AuthenticatorBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}PreviousSession'] = (
            'previous_session', PreviousSession)
    c_cardinality['previous_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ResumeSession'] = (
            'resume_session', ResumeSession)
    c_cardinality['resume_session'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}DigSig'] = (
            'dig_sig', DigSig)
    c_cardinality['dig_sig'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Password'] = (
            'password', Password)
    c_cardinality['password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}RestrictedPassword'] = (
            'restricted_password', RestrictedPassword)
    c_cardinality['restricted_password'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ZeroKnowledge'] = (
            'zero_knowledge', ZeroKnowledge)
    c_cardinality['zero_knowledge'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SharedSecretChallengeResponse'] = (
            'shared_secret_challenge_response', SharedSecretChallengeResponse)
    c_cardinality['shared_secret_challenge_response'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SharedSecretDynamicPlaintext'] = (
            'shared_secret_dynamic_plaintext', SharedSecretDynamicPlaintext)
    c_cardinality['shared_secret_dynamic_plaintext'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}IPAddress'] = (
            'ip_address', IPAddress)
    c_cardinality['ip_address'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}AsymmetricDecryption'] = (
            'asymmetric_decryption', AsymmetricDecryption)
    c_cardinality['asymmetric_decryption'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}AsymmetricKeyAgreement'] = (
            'asymmetric_key_agreement', AsymmetricKeyAgreement)
    c_cardinality['asymmetric_key_agreement'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}SubscriberLineNumber'] = (
            'subscriber_line_number', SubscriberLineNumber)
    c_cardinality['subscriber_line_number'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}UserSuffix'] = (
            'user_suffix', UserSuffix)
    c_cardinality['user_suffix'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ComplexAuthenticator'] = (
            'complex_authenticator', ComplexAuthenticator)
    c_cardinality['complex_authenticator'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
            'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(
        ['previous_session', 'resume_session', 'dig_sig', 'password',
         'restricted_password', 'zero_knowledge',
         'shared_secret_challenge_response', 'shared_secret_dynamic_plaintext',
         'ip_address', 'asymmetric_decryption', 'asymmetric_key_agreement',
         'subscriber_line_number', 'user_suffix', 'complex_authenticator',
         'extension'])

    def __init__(self,
                 previous_session=None,
                 resume_session=None,
                 dig_sig=None,
                 password=None,
                 restricted_password=None,
                 zero_knowledge=None,
                 shared_secret_challenge_response=None,
                 shared_secret_dynamic_plaintext=None,
                 ip_address=None,
                 asymmetric_decryption=None,
                 asymmetric_key_agreement=None,
                 subscriber_line_number=None,
                 user_suffix=None,
                 complex_authenticator=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.previous_session = previous_session
        self.resume_session = resume_session
        self.dig_sig = dig_sig
        self.password = password
        self.restricted_password = restricted_password
        self.zero_knowledge = zero_knowledge
        self.shared_secret_challenge_response = shared_secret_challenge_response
        self.shared_secret_dynamic_plaintext = shared_secret_dynamic_plaintext
        self.ip_address = ip_address
        self.asymmetric_decryption = asymmetric_decryption
        self.asymmetric_key_agreement = asymmetric_key_agreement
        self.subscriber_line_number = subscriber_line_number
        self.user_suffix = user_suffix
        self.complex_authenticator = complex_authenticator
        self.extension = extension or []


def authenticator_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatorBaseType_,
                                              xml_string)


class Authenticator(AuthenticatorBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:Authenticator element """

    c_tag = 'Authenticator'
    c_namespace = NAMESPACE
    c_children = AuthenticatorBaseType_.c_children.copy()
    c_attributes = AuthenticatorBaseType_.c_attributes.copy()
    c_child_order = AuthenticatorBaseType_.c_child_order[:]
    c_cardinality = AuthenticatorBaseType_.c_cardinality.copy()


def authenticator_from_string(xml_string):
    return saml2.create_class_from_xml_string(Authenticator, xml_string)


class AuthnMethodBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AuthnMethodBaseType element """

    c_tag = 'AuthnMethodBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}PrincipalAuthenticationMechanism'] = (
        'principal_authentication_mechanism', PrincipalAuthenticationMechanism)
    c_cardinality['principal_authentication_mechanism'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Authenticator'] = (
        'authenticator', Authenticator)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}AuthenticatorTransportProtocol'] = (
        'authenticator_transport_protocol', AuthenticatorTransportProtocol)
    c_cardinality['authenticator_transport_protocol'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_child_order.extend(['principal_authentication_mechanism', 'authenticator',
                          'authenticator_transport_protocol', 'extension'])

    def __init__(self,
                 principal_authentication_mechanism=None,
                 authenticator=None,
                 authenticator_transport_protocol=None,
                 extension=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.principal_authentication_mechanism = principal_authentication_mechanism
        self.authenticator = authenticator
        self.authenticator_transport_protocol = authenticator_transport_protocol
        self.extension = extension or []


def authn_method_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethodBaseType_, xml_string)


class AuthnMethod(AuthnMethodBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AuthnMethod element """

    c_tag = 'AuthnMethod'
    c_namespace = NAMESPACE
    c_children = AuthnMethodBaseType_.c_children.copy()
    c_attributes = AuthnMethodBaseType_.c_attributes.copy()
    c_child_order = AuthnMethodBaseType_.c_child_order[:]
    c_cardinality = AuthnMethodBaseType_.c_cardinality.copy()


def authn_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnMethod, xml_string)


class AuthnContextDeclarationBaseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AuthnContextDeclarationBaseType element """

    c_tag = 'AuthnContextDeclarationBaseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Identification'] = (
        'identification', Identification)
    c_cardinality['identification'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}TechnicalProtection'] = (
        'technical_protection', TechnicalProtection)
    c_cardinality['technical_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}OperationalProtection'] = (
        'operational_protection', OperationalProtection)
    c_cardinality['operational_protection'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}AuthnMethod'] = (
        'authn_method', AuthnMethod)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}GoverningAgreements'] = (
        'governing_agreements', GoverningAgreements)
    c_cardinality['governing_agreements'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}Extension'] = (
        'extension', [Extension])
    c_cardinality['extension'] = {"min": 0}
    c_attributes['ID'] = ('id', 'ID', False)
    c_child_order.extend(
        ['identification', 'technical_protection', 'operational_protection',
         'authn_method', 'governing_agreements', 'extension'])

    def __init__(self,
                 identification=None,
                 technical_protection=None,
                 operational_protection=None,
                 authn_method=None,
                 governing_agreements=None,
                 extension=None,
                 id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.identification = identification
        self.technical_protection = technical_protection
        self.operational_protection = operational_protection
        self.authn_method = authn_method
        self.governing_agreements = governing_agreements
        self.extension = extension or []
        self.id = id


def authn_context_declaration_base_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextDeclarationBaseType_,
                                              xml_string)


class AuthenticationContextDeclaration(AuthnContextDeclarationBaseType_):
    """The urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken:AuthenticationContextDeclaration element """

    c_tag = 'AuthenticationContextDeclaration'
    c_namespace = NAMESPACE
    c_children = AuthnContextDeclarationBaseType_.c_children.copy()
    c_attributes = AuthnContextDeclarationBaseType_.c_attributes.copy()
    c_child_order = AuthnContextDeclarationBaseType_.c_child_order[:]
    c_cardinality = AuthnContextDeclarationBaseType_.c_cardinality.copy()


def authentication_context_declaration_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticationContextDeclaration,
                                              xml_string)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ComplexAuthenticatorType_.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
ComplexAuthenticator.c_children[
    '{urn:oasis:names:tc:SAML:2.0:ac:classes:TimeSyncToken}ComplexAuthenticator'] = (
    'complex_authenticator', ComplexAuthenticator)
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ELEMENT_FROM_STRING = {
    AuthenticationContextDeclaration.c_tag: authentication_context_declaration_from_string,
    Identification.c_tag: identification_from_string,
    PhysicalVerification.c_tag: physical_verification_from_string,
    WrittenConsent.c_tag: written_consent_from_string,
    TechnicalProtection.c_tag: technical_protection_from_string,
    SecretKeyProtection.c_tag: secret_key_protection_from_string,
    PrivateKeyProtection.c_tag: private_key_protection_from_string,
    KeyActivation.c_tag: key_activation_from_string,
    KeySharing.c_tag: key_sharing_from_string,
    KeyStorage.c_tag: key_storage_from_string,
    SubscriberLineNumber.c_tag: subscriber_line_number_from_string,
    UserSuffix.c_tag: user_suffix_from_string,
    Password.c_tag: password_from_string,
    ActivationPin.c_tag: activation_pin_from_string,
    Token.c_tag: token_from_string,
    TimeSyncToken.c_tag: time_sync_token_from_string,
    Smartcard.c_tag: smartcard_from_string,
    Length.c_tag: length_from_string,
    ActivationLimit.c_tag: activation_limit_from_string,
    Generation.c_tag: generation_from_string,
    AuthnMethod.c_tag: authn_method_from_string,
    PrincipalAuthenticationMechanism.c_tag: principal_authentication_mechanism_from_string,
    Authenticator.c_tag: authenticator_from_string,
    ComplexAuthenticator.c_tag: complex_authenticator_from_string,
    PreviousSession.c_tag: previous_session_from_string,
    ResumeSession.c_tag: resume_session_from_string,
    ZeroKnowledge.c_tag: zero_knowledge_from_string,
    SharedSecretChallengeResponse.c_tag: shared_secret_challenge_response_from_string,
    SharedSecretChallengeResponseType_.c_tag: shared_secret_challenge_response_type__from_string,
    DigSig.c_tag: dig_sig_from_string,
    AsymmetricDecryption.c_tag: asymmetric_decryption_from_string,
    AsymmetricKeyAgreement.c_tag: asymmetric_key_agreement_from_string,
    PublicKeyType_.c_tag: public_key_type__from_string,
    IPAddress.c_tag: ip_address_from_string,
    SharedSecretDynamicPlaintext.c_tag: shared_secret_dynamic_plaintext_from_string,
    AuthenticatorTransportProtocol.c_tag: authenticator_transport_protocol_from_string,
    HTTP.c_tag: http_from_string,
    IPSec.c_tag: ip_sec_from_string,
    WTLS.c_tag: wtls_from_string,
    MobileNetworkNoEncryption.c_tag: mobile_network_no_encryption_from_string,
    MobileNetworkRadioEncryption.c_tag: mobile_network_radio_encryption_from_string,
    MobileNetworkEndToEndEncryption.c_tag: mobile_network_end_to_end_encryption_from_string,
    SSL.c_tag: ssl_from_string,
    PSTN.c_tag: pstn_from_string,
    ISDN.c_tag: isdn_from_string,
    ADSL.c_tag: adsl_from_string,
    OperationalProtection.c_tag: operational_protection_from_string,
    SecurityAudit.c_tag: security_audit_from_string,
    SwitchAudit.c_tag: switch_audit_from_string,
    DeactivationCallCenter.c_tag: deactivation_call_center_from_string,
    GoverningAgreements.c_tag: governing_agreements_from_string,
    GoverningAgreementRef.c_tag: governing_agreement_ref_from_string,
    NymType_.c_tag: nym_type__from_string,
    IdentificationType_.c_tag: identification_type__from_string,
    TechnicalProtectionBaseType_.c_tag: technical_protection_base_type__from_string,
    OperationalProtectionType_.c_tag: operational_protection_type__from_string,
    GoverningAgreementsType_.c_tag: governing_agreements_type__from_string,
    GoverningAgreementRefType_.c_tag: governing_agreement_ref_type__from_string,
    AuthenticatorBaseType_.c_tag: authenticator_base_type__from_string,
    ComplexAuthenticatorType_.c_tag: complex_authenticator_type__from_string,
    AuthenticatorTransportProtocolType_.c_tag: authenticator_transport_protocol_type__from_string,
    KeyActivationType_.c_tag: key_activation_type__from_string,
    KeySharingType_.c_tag: key_sharing_type__from_string,
    PrivateKeyProtectionType_.c_tag: private_key_protection_type__from_string,
    PasswordType_.c_tag: password_type__from_string,
    RestrictedPassword.c_tag: restricted_password_from_string,
    RestrictedPasswordType_.c_tag: restricted_password_type__from_string,
    RestrictedLengthType_.c_tag: restricted_length_type__from_string,
    ActivationPinType_.c_tag: activation_pin_type__from_string,
    Alphabet.c_tag: alphabet_from_string,
    AlphabetType_.c_tag: alphabet_type__from_string,
    DeviceTypeType_.c_tag: device_type_type__from_string,
    BooleanType_.c_tag: boolean_type__from_string,
    ActivationLimitType_.c_tag: activation_limit_type__from_string,
    ActivationLimitDuration.c_tag: activation_limit_duration_from_string,
    ActivationLimitUsages.c_tag: activation_limit_usages_from_string,
    ActivationLimitSession.c_tag: activation_limit_session_from_string,
    ActivationLimitDurationType_.c_tag: activation_limit_duration_type__from_string,
    ActivationLimitUsagesType_.c_tag: activation_limit_usages_type__from_string,
    ActivationLimitSessionType_.c_tag: activation_limit_session_type__from_string,
    LengthType_.c_tag: length_type__from_string,
    MediumType_.c_tag: medium_type__from_string,
    KeyStorageType_.c_tag: key_storage_type__from_string,
    SecretKeyProtectionType_.c_tag: secret_key_protection_type__from_string,
    SecurityAuditType_.c_tag: security_audit_type__from_string,
    ExtensionOnlyType_.c_tag: extension_only_type__from_string,
    Extension.c_tag: extension_from_string,
    ExtensionType_.c_tag: extension_type__from_string,
    AuthnContextDeclarationBaseType_.c_tag: authn_context_declaration_base_type__from_string,
    AuthnMethodBaseType_.c_tag: authn_method_base_type__from_string,
    PrincipalAuthenticationMechanismType_.c_tag: principal_authentication_mechanism_type__from_string,
    TokenType_.c_tag: token_type__from_string,
    TimeSyncTokenType_.c_tag: time_sync_token_type__from_string,
}

ELEMENT_BY_TAG = {
    'AuthenticationContextDeclaration': AuthenticationContextDeclaration,
    'Identification': Identification,
    'PhysicalVerification': PhysicalVerification,
    'WrittenConsent': WrittenConsent,
    'TechnicalProtection': TechnicalProtection,
    'SecretKeyProtection': SecretKeyProtection,
    'PrivateKeyProtection': PrivateKeyProtection,
    'KeyActivation': KeyActivation,
    'KeySharing': KeySharing,
    'KeyStorage': KeyStorage,
    'SubscriberLineNumber': SubscriberLineNumber,
    'UserSuffix': UserSuffix,
    'Password': Password,
    'ActivationPin': ActivationPin,
    'Token': Token,
    'TimeSyncToken': TimeSyncToken,
    'Smartcard': Smartcard,
    'Length': Length,
    'ActivationLimit': ActivationLimit,
    'Generation': Generation,
    'AuthnMethod': AuthnMethod,
    'PrincipalAuthenticationMechanism': PrincipalAuthenticationMechanism,
    'Authenticator': Authenticator,
    'ComplexAuthenticator': ComplexAuthenticator,
    'PreviousSession': PreviousSession,
    'ResumeSession': ResumeSession,
    'ZeroKnowledge': ZeroKnowledge,
    'SharedSecretChallengeResponse': SharedSecretChallengeResponse,
    'SharedSecretChallengeResponseType': SharedSecretChallengeResponseType_,
    'DigSig': DigSig,
    'AsymmetricDecryption': AsymmetricDecryption,
    'AsymmetricKeyAgreement': AsymmetricKeyAgreement,
    'PublicKeyType': PublicKeyType_,
    'IPAddress': IPAddress,
    'SharedSecretDynamicPlaintext': SharedSecretDynamicPlaintext,
    'AuthenticatorTransportProtocol': AuthenticatorTransportProtocol,
    'HTTP': HTTP,
    'IPSec': IPSec,
    'WTLS': WTLS,
    'MobileNetworkNoEncryption': MobileNetworkNoEncryption,
    'MobileNetworkRadioEncryption': MobileNetworkRadioEncryption,
    'MobileNetworkEndToEndEncryption': MobileNetworkEndToEndEncryption,
    'SSL': SSL,
    'PSTN': PSTN,
    'ISDN': ISDN,
    'ADSL': ADSL,
    'OperationalProtection': OperationalProtection,
    'SecurityAudit': SecurityAudit,
    'SwitchAudit': SwitchAudit,
    'DeactivationCallCenter': DeactivationCallCenter,
    'GoverningAgreements': GoverningAgreements,
    'GoverningAgreementRef': GoverningAgreementRef,
    'nymType': NymType_,
    'IdentificationType': IdentificationType_,
    'TechnicalProtectionBaseType': TechnicalProtectionBaseType_,
    'OperationalProtectionType': OperationalProtectionType_,
    'GoverningAgreementsType': GoverningAgreementsType_,
    'GoverningAgreementRefType': GoverningAgreementRefType_,
    'AuthenticatorBaseType': AuthenticatorBaseType_,
    'ComplexAuthenticatorType': ComplexAuthenticatorType_,
    'AuthenticatorTransportProtocolType': AuthenticatorTransportProtocolType_,
    'KeyActivationType': KeyActivationType_,
    'KeySharingType': KeySharingType_,
    'PrivateKeyProtectionType': PrivateKeyProtectionType_,
    'PasswordType': PasswordType_,
    'RestrictedPassword': RestrictedPassword,
    'RestrictedPasswordType': RestrictedPasswordType_,
    'RestrictedLengthType': RestrictedLengthType_,
    'ActivationPinType': ActivationPinType_,
    'Alphabet': Alphabet,
    'AlphabetType': AlphabetType_,
    'DeviceTypeType': DeviceTypeType_,
    'booleanType': BooleanType_,
    'ActivationLimitType': ActivationLimitType_,
    'ActivationLimitDuration': ActivationLimitDuration,
    'ActivationLimitUsages': ActivationLimitUsages,
    'ActivationLimitSession': ActivationLimitSession,
    'ActivationLimitDurationType': ActivationLimitDurationType_,
    'ActivationLimitUsagesType': ActivationLimitUsagesType_,
    'ActivationLimitSessionType': ActivationLimitSessionType_,
    'LengthType': LengthType_,
    'mediumType': MediumType_,
    'KeyStorageType': KeyStorageType_,
    'SecretKeyProtectionType': SecretKeyProtectionType_,
    'SecurityAuditType': SecurityAuditType_,
    'ExtensionOnlyType': ExtensionOnlyType_,
    'Extension': Extension,
    'ExtensionType': ExtensionType_,
    'AuthnContextDeclarationBaseType': AuthnContextDeclarationBaseType_,
    'AuthnMethodBaseType': AuthnMethodBaseType_,
    'PrincipalAuthenticationMechanismType': PrincipalAuthenticationMechanismType_,
    'TokenType': TokenType_,
    'TimeSyncTokenType': TimeSyncTokenType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = cache
#!/usr/bin/env python

import shelve
from saml2.ident import code, decode
from saml2 import time_util, SAMLError
import logging

logger = logging.getLogger(__name__)

# The assumption is that any subject may consist of data 
# gathered from several different sources, all with their own
# timeout time.


class ToOld(SAMLError):
    pass


class CacheError(SAMLError):
    pass


class Cache(object):
    def __init__(self, filename=None):
        if filename:
            self._db = shelve.open(filename, writeback=True)
            self._sync = True
        else:
            self._db = {}
            self._sync = False
        
    def delete(self, name_id):
        """

        :param name_id: The subject identifier, a NameID instance
        """
        del self._db[code(name_id)]

        if self._sync:
            try:
                self._db.sync()
            except AttributeError:
                pass
        
    def get_identity(self, name_id, entities=None,
                     check_not_on_or_after=True):
        """ Get all the identity information that has been received and 
        are still valid about the subject.
        
        :param name_id: The subject identifier, a NameID instance
        :param entities: The identifiers of the entities whoes assertions are
            interesting. If the list is empty all entities are interesting.
        :return: A 2-tuple consisting of the identity information (a
            dictionary of attributes and values) and the list of entities 
            whoes information has timed out.
        """
        if not entities:
            try:
                cni = code(name_id)
                entities = self._db[cni].keys()
            except KeyError:
                return {}, []
            
        res = {}
        oldees = []
        for entity_id in entities:
            try:
                info = self.get(name_id, entity_id, check_not_on_or_after)
            except ToOld:
                oldees.append(entity_id)
                continue

            if not info:
                oldees.append(entity_id)
                continue
                
            for key, vals in info["ava"].items():            
                try:
                    tmp = set(res[key]).union(set(vals))
                    res[key] = list(tmp)
                except KeyError:
                    res[key] = vals
        return res, oldees
        
    def get(self, name_id, entity_id, check_not_on_or_after=True):
        """ Get session information about a subject gotten from a
        specified IdP/AA.
        
        :param name_id: The subject identifier, a NameID instance
        :param entity_id: The identifier of the entity_id
        :param check_not_on_or_after: if True it will check if this
             subject is still valid or if it is too old. Otherwise it
             will not check this. True by default.
        :return: The session information
        """
        cni = code(name_id)
        (timestamp, info) = self._db[cni][entity_id]
        if check_not_on_or_after and time_util.after(timestamp):
            raise ToOld("past %s" % timestamp)

        return info or None
    
    def set(self, name_id, entity_id, info, not_on_or_after=0):
        """ Stores session information in the cache. Assumes that the name_id
        is unique within the context of the Service Provider.
        
        :param name_id: The subject identifier, a NameID instance
        :param entity_id: The identifier of the entity_id/receiver of an 
            assertion
        :param info: The session info, the assertion is part of this
        :param not_on_or_after: A time after which the assertion is not valid.
        """
        cni = code(name_id)
        if cni not in self._db:
            self._db[cni] = {}

        self._db[cni][entity_id] = (not_on_or_after, info)
        if self._sync:
            try:
                self._db.sync()
            except AttributeError:
                pass
            
    def reset(self, name_id, entity_id):
        """ Scrap the assertions received from a IdP or an AA about a special
        subject.
        
        :param name_id: The subject identifier, a NameID instance
        :param entity_id: The identifier of the entity_id of the assertion
        :return:
        """
        self.set(name_id, entity_id, {}, 0)
            
    def entities(self, name_id):
        """ Returns all the entities of assertions for a subject, disregarding
        whether the assertion still is valid or not.
        
        :param name_id: The subject identifier, a NameID instance
        :return: A possibly empty list of entity identifiers
        """
        cni = code(name_id)
        return self._db[cni].keys()
        
    def receivers(self, name_id):
        """ Another name for entities() just to make it more logic in the IdP 
            scenario """
        return self.entities(name_id)
        
    def active(self, name_id, entity_id):
        """ Returns the status of assertions from a specific entity_id.
        
        :param name_id: The ID of the subject
        :param entity_id: The entity ID of the entity_id of the assertion
        :return: True or False depending on if the assertion is still
            valid or not.
        """
        try:
            cni = code(name_id)
            (timestamp, info) = self._db[cni][entity_id]
        except KeyError:
            return False

        if not info:
            return False
        else:
            return time_util.not_on_or_after(timestamp)
        
    def subjects(self):
        """ Return identifiers for all the subjects that are in the cache.
        
        :return: list of subject identifiers
        """
        return [decode(c) for c in self._db.keys()]

########NEW FILE########
__FILENAME__ = cert
__author__ = 'haho0032'

import base64
import datetime
import dateutil.parser
import pytz
from OpenSSL import crypto
from os.path import join
from os import remove
from Crypto.Util import asn1

class WrongInput(Exception):
    pass


class CertificateError(Exception):
    pass


class PayloadError(Exception):
    pass


class OpenSSLWrapper(object):
    def __init__(self):
        pass

    def create_certificate(self, cert_info, request=False, valid_from=0,
                           valid_to=315360000, sn=1, key_length=1024,
                           hash_alg="sha256", write_to_file=False, cert_dir="",
                           cipher_passphrase=None):
        """
        Can create certificate requests, to be signed later by another
        certificate with the method
        create_cert_signed_certificate. If request is True.

        Can also create self signed root certificates if request is False.
        This is default behaviour.

        :param cert_info:         Contains information about the certificate.
                                  Is a dictionary that must contain the keys:
                                  cn                = Common name. This part
                                  must match the host being authenticated
                                  country_code      = Two letter description
                                  of the country.
                                  state             = State
                                  city              = City
                                  organization      = Organization, can be a
                                  company name.
                                  organization_unit = A unit at the
                                  organization, can be a department.
                                  Example:
                                                    cert_info_ca = {
                                                        "cn": "company.com",
                                                        "country_code": "se",
                                                        "state": "AC",
                                                        "city": "Dorotea",
                                                        "organization":
                                                        "Company",
                                                        "organization_unit":
                                                        "Sales"
                                                    }
        :param request:           True if this is a request for certificate,
                                  that should be signed.
                                  False if this is a self signed certificate,
                                  root certificate.
        :param valid_from:        When the certificate starts to be valid.
                                  Amount of seconds from when the
                                  certificate is generated.
        :param valid_to:          How long the certificate will be valid from
                                  when it is generated.
                                  The value is in seconds. Default is
                                  315360000 seconds, a.k.a 10 years.
        :param sn:                Serial number for the certificate. Default
                                  is 1.
        :param key_length:        Length of the key to be generated. Defaults
                                  to 1024.
        :param hash_alg:          Hash algorithm to use for the key. Default
                                  is sha256.
        :param write_to_file:     True if you want to write the certificate
                                  to a file. The method will then return
                                  a tuple with path to certificate file and
                                  path to key file.
                                  False if you want to get the result as
                                  strings. The method will then return a tuple
                                  with the certificate string and the key as
                                  string.
                                  WILL OVERWRITE ALL EXISTING FILES WITHOUT
                                  ASKING!
        :param cert_dir:          Where to save the files if write_to_file is
                                  true.
        :param cipher_passphrase  A dictionary with cipher and passphrase.
        Example::
                {"cipher": "blowfish", "passphrase": "qwerty"}

        :return:                  string representation of certificate,
                                  string representation of private key
                                  if write_to_file parameter is False otherwise
                                  path to certificate file, path to private
                                  key file
        """
        cn = cert_info["cn"]

        c_f = None
        k_f = None

        if write_to_file:
            cert_file = "%s.crt" % cn
            key_file = "%s.key" % cn
            try:
                remove(cert_file)
            except:
                pass
            try:
                remove(key_file)
            except:
                pass
            c_f = join(cert_dir, cert_file)
            k_f = join(cert_dir, key_file)


        # create a key pair
        k = crypto.PKey()
        k.generate_key(crypto.TYPE_RSA, key_length)

        # create a self-signed cert
        cert = crypto.X509()

        if request:
            cert = crypto.X509Req()

        if (len(cert_info["country_code"]) != 2):
            raise WrongInput("Country code must be two letters!")
        cert.get_subject().C = cert_info["country_code"]
        cert.get_subject().ST = cert_info["state"]
        cert.get_subject().L = cert_info["city"]
        cert.get_subject().O = cert_info["organization"]
        cert.get_subject().OU = cert_info["organization_unit"]
        cert.get_subject().CN = cn
        if not request:
            cert.set_serial_number(sn)
            cert.gmtime_adj_notBefore(valid_from)  #Valid before present time
            cert.gmtime_adj_notAfter(valid_to)  #3 650 days
            cert.set_issuer(cert.get_subject())
        cert.set_pubkey(k)
        cert.sign(k, hash_alg)

        filesCreated = False
        try:
            if request:
                tmp_cert = crypto.dump_certificate_request(crypto.FILETYPE_PEM,
                                                           cert)
            else:
                tmp_cert = crypto.dump_certificate(crypto.FILETYPE_PEM, cert)
            tmp_key = None
            if cipher_passphrase is not None:
                tmp_key = crypto.dump_privatekey(crypto.FILETYPE_PEM, k,
                                                 cipher_passphrase["cipher"],
                                                 cipher_passphrase[
                                                     "passphrase"])
            else:
                tmp_key = crypto.dump_privatekey(crypto.FILETYPE_PEM, k)
            if write_to_file:
                fc = open(c_f, "wt")
                fk = open(k_f, "wt")

                if request:
                    fc.write(tmp_cert)
                else:
                    fc.write(tmp_cert)
                fk.write(tmp_key)
                filesCreated = True
                try:
                    fc.close()
                except:
                    pass

                try:
                    fk.close()
                except:
                    pass
                return c_f, k_f
            return tmp_cert, tmp_key
        except Exception as ex:
            raise CertificateError("Certificate cannot be generated.", ex)

    def write_str_to_file(self, file, str_data):
        f = open(file, "wt")
        f.write(str_data)
        f.close()

    def read_str_from_file(self, file, type="pem"):
        f = open(file)
        str_data = f.read()
        f.close()

        if type == "pem":
            return str_data

        if type in ["der", "cer", "crt"]:
            return base64.b64encode(str(str_data))


    def create_cert_signed_certificate(self, sign_cert_str, sign_key_str,
                                       request_cert_str, hash_alg="sha256",
                                       valid_from=0, valid_to=315360000, sn=1,
                                       passphrase=None):

        """
        Will sign a certificate request with a give certificate.
        :param sign_cert_str:     This certificate will be used to sign with.
                                  Must be a string representation of
                                  the certificate. If you only have a file
                                  use the method read_str_from_file to
                                  get a string representation.
        :param sign_key_str:        This is the key for the ca_cert_str
                                  represented as a string.
                                  If you only have a file use the method
                                  read_str_from_file to get a string
                                  representation.
        :param request_cert_str:  This is the prepared certificate to be
                                  signed. Must be a string representation of
                                  the requested certificate. If you only have
                                  a file use the method read_str_from_file
                                  to get a string representation.
        :param hash_alg:          Hash algorithm to use for the key. Default
                                  is sha256.
        :param valid_from:        When the certificate starts to be valid.
                                  Amount of seconds from when the
                                  certificate is generated.
        :param valid_to:          How long the certificate will be valid from
                                  when it is generated.
                                  The value is in seconds. Default is
                                  315360000 seconds, a.k.a 10 years.
        :param sn:                Serial number for the certificate. Default
                                  is 1.
        :param passphrase:        Password for the private key in sign_key_str.
        :return:                  String representation of the signed
                                  certificate.
        """
        ca_cert = crypto.load_certificate(crypto.FILETYPE_PEM, sign_cert_str)
        ca_key = None
        if passphrase is not None:
            ca_key = crypto.load_privatekey(crypto.FILETYPE_PEM, sign_key_str,
                                            passphrase)
        else:
            ca_key = crypto.load_privatekey(crypto.FILETYPE_PEM, sign_key_str)
        req_cert = crypto.load_certificate_request(crypto.FILETYPE_PEM,
                                                   request_cert_str)

        cert = crypto.X509()
        cert.set_subject(req_cert.get_subject())
        cert.set_serial_number(sn)
        cert.gmtime_adj_notBefore(valid_from)
        cert.gmtime_adj_notAfter(valid_to)
        cert.set_issuer(ca_cert.get_subject())
        cert.set_pubkey(req_cert.get_pubkey())
        cert.sign(ca_key, hash_alg)

        return crypto.dump_certificate(crypto.FILETYPE_PEM, cert)

    def verify_chain(self, cert_chain_str_list, cert_str):
        """

        :param cert_chain_str_list: Must be a list of certificate strings,
        where the first certificate to be validate
        is in the beginning and the root certificate is last.
        :param cert_str: The certificate to be validated.
        :return:
        """
        for tmp_cert_str in cert_chain_str_list:
            valid, message = self.verify(tmp_cert_str, cert_str)
            if not valid:
                return False, message
            else:
                cert_str = tmp_cert_str
            return (True,
                    "Signed certificate is valid and correctly signed by CA "
                    "certificate.")

    def certificate_not_valid_yet(self, cert):
        starts_to_be_valid = dateutil.parser.parse(cert.get_notBefore())
        now = pytz.UTC.localize(datetime.datetime.utcnow())
        if starts_to_be_valid < now:
            return False
        return True


    def verify(self, signing_cert_str, cert_str):
        """
        Verifies if a certificate is valid and signed by a given certificate.

        :param signing_cert_str: This certificate will be used to verify the
                                  signature. Must be a string representation
                                 of the certificate. If you only have a file
                                 use the method read_str_from_file to
                                 get a string representation.
        :param cert_str:         This certificate will be verified if it is
                                  correct. Must be a string representation
                                 of the certificate. If you only have a file
                                 use the method read_str_from_file to
                                 get a string representation.
        :return:                 Valid, Message
                                 Valid = True if the certificate is valid,
                                 otherwise false.
                                 Message = Why the validation failed.
        """
        try:
            ca_cert = crypto.load_certificate(crypto.FILETYPE_PEM,
                                              signing_cert_str)
            cert = crypto.load_certificate(crypto.FILETYPE_PEM, cert_str)

            if self.certificate_not_valid_yet(ca_cert):
                return False, "CA certificate is not valid yet."

            if ca_cert.has_expired() == 1:
                return False, "CA certificate is expired."

            if cert.has_expired() == 1:
                return False, "The signed certificate is expired."

            if self.certificate_not_valid_yet(cert):
                return False, "The signed certificate is not valid yet."

            if ca_cert.get_subject().CN == cert.get_subject().CN:
                return False, ("CN may not be equal for CA certificate and the "
                               "signed certificate.")

            cert_algorithm = cert.get_signature_algorithm()

            cert_asn1 = crypto.dump_certificate(crypto.FILETYPE_ASN1, cert)

            der_seq = asn1.DerSequence()
            der_seq.decode(cert_asn1)

            cert_certificate = der_seq[0]
            #cert_signature_algorithm=der_seq[1]
            cert_signature = der_seq[2]

            cert_signature_decoded = asn1.DerObject()
            cert_signature_decoded.decode(cert_signature)

            signature_payload = cert_signature_decoded.payload

            if signature_payload[0] != '\x00':
                return (False,
                       "The certificate should not contain any unused bits.")

            signature = signature_payload[1:]

            try:
                crypto.verify(ca_cert, signature, cert_certificate,
                              cert_algorithm)
                return True, "Signed certificate is valid and correctly signed by CA certificate."
            except crypto.Error, e:
                return False, "Certificate is incorrectly signed."
        except Exception, e:
            return False, "Certificate is not valid for an unknown reason."
########NEW FILE########
__FILENAME__ = client
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Contains classes and functions that a SAML2.0 Service Provider (SP) may use
to conclude its tasks.
"""
from saml2.request import LogoutRequest
import saml2

from saml2 import saml, SAMLError
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_SOAP

from saml2.ident import decode
from saml2.httpbase import HTTPError
from saml2.s_utils import sid
from saml2.s_utils import status_message_factory
from saml2.s_utils import success_status_factory
from saml2.samlp import STATUS_REQUEST_DENIED
from saml2.samlp import STATUS_UNKNOWN_PRINCIPAL
from saml2.time_util import not_on_or_after
from saml2.saml import AssertionIDRef
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.client_base import Base
from saml2.client_base import LogoutError
from saml2.client_base import NoServiceDefined
from saml2.mdstore import destinations

try:
    from urlparse import parse_qs
except ImportError:
    # Compatibility with Python <= 2.5
    from cgi import parse_qs

import logging
logger = logging.getLogger(__name__)


class Saml2Client(Base):
    """ The basic pySAML2 service provider class """

    def prepare_for_authenticate(self, entityid=None, relay_state="",
                                 binding=saml2.BINDING_HTTP_REDIRECT, vorg="",
                                 nameid_format=NAMEID_FORMAT_PERSISTENT,
                                 scoping=None, consent=None, extensions=None,
                                 sign=None,
                                 response_binding=saml2.BINDING_HTTP_POST,
                                 **kwargs):
        """ Makes all necessary preparations for an authentication request.

        :param entityid: The entity ID of the IdP to send the request to
        :param relay_state: To where the user should be returned after
            successfull log in.
        :param binding: Which binding to use for sending the request
        :param vorg: The entity_id of the virtual organization I'm a member of
        :param scoping: For which IdPs this query are aimed.
        :param consent: Whether the principal have given her consent
        :param extensions: Possible extensions
        :param sign: Whether the request should be signed or not.
        :param response_binding: Which binding to use for receiving the response
        :param kwargs: Extra key word arguments
        :return: session id and AuthnRequest info
        """

        destination = self._sso_location(entityid, binding)

        reqid, req = self.create_authn_request(destination, vorg, scoping,
                                        response_binding, nameid_format,
                                        consent=consent, extensions=extensions,
                                        sign=sign, **kwargs)
        _req_str = "%s" % req

        logger.info("AuthNReq: %s" % _req_str)

        info = self.apply_binding(binding, _req_str, destination, relay_state)

        return reqid, info

    def global_logout(self, name_id, reason="", expire=None, sign=None):
        """ More or less a layer of indirection :-/
        Bootstrapping the whole thing by finding all the IdPs that should
        be notified.
        
        :param name_id: The identifier of the subject that wants to be
            logged out.
        :param reason: Why the subject wants to log out
        :param expire: The latest the log out should happen.
            If this time has passed don't bother.
        :param sign: Whether the request should be signed or not.
            This also depends on what binding is used.
        :return: Depends on which binding is used:
            If the HTTP redirect binding then a HTTP redirect,
            if SOAP binding has been used the just the result of that
            conversation. 
        """

        if isinstance(name_id, basestring):
            name_id = decode(name_id)

        logger.info("logout request for: %s" % name_id)

        # find out which IdPs/AAs I should notify
        entity_ids = self.users.issuers_of_info(name_id)
        return self.do_logout(name_id, entity_ids, reason, expire, sign)
        
    def do_logout(self, name_id, entity_ids, reason, expire, sign=None,
                  expected_binding=None):
        """

        :param name_id: Identifier of the Subject (a NameID instance)
        :param entity_ids: List of entity ids for the IdPs that have provided
            information concerning the subject
        :param reason: The reason for doing the logout
        :param expire: Try to logout before this time.
        :param sign: Whether to sign the request or not
        :param expected_binding: Specify the expected binding then not try it
            all
        :return:
        """
        # check time
        if not not_on_or_after(expire):  # I've run out of time
            # Do the local logout anyway
            self.local_logout(name_id)
            return 0, "504 Gateway Timeout", [], []
            
        not_done = entity_ids[:]
        responses = {}

        for entity_id in entity_ids:
            logger.debug("Logout from '%s'" % entity_id)
            # for all where I can use the SOAP binding, do those first
            for binding in [BINDING_SOAP, BINDING_HTTP_POST,
                            BINDING_HTTP_REDIRECT]:
                if expected_binding and binding != expected_binding:
                    continue
                try:
                    srvs = self.metadata.single_logout_service(entity_id,
                                                               binding,
                                                               "idpsso")
                except:
                    srvs = None

                if not srvs:
                    logger.debug("No SLO '%s' service" % binding)
                    continue

                destination = destinations(srvs)[0]
                logger.info("destination to provider: %s" % destination)
                req_id, request = self.create_logout_request(
                    destination, entity_id, name_id=name_id, reason=reason,
                    expire=expire)
                
                #to_sign = []
                if binding.startswith("http://"):
                    sign = True

                if sign is None:
                    sign = self.logout_requests_signed

                if sign:
                    srequest = self.sign(request)
                else:
                    srequest = "%s" % request

                relay_state = self._relay_state(req_id)

                http_info = self.apply_binding(binding, srequest, destination,
                                               relay_state)

                if binding == BINDING_SOAP:
                    response = self.send(**http_info)

                    if response and response.status_code == 200:
                        not_done.remove(entity_id)
                        response = response.text
                        logger.info("Response: %s" % response)
                        res = self.parse_logout_request_response(response)
                        responses[entity_id] = res
                    else:
                        logger.info("NOT OK response from %s" % destination)

                else:
                    self.state[req_id] = {"entity_id": entity_id,
                                              "operation": "SLO",
                                              "entity_ids": entity_ids,
                                              "name_id": name_id,
                                              "reason": reason,
                                              "not_on_of_after": expire,
                                              "sign": sign}

                    responses[entity_id] = (binding, http_info)
                    not_done.remove(entity_id)

                # only try one binding
                break

        if not_done:
            # upstream should try later
            raise LogoutError("%s" % (entity_ids,))
        
        return responses

    def local_logout(self, name_id):
        """ Remove the user from the cache, equals local logout 
        
        :param name_id: The identifier of the subject
        """
        self.users.remove_person(name_id)
        return True

    def is_logged_in(self, name_id):
        """ Check if user is in the cache
        
        :param name_id: The identifier of the subject
        """
        identity = self.users.get_identity(name_id)[0]
        return bool(identity)
        
    def handle_logout_response(self, response):
        """ handles a Logout response 
        
        :param response: A response.Response instance
        :return: 4-tuple of (session_id of the last sent logout request,
            response message, response headers and message)
        """

        logger.info("state: %s" % (self.state,))
        status = self.state[response.in_response_to]
        logger.info("status: %s" % (status,))
        issuer = response.issuer()
        logger.info("issuer: %s" % issuer)
        del self.state[response.in_response_to]
        if status["entity_ids"] == [issuer]:  # done
            self.local_logout(status["name_id"])
            return 0, "200 Ok", [("Content-type", "text/html")], []
        else:
            status["entity_ids"].remove(issuer)
            return self.do_logout(status["name_id"], status["entity_ids"],
                                  status["reason"], status["not_on_or_after"],
                                  status["sign"])

    def _use_soap(self, destination, query_type, **kwargs):
        _create_func = getattr(self, "create_%s" % query_type)
        _response_func = getattr(self, "parse_%s_response" % query_type)
        try:
            response_args = kwargs["response_args"]
            del kwargs["response_args"]
        except KeyError:
            response_args = None

        qid, query = _create_func(destination, **kwargs)

        response = self.send_using_soap(query, destination)

        if response.status_code == 200:
            if not response_args:
                response_args = {"binding": BINDING_SOAP}
            else:
                response_args["binding"] = BINDING_SOAP

            logger.info("Verifying response")
            if response_args:
                response = _response_func(response.text, **response_args)
            else:
                response = _response_func(response.text)
        else:
            raise HTTPError("%d:%s" % (response.status_code, response.error))

        if response:
            #not_done.remove(entity_id)
            logger.info("OK response from %s" % destination)
            return response
        else:
            logger.info("NOT OK response from %s" % destination)

        return None

    #noinspection PyUnusedLocal
    def do_authz_decision_query(self, entity_id, action,
                                subject_id, nameid_format,
                                evidence=None, resource=None,
                                sp_name_qualifier=None,
                                name_qualifier=None,
                                consent=None, extensions=None, sign=False):

        subject = saml.Subject(
            name_id=saml.NameID(text=subject_id, format=nameid_format,
                                sp_name_qualifier=sp_name_qualifier,
                                name_qualifier=name_qualifier))

        srvs = self.metadata.authz_service(entity_id, BINDING_SOAP)
        for dest in destinations(srvs):
            resp = self._use_soap(dest, "authz_decision_query",
                                  action=action, evidence=evidence,
                                  resource=resource, subject=subject)
            if resp:
                return resp

        return None

    def do_assertion_id_request(self, assertion_ids, entity_id,
                                consent=None, extensions=None, sign=False):

        srvs = self.metadata.assertion_id_request_service(entity_id,
                                                          BINDING_SOAP)
        if not srvs:
            raise NoServiceDefined("%s: %s" % (entity_id,
                                               "assertion_id_request_service"))

        if isinstance(assertion_ids, basestring):
            assertion_ids = [assertion_ids]

        _id_refs = [AssertionIDRef(_id) for _id in assertion_ids]

        for destination in destinations(srvs):
            res = self._use_soap(destination, "assertion_id_request",
                                 assertion_id_refs=_id_refs, consent=consent,
                                 extensions=extensions, sign=sign)
            if res:
                return res

        return None

    def do_authn_query(self, entity_id,
                       consent=None, extensions=None, sign=False):

        srvs = self.metadata.authn_request_service(entity_id, BINDING_SOAP)

        for destination in destinations(srvs):
            resp = self._use_soap(destination, "authn_query", consent=consent,
                                  extensions=extensions, sign=sign)
            if resp:
                return resp

        return None

    def do_attribute_query(self, entityid, subject_id,
                           attribute=None, sp_name_qualifier=None,
                           name_qualifier=None, nameid_format=None,
                           real_id=None, consent=None, extensions=None,
                           sign=False, binding=BINDING_SOAP):
        """ Does a attribute request to an attribute authority, this is
        by default done over SOAP.

        :param entityid: To whom the query should be sent
        :param subject_id: The identifier of the subject
        :param attribute: A dictionary of attributes and values that is
            asked for
        :param sp_name_qualifier: The unique identifier of the
            service provider or affiliation of providers for whom the
            identifier was generated.
        :param name_qualifier: The unique identifier of the identity
            provider that generated the identifier.
        :param nameid_format: The format of the name ID
        :param real_id: The identifier which is the key to this entity in the
            identity database
        :param binding: Which binding to use
        :return: The attributes returned if BINDING_SOAP was used.
            HTTP args if BINDING_HTT_POST was used.
        """

        if real_id:
            response_args = {"real_id": real_id}
        else:
            response_args = {}

        if not binding:
            binding, destination = self.pick_binding("attribute_service",
                                                     None,
                                                     "attribute_authority",
                                                     entity_id=entityid)
        else:
            srvs = self.metadata.attribute_service(entityid, binding)
            if srvs is []:
                raise SAMLError("No attribute service support at entity")

            destination = destinations(srvs)[0]

        if binding == BINDING_SOAP:
            return self._use_soap(destination, "attribute_query",
                                  consent=consent, extensions=extensions,
                                  sign=sign, subject_id=subject_id,
                                  attribute=attribute,
                                  sp_name_qualifier=sp_name_qualifier,
                                  name_qualifier=name_qualifier,
                                  nameid_format=nameid_format,
                                  response_args=response_args)
        elif binding == BINDING_HTTP_POST:
            mid = sid()
            query = self.create_attribute_query(destination, subject_id,
                                                attribute, mid, consent,
                                                extensions, sign)
            self.state[query.id] = {"entity_id": entityid,
                                    "operation": "AttributeQuery",
                                    "subject_id": subject_id,
                                    "sign": sign}
            relay_state = self._relay_state(query.id)
            return self.apply_binding(binding, "%s" % query, destination,
                                      relay_state)
        else:
            raise SAMLError("Unsupported binding")

    def handle_logout_request(self, request, name_id, binding, sign=False,
                              relay_state=""):
        """
        Deal with a LogoutRequest

        :param request: The request as text string
        :param name_id: The id of the current user
        :param binding: Which binding the message came in over
        :param sign: Whether the response will be signed or not
        :return: Keyword arguments which can be used to send the response
            what's returned follow different patterns for different bindings.
            If the binding is BINDIND_SOAP, what is returned looks like this::

                {
                    "data": <the SOAP enveloped response>
                    "url": "",
                    'headers': [('content-type', 'application/soap+xml')]
                    'method': "POST
                }
        """
        logger.info("logout request: %s" % request)

        _req = self._parse_request(request, LogoutRequest,
                                   "single_logout_service", binding)

        if _req.message.name_id == name_id:
            try:
                if self.local_logout(name_id):
                    status = success_status_factory()
                else:
                    status = status_message_factory("Server error",
                                                    STATUS_REQUEST_DENIED)
            except KeyError:
                status = status_message_factory("Server error",
                                                STATUS_REQUEST_DENIED)
        else:
            status = status_message_factory("Wrong user",
                                            STATUS_UNKNOWN_PRINCIPAL)

        if binding == BINDING_SOAP:
            response_bindings = [BINDING_SOAP]
        elif binding == BINDING_HTTP_POST or BINDING_HTTP_REDIRECT:
            response_bindings = [BINDING_HTTP_POST, BINDING_HTTP_REDIRECT]
        else:
            response_bindings = self.config.preferred_binding[
                "single_logout_service"]

        response = self.create_logout_response(_req.message, response_bindings,
                                               status, sign)
        rinfo = self.response_args(_req.message, response_bindings)

        return self.apply_binding(rinfo["binding"], response,
                                  rinfo["destination"], relay_state,
                                  response=True)

########NEW FILE########
__FILENAME__ = client_base
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Contains classes and functions that a SAML2.0 Service Provider (SP) may use
to conclude its tasks.
"""
import threading
from urllib import urlencode
from urlparse import urlparse

from saml2.entity import Entity

from saml2.mdstore import destinations
from saml2.profile import paos, ecp
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2.samlp import AuthnQuery
from saml2.samlp import NameIDMappingRequest
from saml2.samlp import AttributeQuery
from saml2.samlp import AuthzDecisionQuery
from saml2.samlp import AuthnRequest

import saml2
import time
from saml2.soap import make_soap_enveloped_saml_thingy

from urlparse import parse_qs

from saml2.s_utils import signature, UnravelError
from saml2.s_utils import do_attributes

from saml2 import samlp, BINDING_SOAP, SAMLError
from saml2 import saml
from saml2 import soap
from saml2.population import Population

from saml2.response import AttributeResponse, StatusError
from saml2.response import AuthzResponse
from saml2.response import AssertionIDResponse
from saml2.response import AuthnQueryResponse
from saml2.response import NameIDMappingResponse
from saml2.response import AuthnResponse

from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_PAOS
import logging

logger = logging.getLogger(__name__)

SSO_BINDING = saml2.BINDING_HTTP_REDIRECT

FORM_SPEC = """<form method="post" action="%s">
   <input type="hidden" name="SAMLRequest" value="%s" />
   <input type="hidden" name="RelayState" value="%s" />
   <input type="submit" value="Submit" />
</form>"""

LAX = False

ECP_SERVICE = "urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp"
ACTOR = "http://schemas.xmlsoap.org/soap/actor/next"
MIME_PAOS = "application/vnd.paos+xml"


class IdpUnspecified(SAMLError):
    pass


class VerifyError(SAMLError):
    pass


class LogoutError(SAMLError):
    pass


class NoServiceDefined(SAMLError):
    pass


class Base(Entity):
    """ The basic pySAML2 service provider class """

    def __init__(self, config=None, identity_cache=None, state_cache=None,
                 virtual_organization="", config_file=""):
        """
        :param config: A saml2.config.Config instance
        :param identity_cache: Where the class should store identity information
        :param state_cache: Where the class should keep state information
        :param virtual_organization: A specific virtual organization
        """

        Entity.__init__(self, "sp", config, config_file, virtual_organization)

        self.users = Population(identity_cache)
        self.lock = threading.Lock()
        # for server state storage
        if state_cache is None:
            self.state = {}  # in memory storage
        else:
            self.state = state_cache

        self.logout_requests_signed = False
        self.allow_unsolicited = False
        self.authn_requests_signed = False
        self.want_assertions_signed = False
        self.want_response_signed = False
        for foo in ["allow_unsolicited", "authn_requests_signed",
                    "logout_requests_signed", "want_assertions_signed",
                    "want_response_signed"]:
            v = self.config.getattr(foo, "sp")
            if v is True or v == 'true':
                setattr(self, foo, True)

        self.artifact2response = {}

    #
    # Private methods
    #

    def _relay_state(self, session_id):
        vals = [session_id, str(int(time.time()))]
        if self.config.secret is None:
            vals.append(signature("", vals))
        else:
            vals.append(signature(self.config.secret, vals))
        return "|".join(vals)

    def _sso_location(self, entityid=None, binding=BINDING_HTTP_REDIRECT):
        if entityid:
            # verify that it's in the metadata
            srvs = self.metadata.single_sign_on_service(entityid, binding)
            if srvs:
                return destinations(srvs)[0]
            else:
                logger.info("_sso_location: %s, %s" % (entityid, binding))
                raise IdpUnspecified("No IdP to send to given the premises")

        # get the idp location from the metadata. If there is more than one
        # IdP in the configuration raise exception
        eids = self.metadata.with_descriptor("idpsso")
        if len(eids) > 1:
            raise IdpUnspecified("Too many IdPs to choose from: %s" % eids)

        try:
            srvs = self.metadata.single_sign_on_service(eids.keys()[0], binding)
            return destinations(srvs)[0]
        except IndexError:
            raise IdpUnspecified("No IdP to send to given the premises")

    def _my_name(self):
        return self.config.name

    #
    # Public API
    #

    def add_vo_information_about_user(self, name_id):
        """ Add information to the knowledge I have about the user. This is
        for Virtual organizations.

        :param name_id: The subject identifier
        :return: A possibly extended knowledge.
        """

        ava = {}
        try:
            (ava, _) = self.users.get_identity(name_id)
        except KeyError:
            pass

        # is this a Virtual Organization situation
        if self.vorg:
            if self.vorg.do_aggregation(name_id):
                # Get the extended identity
                ava = self.users.get_identity(name_id)[0]
        return ava

    #noinspection PyUnusedLocal
    def is_session_valid(self, _session_id):
        """ Place holder. Supposed to check if the session is still valid.
        """
        return True

    def service_urls(self, binding=BINDING_HTTP_POST):
        _res = self.config.endpoint("assertion_consumer_service", binding, "sp")
        if _res:
            return _res
        else:
            return None

    def create_authn_request(self, destination, vorg="", scoping=None,
                             binding=saml2.BINDING_HTTP_POST,
                             nameid_format=NAMEID_FORMAT_TRANSIENT,
                             service_url_binding=None, message_id=0,
                             consent=None, extensions=None, sign=None,
                             allow_create=False, sign_prepare=False, **kwargs):
        """ Creates an authentication request.
        
        :param destination: Where the request should be sent.
        :param vorg: The virtual organization the service belongs to.
        :param scoping: The scope of the request
        :param binding: The protocol to use for the Response !!
        :param nameid_format: Format of the NameID
        :param service_url_binding: Where the reply should be sent dependent
            on reply binding.
        :param message_id: The identifier for this request
        :param consent: Whether the principal have given her consent
        :param extensions: Possible extensions
        :param sign: Whether the request should be signed or not.
        :param sign_prepare: Whether the signature should be prepared or not.
        :param allow_create: If the identity provider is allowed, in the course
            of fulfilling the request, to create a new identifier to represent
            the principal.
        :param kwargs: Extra key word arguments
        :return: tuple of request ID and <samlp:AuthnRequest> instance
        """
        client_crt = None
        if "client_crt" in kwargs:
            client_crt = kwargs["client_crt"]

        args = {}

        try:
            args["assertion_consumer_service_url"] = kwargs[
                "assertion_consumer_service_urls"][0]
            del kwargs["assertion_consumer_service_urls"]
        except KeyError:
            try:
                args["assertion_consumer_service_url"] = kwargs[
                    "assertion_consumer_service_url"]
                del kwargs["assertion_consumer_service_url"]
            except KeyError:
                try:
                    args["attribute_consuming_service_index"] = str(kwargs[
                        "attribute_consuming_service_index"])
                    del kwargs["attribute_consuming_service_index"]
                except KeyError:
                    if service_url_binding is None:
                        service_urls = self.service_urls(binding)
                    else:
                        service_urls = self.service_urls(service_url_binding)
                    args["assertion_consumer_service_url"] = service_urls[0]

        try:
            args["provider_name"] = kwargs["provider_name"]
        except KeyError:
            if binding == BINDING_PAOS:
                pass
            else:
                args["provider_name"] = self._my_name()

        try:
            args["name_id_policy"] = kwargs["name_id_policy"]
            del kwargs["name_id_policy"]
        except KeyError:
            if allow_create:
                allow_create = "true"
            else:
                allow_create = "false"

            # Profile stuff, should be configurable
            if nameid_format is None:
                name_id_policy = samlp.NameIDPolicy(
                    allow_create=allow_create, format=NAMEID_FORMAT_TRANSIENT)
            elif nameid_format == "":
                name_id_policy = None
            else:
                name_id_policy = samlp.NameIDPolicy(allow_create=allow_create,
                                                    format=nameid_format)

            if name_id_policy and vorg:
                try:
                    name_id_policy.sp_name_qualifier = vorg
                    name_id_policy.format = saml.NAMEID_FORMAT_PERSISTENT
                except KeyError:
                    pass
            args["name_id_policy"] = name_id_policy

        if kwargs:
            _args, extensions = self._filter_args(AuthnRequest(), extensions,
                                                  **kwargs)
            args.update(_args)

        try:
            del args["id"]
        except KeyError:
            pass

        if sign is None:
            sign = self.authn_requests_signed

        if (sign and self.sec.cert_handler.generate_cert()) or \
                client_crt is not None:
            with self.lock:
                self.sec.cert_handler.update_cert(True, client_crt)
                if client_crt is not None:
                    sign_prepare = True
                return self._message(AuthnRequest, destination, message_id,
                                     consent, extensions, sign, sign_prepare,
                                     protocol_binding=binding,
                                     scoping=scoping, **args)
        return self._message(AuthnRequest, destination, message_id, consent,
                             extensions, sign, sign_prepare,
                             protocol_binding=binding,
                             scoping=scoping, **args)

    def create_attribute_query(self, destination, name_id=None,
                               attribute=None, message_id=0, consent=None,
                               extensions=None, sign=False, sign_prepare=False,
                               **kwargs):
        """ Constructs an AttributeQuery
        
        :param destination: To whom the query should be sent
        :param name_id: The identifier of the subject
        :param attribute: A dictionary of attributes and values that is
            asked for. The key are one of 4 variants:
            3-tuple of name_format,name and friendly_name,
            2-tuple of name_format and name,
            1-tuple with name or
            just the name as a string.
        :param sp_name_qualifier: The unique identifier of the
            service provider or affiliation of providers for whom the
            identifier was generated.
        :param name_qualifier: The unique identifier of the identity
            provider that generated the identifier.
        :param format: The format of the name ID
        :param message_id: The identifier of the session
        :param consent: Whether the principal have given her consent
        :param extensions: Possible extensions
        :param sign: Whether the query should be signed or not.
        :param sign_prepare: Whether the Signature element should be added.
        :return: Tuple of request ID and an AttributeQuery instance
        """

        if name_id is None:
            if "subject_id" in kwargs:
                name_id = saml.NameID(text=kwargs["subject_id"])
                for key in ["sp_name_qualifier", "name_qualifier",
                            "format"]:
                    try:
                        setattr(name_id, key, kwargs[key])
                    except KeyError:
                        pass
            else:
                raise AttributeError("Missing required parameter")
        elif isinstance(name_id, basestring):
            name_id = saml.NameID(text=name_id)
            for key in ["sp_name_qualifier", "name_qualifier", "format"]:
                try:
                    setattr(name_id, key, kwargs[key])
                except KeyError:
                    pass

        subject = saml.Subject(name_id=name_id)

        if attribute:
            attribute = do_attributes(attribute)

        return self._message(AttributeQuery, destination, message_id, consent,
                             extensions, sign, sign_prepare, subject=subject,
                             attribute=attribute)

    # MUST use SOAP for
    # AssertionIDRequest, SubjectQuery,
    # AuthnQuery, AttributeQuery, or AuthzDecisionQuery
    def create_authz_decision_query(self, destination, action,
                                    evidence=None, resource=None, subject=None,
                                    message_id=0, consent=None, extensions=None,
                                    sign=None, **kwargs):
        """ Creates an authz decision query.

        :param destination: The IdP endpoint
        :param action: The action you want to perform (has to be at least one)
        :param evidence: Why you should be able to perform the action
        :param resource: The resource you want to perform the action on
        :param subject: Who wants to do the thing
        :param message_id: Message identifier
        :param consent: If the principal gave her consent to this request
        :param extensions: Possible request extensions
        :param sign: Whether the request should be signed or not.
        :return: AuthzDecisionQuery instance
        """

        return self._message(AuthzDecisionQuery, destination, message_id,
                             consent, extensions, sign, action=action,
                             evidence=evidence, resource=resource,
                             subject=subject)

    def create_authz_decision_query_using_assertion(self, destination,
                                                    assertion, action=None,
                                                    resource=None,
                                                    subject=None, message_id=0,
                                                    consent=None,
                                                    extensions=None,
                                                    sign=False):
        """ Makes an authz decision query based on a previously received
        Assertion.

        :param destination: The IdP endpoint to send the request to
        :param assertion: An Assertion instance
        :param action: The action you want to perform (has to be at least one)
        :param resource: The resource you want to perform the action on
        :param subject: Who wants to do the thing
        :param message_id: Message identifier
        :param consent: If the principal gave her consent to this request
        :param extensions: Possible request extensions
        :param sign: Whether the request should be signed or not.
        :return: AuthzDecisionQuery instance
        """

        if action:
            if isinstance(action, basestring):
                _action = [saml.Action(text=action)]
            else:
                _action = [saml.Action(text=a) for a in action]
        else:
            _action = None

        return self.create_authz_decision_query(
            destination, _action, saml.Evidence(assertion=assertion),
            resource, subject, message_id=message_id, consent=consent,
            extensions=extensions, sign=sign)

    def create_assertion_id_request(self, assertion_id_refs, **kwargs):
        """

        :param assertion_id_refs:
        :return: One ID ref
        """

        if isinstance(assertion_id_refs, basestring):
            return 0, assertion_id_refs
        else:
            return 0, assertion_id_refs[0]

    def create_authn_query(self, subject, destination=None, authn_context=None,
                           session_index="", message_id=0, consent=None,
                           extensions=None, sign=False):
        """

        :param subject: The subject its all about as a <Subject> instance
        :param destination: The IdP endpoint to send the request to
        :param authn_context: list of <RequestedAuthnContext> instances
        :param session_index: a specified session index
        :param message_id: Message identifier
        :param consent: If the principal gave her consent to this request
        :param extensions: Possible request extensions
        :param sign: Whether the request should be signed or not.
        :return:
        """
        return self._message(AuthnQuery, destination, message_id, consent, extensions,
                             sign, subject=subject, session_index=session_index,
                             requested_authn_context=authn_context)

    def create_name_id_mapping_request(self, name_id_policy,
                                       name_id=None, base_id=None,
                                       encrypted_id=None, destination=None,
                                       message_id=0, consent=None, extensions=None,
                                       sign=False):
        """

        :param name_id_policy:
        :param name_id:
        :param base_id:
        :param encrypted_id:
        :param destination:
        :param message_id: Message identifier
        :param consent: If the principal gave her consent to this request
        :param extensions: Possible request extensions
        :param sign: Whether the request should be signed or not.
        :return:
        """

        # One of them must be present
        assert name_id or base_id or encrypted_id

        if name_id:
            return self._message(NameIDMappingRequest, destination, message_id,
                                 consent, extensions, sign,
                                 name_id_policy=name_id_policy, name_id=name_id)
        elif base_id:
            return self._message(NameIDMappingRequest, destination, message_id,
                                 consent, extensions, sign,
                                 name_id_policy=name_id_policy, base_id=base_id)
        else:
            return self._message(NameIDMappingRequest, destination, message_id,
                                 consent, extensions, sign,
                                 name_id_policy=name_id_policy,
                                 encrypted_id=encrypted_id)

    # ======== response handling ===========

    def parse_authn_request_response(self, xmlstr, binding, outstanding=None,
                                     outstanding_certs=None):
        """ Deal with an AuthnResponse

        :param xmlstr: The reply as a xml string
        :param binding: Which binding that was used for the transport
        :param outstanding: A dictionary with session IDs as keys and
            the original web request from the user before redirection
            as values.
        :return: An response.AuthnResponse or None
        """

        try:
            _ = self.config.entityid
        except KeyError:
            raise SAMLError("Missing entity_id specification")

        resp = None
        if xmlstr:
            kwargs = {
                "outstanding_queries": outstanding,
                "outstanding_certs": outstanding_certs,
                "allow_unsolicited": self.allow_unsolicited,
                "want_assertions_signed": self.want_assertions_signed,
                "want_response_signed": self.want_response_signed,
                "return_addrs": self.service_urls(),
                "entity_id": self.config.entityid,
                "attribute_converters": self.config.attribute_converters,
                "allow_unknown_attributes":
                    self.config.allow_unknown_attributes,
            }
            try:
                resp = self._parse_response(xmlstr, AuthnResponse,
                                            "assertion_consumer_service",
                                            binding, **kwargs)
            except StatusError as err:
                logger.error("SAML status error: %s" % err)
                raise
            except UnravelError:
                return None
            except Exception:
                logger.error("XML parse error")
                raise

            #logger.debug(">> %s", resp)

            if resp is None:
                return None
            elif isinstance(resp, AuthnResponse):
                self.users.add_information_about_person(resp.session_info())
                logger.info("--- ADDED person info ----")
                pass
            else:
                logger.error("Response type not supported: %s" % (
                    saml2.class_name(resp),))
        return resp

    # ------------------------------------------------------------------------
    # SubjectQuery, AuthnQuery, RequestedAuthnContext, AttributeQuery,
    # AuthzDecisionQuery all get Response as response

    def parse_authz_decision_query_response(self, response,
                                            binding=BINDING_SOAP):
        """ Verify that the response is OK
        """
        kwargs = {"entity_id": self.config.entityid,
                  "attribute_converters": self.config.attribute_converters}

        return self._parse_response(response, AuthzResponse, "", binding,
                                    **kwargs)

    def parse_authn_query_response(self, response, binding=BINDING_SOAP):
        """ Verify that the response is OK
        """
        kwargs = {"entity_id": self.config.entityid,
                  "attribute_converters": self.config.attribute_converters}

        return self._parse_response(response, AuthnQueryResponse, "", binding,
                                    **kwargs)

    def parse_assertion_id_request_response(self, response, binding):
        """ Verify that the response is OK
        """
        kwargs = {"entity_id": self.config.entityid,
                  "attribute_converters": self.config.attribute_converters}

        res = self._parse_response(response, AssertionIDResponse, "", binding,
                                   **kwargs)
        return res

    # ------------------------------------------------------------------------

    def parse_attribute_query_response(self, response, binding):
        kwargs = {"entity_id": self.config.entityid,
                  "attribute_converters": self.config.attribute_converters}

        return self._parse_response(response, AttributeResponse,
                                    "attribute_consuming_service", binding,
                                    **kwargs)

    def parse_name_id_mapping_request_response(self, txt, binding=BINDING_SOAP):
        """

        :param txt: SOAP enveloped SAML message
        :param binding: Just a placeholder, it's always BINDING_SOAP
        :return: parsed and verified <NameIDMappingResponse> instance
        """

        return self._parse_response(txt, NameIDMappingResponse, "", binding)

    # ------------------- ECP ------------------------------------------------

    def create_ecp_authn_request(self, entityid=None, relay_state="",
                                 sign=False, **kwargs):
        """ Makes an authentication request.

        :param entityid: The entity ID of the IdP to send the request to
        :param relay_state: A token that can be used by the SP to know
            where to continue the conversation with the client
        :param sign: Whether the request should be signed or not.
        :return: SOAP message with the AuthnRequest
        """

        # ----------------------------------------
        # <paos:Request>
        # ----------------------------------------
        my_url = self.service_urls(BINDING_PAOS)[0]

        # must_understand and act according to the standard
        #
        paos_request = paos.Request(must_understand="1", actor=ACTOR,
                                    response_consumer_url=my_url,
                                    service=ECP_SERVICE)

        # ----------------------------------------
        # <ecp:RelayState>
        # ----------------------------------------

        relay_state = ecp.RelayState(actor=ACTOR, must_understand="1",
                                     text=relay_state)

        # ----------------------------------------
        # <samlp:AuthnRequest>
        # ----------------------------------------

        try:
            authn_req = kwargs["authn_req"]
            try:
                req_id = authn_req.id
            except AttributeError:
                req_id = 0  # Unknown but since it's SOAP it doesn't matter
        except KeyError:
            try:
                _binding = kwargs["binding"]
            except KeyError:
                _binding = BINDING_SOAP
                kwargs["binding"] = _binding

            logger.debug("entityid: %s, binding: %s" % (entityid, _binding))

            # The IDP publishes support for ECP by using the SOAP binding on
            # SingleSignOnService
            _, location = self.pick_binding("single_sign_on_service",
                                            [_binding], entity_id=entityid)
            req_id, authn_req = self.create_authn_request(
                location, service_url_binding=BINDING_PAOS, **kwargs)

        # ----------------------------------------
        # The SOAP envelope
        # ----------------------------------------

        soap_envelope = make_soap_enveloped_saml_thingy(authn_req,
                                                        [paos_request,
                                                         relay_state])

        return req_id, "%s" % soap_envelope

    def parse_ecp_authn_response(self, txt, outstanding=None):
        rdict = soap.class_instances_from_soap_enveloped_saml_thingies(txt,
                                                                       [paos,
                                                                        ecp,
                                                                        samlp])

        _relay_state = None
        for item in rdict["header"]:
            if item.c_tag == "RelayState" and\
                    item.c_namespace == ecp.NAMESPACE:
                _relay_state = item

        response = self.parse_authn_request_response(rdict["body"],
                                                     BINDING_PAOS, outstanding)

        return response, _relay_state

    @staticmethod
    def can_handle_ecp_response(response):
        try:
            accept = response.headers["accept"]
        except KeyError:
            try:
                accept = response.headers["Accept"]
            except KeyError:
                return False

        if MIME_PAOS in accept:
            return True
        else:
            return False

    # ----------------------------------------------------------------------
    # IDP discovery
    # ----------------------------------------------------------------------

    @staticmethod
    def create_discovery_service_request(url, entity_id, **kwargs):
        """
        Created the HTTP redirect URL needed to send the user to the
        discovery service.

        :param url: The URL of the discovery service
        :param entity_id: The unique identifier of the service provider
        :param return: The discovery service MUST redirect the user agent
            to this location in response to this request
        :param policy: A parameter name used to indicate the desired behavior
            controlling the processing of the discovery service
        :param returnIDParam: A parameter name used to return the unique
            identifier of the selected identity provider to the original
            requester.
        :param isPassive: A boolean value True/False that controls
            whether the discovery service is allowed to visibly interact with
            the user agent.
        :return: A URL
        """
        args = {"entityID": entity_id}
        for key in ["policy", "returnIDParam"]:
            try:
                args[key] = kwargs[key]
            except KeyError:
                pass

        try:
            args["return"] = kwargs["return_url"]
        except KeyError:
            try:
                args["return"] = kwargs["return"]
            except KeyError:
                pass

        if "isPassive" in kwargs:
            if kwargs["isPassive"]:
                args["isPassive"] = "true"
            else:
                args["isPassive"] = "false"

        params = urlencode(args)
        return "%s?%s" % (url, params)

    @staticmethod
    def parse_discovery_service_response(url="", query="",
                                         returnIDParam="entityID"):
        """
        Deal with the response url from a Discovery Service

        :param url: the url the user was redirected back to or
        :param query: just the query part of the URL.
        :param returnIDParam: This is where the identifier of the IdP is
            place if it was specified in the query. Default is 'entityID'
        :return: The IdP identifier or "" if none was given
        """

        if url:
            part = urlparse(url)
            qsd = parse_qs(part[4])
        elif query:
            qsd = parse_qs(query)
        else:
            qsd = {}

        try:
            return qsd[returnIDParam][0]
        except KeyError:
            return ""

########NEW FILE########
__FILENAME__ = config
#!/usr/bin/env python

__author__ = 'rolandh'

import copy
import sys
import os
import re
import logging
import logging.handlers

from importlib import import_module

from saml2 import root_logger, BINDING_URI, SAMLError
from saml2 import BINDING_SOAP
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_ARTIFACT

from saml2.attribute_converter import ac_factory
from saml2.assertion import Policy
from saml2.mdstore import MetadataStore
from saml2.virtual_org import VirtualOrg

logger = logging.getLogger(__name__)

from saml2 import md
from saml2 import saml
from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
import xmldsig
import xmlenc


ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc
}

COMMON_ARGS = [
    "entityid", "xmlsec_binary", "debug", "key_file", "cert_file",
    "encryption_type", "secret", "accepted_time_diff", "name", "ca_certs",
    "description", "valid_for", "verify_ssl_cert",
    "organization",
    "contact_person",
    "name_form",
    "virtual_organization",
    "logger",
    "only_use_keys_in_metadata",
    "logout_requests_signed",
    "disable_ssl_certificate_validation",
    "referred_binding",
    "session_storage",
    "entity_category",
    "xmlsec_path",
    "extension_schemas",
    "cert_handler_extra_class",
    "generate_cert_func",
    "generate_cert_info",
    "verify_encrypt_cert",
    "tmp_cert_file",
    "tmp_key_file",
    "validate_certificate",
    "extensions"
]

SP_ARGS = [
    "required_attributes",
    "optional_attributes",
    "idp",
    "aa",
    "subject_data",
    "want_response_signed",
    "want_assertions_signed",
    "authn_requests_signed",
    "name_form",
    "endpoints",
    "ui_info",
    "discovery_response",
    "allow_unsolicited",
    "ecp",
    "name_id_format",
    "allow_unknown_attributes"
]

AA_IDP_ARGS = [
    "sign_assertion",
    "sign_response",
    "encrypt_assertion",
    "want_authn_requests_signed",
    "want_authn_requests_only_with_valid_cert",
    "provided_attributes",
    "subject_data",
    "sp",
    "scope",
    "endpoints",
    "metadata",
    "ui_info",
    "name_id_format",
    "domain",
    "name_qualifier",
    "edu_person_targeted_id",
]

PDP_ARGS = ["endpoints", "name_form", "name_id_format"]

AQ_ARGS = ["endpoints"]

COMPLEX_ARGS = ["attribute_converters", "metadata", "policy"]
ALL = set(COMMON_ARGS + SP_ARGS + AA_IDP_ARGS + PDP_ARGS + COMPLEX_ARGS)

SPEC = {
    "": COMMON_ARGS + COMPLEX_ARGS,
    "sp": COMMON_ARGS + COMPLEX_ARGS + SP_ARGS,
    "idp": COMMON_ARGS + COMPLEX_ARGS + AA_IDP_ARGS,
    "aa": COMMON_ARGS + COMPLEX_ARGS + AA_IDP_ARGS,
    "pdp": COMMON_ARGS + COMPLEX_ARGS + PDP_ARGS,
    "aq": COMMON_ARGS + COMPLEX_ARGS + AQ_ARGS,
}

# --------------- Logging stuff ---------------

LOG_LEVEL = {
    'debug': logging.DEBUG,
    'info': logging.INFO,
    'warning': logging.WARNING,
    'error': logging.ERROR,
    'critical': logging.CRITICAL}

LOG_HANDLER = {
    "rotating": logging.handlers.RotatingFileHandler,
    "syslog": logging.handlers.SysLogHandler,
    "timerotate": logging.handlers.TimedRotatingFileHandler,
    "memory": logging.handlers.MemoryHandler,
}

LOG_FORMAT = "%(asctime)s %(name)s:%(levelname)s %(message)s"

_RPA = [BINDING_HTTP_REDIRECT, BINDING_HTTP_POST, BINDING_HTTP_ARTIFACT]
_PRA = [BINDING_HTTP_POST, BINDING_HTTP_REDIRECT, BINDING_HTTP_ARTIFACT]
_SRPA = [BINDING_SOAP, BINDING_HTTP_REDIRECT, BINDING_HTTP_POST,
         BINDING_HTTP_ARTIFACT]

PREFERRED_BINDING = {
    "single_logout_service": _SRPA,
    "manage_name_id_service": _SRPA,
    "assertion_consumer_service": _PRA,
    "single_sign_on_service": _RPA,
    "name_id_mapping_service": [BINDING_SOAP],
    "authn_query_service": [BINDING_SOAP],
    "attribute_service": [BINDING_SOAP],
    "authz_service": [BINDING_SOAP],
    "assertion_id_request_service": [BINDING_URI],
    "artifact_resolution_service": [BINDING_SOAP],
    "attribute_consuming_service": _RPA
}


class ConfigurationError(SAMLError):
    pass

# -----------------------------------------------------------------


class Config(object):
    def_context = ""

    def __init__(self, homedir="."):
        self._homedir = homedir
        self.entityid = None
        self.xmlsec_binary = None
        self.xmlsec_path = []
        self.debug = False
        self.key_file = None
        self.cert_file = None
        self.encryption_type = 'both'
        self.secret = None
        self.accepted_time_diff = None
        self.name = None
        self.ca_certs = None
        self.verify_ssl_cert = False
        self.description = None
        self.valid_for = None
        self.organization = None
        self.contact_person = None
        self.name_form = None
        self.name_id_format = None
        self.virtual_organization = None
        self.logger = None
        self.only_use_keys_in_metadata = True
        self.logout_requests_signed = None
        self.disable_ssl_certificate_validation = None
        self.context = ""
        self.attribute_converters = None
        self.metadata = None
        self.policy = None
        self.serves = []
        self.vorg = {}
        self.preferred_binding = PREFERRED_BINDING
        self.domain = ""
        self.name_qualifier = ""
        self.entity_category = ""
        self.crypto_backend = 'xmlsec1'
        self.scope = ""
        self.allow_unknown_attributes = False
        self.extension_schema = {}
        self.cert_handler_extra_class = None
        self.verify_encrypt_cert = None
        self.generate_cert_func = None
        self.generate_cert_info = None
        self.tmp_cert_file = None
        self.tmp_key_file = None
        self.validate_certificate = None
        self.extensions = {}

    def setattr(self, context, attr, val):
        if context == "":
            setattr(self, attr, val)
        else:
            setattr(self, "_%s_%s" % (context, attr), val)

    def getattr(self, attr, context=None):
        if context is None:
            context = self.context

        if context == "":
            return getattr(self, attr, None)
        else:
            return getattr(self, "_%s_%s" % (context, attr), None)

    def load_special(self, cnf, typ, metadata_construction=False):
        for arg in SPEC[typ]:
            try:
                self.setattr(typ, arg, cnf[arg])
            except KeyError:
                pass

        self.context = typ
        self.load_complex(cnf, typ, metadata_construction=metadata_construction)
        self.context = self.def_context

    def load_complex(self, cnf, typ="", metadata_construction=False):
        try:
            self.setattr(typ, "policy", Policy(cnf["policy"]))
        except KeyError:
            pass

        # for srv, spec in cnf["service"].items():
        #     try:
        #         self.setattr(srv, "policy",
        #                      Policy(cnf["service"][srv]["policy"]))
        #     except KeyError:
        #         pass

        try:
            try:
                acs = ac_factory(cnf["attribute_map_dir"])
            except KeyError:
                acs = ac_factory()

            if not acs:
                raise ConfigurationError(
                    "No attribute converters, something is wrong!!")

            _acs = self.getattr("attribute_converters", typ)
            if _acs:
                _acs.extend(acs)
            else:
                self.setattr(typ, "attribute_converters", acs)

        except KeyError:
            pass

        if not metadata_construction:
            try:
                self.setattr(typ, "metadata",
                             self.load_metadata(cnf["metadata"]))
            except KeyError:
                pass

    def unicode_convert(self, item):
        try:
            return unicode(item, "utf-8")
        except TypeError:
            _uc = self.unicode_convert
            if isinstance(item, dict):
                return dict([(key, _uc(val)) for key, val in item.items()])
            elif isinstance(item, list):
                return [_uc(v) for v in item]
            elif isinstance(item, tuple):
                return tuple([_uc(v) for v in item])
            else:
                return item

    def load(self, cnf, metadata_construction=False):
        """ The base load method, loads the configuration

        :param cnf: The configuration as a dictionary
        :param metadata_construction: Is this only to be able to construct
            metadata. If so some things can be left out.
        :return: The Configuration instance
        """
        _uc = self.unicode_convert
        for arg in COMMON_ARGS:
            if arg == "virtual_organization":
                if "virtual_organization" in cnf:
                    for key, val in cnf["virtual_organization"].items():
                        self.vorg[key] = VirtualOrg(None, key, val)
                continue
            elif arg == "extension_schemas":
                # List of filename of modules representing the schemas
                if "extension_schemas" in cnf:
                    for mod_file in cnf["extension_schemas"]:
                        _mod = self._load(mod_file)
                        self.extension_schema[_mod.NAMESPACE] = _mod

            try:
                setattr(self, arg, _uc(cnf[arg]))
            except KeyError:
                pass
            except TypeError:  # Something that can't be a string
                setattr(self, arg, cnf[arg])

        if "service" in cnf:
            for typ in ["aa", "idp", "sp", "pdp", "aq"]:
                try:
                    self.load_special(
                        cnf["service"][typ], typ,
                        metadata_construction=metadata_construction)
                    self.serves.append(typ)
                except KeyError:
                    pass

        if "extensions" in cnf:
            self.do_extensions(cnf["extensions"])

        self.load_complex(cnf, metadata_construction=metadata_construction)
        self.context = self.def_context

        return self

    def _load(self, fil):
        head, tail = os.path.split(fil)
        if head == "":
            if sys.path[0] != ".":
                sys.path.insert(0, ".")
        else:
            sys.path.insert(0, head)

        return import_module(tail)

    def load_file(self, config_file, metadata_construction=False):
        if config_file.endswith(".py"):
            config_file = config_file[:-3]

        mod = self._load(config_file)
        #return self.load(eval(open(config_file).read()))
        return self.load(copy.deepcopy(mod.CONFIG), metadata_construction)

    def load_metadata(self, metadata_conf):
        """ Loads metadata into an internal structure """

        acs = self.attribute_converters

        if acs is None:
            raise ConfigurationError(
                "Missing attribute converter specification")

        try:
            ca_certs = self.ca_certs
        except:
            ca_certs = None
        try:
            disable_validation = self.disable_ssl_certificate_validation
        except:
            disable_validation = False

        mds = MetadataStore(
            ONTS.values(), acs, self, ca_certs,
            disable_ssl_certificate_validation=disable_validation)

        mds.imp(metadata_conf)

        return mds

    def endpoint(self, service, binding=None, context=None):
        """ Goes through the list of endpoint specifications for the
        given type of service and returnes the first endpoint that matches
        the given binding. If no binding is given any endpoint for that
        service will be returned.

        :param service: The service the endpoint should support
        :param binding: The expected binding
        :return: All the endpoints that matches the given restrictions
        """
        spec = []
        unspec = []
        endps = self.getattr("endpoints", context)
        if endps and service in endps:
            for endpspec in endps[service]:
                try:
                    endp, bind = endpspec
                    if binding is None or bind == binding:
                        spec.append(endp)
                except ValueError:
                    unspec.append(endpspec)

        if spec:
            return spec
        else:
            return unspec

    def log_handler(self):
        try:
            _logconf = self.logger
        except KeyError:
            return None

        handler = None
        for htyp in LOG_HANDLER:
            if htyp in _logconf:
                if htyp == "syslog":
                    args = _logconf[htyp]
                    if "socktype" in args:
                        import socket
                        if args["socktype"] == "dgram":
                            args["socktype"] = socket.SOCK_DGRAM
                        elif args["socktype"] == "stream":
                            args["socktype"] = socket.SOCK_STREAM
                        else:
                            raise ConfigurationError("Unknown socktype!")
                    try:
                        handler = LOG_HANDLER[htyp](**args)
                    except TypeError:  # difference between 2.6 and 2.7
                        del args["socktype"]
                        handler = LOG_HANDLER[htyp](**args)
                else:
                    handler = LOG_HANDLER[htyp](**_logconf[htyp])
                break

        if handler is None:
            # default if rotating logger
            handler = LOG_HANDLER["rotating"]()

        if "format" in _logconf:
            formatter = logging.Formatter(_logconf["format"])
        else:
            formatter = logging.Formatter(LOG_FORMAT)

        handler.setFormatter(formatter)
        return handler
    
    def setup_logger(self):
        if root_logger.level != logging.NOTSET:  # Someone got there before me
            return root_logger

        _logconf = self.logger
        if _logconf is None:
            return root_logger

        try:
            root_logger.setLevel(LOG_LEVEL[_logconf["loglevel"].lower()])
        except KeyError:  # reasonable default
            root_logger.setLevel(logging.INFO)

        root_logger.addHandler(self.log_handler())
        root_logger.info("Logging started")
        return root_logger

    def endpoint2service(self, endpoint, context=None):
        endps = self.getattr("endpoints", context)

        for service, specs in endps.items():
            for endp, binding in specs:
                if endp == endpoint:
                    return service, binding

        return None, None

    def do_extensions(self, extensions):
        for key, val in extensions.items():
            self.extensions[key] = val


class SPConfig(Config):
    def_context = "sp"

    def __init__(self):
        Config.__init__(self)

    def vo_conf(self, vo_name):
        try:
            return self.virtual_organization[vo_name]
        except KeyError:
            return None

    def ecp_endpoint(self, ipaddress):
        """
        Returns the entity ID of the IdP which the ECP client should talk to

        :param ipaddress: The IP address of the user client
        :return: IdP entity ID or None
        """
        _ecp = self.getattr("ecp")
        if _ecp:
            for key, eid in _ecp.items():
                if re.match(key, ipaddress):
                    return eid

        return None


class IdPConfig(Config):
    def_context = "idp"
    
    def __init__(self):
        Config.__init__(self)


def config_factory(typ, filename):
    if typ == "sp":
        conf = SPConfig().load_file(filename)
        conf.context = typ
    elif typ in ["aa", "idp", "pdp", "aq"]:
        conf = IdPConfig().load_file(filename)
        conf.context = typ
    else:
        conf = Config().load_file(filename)
        conf.context = typ
    return conf

########NEW FILE########
__FILENAME__ = country_codes
#!/usr/bin/env python
# This Python file uses the following encoding: utf-8
# ISO 3166-1 country names and codes from http://opencountrycodes.appspot.com/python

COUNTRIES = (
    ("AF", "Afghanistan"),("AX", "Aland Islands"),("AL", "Albania"),
    ("DZ", "Algeria"),("AS", "American Samoa"),("AD", "Andorra"),
    ("AO", "Angola"),("AI", "Anguilla"),("AQ", "Antarctica"),
    ("AG", "Antigua and Barbuda"),("AR", "Argentina"),("AM", "Armenia"),
    ("AW", "Aruba"),("AU", "Australia"),("AT", "Austria"),
    ("AZ", "Azerbaijan"),("BS", "Bahamas"),("BH", "Bahrain"),
    ("BD", "Bangladesh"),("BB", "Barbados"),("BY", "Belarus"),("BE", "Belgium"),
    ("BZ", "Belize"),("BJ", "Benin"),("BM", "Bermuda"),("BT", "Bhutan"),
    ("BO", "Bolivia, Plurinational State of"),
    ("BQ", "Bonaire, Sint Eustatius and Saba"),("BA", "Bosnia and Herzegovina"),
    ("BW", "Botswana"),("BV", "Bouvet Island"),("BR", "Brazil"),
    ("IO", "British Indian Ocean Territory"),("BN", "Brunei Darussalam"),
    ("BG", "Bulgaria"),("BF", "Burkina Faso"),("BI", "Burundi"),
    ("KH", "Cambodia"),("CM", "Cameroon"),("CA", "Canada"),("CV", "Cape Verde"),
    ("KY", "Cayman Islands"),("CF", "Central African Republic"),("TD", "Chad"),
    ("CL", "Chile"),("CN", "China"),("CX", "Christmas Island"),
    ("CC", "Cocos (Keeling) Islands"),("CO", "Colombia"),("KM", "Comoros"),
    ("CG", "Congo"),("CD", "Congo, The Democratic Republic of the"),
    ("CK", "Cook Islands"),("CR", "Costa Rica"),("CI", "Cote D'ivoire"),
    ("HR", "Croatia"),("CU", "Cuba"),("CW", "Curacao"),("CY", "Cyprus"),
    ("CZ", "Czech Republic"),("DK", "Denmark"),("DJ", "Djibouti"),
    ("DM", "Dominica"),("DO", "Dominican Republic"),("EC", "Ecuador"),
    ("EG", "Egypt"),("SV", "El Salvador"),("GQ", "Equatorial Guinea"),
    ("ER", "Eritrea"),("EE", "Estonia"),("ET", "Ethiopia"),
    ("FK", "Falkland Islands (Malvinas)"),("FO", "Faroe Islands"),
    ("FJ", "Fiji"),("FI", "Finland"),("FR", "France"),("GF", "French Guiana"),
    ("PF", "French Polynesia"),("TF", "French Southern Territories"),
    ("GA", "Gabon"),("GM", "Gambia"),("GE", "Georgia"),("DE", "Germany"),
    ("GH", "Ghana"),("GI", "Gibraltar"),("GR", "Greece"),("GL", "Greenland"),
    ("GD", "Grenada"),("GP", "Guadeloupe"),("GU", "Guam"),("GT", "Guatemala"),
    ("GG", "Guernsey"),("GN", "Guinea"),("GW", "Guinea-Bissau"),("GY", "Guyana"),
    ("HT", "Haiti"),("HM", "Heard Island and McDonald Islands"),
    ("VA", "Holy See (Vatican City State)"),("HN", "Honduras"),
    ("HK", "Hong Kong"),("HU", "Hungary"),("IS", "Iceland"),("IN", "India"),
    ("ID", "Indonesia"),("IR", "Iran, Islamic Republic of"),("IQ", "Iraq"),
    ("IE", "Ireland"),("IM", "Isle of Man"),("IL", "Israel"),("IT", "Italy"),
    ("JM", "Jamaica"),("JP", "Japan"),("JE", "Jersey"),("JO", "Jordan"),
    ("KZ", "Kazakhstan"),("KE", "Kenya"),("KI", "Kiribati"),
    ("KP", "Korea, Democratic People's Republic of"),
    ("KR", "Korea, Republic of"),("KW", "Kuwait"),("KG", "Kyrgyzstan"),
    ("LA", "Lao People's Democratic Republic"),("LV", "Latvia"),
    ("LB", "Lebanon"),("LS", "Lesotho"),("LR", "Liberia"),
    ("LY", "Libyan Arab Jamahiriya"),("LI", "Liechtenstein"),
    ("LT", "Lithuania"),("LU", "Luxembourg"),("MO", "Macao"),
    ("MK", "Macedonia, The Former Yugoslav Republic of"),("MG", "Madagascar"),
    ("MW", "Malawi"),("MY", "Malaysia"),("MV", "Maldives"),("ML", "Mali"),
    ("MT", "Malta"),("MH", "Marshall Islands"),("MQ", "Martinique"),
    ("MR", "Mauritania"),("MU", "Mauritius"),("YT", "Mayotte"),("MX", "Mexico"),
    ("FM", "Micronesia, Federated States of"),("MD", "Moldova, Republic of"),
    ("MC", "Monaco"),("MN", "Mongolia"),("ME", "Montenegro"),
    ("MS", "Montserrat"),("MA", "Morocco"),("MZ", "Mozambique"),
    ("MM", "Myanmar"),("NA", "Namibia"),("NR", "Nauru"),("NP", "Nepal"),
    ("NL", "Netherlands"),("NC", "New Caledonia"),("NZ", "New Zealand"),
    ("NI", "Nicaragua"),("NE", "Niger"),("NG", "Nigeria"),("NU", "Niue"),
    ("NF", "Norfolk Island"),("MP", "Northern Mariana Islands"),
    ("NO", "Norway"),("OM", "Oman"),("PK", "Pakistan"),("PW", "Palau"),
    ("PS", "Palestinian Territory, Occupied"),("PA", "Panama"),
    ("PG", "Papua New Guinea"),("PY", "Paraguay"),("PE", "Peru"),
    ("PH", "Philippines"),("PN", "Pitcairn"),("PL", "Poland"),
    ("PT", "Portugal"),("PR", "Puerto Rico"),("QA", "Qatar"),("RE", "Reunion"),
    ("RO", "Romania"),("RU", "Russian Federation"),("RW", "Rwanda"),
    ("BL", "Saint Barthelemy"),
    ("SH", "Saint Helena, Ascension and Tristan Da Cunha"),
    ("KN", "Saint Kitts and Nevis"),("LC", "Saint Lucia"),
    ("MF", "Saint Martin (French Part)"),("PM", "Saint Pierre and Miquelon"),
    ("VC", "Saint Vincent and the Grenadines"),("WS", "Samoa"),
    ("SM", "San Marino"),("ST", "Sao Tome and Principe"),("SA", "Saudi Arabia"),
    ("SN", "Senegal"),("RS", "Serbia"),("SC", "Seychelles"),
    ("SL", "Sierra Leone"),("SG", "Singapore"),
    ("SX", "Sint Maarten (Dutch Part)"),("SK", "Slovakia"),("SI", "Slovenia"),
    ("SB", "Solomon Islands"),("SO", "Somalia"),("ZA", "South Africa"),
    ("GS", "South Georgia and the South Sandwich Islands"),("ES", "Spain"),
    ("LK", "Sri Lanka"),("SD", "Sudan"),("SR", "Suriname"),
    ("SJ", "Svalbard and Jan Mayen"),("SZ", "Swaziland"),("SE", "Sweden"),
    ("CH", "Switzerland"),("SY", "Syrian Arab Republic"),
    ("TW", "Taiwan, Province of China"),("TJ", "Tajikistan"),
    ("TZ", "Tanzania, United Republic of"),("TH", "Thailand"),
    ("TL", "Timor-Leste"),("TG", "Togo"),("TK", "Tokelau"),("TO", "Tonga"),
    ("TT", "Trinidad and Tobago"),("TN", "Tunisia"),("TR", "Turkey"),
    ("TM", "Turkmenistan"),("TC", "Turks and Caicos Islands"),("TV", "Tuvalu"),
    ("UG", "Uganda"),("UA", "Ukraine"),("AE", "United Arab Emirates"),
    ("GB", "United Kingdom"),("US", "United States"),
    ("UM", "United States Minor Outlying Islands"),("UY", "Uruguay"),
    ("UZ", "Uzbekistan"),("VU", "Vanuatu"),
    ("VE", "Venezuela, Bolivarian Republic of"),("VN", "Viet Nam"),
    ("VG", "Virgin Islands, British"),("VI", "Virgin Islands, U.S."),
    ("WF", "Wallis and Futuna"),("EH", "Western Sahara"),("YE", "Yemen"),
    ("ZM", "Zambia"),("ZW", "Zimbabwe"),)

D_COUNTRIES = dict(COUNTRIES)
########NEW FILE########
__FILENAME__ = discovery
from urllib import urlencode
from urlparse import urlparse, parse_qs
from saml2.entity import Entity
from saml2.response import VerificationError

__author__ = 'rolandh'

IDPDISC_POLICY = "urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol:single"


class DiscoveryServer(Entity):
    def __init__(self, config=None, config_file=""):
        Entity.__init__(self, "disco", config, config_file)

    def parse_discovery_service_request(self, url="", query=""):
        if url:
            part = urlparse(url)
            dsr = parse_qs(part[4])
        elif query:
            dsr = parse_qs(query)
        else:
            dsr = {}

        # verify

        for key in ["isPassive", "return", "returnIDParam", "policy"]:
            try:
                assert len(dsr[key]) == 1
                dsr[key] = dsr[key][0]
            except KeyError:
                pass

        if "return" in dsr:
            part = urlparse(dsr["return"])
            if part.query:
                qp = parse_qs(part.query)
                if "returnIDParam" in dsr:
                    assert dsr["returnIDParam"] not in qp.keys()
                else:
                    assert "entityID" not in qp.keys()
        else:
            # If metadata not used this is mandatory
            raise VerificationError("Missing mandatory parameter 'return'")

        if "policy" not in dsr:
            dsr["policy"] = IDPDISC_POLICY

        try:
            assert dsr["isPassive"] in ["true", "false"]
        except KeyError:
            pass

        if "isPassive" in dsr and dsr["isPassive"] == "true":
            dsr["isPassive"] = True
        else:
            dsr["isPassive"] = False

        if not "returnIDParam" in dsr:
            dsr["returnIDParam"] = "entityID"

        return dsr

    # -------------------------------------------------------------------------

    @staticmethod
    def create_discovery_service_response(return_url=None,
                                          returnIDParam="entityID",
                                          entity_id=None, **kwargs):
        if return_url is None:
            return_url = kwargs["return"]
            
        if entity_id:
            qp = urlencode({returnIDParam: entity_id})

            part = urlparse(return_url)
            if part.query:
                # Iff there is a query part add the new info at the end
                return_url = "%s&%s" % (return_url, qp)
            else:
                return_url = "%s?%s" % (return_url, qp)

        return return_url

    def verify_sp_in_metadata(self, entity_id):
        if self.metadata:
            endp = self.metadata.discovery_response(entity_id)
            if endp:
                return True

        return False

    def verify_return(self, entity_id, return_url):
        for endp in self.metadata.discovery_response(entity_id):
            try:
                assert return_url.startswith(endp["location"])
            except AssertionError:
                pass
            else:
                return True
        return False

########NEW FILE########
__FILENAME__ = ecp
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Contains classes used in the SAML ECP profile
"""
import logging
from saml2.client_base import ACTOR
from saml2.ecp_client import SERVICE

from saml2 import element_to_extension_element
from saml2 import samlp
from saml2 import soap
from saml2 import BINDING_SOAP, BINDING_PAOS

from saml2.profile import paos
from saml2.profile import ecp

#from saml2.client import Saml2Client
from saml2.server import Server

from saml2.schema import soapenv

from saml2.response import authn_response

logger = logging.getLogger(__name__)


def ecp_capable(headers):
    if "application/vnd.paos+xml" in headers["Accept"]:
        if "PAOS" in headers:
            if 'ver="%s";"%s"' % (paos.NAMESPACE,
                                  SERVICE) in headers["PAOS"]:
                return True

    return False


#noinspection PyUnusedLocal
def ecp_auth_request(cls, entityid=None, relay_state="", sign=False):
    """ Makes an authentication request.

    :param entityid: The entity ID of the IdP to send the request to
    :param relay_state: To where the user should be returned after
        successfull log in.
    :param sign: Whether the request should be signed or not.
    :return: AuthnRequest response
    """

    eelist = []

    # ----------------------------------------
    # <paos:Request>
    # ----------------------------------------
    my_url = cls.service_url(BINDING_PAOS)

    # must_understand and actor according to the standard
    #
    paos_request = paos.Request(must_understand="1", actor=ACTOR,
                                response_consumer_url=my_url,
                                service=SERVICE)

    eelist.append(element_to_extension_element(paos_request))

    # ----------------------------------------
    # <ecp:Request>
    # ----------------------------------------

#        idp = samlp.IDPEntry(
#            provider_id = "https://idp.example.org/entity",
#            name = "Example identity provider",
#            loc = "https://idp.example.org/saml2/sso",
#            )
#
#        idp_list = samlp.IDPList(idp_entry= [idp])
#
#        ecp_request = ecp.Request(
#            actor = ACTOR, must_understand = "1",
#            provider_name = "Example Service Provider",
#            issuer=saml.Issuer(text="https://sp.example.org/entity"),
#            idp_list = idp_list)
#
#        eelist.append(element_to_extension_element(ecp_request))

    # ----------------------------------------
    # <ecp:RelayState>
    # ----------------------------------------

    relay_state = ecp.RelayState(actor=ACTOR, must_understand="1",
                                 text=relay_state)

    eelist.append(element_to_extension_element(relay_state))

    header = soapenv.Header()
    header.extension_elements = eelist

    # ----------------------------------------
    # <samlp:AuthnRequest>
    # ----------------------------------------

    logger.info("entityid: %s, binding: %s" % (entityid, BINDING_SOAP))
        
    location = cls._sso_location(entityid, binding=BINDING_SOAP)
    req_id, authn_req = cls.create_authn_request(
        location, binding=BINDING_PAOS, service_url_binding=BINDING_PAOS)

    body = soapenv.Body()
    body.extension_elements = [element_to_extension_element(authn_req)]

    # ----------------------------------------
    # The SOAP envelope
    # ----------------------------------------

    soap_envelope = soapenv.Envelope(header=header, body=body)

    return req_id, "%s" % soap_envelope


def handle_ecp_authn_response(cls, soap_message, outstanding=None):
    rdict = soap.class_instances_from_soap_enveloped_saml_thingies(
        soap_message, [paos, ecp, samlp])

    _relay_state = None
    for item in rdict["header"]:
        if item.c_tag == "RelayState" and item.c_namespace == ecp.NAMESPACE:
            _relay_state = item

    response = authn_response(cls.config, cls.service_url(), outstanding,
                              allow_unsolicited=True)

    response.loads("%s" % rdict["body"], False, soap_message)
    response.verify()
    cls.users.add_information_about_person(response.session_info())

    return response, _relay_state
        

def ecp_response(target_url, response):

    # ----------------------------------------
    # <ecp:Response
    # ----------------------------------------

    ecp_response = ecp.Response(assertion_consumer_service_url=target_url)
    header = soapenv.Header()
    header.extension_elements = [element_to_extension_element(ecp_response)]

    # ----------------------------------------
    # <samlp:Response
    # ----------------------------------------

    body = soapenv.Body()
    body.extension_elements = [element_to_extension_element(response)]

    soap_envelope = soapenv.Envelope(header=header, body=body)

    return "%s" % soap_envelope


class ECPServer(Server):
    """ This deals with what the IdP has to do

    TODO: Still tentative
    """
    def __init__(self, config_file="", config=None, cache=None):
        Server.__init__(self, config_file, config, cache)

    def parse_ecp_authn_query(self):
        pass
    
    def ecp_response(self):

        # ----------------------------------------
        # <ecp:Response
        # ----------------------------------------
        target_url = ""

        ecp_response = ecp.Response(assertion_consumer_service_url=target_url)
        header = soapenv.Body()
        header.extension_elements = [element_to_extension_element(ecp_response)]

        # ----------------------------------------
        # <samlp:Response
        # ----------------------------------------

        response = samlp.Response()
        body = soapenv.Body()
        body.extension_elements = [element_to_extension_element(response)]

        soap_envelope = soapenv.Envelope(header=header, body=body)

        return "%s" % soap_envelope

########NEW FILE########
__FILENAME__ = ecp_client
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Contains a class that can do SAML ECP Authentication for other python
programs.
"""

import cookielib
import logging

from saml2 import soap
from saml2 import saml
from saml2 import samlp
from saml2 import SAMLError
from saml2 import BINDING_SOAP
from saml2.client_base import MIME_PAOS
from saml2.config import Config
from saml2.entity import Entity
from saml2.httpbase import set_list2dict, dict2set_list

from saml2.profile import paos
from saml2.profile import ecp

from saml2.mdstore import MetadataStore
from saml2.s_utils import BadRequest

SERVICE = "urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp"
PAOS_HEADER_INFO = 'ver="%s";"%s"' % (paos.NAMESPACE, SERVICE)

logger = logging.getLogger(__name__)


class Client(Entity):
    def __init__(self, user, passwd, sp="", idp=None, metadata_file=None,
                 xmlsec_binary=None, verbose=0, ca_certs="",
                 disable_ssl_certificate_validation=True, key_file=None,
                 cert_file=None, config=None):
        """
        :param user: user name
        :param passwd: user password
        :param sp: The SP URL
        :param idp: The IdP PAOS endpoint
        :param metadata_file: Where the metadata file is if used
        :param xmlsec_binary: Where the xmlsec1 binary can be found (*)
        :param verbose: Chatty or not
        :param ca_certs: is the path of a file containing root CA certificates
            for SSL server certificate validation (*)
        :param disable_ssl_certificate_validation: If
            disable_ssl_certificate_validation is true, SSL cert validation
            will not be performed (*)
        :param key_file: Private key filename (*)
        :param cert_file: Certificate filename (*)
        :param config: Config() instance, overrides all the parameters marked
            with an asterisk (*) above
        """
        if not config:
            config = Config()
            config.disable_ssl_certificate_validation = \
                disable_ssl_certificate_validation
            config.key_file = key_file
            config.cert_file = cert_file
            config.ca_certs = ca_certs
            config.xmlsec_binary = xmlsec_binary

        Entity.__init__(self, "sp", config)
        self._idp = idp
        self._sp = sp
        self.user = user
        self.passwd = passwd
        self._verbose = verbose

        if metadata_file:
            self._metadata = MetadataStore([saml, samlp], None, config)
            self._metadata.load("local", metadata_file)
            logger.debug("Loaded metadata from '%s'" % metadata_file)
        else:
            self._metadata = None

        self.metadata = self._metadata

        self.cookie_handler = None

        self.done_ecp = False
        self.cookie_jar = cookielib.LWPCookieJar()

    def phase2(self, authn_request, rc_url, idp_entity_id, headers=None,
               sign=False, **kwargs):
        """
        Doing the second phase of the ECP conversation, the conversation
        with the IdP happens.

        :param authn_request: The AuthenticationRequest
        :param rc_url: The assertion consumer service url of the SP
        :param idp_entity_id: The EntityID of the IdP
        :param headers: Possible extra headers
        :param sign: If the message should be signed
        :return: The response from the IdP
        """

        _, destination = self.pick_binding("single_sign_on_service",
                                           [BINDING_SOAP], "idpsso",
                                           entity_id=idp_entity_id)

        ht_args = self.apply_binding(BINDING_SOAP, authn_request, destination,
                                     sign=sign)

        if headers:
            ht_args["headers"].extend(headers)

        logger.debug("[P2] Sending request: %s" % ht_args["data"])

        # POST the request to the IdP
        response = self.send(**ht_args)

        logger.debug("[P2] Got IdP response: %s" % response)

        if response.status_code != 200:
            raise SAMLError(
                "Request to IdP failed (%s): %s" % (response.status_code,
                                                    response.error))

        # SAMLP response in a SOAP envelope body, ecp response in headers
        respdict = self.parse_soap_message(response.text)

        if respdict is None:
            raise SAMLError("Unexpected reply from the IdP")

        logger.debug("[P2] IdP response dict: %s" % respdict)

        idp_response = respdict["body"]
        assert idp_response.c_tag == "Response"

        logger.debug("[P2] IdP AUTHN response: %s" % idp_response)

        _ecp_response = None
        for item in respdict["header"]:
            if item.c_tag == "Response" and item.c_namespace == ecp.NAMESPACE:
                _ecp_response = item

        _acs_url = _ecp_response.assertion_consumer_service_url
        if rc_url != _acs_url:
            error = ("response_consumer_url '%s' does not match" % rc_url,
                     "assertion_consumer_service_url '%s" % _acs_url)
            # Send an error message to the SP
            _ = self.send(rc_url, "POST", data=soap.soap_fault(error))
            # Raise an exception so the user knows something went wrong
            raise SAMLError(error)
        
        return idp_response

    @staticmethod
    def parse_sp_ecp_response(respdict):
        if respdict is None:
            raise SAMLError("Unexpected reply from the SP")

        logger.debug("[P1] SP response dict: %s" % respdict)

        # AuthnRequest in the body or not
        authn_request = respdict["body"]
        assert authn_request.c_tag == "AuthnRequest"

        # ecp.RelayState among headers
        _relay_state = None
        _paos_request = None
        for item in respdict["header"]:
            if item.c_tag == "RelayState" and item.c_namespace == ecp.NAMESPACE:
                _relay_state = item
            if item.c_tag == "Request" and item.c_namespace == paos.NAMESPACE:
                _paos_request = item

        if _paos_request is None:
            raise BadRequest("Missing request")

        _rc_url = _paos_request.response_consumer_url

        return {"authn_request": authn_request, "rc_url": _rc_url,
                "relay_state": _relay_state}

    def ecp_conversation(self, respdict, idp_entity_id=None):
        """

        :param respdict:
        :param idp_entity_id:
        :return:
        """

        args = self.parse_sp_ecp_response(respdict)

        # **********************
        # Phase 2 - talk to the IdP
        # **********************

        idp_response = self.phase2(idp_entity_id=idp_entity_id, **args)

        # **********************************
        # Phase 3 - back to the SP
        # **********************************

        ht_args = self.use_soap(idp_response, args["rc_url"],
                                [args["relay_state"]])

        logger.debug("[P3] Post to SP: %s" % ht_args["data"])

        ht_args["headers"].append(('Content-Type', 'application/vnd.paos+xml'))

        # POST the package from the IdP to the SP
        response = self.send(args["rc_url"], "POST", **ht_args)

        if response.status_code == 302:
            # ignore where the SP is redirecting us to and go for the
            # url I started off with.
            pass
        else:
            print response.error
            raise SAMLError(
                "Error POSTing package to SP: %s" % response.error)

        logger.debug("[P3] SP response: %s" % response.text)

        self.done_ecp = True
        logger.debug("Done ECP")
            
        return None

    def add_paos_headers(self, headers=None):
        if headers:
            headers = set_list2dict(headers)
            headers["PAOS"] = PAOS_HEADER_INFO
            if "Accept" in headers:
                headers["Accept"] += ";%s" % MIME_PAOS
            elif "accept" in headers:
                headers["Accept"] = headers["accept"]
                headers["Accept"] += ";%s" % MIME_PAOS
                del headers["accept"]
            headers = dict2set_list(headers)
        else:
            headers = [
                ('Accept', 'text/html; %s' % MIME_PAOS),
                ('PAOS', PAOS_HEADER_INFO)
            ]

        return headers

    def operation(self, url, idp_entity_id, op, **opargs):
        """
        This is the method that should be used by someone that wants
        to authenticate using SAML ECP

        :param url: The page that access is sought for
        :param idp_entity_id: The entity ID of the IdP that should be
            used for authentication
        :param op: Which HTTP operation (GET/POST/PUT/DELETE)
        :param opargs: Arguments to the HTTP call
        :return: The page
        """
        if url not in opargs:
            url = self._sp

        # ********************************************
        # Phase 1 - First conversation with the SP
        # ********************************************
        # headers needed to indicate to the SP that I'm ECP enabled

        opargs["headers"] = self.add_paos_headers(opargs["headers"])

        response = self.send(url, op, **opargs)
        logger.debug("[Op] SP response: %s" % response)

        if response.status_code != 200:
            raise SAMLError(
                "Request to SP failed: %s" % response.error)

        # The response might be a AuthnRequest instance in a SOAP envelope
        # body. If so it's the start of the ECP conversation
        # Two SOAP header blocks; paos:Request and ecp:Request
        # may also contain a ecp:RelayState SOAP header block
        # If channel-binding was part of the PAOS header any number of
        # <cb:ChannelBindings> header blocks may also be present
        # if 'holder-of-key' option then one or more <ecp:SubjectConfirmation>
        # header blocks may also be present
        try:
            respdict = self.parse_soap_message(response.text)

            self.ecp_conversation(respdict, idp_entity_id)

            # should by now be authenticated so this should go smoothly
            response = self.send(url, op, **opargs)
        except (soap.XmlParseError, AssertionError, KeyError):
            pass

        #print "RESP",response, self.http.response

        if  response.status_code != 404:
            raise SAMLError("Error performing operation: %s" % (
                response.error,))

        return response

    # different HTTP operations
    def delete(self, url=None, idp_entity_id=None):
        return self.operation(url, idp_entity_id, "DELETE")

    def get(self, url=None, idp_entity_id=None, headers=None):
        return self.operation(url, idp_entity_id, "GET", headers=headers)

    def post(self, url=None, data="", idp_entity_id=None, headers=None):
        return self.operation(url, idp_entity_id, "POST", data=data,
                              headers=headers)

    def put(self, url=None, data="", idp_entity_id=None, headers=None):
        return self.operation(url, idp_entity_id, "PUT", data=data,
                              headers=headers)

########NEW FILE########
__FILENAME__ = entity
import base64
from binascii import hexlify
import logging
from hashlib import sha1
from saml2.metadata import ENDPOINTS
from saml2.profile import paos, ecp
from saml2.soap import parse_soap_enveloped_saml_artifact_resolve
from saml2.soap import class_instances_from_soap_enveloped_saml_thingies
from saml2.soap import open_soap_envelope

from saml2 import samlp
from saml2 import SamlBase
from saml2 import SAMLError
from saml2 import saml
from saml2 import response as saml_response
from saml2 import BINDING_URI
from saml2 import BINDING_HTTP_ARTIFACT
from saml2 import BINDING_PAOS
from saml2 import request as saml_request
from saml2 import soap
from saml2 import element_to_extension_element
from saml2 import extension_elements_to_elements

from saml2.saml import NameID
from saml2.saml import Issuer
from saml2.saml import NAMEID_FORMAT_ENTITY
from saml2.response import LogoutResponse
from saml2.response import UnsolicitedResponse
from saml2.time_util import instant
from saml2.s_utils import sid
from saml2.s_utils import UnravelError
from saml2.s_utils import error_status_factory
from saml2.s_utils import rndstr
from saml2.s_utils import success_status_factory
from saml2.s_utils import decode_base64_and_inflate
from saml2.s_utils import UnsupportedBinding
from saml2.samlp import AuthnRequest
from saml2.samlp import AuthzDecisionQuery
from saml2.samlp import AuthnQuery
from saml2.samlp import AssertionIDRequest
from saml2.samlp import ManageNameIDRequest
from saml2.samlp import NameIDMappingRequest
from saml2.samlp import artifact_resolve_from_string
from saml2.samlp import ArtifactResolve
from saml2.samlp import ArtifactResponse
from saml2.samlp import Artifact
from saml2.samlp import LogoutRequest
from saml2.samlp import AttributeQuery
from saml2.mdstore import destinations
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_SOAP
from saml2 import VERSION
from saml2 import class_name
from saml2.config import config_factory
from saml2.httpbase import HTTPBase
from saml2.sigver import security_context
from saml2.sigver import response_factory
from saml2.sigver import SigverError
from saml2.sigver import CryptoBackendXmlSec1
from saml2.sigver import make_temp
from saml2.sigver import pre_encryption_part
from saml2.sigver import pre_signature_part
from saml2.sigver import signed_instance_factory
from saml2.virtual_org import VirtualOrg

logger = logging.getLogger(__name__)

__author__ = 'rolandh'

ARTIFACT_TYPECODE = '\x00\x04'

SERVICE2MESSAGE = {
    "single_sign_on_service": AuthnRequest,
    "attribute_service": AttributeQuery,
    "authz_service": AuthzDecisionQuery,
    "assertion_id_request_service": AssertionIDRequest,
    "authn_query_service": AuthnQuery,
    "manage_name_id_service": ManageNameIDRequest,
    "name_id_mapping_service": NameIDMappingRequest,
    "artifact_resolve_service": ArtifactResolve,
    "single_logout_service": LogoutRequest
}


def create_artifact(entity_id, message_handle, endpoint_index=0):
    """
    SAML_artifact   := B64(TypeCode EndpointIndex RemainingArtifact)
    TypeCode        := Byte1Byte2
    EndpointIndex   := Byte1Byte2

    RemainingArtifact := SourceID MessageHandle
    SourceID          := 20-byte_sequence
    MessageHandle     := 20-byte_sequence

    :param entity_id:
    :param message_handle:
    :param endpoint_index:
    :return:
    """
    sourceid = sha1(entity_id)

    ter = "%s%.2x%s%s" % (ARTIFACT_TYPECODE, endpoint_index,
                          sourceid.digest(), message_handle)
    return base64.b64encode(ter)


class Entity(HTTPBase):
    def __init__(self, entity_type, config=None, config_file="",
                 virtual_organization=""):
        self.entity_type = entity_type
        self.users = None

        if config:
            self.config = config
        elif config_file:
            self.config = config_factory(entity_type, config_file)
        else:
            raise SAMLError("Missing configuration")

        HTTPBase.__init__(self, self.config.verify_ssl_cert,
                          self.config.ca_certs, self.config.key_file,
                          self.config.cert_file)

        if self.config.vorg:
            for vo in self.config.vorg.values():
                vo.sp = self

        self.metadata = self.config.metadata
        self.config.setup_logger()
        self.debug = self.config.debug
        self.seed = rndstr(32)

        self.sec = security_context(self.config)

        if virtual_organization:
            if isinstance(virtual_organization, basestring):
                self.vorg = self.config.vorg[virtual_organization]
            elif isinstance(virtual_organization, VirtualOrg):
                self.vorg = virtual_organization
        else:
            self.vorg = None

        self.artifact = {}
        if self.metadata:
            self.sourceid = self.metadata.construct_source_id()
        else:
            self.sourceid = {}

    def _issuer(self, entityid=None):
        """ Return an Issuer instance """
        if entityid:
            if isinstance(entityid, Issuer):
                return entityid
            else:
                return Issuer(text=entityid, format=NAMEID_FORMAT_ENTITY)
        else:
            return Issuer(text=self.config.entityid,
                          format=NAMEID_FORMAT_ENTITY)

    def apply_binding(self, binding, msg_str, destination="", relay_state="",
                      response=False, sign=False, **kwargs):
        """
        Construct the necessary HTTP arguments dependent on Binding

        :param binding: Which binding to use
        :param msg_str: The return message as a string (XML) if the message is
            to be signed it MUST contain the signature element.
        :param destination: Where to send the message
        :param relay_state: Relay_state if provided
        :param response: Which type of message this is
        :param kwargs: response type specific arguments
        :return: A dictionary
        """
        # unless if BINDING_HTTP_ARTIFACT
        if response:
            typ = "SAMLResponse"
        else:
            typ = "SAMLRequest"

        if binding == BINDING_HTTP_POST:
            logger.info("HTTP POST")
            info = self.use_http_form_post(msg_str, destination,
                                           relay_state, typ)
            info["url"] = destination
            info["method"] = "GET"
        elif binding == BINDING_HTTP_REDIRECT:
            logger.info("HTTP REDIRECT")
            info = self.use_http_get(msg_str, destination, relay_state, typ)
            info["url"] = str(destination)
            info["method"] = "GET"
        elif binding == BINDING_SOAP or binding == BINDING_PAOS:
            info = self.use_soap(msg_str, destination, sign=sign, **kwargs)
        elif binding == BINDING_URI:
            info = self.use_http_uri(msg_str, typ, destination)
        elif binding == BINDING_HTTP_ARTIFACT:
            if response:
                info = self.use_http_artifact(msg_str, destination, relay_state)
                info["method"] = "GET"
                info["status"] = 302
            else:
                info = self.use_http_artifact(msg_str, destination, relay_state)
        else:
            raise SAMLError("Unknown binding type: %s" % binding)

        return info

    def pick_binding(self, service, bindings=None, descr_type="", request=None,
                     entity_id=""):
        if request and not entity_id:
            entity_id = request.issuer.text.strip()

        sfunc = getattr(self.metadata, service)

        if bindings is None:
            bindings = self.config.preferred_binding[service]

        if not descr_type:
            if self.entity_type == "sp":
                descr_type = "idpsso"
            else:
                descr_type = "spsso"

        for binding in bindings:
            try:
                srvs = sfunc(entity_id, binding, descr_type)
                if srvs:
                    return binding, destinations(srvs)[0]
            except UnsupportedBinding:
                pass

        logger.error("Failed to find consumer URL: %s, %s, %s" % (entity_id,
                                                                  bindings,
                                                                  descr_type))
        #logger.error("Bindings: %s" % bindings)
        #logger.error("Entities: %s" % self.metadata)

        raise SAMLError("Unkown entity or unsupported bindings")

    def message_args(self, message_id=0):
        if not message_id:
            message_id = sid(self.seed)

        return {"id": message_id, "version": VERSION,
                "issue_instant": instant(), "issuer": self._issuer()}

    def response_args(self, message, bindings=None, descr_type=""):
        """

        :param message: The message to which a reply is constructed
        :param bindings: Which bindings can be used.
        :param descr_type: Type of descriptor (spssp, idpsso, )
        :return: Dictionary
        """
        info = {"in_response_to": message.id}

        if isinstance(message, AuthnRequest):
            rsrv = "assertion_consumer_service"
            descr_type = "spsso"
            info["sp_entity_id"] = message.issuer.text
            info["name_id_policy"] = message.name_id_policy
        elif isinstance(message, LogoutRequest):
            rsrv = "single_logout_service"
        elif isinstance(message, AttributeQuery):
            info["sp_entity_id"] = message.issuer.text
            rsrv = "attribute_consuming_service"
            descr_type = "spsso"
        elif isinstance(message, ManageNameIDRequest):
            rsrv = "manage_name_id_service"
        # The once below are solely SOAP so no return destination needed
        elif isinstance(message, AssertionIDRequest):
            rsrv = ""
        elif isinstance(message, ArtifactResolve):
            rsrv = ""
        elif isinstance(message, AssertionIDRequest):
            rsrv = ""
        elif isinstance(message, NameIDMappingRequest):
            rsrv = ""
        else:
            raise SAMLError("No support for this type of query")

        if bindings == [BINDING_SOAP]:
            info["binding"] = BINDING_SOAP
            info["destination"] = ""
            return info

        if rsrv:
            if not descr_type:
                if self.entity_type == "sp":
                    descr_type = "idpsso"
                else:
                    descr_type = "spsso"

            binding, destination = self.pick_binding(rsrv, bindings,
                                                     descr_type=descr_type,
                                                     request=message)
            info["binding"] = binding
            info["destination"] = destination

        return info

    @staticmethod
    def unravel(txt, binding, msgtype="response"):
        """
        Will unpack the received text. Depending on the context the original
         response may have been transformed before transmission.
        :param txt:
        :param binding:
        :param msgtype:
        :return:
        """
        #logger.debug("unravel '%s'" % txt)
        if binding not in [BINDING_HTTP_REDIRECT, BINDING_HTTP_POST,
                           BINDING_SOAP, BINDING_URI, BINDING_HTTP_ARTIFACT,
                           None]:
            raise ValueError("Don't know how to handle '%s'" % binding)
        else:
            try:
                if binding == BINDING_HTTP_REDIRECT:
                    xmlstr = decode_base64_and_inflate(txt)
                elif binding == BINDING_HTTP_POST:
                    xmlstr = base64.b64decode(txt)
                elif binding == BINDING_SOAP:
                    func = getattr(soap,
                                   "parse_soap_enveloped_saml_%s" % msgtype)
                    xmlstr = func(txt)
                elif binding == BINDING_HTTP_ARTIFACT:
                    xmlstr = base64.b64decode(txt)
                else:
                    xmlstr = txt
            except Exception:
                raise UnravelError()

        return xmlstr

    @staticmethod
    def parse_soap_message(text):
        """

        :param text: The SOAP message
        :return: A dictionary with two keys "body" and "header"
        """
        return class_instances_from_soap_enveloped_saml_thingies(text, [paos,
                                                                        ecp,
                                                                        samlp])

    @staticmethod
    def unpack_soap_message(text):
        """
        Picks out the parts of the SOAP message, body and headers apart
        :param text: The SOAP message
        :return: A dictionary with two keys "body"/"header"
        """
        return open_soap_envelope(text)

# --------------------------------------------------------------------------

    def sign(self, msg, mid=None, to_sign=None, sign_prepare=False):
        if msg.signature is None:
            msg.signature = pre_signature_part(msg.id, self.sec.my_cert, 1)

        if sign_prepare:
            return msg

        if mid is None:
            mid = msg.id

        try:
            to_sign += [(class_name(msg), mid)]
        except (AttributeError, TypeError):
            to_sign = [(class_name(msg), mid)]

        logger.info("REQUEST: %s" % msg)
        return signed_instance_factory(msg, self.sec, to_sign)

    def _message(self, request_cls, destination=None, message_id=0,
                 consent=None, extensions=None, sign=False, sign_prepare=False,
                 **kwargs):
        """
        Some parameters appear in all requests so simplify by doing
        it in one place

        :param request_cls: The specific request type
        :param destination: The recipient
        :param message_id: A message identifier
        :param consent: Whether the principal have given her consent
        :param extensions: Possible extensions
        :param sign: Whether the request should be signed or not.
        :param sign_prepare: Whether the signature should be prepared or not.
        :param kwargs: Key word arguments specific to one request type
        :return: A tuple containing the request ID and an instance of the
            request_cls
        """
        if not message_id:
            message_id = sid(self.seed)

        for key, val in self.message_args(message_id).items():
            if key not in kwargs:
                kwargs[key] = val

        req = request_cls(**kwargs)
        reqid = req.id

        if destination:
            req.destination = destination

        if consent:
            req.consent = "true"

        if extensions:
            req.extensions = extensions

        if sign:
            return reqid, self.sign(req, sign_prepare=sign_prepare)
        else:
            logger.info("REQUEST: %s" % req)
            return reqid, req

    @staticmethod
    def _filter_args(instance, extensions=None, **kwargs):
        args = {}
        if extensions is None:
            extensions = []

        allowed_attributes = instance.keys()
        for key, val in kwargs.items():
            if key in allowed_attributes:
                args[key] = val
            elif isinstance(val, SamlBase):
                # extension elements allowed ?
                extensions.append(element_to_extension_element(val))

        return args, extensions

    def _add_info(self, msg, **kwargs):
        """
        Add information to a SAML message. If the attribute is not part of
        what's defined in the SAML standard add it as an extension.

        :param msg:
        :param kwargs:
        :return:
        """

        args, extensions = self._filter_args(msg, **kwargs)
        for key, val in args.items():
            setattr(msg, key, val)

        if extensions:
            if msg.extension_elements:
                msg.extension_elements.extend(extensions)
            else:
                msg.extension_elements = extensions

    def _response(self, in_response_to, consumer_url=None, status=None,
                  issuer=None, sign=False, to_sign=None,
                  encrypt_assertion=False, encrypt_cert=None, **kwargs):
        """ Create a Response.

        :param in_response_to: The session identifier of the request
        :param consumer_url: The URL which should receive the response
        :param status: The status of the response
        :param issuer: The issuer of the response
        :param sign: Whether the response should be signed or not
        :param to_sign: If there are other parts to sign
        :param kwargs: Extra key word arguments
        :return: A Response instance
        """

        if not status:
            status = success_status_factory()

        _issuer = self._issuer(issuer)

        response = response_factory(issuer=_issuer,
                                    in_response_to=in_response_to,
                                    status=status)

        if consumer_url:
            response.destination = consumer_url

        self._add_info(response, **kwargs)

        if not sign and to_sign and not encrypt_assertion:
            return signed_instance_factory(response, self.sec, to_sign)

        if encrypt_assertion:
            sign_class = [(class_name(response), response.id)]
            if sign:
                response.signature = pre_signature_part(response.id,
                                                        self.sec.my_cert, 1)
            cbxs = CryptoBackendXmlSec1(self.config.xmlsec_binary)
            _, cert_file = make_temp("%s" % encrypt_cert, decode=False)
            response = cbxs.encrypt_assertion(response, cert_file,
                                              pre_encryption_part())
                                              # template(response.assertion.id))
            if sign:
                return signed_instance_factory(response, self.sec, sign_class)
            else:
                return response

        if sign:
            return self.sign(response, to_sign=to_sign)
        else:
            return response

    def _status_response(self, response_class, issuer, status, sign=False,
                         **kwargs):
        """ Create a StatusResponse.

        :param response_class: Which subclass of StatusResponse that should be
            used
        :param issuer: The issuer of the response message
        :param status: The return status of the response operation
        :param sign: Whether the response should be signed or not
        :param kwargs: Extra arguments to the response class
        :return: Class instance or string representation of the instance
        """

        mid = sid()

        for key in ["binding"]:
            try:
                del kwargs[key]
            except KeyError:
                pass

        if not status:
            status = success_status_factory()

        response = response_class(issuer=issuer, id=mid, version=VERSION,
                                  issue_instant=instant(),
                                  status=status, **kwargs)

        if sign:
            return self.sign(response, mid)
        else:
            return response

    # ------------------------------------------------------------------------

    @staticmethod
    def srv2typ(service):
        for typ in ["aa", "pdp", "aq"]:
            if service in ENDPOINTS[typ]:
                if typ == "aa":
                    return "attribute_authority"
                elif typ == "aq":
                    return "authn_authority"
                else:
                    return typ

    def _parse_request(self, xmlstr, request_cls, service, binding):
        """Parse a Request

        :param xmlstr: The request in its transport format
        :param request_cls: The type of requests I expect
        :param service:
        :param binding: Which binding that was used to transport the message
            to this entity.
        :return: A request instance
        """

        _log_info = logger.info
        _log_debug = logger.debug

        # The addresses I should receive messages like this on
        receiver_addresses = self.config.endpoint(service, binding,
                                                  self.entity_type)
        if not receiver_addresses and self.entity_type == "idp":
            for typ in ["aa", "aq", "pdp"]:
                receiver_addresses = self.config.endpoint(service, binding, typ)
                if receiver_addresses:
                    break

        _log_info("receiver addresses: %s" % receiver_addresses)
        _log_info("Binding: %s" % binding)

        try:
            timeslack = self.config.accepted_time_diff
            if not timeslack:
                timeslack = 0
        except AttributeError:
            timeslack = 0

        _request = request_cls(self.sec, receiver_addresses,
                               self.config.attribute_converters,
                               timeslack=timeslack)

        origdoc = xmlstr
        xmlstr = self.unravel(xmlstr, binding, request_cls.msgtype)
        must = self.config.getattr("want_authn_requests_signed", "idp")
        only_valid_cert = self.config.getattr(
            "want_authn_requests_only_with_valid_cert", "idp")
        if only_valid_cert is None:
            only_valid_cert = False
        if only_valid_cert:
            must = True
        _request = _request.loads(xmlstr, binding, origdoc=origdoc, must=must,
                                  only_valid_cert=only_valid_cert)

        _log_debug("Loaded request")

        if _request:
            _request = _request.verify()
            _log_debug("Verified request")

        if not _request:
            return None
        else:
            return _request

    # ------------------------------------------------------------------------

    def create_error_response(self, in_response_to, destination, info,
                              sign=False, issuer=None, **kwargs):
        """ Create a error response.

        :param in_response_to: The identifier of the message this is a response
            to.
        :param destination: The intended recipient of this message
        :param info: Either an Exception instance or a 2-tuple consisting of
            error code and descriptive text
        :param sign: Whether the response should be signed or not
        :param issuer: The issuer of the response
        :param kwargs: To capture key,value pairs I don't care about
        :return: A response instance
        """
        status = error_status_factory(info)

        return self._response(in_response_to, destination, status, issuer,
                              sign)

    # ------------------------------------------------------------------------

    def create_logout_request(self, destination, issuer_entity_id,
                              subject_id=None, name_id=None,
                              reason=None, expire=None, message_id=0, 
                              consent=None, extensions=None, sign=False):
        """ Constructs a LogoutRequest

        :param destination: Destination of the request
        :param issuer_entity_id: The entity ID of the IdP the request is
            target at.
        :param subject_id: The identifier of the subject
        :param name_id: A NameID instance identifying the subject
        :param reason: An indication of the reason for the logout, in the
            form of a URI reference.
        :param expire: The time at which the request expires,
            after which the recipient may discard the message.
        :param message_id: Request identifier
        :param consent: Whether the principal have given her consent
        :param extensions: Possible extensions
        :param sign: Whether the query should be signed or not.
        :return: A LogoutRequest instance
        """

        if subject_id:
            if self.entity_type == "idp":
                name_id = NameID(text=self.users.get_entityid(subject_id,
                                                              issuer_entity_id,
                                                              False))
            else:
                name_id = NameID(text=subject_id)

        if not name_id:
            raise SAMLError("Missing subject identification")

        return self._message(LogoutRequest, destination, message_id,
                             consent, extensions, sign, name_id=name_id,
                             reason=reason, not_on_or_after=expire,
                             issuer=self._issuer())

    def create_logout_response(self, request, bindings=None, status=None,
                               sign=False, issuer=None):
        """ Create a LogoutResponse.

        :param request: The request this is a response to
        :param bindings: Which bindings that can be used for the response
            If None the preferred bindings are gathered from the configuration
        :param status: The return status of the response operation
            If None the operation is regarded as a Success.
        :param issuer: The issuer of the message
        :return: HTTP args
        """

        rinfo = self.response_args(request, bindings)

        if not issuer:
            issuer = self._issuer()

        response = self._status_response(samlp.LogoutResponse, issuer, status,
                                         sign, **rinfo)

        logger.info("Response: %s" % (response,))

        return response

    def create_artifact_resolve(self, artifact, destination, sessid,
                                consent=None, extensions=None, sign=False):
        """
        Create a ArtifactResolve request

        :param artifact:
        :param destination:
        :param sessid: session id
        :param consent:
        :param extensions:
        :param sign:
        :return: The request message
        """

        artifact = Artifact(text=artifact)

        return self._message(ArtifactResolve, destination, sessid,
                             consent, extensions, sign, artifact=artifact)

    def create_artifact_response(self, request, artifact, bindings=None,
                                 status=None, sign=False, issuer=None):
        """
        Create an ArtifactResponse
        :return:
        """

        rinfo = self.response_args(request, bindings)
        response = self._status_response(ArtifactResponse, issuer, status,
                                         sign=sign, **rinfo)

        msg = element_to_extension_element(self.artifact[artifact])
        response.extension_elements = [msg]

        logger.info("Response: %s" % (response,))

        return response

    def create_manage_name_id_request(self, destination, message_id=0, 
                                      consent=None, extensions=None, sign=False,
                                      name_id=None, new_id=None,
                                      encrypted_id=None, new_encrypted_id=None,
                                      terminate=None):
        """

        :param destination:
        :param message_id:
        :param consent:
        :param extensions:
        :param sign:
        :param name_id:
        :param new_id:
        :param encrypted_id:
        :param new_encrypted_id:
        :param terminate:
        :return:
        """
        kwargs = self.message_args(message_id)

        if name_id:
            kwargs["name_id"] = name_id
        elif encrypted_id:
            kwargs["encrypted_id"] = encrypted_id
        else:
            raise AttributeError(
                "One of NameID or EncryptedNameID has to be provided")

        if new_id:
            kwargs["new_id"] = new_id
        elif new_encrypted_id:
            kwargs["new_encrypted_id"] = new_encrypted_id
        elif terminate:
            kwargs["terminate"] = terminate
        else:
            raise AttributeError(
                "One of NewID, NewEncryptedNameID or Terminate has to be provided")

        return self._message(ManageNameIDRequest, destination, consent=consent,
                             extensions=extensions, sign=sign, **kwargs)

    def parse_manage_name_id_request(self, xmlstr, binding=BINDING_SOAP):
        """ Deal with a LogoutRequest

        :param xmlstr: The response as a xml string
        :param binding: What type of binding this message came through.
        :return: None if the reply doesn't contain a valid SAML LogoutResponse,
            otherwise the reponse if the logout was successful and None if it
            was not.
        """

        return self._parse_request(xmlstr, saml_request.ManageNameIDRequest,
                                   "manage_name_id_service", binding)

    def create_manage_name_id_response(self, request, bindings=None,
                                       status=None, sign=False, issuer=None,
                                       **kwargs):

        rinfo = self.response_args(request, bindings)

        response = self._status_response(samlp.ManageNameIDResponse, issuer,
                                         status, sign, **rinfo)

        logger.info("Response: %s" % (response,))

        return response

    def parse_manage_name_id_request_response(self, string, 
                                              binding=BINDING_SOAP):
        return self._parse_response(string, saml_response.ManageNameIDResponse,
                                    "manage_name_id_service", binding,
                                    asynchop=False)

    # ------------------------------------------------------------------------

    def _parse_response(self, xmlstr, response_cls, service, binding,
                        outstanding_certs=None, **kwargs):
        """ Deal with a Response

        :param xmlstr: The response as a xml string
        :param response_cls: What type of response it is
        :param binding: What type of binding this message came through.
        :param outstanding_certs: Certificates that belongs to me that the
                IdP may have used to encrypt a response/assertion/..
        :param kwargs: Extra key word arguments
        :return: None if the reply doesn't contain a valid SAML Response,
            otherwise the response.
        """

        response = None

        if self.config.accepted_time_diff:
            timeslack = self.config.accepted_time_diff

        if "asynchop" not in kwargs:
            if binding in [BINDING_SOAP, BINDING_PAOS]:
                asynchop = False
            else:
                asynchop = True

        if xmlstr:
            if "return_addrs" not in kwargs:
                if binding in [BINDING_HTTP_REDIRECT, BINDING_HTTP_POST]:
                    try:
                        # expected return address
                        return_addrs = self.config.endpoint(
                            service, binding=binding)
                    except Exception:
                        logger.info("Not supposed to handle this!")
                        return None

            try:
                response = response_cls(self.sec, **kwargs)
            except Exception, exc:
                logger.info("%s" % exc)
                raise

            xmlstr = self.unravel(xmlstr, binding, response_cls.msgtype)
            origxml = xmlstr
            if not xmlstr:  # Not a valid reponse
                return None

            try:
                response = response.loads(xmlstr, False, origxml=origxml)
            except SigverError, err:
                logger.error("Signature Error: %s" % err)
                raise
            except UnsolicitedResponse:
                logger.error("Unsolicited response")
                raise
            except Exception, err:
                if "not well-formed" in "%s" % err:
                    logger.error("Not well-formed XML")
                    raise

            logger.debug("XMLSTR: %s" % xmlstr)

            if response:
                if outstanding_certs:
                    _, key_file = make_temp(
                        "%s" % outstanding_certs[
                            response.in_response_to]["key"], decode=False)
                else:
                    key_file = ""
                response = response.verify(key_file)

            if not response:
                return None

            #logger.debug(response)

        return response

    # ------------------------------------------------------------------------

    def parse_logout_request_response(self, xmlstr, binding=BINDING_SOAP):
        return self._parse_response(xmlstr, LogoutResponse,
                                    "single_logout_service", binding)

    # ------------------------------------------------------------------------

    def parse_logout_request(self, xmlstr, binding=BINDING_SOAP):
        """ Deal with a LogoutRequest

        :param xmlstr: The response as a xml string
        :param binding: What type of binding this message came through.
        :return: None if the reply doesn't contain a valid SAML LogoutResponse,
            otherwise the reponse if the logout was successful and None if it
            was not.
        """

        return self._parse_request(xmlstr, saml_request.LogoutRequest,
                                   "single_logout_service", binding)

    def use_artifact(self, message, endpoint_index=0):
        """

        :param message:
        :param endpoint_index:
        :return:
        """
        message_handle = sha1("%s" % message)
        message_handle.update(rndstr())
        mhd = message_handle.digest()
        saml_art = create_artifact(self.config.entityid, mhd, endpoint_index)
        self.artifact[saml_art] = message
        return saml_art

    def artifact2destination(self, artifact, descriptor):
        """
        Translate an artifact into a receiver location

        :param artifact: The Base64 encoded SAML artifact
        :return:
        """

        _art = base64.b64decode(artifact)

        assert _art[:2] == ARTIFACT_TYPECODE

        try:
            endpoint_index = str(int(_art[2:4]))
        except ValueError:
            endpoint_index = str(int(hexlify(_art[2:4])))
        entity = self.sourceid[_art[4:24]]

        destination = None
        for desc in entity["%s_descriptor" % descriptor]:
            for srv in desc["artifact_resolution_service"]:
                if srv["index"] == endpoint_index:
                    destination = srv["location"]
                    break

        return destination

    def artifact2message(self, artifact, descriptor):
        """

        :param artifact: The Base64 encoded SAML artifact as sent over the net
        :param descriptor: The type of entity on the other side
        :return: A SAML message (request/response)
        """

        destination = self.artifact2destination(artifact, descriptor)

        if not destination:
            raise SAMLError("Missing endpoint location")

        _sid = sid()
        mid, msg = self.create_artifact_resolve(artifact, destination, _sid)
        return self.send_using_soap(msg, destination)

    def parse_artifact_resolve(self, txt, **kwargs):
        """
        Always done over SOAP

        :param txt: The SOAP enveloped ArtifactResolve
        :param kwargs:
        :return: An ArtifactResolve instance
        """

        _resp = parse_soap_enveloped_saml_artifact_resolve(txt)
        return artifact_resolve_from_string(_resp)

    def parse_artifact_resolve_response(self, xmlstr):
        kwargs = {"entity_id": self.config.entityid,
                  "attribute_converters": self.config.attribute_converters}

        resp = self._parse_response(xmlstr, saml_response.ArtifactResponse,
                                    "artifact_resolve", BINDING_SOAP,
                                    **kwargs)
        # should just be one
        elems = extension_elements_to_elements(resp.response.extension_elements,
                                               [samlp, saml])
        return elems[0]

########NEW FILE########
__FILENAME__ = at_egov_pvp2
__author__ = 'rhoerbe'  #2013-09-05
# Entity Categories specifying the PVP eGov Token as of "PVP2-Allgemein V2.1.0", http://www.ref.gv.at/


EGOVTOKEN = ["PVP-VERSION",
             "PVP-PRINCIPALNAME",
             "PVP-GIVENNAME",
             "PVP-BIRTHDATE",
             "PVP-USERID",
             "PVP-GID",
             "PVP-BPK",
             "PVP-MAIL",
             "PVP-TEL",
             "PVP-PARTICIPANT-ID",
             "PVP-PARTICIPANT-OKZ",
             "PVP-OU-OKZ",
             "PVP-OU",
             "PVP-OU-GV-OU-ID",
             "PVP-FUNCTION",
             "PVP-ROLES",
]


CHARGEATTR = ["PVP-INVOICE-RECPT-ID",
              "PVP-COST-CENTER-ID",
              "PVP-CHARGE-CODE",
]

# all eGov Token attributes except (1) transaction charging and (2) chaining
PVP2 = "http://www.ref.gv.at/ns/names/agiz/pvp/egovtoken"
# transaction charging extension
PVP2CHARGE = "http://www.ref.gv.at/ns/names/agiz/pvp/egovtoken-charge"

RELEASE = {
    PVP2: EGOVTOKEN,
    PVP2CHARGE: CHARGEATTR,
}

########NEW FILE########
__FILENAME__ = edugain
__author__ = 'rolandh'

COC = "http://www.geant.net/uri/dataprotection-code-of-conduct/v1"

RELEASE = {
    "": ["eduPersonTargetedID"],
    COC: ["eduPersonPrincipalName", "eduPersonScopedAffiliation", "mail",
          "displayName", "schacHomeOrganization"]
}


########NEW FILE########
__FILENAME__ = incommon
__author__ = 'rolandh'

RESEARCH_AND_SCHOLARSHIP = "http://id.incommon.org/category/research-and-scholarship"

RELEASE = {
    "": ["eduPersonTargetedID"],
    RESEARCH_AND_SCHOLARSHIP: ["eduPersonPrincipalName",
                               "eduPersonScopedAffiliation", "mail",
                               "givenName", "sn", "displayName"]
}


########NEW FILE########
__FILENAME__ = refeds
__author__ = 'rolandh'

RESEARCH_AND_SCHOLARSHIP = "http://refeds.org/category/research-and-scholarship"

RELEASE = {
    "": ["eduPersonTargetedID"],
    RESEARCH_AND_SCHOLARSHIP: ["eduPersonPrincipalName",
                               "eduPersonScopedAffiliation", "mail",
                               "givenName", "sn", "displayName"]
}


########NEW FILE########
__FILENAME__ = swamid
__author__ = 'rolandh'


NAME = ["givenName", "displayName", "sn"]
STATIC_ORG_INFO = ["c", "o", "co", "norEduOrgAcronym", "schacHomeOrganization"]
OTHER = ["eduPersonPrincipalName", "eduPersonScopedAffiliation", "mail"]

# These give you access to information
RESEARCH_AND_EDUCATION = "http://www.swamid.se/category/research-and-education"
SFS_1993_1153 = "http://www.swamid.se/category/sfs-1993-1153"

# presently these don't by themself
EU = "http://www.swamid.se/category/eu-adequate-protection"
NREN = "http://www.swamid.se/category/nren-service"
HEI = "http://www.swamid.se/category/hei-service"

RELEASE = {
    "": ["eduPersonTargetedID"],
    SFS_1993_1153: ["norEduPersonNIN"],
    (RESEARCH_AND_EDUCATION, EU): NAME + STATIC_ORG_INFO + OTHER,
    (RESEARCH_AND_EDUCATION, NREN): NAME + STATIC_ORG_INFO + OTHER,
    (RESEARCH_AND_EDUCATION, HEI): NAME + STATIC_ORG_INFO + OTHER,
}
########NEW FILE########
__FILENAME__ = eptid
# An eduPersonTargetedID comprises
# the entity name of the identity provider, the entity name of the service 
# provider, and a opaque string value.
# These strings are separated by "!" symbols. This form is advocated by 
# Internet2 and may overtake the other form in due course.

import hashlib
import shelve

import logging

logger = logging.getLogger(__name__)


class Eptid(object):
    def __init__(self, secret):
        self._db = {}
        self.secret = secret 
        
    def make(self, idp, sp, args):
        md5 = hashlib.md5()
        for arg in args:
            md5.update(arg.encode("utf-8"))
        md5.update(sp)
        md5.update(self.secret)
        md5.digest()
        hashval = md5.hexdigest()
        return "!".join([idp, sp, hashval])

    def __getitem__(self, key):
        return self._db[key]

    def __setitem__(self, key, value):
        self._db[key] = value

    def get(self, idp, sp, *args):
        # key is a combination of sp_entity_id and object id
        key = ("__".join([sp, args[0]])).encode("utf-8")
        try:
            return self[key]
        except KeyError:
            val = self.make(idp, sp, args)
            self[key] = val
            return val


class EptidShelve(Eptid):
    def __init__(self, secret, filename):
        Eptid.__init__(self, secret)
        self._db = shelve.open(filename, writeback=True)

########NEW FILE########
__FILENAME__ = algsupport
#!/usr/bin/env python

#
# Generated Sat Mar  8 16:15:12 2014 by parse_xsd.py version 0.5.
#

import saml2
from saml2 import SamlBase


NAMESPACE = 'urn:oasis:names:tc:SAML:metadata:algsupport'


class DigestMethodType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:algsupport:DigestMethodType
    element """

    c_tag = 'DigestMethodType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['Algorithm'] = ('algorithm', 'anyURI', True)

    def __init__(self,
                 algorithm=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.algorithm = algorithm


def digest_method_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DigestMethodType_, xml_string)


class SigningMethodType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:algsupport:SigningMethodType
    element """

    c_tag = 'SigningMethodType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['Algorithm'] = ('algorithm', 'anyURI', True)
    c_attributes['MinKeySize'] = ('min_key_size', 'positiveInteger', False)
    c_attributes['MaxKeySize'] = ('max_key_size', 'positiveInteger', False)

    def __init__(self,
                 algorithm=None,
                 min_key_size=None,
                 max_key_size=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.algorithm = algorithm
        self.min_key_size = min_key_size
        self.max_key_size = max_key_size


def signing_method_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SigningMethodType_, xml_string)


class DigestMethod(DigestMethodType_):
    """The urn:oasis:names:tc:SAML:metadata:algsupport:DigestMethod element """

    c_tag = 'DigestMethod'
    c_namespace = NAMESPACE
    c_children = DigestMethodType_.c_children.copy()
    c_attributes = DigestMethodType_.c_attributes.copy()
    c_child_order = DigestMethodType_.c_child_order[:]
    c_cardinality = DigestMethodType_.c_cardinality.copy()


def digest_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(DigestMethod, xml_string)


class SigningMethod(SigningMethodType_):
    """The urn:oasis:names:tc:SAML:metadata:algsupport:SigningMethod element """

    c_tag = 'SigningMethod'
    c_namespace = NAMESPACE
    c_children = SigningMethodType_.c_children.copy()
    c_attributes = SigningMethodType_.c_attributes.copy()
    c_child_order = SigningMethodType_.c_child_order[:]
    c_cardinality = SigningMethodType_.c_cardinality.copy()


def signing_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(SigningMethod, xml_string)


ELEMENT_FROM_STRING = {
    DigestMethod.c_tag: digest_method_from_string,
    DigestMethodType_.c_tag: digest_method_type__from_string,
    SigningMethod.c_tag: signing_method_from_string,
    SigningMethodType_.c_tag: signing_method_type__from_string,
}

ELEMENT_BY_TAG = {
    'DigestMethod': DigestMethod,
    'DigestMethodType': DigestMethodType_,
    'SigningMethod': SigningMethod,
    'SigningMethodType': SigningMethodType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = dri
#!/usr/bin/env python

#
# Generated Mon Oct 25 16:19:28 2010 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

from saml2 import md

NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:metadata:dri'


class CreationInstant(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:CreationInstant element """

    c_tag = 'CreationInstant'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'datetime'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def creation_instant_from_string(xml_string):
    return saml2.create_class_from_xml_string(CreationInstant, xml_string)


class SerialNumber(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:SerialNumber element """

    c_tag = 'SerialNumber'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def serial_number_from_string(xml_string):
    return saml2.create_class_from_xml_string(SerialNumber, xml_string)


class UsagePolicy(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:UsagePolicy element """

    c_tag = 'UsagePolicy'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def usage_policy_from_string(xml_string):
    return saml2.create_class_from_xml_string(UsagePolicy, xml_string)


class PublisherType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:PublisherType element """

    c_tag = 'PublisherType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['PublisherID'] = ('publisher_id', 'md:entityIDType', True)
    c_attributes['CreationInstant'] = ('creation_instant', 'datetime', False)
    c_attributes['SerialNumber'] = ('serial_number', 'string', False)

    def __init__(self,
                 publisher_id=None,
                 creation_instant=None,
                 serial_number=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.publisher_id = publisher_id
        self.creation_instant = creation_instant
        self.serial_number = serial_number


def publisher_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublisherType_, xml_string)


class RegistrationAuthority(md.EntityIDType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:RegistrationAuthority
    element """

    c_tag = 'RegistrationAuthority'
    c_namespace = NAMESPACE
    c_children = md.EntityIDType_.c_children.copy()
    c_attributes = md.EntityIDType_.c_attributes.copy()
    c_child_order = md.EntityIDType_.c_child_order[:]
    c_cardinality = md.EntityIDType_.c_cardinality.copy()


def registration_authority_from_string(xml_string):
    return saml2.create_class_from_xml_string(RegistrationAuthority, xml_string)


class RegistrationInstant(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:RegistrationInstant
    element """

    c_tag = 'RegistrationInstant'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'datetime'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def registration_instant_from_string(xml_string):
    return saml2.create_class_from_xml_string(RegistrationInstant, xml_string)


class RegistrationPolicy(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:RegistrationPolicy
    element """

    c_tag = 'RegistrationPolicy'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def registration_policy_from_string(xml_string):
    return saml2.create_class_from_xml_string(RegistrationPolicy, xml_string)


class Publisher(PublisherType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:Publisher element """

    c_tag = 'Publisher'
    c_namespace = NAMESPACE
    c_children = PublisherType_.c_children.copy()
    c_attributes = PublisherType_.c_attributes.copy()
    c_child_order = PublisherType_.c_child_order[:]
    c_cardinality = PublisherType_.c_cardinality.copy()


def publisher_from_string(xml_string):
    return saml2.create_class_from_xml_string(Publisher, xml_string)


class RegistrationInfoType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:RegistrationInfoType
    element """

    c_tag = 'RegistrationInfoType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata:dri}RegistrationAuthority'] = (
    'registration_authority', RegistrationAuthority)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata:dri}RegistrationInstant'] = (
    'registration_instant', RegistrationInstant)
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata:dri}RegistrationPolicy'] = (
    'registration_policy', RegistrationPolicy)
    c_cardinality['registration_policy'] = {"min": 0, "max": 1}
    c_child_order.extend(['registration_authority', 'registration_instant',
                          'registration_policy'])

    def __init__(self,
                 registration_authority=None,
                 registration_instant=None,
                 registration_policy=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.registration_authority = registration_authority
        self.registration_instant = registration_instant
        self.registration_policy = registration_policy


def registration_info_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RegistrationInfoType_, xml_string)


class PublishersType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:PublishersType element """

    c_tag = 'PublishersType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata:dri}Publisher'] = (
    'publisher', [Publisher])
    c_cardinality['publisher'] = {"min": 0}
    c_child_order.extend(['publisher'])

    def __init__(self,
                 publisher=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.publisher = publisher or []


def publishers_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublishersType_, xml_string)


class RegistrationInfo(RegistrationInfoType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:RegistrationInfo element """

    c_tag = 'RegistrationInfo'
    c_namespace = NAMESPACE
    c_children = RegistrationInfoType_.c_children.copy()
    c_attributes = RegistrationInfoType_.c_attributes.copy()
    c_child_order = RegistrationInfoType_.c_child_order[:]
    c_cardinality = RegistrationInfoType_.c_cardinality.copy()


def registration_info_from_string(xml_string):
    return saml2.create_class_from_xml_string(RegistrationInfo, xml_string)


class Publishers(PublishersType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:Publishers element """

    c_tag = 'Publishers'
    c_namespace = NAMESPACE
    c_children = PublishersType_.c_children.copy()
    c_attributes = PublishersType_.c_attributes.copy()
    c_child_order = PublishersType_.c_child_order[:]
    c_cardinality = PublishersType_.c_cardinality.copy()


def publishers_from_string(xml_string):
    return saml2.create_class_from_xml_string(Publishers, xml_string)


class DocumentInfoType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:DocumentInfoType element """

    c_tag = 'DocumentInfoType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata:dri}CreationInstant'] = (
    'creation_instant', CreationInstant)
    c_cardinality['creation_instant'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata:dri}SerialNumber'] = (
    'serial_number', SerialNumber)
    c_cardinality['serial_number'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata:dri}UsagePolicy'] = (
    'usage_policy', UsagePolicy)
    c_cardinality['usage_policy'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata:dri}Publishers'] = (
    'publishers', Publishers)
    c_cardinality['publishers'] = {"min": 0, "max": 1}
    c_child_order.extend(
        ['creation_instant', 'serial_number', 'usage_policy', 'publishers'])

    def __init__(self,
                 creation_instant=None,
                 serial_number=None,
                 usage_policy=None,
                 publishers=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.creation_instant = creation_instant
        self.serial_number = serial_number
        self.usage_policy = usage_policy
        self.publishers = publishers


def document_info_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DocumentInfoType_, xml_string)


class DocumentInfo(DocumentInfoType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:dri:DocumentInfo element """

    c_tag = 'DocumentInfo'
    c_namespace = NAMESPACE
    c_children = DocumentInfoType_.c_children.copy()
    c_attributes = DocumentInfoType_.c_attributes.copy()
    c_child_order = DocumentInfoType_.c_child_order[:]
    c_cardinality = DocumentInfoType_.c_cardinality.copy()


def document_info_from_string(xml_string):
    return saml2.create_class_from_xml_string(DocumentInfo, xml_string)


ELEMENT_FROM_STRING = {
    DocumentInfo.c_tag: document_info_from_string,
    DocumentInfoType_.c_tag: document_info_type__from_string,
    CreationInstant.c_tag: creation_instant_from_string,
    SerialNumber.c_tag: serial_number_from_string,
    UsagePolicy.c_tag: usage_policy_from_string,
    Publishers.c_tag: publishers_from_string,
    PublishersType_.c_tag: publishers_type__from_string,
    Publisher.c_tag: publisher_from_string,
    PublisherType_.c_tag: publisher_type__from_string,
    RegistrationInfo.c_tag: registration_info_from_string,
    RegistrationInfoType_.c_tag: registration_info_type__from_string,
    RegistrationAuthority.c_tag: registration_authority_from_string,
    RegistrationInstant.c_tag: registration_instant_from_string,
    RegistrationPolicy.c_tag: registration_policy_from_string,
}

ELEMENT_BY_TAG = {
    'DocumentInfo': DocumentInfo,
    'DocumentInfoType': DocumentInfoType_,
    'CreationInstant': CreationInstant,
    'SerialNumber': SerialNumber,
    'UsagePolicy': UsagePolicy,
    'Publishers': Publishers,
    'PublishersType': PublishersType_,
    'Publisher': Publisher,
    'PublisherType': PublisherType_,
    'RegistrationInfo': RegistrationInfo,
    'RegistrationInfoType': RegistrationInfoType_,
    'RegistrationAuthority': RegistrationAuthority,
    'RegistrationInstant': RegistrationInstant,
    'RegistrationPolicy': RegistrationPolicy,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = idpdisc
#!/usr/bin/env python

#
# Generated Thu Jun 23 09:01:47 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import md

NAMESPACE = 'urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol'
BINDING_DISCO = "urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol"


class DiscoveryResponse(md.IndexedEndpointType_):
    """The urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol:
    DiscoveryResponse element """

    c_tag = 'DiscoveryResponse'
    c_namespace = NAMESPACE
    c_children = md.IndexedEndpointType_.c_children.copy()
    c_attributes = md.IndexedEndpointType_.c_attributes.copy()
    c_child_order = md.IndexedEndpointType_.c_child_order[:]
    c_cardinality = md.IndexedEndpointType_.c_cardinality.copy()


def discovery_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(DiscoveryResponse, xml_string)


ELEMENT_FROM_STRING = {
    DiscoveryResponse.c_tag: discovery_response_from_string,
}

ELEMENT_BY_TAG = {
    'DiscoveryResponse': DiscoveryResponse,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = mdattr
#!/usr/bin/env python

#
# Generated Mon May  2 14:23:34 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

from saml2 import saml

NAMESPACE = 'urn:oasis:names:tc:SAML:metadata:attribute'

class EntityAttributesType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:attribute:EntityAttributesType element """

    c_tag = 'EntityAttributesType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Attribute'] = ('attribute', [saml.Attribute])
    c_cardinality['attribute'] = {"min":0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Assertion'] = ('assertion', [saml.Assertion])
    c_cardinality['assertion'] = {"min":0}
    c_child_order.extend(['attribute', 'assertion'])

    def __init__(self,
            attribute=None,
            assertion=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.attribute=attribute or []
        self.assertion=assertion or []

def entity_attributes_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(EntityAttributesType_, xml_string)


class EntityAttributes(EntityAttributesType_):
    """The urn:oasis:names:tc:SAML:metadata:attribute:EntityAttributes element """

    c_tag = 'EntityAttributes'
    c_namespace = NAMESPACE
    c_children = EntityAttributesType_.c_children.copy()
    c_attributes = EntityAttributesType_.c_attributes.copy()
    c_child_order = EntityAttributesType_.c_child_order[:]
    c_cardinality = EntityAttributesType_.c_cardinality.copy()

def entity_attributes_from_string(xml_string):
    return saml2.create_class_from_xml_string(EntityAttributes, xml_string)


ELEMENT_FROM_STRING = {
    EntityAttributes.c_tag: entity_attributes_from_string,
    EntityAttributesType_.c_tag: entity_attributes_type__from_string,
}

ELEMENT_BY_TAG = {
    'EntityAttributes': EntityAttributes,
    'EntityAttributesType': EntityAttributesType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = mdrpi
#!/usr/bin/env python

#
# Generated Mon Jun 27 09:54:22 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

from saml2 import md

NAMESPACE = 'urn:oasis:names:tc:SAML:metadata:rpi'


class RegistrationPolicy(md.LocalizedURIType_):
    """The urn:oasis:names:tc:SAML:metadata:rpi:RegistrationPolicy element """

    c_tag = 'RegistrationPolicy'
    c_namespace = NAMESPACE
    c_children = md.LocalizedURIType_.c_children.copy()
    c_attributes = md.LocalizedURIType_.c_attributes.copy()
    c_child_order = md.LocalizedURIType_.c_child_order[:]
    c_cardinality = md.LocalizedURIType_.c_cardinality.copy()


def registration_policy_from_string(xml_string):
    return saml2.create_class_from_xml_string(RegistrationPolicy, xml_string)


class UsagePolicy(md.LocalizedURIType_):
    """The urn:oasis:names:tc:SAML:metadata:rpi:UsagePolicy element """

    c_tag = 'UsagePolicy'
    c_namespace = NAMESPACE
    c_children = md.LocalizedURIType_.c_children.copy()
    c_attributes = md.LocalizedURIType_.c_attributes.copy()
    c_child_order = md.LocalizedURIType_.c_child_order[:]
    c_cardinality = md.LocalizedURIType_.c_cardinality.copy()


def usage_policy_from_string(xml_string):
    return saml2.create_class_from_xml_string(UsagePolicy, xml_string)


class PublicationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:rpi:PublicationType element """

    c_tag = 'PublicationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['publisher'] = ('publisher', 'string', True)
    c_attributes['creationInstant'] = ('creation_instant', 'dateTime', False)
    c_attributes['publicationId'] = ('publication_id', 'string', False)

    def __init__(self,
                 publisher=None,
                 creation_instant=None,
                 publication_id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.publisher = publisher
        self.creation_instant = creation_instant
        self.publication_id = publication_id


def publication_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicationType_, xml_string)


class RegistrationInfoType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:rpi:RegistrationInfoType element """

    c_tag = 'RegistrationInfoType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:metadata:rpi}RegistrationPolicy'] = (
    'registration_policy', [RegistrationPolicy])
    c_cardinality['registration_policy'] = {"min": 0}
    c_attributes['registrationAuthority'] = (
    'registration_authority', 'string', True)
    c_attributes['registrationInstant'] = (
    'registration_instant', 'dateTime', False)
    c_child_order.extend(['registration_policy'])

    def __init__(self,
                 registration_policy=None,
                 registration_authority=None,
                 registration_instant=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.registration_policy = registration_policy or []
        self.registration_authority = registration_authority
        self.registration_instant = registration_instant


def registration_info_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RegistrationInfoType_, xml_string)


class PublicationInfoType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:rpi:PublicationInfoType element """

    c_tag = 'PublicationInfoType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:metadata:rpi}UsagePolicy'] = (
    'usage_policy', [UsagePolicy])
    c_cardinality['usage_policy'] = {"min": 0}
    c_attributes['publisher'] = ('publisher', 'string', True)
    c_attributes['creationInstant'] = ('creation_instant', 'dateTime', False)
    c_attributes['publicationId'] = ('publication_id', 'string', False)
    c_child_order.extend(['usage_policy'])

    def __init__(self,
                 usage_policy=None,
                 publisher=None,
                 creation_instant=None,
                 publication_id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.usage_policy = usage_policy or []
        self.publisher = publisher
        self.creation_instant = creation_instant
        self.publication_id = publication_id


def publication_info_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicationInfoType_, xml_string)


class Publication(PublicationType_):
    """The urn:oasis:names:tc:SAML:metadata:rpi:Publication element """

    c_tag = 'Publication'
    c_namespace = NAMESPACE
    c_children = PublicationType_.c_children.copy()
    c_attributes = PublicationType_.c_attributes.copy()
    c_child_order = PublicationType_.c_child_order[:]
    c_cardinality = PublicationType_.c_cardinality.copy()


def publication_from_string(xml_string):
    return saml2.create_class_from_xml_string(Publication, xml_string)


class RegistrationInfo(RegistrationInfoType_):
    """The urn:oasis:names:tc:SAML:metadata:rpi:RegistrationInfo element """

    c_tag = 'RegistrationInfo'
    c_namespace = NAMESPACE
    c_children = RegistrationInfoType_.c_children.copy()
    c_attributes = RegistrationInfoType_.c_attributes.copy()
    c_child_order = RegistrationInfoType_.c_child_order[:]
    c_cardinality = RegistrationInfoType_.c_cardinality.copy()


def registration_info_from_string(xml_string):
    return saml2.create_class_from_xml_string(RegistrationInfo, xml_string)


class PublicationInfo(PublicationInfoType_):
    """The urn:oasis:names:tc:SAML:metadata:rpi:PublicationInfo element """

    c_tag = 'PublicationInfo'
    c_namespace = NAMESPACE
    c_children = PublicationInfoType_.c_children.copy()
    c_attributes = PublicationInfoType_.c_attributes.copy()
    c_child_order = PublicationInfoType_.c_child_order[:]
    c_cardinality = PublicationInfoType_.c_cardinality.copy()


def publication_info_from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicationInfo, xml_string)


class PublicationPathType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:rpi:PublicationPathType element """

    c_tag = 'PublicationPathType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:metadata:rpi}Publication'] = (
    'publication', [Publication])
    c_cardinality['publication'] = {"min": 0}
    c_child_order.extend(['publication'])

    def __init__(self,
                 publication=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.publication = publication or []


def publication_path_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicationPathType_, xml_string)


class PublicationPath(PublicationPathType_):
    """The urn:oasis:names:tc:SAML:metadata:rpi:PublicationPath element """

    c_tag = 'PublicationPath'
    c_namespace = NAMESPACE
    c_children = PublicationPathType_.c_children.copy()
    c_attributes = PublicationPathType_.c_attributes.copy()
    c_child_order = PublicationPathType_.c_child_order[:]
    c_cardinality = PublicationPathType_.c_cardinality.copy()


def publication_path_from_string(xml_string):
    return saml2.create_class_from_xml_string(PublicationPath, xml_string)


ELEMENT_FROM_STRING = {
    RegistrationInfo.c_tag: registration_info_from_string,
    RegistrationInfoType_.c_tag: registration_info_type__from_string,
    RegistrationPolicy.c_tag: registration_policy_from_string,
    PublicationInfo.c_tag: publication_info_from_string,
    PublicationInfoType_.c_tag: publication_info_type__from_string,
    UsagePolicy.c_tag: usage_policy_from_string,
    PublicationPath.c_tag: publication_path_from_string,
    PublicationPathType_.c_tag: publication_path_type__from_string,
    Publication.c_tag: publication_from_string,
    PublicationType_.c_tag: publication_type__from_string,
}

ELEMENT_BY_TAG = {
    'RegistrationInfo': RegistrationInfo,
    'RegistrationInfoType': RegistrationInfoType_,
    'RegistrationPolicy': RegistrationPolicy,
    'PublicationInfo': PublicationInfo,
    'PublicationInfoType': PublicationInfoType_,
    'UsagePolicy': UsagePolicy,
    'PublicationPath': PublicationPath,
    'PublicationPathType': PublicationPathType_,
    'Publication': Publication,
    'PublicationType': PublicationType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = mdui
#!/usr/bin/env python

#
# Generated Mon May  2 14:23:33 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

from saml2 import md

NAMESPACE = 'urn:oasis:names:tc:SAML:metadata:ui'


class DisplayName(md.LocalizedNameType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:DisplayName element """

    c_tag = 'DisplayName'
    c_namespace = NAMESPACE
    c_children = md.LocalizedNameType_.c_children.copy()
    c_attributes = md.LocalizedNameType_.c_attributes.copy()
    c_child_order = md.LocalizedNameType_.c_child_order[:]
    c_cardinality = md.LocalizedNameType_.c_cardinality.copy()


def display_name_from_string(xml_string):
    return saml2.create_class_from_xml_string(DisplayName, xml_string)


class Description(md.LocalizedNameType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:Description element """

    c_tag = 'Description'
    c_namespace = NAMESPACE
    c_children = md.LocalizedNameType_.c_children.copy()
    c_attributes = md.LocalizedNameType_.c_attributes.copy()
    c_child_order = md.LocalizedNameType_.c_child_order[:]
    c_cardinality = md.LocalizedNameType_.c_cardinality.copy()


def description_from_string(xml_string):
    return saml2.create_class_from_xml_string(Description, xml_string)


class InformationURL(md.LocalizedURIType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:InformationURL element """

    c_tag = 'InformationURL'
    c_namespace = NAMESPACE
    c_children = md.LocalizedURIType_.c_children.copy()
    c_attributes = md.LocalizedURIType_.c_attributes.copy()
    c_child_order = md.LocalizedURIType_.c_child_order[:]
    c_cardinality = md.LocalizedURIType_.c_cardinality.copy()


def information_url_from_string(xml_string):
    return saml2.create_class_from_xml_string(InformationURL, xml_string)


class PrivacyStatementURL(md.LocalizedURIType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:PrivacyStatementURL element """

    c_tag = 'PrivacyStatementURL'
    c_namespace = NAMESPACE
    c_children = md.LocalizedURIType_.c_children.copy()
    c_attributes = md.LocalizedURIType_.c_attributes.copy()
    c_child_order = md.LocalizedURIType_.c_child_order[:]
    c_cardinality = md.LocalizedURIType_.c_cardinality.copy()


def privacy_statement_url_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivacyStatementURL, xml_string)


class ListOfStrings_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:listOfStrings element """

    c_tag = 'listOfStrings'
    c_namespace = NAMESPACE
    c_value_type = {'member': 'string', 'base': 'list'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def list_of_strings__from_string(xml_string):
    return saml2.create_class_from_xml_string(ListOfStrings_, xml_string)


class KeywordsType_(ListOfStrings_):
    """The urn:oasis:names:tc:SAML:metadata:ui:KeywordsType element """

    c_tag = 'KeywordsType'
    c_namespace = NAMESPACE
    c_children = ListOfStrings_.c_children.copy()
    c_attributes = ListOfStrings_.c_attributes.copy()
    c_child_order = ListOfStrings_.c_child_order[:]
    c_cardinality = ListOfStrings_.c_cardinality.copy()
    c_attributes['{http://www.w3.org/XML/1998/namespace}lang'] = (
    'lang', 'mdui:listOfStrings', True)

    def __init__(self,
                 lang=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        ListOfStrings_.__init__(self,
                                text=text,
                                extension_elements=extension_elements,
                                extension_attributes=extension_attributes)
        self.lang = lang


def keywords_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeywordsType_, xml_string)


class LogoType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:LogoType element """

    c_tag = 'LogoType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['height'] = ('height', 'positiveInteger', True)
    c_attributes['width'] = ('width', 'positiveInteger', True)
    c_attributes['{http://www.w3.org/XML/1998/namespace}lang'] = (
        'lang', 'anyURI', False)

    def __init__(self,
                 height=None,
                 width=None,
                 lang=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.height = height
        self.width = width
        self.lang = lang


def logo_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LogoType_, xml_string)


class IPHint(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:IPHint element """

    c_tag = 'IPHint'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def ip_hint_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPHint, xml_string)


class DomainHint(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:DomainHint element """

    c_tag = 'DomainHint'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def domain_hint_from_string(xml_string):
    return saml2.create_class_from_xml_string(DomainHint, xml_string)


class GeolocationHint(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:GeolocationHint element """

    c_tag = 'GeolocationHint'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def geolocation_hint_from_string(xml_string):
    return saml2.create_class_from_xml_string(GeolocationHint, xml_string)


class Keywords(KeywordsType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:Keywords element """

    c_tag = 'Keywords'
    c_namespace = NAMESPACE
    c_children = KeywordsType_.c_children.copy()
    c_attributes = KeywordsType_.c_attributes.copy()
    c_child_order = KeywordsType_.c_child_order[:]
    c_cardinality = KeywordsType_.c_cardinality.copy()


def keywords_from_string(xml_string):
    return saml2.create_class_from_xml_string(Keywords, xml_string)


class Logo(LogoType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:Logo element """

    c_tag = 'Logo'
    c_namespace = NAMESPACE
    c_children = LogoType_.c_children.copy()
    c_attributes = LogoType_.c_attributes.copy()
    c_child_order = LogoType_.c_child_order[:]
    c_cardinality = LogoType_.c_cardinality.copy()


def logo_from_string(xml_string):
    return saml2.create_class_from_xml_string(Logo, xml_string)


class DiscoHintsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:DiscoHintsType element """

    c_tag = 'DiscoHintsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}IPHint'] = (
        'ip_hint', [IPHint])
    c_cardinality['ip_hint'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}DomainHint'] = (
        'domain_hint', [DomainHint])
    c_cardinality['domain_hint'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}GeolocationHint'] = (
        'geolocation_hint', [GeolocationHint])
    c_cardinality['geolocation_hint'] = {"min": 0}
    c_child_order.extend(['ip_hint', 'domain_hint', 'geolocation_hint'])

    def __init__(self,
                 ip_hint=None,
                 domain_hint=None,
                 geolocation_hint=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.ip_hint = ip_hint or []
        self.domain_hint = domain_hint or []
        self.geolocation_hint = geolocation_hint or []


def disco_hints_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DiscoHintsType_, xml_string)


class UIInfoType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:UIInfoType element """

    c_tag = 'UIInfoType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}DisplayName'] = (
        'display_name', [DisplayName])
    c_cardinality['display_name'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}Description'] = (
        'description', [Description])
    c_cardinality['description'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}Keywords'] = (
        'keywords', [Keywords])
    c_cardinality['keywords'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}Logo'] = ('logo', [Logo])
    c_cardinality['logo'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}InformationURL'] = (
        'information_url', [InformationURL])
    c_cardinality['information_url'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}PrivacyStatementURL'] = (
        'privacy_statement_url', [PrivacyStatementURL])
    c_cardinality['privacy_statement_url'] = {"min": 0}
    c_child_order.extend(
        ['display_name', 'description', 'keywords', 'logo', 'information_url',
         'privacy_statement_url'])

    def __init__(self,
                 display_name=None,
                 description=None,
                 keywords=None,
                 logo=None,
                 information_url=None,
                 privacy_statement_url=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.display_name = display_name or []
        self.description = description or []
        self.keywords = keywords or []
        self.logo = logo or []
        self.information_url = information_url or []
        self.privacy_statement_url = privacy_statement_url or []


def ui_info_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(UIInfoType_, xml_string)


class DiscoHints(DiscoHintsType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:DiscoHints element """

    c_tag = 'DiscoHints'
    c_namespace = NAMESPACE
    c_children = DiscoHintsType_.c_children.copy()
    c_attributes = DiscoHintsType_.c_attributes.copy()
    c_child_order = DiscoHintsType_.c_child_order[:]
    c_cardinality = DiscoHintsType_.c_cardinality.copy()


def disco_hints_from_string(xml_string):
    return saml2.create_class_from_xml_string(DiscoHints, xml_string)


class UIInfo(UIInfoType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:UIInfo element """

    c_tag = 'UIInfo'
    c_namespace = NAMESPACE
    c_children = UIInfoType_.c_children.copy()
    c_attributes = UIInfoType_.c_attributes.copy()
    c_child_order = UIInfoType_.c_child_order[:]
    c_cardinality = UIInfoType_.c_cardinality.copy()


def ui_info_from_string(xml_string):
    return saml2.create_class_from_xml_string(UIInfo, xml_string)


ELEMENT_FROM_STRING = {
    UIInfo.c_tag: ui_info_from_string,
    UIInfoType_.c_tag: ui_info_type__from_string,
    DisplayName.c_tag: display_name_from_string,
    Description.c_tag: description_from_string,
    InformationURL.c_tag: information_url_from_string,
    PrivacyStatementURL.c_tag: privacy_statement_url_from_string,
    Keywords.c_tag: keywords_from_string,
    KeywordsType_.c_tag: keywords_type__from_string,
    ListOfStrings_.c_tag: list_of_strings__from_string,
    Logo.c_tag: logo_from_string,
    LogoType_.c_tag: logo_type__from_string,
    DiscoHints.c_tag: disco_hints_from_string,
    DiscoHintsType_.c_tag: disco_hints_type__from_string,
    IPHint.c_tag: ip_hint_from_string,
    DomainHint.c_tag: domain_hint_from_string,
    GeolocationHint.c_tag: geolocation_hint_from_string,
}

ELEMENT_BY_TAG = {
    'UIInfo': UIInfo,
    'UIInfoType': UIInfoType_,
    'DisplayName': DisplayName,
    'Description': Description,
    'InformationURL': InformationURL,
    'PrivacyStatementURL': PrivacyStatementURL,
    'Keywords': Keywords,
    'KeywordsType': KeywordsType_,
    'listOfStrings': ListOfStrings_,
    'Logo': Logo,
    'LogoType': LogoType_,
    'DiscoHints': DiscoHints,
    'DiscoHintsType': DiscoHintsType_,
    'IPHint': IPHint,
    'DomainHint': DomainHint,
    'GeolocationHint': GeolocationHint,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)

########NEW FILE########
__FILENAME__ = pefim
#!/usr/bin/env python

import saml2
from saml2 import SamlBase
from xmldsig import X509Data

NAMESPACE = 'urn:net:eustix:names:tc:PEFIM:0.0:assertion'


class SPCertEncType_(SamlBase):
    """The urn:net:eustix:names:tc:PEFIM:0.0:assertion:SPCertEncType element """

    c_tag = 'SPCertEncType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2000/09/xmldsig#}X509Data'] = ('x509_data',
                                                                  [X509Data])

    def __init__(self,
                 x509_data=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.x509_data = x509_data


def spcertenc_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SPCertEncType_, xml_string)


class SPCertEnc(SPCertEncType_):
    """The urn:net:eustix:names:tc:PEFIM:0.0:assertion:SPCertEnc element """

    c_tag = 'SPCertEnc'
    c_namespace = NAMESPACE
    c_children = SPCertEncType_.c_children.copy()
    c_attributes = SPCertEncType_.c_attributes.copy()
    c_child_order = SPCertEncType_.c_child_order[:]
    c_cardinality = SPCertEncType_.c_cardinality.copy()


def spcertenc_from_string(xml_string):
    return saml2.create_class_from_xml_string(SPCertEnc, xml_string)


ELEMENT_FROM_STRING = {
    SPCertEnc.c_tag: spcertenc_from_string,
    SPCertEncType_.c_tag: spcertenc_type__from_string,
}

ELEMENT_BY_TAG = {
    'SPCertEnc': SPCertEnc,
    'SPCertEncType': SPCertEncType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = reqinit
#!/usr/bin/env python

#
# Generated Thu May 15 13:58:36 2014 by parse_xsd.py version 0.5.
#

import saml2

from saml2 import md

NAMESPACE = 'urn:oasis:names:tc:SAML:profiles:SSO:request-init'


class RequestInitiator(md.EndpointType_):
    """The urn:oasis:names:tc:SAML:profiles:SSO:request-init:RequestInitiator
    element """

    c_tag = 'RequestInitiator'
    c_namespace = NAMESPACE
    c_children = md.EndpointType_.c_children.copy()
    c_attributes = md.EndpointType_.c_attributes.copy()
    c_child_order = md.EndpointType_.c_child_order[:]
    c_cardinality = md.EndpointType_.c_cardinality.copy()


def request_initiator_from_string(xml_string):
    return saml2.create_class_from_xml_string(RequestInitiator, xml_string)


ELEMENT_FROM_STRING = {
    RequestInitiator.c_tag: request_initiator_from_string,
}

ELEMENT_BY_TAG = {
    'RequestInitiator': RequestInitiator,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = shibmd
#!/usr/bin/env python

#
# Generated Sun Mar 20 18:06:44 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

import xmldsig as ds

NAMESPACE = 'urn:mace:shibboleth:metadata:1.0'


class Scope(SamlBase):
    """The urn:mace:shibboleth:metadata:1.0:Scope element """

    c_tag = 'Scope'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['regexp'] = ('regexp', 'boolean', False)

    def __init__(self,
                 regexp='false',
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.regexp = regexp


def scope_from_string(xml_string):
    return saml2.create_class_from_xml_string(Scope, xml_string)


class KeyAuthority(SamlBase):
    """The urn:mace:shibboleth:metadata:1.0:KeyAuthority element """

    c_tag = 'KeyAuthority'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2000/09/xmldsig#}KeyInfo'] = ('key_info',
                                                                 [ds.KeyInfo])
    c_cardinality['key_info'] = {"min": 1}
    c_attributes['VerifyDepth'] = ('verify_depth', 'unsignedByte', False)
    c_child_order.extend(['key_info'])

    def __init__(self,
                 key_info=None,
                 verify_depth='1',
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.key_info = key_info or []
        self.verify_depth = verify_depth


def key_authority_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyAuthority, xml_string)


ELEMENT_FROM_STRING = {
    Scope.c_tag: scope_from_string,
    KeyAuthority.c_tag: key_authority_from_string,
}

ELEMENT_BY_TAG = {
    'Scope': Scope,
    'KeyAuthority': KeyAuthority,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)

########NEW FILE########
__FILENAME__ = ui
#!/usr/bin/env python

#
# Generated Mon Oct 25 16:17:51 2010 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

from saml2 import md

NAMESPACE = 'urn:oasis:names:tc:SAML:metadata:ui'


class DisplayName(md.LocalizedNameType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:DisplayName element """

    c_tag = 'DisplayName'
    c_namespace = NAMESPACE
    c_children = md.LocalizedNameType_.c_children.copy()
    c_attributes = md.LocalizedNameType_.c_attributes.copy()
    c_child_order = md.LocalizedNameType_.c_child_order[:]
    c_cardinality = md.LocalizedNameType_.c_cardinality.copy()


def display_name_from_string(xml_string):
    return saml2.create_class_from_xml_string(DisplayName, xml_string)


class Description(md.LocalizedNameType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:Description element """

    c_tag = 'Description'
    c_namespace = NAMESPACE
    c_children = md.LocalizedNameType_.c_children.copy()
    c_attributes = md.LocalizedNameType_.c_attributes.copy()
    c_child_order = md.LocalizedNameType_.c_child_order[:]
    c_cardinality = md.LocalizedNameType_.c_cardinality.copy()


def description_from_string(xml_string):
    return saml2.create_class_from_xml_string(Description, xml_string)


class InformationURL(md.LocalizedURIType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:InformationURL element """

    c_tag = 'InformationURL'
    c_namespace = NAMESPACE
    c_children = md.LocalizedURIType_.c_children.copy()
    c_attributes = md.LocalizedURIType_.c_attributes.copy()
    c_child_order = md.LocalizedURIType_.c_child_order[:]
    c_cardinality = md.LocalizedURIType_.c_cardinality.copy()


def information_url_from_string(xml_string):
    return saml2.create_class_from_xml_string(InformationURL, xml_string)


class PrivacyStatementURL(md.LocalizedURIType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:PrivacyStatementURL element """

    c_tag = 'PrivacyStatementURL'
    c_namespace = NAMESPACE
    c_children = md.LocalizedURIType_.c_children.copy()
    c_attributes = md.LocalizedURIType_.c_attributes.copy()
    c_child_order = md.LocalizedURIType_.c_child_order[:]
    c_cardinality = md.LocalizedURIType_.c_cardinality.copy()


def privacy_statement_url_from_string(xml_string):
    return saml2.create_class_from_xml_string(PrivacyStatementURL, xml_string)


class LogoType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:LogoType element """

    c_tag = 'LogoType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['height'] = ('height', 'positiveInteger', True)
    c_attributes['width'] = ('width', 'positiveInteger', True)
    c_attributes['{http://www.w3.org/XML/1998/namespace}lang'] = (
        'lang', 'anyURI', False)

    def __init__(self,
                 height=None,
                 width=None,
                 lang=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.height = height
        self.width = width
        self.lang = lang


def logo_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LogoType_, xml_string)


class IPHint(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:IPHint element """

    c_tag = 'IPHint'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def ip_hint_from_string(xml_string):
    return saml2.create_class_from_xml_string(IPHint, xml_string)


class DomainHint(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:DomainHint element """

    c_tag = 'DomainHint'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def domain_hint_from_string(xml_string):
    return saml2.create_class_from_xml_string(DomainHint, xml_string)


class GeolocationHint(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:GeolocationHint element """

    c_tag = 'GeolocationHint'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def geolocation_hint_from_string(xml_string):
    return saml2.create_class_from_xml_string(GeolocationHint, xml_string)


class Logo(LogoType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:Logo element """

    c_tag = 'Logo'
    c_namespace = NAMESPACE
    c_children = LogoType_.c_children.copy()
    c_attributes = LogoType_.c_attributes.copy()
    c_child_order = LogoType_.c_child_order[:]
    c_cardinality = LogoType_.c_cardinality.copy()


def logo_from_string(xml_string):
    return saml2.create_class_from_xml_string(Logo, xml_string)


class DiscoHintsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:DiscoHintsType element """

    c_tag = 'DiscoHintsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}IPHint'] = (
        'ip_hint', [IPHint])
    c_cardinality['ip_hint'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}DomainHint'] = (
        'domain_hint', [DomainHint])
    c_cardinality['domain_hint'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}GeolocationHint'] = (
        'geolocation_hint', [GeolocationHint])
    c_cardinality['geolocation_hint'] = {"min": 0}
    c_child_order.extend(['ip_hint', 'domain_hint', 'geolocation_hint'])

    def __init__(self,
                 ip_hint=None,
                 domain_hint=None,
                 geolocation_hint=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.ip_hint = ip_hint or []
        self.domain_hint = domain_hint or []
        self.geolocation_hint = geolocation_hint or []


def disco_hints_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DiscoHintsType_, xml_string)


class UIInfoType_(SamlBase):
    """The urn:oasis:names:tc:SAML:metadata:ui:UIInfoType element """

    c_tag = 'UIInfoType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}DisplayName'] = (
        'display_name', [DisplayName])
    c_cardinality['display_name'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}Description'] = (
        'description', [Description])
    c_cardinality['description'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}Logo'] = ('logo', [Logo])
    c_cardinality['logo'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}InformationURL'] = (
        'information_url', [InformationURL])
    c_cardinality['information_url'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:metadata:ui}PrivacyStatementURL'] = (
        'privacy_statement_url', [PrivacyStatementURL])
    c_cardinality['privacy_statement_url'] = {"min": 0}
    c_child_order.extend(
        ['display_name', 'description', 'logo', 'information_url',
         'privacy_statement_url'])

    def __init__(self,
                 display_name=None,
                 description=None,
                 logo=None,
                 information_url=None,
                 privacy_statement_url=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.display_name = display_name or []
        self.description = description or []
        self.logo = logo or []
        self.information_url = information_url or []
        self.privacy_statement_url = privacy_statement_url or []


def ui_info_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(UIInfoType_, xml_string)


class DiscoHints(DiscoHintsType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:DiscoHints element """

    c_tag = 'DiscoHints'
    c_namespace = NAMESPACE
    c_children = DiscoHintsType_.c_children.copy()
    c_attributes = DiscoHintsType_.c_attributes.copy()
    c_child_order = DiscoHintsType_.c_child_order[:]
    c_cardinality = DiscoHintsType_.c_cardinality.copy()


def disco_hints_from_string(xml_string):
    return saml2.create_class_from_xml_string(DiscoHints, xml_string)


class UIInfo(UIInfoType_):
    """The urn:oasis:names:tc:SAML:metadata:ui:UIInfo element """

    c_tag = 'UIInfo'
    c_namespace = NAMESPACE
    c_children = UIInfoType_.c_children.copy()
    c_attributes = UIInfoType_.c_attributes.copy()
    c_child_order = UIInfoType_.c_child_order[:]
    c_cardinality = UIInfoType_.c_cardinality.copy()


def ui_info_from_string(xml_string):
    return saml2.create_class_from_xml_string(UIInfo, xml_string)


ELEMENT_FROM_STRING = {
    UIInfo.c_tag: ui_info_from_string,
    UIInfoType_.c_tag: ui_info_type__from_string,
    DisplayName.c_tag: display_name_from_string,
    Description.c_tag: description_from_string,
    InformationURL.c_tag: information_url_from_string,
    PrivacyStatementURL.c_tag: privacy_statement_url_from_string,
    Logo.c_tag: logo_from_string,
    LogoType_.c_tag: logo_type__from_string,
    DiscoHints.c_tag: disco_hints_from_string,
    DiscoHintsType_.c_tag: disco_hints_type__from_string,
    IPHint.c_tag: ip_hint_from_string,
    DomainHint.c_tag: domain_hint_from_string,
    GeolocationHint.c_tag: geolocation_hint_from_string,
}

ELEMENT_BY_TAG = {
    'UIInfo': UIInfo,
    'UIInfoType': UIInfoType_,
    'DisplayName': DisplayName,
    'Description': Description,
    'InformationURL': InformationURL,
    'PrivacyStatementURL': PrivacyStatementURL,
    'Logo': Logo,
    'LogoType': LogoType_,
    'DiscoHints': DiscoHints,
    'DiscoHintsType': DiscoHintsType_,
    'IPHint': IPHint,
    'DomainHint': DomainHint,
    'GeolocationHint': GeolocationHint,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = httpbase
import calendar
import cookielib
import copy
import re
import urllib
import urlparse
import requests
import time
from Cookie import SimpleCookie
from saml2.time_util import utc_now
from saml2 import class_name, SAMLError
from saml2.pack import http_form_post_message
from saml2.pack import make_soap_enveloped_saml_thingy
from saml2.pack import http_redirect_message

import logging

logger = logging.getLogger(__name__)

if requests.__version__ < "2.0.0":
    DICT_HEADERS = False
else:
    DICT_HEADERS = True

__author__ = 'rolandh'

ATTRS = {"version": None,
         "name": "",
         "value": None,
         "port": None,
         "port_specified": False,
         "domain": "",
         "domain_specified": False,
         "domain_initial_dot": False,
         "path": "",
         "path_specified": False,
         "secure": False,
         "expires": None,
         "discard": True,
         "comment": None,
         "comment_url": None,
         "rest": "",
         "rfc2109": True}

PAIRS = {
    "port": "port_specified",
    "domain": "domain_specified",
    "path": "path_specified"
}


class ConnectionError(SAMLError):
    pass


class HTTPError(SAMLError):
    pass


def _since_epoch(cdate):
    """
    :param cdate: date format 'Wed, 06-Jun-2012 01:34:34 GMT'
    :return: UTC time
    """

    if len(cdate) < 29:  # somethings broken
        if len(cdate) < 5:
            return utc_now()

    cdate = cdate[5:] # assume short weekday, i.e. do not support obsolete RFC 1036 date format
    try:
        t = time.strptime(cdate, "%d-%b-%Y %H:%M:%S %Z")   # e.g. 18-Apr-2014 12:30:51 GMT
    except ValueError:
        try:
            t = time.strptime(cdate, "%d-%b-%y %H:%M:%S %Z")   # e.g. 18-Apr-14 12:30:51 GMT
        except ValueError:
            try:
                t = time.strptime(cdate, "%d %b %Y %H:%M:%S %Z")   # e.g. 18 Apr 2014 12:30:51 GMT
            except ValueError:
                raise Exception, 'ValueError: Date "{0}" does not match any of '.format(cdate) + \
                                 '"%d-%b-%Y %H:%M:%S %Z", ' + \
                                 '"%d-%b-%y %H:%M:%S %Z", ' + \
                                 '"%d %b %Y %H:%M:%S %Z".'
    #return int(time.mktime(t))
    return calendar.timegm(t)


def set_list2dict(sl):
    return dict(sl)


def dict2set_list(dic):
    return [(k, v) for k, v in dic.items()]


class HTTPBase(object):
    def __init__(self, verify=True, ca_bundle=None, key_file=None,
                 cert_file=None):
        self.request_args = {"allow_redirects": False}
        #self.cookies = {}
        self.cookiejar = cookielib.CookieJar()

        self.request_args["verify"] = verify
        if verify:
            if ca_bundle:
                self.request_args["verify"] = ca_bundle
            if key_file:
                self.request_args["cert"] = (cert_file, key_file)
        
        self.sec = None
        self.user = None
        self.passwd = None
        
    def cookies(self, url):
        """
        Return cookies that are matching the path and are still valid

        :param url:
        :return:
        """
        part = urlparse.urlparse(url)

        #if part.port:
        #    _domain = "%s:%s" % (part.hostname, part.port)
        #else:
        _domain = part.hostname

        cookie_dict = {}
        now = utc_now()
        for _, a in list(self.cookiejar._cookies.items()):
            for _, b in a.items():
                for cookie in list(b.values()):
                    # print cookie
                    if cookie.expires and cookie.expires <= now:
                        continue
                    if not re.search("%s$" % cookie.domain, _domain):
                        continue
                    if not re.match(cookie.path, part.path):
                        continue

                    cookie_dict[cookie.name] = cookie.value

        return cookie_dict

    def set_cookie(self, kaka, request):
        """Returns a cookielib.Cookie based on a set-cookie header line"""

        if not kaka:
            return

        part = urlparse.urlparse(request.url)
        _domain = part.hostname
        logger.debug("%s: '%s'" % (_domain, kaka))

        for cookie_name, morsel in kaka.items():
            std_attr = ATTRS.copy()
            std_attr["name"] = cookie_name
            _tmp = morsel.coded_value
            if _tmp.startswith('"') and _tmp.endswith('"'):
                std_attr["value"] = _tmp[1:-1]
            else:
                std_attr["value"] = _tmp

            std_attr["version"] = 0
            # copy attributes that have values
            for attr in morsel.keys():
                if attr in ATTRS:
                    if morsel[attr]:
                        if attr == "expires":
                            std_attr[attr] = _since_epoch(morsel[attr])
                        elif attr == "path":
                            if morsel[attr].endswith(","):
                                std_attr[attr] = morsel[attr][:-1]
                            else:
                                std_attr[attr] = morsel[attr]
                        else:
                            std_attr[attr] = morsel[attr]
                elif attr == "max-age":
                    if morsel["max-age"]:
                        std_attr["expires"] = _since_epoch(morsel["max-age"])

            for att, item in PAIRS.items():
                if std_attr[att]:
                    std_attr[item] = True

            if std_attr["domain"]:
                if std_attr["domain"].startswith("."):
                    std_attr["domain_initial_dot"] = True
            else:
                std_attr["domain"] = _domain
                std_attr["domain_specified"] = True

            if morsel["max-age"] is 0:
                try:
                    self.cookiejar.clear(domain=std_attr["domain"],
                                         path=std_attr["path"],
                                         name=std_attr["name"])
                except ValueError:
                    pass
            elif morsel["expires"] < utc_now():
                try:
                    self.cookiejar.clear(domain=std_attr["domain"],
                                         path=std_attr["path"],
                                         name=std_attr["name"])
                except ValueError:
                    pass
            else:
                new_cookie = cookielib.Cookie(**std_attr)
                self.cookiejar.set_cookie(new_cookie)

    def send(self, url, method="GET", **kwargs):
        _kwargs = copy.copy(self.request_args)
        if kwargs:
            _kwargs.update(kwargs)

        if self.cookiejar:
            _cd = self.cookies(url)
            if _cd:
                _kwargs["cookies"] = _cd

        if self.user and self.passwd:
            _kwargs["auth"] = (self.user, self.passwd)

        if "headers" in _kwargs and isinstance(_kwargs["headers"], list):
            if DICT_HEADERS:
                # requests.request wants a dict of headers, not a list of tuples
                _kwargs["headers"] = dict(_kwargs["headers"])

        try:
            logger.debug("%s to %s" % (method, url))
            for arg in ["cookies", "data", "auth"]:
                try:
                    logger.debug("%s: %s" % (arg.upper(), _kwargs[arg]))
                except KeyError:
                    pass
            r = requests.request(method, url, **_kwargs)
            logger.debug("Response status: %s" % r.status_code)
        except requests.ConnectionError, exc:
            raise ConnectionError("%s" % exc)

        try:
            self.set_cookie(SimpleCookie(r.headers["set-cookie"]), r)
        except AttributeError:
            pass
        except KeyError:
            pass

        return r

    def use_http_form_post(self, message, destination, relay_state,
                           typ="SAMLRequest"):
        """
        Return a form that will automagically execute and POST the message
        to the recipient.

        :param message:
        :param destination:
        :param relay_state:
        :param typ: Whether a Request, Response or Artifact
        :return: dictionary
        """
        if not isinstance(message, basestring):
            message = "%s" % (message,)

        return http_form_post_message(message, destination, relay_state, typ)

    def use_http_get(self, message, destination, relay_state,
                     typ="SAMLRequest"):
        """
        Send a message using GET, this is the HTTP-Redirect case so
        no direct response is expected to this request.

        :param message:
        :param destination:
        :param relay_state:
        :param typ: Whether a Request, Response or Artifact
        :return: dictionary
        """
        if not isinstance(message, basestring):
            message = "%s" % (message,)

        return http_redirect_message(message, destination, relay_state, typ)

    def use_http_artifact(self, message, destination="", relay_state=""):
        if relay_state:
            query = urllib.urlencode({"SAMLart": message,
                                      "RelayState": relay_state})
        else:
            query = urllib.urlencode({"SAMLart": message})
        info = {
            "data": "",
            "url": "%s?%s" % (destination, query)
        }
        return info

    def use_http_uri(self, message, typ, destination="", relay_state=""):
        if typ == "SAMLResponse":
            info = {
                "data": message.split("\n")[1],
                "headers": [
                    ("Content-Type", "application/samlassertion+xml"),
                    ("Cache-Control", "no-cache, no-store"),
                    ("Pragma", "no-cache")
                ]
            }
        elif typ == "SAMLRequest":
            # msg should be an identifier
            if relay_state:
                query = urllib.urlencode({"ID": message,
                                          "RelayState": relay_state})
            else:
                query = urllib.urlencode({"ID": message})
            info = {
                "data": "",
                "url": "%s?%s" % (destination, query)
            }
        else:
            raise NotImplemented

        return info

    def use_soap(self, request, destination="", soap_headers=None, sign=False):
        """
        Construct the necessary information for using SOAP+POST

        :param request:
        :param destination:
        :param soap_headers:
        :param sign:
        :return: dictionary
        """
        headers = [("content-type", "application/soap+xml")]

        soap_message = make_soap_enveloped_saml_thingy(request, soap_headers)

        logger.debug("SOAP message: %s" % soap_message)

        if sign and self.sec:
            _signed = self.sec.sign_statement(soap_message,
                                              class_name=class_name(request),
                                              node_id=request.id)
            soap_message = _signed

        return {"url": destination, "method": "POST",
                "data": soap_message, "headers": headers}

    def send_using_soap(self, request, destination, headers=None, sign=False):
        """
        Send a message using SOAP+POST

        :param request:
        :param destination:
        :param headers:
        :param sign:
        :return:
        """

        #_response = self.server.post(soap_message, headers, path=path)
        try:
            args = self.use_soap(request, destination, headers, sign)
            args["headers"] = dict(args["headers"])
            response = self.send(**args)
        except Exception, exc:
            logger.info("HTTPClient exception: %s" % (exc,))
            raise

        if response.status_code == 200:
            logger.info("SOAP response: %s" % response.text)
            return response
        else:
            raise HTTPError("%d:%s" % (response.status_code, response.content))

    def add_credentials(self, user, passwd):
        self.user = user
        self.passwd = passwd

########NEW FILE########
__FILENAME__ = httputil
import hashlib
import hmac
import logging
import time
import cgi

from urllib import quote
from urlparse import parse_qs
from Cookie import SimpleCookie

from saml2 import BINDING_HTTP_ARTIFACT, SAMLError
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_URI
from saml2 import BINDING_SOAP
from saml2 import time_util

__author__ = 'rohe0002'


logger = logging.getLogger(__name__)


class Response(object):
    _template = None
    _status = '200 OK'
    _content_type = 'text/html'
    _mako_template = None
    _mako_lookup = None

    def __init__(self, message=None, **kwargs):
        self.status = kwargs.get('status', self._status)
        self.response = kwargs.get('response', self._response)
        self.template = kwargs.get('template', self._template)
        self.mako_template = kwargs.get('mako_template', self._mako_template)
        self.mako_lookup = kwargs.get('template_lookup', self._mako_lookup)

        self.message = message

        self.headers = kwargs.get('headers', [])
        _content_type = kwargs.get('content', self._content_type)
        addContentType = True
        for header in self.headers:
            if 'content-type' == header[0].lower():
                addContentType = False
        if addContentType:
            self.headers.append(('Content-type', _content_type))

    def __call__(self, environ, start_response, **kwargs):
        try:
            start_response(self.status, self.headers)
        except TypeError:
            pass
        return self.response(self.message or geturl(environ), **kwargs)

    def _response(self, message="", **argv):
        if self.template:
            return [self.template % message]
        elif self.mako_lookup and self.mako_template:
            argv["message"] = message
            mte = self.mako_lookup.get_template(self.mako_template)
            return [mte.render(**argv)]
        else:
            if isinstance(message, basestring):
                return [message]
            else:
                return message


class Created(Response):
    _status = "201 Created"


class Redirect(Response):
    _template = '<html>\n<head><title>Redirecting to %s</title></head>\n' \
        '<body>\nYou are being redirected to <a href="%s">%s</a>\n' \
        '</body>\n</html>'
    _status = '302 Found'

    def __call__(self, environ, start_response, **kwargs):
        location = self.message
        self.headers.append(('location', location))
        start_response(self.status, self.headers)
        return self.response((location, location, location))


class SeeOther(Response):
    _template = '<html>\n<head><title>Redirecting to %s</title></head>\n' \
        '<body>\nYou are being redirected to <a href="%s">%s</a>\n' \
        '</body>\n</html>'
    _status = '303 See Other'

    def __call__(self, environ, start_response, **kwargs):
        location = ""
        if self.message:
            location = self.message
            self.headers.append(('location', location))
        else:
            for param, item in self.headers:
                if param == "location":
                    location = item
                    break
        start_response(self.status, self.headers)
        return self.response((location, location, location))


class Forbidden(Response):
    _status = '403 Forbidden'
    _template = "<html>Not allowed to mess with: '%s'</html>"


class BadRequest(Response):
    _status = "400 Bad Request"
    _template = "<html>%s</html>"


class Unauthorized(Response):
    _status = "401 Unauthorized"
    _template = "<html>%s</html>"


class NotFound(Response):
    _status = '404 NOT FOUND'


class NotAcceptable(Response):
    _status = '406 Not Acceptable'


class ServiceError(Response):
    _status = '500 Internal Service Error'


class NotImplemented(Response):
    _status = "501 Not Implemented"
    # override template since we need an environment variable
    template = ('The request method %s is not implemented '
                'for this server.\r\n%s')


class BadGateway(Response):
    _status = "502 Bad Gateway"


def extract(environ, empty=False, err=False):
    """Extracts strings in form data and returns a dict.

    :param environ: WSGI environ
    :param empty: Stops on empty fields (default: Fault)
    :param err: Stops on errors in fields (default: Fault)
    """
    formdata = cgi.parse(environ['wsgi.input'], environ, empty, err)
    # Remove single entries from lists
    for key, value in formdata.iteritems():
        if len(value) == 1:
            formdata[key] = value[0]
    return formdata


def geturl(environ, query=True, path=True, use_server_name=False):
    """Rebuilds a request URL (from PEP 333).
    You may want to chose to use the environment variables
    server_name and server_port instead of http_host in some case.
    The parameter use_server_name allows you to chose.

    :param query: Is QUERY_STRING included in URI (default: True)
    :param path: Is path included in URI (default: True)
    :param use_server_name: If SERVER_NAME/_HOST should be used instead of
        HTTP_HOST
    """
    url = [environ['wsgi.url_scheme'] + '://']
    if use_server_name:
        url.append(environ['SERVER_NAME'])
        if environ['wsgi.url_scheme'] == 'https':
            if environ['SERVER_PORT'] != '443':
                url.append(':' + environ['SERVER_PORT'])
        else:
            if environ['SERVER_PORT'] != '80':
                url.append(':' + environ['SERVER_PORT'])
    else:
        url.append(environ['HTTP_HOST'])
    if path:
        url.append(getpath(environ))
    if query and environ.get('QUERY_STRING'):
        url.append('?' + environ['QUERY_STRING'])
    return ''.join(url)


def getpath(environ):
    """Builds a path."""
    return ''.join([quote(environ.get('SCRIPT_NAME', '')),
                    quote(environ.get('PATH_INFO', ''))])


def get_post(environ):
    # the environment variable CONTENT_LENGTH may be empty or missing
    try:
        request_body_size = int(environ.get('CONTENT_LENGTH', 0))
    except ValueError:
        request_body_size = 0

    # When the method is POST the query string will be sent
    # in the HTTP request body which is passed by the WSGI server
    # in the file like wsgi.input environment variable.
    return environ['wsgi.input'].read(request_body_size)


def get_response(environ, start_response):
    if environ.get("REQUEST_METHOD") == "GET":
        query = environ.get("QUERY_STRING")
    elif environ.get("REQUEST_METHOD") == "POST":
        query = get_post(environ)
    else:
        resp = BadRequest("Unsupported method")
        return resp(environ, start_response)

    return query


def unpack_redirect(environ):
    if "QUERY_STRING" in environ:
        _qs = environ["QUERY_STRING"]
        return dict([(k, v[0]) for k, v in parse_qs(_qs).items()])
    else:
        return None


def unpack_post(environ):
    try:
        return dict([(k, v[0]) for k, v in parse_qs(get_post(environ))])
    except Exception:
        return None


def unpack_soap(environ):
    try:
        query = get_post(environ)
        return {"SAMLRequest": query, "RelayState": ""}
    except Exception:
        return None


def unpack_artifact(environ):
    if environ["REQUEST_METHOD"] == "GET":
        _dict = unpack_redirect(environ)
    elif environ["REQUEST_METHOD"] == "POST":
        _dict = unpack_post(environ)
    else:
        _dict = None
    return _dict


def unpack_any(environ):
    if environ['REQUEST_METHOD'].upper() == 'GET':
    # Could be either redirect or artifact
        _dict = unpack_redirect(environ)
        if "ID" in _dict:
            binding = BINDING_URI
        elif "SAMLart" in _dict:
            binding = BINDING_HTTP_ARTIFACT
        else:
            binding = BINDING_HTTP_REDIRECT
    else:
        content_type = environ.get('CONTENT_TYPE', 'application/soap+xml')
        if content_type != 'application/soap+xml':
            # normal post
            _dict = unpack_post(environ)
            if "SAMLart" in _dict:
                binding = BINDING_HTTP_ARTIFACT
            else:
                binding = BINDING_HTTP_POST
        else:
            _dict = unpack_soap(environ)
            binding = BINDING_SOAP

    return _dict, binding


def _expiration(timeout, time_format=None):
    if timeout == "now":
        return time_util.instant(time_format)
    else:
        # validity time should match lifetime of assertions
        return time_util.in_a_while(minutes=timeout, format=time_format)


def cookie_signature(seed, *parts):
    """Generates a cookie signature."""
    sha1 = hmac.new(seed, digestmod=hashlib.sha1)
    for part in parts:
        if part:
            sha1.update(part)
    return sha1.hexdigest()


def make_cookie(name, load, seed, expire=0, domain="",  path="",
                timestamp=""):
    """
    Create and return a cookie

    :param name: Cookie name
    :param load: Cookie load
    :param seed: A seed for the HMAC function
    :param expire: Number of minutes before this cookie goes stale
    :param domain: The domain of the cookie
    :param path: The path specification for the cookie
    :return: A tuple to be added to headers
    """
    cookie = SimpleCookie()
    if not timestamp:
        timestamp = str(int(time.mktime(time.gmtime())))
    signature = cookie_signature(seed, load, timestamp)
    cookie[name] = "|".join([load, timestamp, signature])
    if path:
        cookie[name]["path"] = path
    if domain:
        cookie[name]["domain"] = domain
    if expire:
        cookie[name]["expires"] = _expiration(expire,
                                              "%a, %d-%b-%Y %H:%M:%S GMT")

    return tuple(cookie.output().split(": ", 1))


def parse_cookie(name, seed, kaka):
    """Parses and verifies a cookie value

    :param seed: A seed used for the HMAC signature
    :param kaka: The cookie
    :return: A tuple consisting of (payload, timestamp)
    """
    if not kaka:
        return None

    cookie_obj = SimpleCookie(kaka)
    morsel = cookie_obj.get(name)

    if morsel:
        parts = morsel.value.split("|")
        if len(parts) != 3:
            return None
            # verify the cookie signature
        sig = cookie_signature(seed, parts[0], parts[1])
        if sig != parts[2]:
            raise SAMLError("Invalid cookie signature")

        try:
            return parts[0].strip(), parts[1]
        except KeyError:
            return None
    else:
        return None


def cookie_parts(name, kaka):
    cookie_obj = SimpleCookie(kaka)
    morsel = cookie_obj.get(name)
    if morsel:
        return morsel.value.split("|")
    else:
        return None

########NEW FILE########
__FILENAME__ = ident
import copy
import shelve
import logging

from hashlib import sha256
from urllib import quote
from urllib import unquote
from saml2 import SAMLError
from saml2.s_utils import rndstr
from saml2.s_utils import PolicyError
from saml2.saml import NameID
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2.saml import NAMEID_FORMAT_EMAILADDRESS

__author__ = 'rolandh'

logger = logging.getLogger(__name__)

ATTR = ["name_qualifier", "sp_name_qualifier", "format", "sp_provided_id",
        "text"]


class Unknown(SAMLError):
    pass


def code(item):
    _res = []
    i = 0
    for attr in ATTR:
        val = getattr(item, attr)
        if val:
            _res.append("%d=%s" % (i, quote(val)))
        i += 1
    return ",".join(_res)


def decode(txt):
    _nid = NameID()
    for part in txt.split(","):
        if part.find("=") != -1:
            i, val = part.split("=")
            try:
                setattr(_nid, ATTR[int(i)], unquote(val))
            except:
                pass
    return _nid


class IdentDB(object):
    """ A class that handles identifiers of entities
     Keeps a list of all nameIDs returned per SP
    """
    def __init__(self, db, domain="", name_qualifier=""):
        if isinstance(db, basestring):
            self.db = shelve.open(db)
        else:
            self.db = db
        self.domain = domain
        self.name_qualifier = name_qualifier

    def _create_id(self, nformat, name_qualifier="", sp_name_qualifier=""):
        _id = sha256(rndstr(32))
        _id.update(nformat)
        if name_qualifier:
            _id.update(name_qualifier)
        if sp_name_qualifier:
            _id.update(sp_name_qualifier)
        return _id.hexdigest()

    def create_id(self, nformat, name_qualifier="", sp_name_qualifier=""):
        _id = self._create_id(nformat, name_qualifier, sp_name_qualifier)
        while _id in self.db:
            _id = self._create_id(nformat, name_qualifier, sp_name_qualifier)
        return _id

    def store(self, ident, name_id):
        if isinstance(ident, unicode):
            ident = ident.encode("utf-8")

        try:
            val = self.db[ident].split(" ")
        except KeyError:
            val = []

        _cn = code(name_id)
        val.append(_cn)
        self.db[ident] = " ".join(val)
        self.db[_cn] = ident

    def remove_remote(self, name_id):
        _cn = code(name_id)
        _id = self.db[_cn]
        try:
            vals = self.db[_id].split(" ")
            vals.remove(_cn)
            self.db[_id] = " ".join(vals)
        except KeyError:
            pass

        del self.db[_cn]

    def remove_local(self, sid):
        if isinstance(sid, unicode):
            sid = sid.encode("utf-8")

        try:
            for val in self.db[sid].split(" "):
                try:
                    del self.db[val]
                except KeyError:
                    pass
            del self.db[sid]
        except KeyError:
            pass

    def get_nameid(self, userid, nformat, sp_name_qualifier, name_qualifier):
        _id = self.create_id(nformat, name_qualifier, sp_name_qualifier)

        if nformat == NAMEID_FORMAT_EMAILADDRESS:
            if not self.domain:
                raise SAMLError("Can't issue email nameids, unknown domain")

            _id = "%s@%s" % (_id, self.domain)

        if nformat == NAMEID_FORMAT_PERSISTENT:
            _id = userid

        nameid = NameID(format=nformat, sp_name_qualifier=sp_name_qualifier,
                        name_qualifier=name_qualifier, text=_id)

        self.store(userid, nameid)
        return nameid

    def find_nameid(self, userid, **kwargs):
        res = []
        try:
            _vals = self.db[userid]
        except KeyError:
            logger.debug("failed to find userid %s in IdentDB" % userid)
            return res

        for val in _vals.split(" "):
            nid = decode(val)
            if kwargs:
                for key, val in kwargs.items():
                    if getattr(nid, key, None) != val:
                        break
                else:
                    res.append(nid)
            else:
                res.append(nid)

        return res

    def nim_args(self, local_policy=None, sp_name_qualifier="",
                 name_id_policy=None, name_qualifier=""):
        """

        :param local_policy:
        :param sp_name_qualifier:
        :param name_id_policy:
        :param name_qualifier:
        :return:
        """

        logger.debug("local_policy: %s, name_id_policy: %s" % (local_policy,
                                                               name_id_policy))

        if name_id_policy and name_id_policy.sp_name_qualifier:
            sp_name_qualifier = name_id_policy.sp_name_qualifier
        else:
            sp_name_qualifier = sp_name_qualifier

        if name_id_policy and name_id_policy.format:
            nameid_format = name_id_policy.format
        elif local_policy:
            nameid_format = local_policy.get_nameid_format(sp_name_qualifier)
        else:
            raise SAMLError("Unknown NameID format")

        if not name_qualifier:
            name_qualifier = self.name_qualifier

        return {"nformat": nameid_format,
                "sp_name_qualifier": sp_name_qualifier,
                "name_qualifier": name_qualifier}

    def construct_nameid(self, userid, local_policy=None,
                         sp_name_qualifier=None, name_id_policy=None,
                         name_qualifier=""):
        """ Returns a name_id for the object. How the name_id is
        constructed depends on the context.

        :param local_policy: The policy the server is configured to follow
        :param userid: The local permanent identifier of the object
        :param sp_name_qualifier: The 'user'/-s of the name_id
        :param name_id_policy: The policy the server on the other side wants
            us to follow.
        :param name_qualifier: A domain qualifier
        :return: NameID instance precursor
        """

        args = self.nim_args(local_policy, sp_name_qualifier, name_id_policy)
        if name_qualifier:
            args["name_qualifier"] = name_qualifier
        else:
            args["name_qualifier"] = self.name_qualifier

        return self.get_nameid(userid, **args)

    def transient_nameid(self, userid, sp_name_qualifier="", name_qualifier=""):
        return self.get_nameid(userid, NAMEID_FORMAT_TRANSIENT,
                               sp_name_qualifier, name_qualifier)

    def persistent_nameid(self, userid, sp_name_qualifier="",
                          name_qualifier=""):
        nameid = self.match_local_id(userid, sp_name_qualifier, name_qualifier)
        if nameid:
            return nameid
        else:
            return self.get_nameid(userid, NAMEID_FORMAT_PERSISTENT,
                                   sp_name_qualifier, name_qualifier)

    def find_local_id(self, name_id):
        """
        Only find persistent IDs

        :param name_id:
        :return:
        """

        try:
            return self.db[code(name_id)]
        except KeyError:
            logger.debug("name: %s" % code(name_id))
            logger.debug("id keys: %s" % self.db.keys())
            return None

    def match_local_id(self, userid, sp_name_qualifier, name_qualifier):
        try:
            for val in self.db[userid].split(" "):
                nid = decode(val)
                if nid.format == NAMEID_FORMAT_TRANSIENT:
                    continue
                snq = getattr(nid, "sp_name_qualifier", "")
                if snq and snq == sp_name_qualifier:
                    nq = getattr(nid, "name_qualifier", None)
                    if nq and nq == name_qualifier:
                        return nid
                    elif not nq and not name_qualifier:
                        return nid
                elif not snq and not sp_name_qualifier:
                    nq = getattr(nid, "name_qualifier", None)
                    if nq and nq == name_qualifier:
                        return nid
                    elif not nq and not name_qualifier:
                        return nid
        except KeyError:
            pass

        return None

    def handle_name_id_mapping_request(self, name_id, name_id_policy):
        """

        :param name_id: The NameID that specifies the principal
        :param name_id_policy: The NameIDPolicy of the requester
        :return: If an old name_id exists that match the name-id policy
            that is return otherwise if a new one can be created it
            will be and returned. If no old matching exists and a new
            is not allowed to be created None is returned.
        """
        _id = self.find_local_id(name_id)
        if not _id:
            raise Unknown("Unknown entity")

        # return an old one if present
        for val in self.db[_id].split(" "):
            _nid = decode(val)
            if _nid.format == name_id_policy.format:
                if _nid.sp_name_qualifier == name_id_policy.sp_name_qualifier:
                    return _nid

        if name_id_policy.allow_create == "false":
            raise PolicyError("Not allowed to create new identifier")

        # else create and return a new one
        return self.construct_nameid(_id, name_id_policy=name_id_policy)

    def handle_manage_name_id_request(self, name_id, new_id=None,
                                      new_encrypted_id="", terminate=""):
        """
        Requests from the SP is about the SPProvidedID attribute.
        So this is about adding,replacing and removing said attribute.

        :param name_id: NameID instance
        :param new_id: NewID instance
        :param new_encrypted_id: NewEncryptedID instance
        :param terminate: Terminate instance
        :return: The modified name_id
        """
        _id = self.find_local_id(name_id)

        orig_name_id = copy.copy(name_id)

        if new_id:
            name_id.sp_provided_id = new_id.text
        elif new_encrypted_id:
            # TODO
            pass
        elif terminate:
            name_id.sp_provided_id = None
        else:
            #NOOP
            return name_id

        self.remove_remote(orig_name_id)
        self.store(_id, name_id)
        return name_id

    def close(self):
        self.db.close()

########NEW FILE########
__FILENAME__ = mcache
#!/usr/bin/env python
import logging

import memcache
from saml2 import time_util
from saml2.cache import ToOld, CacheError

# The assumption is that any subject may consist of data 
# gathered from several different sources, all with their own
# timeout time.

logger = logging.getLogger(__name__)

def _key(prefix, name):
    return "%s_%s" % (prefix, name)
            
class Cache(object):
    def __init__(self, servers, debug=0):
        self._cache = memcache.Client(servers, debug)
        
    def delete(self, subject_id):
        entities = self.entities(subject_id)
        if entities:
            for entity_id in entities:
                if not self._cache.delete(_key(subject_id, entity_id)):
                    raise CacheError("Delete failed")
    
        if not self._cache.delete(subject_id):
            raise CacheError("Delete failed")

        subjects = self._cache.get("subjects")
        if subjects and subject_id in subjects:
            subjects.remove(subject_id)
            if not self._cache.set("subjects", subjects):
                raise CacheError("Set operation failed")
        
    def get_identity(self, subject_id, entities=None):
        """ Get all the identity information that has been received and 
        are still valid about the subject.
        
        :param subject_id: The identifier of the subject
        :param entities: The identifiers of the entities whoes assertions are
            interesting. If the list is empty all entities are interesting.
        :return: A 2-tuple consisting of the identity information (a
            dictionary of attributes and values) and the list of entities 
            whoes information has timed out.
        """
        if not entities:
            entities = self.entities(subject_id)
            if not entities:
                return {}, []
            
        res = {}
        oldees = []
        for (entity_id, item) in self._cache.get_multi(entities, 
                                                    subject_id+'_').items():
            try:
                info = self.get_info(item)
            except ToOld:
                oldees.append(entity_id)
                continue
            for key, vals in info["ava"].items():            
                try:
                    tmp = set(res[key]).union(set(vals))
                    res[key] = list(tmp)
                except KeyError:
                    res[key] = vals
        return res, oldees

    def get_info(self, item, check_not_on_or_after=True):
        """ Get session information about a subject gotten from a
        specified IdP/AA.

        :param item: Information stored
        :return: The session information as a dictionary
        """
        try:
            (timestamp, info) = item
        except ValueError:
            raise ToOld()
            
        if check_not_on_or_after and not time_util.not_on_or_after(timestamp):
            raise ToOld()

        return info or None

    def get(self, subject_id, entity_id, check_not_on_or_after=True):
        res = self._cache.get(_key(subject_id, entity_id))
        if not res:
            return {}
        else:
            return self.get_info(res)
        
    def set(self, subject_id, entity_id, info, timestamp=0):
        """ Stores session information in the cache. Assumes that the subject_id
        is unique within the context of the Service Provider.
        
        :param subject_id: The subject identifier
        :param entity_id: The identifier of the entity_id/receiver of an 
            assertion
        :param info: The session info, the assertion is part of this
        :param timestamp: A time after which the assertion is not valid.
        """
        entities = self._cache.get(subject_id)
        if not entities:
            entities = []
            subjects = self._cache.get("subjects")
            if not subjects:
                subjects = []
            if subject_id not in subjects:
                subjects.append(subject_id)
                if not self._cache.set("subjects", subjects):
                    raise CacheError("set failed")
        
        if entity_id not in entities:
            entities.append(entity_id)
            if not self._cache.set(subject_id, entities):
                raise CacheError("set failed")
          
        # Should use memcache's expire
        if not self._cache.set(_key(subject_id, entity_id), (timestamp, info)):
            raise CacheError("set failed")
            
    def reset(self, subject_id, entity_id):
        """ Scrap the assertions received from a IdP or an AA about a special
        subject.
        
        :param subject_id: The subjects identifier
        :param entity_id: The identifier of the entity_id of the assertion
        :return:
        """
        if not self._cache.set(_key(subject_id, entity_id), {}, 0):
            raise CacheError("reset failed")
            
    def entities(self, subject_id):
        """ Returns all the entities of assertions for a subject, disregarding
        whether the assertion still is valid or not.
        
        :param subject_id: The identifier of the subject
        :return: A possibly empty list of entity identifiers
        """
        res = self._cache.get(subject_id)
        if not res:
            raise KeyError("No such subject")
        else:
            return res
        
    def receivers(self, subject_id):
        """ Another name for entities() just to make it more logic in the IdP 
            scenario """
        return self.entities(subject_id)
        
    def active(self, subject_id, entity_id):
        """ Returns the status of assertions from a specific entity_id.
        
        :param subject_id: The ID of the subject
        :param entity_id: The entity ID of the entity_id of the assertion
        :return: True or False depending on if the assertion is still
            valid or not.
        """
        try:
            (timestamp, info) = self._cache.get(_key(subject_id, entity_id))
        except ValueError:
            return False
        except TypeError:
            return False
            
        # if not info:
        #     return False
            
        try:
            return time_util.not_on_or_after(timestamp)
        except ToOld:
            return False
        
    def subjects(self):
        """ Return identifiers for all the subjects that are in the cache.
        
        :return: list of subject identifiers
        """
        return self._cache.get("subjects")

    def update(self, subject_id, entity_id, ava):
        res = self._cache.get(_key(subject_id, entity_id))
        if res is None:
            raise KeyError("No such subject")
        else:
            info = self.get_info(res)
            if info:
                info.update(ava)
                self.set(subject_id, entity_id, info, res[0])
                
    def valid_to(self, subject_id, entity_id, newtime):
        try:
            (timestamp, info) = self._cache.get(_key(subject_id, entity_id))
        except ValueError:
            return False
        except TypeError:
            info = {}
            
        if not self._cache.set(_key(subject_id, entity_id), (newtime, info)):
            raise CacheError("valid_to failed")

########NEW FILE########
__FILENAME__ = md
#!/usr/bin/env python

#
# Generated Mon May  2 14:23:33 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

import xmldsig as ds
import xmlenc as xenc
from saml2 import saml

NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:metadata'


class EntityIDType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:entityIDType element """

    c_tag = 'entityIDType'
    c_namespace = NAMESPACE
    c_value_type = {'maxlen': '1024', 'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def entity_id_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(EntityIDType_, xml_string)


class LocalizedNameType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:localizedNameType element """

    c_tag = 'localizedNameType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['{http://www.w3.org/XML/1998/namespace}lang'] = ('lang',
                                                                  'string',
                                                                  True)

    def __init__(self,
                 lang=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.lang = lang


def localized_name_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LocalizedNameType_, xml_string)


class LocalizedURIType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:localizedURIType element """

    c_tag = 'localizedURIType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['{http://www.w3.org/XML/1998/namespace}lang'] = ('lang',
                                                                  'anyURI',
                                                                  True)

    def __init__(self,
                 lang=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.lang = lang


def localized_uri_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LocalizedURIType_, xml_string)


class ExtensionsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:ExtensionsType element """

    c_tag = 'ExtensionsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def extensions_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionsType_, xml_string)


class EndpointType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:EndpointType element """

    c_tag = 'EndpointType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['Binding'] = ('binding', 'anyURI', True)
    c_attributes['Location'] = ('location', 'anyURI', True)
    c_attributes['ResponseLocation'] = ('response_location', 'anyURI', False)

    def __init__(self,
                 binding=None,
                 location=None,
                 response_location=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.binding = binding
        self.location = location
        self.response_location = response_location


def endpoint_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(EndpointType_, xml_string)


class IndexedEndpointType_(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:IndexedEndpointType element """

    c_tag = 'IndexedEndpointType'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()
    c_attributes['index'] = ('index', 'unsignedShort', True)
    c_attributes['isDefault'] = ('is_default', 'boolean', False)

    def __init__(self,
                 index=None,
                 is_default=None,
                 binding=None,
                 location=None,
                 response_location=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        EndpointType_.__init__(self,
                               binding=binding,
                               location=location,
                               response_location=response_location,
                               text=text,
                               extension_elements=extension_elements,
                               extension_attributes=extension_attributes)
        self.index = index
        self.is_default = is_default


def indexed_endpoint_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IndexedEndpointType_, xml_string)


class OrganizationName(LocalizedNameType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:OrganizationName element """

    c_tag = 'OrganizationName'
    c_namespace = NAMESPACE
    c_children = LocalizedNameType_.c_children.copy()
    c_attributes = LocalizedNameType_.c_attributes.copy()
    c_child_order = LocalizedNameType_.c_child_order[:]
    c_cardinality = LocalizedNameType_.c_cardinality.copy()


def organization_name_from_string(xml_string):
    return saml2.create_class_from_xml_string(OrganizationName, xml_string)


class OrganizationDisplayName(LocalizedNameType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:OrganizationDisplayName
    element """

    c_tag = 'OrganizationDisplayName'
    c_namespace = NAMESPACE
    c_children = LocalizedNameType_.c_children.copy()
    c_attributes = LocalizedNameType_.c_attributes.copy()
    c_child_order = LocalizedNameType_.c_child_order[:]
    c_cardinality = LocalizedNameType_.c_cardinality.copy()


def organization_display_name_from_string(xml_string):
    return saml2.create_class_from_xml_string(OrganizationDisplayName,
                                              xml_string)


class OrganizationURL(LocalizedURIType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:OrganizationURL element """

    c_tag = 'OrganizationURL'
    c_namespace = NAMESPACE
    c_children = LocalizedURIType_.c_children.copy()
    c_attributes = LocalizedURIType_.c_attributes.copy()
    c_child_order = LocalizedURIType_.c_child_order[:]
    c_cardinality = LocalizedURIType_.c_cardinality.copy()


def organization_url_from_string(xml_string):
    return saml2.create_class_from_xml_string(OrganizationURL, xml_string)


class Company(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:Company element """

    c_tag = 'Company'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def company_from_string(xml_string):
    return saml2.create_class_from_xml_string(Company, xml_string)


class GivenName(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:GivenName element """

    c_tag = 'GivenName'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def given_name_from_string(xml_string):
    return saml2.create_class_from_xml_string(GivenName, xml_string)


class SurName(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:SurName element """

    c_tag = 'SurName'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def sur_name_from_string(xml_string):
    return saml2.create_class_from_xml_string(SurName, xml_string)


class EmailAddress(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:EmailAddress element """

    c_tag = 'EmailAddress'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def email_address_from_string(xml_string):
    return saml2.create_class_from_xml_string(EmailAddress, xml_string)


class TelephoneNumber(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:TelephoneNumber element """

    c_tag = 'TelephoneNumber'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def telephone_number_from_string(xml_string):
    return saml2.create_class_from_xml_string(TelephoneNumber, xml_string)


class ContactTypeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:ContactTypeType element """

    c_tag = 'ContactTypeType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string', 'enumeration': ['technical', 'support',
                                                      'administrative',
                                                      'billing', 'other']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def contact_type_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ContactTypeType_, xml_string)


class AdditionalMetadataLocationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AdditionalMetadataLocationType
    element """

    c_tag = 'AdditionalMetadataLocationType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['namespace'] = ('namespace', 'anyURI', True)

    def __init__(self, namespace=None, text=None, extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self, text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.namespace = namespace


def additional_metadata_location_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AdditionalMetadataLocationType_,
                                              xml_string)


class AnyURIListType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:anyURIListType element """

    c_tag = 'anyURIListType'
    c_namespace = NAMESPACE
    c_value_type = {'member': 'anyURI', 'base': 'list'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def any_uri_list_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AnyURIListType_, xml_string)


class KeyTypes_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:KeyTypes element """

    c_tag = 'KeyTypes'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string', 'enumeration': ['encryption', 'signing']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def key_types__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyTypes_, xml_string)


class EncryptionMethod(xenc.EncryptionMethodType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:EncryptionMethod element """

    c_tag = 'EncryptionMethod'
    c_namespace = NAMESPACE
    c_children = xenc.EncryptionMethodType_.c_children.copy()
    c_attributes = xenc.EncryptionMethodType_.c_attributes.copy()
    c_child_order = xenc.EncryptionMethodType_.c_child_order[:]
    c_cardinality = xenc.EncryptionMethodType_.c_cardinality.copy()


def encryption_method_from_string(xml_string):
    return saml2.create_class_from_xml_string(EncryptionMethod, xml_string)


class ArtifactResolutionService(IndexedEndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:ArtifactResolutionService
    element """

    c_tag = 'ArtifactResolutionService'
    c_namespace = NAMESPACE
    c_children = IndexedEndpointType_.c_children.copy()
    c_attributes = IndexedEndpointType_.c_attributes.copy()
    c_child_order = IndexedEndpointType_.c_child_order[:]
    c_cardinality = IndexedEndpointType_.c_cardinality.copy()


def artifact_resolution_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(ArtifactResolutionService,
                                              xml_string)


class SingleLogoutService(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:SingleLogoutService element """

    c_tag = 'SingleLogoutService'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()


def single_logout_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(SingleLogoutService, xml_string)


class ManageNameIDService(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:ManageNameIDService element """

    c_tag = 'ManageNameIDService'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()


def manage_name_id_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(ManageNameIDService, xml_string)


class NameIDFormat(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:NameIDFormat element """

    c_tag = 'NameIDFormat'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def name_id_format_from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDFormat, xml_string)


class SingleSignOnService(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:SingleSignOnService element """

    c_tag = 'SingleSignOnService'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()


def single_sign_on_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(SingleSignOnService, xml_string)


class NameIDMappingService(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:NameIDMappingService element """

    c_tag = 'NameIDMappingService'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()


def name_id_mapping_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDMappingService, xml_string)


class AssertionIDRequestService(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AssertionIDRequestService
    element """

    c_tag = 'AssertionIDRequestService'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()


def assertion_id_request_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(AssertionIDRequestService,
                                              xml_string)


class AttributeProfile(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AttributeProfile element """

    c_tag = 'AttributeProfile'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def attribute_profile_from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeProfile, xml_string)


class AssertionConsumerService(IndexedEndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AssertionConsumerService
    element """

    c_tag = 'AssertionConsumerService'
    c_namespace = NAMESPACE
    c_children = IndexedEndpointType_.c_children.copy()
    c_attributes = IndexedEndpointType_.c_attributes.copy()
    c_child_order = IndexedEndpointType_.c_child_order[:]
    c_cardinality = IndexedEndpointType_.c_cardinality.copy()


def assertion_consumer_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(AssertionConsumerService,
                                              xml_string)


class ServiceName(LocalizedNameType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:ServiceName element """

    c_tag = 'ServiceName'
    c_namespace = NAMESPACE
    c_children = LocalizedNameType_.c_children.copy()
    c_attributes = LocalizedNameType_.c_attributes.copy()
    c_child_order = LocalizedNameType_.c_child_order[:]
    c_cardinality = LocalizedNameType_.c_cardinality.copy()


def service_name_from_string(xml_string):
    return saml2.create_class_from_xml_string(ServiceName, xml_string)


class ServiceDescription(LocalizedNameType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:ServiceDescription element """

    c_tag = 'ServiceDescription'
    c_namespace = NAMESPACE
    c_children = LocalizedNameType_.c_children.copy()
    c_attributes = LocalizedNameType_.c_attributes.copy()
    c_child_order = LocalizedNameType_.c_child_order[:]
    c_cardinality = LocalizedNameType_.c_cardinality.copy()


def service_description_from_string(xml_string):
    return saml2.create_class_from_xml_string(ServiceDescription, xml_string)


class RequestedAttributeType_(saml.AttributeType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:RequestedAttributeType
    element """

    c_tag = 'RequestedAttributeType'
    c_namespace = NAMESPACE
    c_children = saml.AttributeType_.c_children.copy()
    c_attributes = saml.AttributeType_.c_attributes.copy()
    c_child_order = saml.AttributeType_.c_child_order[:]
    c_cardinality = saml.AttributeType_.c_cardinality.copy()
    c_attributes['isRequired'] = ('is_required', 'boolean', False)

    def __init__(self, is_required=None, friendly_name=None, name=None,
                 name_format=None, attribute_value=None, text=None,
                 extension_elements=None, extension_attributes=None):
        saml.AttributeType_.__init__(self, friendly_name=friendly_name,
                                     name=name, name_format=name_format,
                                     attribute_value=attribute_value,
                                     text=text,
                                     extension_elements=extension_elements,
                                     extension_attributes=extension_attributes)
        self.is_required = is_required


def requested_attribute_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RequestedAttributeType_,
                                              xml_string)


class AuthnQueryService(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AuthnQueryService element """

    c_tag = 'AuthnQueryService'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()


def authn_query_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnQueryService, xml_string)


class AuthzService(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AuthzService element """

    c_tag = 'AuthzService'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()


def authz_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthzService, xml_string)


class AttributeService(EndpointType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AttributeService element """

    c_tag = 'AttributeService'
    c_namespace = NAMESPACE
    c_children = EndpointType_.c_children.copy()
    c_attributes = EndpointType_.c_attributes.copy()
    c_child_order = EndpointType_.c_child_order[:]
    c_cardinality = EndpointType_.c_cardinality.copy()


def attribute_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeService, xml_string)


class AffiliateMember(EntityIDType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AffiliateMember element """

    c_tag = 'AffiliateMember'
    c_namespace = NAMESPACE
    c_children = EntityIDType_.c_children.copy()
    c_attributes = EntityIDType_.c_attributes.copy()
    c_child_order = EntityIDType_.c_child_order[:]
    c_cardinality = EntityIDType_.c_cardinality.copy()


def affiliate_member_from_string(xml_string):
    return saml2.create_class_from_xml_string(AffiliateMember, xml_string)


class Extensions(ExtensionsType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:Extensions element """

    c_tag = 'Extensions'
    c_namespace = NAMESPACE
    c_children = ExtensionsType_.c_children.copy()
    c_attributes = ExtensionsType_.c_attributes.copy()
    c_child_order = ExtensionsType_.c_child_order[:]
    c_cardinality = ExtensionsType_.c_cardinality.copy()


def extensions_from_string(xml_string):
    return saml2.create_class_from_xml_string(Extensions, xml_string)


class OrganizationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:OrganizationType element """

    c_tag = 'OrganizationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Extensions'] = (
        'extensions', Extensions)
    c_cardinality['extensions'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}OrganizationName'] = (
        'organization_name', [OrganizationName])
    c_cardinality['organization_name'] = {"min": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}OrganizationDisplayName'] = (
            'organization_display_name', [OrganizationDisplayName])
    c_cardinality['organization_display_name'] = {"min": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}OrganizationURL'] = (
        'organization_url', [OrganizationURL])
    c_cardinality['organization_url'] = {"min": 1}
    c_child_order.extend(['extensions', 'organization_name',
                          'organization_display_name', 'organization_url'])

    def __init__(self, extensions=None, organization_name=None,
                 organization_display_name=None, organization_url=None,
                 text=None, extension_elements=None, extension_attributes=None):
        SamlBase.__init__(self, text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.extensions = extensions
        self.organization_name = organization_name or []
        self.organization_display_name = organization_display_name or []
        self.organization_url = organization_url or []


def organization_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(OrganizationType_, xml_string)


class ContactType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:ContactType element """

    c_tag = 'ContactType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Extensions'] = (
        'extensions', Extensions)
    c_cardinality['extensions'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Company'] = (
        'company', Company)
    c_cardinality['company'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}GivenName'] = (
        'given_name', GivenName)
    c_cardinality['given_name'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}SurName'] = (
        'sur_name', SurName)
    c_cardinality['sur_name'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}EmailAddress'] = (
        'email_address', [EmailAddress])
    c_cardinality['email_address'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}TelephoneNumber'] = (
        'telephone_number', [TelephoneNumber])
    c_cardinality['telephone_number'] = {"min": 0}
    c_attributes['contactType'] = ('contact_type', ContactTypeType_, True)
    c_child_order.extend(['extensions', 'company', 'given_name', 'sur_name',
                          'email_address', 'telephone_number'])

    def __init__(self,
                 extensions=None,
                 company=None,
                 given_name=None,
                 sur_name=None,
                 email_address=None,
                 telephone_number=None,
                 contact_type=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.extensions = extensions
        self.company = company
        self.given_name = given_name
        self.sur_name = sur_name
        self.email_address = email_address or []
        self.telephone_number = telephone_number or []
        self.contact_type = contact_type


def contact_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ContactType_, xml_string)


class AdditionalMetadataLocation(AdditionalMetadataLocationType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AdditionalMetadataLocation
    element """

    c_tag = 'AdditionalMetadataLocation'
    c_namespace = NAMESPACE
    c_children = AdditionalMetadataLocationType_.c_children.copy()
    c_attributes = AdditionalMetadataLocationType_.c_attributes.copy()
    c_child_order = AdditionalMetadataLocationType_.c_child_order[:]
    c_cardinality = AdditionalMetadataLocationType_.c_cardinality.copy()


def additional_metadata_location_from_string(xml_string):
    return saml2.create_class_from_xml_string(AdditionalMetadataLocation,
                                              xml_string)


class KeyDescriptorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:KeyDescriptorType element """

    c_tag = 'KeyDescriptorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2000/09/xmldsig#}KeyInfo'] = (
        'key_info', ds.KeyInfo)
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}EncryptionMethod'] = (
        'encryption_method', [EncryptionMethod])
    c_cardinality['encryption_method'] = {"min": 0}
    c_attributes['use'] = ('use', KeyTypes_, False)
    c_child_order.extend(['key_info', 'encryption_method'])

    def __init__(self,
                 key_info=None,
                 encryption_method=None,
                 use=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.key_info = key_info
        self.encryption_method = encryption_method or []
        self.use = use


def key_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyDescriptorType_, xml_string)


class RequestedAttribute(RequestedAttributeType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:RequestedAttribute element """

    c_tag = 'RequestedAttribute'
    c_namespace = NAMESPACE
    c_children = RequestedAttributeType_.c_children.copy()
    c_attributes = RequestedAttributeType_.c_attributes.copy()
    c_child_order = RequestedAttributeType_.c_child_order[:]
    c_cardinality = RequestedAttributeType_.c_cardinality.copy()


def requested_attribute_from_string(xml_string):
    return saml2.create_class_from_xml_string(RequestedAttribute, xml_string)


class Organization(OrganizationType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:Organization element """

    c_tag = 'Organization'
    c_namespace = NAMESPACE
    c_children = OrganizationType_.c_children.copy()
    c_attributes = OrganizationType_.c_attributes.copy()
    c_child_order = OrganizationType_.c_child_order[:]
    c_cardinality = OrganizationType_.c_cardinality.copy()


def organization_from_string(xml_string):
    return saml2.create_class_from_xml_string(Organization, xml_string)


class ContactPerson(ContactType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:ContactPerson element """

    c_tag = 'ContactPerson'
    c_namespace = NAMESPACE
    c_children = ContactType_.c_children.copy()
    c_attributes = ContactType_.c_attributes.copy()
    c_child_order = ContactType_.c_child_order[:]
    c_cardinality = ContactType_.c_cardinality.copy()


def contact_person_from_string(xml_string):
    return saml2.create_class_from_xml_string(ContactPerson, xml_string)


class KeyDescriptor(KeyDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:KeyDescriptor element """

    c_tag = 'KeyDescriptor'
    c_namespace = NAMESPACE
    c_children = KeyDescriptorType_.c_children.copy()
    c_attributes = KeyDescriptorType_.c_attributes.copy()
    c_child_order = KeyDescriptorType_.c_child_order[:]
    c_cardinality = KeyDescriptorType_.c_cardinality.copy()


def key_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyDescriptor, xml_string)


class RoleDescriptorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:RoleDescriptorType element """

    c_tag = 'RoleDescriptorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2000/09/xmldsig#}Signature'] = (
        'signature', ds.Signature)
    c_cardinality['signature'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Extensions'] = (
        'extensions', Extensions)
    c_cardinality['extensions'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}KeyDescriptor'] = (
        'key_descriptor', [KeyDescriptor])
    c_cardinality['key_descriptor'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Organization'] = (
        'organization', Organization)
    c_cardinality['organization'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}ContactPerson'] = (
        'contact_person', [ContactPerson])
    c_cardinality['contact_person'] = {"min": 0}
    c_attributes['ID'] = ('id', 'ID', False)
    c_attributes['validUntil'] = ('valid_until', 'dateTime', False)
    c_attributes['cacheDuration'] = ('cache_duration', 'duration', False)
    c_attributes['protocolSupportEnumeration'] = (
        'protocol_support_enumeration', AnyURIListType_, True)
    c_attributes['errorURL'] = ('error_url', 'anyURI', False)
    c_child_order.extend(['signature', 'extensions', 'key_descriptor',
                          'organization', 'contact_person'])

    def __init__(self,
                 signature=None,
                 extensions=None,
                 key_descriptor=None,
                 organization=None,
                 contact_person=None,
                 id=None,
                 valid_until=None,
                 cache_duration=None,
                 protocol_support_enumeration=None,
                 error_url=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.signature = signature
        self.extensions = extensions
        self.key_descriptor = key_descriptor or []
        self.organization = organization
        self.contact_person = contact_person or []
        self.id = id
        self.valid_until = valid_until
        self.cache_duration = cache_duration
        self.protocol_support_enumeration = protocol_support_enumeration
        self.error_url = error_url


class SSODescriptorType_(RoleDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:SSODescriptorType element """

    c_tag = 'SSODescriptorType'
    c_namespace = NAMESPACE
    c_children = RoleDescriptorType_.c_children.copy()
    c_attributes = RoleDescriptorType_.c_attributes.copy()
    c_child_order = RoleDescriptorType_.c_child_order[:]
    c_cardinality = RoleDescriptorType_.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}ArtifactResolutionService'] = (
            'artifact_resolution_service', [ArtifactResolutionService])
    c_cardinality['artifact_resolution_service'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}SingleLogoutService'] = (
        'single_logout_service', [SingleLogoutService])
    c_cardinality['single_logout_service'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}ManageNameIDService'] = (
        'manage_name_id_service', [ManageNameIDService])
    c_cardinality['manage_name_id_service'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}NameIDFormat'] = (
        'name_id_format', [NameIDFormat])
    c_cardinality['name_id_format'] = {"min": 0}
    c_child_order.extend(['artifact_resolution_service',
                          'single_logout_service', 'manage_name_id_service',
                          'name_id_format'])

    def __init__(
            self,
            artifact_resolution_service=None,
            single_logout_service=None,
            manage_name_id_service=None,
            name_id_format=None,
            signature=None,
            extensions=None,
            key_descriptor=None,
            organization=None,
            contact_person=None,
            id=None,
            valid_until=None,
            cache_duration=None,
            protocol_support_enumeration=None,
            error_url=None,
            text=None,
            extension_elements=None,
            extension_attributes=None):
        RoleDescriptorType_.__init__(
            self,
            signature=signature,
            extensions=extensions,
            key_descriptor=key_descriptor,
            organization=organization,
            contact_person=contact_person,
            id=id,
            valid_until=valid_until,
            cache_duration=cache_duration,
            protocol_support_enumeration=protocol_support_enumeration,
            error_url=error_url,
            text=text,
            extension_elements=extension_elements,
            extension_attributes=extension_attributes)
        self.artifact_resolution_service = artifact_resolution_service or []
        self.single_logout_service = single_logout_service or []
        self.manage_name_id_service = manage_name_id_service or []
        self.name_id_format = name_id_format or []


class IDPSSODescriptorType_(SSODescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:IDPSSODescriptorType element """

    c_tag = 'IDPSSODescriptorType'
    c_namespace = NAMESPACE
    c_children = SSODescriptorType_.c_children.copy()
    c_attributes = SSODescriptorType_.c_attributes.copy()
    c_child_order = SSODescriptorType_.c_child_order[:]
    c_cardinality = SSODescriptorType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}SingleSignOnService'] = (
        'single_sign_on_service', [SingleSignOnService])
    c_cardinality['single_sign_on_service'] = {"min": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}NameIDMappingService'] = (
        'name_id_mapping_service', [NameIDMappingService])
    c_cardinality['name_id_mapping_service'] = {"min": 0}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AssertionIDRequestService'] = (
            'assertion_id_request_service', [AssertionIDRequestService])
    c_cardinality['assertion_id_request_service'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}AttributeProfile'] = (
        'attribute_profile', [AttributeProfile])
    c_cardinality['attribute_profile'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Attribute'] = (
        'attribute', [saml.Attribute])
    c_cardinality['attribute'] = {"min": 0}
    c_attributes['WantAuthnRequestsSigned'] = (
        'want_authn_requests_signed', 'boolean', False)
    c_child_order.extend(['single_sign_on_service', 'name_id_mapping_service',
                          'assertion_id_request_service', 'attribute_profile',
                          'attribute'])

    def __init__(self,
                 single_sign_on_service=None,
                 name_id_mapping_service=None,
                 assertion_id_request_service=None,
                 attribute_profile=None,
                 attribute=None,
                 want_authn_requests_signed=None,
                 artifact_resolution_service=None,
                 single_logout_service=None,
                 manage_name_id_service=None,
                 name_id_format=None,
                 signature=None,
                 extensions=None,
                 key_descriptor=None,
                 organization=None,
                 contact_person=None,
                 id=None,
                 valid_until=None,
                 cache_duration=None,
                 protocol_support_enumeration=None,
                 error_url=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
                 want_authn_requests_only_with_valid_cert=None,
    ):
        SSODescriptorType_.__init__(self,
                                    artifact_resolution_service=artifact_resolution_service,
                                    single_logout_service=single_logout_service,
                                    manage_name_id_service=manage_name_id_service,
                                    name_id_format=name_id_format,
                                    signature=signature,
                                    extensions=extensions,
                                    key_descriptor=key_descriptor,
                                    organization=organization,
                                    contact_person=contact_person,
                                    id=id,
                                    valid_until=valid_until,
                                    cache_duration=cache_duration,
                                    protocol_support_enumeration=protocol_support_enumeration,
                                    error_url=error_url,
                                    text=text,
                                    extension_elements=extension_elements,
                                    extension_attributes=extension_attributes,
        )
        self.single_sign_on_service = single_sign_on_service or []
        self.name_id_mapping_service = name_id_mapping_service or []
        self.assertion_id_request_service = assertion_id_request_service or []
        self.attribute_profile = attribute_profile or []
        self.attribute = attribute or []
        self.want_authn_requests_signed = want_authn_requests_signed
        self.want_authn_requests_only_with_valid_cert = want_authn_requests_only_with_valid_cert


def idpsso_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IDPSSODescriptorType_, xml_string)


class AttributeConsumingServiceType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AttributeConsumingServiceType
    element """

    c_tag = 'AttributeConsumingServiceType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}ServiceName'] = (
        'service_name',
        [ServiceName])
    c_cardinality['service_name'] = {"min": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}ServiceDescription'] = (
        'service_description',
        [ServiceDescription])
    c_cardinality['service_description'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}RequestedAttribute'] = (
        'requested_attribute',
        [RequestedAttribute])
    c_cardinality['requested_attribute'] = {"min": 1}
    c_attributes['index'] = ('index', 'unsignedShort', True)
    c_attributes['isDefault'] = ('is_default', 'boolean', False)
    c_child_order.extend(['service_name', 'service_description',
                          'requested_attribute'])

    def __init__(self,
                 service_name=None,
                 service_description=None,
                 requested_attribute=None,
                 index=None,
                 is_default=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.service_name = service_name or []
        self.service_description = service_description or []
        self.requested_attribute = requested_attribute or []
        self.index = index
        self.is_default = is_default


def attribute_consuming_service_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeConsumingServiceType_,
                                              xml_string)


class AuthnAuthorityDescriptorType_(RoleDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AuthnAuthorityDescriptorType
    element """

    c_tag = 'AuthnAuthorityDescriptorType'
    c_namespace = NAMESPACE
    c_children = RoleDescriptorType_.c_children.copy()
    c_attributes = RoleDescriptorType_.c_attributes.copy()
    c_child_order = RoleDescriptorType_.c_child_order[:]
    c_cardinality = RoleDescriptorType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}AuthnQueryService'] = (
        'authn_query_service',
        [AuthnQueryService])
    c_cardinality['authn_query_service'] = {"min": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AssertionIDRequestService'] = (
        'assertion_id_request_service',
        [AssertionIDRequestService])
    c_cardinality['assertion_id_request_service'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}NameIDFormat'] = (
        'name_id_format',
        [NameIDFormat])
    c_cardinality['name_id_format'] = {"min": 0}
    c_child_order.extend(['authn_query_service', 'assertion_id_request_service',
                          'name_id_format'])

    def __init__(self,
                 authn_query_service=None,
                 assertion_id_request_service=None,
                 name_id_format=None,
                 signature=None,
                 extensions=None,
                 key_descriptor=None,
                 organization=None,
                 contact_person=None,
                 id=None,
                 valid_until=None,
                 cache_duration=None,
                 protocol_support_enumeration=None,
                 error_url=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        RoleDescriptorType_.__init__(self,
                                     signature=signature,
                                     extensions=extensions,
                                     key_descriptor=key_descriptor,
                                     organization=organization,
                                     contact_person=contact_person,
                                     id=id,
                                     valid_until=valid_until,
                                     cache_duration=cache_duration,
                                     protocol_support_enumeration=protocol_support_enumeration,
                                     error_url=error_url,
                                     text=text,
                                     extension_elements=extension_elements,
                                     extension_attributes=extension_attributes,
        )
        self.authn_query_service = authn_query_service or []
        self.assertion_id_request_service = assertion_id_request_service or []
        self.name_id_format = name_id_format or []


def authn_authority_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnAuthorityDescriptorType_,
                                              xml_string)


class PDPDescriptorType_(RoleDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:PDPDescriptorType element """

    c_tag = 'PDPDescriptorType'
    c_namespace = NAMESPACE
    c_children = RoleDescriptorType_.c_children.copy()
    c_attributes = RoleDescriptorType_.c_attributes.copy()
    c_child_order = RoleDescriptorType_.c_child_order[:]
    c_cardinality = RoleDescriptorType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}AuthzService'] = (
        'authz_service',
        [AuthzService])
    c_cardinality['authz_service'] = {"min": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AssertionIDRequestService'] = (
        'assertion_id_request_service',
        [AssertionIDRequestService])
    c_cardinality['assertion_id_request_service'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}NameIDFormat'] = (
        'name_id_format',
        [NameIDFormat])
    c_cardinality['name_id_format'] = {"min": 0}
    c_child_order.extend(['authz_service', 'assertion_id_request_service',
                          'name_id_format'])

    def __init__(self,
                 authz_service=None,
                 assertion_id_request_service=None,
                 name_id_format=None,
                 signature=None,
                 extensions=None,
                 key_descriptor=None,
                 organization=None,
                 contact_person=None,
                 id=None,
                 valid_until=None,
                 cache_duration=None,
                 protocol_support_enumeration=None,
                 error_url=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        RoleDescriptorType_.__init__(self,
                                     signature=signature,
                                     extensions=extensions,
                                     key_descriptor=key_descriptor,
                                     organization=organization,
                                     contact_person=contact_person,
                                     id=id,
                                     valid_until=valid_until,
                                     cache_duration=cache_duration,
                                     protocol_support_enumeration=protocol_support_enumeration,
                                     error_url=error_url,
                                     text=text,
                                     extension_elements=extension_elements,
                                     extension_attributes=extension_attributes,
        )
        self.authz_service = authz_service or []
        self.assertion_id_request_service = assertion_id_request_service or []
        self.name_id_format = name_id_format or []


def pdp_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(PDPDescriptorType_, xml_string)


class AttributeAuthorityDescriptorType_(RoleDescriptorType_):
    """The urn:oasis:names:tc:SAML:2
    .0:metadata:AttributeAuthorityDescriptorType element """

    c_tag = 'AttributeAuthorityDescriptorType'
    c_namespace = NAMESPACE
    c_children = RoleDescriptorType_.c_children.copy()
    c_attributes = RoleDescriptorType_.c_attributes.copy()
    c_child_order = RoleDescriptorType_.c_child_order[:]
    c_cardinality = RoleDescriptorType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}AttributeService'] = (
        'attribute_service',
        [AttributeService])
    c_cardinality['attribute_service'] = {"min": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AssertionIDRequestService'] = (
        'assertion_id_request_service',
        [AssertionIDRequestService])
    c_cardinality['assertion_id_request_service'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}NameIDFormat'] = (
        'name_id_format',
        [NameIDFormat])
    c_cardinality['name_id_format'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}AttributeProfile'] = (
        'attribute_profile',
        [AttributeProfile])
    c_cardinality['attribute_profile'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Attribute'] = (
        'attribute',
        [saml.Attribute])
    c_cardinality['attribute'] = {"min": 0}
    c_child_order.extend(['attribute_service', 'assertion_id_request_service',
                          'name_id_format', 'attribute_profile', 'attribute'])

    def __init__(self,
                 attribute_service=None,
                 assertion_id_request_service=None,
                 name_id_format=None,
                 attribute_profile=None,
                 attribute=None,
                 signature=None,
                 extensions=None,
                 key_descriptor=None,
                 organization=None,
                 contact_person=None,
                 id=None,
                 valid_until=None,
                 cache_duration=None,
                 protocol_support_enumeration=None,
                 error_url=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        RoleDescriptorType_.__init__(self,
                                     signature=signature,
                                     extensions=extensions,
                                     key_descriptor=key_descriptor,
                                     organization=organization,
                                     contact_person=contact_person,
                                     id=id,
                                     valid_until=valid_until,
                                     cache_duration=cache_duration,
                                     protocol_support_enumeration=protocol_support_enumeration,
                                     error_url=error_url,
                                     text=text,
                                     extension_elements=extension_elements,
                                     extension_attributes=extension_attributes,
        )
        self.attribute_service = attribute_service or []
        self.assertion_id_request_service = assertion_id_request_service or []
        self.name_id_format = name_id_format or []
        self.attribute_profile = attribute_profile or []
        self.attribute = attribute or []


def attribute_authority_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeAuthorityDescriptorType_,
                                              xml_string)


class AffiliationDescriptorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AffiliationDescriptorType
    element """

    c_tag = 'AffiliationDescriptorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2000/09/xmldsig#}Signature'] = ('signature',
                                                                   ds.Signature)
    c_cardinality['signature'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Extensions'] = (
        'extensions',
        Extensions)
    c_cardinality['extensions'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}AffiliateMember'] = (
        'affiliate_member',
        [AffiliateMember])
    c_cardinality['affiliate_member'] = {"min": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}KeyDescriptor'] = (
        'key_descriptor',
        [KeyDescriptor])
    c_cardinality['key_descriptor'] = {"min": 0}
    c_attributes['affiliationOwnerID'] = ('affiliation_owner_id', EntityIDType_,
                                          True)
    c_attributes['validUntil'] = ('valid_until', 'dateTime', False)
    c_attributes['cacheDuration'] = ('cache_duration', 'duration', False)
    c_attributes['ID'] = ('id', 'ID', False)
    c_child_order.extend(['signature', 'extensions', 'affiliate_member',
                          'key_descriptor'])

    def __init__(self,
                 signature=None,
                 extensions=None,
                 affiliate_member=None,
                 key_descriptor=None,
                 affiliation_owner_id=None,
                 valid_until=None,
                 cache_duration=None,
                 id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.signature = signature
        self.extensions = extensions
        self.affiliate_member = affiliate_member or []
        self.key_descriptor = key_descriptor or []
        self.affiliation_owner_id = affiliation_owner_id
        self.valid_until = valid_until
        self.cache_duration = cache_duration
        self.id = id


def affiliation_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AffiliationDescriptorType_,
                                              xml_string)


class RoleDescriptor(RoleDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:RoleDescriptor element """

    c_tag = 'RoleDescriptor'
    c_namespace = NAMESPACE
    c_children = RoleDescriptorType_.c_children.copy()
    c_attributes = RoleDescriptorType_.c_attributes.copy()
    c_child_order = RoleDescriptorType_.c_child_order[:]
    c_cardinality = RoleDescriptorType_.c_cardinality.copy()


def role_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(RoleDescriptor, xml_string)


class IDPSSODescriptor(IDPSSODescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:IDPSSODescriptor element """

    c_tag = 'IDPSSODescriptor'
    c_namespace = NAMESPACE
    c_children = IDPSSODescriptorType_.c_children.copy()
    c_attributes = IDPSSODescriptorType_.c_attributes.copy()
    c_child_order = IDPSSODescriptorType_.c_child_order[:]
    c_cardinality = IDPSSODescriptorType_.c_cardinality.copy()


def idpsso_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(IDPSSODescriptor, xml_string)


class AttributeConsumingService(AttributeConsumingServiceType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AttributeConsumingService
    element """

    c_tag = 'AttributeConsumingService'
    c_namespace = NAMESPACE
    c_children = AttributeConsumingServiceType_.c_children.copy()
    c_attributes = AttributeConsumingServiceType_.c_attributes.copy()
    c_child_order = AttributeConsumingServiceType_.c_child_order[:]
    c_cardinality = AttributeConsumingServiceType_.c_cardinality.copy()


def attribute_consuming_service_from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeConsumingService,
                                              xml_string)


class AuthnAuthorityDescriptor(AuthnAuthorityDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AuthnAuthorityDescriptor
    element """

    c_tag = 'AuthnAuthorityDescriptor'
    c_namespace = NAMESPACE
    c_children = AuthnAuthorityDescriptorType_.c_children.copy()
    c_attributes = AuthnAuthorityDescriptorType_.c_attributes.copy()
    c_child_order = AuthnAuthorityDescriptorType_.c_child_order[:]
    c_cardinality = AuthnAuthorityDescriptorType_.c_cardinality.copy()


def authn_authority_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnAuthorityDescriptor,
                                              xml_string)


class PDPDescriptor(PDPDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:PDPDescriptor element """

    c_tag = 'PDPDescriptor'
    c_namespace = NAMESPACE
    c_children = PDPDescriptorType_.c_children.copy()
    c_attributes = PDPDescriptorType_.c_attributes.copy()
    c_child_order = PDPDescriptorType_.c_child_order[:]
    c_cardinality = PDPDescriptorType_.c_cardinality.copy()


def pdp_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(PDPDescriptor, xml_string)


class AttributeAuthorityDescriptor(AttributeAuthorityDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AttributeAuthorityDescriptor
    element """

    c_tag = 'AttributeAuthorityDescriptor'
    c_namespace = NAMESPACE
    c_children = AttributeAuthorityDescriptorType_.c_children.copy()
    c_attributes = AttributeAuthorityDescriptorType_.c_attributes.copy()
    c_child_order = AttributeAuthorityDescriptorType_.c_child_order[:]
    c_cardinality = AttributeAuthorityDescriptorType_.c_cardinality.copy()


def attribute_authority_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeAuthorityDescriptor,
                                              xml_string)


class AffiliationDescriptor(AffiliationDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:AffiliationDescriptor element
    """

    c_tag = 'AffiliationDescriptor'
    c_namespace = NAMESPACE
    c_children = AffiliationDescriptorType_.c_children.copy()
    c_attributes = AffiliationDescriptorType_.c_attributes.copy()
    c_child_order = AffiliationDescriptorType_.c_child_order[:]
    c_cardinality = AffiliationDescriptorType_.c_cardinality.copy()


def affiliation_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(AffiliationDescriptor, xml_string)


class SPSSODescriptorType_(SSODescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:SPSSODescriptorType element """

    c_tag = 'SPSSODescriptorType'
    c_namespace = NAMESPACE
    c_children = SSODescriptorType_.c_children.copy()
    c_attributes = SSODescriptorType_.c_attributes.copy()
    c_child_order = SSODescriptorType_.c_child_order[:]
    c_cardinality = SSODescriptorType_.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AssertionConsumerService'] = (
        'assertion_consumer_service',
        [AssertionConsumerService])
    c_cardinality['assertion_consumer_service'] = {"min": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AttributeConsumingService'] = (
        'attribute_consuming_service',
        [AttributeConsumingService])
    c_cardinality['attribute_consuming_service'] = {"min": 0}
    c_attributes['AuthnRequestsSigned'] = ('authn_requests_signed', 'boolean',
                                           False)
    c_attributes['WantAssertionsSigned'] = ('want_assertions_signed', 'boolean',
                                            False)
    c_child_order.extend(['assertion_consumer_service',
                          'attribute_consuming_service'])

    def __init__(self,
                 assertion_consumer_service=None,
                 attribute_consuming_service=None,
                 authn_requests_signed=None,
                 want_assertions_signed=None,
                 artifact_resolution_service=None,
                 single_logout_service=None,
                 manage_name_id_service=None,
                 name_id_format=None,
                 signature=None,
                 extensions=None,
                 key_descriptor=None,
                 organization=None,
                 contact_person=None,
                 id=None,
                 valid_until=None,
                 cache_duration=None,
                 protocol_support_enumeration=None,
                 error_url=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SSODescriptorType_.__init__(self,
                                    artifact_resolution_service=artifact_resolution_service,
                                    single_logout_service=single_logout_service,
                                    manage_name_id_service=manage_name_id_service,
                                    name_id_format=name_id_format,
                                    signature=signature,
                                    extensions=extensions,
                                    key_descriptor=key_descriptor,
                                    organization=organization,
                                    contact_person=contact_person,
                                    id=id,
                                    valid_until=valid_until,
                                    cache_duration=cache_duration,
                                    protocol_support_enumeration=protocol_support_enumeration,
                                    error_url=error_url,
                                    text=text,
                                    extension_elements=extension_elements,
                                    extension_attributes=extension_attributes,
        )
        self.assertion_consumer_service = assertion_consumer_service or []
        self.attribute_consuming_service = attribute_consuming_service or []
        self.authn_requests_signed = authn_requests_signed
        self.want_assertions_signed = want_assertions_signed


def spsso_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SPSSODescriptorType_, xml_string)


class SPSSODescriptor(SPSSODescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:SPSSODescriptor element """

    c_tag = 'SPSSODescriptor'
    c_namespace = NAMESPACE
    c_children = SPSSODescriptorType_.c_children.copy()
    c_attributes = SPSSODescriptorType_.c_attributes.copy()
    c_child_order = SPSSODescriptorType_.c_child_order[:]
    c_cardinality = SPSSODescriptorType_.c_cardinality.copy()


def spsso_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(SPSSODescriptor, xml_string)


class EntityDescriptorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:EntityDescriptorType element """

    c_tag = 'EntityDescriptorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2000/09/xmldsig#}Signature'] = ('signature',
                                                                   ds.Signature)
    c_cardinality['signature'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Extensions'] = (
        'extensions',
        Extensions)
    c_cardinality['extensions'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}RoleDescriptor'] = (
        'role_descriptor',
        [RoleDescriptor])
    c_cardinality['role_descriptor'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}IDPSSODescriptor'] = (
        'idpsso_descriptor',
        [IDPSSODescriptor])
    c_cardinality['idpsso_descriptor'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}SPSSODescriptor'] = (
        'spsso_descriptor',
        [SPSSODescriptor])
    c_cardinality['spsso_descriptor'] = {"min": 0}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AuthnAuthorityDescriptor'] = (
        'authn_authority_descriptor',
        [AuthnAuthorityDescriptor])
    c_cardinality['authn_authority_descriptor'] = {"min": 0}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AttributeAuthorityDescriptor']\
        = (
        'attribute_authority_descriptor',
        [AttributeAuthorityDescriptor])
    c_cardinality['attribute_authority_descriptor'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}PDPDescriptor'] = (
        'pdp_descriptor',
        [PDPDescriptor])
    c_cardinality['pdp_descriptor'] = {"min": 0}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AffiliationDescriptor'] = (
        'affiliation_descriptor',
        AffiliationDescriptor)
    c_cardinality['affiliation_descriptor'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Organization'] = (
        'organization',
        Organization)
    c_cardinality['organization'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}ContactPerson'] = (
        'contact_person',
        [ContactPerson])
    c_cardinality['contact_person'] = {"min": 0}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:metadata}AdditionalMetadataLocation'] = (
        'additional_metadata_location',
        [AdditionalMetadataLocation])
    c_cardinality['additional_metadata_location'] = {"min": 0}
    c_attributes['entityID'] = ('entity_id', EntityIDType_, True)
    c_attributes['validUntil'] = ('valid_until', 'dateTime', False)
    c_attributes['cacheDuration'] = ('cache_duration', 'duration', False)
    c_attributes['ID'] = ('id', 'ID', False)
    c_child_order.extend(['signature', 'extensions', 'role_descriptor',
                          'idpsso_descriptor', 'spsso_descriptor',
                          'authn_authority_descriptor',
                          'attribute_authority_descriptor', 'pdp_descriptor',
                          'affiliation_descriptor', 'organization',
                          'contact_person', 'additional_metadata_location'])

    def __init__(self,
                 signature=None,
                 extensions=None,
                 role_descriptor=None,
                 idpsso_descriptor=None,
                 spsso_descriptor=None,
                 authn_authority_descriptor=None,
                 attribute_authority_descriptor=None,
                 pdp_descriptor=None,
                 affiliation_descriptor=None,
                 organization=None,
                 contact_person=None,
                 additional_metadata_location=None,
                 entity_id=None,
                 valid_until=None,
                 cache_duration=None,
                 id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.signature = signature
        self.extensions = extensions
        self.role_descriptor = role_descriptor or []
        self.idpsso_descriptor = idpsso_descriptor or []
        self.spsso_descriptor = spsso_descriptor or []
        self.authn_authority_descriptor = authn_authority_descriptor or []
        self.attribute_authority_descriptor = attribute_authority_descriptor \
            or []
        self.pdp_descriptor = pdp_descriptor or []
        self.affiliation_descriptor = affiliation_descriptor
        self.organization = organization
        self.contact_person = contact_person or []
        self.additional_metadata_location = additional_metadata_location or []
        self.entity_id = entity_id
        self.valid_until = valid_until
        self.cache_duration = cache_duration
        self.id = id


def entity_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(EntityDescriptorType_, xml_string)


class EntityDescriptor(EntityDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:EntityDescriptor element """

    c_tag = 'EntityDescriptor'
    c_namespace = NAMESPACE
    c_children = EntityDescriptorType_.c_children.copy()
    c_attributes = EntityDescriptorType_.c_attributes.copy()
    c_child_order = EntityDescriptorType_.c_child_order[:]
    c_cardinality = EntityDescriptorType_.c_cardinality.copy()


def entity_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(EntityDescriptor, xml_string)


#..................
# ['EntitiesDescriptor', 'EntitiesDescriptorType']
class EntitiesDescriptorType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:metadata:EntitiesDescriptorType
    element """

    c_tag = 'EntitiesDescriptorType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2000/09/xmldsig#}Signature'] = ('signature',
                                                                   ds.Signature)
    c_cardinality['signature'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}Extensions'] = (
        'extensions',
        Extensions)
    c_cardinality['extensions'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:metadata}EntityDescriptor'] = (
        'entity_descriptor',
        [EntityDescriptor])
    c_cardinality['entity_descriptor'] = {"min": 0}
    c_cardinality['entities_descriptor'] = {"min": 0}
    c_attributes['validUntil'] = ('valid_until', 'dateTime', False)
    c_attributes['cacheDuration'] = ('cache_duration', 'duration', False)
    c_attributes['ID'] = ('id', 'ID', False)
    c_attributes['Name'] = ('name', 'string', False)
    c_child_order.extend(['signature', 'extensions', 'entity_descriptor',
                          'entities_descriptor'])

    def __init__(self,
                 signature=None,
                 extensions=None,
                 entity_descriptor=None,
                 entities_descriptor=None,
                 valid_until=None,
                 cache_duration=None,
                 id=None,
                 name=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.signature = signature
        self.extensions = extensions
        self.entity_descriptor = entity_descriptor or []
        self.entities_descriptor = entities_descriptor or []
        self.valid_until = valid_until
        self.cache_duration = cache_duration
        self.id = id
        self.name = name


def entities_descriptor_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(EntitiesDescriptorType_,
                                              xml_string)


class EntitiesDescriptor(EntitiesDescriptorType_):
    """The urn:oasis:names:tc:SAML:2.0:metadata:EntitiesDescriptor element """

    c_tag = 'EntitiesDescriptor'
    c_namespace = NAMESPACE
    c_children = EntitiesDescriptorType_.c_children.copy()
    c_attributes = EntitiesDescriptorType_.c_attributes.copy()
    c_child_order = EntitiesDescriptorType_.c_child_order[:]
    c_cardinality = EntitiesDescriptorType_.c_cardinality.copy()


def entities_descriptor_from_string(xml_string):
    return saml2.create_class_from_xml_string(EntitiesDescriptor, xml_string)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
EntitiesDescriptorType_.c_children[
    '{urn:oasis:names:tc:SAML:2.0:metadata}EntitiesDescriptor'] = (
    'entities_descriptor',
    [EntitiesDescriptor])
EntitiesDescriptor.c_children[
    '{urn:oasis:names:tc:SAML:2.0:metadata}EntitiesDescriptor'] = (
    'entities_descriptor',
    [EntitiesDescriptor])
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ELEMENT_FROM_STRING = {
    EntityIDType_.c_tag: entity_id_type__from_string,
    LocalizedNameType_.c_tag: localized_name_type__from_string,
    LocalizedURIType_.c_tag: localized_uri_type__from_string,
    Extensions.c_tag: extensions_from_string,
    ExtensionsType_.c_tag: extensions_type__from_string,
    EndpointType_.c_tag: endpoint_type__from_string,
    IndexedEndpointType_.c_tag: indexed_endpoint_type__from_string,
    EntitiesDescriptor.c_tag: entities_descriptor_from_string,
    EntitiesDescriptorType_.c_tag: entities_descriptor_type__from_string,
    EntityDescriptor.c_tag: entity_descriptor_from_string,
    EntityDescriptorType_.c_tag: entity_descriptor_type__from_string,
    Organization.c_tag: organization_from_string,
    OrganizationType_.c_tag: organization_type__from_string,
    OrganizationName.c_tag: organization_name_from_string,
    OrganizationDisplayName.c_tag: organization_display_name_from_string,
    OrganizationURL.c_tag: organization_url_from_string,
    ContactPerson.c_tag: contact_person_from_string,
    ContactType_.c_tag: contact_type__from_string,
    Company.c_tag: company_from_string,
    GivenName.c_tag: given_name_from_string,
    SurName.c_tag: sur_name_from_string,
    EmailAddress.c_tag: email_address_from_string,
    TelephoneNumber.c_tag: telephone_number_from_string,
    ContactTypeType_.c_tag: contact_type_type__from_string,
    AdditionalMetadataLocation.c_tag: additional_metadata_location_from_string,
    AdditionalMetadataLocationType_.c_tag:
        additional_metadata_location_type__from_string,
    RoleDescriptor.c_tag: role_descriptor_from_string,
    AnyURIListType_.c_tag: any_uri_list_type__from_string,
    KeyDescriptor.c_tag: key_descriptor_from_string,
    KeyDescriptorType_.c_tag: key_descriptor_type__from_string,
    KeyTypes_.c_tag: key_types__from_string,
    EncryptionMethod.c_tag: encryption_method_from_string,
    ArtifactResolutionService.c_tag: artifact_resolution_service_from_string,
    SingleLogoutService.c_tag: single_logout_service_from_string,
    ManageNameIDService.c_tag: manage_name_id_service_from_string,
    NameIDFormat.c_tag: name_id_format_from_string,
    IDPSSODescriptor.c_tag: idpsso_descriptor_from_string,
    IDPSSODescriptorType_.c_tag: idpsso_descriptor_type__from_string,
    SingleSignOnService.c_tag: single_sign_on_service_from_string,
    NameIDMappingService.c_tag: name_id_mapping_service_from_string,
    AssertionIDRequestService.c_tag: assertion_id_request_service_from_string,
    AttributeProfile.c_tag: attribute_profile_from_string,
    SPSSODescriptor.c_tag: spsso_descriptor_from_string,
    SPSSODescriptorType_.c_tag: spsso_descriptor_type__from_string,
    AssertionConsumerService.c_tag: assertion_consumer_service_from_string,
    AttributeConsumingService.c_tag: attribute_consuming_service_from_string,
    AttributeConsumingServiceType_.c_tag:
        attribute_consuming_service_type__from_string,
    ServiceName.c_tag: service_name_from_string,
    ServiceDescription.c_tag: service_description_from_string,
    RequestedAttribute.c_tag: requested_attribute_from_string,
    RequestedAttributeType_.c_tag: requested_attribute_type__from_string,
    AuthnAuthorityDescriptor.c_tag: authn_authority_descriptor_from_string,
    AuthnAuthorityDescriptorType_.c_tag:
        authn_authority_descriptor_type__from_string,
    AuthnQueryService.c_tag: authn_query_service_from_string,
    PDPDescriptor.c_tag: pdp_descriptor_from_string,
    PDPDescriptorType_.c_tag: pdp_descriptor_type__from_string,
    AuthzService.c_tag: authz_service_from_string,
    AttributeAuthorityDescriptor.c_tag:
        attribute_authority_descriptor_from_string,
    AttributeAuthorityDescriptorType_.c_tag:
        attribute_authority_descriptor_type__from_string,
    AttributeService.c_tag: attribute_service_from_string,
    AffiliationDescriptor.c_tag: affiliation_descriptor_from_string,
    AffiliationDescriptorType_.c_tag: affiliation_descriptor_type__from_string,
    AffiliateMember.c_tag: affiliate_member_from_string,
}

ELEMENT_BY_TAG = {
    'entityIDType': EntityIDType_,
    'localizedNameType': LocalizedNameType_,
    'localizedURIType': LocalizedURIType_,
    'Extensions': Extensions,
    'ExtensionsType': ExtensionsType_,
    'EndpointType': EndpointType_,
    'IndexedEndpointType': IndexedEndpointType_,
    'EntitiesDescriptor': EntitiesDescriptor,
    'EntitiesDescriptorType': EntitiesDescriptorType_,
    'EntityDescriptor': EntityDescriptor,
    'EntityDescriptorType': EntityDescriptorType_,
    'Organization': Organization,
    'OrganizationType': OrganizationType_,
    'OrganizationName': OrganizationName,
    'OrganizationDisplayName': OrganizationDisplayName,
    'OrganizationURL': OrganizationURL,
    'ContactPerson': ContactPerson,
    'ContactType': ContactType_,
    'Company': Company,
    'GivenName': GivenName,
    'SurName': SurName,
    'EmailAddress': EmailAddress,
    'TelephoneNumber': TelephoneNumber,
    'ContactTypeType': ContactTypeType_,
    'AdditionalMetadataLocation': AdditionalMetadataLocation,
    'AdditionalMetadataLocationType': AdditionalMetadataLocationType_,
    'RoleDescriptor': RoleDescriptor,
    'anyURIListType': AnyURIListType_,
    'KeyDescriptor': KeyDescriptor,
    'KeyDescriptorType': KeyDescriptorType_,
    'KeyTypes': KeyTypes_,
    'EncryptionMethod': EncryptionMethod,
    'ArtifactResolutionService': ArtifactResolutionService,
    'SingleLogoutService': SingleLogoutService,
    'ManageNameIDService': ManageNameIDService,
    'NameIDFormat': NameIDFormat,
    'IDPSSODescriptor': IDPSSODescriptor,
    'IDPSSODescriptorType': IDPSSODescriptorType_,
    'SingleSignOnService': SingleSignOnService,
    'NameIDMappingService': NameIDMappingService,
    'AssertionIDRequestService': AssertionIDRequestService,
    'AttributeProfile': AttributeProfile,
    'SPSSODescriptor': SPSSODescriptor,
    'SPSSODescriptorType': SPSSODescriptorType_,
    'AssertionConsumerService': AssertionConsumerService,
    'AttributeConsumingService': AttributeConsumingService,
    'AttributeConsumingServiceType': AttributeConsumingServiceType_,
    'ServiceName': ServiceName,
    'ServiceDescription': ServiceDescription,
    'RequestedAttribute': RequestedAttribute,
    'RequestedAttributeType': RequestedAttributeType_,
    'AuthnAuthorityDescriptor': AuthnAuthorityDescriptor,
    'AuthnAuthorityDescriptorType': AuthnAuthorityDescriptorType_,
    'AuthnQueryService': AuthnQueryService,
    'PDPDescriptor': PDPDescriptor,
    'PDPDescriptorType': PDPDescriptorType_,
    'AuthzService': AuthzService,
    'AttributeAuthorityDescriptor': AttributeAuthorityDescriptor,
    'AttributeAuthorityDescriptorType': AttributeAuthorityDescriptorType_,
    'AttributeService': AttributeService,
    'AffiliationDescriptor': AffiliationDescriptor,
    'AffiliationDescriptorType': AffiliationDescriptorType_,
    'AffiliateMember': AffiliateMember,
    'RoleDescriptorType': RoleDescriptorType_,
    'SSODescriptorType': SSODescriptorType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)




########NEW FILE########
__FILENAME__ = mdbcache
#!/usr/bin/env python
import logging

__author__ = 'rolandh'

from pymongo import Connection
#import cjson
import time
from datetime import datetime

from saml2 import time_util
from saml2.cache import ToOld
from saml2.time_util import TIME_FORMAT

logger = logging.getLogger(__name__)


class Cache(object):
    def __init__(self, server=None, debug=0, db=None):
        if server:
            connection = Connection(server)
        else:
            connection = Connection()

        if db:
            self._db = connection[db]
        else:
            self._db = connection.pysaml2

        self._cache = self._db.collection
        self.debug = debug

    def delete(self, subject_id):
        self._cache.remove({"subject_id": subject_id})

    def get_identity(self, subject_id, entities=None,
                     check_not_on_or_after=True):
        """ Get all the identity information that has been received and
        are still valid about the subject.

        :param subject_id: The identifier of the subject
        :param entities: The identifiers of the entities whoes assertions are
            interesting. If the list is empty all entities are interesting.
        :return: A 2-tuple consisting of the identity information (a
            dictionary of attributes and values) and the list of entities
            whoes information has timed out.
        """
        res = {}
        oldees = []
        if not entities:
            for item in self._cache.find({"subject_id": subject_id}):
                try:
                    info = self._get_info(item, check_not_on_or_after)
                except ToOld:
                    oldees.append(item["entity_id"])
                    continue

                for key, vals in info["ava"].items():
                    try:
                        tmp = set(res[key]).union(set(vals))
                        res[key] = list(tmp)
                    except KeyError:
                        res[key] = vals
        else:
            for entity_id in entities:
                try:
                    info = self.get(subject_id, entity_id,
                                    check_not_on_or_after)
                except ToOld:
                    oldees.append(entity_id)
                    continue

                for key, vals in info["ava"].items():
                    try:
                        tmp = set(res[key]).union(set(vals))
                        res[key] = list(tmp)
                    except KeyError:
                        res[key] = vals

        return res, oldees
                
    def _get_info(self, item, check_not_on_or_after=True):
        """ Get session information about a subject gotten from a
        specified IdP/AA.

        :param item: Information stored
        :return: The session information as a dictionary
        """
        timestamp = item["timestamp"]

        if check_not_on_or_after and not time_util.not_on_or_after(timestamp):
            raise ToOld()

        try:
            return item["info"]
        except KeyError:
            return None

    def get(self, subject_id, entity_id, check_not_on_or_after=True):
        res = self._cache.find_one({"subject_id": subject_id,
                                    "entity_id": entity_id})
        if not res:
            return {}
        else:
            return self._get_info(res, check_not_on_or_after)

    def set(self, subject_id, entity_id, info, timestamp=0):
        """ Stores session information in the cache. Assumes that the subject_id
        is unique within the context of the Service Provider.

        :param subject_id: The subject identifier
        :param entity_id: The identifier of the entity_id/receiver of an
            assertion
        :param info: The session info, the assertion is part of this
        :param timestamp: A time after which the assertion is not valid.
        """

        if isinstance(timestamp, datetime) or isinstance(timestamp,
                                                         time.struct_time):
            timestamp = time.strftime(TIME_FORMAT, timestamp)

        doc = {"subject_id": subject_id,
               "entity_id": entity_id,
               "info": info,
               "timestamp": timestamp}

        _ = self._cache.insert(doc)

    def reset(self, subject_id, entity_id):
        """ Scrap the assertions received from a IdP or an AA about a special
        subject.

        :param subject_id: The subjects identifier
        :param entity_id: The identifier of the entity_id of the assertion
        :return:
        """
        self._cache.update({"subject_id": subject_id, "entity_id": entity_id},
                           {"$set": {"info": {}, "timestamp": 0}})

    def entities(self, subject_id):
        """ Returns all the entities of assertions for a subject, disregarding
        whether the assertion still is valid or not.

        :param subject_id: The identifier of the subject
        :return: A possibly empty list of entity identifiers
        """
        try:
            return [i["entity_id"] for i in self._cache.find({"subject_id":
                    subject_id})]
        except ValueError:
            return []

    def receivers(self, subject_id):
        """ Another name for entities() just to make it more logic in the IdP
            scenario """
        return self.entities(subject_id)

    def active(self, subject_id, entity_id):
        """ Returns the status of assertions from a specific entity_id.

        :param subject_id: The ID of the subject
        :param entity_id: The entity ID of the entity_id of the assertion
        :return: True or False depending on if the assertion is still
            valid or not.
        """

        item = self._cache.find_one({"subject_id": subject_id,
                                     "entity_id": entity_id})
        try:
            return time_util.not_on_or_after(item["timestamp"])
        except ToOld:
            return False

    def subjects(self):
        """ Return identifiers for all the subjects that are in the cache.

        :return: list of subject identifiers
        """

        subj = [i["subject_id"] for i in self._cache.find()]

        return list(set(subj))

    def update(self, subject_id, entity_id, ava):
        """ """
        item = self._cache.find_one({"subject_id": subject_id,
                                     "entity_id": entity_id})
        info = item["info"]
        info["ava"].update(ava)
        self._cache.update({"subject_id": subject_id, "entity_id": entity_id},
                           {"$set": {"info": info}})

    def valid_to(self, subject_id, entity_id, newtime):
        """ """
        self._cache.update({"subject_id": subject_id, "entity_id": entity_id},
                           {"$set": {"timestamp": newtime}})

    def clear(self):
        self._cache.remove()
########NEW FILE########
__FILENAME__ = mdie
#!/usr/bin/env python
from saml2 import element_to_extension_element
from saml2 import extension_elements_to_elements
from saml2 import SamlBase
from saml2 import md

__author__ = 'rolandh'

"""
Functions used to import metadata from and export it to a pysaml2 format
"""

IMP_SKIP = ["_certs", "e_e_", "_extatt"]
EXP_SKIP = ["__class__"]


# From pysaml2 SAML2 metadata format to Python dictionary
def _eval(val, onts, mdb_safe):
    """
    Convert a value to a basic dict format
    :param val: The value
    :param onts: Schemas to be used in the conversion
    :return: The basic dictionary
    """
    if isinstance(val, basestring):
        val = val.strip()
        if not val:
            return None
        else:
            return val
    elif isinstance(val, dict) or isinstance(val, SamlBase):
        return to_dict(val, onts, mdb_safe)
    elif isinstance(val, list):
        lv = []
        for v in val:
            if isinstance(v, dict) or isinstance(v, SamlBase):
                lv.append(to_dict(v, onts, mdb_safe))
            else:
                lv.append(v)
        return lv
    return val


def to_dict(_dict, onts, mdb_safe=False):
    """
    Convert a pysaml2 SAML2 message class instance into a basic dictionary
    format.
    The export interface.

    :param _dict: The pysaml2 metadata instance
    :param onts: List of schemas to use for the conversion
    :return: The converted information
    """
    res = {}
    if isinstance(_dict, SamlBase):
        res["__class__"] = "%s&%s" % (_dict.c_namespace, _dict.c_tag)
        for key in _dict.keyswv():
            if key in IMP_SKIP:
                continue
            val = getattr(_dict, key)
            if key == "extension_elements":
                _eel = extension_elements_to_elements(val, onts)
                _val = [_eval(_v, onts, mdb_safe) for _v in _eel]
            elif key == "extension_attributes":
                if mdb_safe:
                    _val = dict([(k.replace(".", "__"), v) for k, v in
                                 val.items()])
                    #_val = {k.replace(".", "__"): v for k, v in val.items()}
                else:
                    _val = val
            else:
                _val = _eval(val, onts, mdb_safe)

            if _val:
                if mdb_safe:
                    key = key.replace(".", "__")
                res[key] = _val
    else:
        for key, val in _dict.items():
            _val = _eval(val, onts, mdb_safe)
            if _val:
                if mdb_safe and "." in key:
                    key = key.replace(".", "__")
                res[key] = _val
    return res


# From Python dictionary to pysaml2 SAML2 metadata format

def _kwa(val, onts, mdb_safe=False):
    """
    Key word argument conversion

    :param val: A dictionary
    :param onts: dictionary with schemas to use in the conversion
        schema namespase is the key in the dictionary
    :return: A converted dictionary
    """
    if not mdb_safe:
        return dict([(k, from_dict(v, onts)) for k, v in val.items()
                     if k not in EXP_SKIP])
    else:
        _skip = ["_id"]
        _skip.extend(EXP_SKIP)
        return dict([(k.replace("__", "."), from_dict(v, onts)) for k, v in
                     val.items() if k not in _skip])


def from_dict(val, onts, mdb_safe=False):
    """
    Converts a dictionary into a pysaml2 object
    :param val: A dictionary
    :param onts: Dictionary of schemas to use in the conversion
    :return: The pysaml2 object instance
    """
    if isinstance(val, dict):
        if "__class__" in val:
            ns, typ = val["__class__"].split("&")
            cls = getattr(onts[ns], typ)
            if cls is md.Extensions:
                lv = []
                for key, ditems in val.items():
                    if key in EXP_SKIP:
                        continue
                    for item in ditems:
                        ns, typ = item["__class__"].split("&")
                        cls = getattr(onts[ns], typ)
                        kwargs = _kwa(item, onts, mdb_safe)
                        inst = cls(**kwargs)
                        lv.append(element_to_extension_element(inst))
                return lv
            else:
                kwargs = _kwa(val, onts, mdb_safe)
                inst = cls(**kwargs)
            return inst
        else:
            res = {}
            for key, v in val.items():
                if mdb_safe:
                    key = key.replace("__", ".")
                res[key] = from_dict(v, onts)
            return res
    elif isinstance(val, basestring):
        return val
    elif isinstance(val, list):
        return [from_dict(v, onts) for v in val]
    else:
        return val

########NEW FILE########
__FILENAME__ = mdstore
import logging
import sys
import json

from hashlib import sha1
from saml2.httpbase import HTTPBase
from saml2.extension.idpdisc import BINDING_DISCO
from saml2.extension.idpdisc import DiscoveryResponse

from saml2.mdie import to_dict

from saml2 import md
from saml2 import samlp
from saml2 import SAMLError
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_SOAP
from saml2.s_utils import UnsupportedBinding, UnknownPrincipal
from saml2.sigver import split_len
from saml2.validate import valid_instance
from saml2.time_util import valid
from saml2.validate import NotValid
from saml2.sigver import security_context
from importlib import import_module

__author__ = 'rolandh'

logger = logging.getLogger(__name__)


class ToOld(Exception):
    pass


REQ2SRV = {
    # IDP
    "authn_request": "single_sign_on_service",
    "name_id_mapping_request": "name_id_mapping_service",
    # AuthnAuthority
    "authn_query": "authn_query_service",
    # AttributeAuthority
    "attribute_query": "attribute_service",
    # PDP
    "authz_decision_query": "authz_service",
    # AuthnAuthority + IDP + PDP + AttributeAuthority
    "assertion_id_request": "assertion_id_request_service",
    # IDP + SP
    "logout_request": "single_logout_service",
    "manage_name_id_request": "manage_name_id_service",
    "artifact_query": "artifact_resolution_service",
    # SP
    "assertion_response": "assertion_consumer_service",
    "attribute_response": "attribute_consuming_service",
    "discovery_service_request": "discovery_response"
}


ENTITYATTRIBUTES = "urn:oasis:names:tc:SAML:metadata:attribute&EntityAttributes"
ENTITY_CATEGORY = "http://macedir.org/entity-category"
ENTITY_CATEGORY_SUPPORT = "http://macedir.org/entity-category-support"

# ---------------------------------------------------


def destinations(srvs):
    return [s["location"] for s in srvs]


def attribute_requirement(entity):
    res = {"required": [], "optional": []}
    for acs in entity["attribute_consuming_service"]:
        for attr in acs["requested_attribute"]:
            if "is_required" in attr and attr["is_required"] == "true":
                res["required"].append(attr)
            else:
                res["optional"].append(attr)
    return res


def name(ent, langpref="en"):
    try:
        org = ent["organization"]
    except KeyError:
        return None

    for info in ["organization_display_name",
                 "organization_name",
                 "organization_url"]:
        try:
            for item in org[info]:
                if item["lang"] == langpref:
                    return item["text"]
        except KeyError:
            pass
    return None


def repack_cert(cert):
    part = cert.split("\n")
    if len(part) == 1:
        part = part[0].strip()
        return "\n".join(split_len(part, 64))
    else:
        return "\n".join([s.strip() for s in part])


class MetaData(object):
    def __init__(self, onts, attrc, metadata="", node_name=None,
                 check_validity=True, **kwargs):
        self.onts = onts
        self.attrc = attrc
        self.entity = {}
        self.metadata = metadata
        self.security = None
        self.node_name = node_name
        self.entities_descr = None
        self.entity_descr = None
        self.check_validity = check_validity
        
    def items(self):
        return self.entity.items()

    def keys(self):
        return self.entity.keys()

    def values(self):
        return self.entity.values()

    def __contains__(self, item):
        return item in self.entity

    def __getitem__(self, item):
        return self.entity[item]

    def do_entity_descriptor(self, entity_descr):
        if self.check_validity:
            try:
                if not valid(entity_descr.valid_until):
                    logger.info("Entity descriptor (entity id:%s) to old" % (
                        entity_descr.entity_id,))
                    return
            except AttributeError:
                pass

        # have I seen this entity_id before ? If so if log: ignore it
        if entity_descr.entity_id in self.entity:
            print >> sys.stderr, \
                "Duplicated Entity descriptor (entity id: '%s')" % \
                entity_descr.entity_id
            return

        _ent = to_dict(entity_descr, self.onts)
        flag = 0
        # verify support for SAML2
        for descr in ["spsso", "idpsso", "role", "authn_authority",
                      "attribute_authority", "pdp", "affiliation"]:
            _res = []
            try:
                _items = _ent["%s_descriptor" % descr]
            except KeyError:
                continue

            if descr == "affiliation":  # Not protocol specific
                flag += 1
                continue

            for item in _items:
                for prot in item["protocol_support_enumeration"].split(" "):
                    if prot == samlp.NAMESPACE:
                        item["protocol_support_enumeration"] = prot
                        _res.append(item)
                        break
            if not _res:
                del _ent["%s_descriptor" % descr]
            else:
                flag += 1

        if flag:
            self.entity[entity_descr.entity_id] = _ent

    def parse(self, xmlstr):
        self.entities_descr = md.entities_descriptor_from_string(xmlstr)

        if not self.entities_descr:
            self.entity_descr = md.entity_descriptor_from_string(xmlstr)
            if self.entity_descr:
                self.do_entity_descriptor(self.entity_descr)
        else:
            try:
                valid_instance(self.entities_descr)
            except NotValid, exc:
                logger.error(exc.args[0])
                return

            if self.check_validity:
                try:
                    if not valid(self.entities_descr.valid_until):
                        raise ToOld(
                            "Metadata not valid anymore, it's after %s" % (
                                self.entities_descr.valid_until,))
                except AttributeError:
                    pass

            for entity_descr in self.entities_descr.entity_descriptor:
                self.do_entity_descriptor(entity_descr)

    def load(self):
        self.parse(self.metadata)

    def service(self, entity_id, typ, service, binding=None):
        """ Get me all services with a specified
        entity ID and type, that supports the specified version of binding.

        :param entity_id: The EntityId
        :param typ: Type of service (idp, attribute_authority, ...)
        :param service: which service that is sought for
        :param binding: A binding identifier
        :return: list of service descriptions.
            Or if no binding was specified a list of 2-tuples (binding, srv)
        """

        logger.debug("service(%s, %s, %s, %s)" % (entity_id, typ, service,
                                                   binding))
        try:
            srvs = []
            for t in self[entity_id][typ]:
                try:
                    srvs.extend(t[service])
                except KeyError:
                    pass
        except KeyError:
            return None

        if not srvs:
            return srvs

        if binding:
            res = []
            for srv in srvs:
                if srv["binding"] == binding:
                    res.append(srv)
        else:
            res = {}
            for srv in srvs:
                try:
                    res[srv["binding"]].append(srv)
                except KeyError:
                    res[srv["binding"]] = [srv]
        logger.debug("service => %s" % res)
        return res

    def ext_service(self, entity_id, typ, service, binding):
        try:
            srvs = self[entity_id][typ]
        except KeyError:
            return None

        if not srvs:
            return srvs

        res = []
        for srv in srvs:
            if "extensions" in srv:
                for elem in srv["extensions"]["extension_elements"]:
                    if elem["__class__"] == service:
                        if elem["binding"] == binding:
                            res.append(elem)

        return res

    def any(self, typ, service, binding=None):
        """
        Return any entity that matches the specification

        :param typ:
        :param service:
        :param binding:
        :return:
        """
        res = {}
        for ent in self.keys():
            bind = self.service(ent, typ, service, binding)
            if bind:
                res[ent] = bind

        return res

    def bindings(self, entity_id, typ, service):
        """
        Get me all the bindings that are registered for a service entity

        :param entity_id:
        :param service:
        :return:
        """

        return self.service(entity_id, typ, service)

    def attribute_requirement(self, entity_id, index=0):
        """ Returns what attributes the SP requires and which are optional
        if any such demands are registered in the Metadata.

        :param entity_id: The entity id of the SP
        :param index: which of the attribute consumer services its all about
        :return: 2-tuple, list of required and list of optional attributes
        """

        res = {"required": [], "optional": []}

        try:
            for sp in self[entity_id]["spsso_descriptor"]:
                _res = attribute_requirement(sp)
                res["required"].extend(_res["required"])
                res["optional"].extend(_res["optional"])
        except KeyError:
            return None

        return res

    def dumps(self):
        return json.dumps(self.items(), indent=2)

    def with_descriptor(self, descriptor):
        res = {}
        desc = "%s_descriptor" % descriptor
        for eid, ent in self.items():
            if desc in ent:
                res[eid] = ent
        return res

    def __str__(self):
        return "%s" % self.items()

    def construct_source_id(self):
        res = {}
        for eid, ent in self.items():
            for desc in ["spsso_descriptor", "idpsso_descriptor"]:
                try:
                    for srv in ent[desc]:
                        if "artifact_resolution_service" in srv:
                            s = sha1(eid)
                            res[s.digest()] = ent
                except KeyError:
                    pass

        return res

    def entity_categories(self, entity_id):
        res = []
        if "extensions" in self[entity_id]:
            for elem in self[entity_id]["extensions"]["extension_elements"]:
                if elem["__class__"] == ENTITYATTRIBUTES:
                    for attr in elem["attribute"]:
                        res.append(attr["text"])

        return res

    def __eq__(self, other):
        try:
            assert isinstance(other, MetaData)
        except AssertionError:
            return False

        if len(self.entity) != len(other.entity):
            return False

        if set(self.entity.keys()) != set(other.entity.keys()):
            return False

        for key, item in self.entity.items():
            try:
                assert item == other[key]
            except AssertionError:
                return False

        return True


class MetaDataFile(MetaData):
    """
    Handles Metadata file on the same machine. The format of the file is
    the SAML Metadata format.
    """
    def __init__(self, onts, attrc, filename, cert=None, **kwargs):
        MetaData.__init__(self, onts, attrc, **kwargs)
        self.filename = filename
        self.cert = cert

    def get_metadata_content(self):
        return open(self.filename).read()

    def load(self):
        _txt = self.get_metadata_content()
        if self.cert:
            node_name = self.node_name \
                or "%s:%s" % (md.EntitiesDescriptor.c_namespace,
                              md.EntitiesDescriptor.c_tag)

            if self.security.verify_signature(_txt,
                                              node_name=node_name,
                                              cert_file=self.cert):
                self.parse(_txt)
                return True
        else:
            self.parse(_txt)
            return True


class MetaDataLoader(MetaDataFile):
    """
    Handles Metadata file loaded by a passed in function.
    The format of the file is the SAML Metadata format.
    """
    def __init__(self, onts, attrc, loader_callable, cert=None, **kwargs):
        MetaData.__init__(self, onts, attrc, **kwargs)
        self.metadata_provider_callable = self.get_metadata_loader(
            loader_callable)
        self.cert = cert

    @staticmethod
    def get_metadata_loader(func):
        if callable(func):
            return func

        i = func.rfind('.')
        module, attr = func[:i], func[i + 1:]
        try:
            mod = import_module(module)
        except Exception, e:
            raise RuntimeError(
                'Cannot find metadata provider function %s: "%s"' % (func, e))

        try:
            metadata_loader = getattr(mod, attr)
        except AttributeError:
            raise RuntimeError(
                'Module "%s" does not define a "%s" metadata loader' % (
                    module, attr))

        if not callable(metadata_loader):
            raise RuntimeError(
                'Metadata loader %s.%s must be callable' % (module, attr))

        return metadata_loader

    def get_metadata_content(self):
        return self.metadata_provider_callable()


class MetaDataExtern(MetaData):
    """
    Class that handles metadata store somewhere on the net.
    Accessible but HTTP GET.
    """

    def __init__(self, onts, attrc, url, security, cert, http, **kwargs):
        """
        :params onts:
        :params attrc:
        :params url:
        :params security: SecurityContext()
        :params cert:
        :params http:
        """
        MetaData.__init__(self, onts, attrc, **kwargs)
        self.url = url
        self.security = security
        self.cert = cert
        self.http = http

    def load(self):
        """ Imports metadata by the use of HTTP GET.
        If the fingerprint is known the file will be checked for
        compliance before it is imported.
        """
        response = self.http.send(self.url)
        if response.status_code == 200:
            node_name = self.node_name \
                or "%s:%s" % (md.EntitiesDescriptor.c_namespace,
                              md.EntitiesDescriptor.c_tag)

            _txt = response.text.encode("utf-8")
            if self.cert:
                if self.security.verify_signature(_txt,
                                                  node_name=node_name,
                                                  cert_file=self.cert):
                    self.parse(_txt)
                    return True
            else:
                self.parse(_txt)
                return True
        else:
            logger.info("Response status: %s" % response.status_code)
        return False


class MetaDataMD(MetaData):
    """
    Handles locally stored metadata, the file format is the text representation
    of the Python representation of the metadata.
    """
    def __init__(self, onts, attrc, filename, **kwargs):
        MetaData.__init__(self, onts, attrc, **kwargs)
        self.filename = filename

    def load(self):
        for key, item in json.loads(open(self.filename).read()):
            self.entity[key] = item


class MetadataStore(object):
    def __init__(self, onts, attrc, config, ca_certs=None,
                 disable_ssl_certificate_validation=False):
        """
        :params onts:
        :params attrc:
        :params config: Config()
        :params ca_certs:
        :params disable_ssl_certificate_validation:
        """
        self.onts = onts
        self.attrc = attrc
        self.http = HTTPBase(verify=disable_ssl_certificate_validation,
                             ca_bundle=ca_certs)
        self.security = security_context(config)
        self.ii = 0
        self.metadata = {}

    def load(self, typ, *args, **kwargs):
        if typ == "local":
            key = args[0]
            _md = MetaDataFile(self.onts, self.attrc, args[0])
        elif typ == "inline":
            self.ii += 1
            key = self.ii
            _md = MetaData(self.onts, self.attrc, args[0], **kwargs)
        elif typ == "remote":
            key = kwargs["url"]
            _md = MetaDataExtern(self.onts, self.attrc,
                                 kwargs["url"], self.security,
                                 kwargs["cert"], self.http,
                                 node_name=kwargs.get('node_name'))
        elif typ == "mdfile":
            key = args[0]
            _md = MetaDataMD(self.onts, self.attrc, args[0])
        elif typ == "loader":
            key = args[0]
            _md = MetaDataLoader(self.onts, self.attrc, args[0])
        else:
            raise SAMLError("Unknown metadata type '%s'" % typ)

        _md.load()
        self.metadata[key] = _md

    def imp(self, spec):
        for key, vals in spec.items():
            for val in vals:
                if isinstance(val, dict):
                    self.load(key, **val)
                else:
                    self.load(key, val)

    def service(self, entity_id, typ, service, binding=None):
        known_principal = False
        for key, _md in self.metadata.items():
            srvs = _md.service(entity_id, typ, service, binding)
            if srvs:
                return srvs
            elif srvs is None:
                pass
            else:
                known_principal = True

        if known_principal:
            logger.error("Unsupported binding: %s (%s)" % (binding, entity_id))
            raise UnsupportedBinding(binding)
        else:
            logger.error("Unknown principal: %s" % entity_id)
            raise UnknownPrincipal(entity_id)

    def ext_service(self, entity_id, typ, service, binding=None):
        known_principal = False
        for key, _md in self.metadata.items():
            srvs = _md.ext_service(entity_id, typ, service, binding)
            if srvs:
                return srvs
            elif srvs is None:
                pass
            else:
                known_principal = True

        if known_principal:
            raise UnsupportedBinding(binding)
        else:
            raise UnknownPrincipal(entity_id)

    def single_sign_on_service(self, entity_id, binding=None, typ="idpsso"):
        # IDP

        if binding is None:
            binding = BINDING_HTTP_REDIRECT
        return self.service(entity_id, "idpsso_descriptor",
                            "single_sign_on_service", binding)

    def name_id_mapping_service(self, entity_id, binding=None, typ="idpsso"):
        # IDP
        if binding is None:
            binding = BINDING_HTTP_REDIRECT
        return self.service(entity_id, "idpsso_descriptor",
                            "name_id_mapping_service", binding)

    def authn_query_service(self, entity_id, binding=None,
                            typ="authn_authority"):
        # AuthnAuthority
        if binding is None:
            binding = BINDING_SOAP
        return self.service(entity_id, "authn_authority_descriptor",
                            "authn_query_service", binding)

    def attribute_service(self, entity_id, binding=None,
                          typ="attribute_authority"):
        # AttributeAuthority
        if binding is None:
            binding = BINDING_HTTP_REDIRECT
        return self.service(entity_id, "attribute_authority_descriptor",
                            "attribute_service", binding)

    def authz_service(self, entity_id, binding=None, typ="pdp"):
        # PDP
        if binding is None:
            binding = BINDING_SOAP
        return self.service(entity_id, "pdp_descriptor",
                             "authz_service", binding)

    def assertion_id_request_service(self, entity_id, binding=None, typ=None):
        # AuthnAuthority + IDP + PDP + AttributeAuthority
        if typ is None:
            raise AttributeError("Missing type specification")
        if binding is None:
            binding = BINDING_SOAP
        return self.service(entity_id, "%s_descriptor" % typ,
                             "assertion_id_request_service", binding)

    def single_logout_service(self, entity_id, binding=None, typ=None):
        # IDP + SP
        if typ is None:
            raise AttributeError("Missing type specification")
        if binding is None:
            binding = BINDING_HTTP_REDIRECT
        return self.service(entity_id, "%s_descriptor" % typ,
                             "single_logout_service", binding)

    def manage_name_id_service(self, entity_id, binding=None, typ=None):
        # IDP + SP
        if binding is None:
            binding = BINDING_HTTP_REDIRECT
        return self.service(entity_id, "%s_descriptor" % typ,
                             "manage_name_id_service", binding)

    def artifact_resolution_service(self, entity_id, binding=None, typ=None):
        # IDP + SP
        if binding is None:
            binding = BINDING_HTTP_REDIRECT
        return self.service(entity_id, "%s_descriptor" % typ,
                             "artifact_resolution_service", binding)

    def assertion_consumer_service(self, entity_id, binding=None, _="spsso"):
        # SP
        if binding is None:
            binding = BINDING_HTTP_POST
        return self.service(entity_id, "spsso_descriptor",
                             "assertion_consumer_service", binding)

    def attribute_consuming_service(self, entity_id, binding=None, _="spsso"):
        # SP
        if binding is None:
            binding = BINDING_HTTP_REDIRECT
        return self.service(entity_id, "spsso_descriptor",
                             "attribute_consuming_service", binding)

    def discovery_response(self, entity_id, binding=None, _="spsso"):
        if binding is None:
            binding = BINDING_DISCO
        return self.ext_service(entity_id, "spsso_descriptor",
                                "%s&%s" % (DiscoveryResponse.c_namespace,
                                           DiscoveryResponse.c_tag),
                                binding)

    def attribute_requirement(self, entity_id, index=0):
        for _md in self.metadata.values():
            if entity_id in _md:
                return _md.attribute_requirement(entity_id, index)

    def keys(self):
        res = []
        for _md in self.metadata.values():
            res.extend(_md.keys())
        return res

    def __getitem__(self, item):
        for _md in self.metadata.values():
            try:
                return _md[item]
            except KeyError:
                pass

        raise KeyError(item)

    def __setitem__(self, key, value):
        self.metadata[key] = value

    def entities(self):
        num = 0
        for _md in self.metadata.values():
            num += len(_md.items())

        return num

    def __len__(self):
        return len(self.metadata)

    def with_descriptor(self, descriptor):
        res = {}
        for _md in self.metadata.values():
            res.update(_md.with_descriptor(descriptor))
        return res

    def name(self, entity_id, langpref="en"):
        for _md in self.metadata.values():
            if entity_id in _md.items():
                return name(_md[entity_id], langpref)
        return None

    def certs(self, entity_id, descriptor, use="signing"):
        ent = self.__getitem__(entity_id)
        if descriptor == "any":
            res = []
            for descr in ["spsso", "idpsso", "role", "authn_authority",
                          "attribute_authority", "pdp"]:
                try:
                    srvs = ent["%s_descriptor" % descr]
                except KeyError:
                    continue

                for srv in srvs:
                    for key in srv["key_descriptor"]:
                        if "use" in key and key["use"] == use:
                            for dat in key["key_info"]["x509_data"]:
                                cert = repack_cert(
                                    dat["x509_certificate"]["text"])
                                if cert not in res:
                                    res.append(cert)
                        elif not "use" in key:
                            for dat in key["key_info"]["x509_data"]:
                                cert = repack_cert(
                                    dat["x509_certificate"]["text"])
                                if cert not in res:
                                    res.append(cert)
        else:
            srvs = ent["%s_descriptor" % descriptor]

            res = []
            for srv in srvs:
                for key in srv["key_descriptor"]:
                    if "use" in key and key["use"] == use:
                        for dat in key["key_info"]["x509_data"]:
                            res.append(dat["x509_certificate"]["text"])
                    elif not "use" in key:
                        for dat in key["key_info"]["x509_data"]:
                            res.append(dat["x509_certificate"]["text"])
        return res

    def vo_members(self, entity_id):
        ad = self.__getitem__(entity_id)["affiliation_descriptor"]
        return [m["text"] for m in ad["affiliate_member"]]

    def entity_categories(self, entity_id):
        """
        Get a list of entity categories for an entity id.

        :param entity_id: Entity id
        :return: Entity categories

        :type entity_id: string
        :rtype: [string]
        """
        attributes = self.entity_attributes(entity_id)
        return attributes.get(ENTITY_CATEGORY, [])

    def supported_entity_categories(self, entity_id):
        """
        Get a list of entity category support for an entity id.

        :param entity_id: Entity id
        :return: Entity category support

        :type entity_id: string
        :rtype: [string]
        """
        attributes = self.entity_attributes(entity_id)
        return attributes.get(ENTITY_CATEGORY_SUPPORT, [])

    def entity_attributes(self, entity_id):
        """
        Get all entity attributes for an entry in the metadata.

        Example return data:

        {'http://macedir.org/entity-category': ['something', 'something2'],
         'http://example.org/saml-foo': ['bar']}

        :param entity_id: Entity id
        :return: dict with keys and value-lists from metadata

        :type entity_id: string
        :rtype: dict
        """
        res = {}
        try:
            ext = self.__getitem__(entity_id)["extensions"]
        except KeyError:
            return res
        for elem in ext["extension_elements"]:
            if elem["__class__"] == ENTITYATTRIBUTES:
                for attr in elem["attribute"]:
                    if attr["name"] not in res:
                        res[attr["name"]] = []
                    res[attr["name"]] += [v["text"] for v in attr[
                        "attribute_value"]]
        return res

    def bindings(self, entity_id, typ, service):
        for _md in self.metadata.values():
            if entity_id in _md.items():
                return _md.bindings(entity_id, typ, service)

        return None

    def __str__(self):
        _str = ["{"]
        for key, val in self.metadata.items():
            _str.append("%s: %s" % (key, val))
        _str.append("}")
        return "\n".join(_str)

    def construct_source_id(self):
        res = {}
        for _md in self.metadata.values():
            res.update(_md.construct_source_id())
        return res

    def items(self):
        res = {}
        for _md in self.metadata.values():
            res.update(_md.items())
        return res.items()

    def _providers(self, descriptor):
        res = []
        for _md in self.metadata.values():
            for ent_id, ent_desc in _md.items():
                if descriptor in ent_desc:
                    res.append(ent_id)
        return res

    def service_providers(self):
        return self._providers("spsso_descriptor")

    def identity_providers(self):
        return self._providers("idpsso_descriptor")

    def attribute_authorities(self):
        return self._providers("attribute_authority")

########NEW FILE########
__FILENAME__ = metadata
#!/usr/bin/env python
from saml2.sigver import security_context
from saml2.config import Config
from saml2.validate import valid_instance
from saml2.time_util import in_a_while
from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import shibmd
from saml2.extension import mdattr
from saml2.saml import NAME_FORMAT_URI
from saml2.saml import AttributeValue
from saml2.saml import Attribute
from saml2.attribute_converter import from_local_name
from saml2 import md, SAMLError
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_SOAP
from saml2 import samlp
from saml2 import class_name

import xmldsig as ds

from saml2.sigver import pre_signature_part

from saml2.s_utils import factory
from saml2.s_utils import rec_factory
from saml2.s_utils import sid

__author__ = 'rolandh'

NSPAIR = {
    "saml2p": "urn:oasis:names:tc:SAML:2.0:protocol",
    "saml2": "urn:oasis:names:tc:SAML:2.0:assertion",
    "soap11": "http://schemas.xmlsoap.org/soap/envelope/",
    "meta": "urn:oasis:names:tc:SAML:2.0:metadata",
    "xsi": "http://www.w3.org/2001/XMLSchema-instance",
    "ds": "http://www.w3.org/2000/09/xmldsig#",
    "shibmd": "urn:mace:shibboleth:metadata:1.0",
    "md": "urn:oasis:names:tc:SAML:2.0:metadata",
}

DEFAULTS = {
    "want_assertions_signed": "true",
    "authn_requests_signed": "false",
    "want_authn_requests_signed": "true",
    "want_authn_requests_only_with_valid_cert": "false",
}

ORG_ATTR_TRANSL = {
    "organization_name": ("name", md.OrganizationName),
    "organization_display_name": ("display_name", md.OrganizationDisplayName),
    "organization_url": ("url", md.OrganizationURL)
}


def metadata_tostring_fix(desc, nspair):
    MDNS = '"urn:oasis:names:tc:SAML:2.0:metadata"'
    XMLNSXS = " xmlns:xs=\"http://www.w3.org/2001/XMLSchema\""
    xmlstring = desc.to_string(nspair)
    if "\"xs:string\"" in xmlstring and XMLNSXS not in xmlstring:
        xmlstring = xmlstring.replace(MDNS, MDNS+XMLNSXS)
    return xmlstring


def create_metadata_string(configfile, config, valid, cert, keyfile, mid, name,
                           sign):
    valid_for = 0
    nspair = {"xs": "http://www.w3.org/2001/XMLSchema"}
    #paths = [".", "/opt/local/bin"]

    if valid:
        valid_for = int(valid)  # Hours

    eds = []
    if config is not None:
        eds.append(entity_descriptor(config))
    else:
        if configfile.endswith(".py"):
            configfile = configfile[:-3]
        config = Config().load_file(configfile, metadata_construction=True)
        eds.append(entity_descriptor(config))

    conf = Config()
    conf.key_file = keyfile
    conf.cert_file = cert
    conf.debug = 1
    conf.xmlsec_binary = config.xmlsec_binary
    secc = security_context(conf)

    if mid:
        desc = entities_descriptor(eds, valid_for, name, mid,
                                   sign, secc)
        valid_instance(desc)

        return metadata_tostring_fix(desc, nspair)
    else:
        for eid in eds:
            if sign:
                desc = sign_entity_descriptor(eid, mid, secc)
            else:
                desc = eid
            valid_instance(desc)
            return metadata_tostring_fix(desc, nspair)


def _localized_name(val, klass):
    """If no language is defined 'en' is the default"""
    try:
        (text, lang) = val
        return klass(text=text, lang=lang)
    except ValueError:
        return klass(text=val, lang="en")


def do_organization_info(ava):
    """
    Description of an organization in the configuration is
    a dictionary of keys and values, where the values might be tuples::

        "organization": {
            "name": ("AB Exempel", "se"),
            "display_name": ("AB Exempel", "se"),
            "url": "http://www.example.org"
        }

    """

    if ava is None:
        return None

    org = md.Organization()
    for dkey, (ckey, klass) in ORG_ATTR_TRANSL.items():
        if ckey not in ava:
            continue
        if isinstance(ava[ckey], basestring):
            setattr(org, dkey, [_localized_name(ava[ckey], klass)])
        elif isinstance(ava[ckey], list):
            setattr(org, dkey,
                    [_localized_name(n, klass) for n in ava[ckey]])
        else:
            setattr(org, dkey, [_localized_name(ava[ckey], klass)])
    return org


def do_contact_person_info(lava):
    """ Creates a ContactPerson instance from configuration information"""

    cps = []
    if lava is None:
        return cps

    contact_person = md.ContactPerson
    for ava in lava:
        cper = md.ContactPerson()
        for (key, classpec) in contact_person.c_children.values():
            try:
                value = ava[key]
                data = []
                if isinstance(classpec, list):
                    # What if value is not a list ?
                    if isinstance(value, basestring):
                        data = [classpec[0](text=value)]
                    else:
                        for val in value:
                            data.append(classpec[0](text=val))
                else:
                    data = classpec(text=value)
                setattr(cper, key, data)
            except KeyError:
                pass
        for (prop, classpec, _) in contact_person.c_attributes.values():
            try:
                # should do a check for valid value
                setattr(cper, prop, ava[prop])
            except KeyError:
                pass

        # ContactType must have a value
        typ = getattr(cper, "contact_type")
        if not typ:
            setattr(cper, "contact_type", "technical")

        cps.append(cper)

    return cps


def do_key_descriptor(cert, use="both"):
    if use == "both":
        return [
            md.KeyDescriptor(
                key_info=ds.KeyInfo(
                    x509_data=ds.X509Data(
                        x509_certificate=ds.X509Certificate(text=cert)
                    )
                ),
                use="encryption"
            ),
            md.KeyDescriptor(
                key_info=ds.KeyInfo(
                    x509_data=ds.X509Data(
                        x509_certificate=ds.X509Certificate(text=cert)
                    )
                ),
                use="signing"
            )
        ]
    elif use in ["signing", "encryption"]:
        return md.KeyDescriptor(
            key_info=ds.KeyInfo(
                x509_data=ds.X509Data(
                    x509_certificate=ds.X509Certificate(text=cert)
                )
            ),
            use=use
        )
    else:
        return md.KeyDescriptor(
            key_info=ds.KeyInfo(
                x509_data=ds.X509Data(
                    x509_certificate=ds.X509Certificate(text=cert)
                )
            )
        )


def do_requested_attribute(attributes, acs, is_required="false"):
    lista = []
    for attr in attributes:
        attr = from_local_name(acs, attr, NAME_FORMAT_URI)
        args = {}
        for key in attr.keyswv():
            args[key] = getattr(attr, key)
        args["is_required"] = is_required
        args["name_format"] = NAME_FORMAT_URI
        lista.append(md.RequestedAttribute(**args))
    return lista


def do_uiinfo(_uiinfo):
    uii = mdui.UIInfo()
    for attr in ['display_name', 'description', "information_url",
                 'privacy_statement_url']:
        try:
            val = _uiinfo[attr]
        except KeyError:
            continue

        aclass = uii.child_class(attr)
        inst = getattr(uii, attr)
        if isinstance(val, basestring):
            ainst = aclass(text=val)
            inst.append(ainst)
        elif isinstance(val, dict):
            ainst = aclass()
            ainst.text = val["text"]
            ainst.lang = val["lang"]
            inst.append(ainst)
        else:
            for value in val:
                if isinstance(value, basestring):
                    ainst = aclass(text=value)
                    inst.append(ainst)
                elif isinstance(value, dict):
                    ainst = aclass()
                    ainst.text = value["text"]
                    ainst.lang = value["lang"]
                    inst.append(ainst)

    try:
        _attr = "logo"
        val = _uiinfo[_attr]
        inst = getattr(uii, _attr)
        # dictionary or list of dictionaries
        if isinstance(val, dict):
            logo = mdui.Logo()
            for attr, value in val.items():
                if attr in logo.keys():
                    setattr(logo, attr, value)
            inst.append(logo)
        elif isinstance(val, list):
            for logga in val:
                if not isinstance(logga, dict):
                    raise SAMLError("Configuration error !!")
                logo = mdui.Logo()
                for attr, value in logga.items():
                    if attr in logo.keys():
                        setattr(logo, attr, value)
                inst.append(logo)
    except KeyError:
        pass

    try:
        _attr = "keywords"
        val = _uiinfo[_attr]
        inst = getattr(uii, _attr)
        # list of basestrings, dictionary or list of dictionaries
        if isinstance(val, list):
            for value in val:
                keyw = mdui.Keywords()
                if isinstance(value, basestring):
                    keyw.text = value
                elif isinstance(value, dict):
                    keyw.text = " ".join(value["text"])
                    try:
                        keyw.lang = value["lang"]
                    except KeyError:
                        pass
                else:
                    raise SAMLError("Configuration error: ui_info logo")
                inst.append(keyw)
        elif isinstance(val, dict):
            keyw = mdui.Keywords()
            keyw.text = " ".join(val["text"])
            try:
                keyw.lang = val["lang"]
            except KeyError:
                pass
            inst.append(keyw)
        else:
            raise SAMLError("Configuration Error: ui_info logo")
    except KeyError:
        pass

    return uii


def do_idpdisc(discovery_response):
    return idpdisc.DiscoveryResponse(index="0", location=discovery_response,
                                     binding=idpdisc.NAMESPACE)

ENDPOINTS = {
    "sp": {
        "artifact_resolution_service": (md.ArtifactResolutionService, True),
        "single_logout_service": (md.SingleLogoutService, False),
        "manage_name_id_service": (md.ManageNameIDService, False),
        "assertion_consumer_service": (md.AssertionConsumerService, True),
    },
    "idp": {
        "artifact_resolution_service": (md.ArtifactResolutionService, True),
        "single_logout_service": (md.SingleLogoutService, False),
        "manage_name_id_service": (md.ManageNameIDService, False),
        "single_sign_on_service": (md.SingleSignOnService, False),
        "name_id_mapping_service": (md.NameIDMappingService, False),
        "assertion_id_request_service": (md.AssertionIDRequestService, False),
    },
    "aa": {
        "artifact_resolution_service": (md.ArtifactResolutionService, True),
        "single_logout_service": (md.SingleLogoutService, False),
        "manage_name_id_service": (md.ManageNameIDService, False),
        "assertion_id_request_service": (md.AssertionIDRequestService, False),
        "attribute_service": (md.AttributeService, False)
    },
    "pdp": {
        "authz_service": (md.AuthzService, True)
    },
    "aq": {
        "authn_query_service": (md.AuthnQueryService, True)
    }
}

ENDPOINT_EXT = {
    "sp": {
        "discovery_response": (idpdisc.DiscoveryResponse, True)
    }
}

DEFAULT_BINDING = {
    "assertion_consumer_service": BINDING_HTTP_POST,
    "single_sign_on_service": BINDING_HTTP_REDIRECT,
    "single_logout_service": BINDING_HTTP_POST,
    "attribute_service": BINDING_SOAP,
    "artifact_resolution_service": BINDING_SOAP,
    "authn_query_service": BINDING_SOAP
}


def do_extensions(mname, item):
    try:
        _mod = __import__("saml2.extension.%s" % mname, globals(), locals(),
                          mname)
    except ImportError:
        return None
    else:
        res = []

        for _cname, ava in item.items():
            cls = getattr(_mod, _cname)
            res.append(rec_factory(cls, **ava))
    return res


def _do_nameid_format(cls, conf, typ):
    namef = conf.getattr("name_id_format", typ)
    if namef:
        if isinstance(namef, basestring):
            ids = [md.NameIDFormat(namef)]
        else:
            ids = [md.NameIDFormat(text=form) for form in namef]
        setattr(cls, "name_id_format", ids)


def do_endpoints(conf, endpoints):
    service = {}

    for endpoint, (eclass, indexed) in endpoints.items():
        try:
            servs = []
            i = 1
            for args in conf[endpoint]:
                if isinstance(args, basestring):  # Assume it's the location
                    args = {"location": args,
                            "binding": DEFAULT_BINDING[endpoint]}
                elif isinstance(args, tuple):
                    if len(args) == 2:  # (location, binding)
                        args = {"location": args[0], "binding": args[1]}
                    elif len(args) == 3:  # (location, binding, index)
                        args = {"location": args[0], "binding": args[1],
                                "index": args[2]}

                if indexed and "index" not in args:
                    args["index"] = "%d" % i
                    i += 1
                servs.append(factory(eclass, **args))
                service[endpoint] = servs
        except KeyError:
            pass
    return service

DEFAULT = {
    "want_assertions_signed": "true",
    "authn_requests_signed": "false",
    "want_authn_requests_signed": "false",
    #"want_authn_requests_only_with_valid_cert": "false",
}


def do_attribute_consuming_service(conf, spsso):

    service_description = service_name = None
    requested_attributes = []
    acs = conf.attribute_converters
    req = conf.getattr("required_attributes", "sp")
    if req:
        requested_attributes.extend(do_requested_attribute(req, acs,
                                                           is_required="true"))

    opt = conf.getattr("optional_attributes", "sp")

    if opt:
        requested_attributes.extend(do_requested_attribute(opt, acs))

    try:
        if conf.description:
            try:
                (text, lang) = conf.description
            except ValueError:
                text = conf.description
                lang = "en"
            service_description = [md.ServiceDescription(text=text, lang=lang)]
    except KeyError:
        pass

    try:
        if conf.name:
            try:
                (text, lang) = conf.name
            except ValueError:
                text = conf.name
                lang = "en"
            service_name = [md.ServiceName(text=text, lang=lang)]
    except KeyError:
        pass

    # Must be both requested attributes and service name
    if requested_attributes:
        if not service_name:
            service_name = [md.ServiceName(text="", lang="en")]

        ac_serv = md.AttributeConsumingService(
            index="1", service_name=service_name,
            requested_attribute=requested_attributes)

        if service_description:
            ac_serv.service_description = service_description

        spsso.attribute_consuming_service = [ac_serv]


def do_spsso_descriptor(conf, cert=None):
    spsso = md.SPSSODescriptor()
    spsso.protocol_support_enumeration = samlp.NAMESPACE

    exts = conf.getattr("extensions", "sp")
    if exts:
        if spsso.extensions is None:
            spsso.extensions = md.Extensions()

        for key, val in exts.items():
            _ext = do_extensions(key, val)
            if _ext:
                for _e in _ext:
                    spsso.extensions.add_extension_element(_e)

    endps = conf.getattr("endpoints", "sp")
    if endps:
        for (endpoint, instlist) in do_endpoints(endps,
                                                 ENDPOINTS["sp"]).items():
            setattr(spsso, endpoint, instlist)

    ext = do_endpoints(endps, ENDPOINT_EXT["sp"])
    if ext:
        if spsso.extensions is None:
            spsso.extensions = md.Extensions()
        for vals in ext.values():
            for val in vals:
                spsso.extensions.add_extension_element(val)

    if cert:
        encryption_type = conf.encryption_type
        spsso.key_descriptor = do_key_descriptor(cert, encryption_type)

    for key in ["want_assertions_signed", "authn_requests_signed"]:
        try:
            val = conf.getattr(key, "sp")
            if val is None:
                setattr(spsso, key, DEFAULT[key])  # default ?!
            else:
                strval = "{0:>s}".format(str(val))
                setattr(spsso, key, strval.lower())
        except KeyError:
            setattr(spsso, key, DEFAULTS[key])

    do_attribute_consuming_service(conf, spsso)
    _do_nameid_format(spsso, conf, "sp")
    return spsso


def do_idpsso_descriptor(conf, cert=None):
    idpsso = md.IDPSSODescriptor()
    idpsso.protocol_support_enumeration = samlp.NAMESPACE

    endps = conf.getattr("endpoints", "idp")
    if endps:
        for (endpoint, instlist) in do_endpoints(endps,
                                                 ENDPOINTS["idp"]).items():
            setattr(idpsso, endpoint, instlist)

    _do_nameid_format(idpsso, conf, "idp")

    scopes = conf.getattr("scope", "idp")
    if scopes:
        if idpsso.extensions is None:
            idpsso.extensions = md.Extensions()
        for scope in scopes:
            mdscope = shibmd.Scope()
            mdscope.text = scope
            # unless scope contains '*'/'+'/'?' assume non regexp ?
            mdscope.regexp = "false"
            idpsso.extensions.add_extension_element(mdscope)

    ui_info = conf.getattr("ui_info", "idp")
    if ui_info:
        if idpsso.extensions is None:
            idpsso.extensions = md.Extensions()
        idpsso.extensions.add_extension_element(do_uiinfo(ui_info))

    if cert:
        idpsso.key_descriptor = do_key_descriptor(cert)

    for key in ["want_authn_requests_signed"]:
                #"want_authn_requests_only_with_valid_cert"]:
        try:
            val = conf.getattr(key, "idp")
            if val is None:
                setattr(idpsso, key, DEFAULT[key])
            else:
                setattr(idpsso, key, ("%s" % val).lower())
        except KeyError:
            setattr(idpsso, key, DEFAULTS[key])

    return idpsso


def do_aa_descriptor(conf, cert):
    aad = md.AttributeAuthorityDescriptor()
    aad.protocol_support_enumeration = samlp.NAMESPACE

    endps = conf.getattr("endpoints", "aa")

    if endps:
        for (endpoint, instlist) in do_endpoints(endps,
                                                 ENDPOINTS["aa"]).items():
            setattr(aad, endpoint, instlist)

    _do_nameid_format(aad, conf, "aa")

    if cert:
        aad.key_descriptor = do_key_descriptor(cert)

    return aad


def do_aq_descriptor(conf, cert):
    aqs = md.AuthnAuthorityDescriptor()
    aqs.protocol_support_enumeration = samlp.NAMESPACE

    endps = conf.getattr("endpoints", "aq")

    if endps:
        for (endpoint, instlist) in do_endpoints(endps,
                                                 ENDPOINTS["aq"]).items():
            setattr(aqs, endpoint, instlist)

    _do_nameid_format(aqs, conf, "aq")

    if cert:
        aqs.key_descriptor = do_key_descriptor(cert)

    return aqs


def do_pdp_descriptor(conf, cert):
    """ Create a Policy Decision Point descriptor """
    pdp = md.PDPDescriptor()

    pdp.protocol_support_enumeration = samlp.NAMESPACE

    endps = conf.getattr("endpoints", "pdp")

    if endps:
        for (endpoint, instlist) in do_endpoints(endps,
                                                 ENDPOINTS["pdp"]).items():
            setattr(pdp, endpoint, instlist)

    _do_nameid_format(pdp, conf, "pdp")

    if cert:
        pdp.key_descriptor = do_key_descriptor(cert)

    return pdp


def entity_descriptor(confd):
    mycert = "".join(open(confd.cert_file).readlines()[1:-1])

    entd = md.EntityDescriptor()
    entd.entity_id = confd.entityid

    if confd.valid_for:
        entd.valid_until = in_a_while(hours=int(confd.valid_for))

    if confd.organization is not None:
        entd.organization = do_organization_info(confd.organization)
    if confd.contact_person is not None:
        entd.contact_person = do_contact_person_info(confd.contact_person)

    if confd.entity_category:
        entd.extensions = md.Extensions()
        ava = [AttributeValue(text=c) for c in confd.entity_category]
        attr = Attribute(attribute_value=ava,
                         name="http://macedir.org/entity-category")
        item = mdattr.EntityAttributes(attribute=attr)
        entd.extensions.add_extension_element(item)

    serves = confd.serves
    if not serves:
        raise SAMLError(
            'No service type ("sp","idp","aa") provided in the configuration')

    if "sp" in serves:
        confd.context = "sp"
        entd.spsso_descriptor = do_spsso_descriptor(confd, mycert)
    if "idp" in serves:
        confd.context = "idp"
        entd.idpsso_descriptor = do_idpsso_descriptor(confd, mycert)
    if "aa" in serves:
        confd.context = "aa"
        entd.attribute_authority_descriptor = do_aa_descriptor(confd, mycert)
    if "pdp" in serves:
        confd.context = "pdp"
        entd.pdp_descriptor = do_pdp_descriptor(confd, mycert)
    if "aq" in serves:
        confd.context = "aq"
        entd.authn_authority_descriptor = do_aq_descriptor(confd, mycert)

    return entd


def entities_descriptor(eds, valid_for, name, ident, sign, secc):
    entities = md.EntitiesDescriptor(entity_descriptor=eds)
    if valid_for:
        entities.valid_until = in_a_while(hours=valid_for)
    if name:
        entities.name = name
    if ident:
        entities.id = ident

    if sign:
        if not ident:
            ident = sid()

        if not secc.key_file:
            raise SAMLError("If you want to do signing you should define " +
                            "a key to sign with")

        if not secc.my_cert:
            raise SAMLError("If you want to do signing you should define " +
                            "where your public key are")

        entities.signature = pre_signature_part(ident, secc.my_cert, 1)
        entities.id = ident
        xmldoc = secc.sign_statement("%s" % entities, class_name(entities))
        entities = md.entities_descriptor_from_string(xmldoc)
    return entities


def sign_entity_descriptor(edesc, ident, secc):
    if not ident:
        ident = sid()

    edesc.signature = pre_signature_part(ident, secc.my_cert, 1)
    edesc.id = ident
    xmldoc = secc.sign_statement("%s" % edesc, class_name(edesc))
    return md.entity_descriptor_from_string(xmldoc)

########NEW FILE########
__FILENAME__ = mongo_store
from hashlib import sha1
import logging

from pymongo import MongoClient
from pymongo.mongo_replica_set_client import MongoReplicaSetClient
import pymongo.uri_parser
import pymongo.errors
from saml2.eptid import Eptid
from saml2.mdstore import MetaData
from saml2.s_utils import PolicyError

from saml2.ident import code, IdentDB, Unknown
from saml2.mdie import to_dict, from_dict

from saml2 import md
from saml2 import saml
from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
import xmldsig
import xmlenc


ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc
}

__author__ = 'rolandh'

logger = logging.getLogger(__name__)


class CorruptDatabase(Exception):
    pass


def context_match(cfilter, cntx):
    # TODO
    return True


class SessionStorageMDB(object):
    """ Session information is stored in a MongoDB database"""

    def __init__(self, database="", collection="assertion", **kwargs):
        db = _mdb_get_database(database, **kwargs)
        self.assertion = db[collection]

    def store_assertion(self, assertion, to_sign):
        name_id = assertion.subject.name_id
        nkey = sha1(code(name_id)).hexdigest()

        doc = {
            "name_id_key": nkey,
            "assertion_id": assertion.id,
            "assertion": to_dict(assertion, ONTS.values(), True),
            "to_sign": to_sign
        }

        _ = self.assertion.insert(doc)

    def get_assertion(self, cid):
        res = []
        for item in self.assertion.find({"assertion_id": cid}):
            res.append({"assertion": from_dict(item["assertion"], ONTS, True),
                        "to_sign": item["to_sign"]})
        if len(res) == 1:
            return res[0]
        elif res is []:
            return None
        else:
            raise SystemError("More then one assertion with the same ID")

    def get_assertions_by_subject(self, name_id=None, session_index=None,
                                  requested_context=None):
        """

        :param name_id: One of name_id or key can be used to get the authn
            statement
        :param session_index: If match against a session index should be done
        :param requested_context: Authn statements should match a specific
            authn context
        :return:
        """
        result = []
        key = sha1(code(name_id)).hexdigest()
        for item in self.assertion.find({"name_id_key": key}):
            assertion = from_dict(item["assertion"], ONTS, True)
            if session_index or requested_context:
                for statement in assertion.authn_statement:
                    if session_index:
                        if statement.session_index == session_index:
                            result.append(assertion)
                            break
                    if requested_context:
                        if context_match(requested_context,
                                         statement.authn_context):
                            result.append(assertion)
                            break
            else:
                result.append(assertion)
        return result

    def remove_authn_statements(self, name_id):
        logger.debug("remove authn about: %s" % name_id)
        key = sha1(code(name_id)).hexdigest()
        for item in self.assertion.find({"name_id_key": key}):
            self.assertion.remove(item["_id"])

    def get_authn_statements(self, name_id, session_index=None,
                             requested_context=None):
        """

        :param name_id:
        :param session_index:
        :param requested_context:
        :return:
        """
        return [k.authn_statement for k in self.get_assertions_by_subject(
            name_id, session_index, requested_context)]


class IdentMDB(IdentDB):
    def __init__(self, database="", collection="ident", domain="",
                 name_qualifier=""):
        IdentDB.__init__(self, None, domain, name_qualifier)
        self.mdb = MDB(database=database, collection=collection)
        self.mdb.primary_key = "user_id"

    def in_store(self, _id):
        if [x for x in self.mdb.get(ident_id=_id)]:
            return True
        else:
            return False

    def create_id(self, nformat, name_qualifier="", sp_name_qualifier=""):
        _id = self._create_id(nformat, name_qualifier, sp_name_qualifier)
        while self.in_store(_id):
            _id = self._create_id(nformat, name_qualifier, sp_name_qualifier)
        return _id

    def store(self, ident, name_id):
        self.mdb.store(ident, name_id=to_dict(name_id, ONTS.values(), True))

    def find_nameid(self, userid, nformat=None, sp_name_qualifier=None,
                    name_qualifier=None, sp_provided_id=None, **kwargs):
        # reset passed for compatibility kwargs for next usage
        kwargs = {}
        if nformat:
            kwargs["name_format"] = nformat
        if sp_name_qualifier:
            kwargs["sp_name_qualifier"] = sp_name_qualifier
        if name_qualifier:
            kwargs["name_qualifier"] = name_qualifier
        if sp_provided_id:
            kwargs["sp_provided_id"] = sp_provided_id

        res = []
        for item in self.mdb.get(userid, **kwargs):
            res.append(from_dict(item["name_id"], ONTS, True))
        return res

    def find_local_id(self, name_id):
        cnid = to_dict(name_id, ONTS.values(), True)
        for item in self.mdb.get(name_id=cnid):
            return item[self.mdb.primary_key]
        return None

    def remove_remote(self, name_id):
        cnid = to_dict(name_id, ONTS.values(), True)
        self.mdb.remove(name_id=cnid)

    def handle_name_id_mapping_request(self, name_id, name_id_policy):
        _id = self.find_local_id(name_id)
        if not _id:
            raise Unknown("Unknown entity")

        if name_id_policy.allow_create == "false":
            raise PolicyError("Not allowed to create new identifier")

        # else create and return a new one
        return self.construct_nameid(_id, name_id_policy=name_id_policy)

    def close(self):
        pass


#------------------------------------------------------------------------------
class MDB(object):
    primary_key = "mdb"

    def __init__(self, database, collection, **kwargs):
        _db = _mdb_get_database(database, **kwargs)
        self.db = _db[collection]

    def store(self, value, **kwargs):
        if value:
            doc = {self.primary_key: value}
        else:
            doc = {}
        doc.update(kwargs)
        _ = self.db.insert(doc)

    def get(self, value=None, **kwargs):
        if value is not None:
            doc = {self.primary_key: value}
            doc.update(kwargs)
            return [item for item in self.db.find(doc)]
        elif kwargs:
            return [item for item in self.db.find(kwargs)]

    def remove(self, key=None, **kwargs):
        if key is None:
            if kwargs:
                for item in self.db.find(kwargs):
                    self.db.remove(item["_id"])
        else:
            doc = {self.primary_key: key}
            doc.update(kwargs)
            for item in self.db.find(doc):
                self.db.remove(item["_id"])

    def keys(self):
        for item in self.db.find():
            yield item[self.primary_key]

    def items(self):
        for item in self.db.find():
            _key = item[self.primary_key]
            del item[self.primary_key]
            del item["_id"]
            yield _key, item

    def __contains__(self, key):
        doc = {self.primary_key: key}
        res = [item for item in self.db.find(doc)]
        if not res:
            return False
        else:
            return True

    def reset(self):
        self.db.drop()


def _mdb_get_database(uri, **kwargs):
    """
    Helper-function to connect to MongoDB and return a database object.

    The `uri' argument should be either a full MongoDB connection URI string,
    or just a database name in which case a connection to the default mongo
    instance at mongodb://localhost:27017 will be made.

    Performs explicit authentication if a username is provided in a connection
    string URI, since PyMongo does not always seem to do that as promised.

    :params database: name as string or (uri, name)
    :returns: pymongo database object
    """
    if not "tz_aware" in kwargs:
        # default, but not forced
        kwargs["tz_aware"] = True

    connection_factory = MongoClient
    _parsed_uri = {}

    try:
        _parsed_uri = pymongo.uri_parser.parse_uri(uri)
    except pymongo.errors.InvalidURI:
        # assume URI to be just the database name
        db_name = uri
        _conn = MongoClient()
        pass
    else:
        if "replicaset" in _parsed_uri["options"]:
            connection_factory = MongoReplicaSetClient
        db_name = _parsed_uri.get("database", "pysaml2")
        _conn = connection_factory(uri, **kwargs)

    _db = _conn[db_name]

    if "username" in _parsed_uri:
        _db.authenticate(
            _parsed_uri.get("username", None),
            _parsed_uri.get("password", None)
        )

    return _db


#------------------------------------------------------------------------------
class EptidMDB(Eptid):
    def __init__(self, secret, database="", collection="eptid"):
        Eptid.__init__(self, secret)
        self.mdb = MDB(database, collection)
        self.mdb.primary_key = "eptid_key"

    def __getitem__(self, key):
        res = self.mdb.get(key)
        if not res:
            raise KeyError(key)
        elif len(res) == 1:
            return res[0]["eptid"]
        else:
            raise CorruptDatabase("Found more than one EPTID document")

    def __setitem__(self, key, value):
        _ = self.mdb.store(key, **{"eptid": value})


#------------------------------------------------------------------------------

def protect(dic):
    res = {}
    for key, val in dic.items():
        key = key.replace(".", "__")
        if isinstance(val, basestring):
            pass
        elif isinstance(val, dict):
            val = protect(val)
        elif isinstance(val, list):
            li = []
            for va in val:
                if isinstance(va, basestring):
                    pass
                elif isinstance(va, dict):
                    va = protect(va)
                    # I don't think lists of lists will appear am I wrong ?
                li.append(va)
            val = li
        res[key] = val
    return res


def unprotect(dic):
    res = {}
    for key, val in dic.items():
        if key == "__class__":
            pass
        else:
            key = key.replace("__", ".")
        if isinstance(val, basestring):
            pass
        elif isinstance(val, dict):
            val = unprotect(val)
        elif isinstance(val, list):
            li = []
            for va in val:
                if isinstance(va, basestring):
                    pass
                elif isinstance(val, dict):
                    va = unprotect(va)
                li.append(va)
            val = li
        res[key] = val
    return res


def export_mdstore_to_mongo_db(mds, database, collection, sub_collection=""):
    mdb = MDB(database, collection, sub_collection=sub_collection)
    mdb.reset()
    mdb.primary_key = "entity_id"
    for key, desc in mds.items():
        kwargs = {
            "entity_description": protect(desc),
        }
        mdb.store(key, **kwargs)


class MetadataMDB(MetaData):
    def __init__(self, onts, attrc, database="", collection=""):
        MetaData.__init__(self, onts, attrc)
        self.mdb = MDB(database, collection)
        self.mdb.primary_key = "entity_id"

    def _ext_service(self, entity_id, typ, service, binding):
        try:
            srvs = self[entity_id][typ]
        except KeyError:
            return None

        if not srvs:
            return srvs

        res = []
        for srv in srvs:
            if "extensions" in srv:
                for elem in srv["extensions"]["extension_elements"]:
                    if elem["__class__"] == service:
                        if elem["binding"] == binding:
                            res.append(elem)

        return res

    def load(self):
        pass

    def items(self):
        for key, item in self.mdb.items():
            yield key, unprotect(item["entity_description"])

    def keys(self):
        return self.mdb.keys()

    def values(self):
        for key, item in self.mdb.items():
            yield unprotect(item["entity_description"])

    def __contains__(self, item):
        return item in self.mdb

    def __getitem__(self, item):
        res = self.mdb.get(item)
        if not res:
            raise KeyError(item)
        elif len(res) == 1:
            return unprotect(res[0]["entity_description"])
        else:
            raise CorruptDatabase("More then one document with key %s" % item)

    def bindings(self, entity_id, typ, service):
        pass

########NEW FILE########
__FILENAME__ = pack
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Contains classes and functions that are necessary to implement 
different bindings.

Bindings normally consists of three parts:
- rules about what to send 
- how to package the information
- which protocol to use
"""
import urlparse
import saml2
import base64
import urllib
from saml2.s_utils import deflate_and_base64_encode
from saml2.s_utils import Unsupported
import logging
from saml2.sigver import REQ_ORDER
from saml2.sigver import RESP_ORDER
from saml2.sigver import SIGNER_ALGS

logger = logging.getLogger(__name__)

try:
    from xml.etree import cElementTree as ElementTree
    if ElementTree.VERSION < '1.3.0':
        # cElementTree has no support for register_namespace
        # neither _namespace_map, thus we sacrify performance
        # for correctness
        from xml.etree import ElementTree
except ImportError:
    try:
        import cElementTree as ElementTree
    except ImportError:
        from elementtree import ElementTree

NAMESPACE = "http://schemas.xmlsoap.org/soap/envelope/"
FORM_SPEC = """<form method="post" action="%s">
   <input type="hidden" name="%s" value="%s" />
   <input type="hidden" name="RelayState" value="%s" />
</form>"""


def http_form_post_message(message, location, relay_state="",
                           typ="SAMLRequest"):
    """The HTTP POST binding defines a mechanism by which SAML protocol 
    messages may be transmitted within the base64-encoded content of a
    HTML form control.
    
    :param message: The message
    :param location: Where the form should be posted to
    :param relay_state: for preserving and conveying state information
    :return: A tuple containing header information and a HTML message.
    """
    response = ["<head>", """<title>SAML 2.0 POST</title>""", "</head><body>"]

    if not isinstance(message, basestring):
        message = "%s" % (message,)

    if typ == "SAMLRequest" or typ == "SAMLResponse":
        _msg = base64.b64encode(message)
    else:
        _msg = message

    response.append(FORM_SPEC % (location, typ, _msg, relay_state))
                                
    response.append("""<script type="text/javascript">""")
    response.append("     window.onload = function ()")
    response.append(" { document.forms[0].submit(); }")
    response.append("""</script>""")
    response.append("</body>")
    
    return {"headers": [("Content-type", "text/html")], "data": response}


def http_redirect_message(message, location, relay_state="", typ="SAMLRequest",
                          sigalg=None, key=None):
    """The HTTP Redirect binding defines a mechanism by which SAML protocol 
    messages can be transmitted within URL parameters.
    Messages are encoded for use with this binding using a URL encoding 
    technique, and transmitted using the HTTP GET method. 
    
    The DEFLATE Encoding is used in this function.
    
    :param message: The message
    :param location: Where the message should be posted to
    :param relay_state: for preserving and conveying state information
    :param typ: What type of message it is SAMLRequest/SAMLResponse/SAMLart
    :param sigalg: The signature algorithm to use.
    :param key: Key to use for signing
    :return: A tuple containing header information and a HTML message.
    """
    
    if not isinstance(message, basestring):
        message = "%s" % (message,)

    _order = None
    if typ in ["SAMLRequest", "SAMLResponse"]:
        if typ == "SAMLRequest":
            _order = REQ_ORDER
        else:
            _order = RESP_ORDER
        args = {typ: deflate_and_base64_encode(message)}
    elif typ == "SAMLart":
        args = {typ: message}
    else:
        raise Exception("Unknown message type: %s" % typ)

    if relay_state:
        args["RelayState"] = relay_state

    if sigalg:
        # sigalgs
        # http://www.w3.org/2000/09/xmldsig#dsa-sha1
        # http://www.w3.org/2000/09/xmldsig#rsa-sha1

        args["SigAlg"] = sigalg

        try:
            signer = SIGNER_ALGS[sigalg]
        except:
            raise Unsupported("Signing algorithm")
        else:
            string = "&".join([urllib.urlencode({k: args[k]}) for k in _order if k in args])
            args["Signature"] = base64.b64encode(signer.sign(string, key))
            string = urllib.urlencode(args)
    else:
        string = urllib.urlencode(args)

    glue_char = "&" if urlparse.urlparse(location).query else "?"
    login_url = glue_char.join([location, string])
    headers = [('Location', str(login_url))]
    body = []
    
    return {"headers": headers, "data": body}


DUMMY_NAMESPACE = "http://example.org/"
PREFIX = '<?xml version="1.0" encoding="UTF-8"?>'


def make_soap_enveloped_saml_thingy(thingy, header_parts=None):
    """ Returns a soap envelope containing a SAML request
    as a text string.

    :param thingy: The SAML thingy
    :return: The SOAP envelope as a string
    """
    envelope = ElementTree.Element('')
    envelope.tag = '{%s}Envelope' % NAMESPACE

    if header_parts:
        header = ElementTree.Element('')
        header.tag = '{%s}Header' % NAMESPACE
        envelope.append(header)
        for part in header_parts:
            # This doesn't work if the headers are signed
            part.become_child_element_of(header)

    body = ElementTree.Element('')
    body.tag = '{%s}Body' % NAMESPACE
    envelope.append(body)

    if isinstance(thingy, basestring):
        # remove the first XML version/encoding line
        logger.debug("thingy0: %s" % thingy)
        _part = thingy.split("\n")
        thingy = "".join(_part[1:])
        thingy = thingy.replace(PREFIX, "")
        logger.debug("thingy: %s" % thingy)
        _child = ElementTree.Element('')
        _child.tag = '{%s}FuddleMuddle' % DUMMY_NAMESPACE
        body.append(_child)
        _str = ElementTree.tostring(envelope, encoding="UTF-8")
        logger.debug("SOAP precursor: %s" % _str)
        # find an remove the namespace definition
        i = _str.find(DUMMY_NAMESPACE)
        j = _str.rfind("xmlns:", 0, i)
        cut1 = _str[j:i + len(DUMMY_NAMESPACE) + 1]
        _str = _str.replace(cut1, "")
        first = _str.find("<%s:FuddleMuddle" % (cut1[6:9],))
        last = _str.find(">", first + 14)
        cut2 = _str[first:last + 1]
        return _str.replace(cut2, thingy)
    else:
        thingy.become_child_element_of(body)
        return ElementTree.tostring(envelope, encoding="UTF-8")


def http_soap_message(message):
    return {"headers": [("Content-type", "application/soap+xml")],
            "data": make_soap_enveloped_saml_thingy(message)}
    

def http_paos(message, extra=None):
    return {"headers": [("Content-type", "application/soap+xml")],
            "data": make_soap_enveloped_saml_thingy(message, extra)}
    

def parse_soap_enveloped_saml(text, body_class, header_class=None):
    """Parses a SOAP enveloped SAML thing and returns header parts and body

    :param text: The SOAP object as XML 
    :return: header parts and body as saml.samlbase instances
    """
    envelope = ElementTree.fromstring(text)
    assert envelope.tag == '{%s}Envelope' % NAMESPACE

    #print len(envelope)
    body = None
    header = {}
    for part in envelope:
        #print ">",part.tag
        if part.tag == '{%s}Body' % NAMESPACE:
            for sub in part:
                try:
                    body = saml2.create_class_from_element_tree(body_class, sub)
                except Exception:
                    raise Exception(
                        "Wrong body type (%s) in SOAP envelope" % sub.tag)
        elif part.tag == '{%s}Header' % NAMESPACE:
            if not header_class:
                raise Exception("Header where I didn't expect one")
            #print "--- HEADER ---"
            for sub in part:
                #print ">>",sub.tag
                for klass in header_class:
                    #print "?{%s}%s" % (klass.c_namespace,klass.c_tag)
                    if sub.tag == "{%s}%s" % (klass.c_namespace, klass.c_tag):
                        header[sub.tag] = \
                            saml2.create_class_from_element_tree(klass, sub)
                        break
                        
    return body, header

# -----------------------------------------------------------------------------

PACKING = {
    saml2.BINDING_HTTP_REDIRECT: http_redirect_message,
    saml2.BINDING_HTTP_POST: http_form_post_message,
}
    

def packager(identifier):
    try:
        return PACKING[identifier]
    except KeyError:
        raise Exception("Unkown binding type: %s" % identifier)


def factory(binding, message, location, relay_state="", typ="SAMLRequest"):
    return PACKING[binding](message, location, relay_state, typ)

########NEW FILE########
__FILENAME__ = population
import logging
from saml2.cache import Cache

logger = logging.getLogger(__name__)


class Population(object):
    def __init__(self, cache=None):
        if cache:
            if isinstance(cache, basestring):
                self.cache = Cache(cache)
            else:
                self.cache = cache
        else:
            self.cache = Cache()

    def add_information_about_person(self, session_info):
        """If there already are information from this source in the cache 
        this function will overwrite that information"""
        
        name_id = session_info["name_id"]
        issuer = session_info["issuer"]
        del session_info["issuer"]
        self.cache.set(name_id, issuer, session_info,
                       session_info["not_on_or_after"])
        return name_id
    
    def stale_sources_for_person(self, name_id, sources=None):
        """
        
        :param name_id: Identifier of the subject, a NameID instance 
        :param sources: Sources for information about the subject
        :return:
        """
        if not sources:  # assume that all the members has be asked
                         # once before, hence they are represented in the cache
            sources = self.cache.entities(name_id)
        sources = [m for m in sources if not self.cache.active(name_id, m)]
        return sources                       
        
    def issuers_of_info(self, name_id):
        return self.cache.entities(name_id)

    def get_identity(self, name_id, entities=None, check_not_on_or_after=True):
        return self.cache.get_identity(name_id, entities, check_not_on_or_after)

    def get_info_from(self, name_id, entity_id):
        return self.cache.get(name_id, entity_id)
        
    def subjects(self):
        """Returns the name id's for all the persons in the cache"""
        return self.cache.subjects()

    def remove_person(self, name_id):
        self.cache.delete(name_id)
        
    def get_entityid(self, name_id, source_id, check_not_on_or_after=True):
        try:
            return self.cache.get(name_id, source_id, check_not_on_or_after)[
                "name_id"]
        except (KeyError, ValueError):
            return ""
            
    def sources(self, name_id):
        return self.cache.entities(name_id)

########NEW FILE########
__FILENAME__ = ecp
#!/usr/bin/env python

#
# Generated Fri May 27 23:08:21 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

from saml2 import saml
from saml2 import samlp
#import soapenv as S

NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp'

class RequestType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp:RequestType element """

    c_tag = 'RequestType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Issuer'] = ('issuer', saml.Issuer)
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}IDPList'] = ('idp_list', samlp.IDPList)
    c_cardinality['idp_list'] = {"min":0, "max":1}
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}mustUnderstand'] = ('must_understand', 'None', True)
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}actor'] = ('actor', 'None', True)
    c_attributes['ProviderName'] = ('provider_name', 'string', False)
    c_attributes['IsPassive'] = ('is_passive', 'boolean', False)
    c_child_order.extend(['issuer', 'idp_list'])

    def __init__(self,
            issuer=None,
            idp_list=None,
            must_understand=None,
            actor=None,
            provider_name=None,
            is_passive=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.issuer=issuer
        self.idp_list=idp_list
        self.must_understand=must_understand
        self.actor=actor
        self.provider_name=provider_name
        self.is_passive=is_passive

def request_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RequestType_, xml_string)


class ResponseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp:ResponseType element """

    c_tag = 'ResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}mustUnderstand'] = ('must_understand', 'None', True)
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}actor'] = ('actor', 'None', True)
    c_attributes['AssertionConsumerServiceURL'] = ('assertion_consumer_service_url', 'anyURI', True)

    def __init__(self,
            must_understand=None,
            actor=None,
            assertion_consumer_service_url=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.must_understand=must_understand
        self.actor=actor
        self.assertion_consumer_service_url=assertion_consumer_service_url

def response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ResponseType_, xml_string)


class RelayStateType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp:RelayStateType element """

    c_tag = 'RelayStateType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}mustUnderstand'] = ('must_understand', 'string', True)
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}actor'] = ('actor', 'string', True)

    def __init__(self,
            must_understand=None,
            actor=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.must_understand=must_understand
        self.actor=actor

def relay_state_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RelayStateType_, xml_string)


class Request(RequestType_):
    """The urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp:Request element """

    c_tag = 'Request'
    c_namespace = NAMESPACE
    c_children = RequestType_.c_children.copy()
    c_attributes = RequestType_.c_attributes.copy()
    c_child_order = RequestType_.c_child_order[:]
    c_cardinality = RequestType_.c_cardinality.copy()

def request_from_string(xml_string):
    return saml2.create_class_from_xml_string(Request, xml_string)


class Response(ResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp:Response element """

    c_tag = 'Response'
    c_namespace = NAMESPACE
    c_children = ResponseType_.c_children.copy()
    c_attributes = ResponseType_.c_attributes.copy()
    c_child_order = ResponseType_.c_child_order[:]
    c_cardinality = ResponseType_.c_cardinality.copy()

def response_from_string(xml_string):
    return saml2.create_class_from_xml_string(Response, xml_string)


class RelayState(RelayStateType_):
    """The urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp:RelayState element """

    c_tag = 'RelayState'
    c_namespace = NAMESPACE
    c_children = RelayStateType_.c_children.copy()
    c_attributes = RelayStateType_.c_attributes.copy()
    c_child_order = RelayStateType_.c_child_order[:]
    c_cardinality = RelayStateType_.c_cardinality.copy()

def relay_state_from_string(xml_string):
    return saml2.create_class_from_xml_string(RelayState, xml_string)


ELEMENT_FROM_STRING = {
    Request.c_tag: request_from_string,
    RequestType_.c_tag: request_type__from_string,
    Response.c_tag: response_from_string,
    ResponseType_.c_tag: response_type__from_string,
    RelayState.c_tag: relay_state_from_string,
    RelayStateType_.c_tag: relay_state_type__from_string,
}

ELEMENT_BY_TAG = {
    'Request': Request,
    'RequestType': RequestType_,
    'Response': Response,
    'ResponseType': ResponseType_,
    'RelayState': RelayState,
    'RelayStateType': RelayStateType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = paos
#!/usr/bin/env python

#
# Generated Fri May 27 17:30:44 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

#import soapenv as S

NAMESPACE = 'urn:liberty:paos:2003-08'

class RequestType_(SamlBase):
    """The urn:liberty:paos:2003-08:RequestType element """

    c_tag = 'RequestType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['responseConsumerURL'] = ('response_consumer_url', 'anyURI', True)
    c_attributes['service'] = ('service', 'anyURI', True)
    c_attributes['messageID'] = ('message_id', 'None', False)
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}mustUnderstand'] = ('must_understand', 'None', True)
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}actor'] = ('actor', 'None', True)

    def __init__(self,
            response_consumer_url=None,
            service=None,
            message_id=None,
            must_understand=None,
            actor=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.response_consumer_url=response_consumer_url
        self.service=service
        self.message_id=message_id
        self.must_understand=must_understand
        self.actor=actor

def request_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RequestType_, xml_string)


class ResponseType_(SamlBase):
    """The urn:liberty:paos:2003-08:ResponseType element """

    c_tag = 'ResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['refToMessageID'] = ('ref_to_message_id', 'None', False)
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}mustUnderstand'] = ('must_understand', 'None', True)
    c_attributes['{http://schemas.xmlsoap.org/soap/envelope/}actor'] = ('actor', 'None', True)

    def __init__(self,
            ref_to_message_id=None,
            must_understand=None,
            actor=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.ref_to_message_id=ref_to_message_id
        self.must_understand=must_understand
        self.actor=actor

def response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ResponseType_, xml_string)


class Request(RequestType_):
    """The urn:liberty:paos:2003-08:Request element """

    c_tag = 'Request'
    c_namespace = NAMESPACE
    c_children = RequestType_.c_children.copy()
    c_attributes = RequestType_.c_attributes.copy()
    c_child_order = RequestType_.c_child_order[:]
    c_cardinality = RequestType_.c_cardinality.copy()

def request_from_string(xml_string):
    return saml2.create_class_from_xml_string(Request, xml_string)


class Response(ResponseType_):
    """The urn:liberty:paos:2003-08:Response element """

    c_tag = 'Response'
    c_namespace = NAMESPACE
    c_children = ResponseType_.c_children.copy()
    c_attributes = ResponseType_.c_attributes.copy()
    c_child_order = ResponseType_.c_child_order[:]
    c_cardinality = ResponseType_.c_cardinality.copy()

def response_from_string(xml_string):
    return saml2.create_class_from_xml_string(Response, xml_string)


ELEMENT_FROM_STRING = {
    Request.c_tag: request_from_string,
    RequestType_.c_tag: request_type__from_string,
    Response.c_tag: response_from_string,
    ResponseType_.c_tag: response_type__from_string,
}

ELEMENT_BY_TAG = {
    'Request': Request,
    'RequestType': RequestType_,
    'Response': Response,
    'ResponseType': ResponseType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = request
import logging

from attribute_converter import to_local
from saml2 import time_util
from saml2.s_utils import OtherError

from saml2.validate import valid_instance
from saml2.validate import NotValid
from saml2.response import IncorrectlySigned

logger = logging.getLogger(__name__)


def _dummy(_arg):
    return None
    

class Request(object):
    def __init__(self, sec_context, receiver_addrs, attribute_converters=None,
                 timeslack=0):
        self.sec = sec_context
        self.receiver_addrs = receiver_addrs
        self.timeslack = timeslack
        self.xmlstr = ""
        self.name_id = ""
        self.message = None
        self.not_on_or_after = 0
        self.attribute_converters = attribute_converters
        self.binding = None
        self.relay_state = ""
        self.signature_check = _dummy  # has to be set !!!
    
    def _clear(self):
        self.xmlstr = ""
        self.name_id = ""
        self.message = None
        self.not_on_or_after = 0

    def _loads(self, xmldata, binding=None, origdoc=None, must=None, only_valid_cert=False):
        # own copy
        self.xmlstr = xmldata[:]
        logger.info("xmlstr: %s" % (self.xmlstr,))
        try:
            self.message = self.signature_check(xmldata, origdoc=origdoc, must=must, only_valid_cert=only_valid_cert)
        except TypeError:
            raise
        except Exception, excp:
            logger.info("EXCEPTION: %s", excp)
    
        if not self.message:
            logger.error("Response was not correctly signed")
            logger.info(xmldata)
            raise IncorrectlySigned()

        logger.info("request: %s" % (self.message,))

        try:
            valid_instance(self.message)
        except NotValid, exc:
            logger.error("Not valid request: %s" % exc.args[0])
            raise
        
        return self
    
    def issue_instant_ok(self):
        """ Check that the request was issued at a reasonable time """
        upper = time_util.shift_time(time_util.time_in_a_while(days=1),
                                     self.timeslack).timetuple()
        lower = time_util.shift_time(time_util.time_a_while_ago(days=1),
                                     - self.timeslack).timetuple()
        # print "issue_instant: %s" % self.message.issue_instant
        # print "%s < x < %s" % (lower, upper)
        issued_at = time_util.str_to_time(self.message.issue_instant)
        return issued_at > lower and issued_at < upper

    def _verify(self):            
        assert self.message.version == "2.0"
        if self.message.destination and \
                self.message.destination not in self.receiver_addrs:
            logger.error("%s not in %s" % (self.message.destination,
                                                self.receiver_addrs))
            raise OtherError("Not destined for me!")
            
        assert self.issue_instant_ok()
        return self

    def loads(self, xmldata, binding, origdoc=None, must=None, only_valid_cert=False):
        return self._loads(xmldata, binding, origdoc, must, only_valid_cert=only_valid_cert)

    def verify(self):
        try:
            return self._verify()
        except AssertionError:
            return None
            
    def subject_id(self):
        """ The name of the subject can be in either of 
        BaseID, NameID or EncryptedID

        :return: The identifier if there is one
        """

        if "subject" in self.message.keys():
            _subj = self.message.subject
            if "base_id" in _subj.keys() and _subj.base_id:
                return _subj.base_id
            elif _subj.name_id:
                return _subj.name_id
        else:
            if "base_id" in self.message.keys() and self.message.base_id:
                return self.message.base_id
            elif self.message.name_id:
                return self.message.name_id
            else:  # EncryptedID
                pass
            
    def sender(self):
        return self.message.issuer.text
        

class LogoutRequest(Request):
    msgtype = "logout_request"

    def __init__(self, sec_context, receiver_addrs, attribute_converters=None,
                 timeslack=0):
        Request.__init__(self, sec_context, receiver_addrs,
                         attribute_converters, timeslack)
        self.signature_check = self.sec.correctly_signed_logout_request
        
            
class AttributeQuery(Request):
    msgtype = "attribute_query"

    def __init__(self, sec_context, receiver_addrs, attribute_converters=None,
                 timeslack=0):
        Request.__init__(self, sec_context, receiver_addrs,
                         attribute_converters, timeslack)
        self.signature_check = self.sec.correctly_signed_attribute_query
    
    def attribute(self):
        """ Which attributes that are sought for """
        return []


class AuthnRequest(Request):
    msgtype = "authn_request"

    def __init__(self, sec_context, receiver_addrs, attribute_converters,
                 timeslack=0):
        Request.__init__(self, sec_context, receiver_addrs,
                         attribute_converters, timeslack)
        self.signature_check = self.sec.correctly_signed_authn_request

    def attributes(self):
        return to_local(self.attribute_converters, self.message)


class AuthnQuery(Request):
    msgtype = "authn_query"

    def __init__(self, sec_context, receiver_addrs, attribute_converters,
                 timeslack=0):
        Request.__init__(self, sec_context, receiver_addrs,
                         attribute_converters, timeslack)
        self.signature_check = self.sec.correctly_signed_authn_query

    def attributes(self):
        return to_local(self.attribute_converters, self.message)


class AssertionIDRequest(Request):
    msgtype = "assertion_id_request"

    def __init__(self, sec_context, receiver_addrs, attribute_converters,
                 timeslack=0):
        Request.__init__(self, sec_context, receiver_addrs,
                         attribute_converters, timeslack)
        self.signature_check = self.sec.correctly_signed_assertion_id_request

    def attributes(self):
        return to_local(self.attribute_converters, self.message)


class AuthzDecisionQuery(Request):
    msgtype = "authz_decision_query"

    def __init__(self, sec_context, receiver_addrs,
                 attribute_converters=None, timeslack=0):
        Request.__init__(self, sec_context, receiver_addrs,
                         attribute_converters, timeslack)
        self.signature_check = self.sec.correctly_signed_authz_decision_query

    def action(self):
        """ Which action authorization is requested for """
        pass

    def evidence(self):
        """ The evidence on which the decision is based """
        pass

    def resource(self):
        """ On which resource the action is expected to occur """
        pass


class NameIDMappingRequest(Request):
    msgtype = "name_id_mapping_request"

    def __init__(self, sec_context, receiver_addrs, attribute_converters,
                 timeslack=0):
        Request.__init__(self, sec_context, receiver_addrs,
                         attribute_converters, timeslack)
        self.signature_check = self.sec.correctly_signed_name_id_mapping_request


class ManageNameIDRequest(Request):
    msgtype = "manage_name_id_request"

    def __init__(self, sec_context, receiver_addrs, attribute_converters,
                 timeslack=0):
        Request.__init__(self, sec_context, receiver_addrs,
                         attribute_converters, timeslack)
        self.signature_check = self.sec.correctly_signed_manage_name_id_request

SERVICE2REQUEST = {
    "single_sign_on_service": AuthnRequest,
    "attribute_service": AttributeQuery,
    "authz_service": AuthzDecisionQuery,
    "assertion_id_request_service": AssertionIDRequest,
    "authn_query_service": AuthnQuery,
    "manage_name_id_service": ManageNameIDRequest,
    "name_id_mapping_service": NameIDMappingRequest,
    #"artifact_resolve_service": ArtifactResolve,
    "single_logout_service": LogoutRequest
}

########NEW FILE########
__FILENAME__ = response
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import calendar
import logging
from saml2.samlp import STATUS_VERSION_MISMATCH
from saml2.samlp import STATUS_AUTHN_FAILED
from saml2.samlp import STATUS_INVALID_ATTR_NAME_OR_VALUE
from saml2.samlp import STATUS_INVALID_NAMEID_POLICY
from saml2.samlp import STATUS_NO_AUTHN_CONTEXT
from saml2.samlp import STATUS_NO_AVAILABLE_IDP
from saml2.samlp import STATUS_NO_PASSIVE
from saml2.samlp import STATUS_NO_SUPPORTED_IDP
from saml2.samlp import STATUS_PARTIAL_LOGOUT
from saml2.samlp import STATUS_PROXY_COUNT_EXCEEDED
from saml2.samlp import STATUS_REQUEST_DENIED
from saml2.samlp import STATUS_REQUEST_UNSUPPORTED
from saml2.samlp import STATUS_REQUEST_VERSION_DEPRECATED
from saml2.samlp import STATUS_REQUEST_VERSION_TOO_HIGH
from saml2.samlp import STATUS_REQUEST_VERSION_TOO_LOW
from saml2.samlp import STATUS_RESOURCE_NOT_RECOGNIZED
from saml2.samlp import STATUS_TOO_MANY_RESPONSES
from saml2.samlp import STATUS_UNKNOWN_ATTR_PROFILE
from saml2.samlp import STATUS_UNKNOWN_PRINCIPAL
from saml2.samlp import STATUS_UNSUPPORTED_BINDING

import xmldsig as ds
import xmlenc as xenc

from saml2 import samlp
from saml2 import class_name
from saml2 import saml
from saml2 import extension_elements_to_elements
from saml2 import SAMLError
from saml2 import time_util

from saml2.s_utils import RequestVersionTooLow
from saml2.s_utils import RequestVersionTooHigh
from saml2.saml import attribute_from_string, XSI_TYPE
from saml2.saml import SCM_BEARER
from saml2.saml import SCM_HOLDER_OF_KEY
from saml2.saml import SCM_SENDER_VOUCHES
from saml2.saml import encrypted_attribute_from_string
from saml2.sigver import security_context
from saml2.sigver import SignatureError
from saml2.sigver import signed
from saml2.attribute_converter import to_local
from saml2.time_util import str_to_time, later_than

from saml2.validate import validate_on_or_after
from saml2.validate import validate_before
from saml2.validate import valid_instance
from saml2.validate import valid_address
from saml2.validate import NotValid

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------


class IncorrectlySigned(SAMLError):
    pass


class DecryptionFailed(SAMLError):
    pass


class VerificationError(SAMLError):
    pass


class StatusError(SAMLError):
    pass


class UnsolicitedResponse(SAMLError):
    pass


class StatusVersionMismatch(StatusError):
    pass


class StatusAuthnFailed(StatusError):
    pass


class StatusInvalidAttrNameOrValue(StatusError):
    pass


class StatusInvalidNameidPolicy(StatusError):
    pass


class StatusNoAuthnContext(StatusError):
    pass


class StatusNoAvailableIdp(StatusError):
    pass


class StatusNoPassive(StatusError):
    pass


class StatusNoSupportedIdp(StatusError):
    pass


class StatusPartialLogout(StatusError):
    pass


class StatusProxyCountExceeded(StatusError):
    pass


class StatusRequestDenied(StatusError):
    pass


class StatusRequestUnsupported(StatusError):
    pass


class StatusRequestVersionDeprecated(StatusError):
    pass


class StatusRequestVersionTooHigh(StatusError):
    pass


class StatusRequestVersionTooLow(StatusError):
    pass


class StatusResourceNotRecognized(StatusError):
    pass


class StatusTooManyResponses(StatusError):
    pass


class StatusUnknownAttrProfile(StatusError):
    pass


class StatusUnknownPrincipal(StatusError):
    pass


class StatusUnsupportedBinding(StatusError):
    pass


STATUSCODE2EXCEPTION = {
    STATUS_VERSION_MISMATCH: StatusVersionMismatch,
    STATUS_AUTHN_FAILED: StatusAuthnFailed,
    STATUS_INVALID_ATTR_NAME_OR_VALUE: StatusInvalidAttrNameOrValue,
    STATUS_INVALID_NAMEID_POLICY: StatusInvalidNameidPolicy,
    STATUS_NO_AUTHN_CONTEXT: StatusNoAuthnContext,
    STATUS_NO_AVAILABLE_IDP: StatusNoAvailableIdp,
    STATUS_NO_PASSIVE: StatusNoPassive,
    STATUS_NO_SUPPORTED_IDP: StatusNoSupportedIdp,
    STATUS_PARTIAL_LOGOUT: StatusPartialLogout,
    STATUS_PROXY_COUNT_EXCEEDED: StatusProxyCountExceeded,
    STATUS_REQUEST_DENIED: StatusRequestDenied,
    STATUS_REQUEST_UNSUPPORTED: StatusRequestUnsupported,
    STATUS_REQUEST_VERSION_DEPRECATED: StatusRequestVersionDeprecated,
    STATUS_REQUEST_VERSION_TOO_HIGH: StatusRequestVersionTooHigh,
    STATUS_REQUEST_VERSION_TOO_LOW: StatusRequestVersionTooLow,
    STATUS_RESOURCE_NOT_RECOGNIZED: StatusResourceNotRecognized,
    STATUS_TOO_MANY_RESPONSES: StatusTooManyResponses,
    STATUS_UNKNOWN_ATTR_PROFILE: StatusUnknownAttrProfile,
    STATUS_UNKNOWN_PRINCIPAL: StatusUnknownPrincipal,
    STATUS_UNSUPPORTED_BINDING: StatusUnsupportedBinding,
}
# ---------------------------------------------------------------------------


def _dummy(_):
    return None


def for_me(conditions, myself):
    """ Am I among the intended audiences """

    if not conditions.audience_restriction:  # No audience restriction
        return True

    for restriction in conditions.audience_restriction:
        if not restriction.audience:
            continue
        for audience in restriction.audience:
            if audience.text.strip() == myself:
                return True
            else:
                #print "Not for me: %s != %s" % (audience.text.strip(), myself)
                pass

    return False


def authn_response(conf, return_addrs, outstanding_queries=None, timeslack=0,
                   asynchop=True, allow_unsolicited=False,
                   want_assertions_signed=False):
    sec = security_context(conf)
    if not timeslack:
        try:
            timeslack = int(conf.accepted_time_diff)
        except TypeError:
            timeslack = 0

    return AuthnResponse(sec, conf.attribute_converters, conf.entityid,
                         return_addrs, outstanding_queries, timeslack,
                         asynchop=asynchop, allow_unsolicited=allow_unsolicited,
                         want_assertions_signed=want_assertions_signed)


# comes in over SOAP so synchronous
def attribute_response(conf, return_addrs, timeslack=0, asynchop=False,
                       test=False):
    sec = security_context(conf)
    if not timeslack:
        try:
            timeslack = int(conf.accepted_time_diff)
        except TypeError:
            timeslack = 0

    return AttributeResponse(sec, conf.attribute_converters, conf.entityid,
                             return_addrs, timeslack, asynchop=asynchop,
                             test=test)


class StatusResponse(object):
    msgtype = "status_response"

    def __init__(self, sec_context, return_addrs=None, timeslack=0,
                 request_id=0, asynchop=True):
        self.sec = sec_context
        self.return_addrs = return_addrs

        self.timeslack = timeslack
        self.request_id = request_id

        self.xmlstr = ""
        self.origxml = ""
        self.name_id = None
        self.response = None
        self.not_on_or_after = 0
        self.in_response_to = None
        self.signature_check = self.sec.correctly_signed_response
        self.require_signature = False
        self.require_response_signature = False
        self.not_signed = False
        self.asynchop = asynchop

    def _clear(self):
        self.xmlstr = ""
        self.name_id = None
        self.response = None
        self.not_on_or_after = 0

    def _postamble(self):
        if not self.response:
            logger.error("Response was not correctly signed")
            if self.xmlstr:
                logger.info(self.xmlstr)
            raise IncorrectlySigned()

        logger.debug("response: %s" % (self.response,))

        try:
            valid_instance(self.response)
        except NotValid as exc:
            logger.error("Not valid response: %s" % exc.args[0])
            self._clear()
            return self

        self.in_response_to = self.response.in_response_to
        return self

    def load_instance(self, instance):
        if signed(instance):
            # This will check signature on Assertion which is the default
            try:
                self.response = self.sec.check_signature(instance)
            except SignatureError:
                # The response as a whole might be signed or not
                self.response = self.sec.check_signature(
                    instance, samlp.NAMESPACE + ":Response")
        else:
            self.not_signed = True
            self.response = instance

        return self._postamble()

    def _loads(self, xmldata, decode=True, origxml=None):

        # own copy
        self.xmlstr = xmldata[:]
        logger.debug("xmlstr: %s" % (self.xmlstr,))
        if origxml:
            self.origxml = origxml
        else:
            self.origxml = self.xmlstr

        try:
            self.response = self.signature_check(
                xmldata, origdoc=origxml, must=self.require_signature,
                require_response_signature=self.require_response_signature)

        except TypeError:
            raise
        except SignatureError:
            raise
        except Exception as excp:
            logger.exception("EXCEPTION: %s", excp)
            raise

        #print "<", self.response

        return self._postamble()

    def status_ok(self):
        if self.response.status:
            status = self.response.status
            logger.info("status: %s" % (status,))
            if status.status_code.value != samlp.STATUS_SUCCESS:
                logger.info("Not successful operation: %s" % status)
                if status.status_code.status_code:
                    excep = STATUSCODE2EXCEPTION[
                        status.status_code.status_code.value]
                else:
                    excep = StatusError
                if status.status_message:
                    msg = status.status_message.text
                else:
                    try:
                        msg = status.status_code.status_code.value
                    except Exception:
                        msg = "Unknown error"
                raise excep(
                    "%s from %s" % (msg, status.status_code.value,))
        return True

    def issue_instant_ok(self):
        """ Check that the response was issued at a reasonable time """
        upper = time_util.shift_time(time_util.time_in_a_while(days=1),
                                     self.timeslack).timetuple()
        lower = time_util.shift_time(time_util.time_a_while_ago(days=1),
                                     -self.timeslack).timetuple()
        # print "issue_instant: %s" % self.response.issue_instant
        # print "%s < x < %s" % (lower, upper)
        issued_at = str_to_time(self.response.issue_instant)
        return lower < issued_at < upper

    def _verify(self):
        if self.request_id and self.in_response_to and \
                        self.in_response_to != self.request_id:
            logger.error("Not the id I expected: %s != %s" % (
                self.in_response_to, self.request_id))
            return None

        try:
            assert self.response.version == "2.0"
        except AssertionError:
            _ver = float(self.response.version)
            if _ver < 2.0:
                raise RequestVersionTooLow()
            else:
                raise RequestVersionTooHigh()

        if self.asynchop:
            if self.response.destination and \
                    self.response.destination not in self.return_addrs:
                logger.error("%s not in %s" % (self.response.destination,
                                               self.return_addrs))
                return None

        assert self.issue_instant_ok()
        assert self.status_ok()
        return self

    def loads(self, xmldata, decode=True, origxml=None):
        return self._loads(xmldata, decode, origxml)

    def verify(self, key_file=""):
        try:
            return self._verify()
        except AssertionError:
            logger.exception("verify")
            return None

    def update(self, mold):
        self.xmlstr = mold.xmlstr
        self.in_response_to = mold.in_response_to
        self.response = mold.response

    def issuer(self):
        return self.response.issuer.text.strip()


class LogoutResponse(StatusResponse):
    msgtype = "logout_response"

    def __init__(self, sec_context, return_addrs=None, timeslack=0,
                 asynchop=True):
        StatusResponse.__init__(self, sec_context, return_addrs, timeslack,
                                asynchop=asynchop)
        self.signature_check = self.sec.correctly_signed_logout_response


class NameIDMappingResponse(StatusResponse):
    msgtype = "name_id_mapping_response"

    def __init__(self, sec_context, return_addrs=None, timeslack=0,
                 request_id=0, asynchop=True):
        StatusResponse.__init__(self, sec_context, return_addrs, timeslack,
                                request_id, asynchop)
        self.signature_check = self.sec\
            .correctly_signed_name_id_mapping_response


class ManageNameIDResponse(StatusResponse):
    msgtype = "manage_name_id_response"

    def __init__(self, sec_context, return_addrs=None, timeslack=0,
                 request_id=0, asynchop=True):
        StatusResponse.__init__(self, sec_context, return_addrs, timeslack,
                                request_id, asynchop)
        self.signature_check = self.sec.correctly_signed_manage_name_id_response


# ----------------------------------------------------------------------------


class AuthnResponse(StatusResponse):
    """ This is where all the profile compliance is checked.
    This one does saml2int compliance. """
    msgtype = "authn_response"

    def __init__(self, sec_context, attribute_converters, entity_id,
                 return_addrs=None, outstanding_queries=None,
                 timeslack=0, asynchop=True, allow_unsolicited=False,
                 test=False, allow_unknown_attributes=False,
                 want_assertions_signed=False, want_response_signed=False,
                 **kwargs):

        StatusResponse.__init__(self, sec_context, return_addrs, timeslack,
                                asynchop=asynchop)
        self.entity_id = entity_id
        self.attribute_converters = attribute_converters
        if outstanding_queries:
            self.outstanding_queries = outstanding_queries
        else:
            self.outstanding_queries = {}
        self.context = "AuthnReq"
        self.came_from = ""
        self.ava = None
        self.assertion = None
        self.assertions = []
        self.session_not_on_or_after = 0
        self.allow_unsolicited = allow_unsolicited
        self.require_signature = want_assertions_signed
        self.require_response_signature = want_response_signed
        self.test = test
        self.allow_unknown_attributes = allow_unknown_attributes
        #
        try:
            self.extension_schema = kwargs["extension_schema"]
        except KeyError:
            self.extension_schema = {}

    def check_subject_confirmation_in_response_to(self, irp):
        for assertion in self.response.assertion:
            for _sc in assertion.subject.subject_confirmation:
                try:
                    assert _sc.subject_confirmation_data.in_response_to == irp
                except AssertionError:
                    return False

        return True

    def loads(self, xmldata, decode=True, origxml=None):
        self._loads(xmldata, decode, origxml)

        if self.asynchop:
            if self.in_response_to in self.outstanding_queries:
                self.came_from = self.outstanding_queries[self.in_response_to]
                del self.outstanding_queries[self.in_response_to]
                try:
                    if not self.check_subject_confirmation_in_response_to(
                            self.in_response_to):
                        logger.exception(
                            "Unsolicited response %s" % self.in_response_to)
                        raise UnsolicitedResponse(
                            "Unsolicited response: %s" % self.in_response_to)
                except AttributeError:
                    pass
            elif self.allow_unsolicited:
                pass
            else:
                logger.exception(
                    "Unsolicited response %s" % self.in_response_to)
                raise UnsolicitedResponse(
                    "Unsolicited response: %s" % self.in_response_to)

        return self

    def clear(self):
        self._clear()
        self.came_from = ""
        self.ava = None
        self.assertion = None

    def authn_statement_ok(self, optional=False):
        try:
            # the assertion MUST contain one AuthNStatement
            assert len(self.assertion.authn_statement) == 1
        except AssertionError:
            if optional:
                return True
            else:
                raise

        authn_statement = self.assertion.authn_statement[0]
        if authn_statement.session_not_on_or_after:
            if validate_on_or_after(authn_statement.session_not_on_or_after,
                                    self.timeslack):
                self.session_not_on_or_after = calendar.timegm(
                    time_util.str_to_time(
                        authn_statement.session_not_on_or_after))
            else:
                return False
        return True
        # check authn_statement.session_index

    def condition_ok(self, lax=False):
        if self.test:
            lax = True

        # The Identity Provider MUST include a <saml:Conditions> element
        assert self.assertion.conditions
        conditions = self.assertion.conditions

        logger.debug("conditions: %s" % conditions)

        # if no sub-elements or elements are supplied, then the
        # assertion is considered to be valid.
        if not conditions.keyswv():
            return True

        # if both are present NotBefore must be earlier than NotOnOrAfter
        if conditions.not_before and conditions.not_on_or_after:
            if not later_than(conditions.not_on_or_after,
                              conditions.not_before):
                return False

        try:
            if conditions.not_on_or_after:
                self.not_on_or_after = validate_on_or_after(
                    conditions.not_on_or_after, self.timeslack)
            if conditions.not_before:
                validate_before(conditions.not_before, self.timeslack)
        except Exception as excp:
            logger.error("Exception on conditions: %s" % (excp,))
            if not lax:
                raise
            else:
                self.not_on_or_after = 0

        if not self.allow_unsolicited:
            if not for_me(conditions, self.entity_id):
                if not lax:
                    raise Exception("Not for me!!!")

        if conditions.condition:  # extra conditions
            for cond in conditions.condition:
                try:
                    if cond.extension_attributes[
                        XSI_TYPE] in self.extension_schema:
                        pass
                    else:
                        raise Exception("Unknown condition")
                except KeyError:
                    raise Exception("Missing xsi:type specification")

        return True

    def decrypt_attributes(self, attribute_statement):
        """
        Decrypts possible encrypted attributes and adds the decrypts to the
        list of attributes.

        :param attribute_statement: A SAML.AttributeStatement which might
            contain both encrypted attributes and attributes.
        """
        #        _node_name = [
        #            "urn:oasis:names:tc:SAML:2.0:assertion:EncryptedData",
        #            "urn:oasis:names:tc:SAML:2.0:assertion:EncryptedAttribute"]

        for encattr in attribute_statement.encrypted_attribute:
            if not encattr.encrypted_key:
                _decr = self.sec.decrypt(encattr.encrypted_data)
                _attr = attribute_from_string(_decr)
                attribute_statement.attribute.append(_attr)
            else:
                _decr = self.sec.decrypt(encattr)
                enc_attr = encrypted_attribute_from_string(_decr)
                attrlist = enc_attr.extensions_as_elements("Attribute", saml)
                attribute_statement.attribute.extend(attrlist)

    def get_identity(self):
        """ The assertion can contain zero or one attributeStatements

        """
        if not self.assertion.attribute_statement:
            logger.error("Missing Attribute Statement")
            ava = {}
        else:
            assert len(self.assertion.attribute_statement) == 1
            _attr_statem = self.assertion.attribute_statement[0]

            logger.debug("Attribute Statement: %s" % (_attr_statem,))
            for aconv in self.attribute_converters:
                logger.debug("Converts name format: %s" % (aconv.name_format,))

            self.decrypt_attributes(_attr_statem)
            ava = to_local(self.attribute_converters, _attr_statem,
                           self.allow_unknown_attributes)
        return ava

    def _bearer_confirmed(self, data):
        if not data:
            return False

        if data.address:
            if not valid_address(data.address):
                return False
                # verify that I got it from the correct sender

        # These two will raise exception if untrue
        validate_on_or_after(data.not_on_or_after, self.timeslack)
        validate_before(data.not_before, self.timeslack)

        # not_before must be < not_on_or_after
        if not later_than(data.not_on_or_after, data.not_before):
            return False

        if self.asynchop and not self.came_from:
            if data.in_response_to:
                if data.in_response_to in self.outstanding_queries:
                    self.came_from = self.outstanding_queries[
                        data.in_response_to]
                    del self.outstanding_queries[data.in_response_to]
                elif self.allow_unsolicited:
                    pass
                else:
                    # This is where I don't allow unsolicited reponses
                    # Either in_response_to == None or has a value I don't
                    # recognize
                    logger.debug("in response to: '%s'" % data.in_response_to)
                    logger.info("outstanding queries: %s" % (
                        self.outstanding_queries.keys(),))
                    raise Exception(
                        "Combination of session id and requestURI I don't "
                        "recall")
        return True

    def _holder_of_key_confirmed(self, data):
        if not data:
            return False

        has_keyinfo = False
        for element in extension_elements_to_elements(data,
                                                      [samlp, saml, xenc, ds]):
            if isinstance(element, ds.KeyInfo):
                has_keyinfo = True

        return has_keyinfo

    def get_subject(self):
        """ The assertion must contain a Subject
        """
        assert self.assertion.subject
        subject = self.assertion.subject
        subjconf = []
        for subject_confirmation in subject.subject_confirmation:
            _data = subject_confirmation.subject_confirmation_data

            if subject_confirmation.method == SCM_BEARER:
                if not self._bearer_confirmed(_data):
                    continue
            elif subject_confirmation.method == SCM_HOLDER_OF_KEY:
                if not self._holder_of_key_confirmed(_data):
                    continue
            elif subject_confirmation.method == SCM_SENDER_VOUCHES:
                pass
            else:
                raise ValueError("Unknown subject confirmation method: %s" % (
                    subject_confirmation.method,))

            subjconf.append(subject_confirmation)

        if not subjconf:
            raise VerificationError("No valid subject confirmation")

        subject.subject_confirmation = subjconf

        # The subject must contain a name_id
        try:
            assert subject.name_id
            self.name_id = subject.name_id
        except AssertionError:
            if subject.encrypted_id:
                # decrypt encrypted ID
                _name_id_str = self.sec.decrypt(
                    subject.encrypted_id.encrypted_data.to_string())
                _name_id = saml.name_id_from_string(_name_id_str)
                self.name_id = _name_id
            else:
                raise VerificationError("Missing NameID")

        logger.info("Subject NameID: %s" % self.name_id)
        return self.name_id

    def _assertion(self, assertion):
        """
        Check the assertion
        :param assertion:
        :return: True/False depending on if the assertion is sane or not
        """

        if not hasattr(assertion, 'signature') or not assertion.signature:
            logger.debug("unsigned")
            if self.require_signature:
                raise SignatureError("Signature missing for assertion")
        else:
            logger.debug("signed")

            try:
                self.sec.check_signature(assertion, class_name(assertion),
                                         self.xmlstr)
            except Exception as exc:
                logger.error("correctly_signed_response: %s" % exc)
                raise

        self.assertion = assertion
        logger.debug("assertion context: %s" % (self.context,))
        logger.debug("assertion keys: %s" % (assertion.keyswv()))
        logger.debug("outstanding_queries: %s" % (self.outstanding_queries,))

        #if self.context == "AuthnReq" or self.context == "AttrQuery":
        if self.context == "AuthnReq":
            self.authn_statement_ok()
        #        elif self.context == "AttrQuery":
        #            self.authn_statement_ok(True)

        if not self.condition_ok():
            raise VerificationError("Condition not OK")

        logger.debug("--- Getting Identity ---")

        if self.context == "AuthnReq" or self.context == "AttrQuery":
            self.ava = self.get_identity()

            logger.debug("--- AVA: %s" % (self.ava,))

        try:
            self.get_subject()
            if self.asynchop:
                if self.allow_unsolicited:
                    pass
                elif not self.came_from:
                    raise VerificationError("Came from")
            return True
        except Exception:
            logger.exception("get subject")
            raise

    def decrypt_assertions(self, encrypted_assertions, key_file=""):
        res = []
        for encrypted_assertion in encrypted_assertions:
            if encrypted_assertion.extension_elements:
                assertions = extension_elements_to_elements(
                    encrypted_assertion.extension_elements, [saml, samlp])
                for assertion in assertions:
                    if assertion.signature:
                        if not self.sec.verify_signature(
                                "%s" % assertion, key_file,
                                node_name=class_name(assertion)):
                            logger.error(
                                "Failed to verify signature on '%s'" % assertion)
                            raise SignatureError()
                    res.append(assertion)
        return res

    def parse_assertion(self, key_file=""):
        if self.context == "AuthnQuery":
            # can contain one or more assertions
            pass
        else:  # This is a saml2int limitation
            try:
                assert len(self.response.assertion) == 1 or \
                    len(self.response.encrypted_assertion) == 1
            except AssertionError:
                raise Exception("No assertion part")

        if self.response.encrypted_assertion:
            logger.debug("***Encrypted assertion/-s***")
            decr_text = self.sec.decrypt(self.xmlstr, key_file)
            resp = samlp.response_from_string(decr_text)
            res = self.decrypt_assertions(resp.encrypted_assertion, key_file)
            if self.response.assertion:
                self.response.assertion.extend(res)
            else:
                self.response.assertion = res
            self.response.encrypted_assertion = []

        if self.response.assertion:
            logger.debug("***Unencrypted assertion***")
            for assertion in self.response.assertion:
                if not self._assertion(assertion):
                    return False
                else:
                    self.assertions.append(assertion)
            self.assertion = self.assertions[0]

        return True

    def verify(self, key_file=""):
        """ Verify that the assertion is syntactically correct and
        the signature is correct if present.
        :param key_file: If not the default key file should be used this is it.
        """

        try:
            self._verify()
        except AssertionError:
            raise

        if not isinstance(self.response, samlp.Response):
            return self

        if self.parse_assertion(key_file):
            return self
        else:
            logger.error("Could not parse the assertion")
            return None

    def session_id(self):
        """ Returns the SessionID of the response """
        return self.response.in_response_to

    def id(self):
        """ Return the ID of the response """
        return self.response.id

    def authn_info(self):
        res = []
        for astat in self.assertion.authn_statement:
            context = astat.authn_context
            if context:
                try:
                    aclass = context.authn_context_class_ref.text
                except AttributeError:
                    aclass = ""
                try:
                    authn_auth = [a.text for a in
                                  context.authenticating_authority]
                except AttributeError:
                    authn_auth = []
                res.append((aclass, authn_auth))
        return res

    def authz_decision_info(self):
        res = {"permit": [], "deny": [], "indeterminate": []}
        for adstat in self.assertion.authz_decision_statement:
            # one of 'Permit', 'Deny', 'Indeterminate'
            res[adstat.decision.text.lower()] = adstat
        return res

    def session_info(self):
        """ Returns a predefined set of information gleened from the 
        response.
        :returns: Dictionary with information
        """
        if self.session_not_on_or_after > 0:
            nooa = self.session_not_on_or_after
        else:
            nooa = self.not_on_or_after

        if self.context == "AuthzQuery":
            return {"name_id": self.name_id, "came_from": self.came_from,
                    "issuer": self.issuer(), "not_on_or_after": nooa,
                    "authz_decision_info": self.authz_decision_info()}
        else:
            return {"ava": self.ava, "name_id": self.name_id,
                    "came_from": self.came_from, "issuer": self.issuer(),
                    "not_on_or_after": nooa, "authn_info": self.authn_info()}

    def __str__(self):
        return "%s" % self.xmlstr

    def verify_attesting_entity(self, address):
        """
        Assumes one assertion. At least one address specification has to be
        correct.

        :param address: IP address of attesting entity
        :return: True/False
        """

        correct = 0
        for subject_conf in self.assertion.subject.subject_confirmation:
            if subject_conf.subject_confirmation_data is None:
                correct += 1  # In reality undefined
            elif subject_conf.subject_confirmation_data.address:
                if subject_conf.subject_confirmation_data.address == address:
                    correct += 1
            else:
                correct += 1

        if correct:
            return True
        else:
            return False


class AuthnQueryResponse(AuthnResponse):
    msgtype = "authn_query_response"

    def __init__(self, sec_context, attribute_converters, entity_id,
                 return_addrs=None, timeslack=0, asynchop=False, test=False):
        AuthnResponse.__init__(self, sec_context, attribute_converters,
                               entity_id, return_addrs, timeslack=timeslack,
                               asynchop=asynchop, test=test)
        self.entity_id = entity_id
        self.attribute_converters = attribute_converters
        self.assertion = None
        self.context = "AuthnQuery"

    def condition_ok(self, lax=False):  # Should I care about conditions ?
        return True


class AttributeResponse(AuthnResponse):
    msgtype = "attribute_response"

    def __init__(self, sec_context, attribute_converters, entity_id,
                 return_addrs=None, timeslack=0, asynchop=False, test=False):
        AuthnResponse.__init__(self, sec_context, attribute_converters,
                               entity_id, return_addrs, timeslack=timeslack,
                               asynchop=asynchop, test=test)
        self.entity_id = entity_id
        self.attribute_converters = attribute_converters
        self.assertion = None
        self.context = "AttrQuery"


class AuthzResponse(AuthnResponse):
    """ A successful response will be in the form of assertions containing
    authorization decision statements."""
    msgtype = "authz_decision_response"

    def __init__(self, sec_context, attribute_converters, entity_id,
                 return_addrs=None, timeslack=0, asynchop=False):
        AuthnResponse.__init__(self, sec_context, attribute_converters,
                               entity_id, return_addrs, timeslack=timeslack,
                               asynchop=asynchop)
        self.entity_id = entity_id
        self.attribute_converters = attribute_converters
        self.assertion = None
        self.context = "AuthzQuery"


class ArtifactResponse(AuthnResponse):
    msgtype = "artifact_response"

    def __init__(self, sec_context, attribute_converters, entity_id,
                 return_addrs=None, timeslack=0, asynchop=False, test=False):
        AuthnResponse.__init__(self, sec_context, attribute_converters,
                               entity_id, return_addrs, timeslack=timeslack,
                               asynchop=asynchop, test=test)
        self.entity_id = entity_id
        self.attribute_converters = attribute_converters
        self.assertion = None
        self.context = "ArtifactResolve"


def response_factory(xmlstr, conf, return_addrs=None, outstanding_queries=None,
                     timeslack=0, decode=True, request_id=0, origxml=None,
                     asynchop=True, allow_unsolicited=False,
                     want_assertions_signed=False):
    sec_context = security_context(conf)
    if not timeslack:
        try:
            timeslack = int(conf.accepted_time_diff)
        except TypeError:
            timeslack = 0

    attribute_converters = conf.attribute_converters
    entity_id = conf.entityid
    extension_schema = conf.extension_schema

    response = StatusResponse(sec_context, return_addrs, timeslack, request_id,
                              asynchop)
    try:
        response.loads(xmlstr, decode, origxml)
        if response.response.assertion or response.response.encrypted_assertion:
            authnresp = AuthnResponse(sec_context, attribute_converters,
                                      entity_id, return_addrs,
                                      outstanding_queries, timeslack, asynchop,
                                      allow_unsolicited,
                                      extension_schema=extension_schema,
                                      want_assertions_signed=want_assertions_signed)
            authnresp.update(response)
            return authnresp
    except TypeError:
        response.signature_check = sec_context.correctly_signed_logout_response
        response.loads(xmlstr, decode, origxml)
        logoutresp = LogoutResponse(sec_context, return_addrs, timeslack,
                                    asynchop=asynchop)
        logoutresp.update(response)
        return logoutresp

    return response


# ===========================================================================
# A class of it's own


class AssertionIDResponse(object):
    msgtype = "assertion_id_response"

    def __init__(self, sec_context, attribute_converters, timeslack=0,
                 **kwargs):

        self.sec = sec_context
        self.timeslack = timeslack
        self.xmlstr = ""
        self.origxml = ""
        self.name_id = ""
        self.response = None
        self.not_signed = False
        self.attribute_converters = attribute_converters
        self.assertion = None
        self.context = "AssertionIdResponse"
        self.signature_check = self.sec.correctly_signed_assertion_id_response

    def loads(self, xmldata, decode=True, origxml=None):
        # own copy
        self.xmlstr = xmldata[:]
        logger.debug("xmlstr: %s" % (self.xmlstr,))
        self.origxml = origxml

        try:
            self.response = self.signature_check(xmldata, origdoc=origxml)
            self.assertion = self.response
        except TypeError:
            raise
        except SignatureError:
            raise
        except Exception as excp:
            logger.exception("EXCEPTION: %s", excp)
            raise

        #print "<", self.response

        return self._postamble()

    def verify(self, key_file=""):
        try:
            valid_instance(self.response)
        except NotValid as exc:
            logger.error("Not valid response: %s" % exc.args[0])
            raise
        return self

    def _postamble(self):
        if not self.response:
            logger.error("Response was not correctly signed")
            if self.xmlstr:
                logger.info(self.xmlstr)
            raise IncorrectlySigned()

        logger.debug("response: %s" % (self.response,))

        return self


########NEW FILE########
__FILENAME__ = saml
#!/usr/bin/env python

#
# Generated Mon May  2 14:23:33 2011 by parse_xsd.py version 0.4.
#
from saml2.validate import valid_ipv4, MustValueError
from saml2.validate import valid_ipv6
from saml2.validate import ShouldValueError
from saml2.validate import valid_domain_name

import saml2
from saml2 import SamlBase

import xmldsig as ds
import xmlenc as xenc

NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:assertion'

XSI_NAMESPACE = 'http://www.w3.org/2001/XMLSchema-instance'
XS_NAMESPACE = 'http://www.w3.org/2001/XMLSchema'

XSI_TYPE = '{%s}type' % XSI_NAMESPACE
XSI_NIL = '{%s}nil' % XSI_NAMESPACE

NAMEID_FORMAT_EMAILADDRESS = (
    "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress")
#NAMEID_FORMAT_UNSPECIFIED1 = (
#    "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified")
NAMEID_FORMAT_UNSPECIFIED = (
    "urn:oasis:names:tc:SAML:2.0:nameid-format:unspecified")
NAMEID_FORMAT_ENCRYPTED = (
    "urn:oasis:names:tc:SAML:2.0:nameid-format:encrypted")
NAMEID_FORMAT_PERSISTENT = (
    "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent")
NAMEID_FORMAT_TRANSIENT = (
    "urn:oasis:names:tc:SAML:2.0:nameid-format:transient")
NAMEID_FORMAT_ENTITY = (
    "urn:oasis:names:tc:SAML:2.0:nameid-format:entity")

PROFILE_ATTRIBUTE_BASIC = (
    "urn:oasis:names:tc:SAML:2.0:profiles:attribute:basic")

AUTHN_PASSWORD = "urn:oasis:names:tc:SAML:2.0:ac:classes:Password"
AUTHN_PASSWORD_PROTECTED = \
    "urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport"

NAME_FORMAT_UNSPECIFIED = (
    "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified")
NAME_FORMAT_URI = "urn:oasis:names:tc:SAML:2.0:attrname-format:uri"
NAME_FORMAT_BASIC = "urn:oasis:names:tc:SAML:2.0:attrname-format:basic"

DECISION_TYPE_PERMIT = "Permit"
DECISION_TYPE_DENY = "Deny"
DECISION_TYPE_INDETERMINATE = "Indeterminate"

CONSENT_UNSPECIFIED = "urn:oasis:names:tc:SAML:2.0:consent:unspecified"
CONSENT_OBTAINED = "urn:oasis:names:tc:SAML:2.0:consent:obtained"
CONSENT_PRIOR = "urn:oasis:names:tc:SAML:2.0:consent:prior"
CONSENT_IMPLICIT = "urn:oasis:names:tc:SAML:2.0:consent:current-implicit"
CONSENT_EXPLICIT = "urn:oasis:names:tc:SAML:2.0:consent:current-explicit"
CONSENT_UNAVAILABLE = "urn:oasis:names:tc:SAML:2.0:consent:unavailable"
CONSENT_INAPPLICABLE = "urn:oasis:names:tc:SAML:2.0:consent:inapplicable"

SCM_HOLDER_OF_KEY = "urn:oasis:names:tc:SAML:2.0:cm:holder-of-key"
SCM_SENDER_VOUCHES = "urn:oasis:names:tc:SAML:2.0:cm:sender-vouches"
SCM_BEARER = "urn:oasis:names:tc:SAML:2.0:cm:bearer"

# -----------------------------------------------------------------------------
XSD = "xs:"
NS_SOAP_ENC = "http://schemas.xmlsoap.org/soap/encoding/"

# -----------------------------------------------------------------------------


def _decode_attribute_value(typ, text):
    if typ == XSD + "string":
        return text or ""
    if typ == XSD + "integer" or typ == XSD + "int":
        return str(int(text))
    if typ == XSD + "float" or typ == XSD + "double":
        return str(float(text))
    if typ == XSD + "boolean":
        return "%s" % (text == "true" or text == "True")
    if typ == XSD + "base64Binary":
        import base64

        return base64.decodestring(text)
    raise ValueError("type %s not supported" % type)


def _verify_value_type(typ, val):
    #print "verify value type: %s, %s" % (typ, val)
    if typ == XSD + "string":
        try:
            return str(val)
        except UnicodeEncodeError:
            return unicode(val)
    if typ == XSD + "integer" or typ == XSD + "int":
        return int(val)
    if typ == XSD + "float" or typ == XSD + "double":
        return float(val)
    if typ == XSD + "boolean":
        if val.lower() == "true" or val.lower() == "false":
            pass
        else:
            raise ValueError("Faulty boolean value")
    if typ == XSD + "base64Binary":
        import base64

        return base64.decodestring(val)


class AttributeValueBase(SamlBase):
    def __init__(self,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        self._extatt = {}

        SamlBase.__init__(self,
                          text=None,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        if self._extatt:
            self.extension_attributes = self._extatt

        if not text:
            self.extension_attributes = {XSI_NIL: 'true'}
        else:
            self.set_text(text)

    def __setattr__(self, key, value):
        if key == "text":
            self.set_text(value)
        else:
            SamlBase.__setattr__(self, key, value)

    def verify(self):
        if not self.text:
            assert self.extension_attributes
            assert self.extension_attributes[XSI_NIL] == "true"
            return True
        else:
            SamlBase.verify(self)

    def set_type(self, typ):
        try:
            del self.extension_attributes[XSI_NIL]
        except KeyError:
            pass

        try:
            self.extension_attributes[XSI_TYPE] = typ
        except AttributeError:
            self._extatt[XSI_TYPE] = typ

    def get_type(self):
        try:
            return self.extension_attributes[XSI_TYPE]
        except (KeyError, AttributeError):
            try:
                return self._extatt[XSI_TYPE]
            except KeyError:
                return ""

    def clear_type(self):
        try:
            del self.extension_attributes[XSI_TYPE]
        except KeyError:
            pass
        try:
            del self._extatt[XSI_TYPE]
        except KeyError:
            pass

    def set_text(self, val, base64encode=False):
        typ = self.get_type()
        if base64encode:
            import base64

            val = base64.encodestring(val)
            self.set_type("xs:base64Binary")
        else:
            if isinstance(val, basestring):
                if not typ:
                    self.set_type("xs:string")
                else:
                    try:
                        assert typ == "xs:string"
                    except AssertionError:
                        if typ == "xs:int":
                            _ = int(val)
                        elif typ == "xs:boolean":
                            if val.lower() not in ["true", "false"]:
                                raise ValueError("Not a boolean")
                        elif typ == "xs:float":
                            _ = float(val)
                        elif typ == "xs:base64Binary":
                            pass
                        else:
                            ValueError("Type and value doesn't match")
            elif isinstance(val, bool):
                if val:
                    val = "true"
                else:
                    val = "false"
                if not typ:
                    self.set_type("xs:boolean")
                else:
                    assert typ == "xs:boolean"
            elif isinstance(val, int):
                val = str(val)
                if not typ:
                    self.set_type("xs:integer")
                else:
                    assert typ == "xs:integer"
            elif isinstance(val, float):
                val = str(val)
                if not typ:
                    self.set_type("xs:float")
                else:
                    assert typ == "xs:float"
            elif not val:
                try:
                    self.extension_attributes[XSI_TYPE] = typ
                except AttributeError:
                    self._extatt[XSI_TYPE] = typ
                val = ""
            else:
                if typ == "xs:anyType":
                    pass
                else:
                    raise ValueError

        SamlBase.__setattr__(self, "text", val)
        return self

    def harvest_element_tree(self, tree):
        # Fill in the instance members from the contents of the XML tree.
        for child in tree:
            self._convert_element_tree_to_member(child)
        for attribute, value in tree.attrib.iteritems():
            self._convert_element_attribute_to_member(attribute, value)
        if tree.text:
            #print "set_text:", tree.text
            # clear type
            #self.clear_type()
            self.set_text(tree.text)
            if XSI_NIL in self.extension_attributes:
                del self.extension_attributes[XSI_NIL]
            try:
                typ = self.extension_attributes[XSI_TYPE]
                _verify_value_type(typ, getattr(self, "text"))
            except KeyError:
                pass


class BaseIDAbstractType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:BaseIDAbstractType element """

    c_tag = 'BaseIDAbstractType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['NameQualifier'] = ('name_qualifier', 'string', False)
    c_attributes['SPNameQualifier'] = ('sp_name_qualifier', 'string', False)

    def __init__(self,
                 name_qualifier=None,
                 sp_name_qualifier=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.name_qualifier = name_qualifier
        self.sp_name_qualifier = sp_name_qualifier


class NameIDType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:NameIDType element """

    c_tag = 'NameIDType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['NameQualifier'] = ('name_qualifier', 'string', False)
    c_attributes['SPNameQualifier'] = ('sp_name_qualifier', 'string', False)
    c_attributes['Format'] = ('format', 'anyURI', False)
    c_attributes['SPProvidedID'] = ('sp_provided_id', 'string', False)

    def __init__(self,
                 name_qualifier=None,
                 sp_name_qualifier=None,
                 format=None,
                 sp_provided_id=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.name_qualifier = name_qualifier
        self.sp_name_qualifier = sp_name_qualifier
        self.format = format
        self.sp_provided_id = sp_provided_id


def name_id_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDType_, xml_string)


class EncryptedElementType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:EncryptedElementType element
    """

    c_tag = 'EncryptedElementType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2001/04/xmlenc#}EncryptedData'] = (
        'encrypted_data',
        xenc.EncryptedData)
    c_children['{http://www.w3.org/2001/04/xmlenc#}EncryptedKey'] = (
        'encrypted_key',
        [xenc.EncryptedKey])
    c_cardinality['encrypted_key'] = {"min": 0}
    c_child_order.extend(['encrypted_data', 'encrypted_key'])

    def __init__(self,
                 encrypted_data=None,
                 encrypted_key=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.encrypted_data = encrypted_data
        self.encrypted_key = encrypted_key or []


def encrypted_element_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(EncryptedElementType_, xml_string)


class EncryptedID(EncryptedElementType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:EncryptedID element """

    c_tag = 'EncryptedID'
    c_namespace = NAMESPACE
    c_children = EncryptedElementType_.c_children.copy()
    c_attributes = EncryptedElementType_.c_attributes.copy()
    c_child_order = EncryptedElementType_.c_child_order[:]
    c_cardinality = EncryptedElementType_.c_cardinality.copy()


def encrypted_id_from_string(xml_string):
    return saml2.create_class_from_xml_string(EncryptedID, xml_string)


class Issuer(NameIDType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Issuer element """

    c_tag = 'Issuer'
    c_namespace = NAMESPACE
    c_children = NameIDType_.c_children.copy()
    c_attributes = NameIDType_.c_attributes.copy()
    c_child_order = NameIDType_.c_child_order[:]
    c_cardinality = NameIDType_.c_cardinality.copy()


def issuer_from_string(xml_string):
    return saml2.create_class_from_xml_string(Issuer, xml_string)


class AssertionIDRef(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AssertionIDRef element """

    c_tag = 'AssertionIDRef'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'NCName'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def assertion_id_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(AssertionIDRef, xml_string)


class AssertionURIRef(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AssertionURIRef element """

    c_tag = 'AssertionURIRef'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def assertion_uri_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(AssertionURIRef, xml_string)


class SubjectConfirmationDataType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmationDataType
    element """

    c_tag = 'SubjectConfirmationDataType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['NotBefore'] = ('not_before', 'AsTime', False)
    c_attributes['NotOnOrAfter'] = ('not_on_or_after', 'dateTime', False)
    c_attributes['Recipient'] = ('recipient', 'anyURI', False)
    c_attributes['InResponseTo'] = ('in_response_to', 'NCName', False)
    c_attributes['Address'] = ('address', 'string', False)
    c_any = {"namespace": "##any", "processContents": "lax", "minOccurs": "0",
             "maxOccurs": "unbounded"}
    c_any_attribute = {"namespace": "##other", "processContents": "lax"}

    def __init__(self,
                 not_before=None,
                 not_on_or_after=None,
                 recipient=None,
                 in_response_to=None,
                 address=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.not_before = not_before
        self.not_on_or_after = not_on_or_after
        self.recipient = recipient
        self.in_response_to = in_response_to
        self.address = address


def subject_confirmation_data_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SubjectConfirmationDataType_,
                                              xml_string)


class KeyInfoConfirmationDataType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:KeyInfoConfirmationDataType
    element """

    c_tag = 'KeyInfoConfirmationDataType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://www.w3.org/2000/09/xmldsig#}KeyInfo'] = ('key_info',
                                                                 [ds.KeyInfo])
    c_cardinality['key_info'] = {"min": 1}
    c_child_order.extend(['key_info'])

    def __init__(self,
                 key_info=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.key_info = key_info or []


def key_info_confirmation_data_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(KeyInfoConfirmationDataType_,
                                              xml_string)


class ConditionAbstractType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:ConditionAbstractType
    element """

    c_tag = 'ConditionAbstractType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


class Audience(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Audience element """

    c_tag = 'Audience'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def audience_from_string(xml_string):
    return saml2.create_class_from_xml_string(Audience, xml_string)


class OneTimeUseType_(ConditionAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:OneTimeUseType element """

    c_tag = 'OneTimeUseType'
    c_namespace = NAMESPACE
    c_children = ConditionAbstractType_.c_children.copy()
    c_attributes = ConditionAbstractType_.c_attributes.copy()
    c_child_order = ConditionAbstractType_.c_child_order[:]
    c_cardinality = ConditionAbstractType_.c_cardinality.copy()


def one_time_use_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(OneTimeUseType_, xml_string)


class ProxyRestrictionType_(ConditionAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:ProxyRestrictionType element
    """

    c_tag = 'ProxyRestrictionType'
    c_namespace = NAMESPACE
    c_children = ConditionAbstractType_.c_children.copy()
    c_attributes = ConditionAbstractType_.c_attributes.copy()
    c_child_order = ConditionAbstractType_.c_child_order[:]
    c_cardinality = ConditionAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Audience'] = ('audience',
                                                                     [Audience])
    c_cardinality['audience'] = {"min": 0}
    c_attributes['Count'] = ('count', 'nonNegativeInteger', False)
    c_child_order.extend(['audience'])

    def __init__(self,
                 audience=None,
                 count=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        ConditionAbstractType_.__init__(
            self, text=text, extension_elements=extension_elements,
            extension_attributes=extension_attributes)
        self.audience = audience or []
        self.count = count


def proxy_restriction_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ProxyRestrictionType_, xml_string)


class EncryptedAssertion(EncryptedElementType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:EncryptedAssertion element """

    c_tag = 'EncryptedAssertion'
    c_namespace = NAMESPACE
    c_children = EncryptedElementType_.c_children.copy()
    c_attributes = EncryptedElementType_.c_attributes.copy()
    c_child_order = EncryptedElementType_.c_child_order[:]
    c_cardinality = EncryptedElementType_.c_cardinality.copy()


def encrypted_assertion_from_string(xml_string):
    return saml2.create_class_from_xml_string(EncryptedAssertion, xml_string)


class StatementAbstractType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:StatementAbstractType element
    """

    c_tag = 'StatementAbstractType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


class SubjectLocalityType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:SubjectLocalityType element """

    c_tag = 'SubjectLocalityType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['Address'] = ('address', 'string', False)
    c_attributes['DNSName'] = ('dns_name', 'string', False)

    def __init__(self,
                 address=None,
                 dns_name=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.address = address
        self.dns_name = dns_name


def subject_locality_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SubjectLocalityType_, xml_string)


class AuthnContextClassRef(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthnContextClassRef element
    """

    c_tag = 'AuthnContextClassRef'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def authn_context_class_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextClassRef, xml_string)


class AuthnContextDeclRef(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthnContextDeclRef element """

    c_tag = 'AuthnContextDeclRef'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def authn_context_decl_ref_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextDeclRef, xml_string)


class AuthnContextDecl(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthnContextDecl element """

    c_tag = 'AuthnContextDecl'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyType'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def authn_context_decl_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextDecl, xml_string)


class AuthenticatingAuthority(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthenticatingAuthority
    element """

    c_tag = 'AuthenticatingAuthority'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def authenticating_authority_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthenticatingAuthority,
                                              xml_string)


class DecisionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:DecisionType element """

    c_tag = 'DecisionType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string', 'enumeration': ['Permit', 'Deny',
                                                      'Indeterminate']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def decision_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(DecisionType_, xml_string)


class ActionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:ActionType element """

    c_tag = 'ActionType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['Namespace'] = ('namespace', 'anyURI', True)

    def __init__(self,
                 namespace=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.namespace = namespace


def action_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ActionType_, xml_string)


class AttributeValue(AttributeValueBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AttributeValue element """

    c_tag = 'AttributeValue'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyType'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def attribute_value_from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeValue, xml_string)


class EncryptedAttribute(EncryptedElementType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:EncryptedAttribute element """

    c_tag = 'EncryptedAttribute'
    c_namespace = NAMESPACE
    c_children = EncryptedElementType_.c_children.copy()
    c_attributes = EncryptedElementType_.c_attributes.copy()
    c_child_order = EncryptedElementType_.c_child_order[:]
    c_cardinality = EncryptedElementType_.c_cardinality.copy()


def encrypted_attribute_from_string(xml_string):
    return saml2.create_class_from_xml_string(EncryptedAttribute, xml_string)


class BaseID(BaseIDAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:BaseID element """

    c_tag = 'BaseID'
    c_namespace = NAMESPACE
    c_children = BaseIDAbstractType_.c_children.copy()
    c_attributes = BaseIDAbstractType_.c_attributes.copy()
    c_child_order = BaseIDAbstractType_.c_child_order[:]
    c_cardinality = BaseIDAbstractType_.c_cardinality.copy()


def base_id_from_string(xml_string):
    return saml2.create_class_from_xml_string(BaseID, xml_string)


class NameID(NameIDType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:NameID element """

    c_tag = 'NameID'
    c_namespace = NAMESPACE
    c_children = NameIDType_.c_children.copy()
    c_attributes = NameIDType_.c_attributes.copy()
    c_child_order = NameIDType_.c_child_order[:]
    c_cardinality = NameIDType_.c_cardinality.copy()


def name_id_from_string(xml_string):
    return saml2.create_class_from_xml_string(NameID, xml_string)


class SubjectConfirmationData(SubjectConfirmationDataType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmationData
    element """

    c_tag = 'SubjectConfirmationData'
    c_namespace = NAMESPACE
    c_children = SubjectConfirmationDataType_.c_children.copy()
    c_attributes = SubjectConfirmationDataType_.c_attributes.copy()
    c_child_order = SubjectConfirmationDataType_.c_child_order[:]
    c_cardinality = SubjectConfirmationDataType_.c_cardinality.copy()


def subject_confirmation_data_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubjectConfirmationData,
                                              xml_string)


class Condition(ConditionAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Condition element """

    c_tag = 'Condition'
    c_namespace = NAMESPACE
    c_children = ConditionAbstractType_.c_children.copy()
    c_attributes = ConditionAbstractType_.c_attributes.copy()
    c_child_order = ConditionAbstractType_.c_child_order[:]
    c_cardinality = ConditionAbstractType_.c_cardinality.copy()


def condition_from_string(xml_string):
    return saml2.create_class_from_xml_string(Condition, xml_string)


class AudienceRestrictionType_(ConditionAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AudienceRestrictionType
    element """

    c_tag = 'AudienceRestrictionType'
    c_namespace = NAMESPACE
    c_children = ConditionAbstractType_.c_children.copy()
    c_attributes = ConditionAbstractType_.c_attributes.copy()
    c_child_order = ConditionAbstractType_.c_child_order[:]
    c_cardinality = ConditionAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Audience'] = ('audience',
                                                                     [Audience])
    c_cardinality['audience'] = {"min": 1}
    c_child_order.extend(['audience'])

    def __init__(self,
                 audience=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        ConditionAbstractType_.__init__(
            self, text=text, extension_elements=extension_elements,
            extension_attributes=extension_attributes)
        self.audience = audience or []


def audience_restriction_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AudienceRestrictionType_,
                                              xml_string)


class OneTimeUse(OneTimeUseType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:OneTimeUse element """

    c_tag = 'OneTimeUse'
    c_namespace = NAMESPACE
    c_children = OneTimeUseType_.c_children.copy()
    c_attributes = OneTimeUseType_.c_attributes.copy()
    c_child_order = OneTimeUseType_.c_child_order[:]
    c_cardinality = OneTimeUseType_.c_cardinality.copy()


def one_time_use_from_string(xml_string):
    return saml2.create_class_from_xml_string(OneTimeUse, xml_string)


class ProxyRestriction(ProxyRestrictionType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:ProxyRestriction element """

    c_tag = 'ProxyRestriction'
    c_namespace = NAMESPACE
    c_children = ProxyRestrictionType_.c_children.copy()
    c_attributes = ProxyRestrictionType_.c_attributes.copy()
    c_child_order = ProxyRestrictionType_.c_child_order[:]
    c_cardinality = ProxyRestrictionType_.c_cardinality.copy()


def proxy_restriction_from_string(xml_string):
    return saml2.create_class_from_xml_string(ProxyRestriction, xml_string)


class Statement(StatementAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Statement element """

    c_tag = 'Statement'
    c_namespace = NAMESPACE
    c_children = StatementAbstractType_.c_children.copy()
    c_attributes = StatementAbstractType_.c_attributes.copy()
    c_child_order = StatementAbstractType_.c_child_order[:]
    c_cardinality = StatementAbstractType_.c_cardinality.copy()


def statement_from_string(xml_string):
    return saml2.create_class_from_xml_string(Statement, xml_string)


class SubjectLocality(SubjectLocalityType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:SubjectLocality element """

    c_tag = 'SubjectLocality'
    c_namespace = NAMESPACE
    c_children = SubjectLocalityType_.c_children.copy()
    c_attributes = SubjectLocalityType_.c_attributes.copy()
    c_child_order = SubjectLocalityType_.c_child_order[:]
    c_cardinality = SubjectLocalityType_.c_cardinality.copy()

    def verify(self):
        if self.address:
            # dotted-decimal IPv4 or RFC3513 IPv6 address
            if valid_ipv4(self.address) or valid_ipv6(self.address):
                pass
            else:
                raise ShouldValueError("Not an IPv4 or IPv6 address")
        elif self.dns_name:
            valid_domain_name(self.dns_name)

        return SubjectLocalityType_.verify(self)


def subject_locality_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubjectLocality, xml_string)


class AuthnContextType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthnContextType element """

    c_tag = 'AuthnContextType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:assertion}AuthnContextClassRef'] = (
            'authn_context_class_ref', AuthnContextClassRef)
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AuthnContextDecl'] = (
        'authn_context_decl',
        AuthnContextDecl)
    c_cardinality['authn_context_decl'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AuthnContextDeclRef'] = (
        'authn_context_decl_ref',
        AuthnContextDeclRef)
    c_cardinality['authn_context_decl_ref'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:assertion}AuthenticatingAuthority'] = (
            'authenticating_authority', [AuthenticatingAuthority])
    c_cardinality['authenticating_authority'] = {"min": 0}
    c_child_order.extend(['authn_context_class_ref', 'authn_context_decl',
                          'authn_context_decl_ref', 'authenticating_authority'])

    def __init__(self,
                 authn_context_class_ref=None,
                 authn_context_decl=None,
                 authn_context_decl_ref=None,
                 authenticating_authority=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.authn_context_class_ref = authn_context_class_ref
        self.authn_context_decl = authn_context_decl
        self.authn_context_decl_ref = authn_context_decl_ref
        self.authenticating_authority = authenticating_authority or []

    def verify(self):
        # either <AuthnContextDecl> or <AuthnContextDeclRef> not both
        if self.authn_context_decl:
            assert self.authn_context_decl_ref is None
        elif self.authn_context_decl_ref:
            assert self.authn_context_decl is None

        return SamlBase.verify(self)


def authn_context_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextType_, xml_string)


class Action(ActionType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Action element """

    c_tag = 'Action'
    c_namespace = NAMESPACE
    c_children = ActionType_.c_children.copy()
    c_attributes = ActionType_.c_attributes.copy()
    c_child_order = ActionType_.c_child_order[:]
    c_cardinality = ActionType_.c_cardinality.copy()


def action_from_string(xml_string):
    return saml2.create_class_from_xml_string(Action, xml_string)


class AttributeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AttributeType element """

    c_tag = 'AttributeType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AttributeValue'] = (
        'attribute_value',
        [AttributeValue])
    c_cardinality['attribute_value'] = {"min": 0}
    c_attributes['Name'] = ('name', 'string', True)
    c_attributes['NameFormat'] = ('name_format', 'anyURI', False)
    c_attributes['FriendlyName'] = ('friendly_name', 'string', False)
    c_child_order.extend(['attribute_value'])
    c_any_attribute = {"namespace": "##other", "processContents": "lax"}

    def __init__(self,
                 attribute_value=None,
                 name=None,
                 name_format=None,
                 friendly_name=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.attribute_value = attribute_value or []
        self.name = name
        self.name_format = name_format
        self.friendly_name = friendly_name


def attribute_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeType_, xml_string)


class SubjectConfirmationType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmationType
    element """

    c_tag = 'SubjectConfirmationType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}BaseID'] = ('base_id',
                                                                   BaseID)
    c_cardinality['base_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}NameID'] = ('name_id',
                                                                   NameID)
    c_cardinality['name_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedID'] = (
        'encrypted_id',
        EncryptedID)
    c_cardinality['encrypted_id'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:assertion}SubjectConfirmationData'] = (
            'subject_confirmation_data', SubjectConfirmationData)
    c_cardinality['subject_confirmation_data'] = {"min": 0, "max": 1}
    c_attributes['Method'] = ('method', 'anyURI', True)
    c_child_order.extend(['base_id', 'name_id', 'encrypted_id',
                          'subject_confirmation_data'])

    def __init__(self,
                 base_id=None,
                 name_id=None,
                 encrypted_id=None,
                 subject_confirmation_data=None,
                 method=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.base_id = base_id
        self.name_id = name_id
        self.encrypted_id = encrypted_id
        self.subject_confirmation_data = subject_confirmation_data
        self.method = method


def subject_confirmation_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SubjectConfirmationType_,
                                              xml_string)


class AudienceRestriction(AudienceRestrictionType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AudienceRestriction element """

    c_tag = 'AudienceRestriction'
    c_namespace = NAMESPACE
    c_children = AudienceRestrictionType_.c_children.copy()
    c_attributes = AudienceRestrictionType_.c_attributes.copy()
    c_child_order = AudienceRestrictionType_.c_child_order[:]
    c_cardinality = AudienceRestrictionType_.c_cardinality.copy()


def audience_restriction_from_string(xml_string):
    return saml2.create_class_from_xml_string(AudienceRestriction, xml_string)


class AuthnContext(AuthnContextType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthnContext element """

    c_tag = 'AuthnContext'
    c_namespace = NAMESPACE
    c_children = AuthnContextType_.c_children.copy()
    c_attributes = AuthnContextType_.c_attributes.copy()
    c_child_order = AuthnContextType_.c_child_order[:]
    c_cardinality = AuthnContextType_.c_cardinality.copy()


def authn_context_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContext, xml_string)


class Attribute(AttributeType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Attribute element """

    c_tag = 'Attribute'
    c_namespace = NAMESPACE
    c_children = AttributeType_.c_children.copy()
    c_attributes = AttributeType_.c_attributes.copy()
    c_child_order = AttributeType_.c_child_order[:]
    c_cardinality = AttributeType_.c_cardinality.copy()


def attribute_from_string(xml_string):
    return saml2.create_class_from_xml_string(Attribute, xml_string)


class SubjectConfirmation(SubjectConfirmationType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmation element """

    c_tag = 'SubjectConfirmation'
    c_namespace = NAMESPACE
    c_children = SubjectConfirmationType_.c_children.copy()
    c_attributes = SubjectConfirmationType_.c_attributes.copy()
    c_child_order = SubjectConfirmationType_.c_child_order[:]
    c_cardinality = SubjectConfirmationType_.c_cardinality.copy()


def subject_confirmation_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubjectConfirmation, xml_string)


class ConditionsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:ConditionsType element """

    c_tag = 'ConditionsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Condition'] = (
        'condition',
        [Condition])
    c_cardinality['condition'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AudienceRestriction'] = (
        'audience_restriction',
        [AudienceRestriction])
    c_cardinality['audience_restriction'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}OneTimeUse'] = (
        'one_time_use',
        [OneTimeUse])
    c_cardinality['one_time_use'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}ProxyRestriction'] = (
        'proxy_restriction',
        [ProxyRestriction])
    c_cardinality['proxy_restriction'] = {"min": 0}
    c_attributes['NotBefore'] = ('not_before', 'dateTime', False)
    c_attributes['NotOnOrAfter'] = ('not_on_or_after', 'dateTime', False)
    c_child_order.extend(['condition', 'audience_restriction', 'one_time_use',
                          'proxy_restriction'])

    def __init__(self,
                 condition=None,
                 audience_restriction=None,
                 one_time_use=None,
                 proxy_restriction=None,
                 not_before=None,
                 not_on_or_after=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.condition = condition or []
        self.audience_restriction = audience_restriction or []
        self.one_time_use = one_time_use or []
        self.proxy_restriction = proxy_restriction or []
        self.not_before = not_before
        self.not_on_or_after = not_on_or_after

    def verify(self):
        if self.one_time_use:
            assert len(self.one_time_use) == 1
        if self.proxy_restriction:
            assert len(self.proxy_restriction) == 1

        return SamlBase.verify(self)


def conditions_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ConditionsType_, xml_string)


class AuthnStatementType_(StatementAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthnStatementType element """

    c_tag = 'AuthnStatementType'
    c_namespace = NAMESPACE
    c_children = StatementAbstractType_.c_children.copy()
    c_attributes = StatementAbstractType_.c_attributes.copy()
    c_child_order = StatementAbstractType_.c_child_order[:]
    c_cardinality = StatementAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}SubjectLocality'] = (
        'subject_locality', SubjectLocality)
    c_cardinality['subject_locality'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AuthnContext'] = (
        'authn_context', AuthnContext)
    c_attributes['AuthnInstant'] = ('authn_instant', 'dateTime', True)
    c_attributes['SessionIndex'] = ('session_index', 'string', False)
    c_attributes['SessionNotOnOrAfter'] = ('session_not_on_or_after',
                                           'dateTime', False)
    c_child_order.extend(['subject_locality', 'authn_context'])

    def __init__(self,
                 subject_locality=None,
                 authn_context=None,
                 authn_instant=None,
                 session_index=None,
                 session_not_on_or_after=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        StatementAbstractType_.__init__(
            self, text=text, extension_elements=extension_elements,
            extension_attributes=extension_attributes)
        self.subject_locality = subject_locality
        self.authn_context = authn_context
        self.authn_instant = authn_instant
        self.session_index = session_index
        self.session_not_on_or_after = session_not_on_or_after


def authn_statement_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnStatementType_, xml_string)


class AttributeStatementType_(StatementAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AttributeStatementType
    element """

    c_tag = 'AttributeStatementType'
    c_namespace = NAMESPACE
    c_children = StatementAbstractType_.c_children.copy()
    c_attributes = StatementAbstractType_.c_attributes.copy()
    c_child_order = StatementAbstractType_.c_child_order[:]
    c_cardinality = StatementAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Attribute'] = (
        'attribute',
        [Attribute])
    c_cardinality['attribute'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedAttribute'] = (
        'encrypted_attribute',
        [EncryptedAttribute])
    c_cardinality['encrypted_attribute'] = {"min": 0}
    c_child_order.extend(['attribute', 'encrypted_attribute'])

    def __init__(self,
                 attribute=None,
                 encrypted_attribute=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        StatementAbstractType_.__init__(
            self, text=text, extension_elements=extension_elements,
            extension_attributes=extension_attributes)
        self.attribute = attribute or []
        self.encrypted_attribute = encrypted_attribute or []


def attribute_statement_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeStatementType_,
                                              xml_string)


class SubjectType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:SubjectType element """

    c_tag = 'SubjectType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}BaseID'] = ('base_id',
                                                                   BaseID)
    c_cardinality['base_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}NameID'] = ('name_id',
                                                                   NameID)
    c_cardinality['name_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedID'] = (
        'encrypted_id', EncryptedID)
    c_cardinality['encrypted_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}SubjectConfirmation'] = (
        'subject_confirmation', [SubjectConfirmation])
    c_cardinality['subject_confirmation'] = {"min": 0}
    c_child_order.extend(['base_id', 'name_id', 'encrypted_id',
                          'subject_confirmation'])

    def __init__(self,
                 base_id=None,
                 name_id=None,
                 encrypted_id=None,
                 subject_confirmation=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.base_id = base_id
        self.name_id = name_id
        self.encrypted_id = encrypted_id
        self.subject_confirmation = subject_confirmation or []


def subject_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(SubjectType_, xml_string)


class Conditions(ConditionsType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Conditions element """

    c_tag = 'Conditions'
    c_namespace = NAMESPACE
    c_children = ConditionsType_.c_children.copy()
    c_attributes = ConditionsType_.c_attributes.copy()
    c_child_order = ConditionsType_.c_child_order[:]
    c_cardinality = ConditionsType_.c_cardinality.copy()


def conditions_from_string(xml_string):
    return saml2.create_class_from_xml_string(Conditions, xml_string)


class AuthnStatement(AuthnStatementType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthnStatement element """

    c_tag = 'AuthnStatement'
    c_namespace = NAMESPACE
    c_children = AuthnStatementType_.c_children.copy()
    c_attributes = AuthnStatementType_.c_attributes.copy()
    c_child_order = AuthnStatementType_.c_child_order[:]
    c_cardinality = AuthnStatementType_.c_cardinality.copy()


def authn_statement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnStatement, xml_string)


class AttributeStatement(AttributeStatementType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AttributeStatement element """

    c_tag = 'AttributeStatement'
    c_namespace = NAMESPACE
    c_children = AttributeStatementType_.c_children.copy()
    c_attributes = AttributeStatementType_.c_attributes.copy()
    c_child_order = AttributeStatementType_.c_child_order[:]
    c_cardinality = AttributeStatementType_.c_cardinality.copy()


def attribute_statement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeStatement, xml_string)


class Subject(SubjectType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Subject element """

    c_tag = 'Subject'
    c_namespace = NAMESPACE
    c_children = SubjectType_.c_children.copy()
    c_attributes = SubjectType_.c_attributes.copy()
    c_child_order = SubjectType_.c_child_order[:]
    c_cardinality = SubjectType_.c_cardinality.copy()


def subject_from_string(xml_string):
    return saml2.create_class_from_xml_string(Subject, xml_string)


#..................
# ['AuthzDecisionStatement', 'EvidenceType', 'AdviceType', 'Evidence',
# 'Assertion', 'AssertionType', 'AuthzDecisionStatementType', 'Advice']
class EvidenceType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:EvidenceType element """

    c_tag = 'EvidenceType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AssertionIDRef'] = (
        'assertion_id_ref', [AssertionIDRef])
    c_cardinality['assertion_id_ref'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AssertionURIRef'] = (
        'assertion_uri_ref', [AssertionURIRef])
    c_cardinality['assertion_uri_ref'] = {"min": 0}
    c_cardinality['assertion'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedAssertion'] = (
        'encrypted_assertion', [EncryptedAssertion])
    c_cardinality['encrypted_assertion'] = {"min": 0}
    c_child_order.extend(['assertion_id_ref', 'assertion_uri_ref', 'assertion',
                          'encrypted_assertion'])

    def __init__(self,
                 assertion_id_ref=None,
                 assertion_uri_ref=None,
                 assertion=None,
                 encrypted_assertion=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.assertion_id_ref = assertion_id_ref or []
        self.assertion_uri_ref = assertion_uri_ref or []
        self.assertion = assertion or []
        self.encrypted_assertion = encrypted_assertion or []


def evidence_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(EvidenceType_, xml_string)


class Evidence(EvidenceType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Evidence element """

    c_tag = 'Evidence'
    c_namespace = NAMESPACE
    c_children = EvidenceType_.c_children.copy()
    c_attributes = EvidenceType_.c_attributes.copy()
    c_child_order = EvidenceType_.c_child_order[:]
    c_cardinality = EvidenceType_.c_cardinality.copy()


def evidence_from_string(xml_string):
    return saml2.create_class_from_xml_string(Evidence, xml_string)


class AuthzDecisionStatementType_(StatementAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthzDecisionStatementType
    element """

    c_tag = 'AuthzDecisionStatementType'
    c_namespace = NAMESPACE
    c_children = StatementAbstractType_.c_children.copy()
    c_attributes = StatementAbstractType_.c_attributes.copy()
    c_child_order = StatementAbstractType_.c_child_order[:]
    c_cardinality = StatementAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Action'] = (
        'action', [Action])
    c_cardinality['action'] = {"min": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Evidence'] = (
        'evidence', Evidence)
    c_cardinality['evidence'] = {"min": 0, "max": 1}
    c_attributes['Resource'] = ('resource', 'anyURI', True)
    c_attributes['Decision'] = ('decision', DecisionType_, True)
    c_child_order.extend(['action', 'evidence'])

    def __init__(self,
                 action=None,
                 evidence=None,
                 resource=None,
                 decision=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        StatementAbstractType_.__init__(
            self, text=text, extension_elements=extension_elements,
            extension_attributes=extension_attributes)
        self.action = action or []
        self.evidence = evidence
        self.resource = resource
        self.decision = decision


def authz_decision_statement_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthzDecisionStatementType_,
                                              xml_string)


class AuthzDecisionStatement(AuthzDecisionStatementType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AuthzDecisionStatement
    element """

    c_tag = 'AuthzDecisionStatement'
    c_namespace = NAMESPACE
    c_children = AuthzDecisionStatementType_.c_children.copy()
    c_attributes = AuthzDecisionStatementType_.c_attributes.copy()
    c_child_order = AuthzDecisionStatementType_.c_child_order[:]
    c_cardinality = AuthzDecisionStatementType_.c_cardinality.copy()


def authz_decision_statement_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthzDecisionStatement,
                                              xml_string)


#..................
# ['Assertion', 'AssertionType', 'AdviceType', 'Advice']
class AssertionType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AssertionType element """

    c_tag = 'AssertionType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Issuer'] = ('issuer',
                                                                   Issuer)
    c_children['{http://www.w3.org/2000/09/xmldsig#}Signature'] = ('signature',
                                                                   ds.Signature)
    c_cardinality['signature'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Subject'] = ('subject',
                                                                    Subject)
    c_cardinality['subject'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Conditions'] = (
        'conditions', Conditions)
    c_cardinality['conditions'] = {"min": 0, "max": 1}
    c_cardinality['advice'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Statement'] = (
        'statement', [Statement])
    c_cardinality['statement'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AuthnStatement'] = (
        'authn_statement', [AuthnStatement])
    c_cardinality['authn_statement'] = {"min": 0}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:assertion}AuthzDecisionStatement'] = (
            'authz_decision_statement', [AuthzDecisionStatement])
    c_cardinality['authz_decision_statement'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AttributeStatement'] = (
        'attribute_statement', [AttributeStatement])
    c_cardinality['attribute_statement'] = {"min": 0}
    c_attributes['Version'] = ('version', 'string', True)
    c_attributes['ID'] = ('id', 'ID', True)
    c_attributes['IssueInstant'] = ('issue_instant', 'dateTime', True)
    c_child_order.extend(['issuer', 'signature', 'subject', 'conditions',
                          'advice', 'statement', 'authn_statement',
                          'authz_decision_statement', 'attribute_statement'])

    def __init__(self,
                 issuer=None,
                 signature=None,
                 subject=None,
                 conditions=None,
                 advice=None,
                 statement=None,
                 authn_statement=None,
                 authz_decision_statement=None,
                 attribute_statement=None,
                 version=None,
                 id=None,
                 issue_instant=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.issuer = issuer
        self.signature = signature
        self.subject = subject
        self.conditions = conditions
        self.advice = advice
        self.statement = statement or []
        self.authn_statement = authn_statement or []
        self.authz_decision_statement = authz_decision_statement or []
        self.attribute_statement = attribute_statement or []
        self.version = version
        self.id = id
        self.issue_instant = issue_instant

    def verify(self):
        # If no statement MUST contain a subject element
        if self.attribute_statement or self.statement or \
                self.authn_statement or self.authz_decision_statement:
            pass
        elif not self.subject:
            raise MustValueError(
                "If no statement MUST contain a subject element")

        if self.authn_statement and not self.subject:
            raise MustValueError(
                "An assertion with an AuthnStatement must contain a Subject")

        return SamlBase.verify(self)


def assertion_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AssertionType_, xml_string)


class Assertion(AssertionType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Assertion element """

    c_tag = 'Assertion'
    c_namespace = NAMESPACE
    c_children = AssertionType_.c_children.copy()
    c_attributes = AssertionType_.c_attributes.copy()
    c_child_order = AssertionType_.c_child_order[:]
    c_cardinality = AssertionType_.c_cardinality.copy()


def assertion_from_string(xml_string):
    return saml2.create_class_from_xml_string(Assertion, xml_string)


class AdviceType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:assertion:AdviceType element """

    c_tag = 'AdviceType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AssertionIDRef'] = (
        'assertion_id_ref', [AssertionIDRef])
    c_cardinality['assertion_id_ref'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AssertionURIRef'] = (
        'assertion_uri_ref', [AssertionURIRef])
    c_cardinality['assertion_uri_ref'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Assertion'] = (
        'assertion', [Assertion])
    c_cardinality['assertion'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedAssertion'] = (
        'encrypted_assertion', [EncryptedAssertion])
    c_cardinality['encrypted_assertion'] = {"min": 0}
    c_child_order.extend(['assertion_id_ref', 'assertion_uri_ref', 'assertion',
                          'encrypted_assertion'])
    c_any = {"namespace": "##other", "processContents": "lax"}

    def __init__(self,
                 assertion_id_ref=None,
                 assertion_uri_ref=None,
                 assertion=None,
                 encrypted_assertion=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.assertion_id_ref = assertion_id_ref or []
        self.assertion_uri_ref = assertion_uri_ref or []
        self.assertion = assertion or []
        self.encrypted_assertion = encrypted_assertion or []


def advice_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AdviceType_, xml_string)


class Advice(AdviceType_):
    """The urn:oasis:names:tc:SAML:2.0:assertion:Advice element """

    c_tag = 'Advice'
    c_namespace = NAMESPACE
    c_children = AdviceType_.c_children.copy()
    c_attributes = AdviceType_.c_attributes.copy()
    c_child_order = AdviceType_.c_child_order[:]
    c_cardinality = AdviceType_.c_cardinality.copy()


def advice_from_string(xml_string):
    return saml2.create_class_from_xml_string(Advice, xml_string)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
EvidenceType_.c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Assertion'] = (
    'assertion', [Assertion])
Evidence.c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Assertion'] = (
    'assertion', [Assertion])
AssertionType_.c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Advice'] = (
    'advice', Advice)
Assertion.c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Advice'] = (
    'advice', Advice)
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

AG_IDNameQualifiers = [
    ('NameQualifier', 'string', False),
    ('SPNameQualifier', 'string', False),
]

ELEMENT_FROM_STRING = {
    BaseID.c_tag: base_id_from_string,
    NameID.c_tag: name_id_from_string,
    NameIDType_.c_tag: name_id_type__from_string,
    EncryptedElementType_.c_tag: encrypted_element_type__from_string,
    EncryptedID.c_tag: encrypted_id_from_string,
    Issuer.c_tag: issuer_from_string,
    AssertionIDRef.c_tag: assertion_id_ref_from_string,
    AssertionURIRef.c_tag: assertion_uri_ref_from_string,
    Assertion.c_tag: assertion_from_string,
    AssertionType_.c_tag: assertion_type__from_string,
    Subject.c_tag: subject_from_string,
    SubjectType_.c_tag: subject_type__from_string,
    SubjectConfirmation.c_tag: subject_confirmation_from_string,
    SubjectConfirmationType_.c_tag: subject_confirmation_type__from_string,
    SubjectConfirmationData.c_tag: subject_confirmation_data_from_string,
    SubjectConfirmationDataType_.c_tag:
    subject_confirmation_data_type__from_string,
    KeyInfoConfirmationDataType_.c_tag:
    key_info_confirmation_data_type__from_string,
    Conditions.c_tag: conditions_from_string,
    ConditionsType_.c_tag: conditions_type__from_string,
    Condition.c_tag: condition_from_string,
    AudienceRestriction.c_tag: audience_restriction_from_string,
    AudienceRestrictionType_.c_tag: audience_restriction_type__from_string,
    Audience.c_tag: audience_from_string,
    OneTimeUse.c_tag: one_time_use_from_string,
    OneTimeUseType_.c_tag: one_time_use_type__from_string,
    ProxyRestriction.c_tag: proxy_restriction_from_string,
    ProxyRestrictionType_.c_tag: proxy_restriction_type__from_string,
    Advice.c_tag: advice_from_string,
    AdviceType_.c_tag: advice_type__from_string,
    EncryptedAssertion.c_tag: encrypted_assertion_from_string,
    Statement.c_tag: statement_from_string,
    AuthnStatement.c_tag: authn_statement_from_string,
    AuthnStatementType_.c_tag: authn_statement_type__from_string,
    SubjectLocality.c_tag: subject_locality_from_string,
    SubjectLocalityType_.c_tag: subject_locality_type__from_string,
    AuthnContext.c_tag: authn_context_from_string,
    AuthnContextType_.c_tag: authn_context_type__from_string,
    AuthnContextClassRef.c_tag: authn_context_class_ref_from_string,
    AuthnContextDeclRef.c_tag: authn_context_decl_ref_from_string,
    AuthnContextDecl.c_tag: authn_context_decl_from_string,
    AuthenticatingAuthority.c_tag: authenticating_authority_from_string,
    AuthzDecisionStatement.c_tag: authz_decision_statement_from_string,
    AuthzDecisionStatementType_.c_tag:
    authz_decision_statement_type__from_string,
    DecisionType_.c_tag: decision_type__from_string,
    Action.c_tag: action_from_string,
    ActionType_.c_tag: action_type__from_string,
    Evidence.c_tag: evidence_from_string,
    EvidenceType_.c_tag: evidence_type__from_string,
    AttributeStatement.c_tag: attribute_statement_from_string,
    AttributeStatementType_.c_tag: attribute_statement_type__from_string,
    Attribute.c_tag: attribute_from_string,
    AttributeType_.c_tag: attribute_type__from_string,
    AttributeValue.c_tag: attribute_value_from_string,
    EncryptedAttribute.c_tag: encrypted_attribute_from_string,
}

ELEMENT_BY_TAG = {
    'BaseID': BaseID,
    'NameID': NameID,
    'NameIDType': NameIDType_,
    'EncryptedElementType': EncryptedElementType_,
    'EncryptedID': EncryptedID,
    'Issuer': Issuer,
    'AssertionIDRef': AssertionIDRef,
    'AssertionURIRef': AssertionURIRef,
    'Assertion': Assertion,
    'AssertionType': AssertionType_,
    'Subject': Subject,
    'SubjectType': SubjectType_,
    'SubjectConfirmation': SubjectConfirmation,
    'SubjectConfirmationType': SubjectConfirmationType_,
    'SubjectConfirmationData': SubjectConfirmationData,
    'SubjectConfirmationDataType': SubjectConfirmationDataType_,
    'KeyInfoConfirmationDataType': KeyInfoConfirmationDataType_,
    'Conditions': Conditions,
    'ConditionsType': ConditionsType_,
    'Condition': Condition,
    'AudienceRestriction': AudienceRestriction,
    'AudienceRestrictionType': AudienceRestrictionType_,
    'Audience': Audience,
    'OneTimeUse': OneTimeUse,
    'OneTimeUseType': OneTimeUseType_,
    'ProxyRestriction': ProxyRestriction,
    'ProxyRestrictionType': ProxyRestrictionType_,
    'Advice': Advice,
    'AdviceType': AdviceType_,
    'EncryptedAssertion': EncryptedAssertion,
    'Statement': Statement,
    'AuthnStatement': AuthnStatement,
    'AuthnStatementType': AuthnStatementType_,
    'SubjectLocality': SubjectLocality,
    'SubjectLocalityType': SubjectLocalityType_,
    'AuthnContext': AuthnContext,
    'AuthnContextType': AuthnContextType_,
    'AuthnContextClassRef': AuthnContextClassRef,
    'AuthnContextDeclRef': AuthnContextDeclRef,
    'AuthnContextDecl': AuthnContextDecl,
    'AuthenticatingAuthority': AuthenticatingAuthority,
    'AuthzDecisionStatement': AuthzDecisionStatement,
    'AuthzDecisionStatementType': AuthzDecisionStatementType_,
    'DecisionType': DecisionType_,
    'Action': Action,
    'ActionType': ActionType_,
    'Evidence': Evidence,
    'EvidenceType': EvidenceType_,
    'AttributeStatement': AttributeStatement,
    'AttributeStatementType': AttributeStatementType_,
    'Attribute': Attribute,
    'AttributeType': AttributeType_,
    'AttributeValue': AttributeValue,
    'EncryptedAttribute': EncryptedAttribute,
    'BaseIDAbstractType': BaseIDAbstractType_,
    'ConditionAbstractType': ConditionAbstractType_,
    'StatementAbstractType': StatementAbstractType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)
########NEW FILE########
__FILENAME__ = samlp
#!/usr/bin/env python

#
# Generated Mon May  2 14:23:33 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

import xmldsig as ds
from saml2 import saml

NAMESPACE = 'urn:oasis:names:tc:SAML:2.0:protocol'

STATUS_SUCCESS = 'urn:oasis:names:tc:SAML:2.0:status:Success'
STATUS_REQUESTER = 'urn:oasis:names:tc:SAML:2.0:status:Requester'
STATUS_RESPONDER = 'urn:oasis:names:tc:SAML:2.0:status:Responder'
STATUS_VERSION_MISMATCH = 'urn:oasis:names:tc:SAML:2.0:status:VersionMismatch'

STATUS_AUTHN_FAILED = 'urn:oasis:names:tc:SAML:2.0:status:AuthnFailed'
STATUS_INVALID_ATTR_NAME_OR_VALUE = (
    'urn:oasis:names:tc:SAML:2.0:status:InvalidAttrNameOrValue')
STATUS_INVALID_NAMEID_POLICY = (
    'urn:oasis:names:tc:SAML:2.0:status:InvalidNameIDPolicy')
STATUS_NO_AUTHN_CONTEXT = 'urn:oasis:names:tc:SAML:2.0:status:NoAuthnContext'
STATUS_NO_AVAILABLE_IDP = 'urn:oasis:names:tc:SAML:2.0:status:NoAvailableIDP'
STATUS_NO_PASSIVE = 'urn:oasis:names:tc:SAML:2.0:status:NoPassive'
STATUS_NO_SUPPORTED_IDP = 'urn:oasis:names:tc:SAML:2.0:status:NoSupportedIDP'
STATUS_PARTIAL_LOGOUT = 'urn:oasis:names:tc:SAML:2.0:status:PartialLogout'
STATUS_PROXY_COUNT_EXCEEDED = (
    'urn:oasis:names:tc:SAML:2.0:status:ProxyCountExceeded')
STATUS_REQUEST_DENIED = 'urn:oasis:names:tc:SAML:2.0:status:RequestDenied'
STATUS_REQUEST_UNSUPPORTED = (
    'urn:oasis:names:tc:SAML:2.0:status:RequestUnsupported')
STATUS_REQUEST_VERSION_DEPRECATED = (
    'urn:oasis:names:tc:SAML:2.0:status:RequestVersionDeprecated')
STATUS_REQUEST_VERSION_TOO_HIGH = (
    'urn:oasis:names:tc:SAML:2.0:status:RequestVersionTooHigh')
STATUS_REQUEST_VERSION_TOO_LOW = (
    'urn:oasis:names:tc:SAML:2.0:status:RequestVersionTooLow')
STATUS_RESOURCE_NOT_RECOGNIZED = (
    'urn:oasis:names:tc:SAML:2.0:status:ResourceNotRecognized')
STATUS_TOO_MANY_RESPONSES = (
    'urn:oasis:names:tc:SAML:2.0:status:TooManyResponses')
STATUS_UNKNOWN_ATTR_PROFILE = (
    'urn:oasis:names:tc:SAML:2.0:status:UnknownAttrProfile')
STATUS_UNKNOWN_PRINCIPAL = (
    'urn:oasis:names:tc:SAML:2.0:status:UnknownPrincipal')
STATUS_UNSUPPORTED_BINDING = (
    'urn:oasis:names:tc:SAML:2.0:status:UnsupportedBinding')


class ExtensionsType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ExtensionsType element """

    c_tag = 'ExtensionsType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def extensions_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ExtensionsType_, xml_string)


class StatusMessage(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:StatusMessage element """

    c_tag = 'StatusMessage'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def status_message_from_string(xml_string):
    return saml2.create_class_from_xml_string(StatusMessage, xml_string)


class StatusDetailType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:StatusDetailType element """

    c_tag = 'StatusDetailType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_any = {"namespace": "##any", "processContents": "lax", "minOccurs": "0",
             "maxOccurs": "unbounded"}


def status_detail_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(StatusDetailType_, xml_string)


class AuthnContextComparisonType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AuthnContextComparisonType element """

    c_tag = 'AuthnContextComparisonType'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string', 'enumeration': ['exact', 'minimum',
                                                      'maximum', 'better']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def authn_context_comparison_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnContextComparisonType_,
                                              xml_string)


class NameIDPolicyType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:NameIDPolicyType element """

    c_tag = 'NameIDPolicyType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['Format'] = ('format', 'anyURI', False)
    c_attributes['SPNameQualifier'] = ('sp_name_qualifier', 'string', False)
    c_attributes['AllowCreate'] = ('allow_create', 'boolean', False)

    def __init__(self,
                 format=None,
                 sp_name_qualifier=None,
                 allow_create=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None,
    ):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes,
        )
        self.format = format
        self.sp_name_qualifier = sp_name_qualifier
        self.allow_create = allow_create


def name_id_policy_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDPolicyType_, xml_string)


class RequesterID(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:RequesterID element """

    c_tag = 'RequesterID'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def requester_id_from_string(xml_string):
    return saml2.create_class_from_xml_string(RequesterID, xml_string)


class IDPEntryType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:IDPEntryType element """

    c_tag = 'IDPEntryType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['ProviderID'] = ('provider_id', 'anyURI', True)
    c_attributes['Name'] = ('name', 'string', False)
    c_attributes['Loc'] = ('loc', 'anyURI', False)

    def __init__(self,
                 provider_id=None,
                 name=None,
                 loc=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.provider_id = provider_id
        self.name = name
        self.loc = loc


def idp_entry_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IDPEntryType_, xml_string)


class GetComplete(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:GetComplete element """

    c_tag = 'GetComplete'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def get_complete_from_string(xml_string):
    return saml2.create_class_from_xml_string(GetComplete, xml_string)


class Artifact(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:Artifact element """

    c_tag = 'Artifact'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def artifact_from_string(xml_string):
    return saml2.create_class_from_xml_string(Artifact, xml_string)


class NewID(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:NewID element """

    c_tag = 'NewID'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def new_id_from_string(xml_string):
    return saml2.create_class_from_xml_string(NewID, xml_string)


class NewEncryptedID(saml.EncryptedElementType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:NewEncryptedID element """

    c_tag = 'NewEncryptedID'
    c_namespace = NAMESPACE
    c_children = saml.EncryptedElementType_.c_children.copy()
    c_attributes = saml.EncryptedElementType_.c_attributes.copy()
    c_child_order = saml.EncryptedElementType_.c_child_order[:]
    c_cardinality = saml.EncryptedElementType_.c_cardinality.copy()


def new_encrypted_id_from_string(xml_string):
    return saml2.create_class_from_xml_string(NewEncryptedID, xml_string)


class TerminateType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:TerminateType element """

    c_tag = 'TerminateType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def terminate_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TerminateType_, xml_string)


class SessionIndex(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:SessionIndex element """

    c_tag = 'SessionIndex'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()


def session_index_from_string(xml_string):
    return saml2.create_class_from_xml_string(SessionIndex, xml_string)


class Extensions(ExtensionsType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:Extensions element """

    c_tag = 'Extensions'
    c_namespace = NAMESPACE
    c_children = ExtensionsType_.c_children.copy()
    c_attributes = ExtensionsType_.c_attributes.copy()
    c_child_order = ExtensionsType_.c_child_order[:]
    c_cardinality = ExtensionsType_.c_cardinality.copy()


def extensions_from_string(xml_string):
    return saml2.create_class_from_xml_string(Extensions, xml_string)


class StatusDetail(StatusDetailType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:StatusDetail element """

    c_tag = 'StatusDetail'
    c_namespace = NAMESPACE
    c_children = StatusDetailType_.c_children.copy()
    c_attributes = StatusDetailType_.c_attributes.copy()
    c_child_order = StatusDetailType_.c_child_order[:]
    c_cardinality = StatusDetailType_.c_cardinality.copy()


def status_detail_from_string(xml_string):
    return saml2.create_class_from_xml_string(StatusDetail, xml_string)


class RequestAbstractType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:RequestAbstractType element """

    c_tag = 'RequestAbstractType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Issuer'] = ('issuer',
                                                                   saml.Issuer)
    c_cardinality['issuer'] = {"min": 0, "max": 1}
    c_children['{http://www.w3.org/2000/09/xmldsig#}Signature'] = ('signature',
                                                                   ds.Signature)
    c_cardinality['signature'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}Extensions'] = (
        'extensions', Extensions)
    c_cardinality['extensions'] = {"min": 0, "max": 1}
    c_attributes['ID'] = ('id', 'ID', True)
    c_attributes['Version'] = ('version', 'string', True)
    c_attributes['IssueInstant'] = ('issue_instant', 'dateTime', True)
    c_attributes['Destination'] = ('destination', 'anyURI', False)
    c_attributes['Consent'] = ('consent', 'anyURI', False)
    c_child_order.extend(['issuer', 'signature', 'extensions'])

    def __init__(self,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.issuer = issuer
        self.signature = signature
        self.extensions = extensions
        self.id = id
        self.version = version
        self.issue_instant = issue_instant
        self.destination = destination
        self.consent = consent


class AssertionIDRequestType_(RequestAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AssertionIDRequestType element """

    c_tag = 'AssertionIDRequestType'
    c_namespace = NAMESPACE
    c_children = RequestAbstractType_.c_children.copy()
    c_attributes = RequestAbstractType_.c_attributes.copy()
    c_child_order = RequestAbstractType_.c_child_order[:]
    c_cardinality = RequestAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AssertionIDRef'] = (
        'assertion_id_ref', [saml.AssertionIDRef])
    c_cardinality['assertion_id_ref'] = {"min": 1}
    c_child_order.extend(['assertion_id_ref'])

    def __init__(self,
                 assertion_id_ref=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        RequestAbstractType_.__init__(self,
                                      issuer=issuer,
                                      signature=signature,
                                      extensions=extensions,
                                      id=id,
                                      version=version,
                                      issue_instant=issue_instant,
                                      destination=destination,
                                      consent=consent,
                                      text=text,
                                      extension_elements=extension_elements,
                                      extension_attributes=extension_attributes)
        self.assertion_id_ref = assertion_id_ref or []


def assertion_id_request_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AssertionIDRequestType_,
                                              xml_string)


class SubjectQueryAbstractType_(RequestAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:SubjectQueryAbstractType element """

    c_tag = 'SubjectQueryAbstractType'
    c_namespace = NAMESPACE
    c_children = RequestAbstractType_.c_children.copy()
    c_attributes = RequestAbstractType_.c_attributes.copy()
    c_child_order = RequestAbstractType_.c_child_order[:]
    c_cardinality = RequestAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Subject'] = ('subject',
                                                                    saml.Subject)
    c_child_order.extend(['subject'])

    def __init__(self,
                 subject=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        RequestAbstractType_.__init__(self,
                                      issuer=issuer,
                                      signature=signature,
                                      extensions=extensions,
                                      id=id,
                                      version=version,
                                      issue_instant=issue_instant,
                                      destination=destination,
                                      consent=consent,
                                      text=text,
                                      extension_elements=extension_elements,
                                      extension_attributes=extension_attributes)
        self.subject = subject


class RequestedAuthnContextType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:RequestedAuthnContextType element """

    c_tag = 'RequestedAuthnContextType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:assertion}AuthnContextClassRef'] = (
            'authn_context_class_ref',
            [saml.AuthnContextClassRef])
    c_cardinality['authn_context_class_ref'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}AuthnContextDeclRef'] = (
        'authn_context_decl_ref',
        [saml.AuthnContextDeclRef])
    c_cardinality['authn_context_decl_ref'] = {"min": 0}
    c_attributes['Comparison'] = ('comparison', AuthnContextComparisonType_,
                                  False)
    c_child_order.extend(['authn_context_class_ref', 'authn_context_decl_ref'])

    def __init__(self,
                 authn_context_class_ref=None,
                 authn_context_decl_ref=None,
                 comparison=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.authn_context_class_ref = authn_context_class_ref or []
        self.authn_context_decl_ref = authn_context_decl_ref or []
        self.comparison = comparison


def requested_authn_context_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(RequestedAuthnContextType_,
                                              xml_string)


class AttributeQueryType_(SubjectQueryAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AttributeQueryType element """

    c_tag = 'AttributeQueryType'
    c_namespace = NAMESPACE
    c_children = SubjectQueryAbstractType_.c_children.copy()
    c_attributes = SubjectQueryAbstractType_.c_attributes.copy()
    c_child_order = SubjectQueryAbstractType_.c_child_order[:]
    c_cardinality = SubjectQueryAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Attribute'] = (
        'attribute',
        [saml.Attribute])
    c_cardinality['attribute'] = {"min": 0}
    c_child_order.extend(['attribute'])

    def __init__(self,
                 attribute=None,
                 subject=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SubjectQueryAbstractType_.__init__(self,
                                           subject=subject,
                                           issuer=issuer,
                                           signature=signature,
                                           extensions=extensions,
                                           id=id,
                                           version=version,
                                           issue_instant=issue_instant,
                                           destination=destination,
                                           consent=consent,
                                           text=text,
                                           extension_elements=extension_elements,
                                           extension_attributes=extension_attributes)
        self.attribute = attribute or []


def attribute_query_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeQueryType_, xml_string)


class AuthzDecisionQueryType_(SubjectQueryAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AuthzDecisionQueryType element """

    c_tag = 'AuthzDecisionQueryType'
    c_namespace = NAMESPACE
    c_children = SubjectQueryAbstractType_.c_children.copy()
    c_attributes = SubjectQueryAbstractType_.c_attributes.copy()
    c_child_order = SubjectQueryAbstractType_.c_child_order[:]
    c_cardinality = SubjectQueryAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Action'] = (
        'action', [saml.Action])
    c_cardinality['action'] = {"min": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Evidence'] = (
        'evidence', saml.Evidence)
    c_cardinality['evidence'] = {"min": 0, "max": 1}
    c_attributes['Resource'] = ('resource', 'anyURI', True)
    c_child_order.extend(['action', 'evidence'])

    def __init__(self,
                 action=None,
                 evidence=None,
                 resource=None,
                 subject=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SubjectQueryAbstractType_.__init__(self,
                                           subject=subject,
                                           issuer=issuer,
                                           signature=signature,
                                           extensions=extensions,
                                           id=id,
                                           version=version,
                                           issue_instant=issue_instant,
                                           destination=destination,
                                           consent=consent,
                                           text=text,
                                           extension_elements=extension_elements,
                                           extension_attributes=extension_attributes)
        self.action = action or []
        self.evidence = evidence
        self.resource = resource


def authz_decision_query_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthzDecisionQueryType_,
                                              xml_string)


class NameIDPolicy(NameIDPolicyType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:NameIDPolicy element """

    c_tag = 'NameIDPolicy'
    c_namespace = NAMESPACE
    c_children = NameIDPolicyType_.c_children.copy()
    c_attributes = NameIDPolicyType_.c_attributes.copy()
    c_child_order = NameIDPolicyType_.c_child_order[:]
    c_cardinality = NameIDPolicyType_.c_cardinality.copy()


def name_id_policy_from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDPolicy, xml_string)


class IDPEntry(IDPEntryType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:IDPEntry element """

    c_tag = 'IDPEntry'
    c_namespace = NAMESPACE
    c_children = IDPEntryType_.c_children.copy()
    c_attributes = IDPEntryType_.c_attributes.copy()
    c_child_order = IDPEntryType_.c_child_order[:]
    c_cardinality = IDPEntryType_.c_cardinality.copy()


def idp_entry_from_string(xml_string):
    return saml2.create_class_from_xml_string(IDPEntry, xml_string)


class ArtifactResolveType_(RequestAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ArtifactResolveType element """

    c_tag = 'ArtifactResolveType'
    c_namespace = NAMESPACE
    c_children = RequestAbstractType_.c_children.copy()
    c_attributes = RequestAbstractType_.c_attributes.copy()
    c_child_order = RequestAbstractType_.c_child_order[:]
    c_cardinality = RequestAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}Artifact'] = ('artifact',
                                                                    Artifact)
    c_child_order.extend(['artifact'])

    def __init__(self,
                 artifact=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        RequestAbstractType_.__init__(self,
                                      issuer=issuer,
                                      signature=signature,
                                      extensions=extensions,
                                      id=id,
                                      version=version,
                                      issue_instant=issue_instant,
                                      destination=destination,
                                      consent=consent,
                                      text=text,
                                      extension_elements=extension_elements,
                                      extension_attributes=extension_attributes)
        self.artifact = artifact


def artifact_resolve_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ArtifactResolveType_, xml_string)


class Terminate(TerminateType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:Terminate element """

    c_tag = 'Terminate'
    c_namespace = NAMESPACE
    c_children = TerminateType_.c_children.copy()
    c_attributes = TerminateType_.c_attributes.copy()
    c_child_order = TerminateType_.c_child_order[:]
    c_cardinality = TerminateType_.c_cardinality.copy()


def terminate_from_string(xml_string):
    return saml2.create_class_from_xml_string(Terminate, xml_string)


class LogoutRequestType_(RequestAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:LogoutRequestType element """

    c_tag = 'LogoutRequestType'
    c_namespace = NAMESPACE
    c_children = RequestAbstractType_.c_children.copy()
    c_attributes = RequestAbstractType_.c_attributes.copy()
    c_child_order = RequestAbstractType_.c_child_order[:]
    c_cardinality = RequestAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}BaseID'] = (
        'base_id', saml.BaseID)
    c_cardinality['base_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}NameID'] = (
        'name_id', saml.NameID)
    c_cardinality['name_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedID'] = (
        'encrypted_id', saml.EncryptedID)
    c_cardinality['encrypted_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}SessionIndex'] = (
        'session_index', [SessionIndex])
    c_cardinality['session_index'] = {"min": 0}
    c_attributes['Reason'] = ('reason', 'string', False)
    c_attributes['NotOnOrAfter'] = ('not_on_or_after', 'dateTime', False)
    c_child_order.extend(
        ['base_id', 'name_id', 'encrypted_id', 'session_index'])

    def __init__(self,
                 base_id=None,
                 name_id=None,
                 encrypted_id=None,
                 session_index=None,
                 reason=None,
                 not_on_or_after=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        RequestAbstractType_.__init__(self,
                                      issuer=issuer,
                                      signature=signature,
                                      extensions=extensions,
                                      id=id,
                                      version=version,
                                      issue_instant=issue_instant,
                                      destination=destination,
                                      consent=consent,
                                      text=text,
                                      extension_elements=extension_elements,
                                      extension_attributes=extension_attributes)
        self.base_id = base_id
        self.name_id = name_id
        self.encrypted_id = encrypted_id
        self.session_index = session_index or []
        self.reason = reason
        self.not_on_or_after = not_on_or_after


def logout_request_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(LogoutRequestType_, xml_string)


class NameIDMappingRequestType_(RequestAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:NameIDMappingRequestType
    element """

    c_tag = 'NameIDMappingRequestType'
    c_namespace = NAMESPACE
    c_children = RequestAbstractType_.c_children.copy()
    c_attributes = RequestAbstractType_.c_attributes.copy()
    c_child_order = RequestAbstractType_.c_child_order[:]
    c_cardinality = RequestAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}BaseID'] = (
        'base_id', saml.BaseID)
    c_cardinality['base_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}NameID'] = (
        'name_id', saml.NameID)
    c_cardinality['name_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedID'] = (
        'encrypted_id', saml.EncryptedID)
    c_cardinality['encrypted_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}NameIDPolicy'] = (
        'name_id_policy', NameIDPolicy)
    c_child_order.extend(
        ['base_id', 'name_id', 'encrypted_id', 'name_id_policy'])

    def __init__(self,
                 base_id=None,
                 name_id=None,
                 encrypted_id=None,
                 name_id_policy=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        RequestAbstractType_.__init__(self,
                                      issuer=issuer,
                                      signature=signature,
                                      extensions=extensions,
                                      id=id,
                                      version=version,
                                      issue_instant=issue_instant,
                                      destination=destination,
                                      consent=consent,
                                      text=text,
                                      extension_elements=extension_elements,
                                      extension_attributes=extension_attributes)
        self.base_id = base_id
        self.name_id = name_id
        self.encrypted_id = encrypted_id
        self.name_id_policy = name_id_policy


def name_id_mapping_request_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDMappingRequestType_,
                                              xml_string)


class AssertionIDRequest(AssertionIDRequestType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AssertionIDRequest element """

    c_tag = 'AssertionIDRequest'
    c_namespace = NAMESPACE
    c_children = AssertionIDRequestType_.c_children.copy()
    c_attributes = AssertionIDRequestType_.c_attributes.copy()
    c_child_order = AssertionIDRequestType_.c_child_order[:]
    c_cardinality = AssertionIDRequestType_.c_cardinality.copy()


def assertion_id_request_from_string(xml_string):
    return saml2.create_class_from_xml_string(AssertionIDRequest, xml_string)


class SubjectQuery(SubjectQueryAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:SubjectQuery element """

    c_tag = 'SubjectQuery'
    c_namespace = NAMESPACE
    c_children = SubjectQueryAbstractType_.c_children.copy()
    c_attributes = SubjectQueryAbstractType_.c_attributes.copy()
    c_child_order = SubjectQueryAbstractType_.c_child_order[:]
    c_cardinality = SubjectQueryAbstractType_.c_cardinality.copy()


def subject_query_from_string(xml_string):
    return saml2.create_class_from_xml_string(SubjectQuery, xml_string)


class RequestedAuthnContext(RequestedAuthnContextType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:RequestedAuthnContext element """

    c_tag = 'RequestedAuthnContext'
    c_namespace = NAMESPACE
    c_children = RequestedAuthnContextType_.c_children.copy()
    c_attributes = RequestedAuthnContextType_.c_attributes.copy()
    c_child_order = RequestedAuthnContextType_.c_child_order[:]
    c_cardinality = RequestedAuthnContextType_.c_cardinality.copy()


def requested_authn_context_from_string(xml_string):
    return saml2.create_class_from_xml_string(RequestedAuthnContext, xml_string)


class AttributeQuery(AttributeQueryType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AttributeQuery element """

    c_tag = 'AttributeQuery'
    c_namespace = NAMESPACE
    c_children = AttributeQueryType_.c_children.copy()
    c_attributes = AttributeQueryType_.c_attributes.copy()
    c_child_order = AttributeQueryType_.c_child_order[:]
    c_cardinality = AttributeQueryType_.c_cardinality.copy()


def attribute_query_from_string(xml_string):
    return saml2.create_class_from_xml_string(AttributeQuery, xml_string)


class AuthzDecisionQuery(AuthzDecisionQueryType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AuthzDecisionQuery element """

    c_tag = 'AuthzDecisionQuery'
    c_namespace = NAMESPACE
    c_children = AuthzDecisionQueryType_.c_children.copy()
    c_attributes = AuthzDecisionQueryType_.c_attributes.copy()
    c_child_order = AuthzDecisionQueryType_.c_child_order[:]
    c_cardinality = AuthzDecisionQueryType_.c_cardinality.copy()


def authz_decision_query_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthzDecisionQuery, xml_string)


class IDPListType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:IDPListType element """

    c_tag = 'IDPListType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}IDPEntry'] = (
        'idp_entry', [IDPEntry])
    c_cardinality['idp_entry'] = {"min": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}GetComplete'] = (
        'get_complete', GetComplete)
    c_cardinality['get_complete'] = {"min": 0, "max": 1}
    c_child_order.extend(['idp_entry', 'get_complete'])

    def __init__(self,
                 idp_entry=None,
                 get_complete=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.idp_entry = idp_entry or []
        self.get_complete = get_complete


def idp_list_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(IDPListType_, xml_string)


class ArtifactResolve(ArtifactResolveType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ArtifactResolve element """

    c_tag = 'ArtifactResolve'
    c_namespace = NAMESPACE
    c_children = ArtifactResolveType_.c_children.copy()
    c_attributes = ArtifactResolveType_.c_attributes.copy()
    c_child_order = ArtifactResolveType_.c_child_order[:]
    c_cardinality = ArtifactResolveType_.c_cardinality.copy()


def artifact_resolve_from_string(xml_string):
    return saml2.create_class_from_xml_string(ArtifactResolve, xml_string)


class ManageNameIDRequestType_(RequestAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ManageNameIDRequestType element """

    c_tag = 'ManageNameIDRequestType'
    c_namespace = NAMESPACE
    c_children = RequestAbstractType_.c_children.copy()
    c_attributes = RequestAbstractType_.c_attributes.copy()
    c_child_order = RequestAbstractType_.c_child_order[:]
    c_cardinality = RequestAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}NameID'] = ('name_id',
                                                                   saml.NameID)
    c_cardinality['name_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedID'] = (
        'encrypted_id',
        saml.EncryptedID)
    c_cardinality['encrypted_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}NewID'] = ('new_id',
                                                                 NewID)
    c_cardinality['new_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}NewEncryptedID'] = (
        'new_encrypted_id',
        NewEncryptedID)
    c_cardinality['new_encrypted_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}Terminate'] = (
        'terminate',
        Terminate)
    c_cardinality['terminate'] = {"min": 0, "max": 1}
    c_child_order.extend(['name_id', 'encrypted_id', 'new_id',
                          'new_encrypted_id', 'terminate'])

    def __init__(self,
                 name_id=None,
                 encrypted_id=None,
                 new_id=None,
                 new_encrypted_id=None,
                 terminate=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        RequestAbstractType_.__init__(self,
                                      issuer=issuer,
                                      signature=signature,
                                      extensions=extensions,
                                      id=id,
                                      version=version,
                                      issue_instant=issue_instant,
                                      destination=destination,
                                      consent=consent,
                                      text=text,
                                      extension_elements=extension_elements,
                                      extension_attributes=extension_attributes)
        self.name_id = name_id
        self.encrypted_id = encrypted_id
        self.new_id = new_id
        self.new_encrypted_id = new_encrypted_id
        self.terminate = terminate


def manage_name_id_request_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ManageNameIDRequestType_,
                                              xml_string)


class LogoutRequest(LogoutRequestType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:LogoutRequest element """

    c_tag = 'LogoutRequest'
    c_namespace = NAMESPACE
    c_children = LogoutRequestType_.c_children.copy()
    c_attributes = LogoutRequestType_.c_attributes.copy()
    c_child_order = LogoutRequestType_.c_child_order[:]
    c_cardinality = LogoutRequestType_.c_cardinality.copy()


def logout_request_from_string(xml_string):
    return saml2.create_class_from_xml_string(LogoutRequest, xml_string)


class NameIDMappingRequest(NameIDMappingRequestType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:NameIDMappingRequest element """

    c_tag = 'NameIDMappingRequest'
    c_namespace = NAMESPACE
    c_children = NameIDMappingRequestType_.c_children.copy()
    c_attributes = NameIDMappingRequestType_.c_attributes.copy()
    c_child_order = NameIDMappingRequestType_.c_child_order[:]
    c_cardinality = NameIDMappingRequestType_.c_cardinality.copy()


def name_id_mapping_request_from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDMappingRequest, xml_string)


class AuthnQueryType_(SubjectQueryAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AuthnQueryType element """

    c_tag = 'AuthnQueryType'
    c_namespace = NAMESPACE
    c_children = SubjectQueryAbstractType_.c_children.copy()
    c_attributes = SubjectQueryAbstractType_.c_attributes.copy()
    c_child_order = SubjectQueryAbstractType_.c_child_order[:]
    c_cardinality = SubjectQueryAbstractType_.c_cardinality.copy()
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:protocol}RequestedAuthnContext'] = (
        'requested_authn_context',
        RequestedAuthnContext)
    c_cardinality['requested_authn_context'] = {"min": 0, "max": 1}
    c_attributes['SessionIndex'] = ('session_index', 'string', False)
    c_child_order.extend(['requested_authn_context'])

    def __init__(self,
                 requested_authn_context=None,
                 session_index=None,
                 subject=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SubjectQueryAbstractType_.__init__(self,
                                           subject=subject,
                                           issuer=issuer,
                                           signature=signature,
                                           extensions=extensions,
                                           id=id,
                                           version=version,
                                           issue_instant=issue_instant,
                                           destination=destination,
                                           consent=consent,
                                           text=text,
                                           extension_elements=extension_elements,
                                           extension_attributes=extension_attributes)
        self.requested_authn_context = requested_authn_context
        self.session_index = session_index


def authn_query_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnQueryType_, xml_string)


class IDPList(IDPListType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:IDPList element """

    c_tag = 'IDPList'
    c_namespace = NAMESPACE
    c_children = IDPListType_.c_children.copy()
    c_attributes = IDPListType_.c_attributes.copy()
    c_child_order = IDPListType_.c_child_order[:]
    c_cardinality = IDPListType_.c_cardinality.copy()


def idp_list_from_string(xml_string):
    return saml2.create_class_from_xml_string(IDPList, xml_string)


class ManageNameIDRequest(ManageNameIDRequestType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ManageNameIDRequest element """

    c_tag = 'ManageNameIDRequest'
    c_namespace = NAMESPACE
    c_children = ManageNameIDRequestType_.c_children.copy()
    c_attributes = ManageNameIDRequestType_.c_attributes.copy()
    c_child_order = ManageNameIDRequestType_.c_child_order[:]
    c_cardinality = ManageNameIDRequestType_.c_cardinality.copy()


def manage_name_id_request_from_string(xml_string):
    return saml2.create_class_from_xml_string(ManageNameIDRequest, xml_string)


class AuthnQuery(AuthnQueryType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AuthnQuery element """

    c_tag = 'AuthnQuery'
    c_namespace = NAMESPACE
    c_children = AuthnQueryType_.c_children.copy()
    c_attributes = AuthnQueryType_.c_attributes.copy()
    c_child_order = AuthnQueryType_.c_child_order[:]
    c_cardinality = AuthnQueryType_.c_cardinality.copy()


def authn_query_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnQuery, xml_string)


class ScopingType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ScopingType element """

    c_tag = 'ScopingType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}IDPList'] = (
        'idp_list', IDPList)
    c_cardinality['idp_list'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}RequesterID'] = (
        'requester_id', [RequesterID])
    c_cardinality['requester_id'] = {"min": 0}
    c_attributes['ProxyCount'] = ('proxy_count', 'nonNegativeInteger', False)
    c_child_order.extend(['idp_list', 'requester_id'])

    def __init__(self,
                 idp_list=None,
                 requester_id=None,
                 proxy_count=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.idp_list = idp_list
        self.requester_id = requester_id or []
        self.proxy_count = proxy_count


def scoping_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ScopingType_, xml_string)


class Scoping(ScopingType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:Scoping element """

    c_tag = 'Scoping'
    c_namespace = NAMESPACE
    c_children = ScopingType_.c_children.copy()
    c_attributes = ScopingType_.c_attributes.copy()
    c_child_order = ScopingType_.c_child_order[:]
    c_cardinality = ScopingType_.c_cardinality.copy()


def scoping_from_string(xml_string):
    return saml2.create_class_from_xml_string(Scoping, xml_string)


class AuthnRequestType_(RequestAbstractType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AuthnRequestType element """

    c_tag = 'AuthnRequestType'
    c_namespace = NAMESPACE
    c_children = RequestAbstractType_.c_children.copy()
    c_attributes = RequestAbstractType_.c_attributes.copy()
    c_child_order = RequestAbstractType_.c_child_order[:]
    c_cardinality = RequestAbstractType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Subject'] = (
        'subject', saml.Subject)
    c_cardinality['subject'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}NameIDPolicy'] = (
        'name_id_policy', NameIDPolicy)
    c_cardinality['name_id_policy'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Conditions'] = (
        'conditions', saml.Conditions)
    c_cardinality['conditions'] = {"min": 0, "max": 1}
    c_children[
        '{urn:oasis:names:tc:SAML:2.0:protocol}RequestedAuthnContext'] = (
        'requested_authn_context', RequestedAuthnContext)
    c_cardinality['requested_authn_context'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}Scoping'] = (
        'scoping', Scoping)
    c_cardinality['scoping'] = {"min": 0, "max": 1}
    c_attributes['ForceAuthn'] = ('force_authn', 'boolean', False)
    c_attributes['IsPassive'] = ('is_passive', 'boolean', False)
    c_attributes['ProtocolBinding'] = ('protocol_binding', 'anyURI', False)
    c_attributes['AssertionConsumerServiceIndex'] = (
        'assertion_consumer_service_index', 'unsignedShort', False)
    c_attributes['AssertionConsumerServiceURL'] = (
        'assertion_consumer_service_url', 'anyURI', False)
    c_attributes['AttributeConsumingServiceIndex'] = (
        'attribute_consuming_service_index', 'unsignedShort', False)
    c_attributes['ProviderName'] = ('provider_name', 'string', False)
    c_child_order.extend(['subject', 'name_id_policy', 'conditions',
                          'requested_authn_context', 'scoping'])

    def __init__(self,
                 subject=None,
                 name_id_policy=None,
                 conditions=None,
                 requested_authn_context=None,
                 scoping=None,
                 force_authn=None,
                 is_passive=None,
                 protocol_binding=None,
                 assertion_consumer_service_index=None,
                 assertion_consumer_service_url=None,
                 attribute_consuming_service_index=None,
                 provider_name=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 id=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        RequestAbstractType_.__init__(self,
                                      issuer=issuer,
                                      signature=signature,
                                      extensions=extensions,
                                      id=id,
                                      version=version,
                                      issue_instant=issue_instant,
                                      destination=destination,
                                      consent=consent,
                                      text=text,
                                      extension_elements=extension_elements,
                                      extension_attributes=extension_attributes)
        self.subject = subject
        self.name_id_policy = name_id_policy
        self.conditions = conditions
        self.requested_authn_context = requested_authn_context
        self.scoping = scoping
        self.force_authn = force_authn
        self.is_passive = is_passive
        self.protocol_binding = protocol_binding
        self.assertion_consumer_service_index = assertion_consumer_service_index
        self.assertion_consumer_service_url = assertion_consumer_service_url
        self.attribute_consuming_service_index = attribute_consuming_service_index
        self.provider_name = provider_name


def authn_request_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnRequestType_, xml_string)


class AuthnRequest(AuthnRequestType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:AuthnRequest element """

    c_tag = 'AuthnRequest'
    c_namespace = NAMESPACE
    c_children = AuthnRequestType_.c_children.copy()
    c_attributes = AuthnRequestType_.c_attributes.copy()
    c_child_order = AuthnRequestType_.c_child_order[:]
    c_cardinality = AuthnRequestType_.c_cardinality.copy()


def authn_request_from_string(xml_string):
    return saml2.create_class_from_xml_string(AuthnRequest, xml_string)


class StatusType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:StatusType element """

    c_tag = 'StatusType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    # Added further down to avoid undefined references
    #c_children['{urn:oasis:names:tc:SAML:2.0:protocol}StatusCode'] = (
    # 'status_code', StatusCode)
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}StatusMessage'] = (
        'status_message', StatusMessage)
    c_cardinality['status_message'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}StatusDetail'] = (
        'status_detail', StatusDetail)
    c_cardinality['status_detail'] = {"min": 0, "max": 1}
    c_child_order.extend(['status_code', 'status_message', 'status_detail'])

    def __init__(self,
                 status_code=None,
                 status_message=None,
                 status_detail=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.status_code = status_code
        self.status_message = status_message
        self.status_detail = status_detail


def status_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(StatusType_, xml_string)


class Status(StatusType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:Status element """

    c_tag = 'Status'
    c_namespace = NAMESPACE
    c_children = StatusType_.c_children.copy()
    c_attributes = StatusType_.c_attributes.copy()
    c_child_order = StatusType_.c_child_order[:]
    c_cardinality = StatusType_.c_cardinality.copy()


def status_from_string(xml_string):
    return saml2.create_class_from_xml_string(Status, xml_string)


class StatusResponseType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:StatusResponseType element """

    c_tag = 'StatusResponseType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Issuer'] = (
        'issuer', saml.Issuer)
    c_cardinality['issuer'] = {"min": 0, "max": 1}
    c_children['{http://www.w3.org/2000/09/xmldsig#}Signature'] = (
        'signature', ds.Signature)
    c_cardinality['signature'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}Extensions'] = (
        'extensions', Extensions)
    c_cardinality['extensions'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:protocol}Status'] = (
        'status', Status)
    c_attributes['ID'] = ('id', 'ID', True)
    c_attributes['InResponseTo'] = ('in_response_to', 'NCName', False)
    c_attributes['Version'] = ('version', 'string', True)
    c_attributes['IssueInstant'] = ('issue_instant', 'dateTime', True)
    c_attributes['Destination'] = ('destination', 'anyURI', False)
    c_attributes['Consent'] = ('consent', 'anyURI', False)
    c_child_order.extend(['issuer', 'signature', 'extensions', 'status'])

    def __init__(self,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 status=None,
                 id=None,
                 in_response_to=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.issuer = issuer
        self.signature = signature
        self.extensions = extensions
        self.status = status
        self.id = id
        self.in_response_to = in_response_to
        self.version = version
        self.issue_instant = issue_instant
        self.destination = destination
        self.consent = consent


def status_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(StatusResponseType_, xml_string)


class ResponseType_(StatusResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ResponseType element """

    c_tag = 'ResponseType'
    c_namespace = NAMESPACE
    c_children = StatusResponseType_.c_children.copy()
    c_attributes = StatusResponseType_.c_attributes.copy()
    c_child_order = StatusResponseType_.c_child_order[:]
    c_cardinality = StatusResponseType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}Assertion'] = (
        'assertion', [saml.Assertion])
    c_cardinality['assertion'] = {"min": 0}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedAssertion'] = (
        'encrypted_assertion', [saml.EncryptedAssertion])
    c_cardinality['encrypted_assertion'] = {"min": 0}
    c_child_order.extend(['assertion', 'encrypted_assertion'])

    def __init__(self,
                 assertion=None,
                 encrypted_assertion=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 status=None,
                 id=None,
                 in_response_to=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        StatusResponseType_.__init__(self,
                                     issuer=issuer,
                                     signature=signature,
                                     extensions=extensions,
                                     status=status,
                                     id=id,
                                     in_response_to=in_response_to,
                                     version=version,
                                     issue_instant=issue_instant,
                                     destination=destination,
                                     consent=consent,
                                     text=text,
                                     extension_elements=extension_elements,
                                     extension_attributes=extension_attributes)
        self.assertion = assertion or []
        self.encrypted_assertion = encrypted_assertion or []


def response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ResponseType_, xml_string)


class ArtifactResponseType_(StatusResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ArtifactResponseType element """

    c_tag = 'ArtifactResponseType'
    c_namespace = NAMESPACE
    c_children = StatusResponseType_.c_children.copy()
    c_attributes = StatusResponseType_.c_attributes.copy()
    c_child_order = StatusResponseType_.c_child_order[:]
    c_cardinality = StatusResponseType_.c_cardinality.copy()
    c_any = {"namespace": "##any", "processContents": "lax", "minOccurs": "0"}


def artifact_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(ArtifactResponseType_, xml_string)


class ManageNameIDResponse(StatusResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ManageNameIDResponse element """

    c_tag = 'ManageNameIDResponse'
    c_namespace = NAMESPACE
    c_children = StatusResponseType_.c_children.copy()
    c_attributes = StatusResponseType_.c_attributes.copy()
    c_child_order = StatusResponseType_.c_child_order[:]
    c_cardinality = StatusResponseType_.c_cardinality.copy()


def manage_name_id_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(ManageNameIDResponse, xml_string)


class LogoutResponse(StatusResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:LogoutResponse element """

    c_tag = 'LogoutResponse'
    c_namespace = NAMESPACE
    c_children = StatusResponseType_.c_children.copy()
    c_attributes = StatusResponseType_.c_attributes.copy()
    c_child_order = StatusResponseType_.c_child_order[:]
    c_cardinality = StatusResponseType_.c_cardinality.copy()


def logout_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(LogoutResponse, xml_string)


class NameIDMappingResponseType_(StatusResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:NameIDMappingResponseType element """

    c_tag = 'NameIDMappingResponseType'
    c_namespace = NAMESPACE
    c_children = StatusResponseType_.c_children.copy()
    c_attributes = StatusResponseType_.c_attributes.copy()
    c_child_order = StatusResponseType_.c_child_order[:]
    c_cardinality = StatusResponseType_.c_cardinality.copy()
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}NameID'] = (
        'name_id', saml.NameID)
    c_cardinality['name_id'] = {"min": 0, "max": 1}
    c_children['{urn:oasis:names:tc:SAML:2.0:assertion}EncryptedID'] = (
        'encrypted_id', saml.EncryptedID)
    c_cardinality['encrypted_id'] = {"min": 0, "max": 1}
    c_child_order.extend(['name_id', 'encrypted_id'])

    def __init__(self,
                 name_id=None,
                 encrypted_id=None,
                 issuer=None,
                 signature=None,
                 extensions=None,
                 status=None,
                 id=None,
                 in_response_to=None,
                 version=None,
                 issue_instant=None,
                 destination=None,
                 consent=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        StatusResponseType_.__init__(self,
                                     issuer=issuer,
                                     signature=signature,
                                     extensions=extensions,
                                     status=status,
                                     id=id,
                                     in_response_to=in_response_to,
                                     version=version,
                                     issue_instant=issue_instant,
                                     destination=destination,
                                     consent=consent,
                                     text=text,
                                     extension_elements=extension_elements,
                                     extension_attributes=extension_attributes)
        self.name_id = name_id
        self.encrypted_id = encrypted_id


def name_id_mapping_response_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDMappingResponseType_,
                                              xml_string)


class Response(ResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:Response element """

    c_tag = 'Response'
    c_namespace = NAMESPACE
    c_children = ResponseType_.c_children.copy()
    c_attributes = ResponseType_.c_attributes.copy()
    c_child_order = ResponseType_.c_child_order[:]
    c_cardinality = ResponseType_.c_cardinality.copy()


def response_from_string(xml_string):
    return saml2.create_class_from_xml_string(Response, xml_string)


class ArtifactResponse(ArtifactResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:ArtifactResponse element """

    c_tag = 'ArtifactResponse'
    c_namespace = NAMESPACE
    c_children = ArtifactResponseType_.c_children.copy()
    c_attributes = ArtifactResponseType_.c_attributes.copy()
    c_child_order = ArtifactResponseType_.c_child_order[:]
    c_cardinality = ArtifactResponseType_.c_cardinality.copy()


def artifact_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(ArtifactResponse, xml_string)


class NameIDMappingResponse(NameIDMappingResponseType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:NameIDMappingResponse element """

    c_tag = 'NameIDMappingResponse'
    c_namespace = NAMESPACE
    c_children = NameIDMappingResponseType_.c_children.copy()
    c_attributes = NameIDMappingResponseType_.c_attributes.copy()
    c_child_order = NameIDMappingResponseType_.c_child_order[:]
    c_cardinality = NameIDMappingResponseType_.c_cardinality.copy()


def name_id_mapping_response_from_string(xml_string):
    return saml2.create_class_from_xml_string(NameIDMappingResponse, xml_string)


#..................
# ['StatusCodeType', 'StatusCode']
class StatusCodeType_(SamlBase):
    """The urn:oasis:names:tc:SAML:2.0:protocol:StatusCodeType element """

    c_tag = 'StatusCodeType'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_cardinality['status_code'] = {"min": 0, "max": 1}
    c_attributes['Value'] = ('value', 'anyURI', True)
    c_child_order.extend(['status_code'])

    def __init__(self,
                 status_code=None,
                 value=None,
                 text=None,
                 extension_elements=None,
                 extension_attributes=None):
        SamlBase.__init__(self,
                          text=text,
                          extension_elements=extension_elements,
                          extension_attributes=extension_attributes)
        self.status_code = status_code
        self.value = value


def status_code_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(StatusCodeType_, xml_string)


class StatusCode(StatusCodeType_):
    """The urn:oasis:names:tc:SAML:2.0:protocol:StatusCode element """

    c_tag = 'StatusCode'
    c_namespace = NAMESPACE
    c_children = StatusCodeType_.c_children.copy()
    c_attributes = StatusCodeType_.c_attributes.copy()
    c_child_order = StatusCodeType_.c_child_order[:]
    c_cardinality = StatusCodeType_.c_cardinality.copy()


def status_code_from_string(xml_string):
    return saml2.create_class_from_xml_string(StatusCode, xml_string)


# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
StatusType_.c_children['{urn:oasis:names:tc:SAML:2.0:protocol}StatusCode'] = (
    'status_code', StatusCode)
Status.c_children['{urn:oasis:names:tc:SAML:2.0:protocol}StatusCode'] = (
    'status_code', StatusCode)
StatusCodeType_.c_children[
    '{urn:oasis:names:tc:SAML:2.0:protocol}StatusCode'] = (
    'status_code', StatusCode)
StatusCode.c_children['{urn:oasis:names:tc:SAML:2.0:protocol}StatusCode'] = (
    'status_code', StatusCode)
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

ELEMENT_FROM_STRING = {
    Extensions.c_tag: extensions_from_string,
    ExtensionsType_.c_tag: extensions_type__from_string,
    StatusResponseType_.c_tag: status_response_type__from_string,
    Status.c_tag: status_from_string,
    StatusType_.c_tag: status_type__from_string,
    StatusCode.c_tag: status_code_from_string,
    StatusCodeType_.c_tag: status_code_type__from_string,
    StatusMessage.c_tag: status_message_from_string,
    StatusDetail.c_tag: status_detail_from_string,
    StatusDetailType_.c_tag: status_detail_type__from_string,
    AssertionIDRequest.c_tag: assertion_id_request_from_string,
    AssertionIDRequestType_.c_tag: assertion_id_request_type__from_string,
    SubjectQuery.c_tag: subject_query_from_string,
    AuthnQuery.c_tag: authn_query_from_string,
    AuthnQueryType_.c_tag: authn_query_type__from_string,
    RequestedAuthnContext.c_tag: requested_authn_context_from_string,
    RequestedAuthnContextType_.c_tag: requested_authn_context_type__from_string,
    AuthnContextComparisonType_.c_tag: authn_context_comparison_type__from_string,
    AttributeQuery.c_tag: attribute_query_from_string,
    AttributeQueryType_.c_tag: attribute_query_type__from_string,
    AuthzDecisionQuery.c_tag: authz_decision_query_from_string,
    AuthzDecisionQueryType_.c_tag: authz_decision_query_type__from_string,
    AuthnRequest.c_tag: authn_request_from_string,
    AuthnRequestType_.c_tag: authn_request_type__from_string,
    NameIDPolicy.c_tag: name_id_policy_from_string,
    NameIDPolicyType_.c_tag: name_id_policy_type__from_string,
    Scoping.c_tag: scoping_from_string,
    ScopingType_.c_tag: scoping_type__from_string,
    RequesterID.c_tag: requester_id_from_string,
    IDPList.c_tag: idp_list_from_string,
    IDPListType_.c_tag: idp_list_type__from_string,
    IDPEntry.c_tag: idp_entry_from_string,
    IDPEntryType_.c_tag: idp_entry_type__from_string,
    GetComplete.c_tag: get_complete_from_string,
    Response.c_tag: response_from_string,
    ResponseType_.c_tag: response_type__from_string,
    ArtifactResolve.c_tag: artifact_resolve_from_string,
    ArtifactResolveType_.c_tag: artifact_resolve_type__from_string,
    Artifact.c_tag: artifact_from_string,
    ArtifactResponse.c_tag: artifact_response_from_string,
    ArtifactResponseType_.c_tag: artifact_response_type__from_string,
    ManageNameIDRequest.c_tag: manage_name_id_request_from_string,
    ManageNameIDRequestType_.c_tag: manage_name_id_request_type__from_string,
    NewID.c_tag: new_id_from_string,
    NewEncryptedID.c_tag: new_encrypted_id_from_string,
    Terminate.c_tag: terminate_from_string,
    TerminateType_.c_tag: terminate_type__from_string,
    ManageNameIDResponse.c_tag: manage_name_id_response_from_string,
    LogoutRequest.c_tag: logout_request_from_string,
    LogoutRequestType_.c_tag: logout_request_type__from_string,
    SessionIndex.c_tag: session_index_from_string,
    LogoutResponse.c_tag: logout_response_from_string,
    NameIDMappingRequest.c_tag: name_id_mapping_request_from_string,
    NameIDMappingRequestType_.c_tag: name_id_mapping_request_type__from_string,
    NameIDMappingResponse.c_tag: name_id_mapping_response_from_string,
    NameIDMappingResponseType_.c_tag: name_id_mapping_response_type__from_string,
}

ELEMENT_BY_TAG = {
    'Extensions': Extensions,
    'ExtensionsType': ExtensionsType_,
    'StatusResponseType': StatusResponseType_,
    'Status': Status,
    'StatusType': StatusType_,
    'StatusCode': StatusCode,
    'StatusCodeType': StatusCodeType_,
    'StatusMessage': StatusMessage,
    'StatusDetail': StatusDetail,
    'StatusDetailType': StatusDetailType_,
    'AssertionIDRequest': AssertionIDRequest,
    'AssertionIDRequestType': AssertionIDRequestType_,
    'SubjectQuery': SubjectQuery,
    'AuthnQuery': AuthnQuery,
    'AuthnQueryType': AuthnQueryType_,
    'RequestedAuthnContext': RequestedAuthnContext,
    'RequestedAuthnContextType': RequestedAuthnContextType_,
    'AuthnContextComparisonType': AuthnContextComparisonType_,
    'AttributeQuery': AttributeQuery,
    'AttributeQueryType': AttributeQueryType_,
    'AuthzDecisionQuery': AuthzDecisionQuery,
    'AuthzDecisionQueryType': AuthzDecisionQueryType_,
    'AuthnRequest': AuthnRequest,
    'AuthnRequestType': AuthnRequestType_,
    'NameIDPolicy': NameIDPolicy,
    'NameIDPolicyType': NameIDPolicyType_,
    'Scoping': Scoping,
    'ScopingType': ScopingType_,
    'RequesterID': RequesterID,
    'IDPList': IDPList,
    'IDPListType': IDPListType_,
    'IDPEntry': IDPEntry,
    'IDPEntryType': IDPEntryType_,
    'GetComplete': GetComplete,
    'Response': Response,
    'ResponseType': ResponseType_,
    'ArtifactResolve': ArtifactResolve,
    'ArtifactResolveType': ArtifactResolveType_,
    'Artifact': Artifact,
    'ArtifactResponse': ArtifactResponse,
    'ArtifactResponseType': ArtifactResponseType_,
    'ManageNameIDRequest': ManageNameIDRequest,
    'ManageNameIDRequestType': ManageNameIDRequestType_,
    'NewID': NewID,
    'NewEncryptedID': NewEncryptedID,
    'Terminate': Terminate,
    'TerminateType': TerminateType_,
    'ManageNameIDResponse': ManageNameIDResponse,
    'LogoutRequest': LogoutRequest,
    'LogoutRequestType': LogoutRequestType_,
    'SessionIndex': SessionIndex,
    'LogoutResponse': LogoutResponse,
    'NameIDMappingRequest': NameIDMappingRequest,
    'NameIDMappingRequestType': NameIDMappingRequestType_,
    'NameIDMappingResponse': NameIDMappingResponse,
    'NameIDMappingResponseType': NameIDMappingResponseType_,
    'RequestAbstractType': RequestAbstractType_,
    'SubjectQueryAbstractType': SubjectQueryAbstractType_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


def any_response_from_string(xmlstr):
    resp = None
    for func in [status_response_type__from_string, response_from_string,
                 artifact_response_from_string, logout_response_from_string,
                 name_id_mapping_response_from_string,
                 manage_name_id_response_from_string]:
        resp = func(xmlstr)
        if resp:
            break

    if not resp:
        raise Exception("Unknown response type")
    return resp
########NEW FILE########
__FILENAME__ = soap
#!/usr/bin/env python

#
# Generated Fri May 27 17:23:42 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

from saml2.schema import wsdl

NAMESPACE = 'http://schemas.xmlsoap.org/wsdl/soap/'

class EncodingStyle_(SamlBase):
    """The http://schemas.xmlsoap.org/wsdl/soap/:encodingStyle element """

    c_tag = 'encodingStyle'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def encoding_style__from_string(xml_string):
    return saml2.create_class_from_xml_string(EncodingStyle_, xml_string)


class TStyleChoice_(SamlBase):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tStyleChoice element """

    c_tag = 'tStyleChoice'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:string', 'enumeration': ['rpc', 'document']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def t_style_choice__from_string(xml_string):
    return saml2.create_class_from_xml_string(TStyleChoice_, xml_string)


class TOperation_(wsdl.TExtensibilityElement_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tOperation element """

    c_tag = 'tOperation'
    c_namespace = NAMESPACE
    c_children = wsdl.TExtensibilityElement_.c_children.copy()
    c_attributes = wsdl.TExtensibilityElement_.c_attributes.copy()
    c_child_order = wsdl.TExtensibilityElement_.c_child_order[:]
    c_cardinality = wsdl.TExtensibilityElement_.c_cardinality.copy()
    c_attributes['soapAction'] = ('soap_action', 'anyURI', False)
    c_attributes['style'] = ('style', TStyleChoice_, False)

    def __init__(self,
            soap_action=None,
            style=None,
            required=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        wsdl.TExtensibilityElement_.__init__(self, 
                required=required,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.soap_action=soap_action
        self.style=style

def t_operation__from_string(xml_string):
    return saml2.create_class_from_xml_string(TOperation_, xml_string)


class UseChoice_(SamlBase):
    """The http://schemas.xmlsoap.org/wsdl/soap/:useChoice element """

    c_tag = 'useChoice'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'xs:string', 'enumeration': ['literal', 'encoded']}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def use_choice__from_string(xml_string):
    return saml2.create_class_from_xml_string(UseChoice_, xml_string)


class TFaultRes_(SamlBase):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tFaultRes element """

    c_tag = 'tFaultRes'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['{http://schemas.xmlsoap.org/wsdl/}required'] = ('required', 'None', False)
    c_attributes['parts'] = ('parts', 'NMTOKENS', False)
    c_attributes['encodingStyle'] = ('encoding_style', EncodingStyle_, False)
    c_attributes['use'] = ('use', UseChoice_, False)
    c_attributes['namespace'] = ('namespace', 'anyURI', False)

    def __init__(self,
            required=None,
            parts=None,
            encoding_style=None,
            use=None,
            namespace=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.required=required
        self.parts=parts
        self.encoding_style=encoding_style
        self.use=use
        self.namespace=namespace


class TFault_(TFaultRes_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tFault element """

    c_tag = 'tFault'
    c_namespace = NAMESPACE
    c_children = TFaultRes_.c_children.copy()
    c_attributes = TFaultRes_.c_attributes.copy()
    c_child_order = TFaultRes_.c_child_order[:]
    c_cardinality = TFaultRes_.c_cardinality.copy()
    c_attributes['name'] = ('name', 'NCName', True)

    def __init__(self,
            name=None,
            required=None,
            parts=None,
            encoding_style=None,
            use=None,
            namespace=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TFaultRes_.__init__(self, 
                required=required,
                parts=parts,
                encoding_style=encoding_style,
                use=use,
                namespace=namespace,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.name=name

def t_fault__from_string(xml_string):
    return saml2.create_class_from_xml_string(TFault_, xml_string)


class THeaderFault_(SamlBase):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tHeaderFault element """

    c_tag = 'tHeaderFault'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['message'] = ('message', 'QName', True)
    c_attributes['part'] = ('part', 'NMTOKEN', True)
    c_attributes['use'] = ('use', UseChoice_, True)
    c_attributes['encodingStyle'] = ('encoding_style', EncodingStyle_, False)
    c_attributes['namespace'] = ('namespace', 'anyURI', False)

    def __init__(self,
            message=None,
            part=None,
            use=None,
            encoding_style=None,
            namespace=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.message=message
        self.part=part
        self.use=use
        self.encoding_style=encoding_style
        self.namespace=namespace

def t_header_fault__from_string(xml_string):
    return saml2.create_class_from_xml_string(THeaderFault_, xml_string)


class TAddress_(wsdl.TExtensibilityElement_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tAddress element """

    c_tag = 'tAddress'
    c_namespace = NAMESPACE
    c_children = wsdl.TExtensibilityElement_.c_children.copy()
    c_attributes = wsdl.TExtensibilityElement_.c_attributes.copy()
    c_child_order = wsdl.TExtensibilityElement_.c_child_order[:]
    c_cardinality = wsdl.TExtensibilityElement_.c_cardinality.copy()
    c_attributes['location'] = ('location', 'anyURI', True)

    def __init__(self,
            location=None,
            required=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        wsdl.TExtensibilityElement_.__init__(self, 
                required=required,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.location=location

def t_address__from_string(xml_string):
    return saml2.create_class_from_xml_string(TAddress_, xml_string)


class TBinding_(wsdl.TExtensibilityElement_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tBinding element """

    c_tag = 'tBinding'
    c_namespace = NAMESPACE
    c_children = wsdl.TExtensibilityElement_.c_children.copy()
    c_attributes = wsdl.TExtensibilityElement_.c_attributes.copy()
    c_child_order = wsdl.TExtensibilityElement_.c_child_order[:]
    c_cardinality = wsdl.TExtensibilityElement_.c_cardinality.copy()
    c_attributes['transport'] = ('transport', 'anyURI', True)
    c_attributes['style'] = ('style', TStyleChoice_, False)

    def __init__(self,
            transport=None,
            style=None,
            required=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        wsdl.TExtensibilityElement_.__init__(self, 
                required=required,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.transport=transport
        self.style=style

def t_binding__from_string(xml_string):
    return saml2.create_class_from_xml_string(TBinding_, xml_string)


class Operation(TOperation_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:operation element """

    c_tag = 'operation'
    c_namespace = NAMESPACE
    c_children = TOperation_.c_children.copy()
    c_attributes = TOperation_.c_attributes.copy()
    c_child_order = TOperation_.c_child_order[:]
    c_cardinality = TOperation_.c_cardinality.copy()

def operation_from_string(xml_string):
    return saml2.create_class_from_xml_string(Operation, xml_string)


class TBody_(wsdl.TExtensibilityElement_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tBody element """

    c_tag = 'tBody'
    c_namespace = NAMESPACE
    c_children = wsdl.TExtensibilityElement_.c_children.copy()
    c_attributes = wsdl.TExtensibilityElement_.c_attributes.copy()
    c_child_order = wsdl.TExtensibilityElement_.c_child_order[:]
    c_cardinality = wsdl.TExtensibilityElement_.c_cardinality.copy()
    c_attributes['parts'] = ('parts', 'NMTOKENS', False)
    c_attributes['encodingStyle'] = ('encoding_style', EncodingStyle_, False)
    c_attributes['use'] = ('use', UseChoice_, False)
    c_attributes['namespace'] = ('namespace', 'anyURI', False)

    def __init__(self,
            parts=None,
            encoding_style=None,
            use=None,
            namespace=None,
            required=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        wsdl.TExtensibilityElement_.__init__(self, 
                required=required,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.parts=parts
        self.encoding_style=encoding_style
        self.use=use
        self.namespace=namespace

def t_body__from_string(xml_string):
    return saml2.create_class_from_xml_string(TBody_, xml_string)


class Fault(TFault_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:fault element """

    c_tag = 'fault'
    c_namespace = NAMESPACE
    c_children = TFault_.c_children.copy()
    c_attributes = TFault_.c_attributes.copy()
    c_child_order = TFault_.c_child_order[:]
    c_cardinality = TFault_.c_cardinality.copy()

def fault_from_string(xml_string):
    return saml2.create_class_from_xml_string(Fault, xml_string)


class Headerfault(THeaderFault_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:headerfault element """

    c_tag = 'headerfault'
    c_namespace = NAMESPACE
    c_children = THeaderFault_.c_children.copy()
    c_attributes = THeaderFault_.c_attributes.copy()
    c_child_order = THeaderFault_.c_child_order[:]
    c_cardinality = THeaderFault_.c_cardinality.copy()

def headerfault_from_string(xml_string):
    return saml2.create_class_from_xml_string(Headerfault, xml_string)


class Address(TAddress_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:address element """

    c_tag = 'address'
    c_namespace = NAMESPACE
    c_children = TAddress_.c_children.copy()
    c_attributes = TAddress_.c_attributes.copy()
    c_child_order = TAddress_.c_child_order[:]
    c_cardinality = TAddress_.c_cardinality.copy()

def address_from_string(xml_string):
    return saml2.create_class_from_xml_string(Address, xml_string)


class Binding(TBinding_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:binding element """

    c_tag = 'binding'
    c_namespace = NAMESPACE
    c_children = TBinding_.c_children.copy()
    c_attributes = TBinding_.c_attributes.copy()
    c_child_order = TBinding_.c_child_order[:]
    c_cardinality = TBinding_.c_cardinality.copy()

def binding_from_string(xml_string):
    return saml2.create_class_from_xml_string(Binding, xml_string)


class Body(TBody_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:body element """

    c_tag = 'body'
    c_namespace = NAMESPACE
    c_children = TBody_.c_children.copy()
    c_attributes = TBody_.c_attributes.copy()
    c_child_order = TBody_.c_child_order[:]
    c_cardinality = TBody_.c_cardinality.copy()

def body_from_string(xml_string):
    return saml2.create_class_from_xml_string(Body, xml_string)


class THeader_(wsdl.TExtensibilityElement_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:tHeader element """

    c_tag = 'tHeader'
    c_namespace = NAMESPACE
    c_children = wsdl.TExtensibilityElement_.c_children.copy()
    c_attributes = wsdl.TExtensibilityElement_.c_attributes.copy()
    c_child_order = wsdl.TExtensibilityElement_.c_child_order[:]
    c_cardinality = wsdl.TExtensibilityElement_.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/wsdl/soap/}headerfault'] = ('headerfault', [Headerfault])
    c_cardinality['headerfault'] = {"min":0}
    c_attributes['message'] = ('message', 'QName', True)
    c_attributes['part'] = ('part', 'NMTOKEN', True)
    c_attributes['use'] = ('use', UseChoice_, True)
    c_attributes['encodingStyle'] = ('encoding_style', EncodingStyle_, False)
    c_attributes['namespace'] = ('namespace', 'anyURI', False)
    c_child_order.extend(['headerfault'])

    def __init__(self,
            headerfault=None,
            message=None,
            part=None,
            use=None,
            encoding_style=None,
            namespace=None,
            required=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        wsdl.TExtensibilityElement_.__init__(self, 
                required=required,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.headerfault=headerfault or []
        self.message=message
        self.part=part
        self.use=use
        self.encoding_style=encoding_style
        self.namespace=namespace

def t_header__from_string(xml_string):
    return saml2.create_class_from_xml_string(THeader_, xml_string)


class Header(THeader_):
    """The http://schemas.xmlsoap.org/wsdl/soap/:header element """

    c_tag = 'header'
    c_namespace = NAMESPACE
    c_children = THeader_.c_children.copy()
    c_attributes = THeader_.c_attributes.copy()
    c_child_order = THeader_.c_child_order[:]
    c_cardinality = THeader_.c_cardinality.copy()

def header_from_string(xml_string):
    return saml2.create_class_from_xml_string(Header, xml_string)


AG_tBodyAttributes = [
    ('encodingStyle', EncodingStyle_, False),
    ('use', UseChoice_, False),
    ('namespace', 'anyURI', False),
]

AG_tHeaderAttributes = [
    ('message', 'QName', True),
    ('part', 'NMTOKEN', True),
    ('use', UseChoice_, True),
    ('encodingStyle', EncodingStyle_, False),
    ('namespace', 'anyURI', False),
]

ELEMENT_FROM_STRING = {
    EncodingStyle_.c_tag: encoding_style__from_string,
    Binding.c_tag: binding_from_string,
    TBinding_.c_tag: t_binding__from_string,
    TStyleChoice_.c_tag: t_style_choice__from_string,
    Operation.c_tag: operation_from_string,
    TOperation_.c_tag: t_operation__from_string,
    Body.c_tag: body_from_string,
    TBody_.c_tag: t_body__from_string,
    UseChoice_.c_tag: use_choice__from_string,
    Fault.c_tag: fault_from_string,
    TFault_.c_tag: t_fault__from_string,
    Header.c_tag: header_from_string,
    THeader_.c_tag: t_header__from_string,
    Headerfault.c_tag: headerfault_from_string,
    THeaderFault_.c_tag: t_header_fault__from_string,
    Address.c_tag: address_from_string,
    TAddress_.c_tag: t_address__from_string,
}

ELEMENT_BY_TAG = {
    'encodingStyle': EncodingStyle_,
    'binding': Binding,
    'tBinding': TBinding_,
    'tStyleChoice': TStyleChoice_,
    'operation': Operation,
    'tOperation': TOperation_,
    'body': Body,
    'tBody': TBody_,
    'useChoice': UseChoice_,
    'fault': Fault,
    'tFault': TFault_,
    'header': Header,
    'tHeader': THeader_,
    'headerfault': Headerfault,
    'tHeaderFault': THeaderFault_,
    'address': Address,
    'tAddress': TAddress_,
    'tFaultRes': TFaultRes_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = soapenv
#!/usr/bin/env python

#
# Generated Fri May 27 17:26:51 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase

NAMESPACE = 'http://schemas.xmlsoap.org/soap/envelope/'

class Header_(SamlBase):
    """The http://schemas.xmlsoap.org/soap/envelope/:Header element """

    c_tag = 'Header'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def header__from_string(xml_string):
    return saml2.create_class_from_xml_string(Header_, xml_string)


class Body_(SamlBase):
    """The http://schemas.xmlsoap.org/soap/envelope/:Body element """

    c_tag = 'Body'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def body__from_string(xml_string):
    return saml2.create_class_from_xml_string(Body_, xml_string)


class EncodingStyle_(SamlBase):
    """The http://schemas.xmlsoap.org/soap/envelope/:encodingStyle element """

    c_tag = 'encodingStyle'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def encoding_style__from_string(xml_string):
    return saml2.create_class_from_xml_string(EncodingStyle_, xml_string)


class Fault_faultcode(SamlBase):

    c_tag = 'faultcode'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'QName'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def fault_faultcode_from_string(xml_string):
    return saml2.create_class_from_xml_string(Fault_faultcode, xml_string)


class Fault_faultstring(SamlBase):

    c_tag = 'faultstring'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'string'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def fault_faultstring_from_string(xml_string):
    return saml2.create_class_from_xml_string(Fault_faultstring, xml_string)


class Fault_faultactor(SamlBase):

    c_tag = 'faultactor'
    c_namespace = NAMESPACE
    c_value_type = {'base': 'anyURI'}
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def fault_faultactor_from_string(xml_string):
    return saml2.create_class_from_xml_string(Fault_faultactor, xml_string)


class Detail_(SamlBase):
    """The http://schemas.xmlsoap.org/soap/envelope/:detail element """

    c_tag = 'detail'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def detail__from_string(xml_string):
    return saml2.create_class_from_xml_string(Detail_, xml_string)


class Envelope_(SamlBase):
    """The http://schemas.xmlsoap.org/soap/envelope/:Envelope element """

    c_tag = 'Envelope'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/soap/envelope/}Header'] = ('header', Header_)
    c_cardinality['header'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/soap/envelope/}Body'] = ('body', Body_)
    c_child_order.extend(['header', 'body'])

    def __init__(self,
            header=None,
            body=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.header=header
        self.body=body

def envelope__from_string(xml_string):
    return saml2.create_class_from_xml_string(Envelope_, xml_string)


class Header(Header_):
    """The http://schemas.xmlsoap.org/soap/envelope/:Header element """

    c_tag = 'Header'
    c_namespace = NAMESPACE
    c_children = Header_.c_children.copy()
    c_attributes = Header_.c_attributes.copy()
    c_child_order = Header_.c_child_order[:]
    c_cardinality = Header_.c_cardinality.copy()

def header_from_string(xml_string):
    return saml2.create_class_from_xml_string(Header, xml_string)


class Body(Body_):
    """The http://schemas.xmlsoap.org/soap/envelope/:Body element """

    c_tag = 'Body'
    c_namespace = NAMESPACE
    c_children = Body_.c_children.copy()
    c_attributes = Body_.c_attributes.copy()
    c_child_order = Body_.c_child_order[:]
    c_cardinality = Body_.c_cardinality.copy()

def body_from_string(xml_string):
    return saml2.create_class_from_xml_string(Body, xml_string)


class Fault_detail(Detail_):

    c_tag = 'detail'
    c_namespace = NAMESPACE
    c_children = Detail_.c_children.copy()
    c_attributes = Detail_.c_attributes.copy()
    c_child_order = Detail_.c_child_order[:]
    c_cardinality = Detail_.c_cardinality.copy()

def fault_detail_from_string(xml_string):
    return saml2.create_class_from_xml_string(Fault_detail, xml_string)


class Fault_(SamlBase):
    """The http://schemas.xmlsoap.org/soap/envelope/:Fault element """

    c_tag = 'Fault'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/soap/envelope/}faultcode'] = ('faultcode', Fault_faultcode)
    c_children['{http://schemas.xmlsoap.org/soap/envelope/}faultstring'] = ('faultstring', Fault_faultstring)
    c_children['{http://schemas.xmlsoap.org/soap/envelope/}faultactor'] = ('faultactor', Fault_faultactor)
    c_cardinality['faultactor'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/soap/envelope/}detail'] = ('detail', Fault_detail)
    c_cardinality['detail'] = {"min":0, "max":1}
    c_child_order.extend(['faultcode', 'faultstring', 'faultactor', 'detail'])

    def __init__(self,
            faultcode=None,
            faultstring=None,
            faultactor=None,
            detail=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.faultcode=faultcode
        self.faultstring=faultstring
        self.faultactor=faultactor
        self.detail=detail

def fault__from_string(xml_string):
    return saml2.create_class_from_xml_string(Fault_, xml_string)


class Envelope(Envelope_):
    """The http://schemas.xmlsoap.org/soap/envelope/:Envelope element """

    c_tag = 'Envelope'
    c_namespace = NAMESPACE
    c_children = Envelope_.c_children.copy()
    c_attributes = Envelope_.c_attributes.copy()
    c_child_order = Envelope_.c_child_order[:]
    c_cardinality = Envelope_.c_cardinality.copy()

def envelope_from_string(xml_string):
    return saml2.create_class_from_xml_string(Envelope, xml_string)


class Fault(Fault_):
    """The http://schemas.xmlsoap.org/soap/envelope/:Fault element """

    c_tag = 'Fault'
    c_namespace = NAMESPACE
    c_children = Fault_.c_children.copy()
    c_attributes = Fault_.c_attributes.copy()
    c_child_order = Fault_.c_child_order[:]
    c_cardinality = Fault_.c_cardinality.copy()

def fault_from_string(xml_string):
    return saml2.create_class_from_xml_string(Fault, xml_string)


#..................
# []
AG_encodingStyle = [
    ('encodingStyle', '', False),
]

ELEMENT_FROM_STRING = {
    Envelope.c_tag: envelope_from_string,
    Envelope_.c_tag: envelope__from_string,
    Header.c_tag: header_from_string,
    Header_.c_tag: header__from_string,
    Body.c_tag: body_from_string,
    Body_.c_tag: body__from_string,
    EncodingStyle_.c_tag: encoding_style__from_string,
    Fault.c_tag: fault_from_string,
    Fault_.c_tag: fault__from_string,
    Detail_.c_tag: detail__from_string,
    Fault_faultcode.c_tag: fault_faultcode_from_string,
    Fault_faultstring.c_tag: fault_faultstring_from_string,
    Fault_faultactor.c_tag: fault_faultactor_from_string,
}

ELEMENT_BY_TAG = {
    'Envelope': Envelope,
    'Envelope': Envelope_,
    'Header': Header,
    'Header': Header_,
    'Body': Body,
    'Body': Body_,
    'encodingStyle': EncodingStyle_,
    'Fault': Fault,
    'Fault': Fault_,
    'detail': Detail_,
    'faultcode': Fault_faultcode,
    'faultstring': Fault_faultstring,
    'faultactor': Fault_faultactor,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = wsdl
#!!!! 'NoneType' object has no attribute 'py_class'
#!!!! 'NoneType' object has no attribute 'py_class'
#!/usr/bin/env python

#
# Generated Fri May 27 17:23:24 2011 by parse_xsd.py version 0.4.
#

import saml2
from saml2 import SamlBase


NAMESPACE = 'http://schemas.xmlsoap.org/wsdl/'

class TDocumentation_(SamlBase):
    """The http://schemas.xmlsoap.org/wsdl/:tDocumentation element """

    c_tag = 'tDocumentation'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()

def t_documentation__from_string(xml_string):
    return saml2.create_class_from_xml_string(TDocumentation_, xml_string)


class TDocumented_documentation(TDocumentation_):

    c_tag = 'documentation'
    c_namespace = NAMESPACE
    c_children = TDocumentation_.c_children.copy()
    c_attributes = TDocumentation_.c_attributes.copy()
    c_child_order = TDocumentation_.c_child_order[:]
    c_cardinality = TDocumentation_.c_cardinality.copy()

def t_documented_documentation_from_string(xml_string):
    return saml2.create_class_from_xml_string(TDocumented_documentation, xml_string)


class TDocumented_(SamlBase):
    """The http://schemas.xmlsoap.org/wsdl/:tDocumented element """

    c_tag = 'tDocumented'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/wsdl/}documentation'] = ('documentation', TDocumented_documentation)
    c_cardinality['documentation'] = {"min":0, "max":1}
    c_child_order.extend(['documentation'])

    def __init__(self,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.documentation=documentation

def t_documented__from_string(xml_string):
    return saml2.create_class_from_xml_string(TDocumented_, xml_string)


class TExtensibleAttributesDocumented_(TDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tExtensibleAttributesDocumented element """

    c_tag = 'tExtensibleAttributesDocumented'
    c_namespace = NAMESPACE
    c_children = TDocumented_.c_children.copy()
    c_attributes = TDocumented_.c_attributes.copy()
    c_child_order = TDocumented_.c_child_order[:]
    c_cardinality = TDocumented_.c_cardinality.copy()


class TExtensibleDocumented_(TDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tExtensibleDocumented element """

    c_tag = 'tExtensibleDocumented'
    c_namespace = NAMESPACE
    c_children = TDocumented_.c_children.copy()
    c_attributes = TDocumented_.c_attributes.copy()
    c_child_order = TDocumented_.c_child_order[:]
    c_cardinality = TDocumented_.c_cardinality.copy()


class TImport_(TExtensibleAttributesDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tImport element """

    c_tag = 'tImport'
    c_namespace = NAMESPACE
    c_children = TExtensibleAttributesDocumented_.c_children.copy()
    c_attributes = TExtensibleAttributesDocumented_.c_attributes.copy()
    c_child_order = TExtensibleAttributesDocumented_.c_child_order[:]
    c_cardinality = TExtensibleAttributesDocumented_.c_cardinality.copy()
    c_attributes['namespace'] = ('namespace', 'anyURI', True)
    c_attributes['location'] = ('location', 'anyURI', True)

    def __init__(self,
            namespace=None,
            location=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleAttributesDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.namespace=namespace
        self.location=location

def t_import__from_string(xml_string):
    return saml2.create_class_from_xml_string(TImport_, xml_string)


class TTypes_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tTypes element """

    c_tag = 'tTypes'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()

def t_types__from_string(xml_string):
    return saml2.create_class_from_xml_string(TTypes_, xml_string)


class TPart_(TExtensibleAttributesDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tPart element """

    c_tag = 'tPart'
    c_namespace = NAMESPACE
    c_children = TExtensibleAttributesDocumented_.c_children.copy()
    c_attributes = TExtensibleAttributesDocumented_.c_attributes.copy()
    c_child_order = TExtensibleAttributesDocumented_.c_child_order[:]
    c_cardinality = TExtensibleAttributesDocumented_.c_cardinality.copy()
    c_attributes['name'] = ('name', 'NCName', True)
    c_attributes['element'] = ('element', 'QName', False)
    c_attributes['type'] = ('type', 'QName', False)

    def __init__(self,
            name=None,
            element=None,
            type=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleAttributesDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.name=name
        self.element=element
        self.type=type

def t_part__from_string(xml_string):
    return saml2.create_class_from_xml_string(TPart_, xml_string)


class TOperation_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tOperation element """

    c_tag = 'tOperation'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_attributes['name'] = ('name', 'NCName', True)
    c_attributes['parameterOrder'] = ('parameter_order', 'NMTOKENS', False)

    def __init__(self,
            name=None,
            parameter_order=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.name=name
        self.parameter_order=parameter_order

def t_operation__from_string(xml_string):
    return saml2.create_class_from_xml_string(TOperation_, xml_string)


class TParam_(TExtensibleAttributesDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tParam element """

    c_tag = 'tParam'
    c_namespace = NAMESPACE
    c_children = TExtensibleAttributesDocumented_.c_children.copy()
    c_attributes = TExtensibleAttributesDocumented_.c_attributes.copy()
    c_child_order = TExtensibleAttributesDocumented_.c_child_order[:]
    c_cardinality = TExtensibleAttributesDocumented_.c_cardinality.copy()
    c_attributes['name'] = ('name', 'NCName', False)
    c_attributes['message'] = ('message', 'QName', True)

    def __init__(self,
            name=None,
            message=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleAttributesDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.name=name
        self.message=message

def t_param__from_string(xml_string):
    return saml2.create_class_from_xml_string(TParam_, xml_string)


class TFault_(TExtensibleAttributesDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tFault element """

    c_tag = 'tFault'
    c_namespace = NAMESPACE
    c_children = TExtensibleAttributesDocumented_.c_children.copy()
    c_attributes = TExtensibleAttributesDocumented_.c_attributes.copy()
    c_child_order = TExtensibleAttributesDocumented_.c_child_order[:]
    c_cardinality = TExtensibleAttributesDocumented_.c_cardinality.copy()
    c_attributes['name'] = ('name', 'NCName', True)
    c_attributes['message'] = ('message', 'QName', True)

    def __init__(self,
            name=None,
            message=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleAttributesDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.name=name
        self.message=message

def t_fault__from_string(xml_string):
    return saml2.create_class_from_xml_string(TFault_, xml_string)


class TBindingOperationMessage_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tBindingOperationMessage element """

    c_tag = 'tBindingOperationMessage'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_attributes['name'] = ('name', 'NCName', False)

    def __init__(self,
            name=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.name=name

def t_binding_operation_message__from_string(xml_string):
    return saml2.create_class_from_xml_string(TBindingOperationMessage_, xml_string)


class TBindingOperationFault_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tBindingOperationFault element """

    c_tag = 'tBindingOperationFault'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_attributes['name'] = ('name', 'NCName', True)

    def __init__(self,
            name=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.name=name

def t_binding_operation_fault__from_string(xml_string):
    return saml2.create_class_from_xml_string(TBindingOperationFault_, xml_string)


class TBindingOperation_input(TBindingOperationMessage_):

    c_tag = 'input'
    c_namespace = NAMESPACE
    c_children = TBindingOperationMessage_.c_children.copy()
    c_attributes = TBindingOperationMessage_.c_attributes.copy()
    c_child_order = TBindingOperationMessage_.c_child_order[:]
    c_cardinality = TBindingOperationMessage_.c_cardinality.copy()

def t_binding_operation_input_from_string(xml_string):
    return saml2.create_class_from_xml_string(TBindingOperation_input, xml_string)


class TBindingOperation_output(TBindingOperationMessage_):

    c_tag = 'output'
    c_namespace = NAMESPACE
    c_children = TBindingOperationMessage_.c_children.copy()
    c_attributes = TBindingOperationMessage_.c_attributes.copy()
    c_child_order = TBindingOperationMessage_.c_child_order[:]
    c_cardinality = TBindingOperationMessage_.c_cardinality.copy()

def t_binding_operation_output_from_string(xml_string):
    return saml2.create_class_from_xml_string(TBindingOperation_output, xml_string)


class TBindingOperation_fault(TBindingOperationFault_):

    c_tag = 'fault'
    c_namespace = NAMESPACE
    c_children = TBindingOperationFault_.c_children.copy()
    c_attributes = TBindingOperationFault_.c_attributes.copy()
    c_child_order = TBindingOperationFault_.c_child_order[:]
    c_cardinality = TBindingOperationFault_.c_cardinality.copy()

def t_binding_operation_fault_from_string(xml_string):
    return saml2.create_class_from_xml_string(TBindingOperation_fault, xml_string)


class TBindingOperation_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tBindingOperation element """

    c_tag = 'tBindingOperation'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/wsdl/}input'] = ('input', TBindingOperation_input)
    c_cardinality['input'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/wsdl/}output'] = ('output', TBindingOperation_output)
    c_cardinality['output'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/wsdl/}fault'] = ('fault', [TBindingOperation_fault])
    c_cardinality['fault'] = {"min":0}
    c_attributes['name'] = ('name', 'NCName', True)
    c_child_order.extend(['input', 'output', 'fault'])

    def __init__(self,
            input=None,
            output=None,
            fault=None,
            name=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.input=input
        self.output=output
        self.fault=fault or []
        self.name=name

def t_binding_operation__from_string(xml_string):
    return saml2.create_class_from_xml_string(TBindingOperation_, xml_string)


class TPort_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tPort element """

    c_tag = 'tPort'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_attributes['name'] = ('name', 'NCName', True)
    c_attributes['binding'] = ('binding', 'QName', True)

    def __init__(self,
            name=None,
            binding=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.name=name
        self.binding=binding

def t_port__from_string(xml_string):
    return saml2.create_class_from_xml_string(TPort_, xml_string)


class TExtensibilityElement_(SamlBase):
    """The http://schemas.xmlsoap.org/wsdl/:tExtensibilityElement element """

    c_tag = 'tExtensibilityElement'
    c_namespace = NAMESPACE
    c_children = SamlBase.c_children.copy()
    c_attributes = SamlBase.c_attributes.copy()
    c_child_order = SamlBase.c_child_order[:]
    c_cardinality = SamlBase.c_cardinality.copy()
    c_attributes['required'] = ('required', 'None', False)

    def __init__(self,
            required=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        SamlBase.__init__(self, 
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.required=required


class Import(TImport_):
    """The http://schemas.xmlsoap.org/wsdl/:import element """

    c_tag = 'import'
    c_namespace = NAMESPACE
    c_children = TImport_.c_children.copy()
    c_attributes = TImport_.c_attributes.copy()
    c_child_order = TImport_.c_child_order[:]
    c_cardinality = TImport_.c_cardinality.copy()

def import_from_string(xml_string):
    return saml2.create_class_from_xml_string(Import, xml_string)


class Types(TTypes_):
    """The http://schemas.xmlsoap.org/wsdl/:types element """

    c_tag = 'types'
    c_namespace = NAMESPACE
    c_children = TTypes_.c_children.copy()
    c_attributes = TTypes_.c_attributes.copy()
    c_child_order = TTypes_.c_child_order[:]
    c_cardinality = TTypes_.c_cardinality.copy()

def types_from_string(xml_string):
    return saml2.create_class_from_xml_string(Types, xml_string)


class TMessage_part(TPart_):

    c_tag = 'part'
    c_namespace = NAMESPACE
    c_children = TPart_.c_children.copy()
    c_attributes = TPart_.c_attributes.copy()
    c_child_order = TPart_.c_child_order[:]
    c_cardinality = TPart_.c_cardinality.copy()

def t_message_part_from_string(xml_string):
    return saml2.create_class_from_xml_string(TMessage_part, xml_string)


class TMessage_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tMessage element """

    c_tag = 'tMessage'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/wsdl/}part'] = ('part', [TMessage_part])
    c_cardinality['part'] = {"min":0}
    c_attributes['name'] = ('name', 'NCName', True)
    c_child_order.extend(['part'])

    def __init__(self,
            part=None,
            name=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.part=part or []
        self.name=name

def t_message__from_string(xml_string):
    return saml2.create_class_from_xml_string(TMessage_, xml_string)


class TPortType_operation(TOperation_):

    c_tag = 'operation'
    c_namespace = NAMESPACE
    c_children = TOperation_.c_children.copy()
    c_attributes = TOperation_.c_attributes.copy()
    c_child_order = TOperation_.c_child_order[:]
    c_cardinality = TOperation_.c_cardinality.copy()

def t_port_type_operation_from_string(xml_string):
    return saml2.create_class_from_xml_string(TPortType_operation, xml_string)


class TPortType_(TExtensibleAttributesDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tPortType element """

    c_tag = 'tPortType'
    c_namespace = NAMESPACE
    c_children = TExtensibleAttributesDocumented_.c_children.copy()
    c_attributes = TExtensibleAttributesDocumented_.c_attributes.copy()
    c_child_order = TExtensibleAttributesDocumented_.c_child_order[:]
    c_cardinality = TExtensibleAttributesDocumented_.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/wsdl/}operation'] = ('operation', [TPortType_operation])
    c_cardinality['operation'] = {"min":0}
    c_attributes['name'] = ('name', 'NCName', True)
    c_child_order.extend(['operation'])

    def __init__(self,
            operation=None,
            name=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleAttributesDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.operation=operation or []
        self.name=name

def t_port_type__from_string(xml_string):
    return saml2.create_class_from_xml_string(TPortType_, xml_string)


class TBinding_operation(TBindingOperation_):

    c_tag = 'operation'
    c_namespace = NAMESPACE
    c_children = TBindingOperation_.c_children.copy()
    c_attributes = TBindingOperation_.c_attributes.copy()
    c_child_order = TBindingOperation_.c_child_order[:]
    c_cardinality = TBindingOperation_.c_cardinality.copy()

def t_binding_operation_from_string(xml_string):
    return saml2.create_class_from_xml_string(TBinding_operation, xml_string)


class TBinding_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tBinding element """

    c_tag = 'tBinding'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/wsdl/}operation'] = ('operation', [TBinding_operation])
    c_cardinality['operation'] = {"min":0}
    c_attributes['name'] = ('name', 'NCName', True)
    c_attributes['type'] = ('type', 'QName', True)
    c_child_order.extend(['operation'])

    def __init__(self,
            operation=None,
            name=None,
            type=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.operation=operation or []
        self.name=name
        self.type=type

def t_binding__from_string(xml_string):
    return saml2.create_class_from_xml_string(TBinding_, xml_string)


class TService_port(TPort_):

    c_tag = 'port'
    c_namespace = NAMESPACE
    c_children = TPort_.c_children.copy()
    c_attributes = TPort_.c_attributes.copy()
    c_child_order = TPort_.c_child_order[:]
    c_cardinality = TPort_.c_cardinality.copy()

def t_service_port_from_string(xml_string):
    return saml2.create_class_from_xml_string(TService_port, xml_string)


class TService_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tService element """

    c_tag = 'tService'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/wsdl/}port'] = ('port', [TService_port])
    c_cardinality['port'] = {"min":0}
    c_attributes['name'] = ('name', 'NCName', True)
    c_child_order.extend(['port'])

    def __init__(self,
            port=None,
            name=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.port=port or []
        self.name=name

def t_service__from_string(xml_string):
    return saml2.create_class_from_xml_string(TService_, xml_string)


class Message(TMessage_):
    """The http://schemas.xmlsoap.org/wsdl/:message element """

    c_tag = 'message'
    c_namespace = NAMESPACE
    c_children = TMessage_.c_children.copy()
    c_attributes = TMessage_.c_attributes.copy()
    c_child_order = TMessage_.c_child_order[:]
    c_cardinality = TMessage_.c_cardinality.copy()

def message_from_string(xml_string):
    return saml2.create_class_from_xml_string(Message, xml_string)


class PortType(TPortType_):
    """The http://schemas.xmlsoap.org/wsdl/:portType element """

    c_tag = 'portType'
    c_namespace = NAMESPACE
    c_children = TPortType_.c_children.copy()
    c_attributes = TPortType_.c_attributes.copy()
    c_child_order = TPortType_.c_child_order[:]
    c_cardinality = TPortType_.c_cardinality.copy()

def port_type_from_string(xml_string):
    return saml2.create_class_from_xml_string(PortType, xml_string)


class Binding(TBinding_):
    """The http://schemas.xmlsoap.org/wsdl/:binding element """

    c_tag = 'binding'
    c_namespace = NAMESPACE
    c_children = TBinding_.c_children.copy()
    c_attributes = TBinding_.c_attributes.copy()
    c_child_order = TBinding_.c_child_order[:]
    c_cardinality = TBinding_.c_cardinality.copy()

def binding_from_string(xml_string):
    return saml2.create_class_from_xml_string(Binding, xml_string)


class Service(TService_):
    """The http://schemas.xmlsoap.org/wsdl/:service element """

    c_tag = 'service'
    c_namespace = NAMESPACE
    c_children = TService_.c_children.copy()
    c_attributes = TService_.c_attributes.copy()
    c_child_order = TService_.c_child_order[:]
    c_cardinality = TService_.c_cardinality.copy()

def service_from_string(xml_string):
    return saml2.create_class_from_xml_string(Service, xml_string)


class TDefinitions_(TExtensibleDocumented_):
    """The http://schemas.xmlsoap.org/wsdl/:tDefinitions element """

    c_tag = 'tDefinitions'
    c_namespace = NAMESPACE
    c_children = TExtensibleDocumented_.c_children.copy()
    c_attributes = TExtensibleDocumented_.c_attributes.copy()
    c_child_order = TExtensibleDocumented_.c_child_order[:]
    c_cardinality = TExtensibleDocumented_.c_cardinality.copy()
    c_children['{http://schemas.xmlsoap.org/wsdl/}import'] = ('import', Import)
    c_cardinality['import'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/wsdl/}types'] = ('types', Types)
    c_cardinality['types'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/wsdl/}message'] = ('message', Message)
    c_cardinality['message'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/wsdl/}portType'] = ('port_type', PortType)
    c_cardinality['port_type'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/wsdl/}binding'] = ('binding', Binding)
    c_cardinality['binding'] = {"min":0, "max":1}
    c_children['{http://schemas.xmlsoap.org/wsdl/}service'] = ('service', Service)
    c_cardinality['service'] = {"min":0, "max":1}
    c_attributes['targetNamespace'] = ('target_namespace', 'anyURI', False)
    c_attributes['name'] = ('name', 'NCName', False)
    c_child_order.extend(['import', 'types', 'message', 'port_type', 'binding', 'service'])

    def __init__(self,
            import_=None,
            types=None,
            message=None,
            port_type=None,
            binding=None,
            service=None,
            target_namespace=None,
            name=None,
            documentation=None,
            text=None,
            extension_elements=None,
            extension_attributes=None,
        ):
        TExtensibleDocumented_.__init__(self, 
                documentation=documentation,
                text=text,
                extension_elements=extension_elements,
                extension_attributes=extension_attributes,
                )
        self.import_=import_
        self.types=types
        self.message=message
        self.port_type=port_type
        self.binding=binding
        self.service=service
        self.target_namespace=target_namespace
        self.name=name

def t_definitions__from_string(xml_string):
    return saml2.create_class_from_xml_string(TDefinitions_, xml_string)


class Definitions(TDefinitions_):
    """The http://schemas.xmlsoap.org/wsdl/:definitions element """

    c_tag = 'definitions'
    c_namespace = NAMESPACE
    c_children = TDefinitions_.c_children.copy()
    c_attributes = TDefinitions_.c_attributes.copy()
    c_child_order = TDefinitions_.c_child_order[:]
    c_cardinality = TDefinitions_.c_cardinality.copy()

def definitions_from_string(xml_string):
    return saml2.create_class_from_xml_string(Definitions, xml_string)


#..................
# []
ELEMENT_FROM_STRING = {
    TDocumentation_.c_tag: t_documentation__from_string,
    TDocumented_.c_tag: t_documented__from_string,
    Definitions.c_tag: definitions_from_string,
    TDefinitions_.c_tag: t_definitions__from_string,
    TImport_.c_tag: t_import__from_string,
    TTypes_.c_tag: t_types__from_string,
    TMessage_.c_tag: t_message__from_string,
    TPart_.c_tag: t_part__from_string,
    TPortType_.c_tag: t_port_type__from_string,
    TOperation_.c_tag: t_operation__from_string,
    TParam_.c_tag: t_param__from_string,
    TFault_.c_tag: t_fault__from_string,
    TBinding_.c_tag: t_binding__from_string,
    TBindingOperationMessage_.c_tag: t_binding_operation_message__from_string,
    TBindingOperationFault_.c_tag: t_binding_operation_fault__from_string,
    TBindingOperation_.c_tag: t_binding_operation__from_string,
    TService_.c_tag: t_service__from_string,
    TPort_.c_tag: t_port__from_string,
    TDocumented_documentation.c_tag: t_documented_documentation_from_string,
    TBindingOperation_input.c_tag: t_binding_operation_input_from_string,
    TBindingOperation_output.c_tag: t_binding_operation_output_from_string,
    TBindingOperation_fault.c_tag: t_binding_operation_fault_from_string,
    Import.c_tag: import_from_string,
    Types.c_tag: types_from_string,
    TMessage_part.c_tag: t_message_part_from_string,
    TPortType_operation.c_tag: t_port_type_operation_from_string,
    TService_port.c_tag: t_service_port_from_string,
    Message.c_tag: message_from_string,
    PortType.c_tag: port_type_from_string,
    Binding.c_tag: binding_from_string,
    Service.c_tag: service_from_string,
}

ELEMENT_BY_TAG = {
    'tDocumentation': TDocumentation_,
    'tDocumented': TDocumented_,
    'definitions': Definitions,
    'tDefinitions': TDefinitions_,
    'tImport': TImport_,
    'tTypes': TTypes_,
    'tMessage': TMessage_,
    'tPart': TPart_,
    'tPortType': TPortType_,
    'tOperation': TOperation_,
    'tParam': TParam_,
    'tFault': TFault_,
    'tBinding': TBinding_,
    'tBindingOperationMessage': TBindingOperationMessage_,
    'tBindingOperationFault': TBindingOperationFault_,
    'tBindingOperation': TBindingOperation_,
    'tService': TService_,
    'tPort': TPort_,
    'documentation': TDocumented_documentation,
    'input': TBindingOperation_input,
    'output': TBindingOperation_output,
    'fault': TBindingOperation_fault,
    'import': Import,
    'types': Types,
    'part': TMessage_part,
    'operation': TPortType_operation,
    'port': TService_port,
    'message': Message,
    'portType': PortType,
    'binding': Binding,
    'service': Service,
    'tExtensibleAttributesDocumented': TExtensibleAttributesDocumented_,
    'tExtensibleDocumented': TExtensibleDocumented_,
    'tExtensibilityElement': TExtensibilityElement_,
}


def factory(tag, **kwargs):
    return ELEMENT_BY_TAG[tag](**kwargs)


########NEW FILE########
__FILENAME__ = sdb
import logging

from hashlib import sha1

from saml2.ident import code

from saml2 import md
from saml2 import saml
from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
import xmldsig
import xmlenc


ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc
}

__author__ = 'rolandh'

logger = logging.getLogger(__name__)


def context_match(cfilter, cntx):
    # TODO
    return True

# The key to the stored authn statement is placed encrypted in the cookie


class SessionStorage(object):
    """ In memory storage of session information """

    def __init__(self):
        self.db = {"assertion": {}, "authn": {}}
        self.assertion = self.db["assertion"]
        self.authn = self.db["authn"]

    def store_assertion(self, assertion, to_sign):
        self.assertion[assertion.id] = (assertion, to_sign)
        key = sha1(code(assertion.subject.name_id)).hexdigest()
        try:
            self.authn[key].append(assertion.authn_statement)
        except KeyError:
            self.authn[key] = [assertion.authn_statement]

    def get_assertion(self, cid):
        return self.assertion[cid]

    def get_authn_statements(self, name_id, session_index=None,
                             requested_context=None):
        """

        :param name_id:
        :param session_index:
        :param requested_context:
        :return:
        """
        result = []
        key = sha1(code(name_id)).hexdigest()
        try:
            statements = self.authn[key]
        except KeyError:
            logger.info("Unknown subject %s" % name_id)
            return []

        for statement in statements:
            if session_index:
                if statement.session_index != session_index:
                    continue
            if requested_context:
                if not context_match(requested_context,
                                     statement[0].authn_context):
                    continue
            result.append(statement)

        return result

    def remove_authn_statements(self, name_id):
        logger.debug("remove authn about: %s" % name_id)
        nkey = sha1(code(name_id)).hexdigest()

        del self.authn[nkey]

########NEW FILE########
__FILENAME__ = server
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Contains classes and functions that a SAML2.0 Identity provider (IdP) 
or attribute authority (AA) may use to conclude its tasks.
"""
import logging
import os

import shelve
import threading

from saml2.eptid import EptidShelve, Eptid
from saml2.saml import EncryptedAssertion
from saml2.sdb import SessionStorage
from saml2.schema import soapenv

from saml2.samlp import NameIDMappingResponse
from saml2.entity import Entity

from saml2 import saml, element_to_extension_element
from saml2 import class_name
from saml2 import BINDING_HTTP_REDIRECT

from saml2.request import AuthnRequest
from saml2.request import AssertionIDRequest
from saml2.request import AttributeQuery
from saml2.request import NameIDMappingRequest
from saml2.request import AuthzDecisionQuery
from saml2.request import AuthnQuery

from saml2.s_utils import MissingValue, Unknown, rndstr

from saml2.sigver import pre_signature_part, signed_instance_factory, CertificateError, CryptoBackendXmlSec1

from saml2.assertion import Assertion
from saml2.assertion import Policy
from saml2.assertion import restriction_from_attribute_spec
from saml2.assertion import filter_attribute_value_assertions

from saml2.ident import IdentDB
from saml2.profile import ecp

logger = logging.getLogger(__name__)

AUTHN_DICT_MAP = {
    "decl": "authn_decl",
    "authn_auth": "authn_auth",
    "class_ref": "authn_class",
    "authn_instant": "authn_instant",
    "subject_locality": "subject_locality"
}


class Server(Entity):
    """ A class that does things that IdPs or AAs do """

    def __init__(self, config_file="", config=None, cache=None, stype="idp",
                 symkey=""):
        Entity.__init__(self, stype, config, config_file)
        self.eptid = None
        self.init_config(stype)
        self.cache = cache
        self.ticket = {}
        #
        self.session_db = self.choose_session_storage()
        # Needed for
        self.symkey = symkey
        self.seed = rndstr()
        self.iv = os.urandom(16)
        self.lock = threading.Lock()

    def getvalid_certificate_str(self):
        if self.sec.cert_handler is not None:
            return self.sec.cert_handler._last_validated_cert
        return None

    def support_AssertionIDRequest(self):
        return True

    def support_AuthnQuery(self):
        return True

    def choose_session_storage(self):
        _spec = self.config.getattr("session_storage", "idp")
        if not _spec:
            return SessionStorage()
        elif isinstance(_spec, basestring):
            if _spec.lower() == "memory":
                return SessionStorage()
        else:  # Should be tuple
            typ, data = _spec
            if typ.lower() == "mongodb":
                from saml2.mongo_store import SessionStorageMDB

                return SessionStorageMDB(database=data, collection="session")

        raise NotImplementedError("No such storage type implemented")

    def init_config(self, stype="idp"):
        """ Remaining init of the server configuration 
        
        :param stype: The type of Server ("idp"/"aa")
        """
        if stype == "aa":
            return

        # subject information is stored in a database
        # default database is in memory which is OK in some setups
        dbspec = self.config.getattr("subject_data", "idp")
        idb = None
        typ = ""
        if not dbspec:
            idb = {}
        elif isinstance(dbspec, basestring):
            idb = shelve.open(dbspec, writeback=True)
        else:  # database spec is a a 2-tuple (type, address)
            #print >> sys.stderr, "DBSPEC: %s" % (dbspec,)
            (typ, addr) = dbspec
            if typ == "shelve":
                idb = shelve.open(addr, writeback=True)
            elif typ == "memcached":
                import memcache

                idb = memcache.Client(addr)
            elif typ == "dict":  # in-memory dictionary
                idb = {}
            elif typ == "mongodb":
                from saml2.mongo_store import IdentMDB

                self.ident = IdentMDB(database=addr, collection="ident")

        if typ == "mongodb":
            pass
        elif idb is not None:
            self.ident = IdentDB(idb)
        elif dbspec:
            raise Exception("Couldn't open identity database: %s" %
                            (dbspec,))

        _domain = self.config.getattr("domain", "idp")
        if _domain:
            self.ident.domain = _domain

        self.ident.name_qualifier = self.config.entityid

        dbspec = self.config.getattr("edu_person_targeted_id", "idp")
        if not dbspec:
            pass
        else:
            typ = dbspec[0]
            addr = dbspec[1]
            secret = dbspec[2]
            if typ == "shelve":
                self.eptid = EptidShelve(secret, addr)
            elif typ == "mongodb":
                from saml2.mongo_store import EptidMDB

                self.eptid = EptidMDB(secret, database=addr,
                                      collection="eptid")
            else:
                self.eptid = Eptid(secret)

    def wants(self, sp_entity_id, index=None):
        """ Returns what attributes the SP requires and which are optional
        if any such demands are registered in the Metadata.

        :param sp_entity_id: The entity id of the SP
        :param index: which of the attribute consumer services its all about
        :return: 2-tuple, list of required and list of optional attributes
        """
        return self.metadata.attribute_requirement(sp_entity_id, index)

    def verify_assertion_consumer_service(self, request):
        _acs = request.assertion_consumer_service_url
        _aci = request.assertion_consumer_service_index
        _binding = request.protocol_binding
        _eid = request.issuer.text
        if _acs:
            # look up acs in for that binding in the metadata given the issuer
            # Assuming the format is entity
            for acs in self.metadata.assertion_consumer_service(_eid, _binding):
                if _acs == acs.text:
                    return True
        elif _aci:
            for acs in self.metadata.assertion_consumer_service(_eid, _binding):
                if _aci == acs.index:
                    return True

        return False

    # -------------------------------------------------------------------------
    def parse_authn_request(self, enc_request, binding=BINDING_HTTP_REDIRECT):
        """Parse a Authentication Request
        
        :param enc_request: The request in its transport format
        :param binding: Which binding that was used to transport the message
            to this entity.
        :return: A dictionary with keys:
            consumer_url - as gotten from the SPs entity_id and the metadata
            id - the id of the request
            sp_entity_id - the entity id of the SP
            request - The verified request
        """

        return self._parse_request(enc_request, AuthnRequest,
                                   "single_sign_on_service", binding)

    def parse_attribute_query(self, xml_string, binding):
        """ Parse an attribute query
        
        :param xml_string: The Attribute Query as an XML string
        :param binding: Which binding that was used for the request
        :return: A query instance
        """

        return self._parse_request(xml_string, AttributeQuery,
                                   "attribute_service", binding)

    def parse_authz_decision_query(self, xml_string, binding):
        """ Parse an authorization decision query

        :param xml_string: The Authz decision Query as an XML string
        :param binding: Which binding that was used when receiving this query
        :return: Query instance
        """

        return self._parse_request(xml_string, AuthzDecisionQuery,
                                   "authz_service", binding)

    def parse_assertion_id_request(self, xml_string, binding):
        """ Parse an assertion id query

        :param xml_string: The AssertionIDRequest as an XML string
        :param binding: Which binding that was used when receiving this request
        :return: Query instance
        """

        return self._parse_request(xml_string, AssertionIDRequest,
                                   "assertion_id_request_service", binding)

    def parse_authn_query(self, xml_string, binding):
        """ Parse an authn query

        :param xml_string: The AuthnQuery as an XML string
        :param binding: Which binding that was used when receiving this query
        :return: Query instance
        """

        return self._parse_request(xml_string, AuthnQuery,
                                   "authn_query_service", binding)

    def parse_name_id_mapping_request(self, xml_string, binding):
        """ Parse a nameid mapping request

        :param xml_string: The NameIDMappingRequest as an XML string
        :param binding: Which binding that was used when receiving this request
        :return: Query instance
        """

        return self._parse_request(xml_string, NameIDMappingRequest,
                                   "name_id_mapping_service", binding)

    # ------------------------------------------------------------------------

    # ------------------------------------------------------------------------

    def _authn_response(self, in_response_to, consumer_url,
                        sp_entity_id, identity=None, name_id=None,
                        status=None, authn=None, issuer=None, policy=None,
                        sign_assertion=False, sign_response=False,
                        best_effort=False, encrypt_assertion=False, encrypt_cert=None):
        """ Create a response. A layer of indirection.
        
        :param in_response_to: The session identifier of the request
        :param consumer_url: The URL which should receive the response
        :param sp_entity_id: The entity identifier of the SP
        :param identity: A dictionary with attributes and values that are
            expected to be the bases for the assertion in the response.
        :param name_id: The identifier of the subject
        :param status: The status of the response
        :param authn: A dictionary containing information about the
            authn context.
        :param issuer: The issuer of the response
        :param sign_assertion: Whether the assertion should be signed or not
        :param sign_response: Whether the response should be signed or not
        :param best_effort: Even if not the SPs demands can be met send a
            response.
        :return: A response instance
        """

        to_sign = []
        args = {}
        #if identity:
        _issuer = self._issuer(issuer)
        ast = Assertion(identity)
        ast.acs = self.config.getattr("attribute_converters", "idp")
        if policy is None:
            policy = Policy()
        try:
            ast.apply_policy(sp_entity_id, policy, self.metadata)
        except MissingValue, exc:
            if not best_effort:
                return self.create_error_response(in_response_to, consumer_url,
                                                  exc, sign_response)

        if authn:  # expected to be a dictionary
            # Would like to use dict comprehension but ...
            authn_args = dict([
                (AUTHN_DICT_MAP[k], v) for k, v in authn.items()
                if k in AUTHN_DICT_MAP])

            assertion = ast.construct(sp_entity_id, in_response_to,
                                      consumer_url, name_id,
                                      self.config.attribute_converters,
                                      policy, issuer=_issuer,
                                      **authn_args)
        else:
            assertion = ast.construct(sp_entity_id, in_response_to,
                                      consumer_url, name_id,
                                      self.config.attribute_converters,
                                      policy, issuer=_issuer)

        if sign_assertion is not None and sign_assertion:
            assertion.signature = pre_signature_part(assertion.id,
                                                     self.sec.my_cert, 1)
            # Just the assertion or the response and the assertion ?
            to_sign = [(class_name(assertion), assertion.id)]

        # Store which assertion that has been sent to which SP about which
        # subject.

        # self.cache.set(assertion.subject.name_id.text,
        #                 sp_entity_id, {"ava": identity, "authn": authn},
        #                 assertion.conditions.not_on_or_after)

        args["assertion"] = assertion

        if self.support_AssertionIDRequest() or self.support_AuthnQuery():
            self.session_db.store_assertion(assertion, to_sign)

        return self._response(in_response_to, consumer_url, status, issuer,
                              sign_response, to_sign, encrypt_assertion=encrypt_assertion,
                              encrypt_cert=encrypt_cert, **args)

    # ------------------------------------------------------------------------

    #noinspection PyUnusedLocal
    def create_attribute_response(self, identity, in_response_to, destination,
                                  sp_entity_id, userid="", name_id=None,
                                  status=None, issuer=None,
                                  sign_assertion=False, sign_response=False,
                                  attributes=None, **kwargs):
        """ Create an attribute assertion response.
        
        :param identity: A dictionary with attributes and values that are
            expected to be the bases for the assertion in the response.
        :param in_response_to: The session identifier of the request
        :param destination: The URL which should receive the response
        :param sp_entity_id: The entity identifier of the SP
        :param userid: A identifier of the user
        :param name_id: The identifier of the subject
        :param status: The status of the response
        :param issuer: The issuer of the response
        :param sign_assertion: Whether the assertion should be signed or not
        :param sign_response: Whether the whole response should be signed
        :param attributes:
        :param kwargs: To catch extra keyword arguments
        :return: A response instance
        """

        policy = self.config.getattr("policy", "aa")

        if not name_id and userid:
            try:
                name_id = self.ident.construct_nameid(userid, policy,
                                                      sp_entity_id)
                logger.warning("Unspecified NameID format")
            except Exception:
                pass

        to_sign = []
        args = {}
        if identity:
            _issuer = self._issuer(issuer)
            ast = Assertion(identity)
            if policy:
                ast.apply_policy(sp_entity_id, policy, self.metadata)
            else:
                policy = Policy()

            if attributes:
                restr = restriction_from_attribute_spec(attributes)
                ast = filter_attribute_value_assertions(ast)

            assertion = ast.construct(sp_entity_id, in_response_to,
                                      destination, name_id,
                                      self.config.attribute_converters,
                                      policy, issuer=_issuer)

            if sign_assertion:
                assertion.signature = pre_signature_part(assertion.id,
                                                         self.sec.my_cert, 1)
                # Just the assertion or the response and the assertion ?
                to_sign = [(class_name(assertion), assertion.id)]

            args["assertion"] = assertion

        return self._response(in_response_to, destination, status, issuer,
                              sign_response, to_sign, **args)

    # ------------------------------------------------------------------------

    def create_authn_response(self, identity, in_response_to, destination,
                              sp_entity_id, name_id_policy=None, userid=None,
                              name_id=None, authn=None, issuer=None,
                              sign_response=None, sign_assertion=None, encrypt_cert=None, encrypt_assertion=None,
                              **kwargs):
        """ Constructs an AuthenticationResponse

        :param identity: Information about an user
        :param in_response_to: The identifier of the authentication request
            this response is an answer to.
        :param destination: Where the response should be sent
        :param sp_entity_id: The entity identifier of the Service Provider
        :param name_id_policy: How the NameID should be constructed
        :param userid: The subject identifier
        :param authn: Dictionary with information about the authentication
            context
        :param issuer: Issuer of the response
        :param sign_assertion: Whether the assertion should be signed or not.
        :param sign_response: Whether the response should be signed or not.
        :return: A response instance
        """

        try:
            policy = kwargs["release_policy"]
        except KeyError:
            policy = self.config.getattr("policy", "idp")

        try:
            best_effort = kwargs["best_effort"]
        except KeyError:
            best_effort = False

        if sign_assertion is None:
            sign_assertion = self.config.getattr("sign_assertion", "idp")
        if sign_assertion is None:
            sign_assertion = False

        if sign_response is None:
            sign_response = self.config.getattr("sign_response", "idp")
        if sign_response is None:
            sign_response = False

        if encrypt_assertion is None:
            encrypt_assertion = self.config.getattr("encrypt_assertion", "idp")
        if encrypt_assertion is None:
            encrypt_assertion = False

        if encrypt_assertion:
            if encrypt_cert is not None:
                verify_encrypt_cert = self.config.getattr("verify_encrypt_cert", "idp")
                if verify_encrypt_cert is not None:
                    if not verify_encrypt_cert(encrypt_cert):
                        raise CertificateError("Invalid certificate for encryption!")
            else:
                raise CertificateError("No SPCertEncType certificate for encryption contained in authentication "
                                       "request.")
        else:
            encrypt_assertion = False

        if not name_id:
            try:
                nid_formats = []
                for _sp in self.metadata[sp_entity_id]["spsso_descriptor"]:
                    if "name_id_format" in _sp:
                        nid_formats.extend([n["text"] for n in
                                            _sp["name_id_format"]])
                try:
                    snq = name_id_policy.sp_name_qualifier
                except AttributeError:
                    snq = sp_entity_id

                if not snq:
                    snq = sp_entity_id

                kwa = {"sp_name_qualifier": snq}

                try:
                    kwa["format"] = name_id_policy.format
                except AttributeError:
                    pass

                _nids = self.ident.find_nameid(userid, **kwa)
                # either none or one
                if _nids:
                    name_id = _nids[0]
                else:
                    name_id = self.ident.construct_nameid(userid, policy,
                                                          sp_entity_id,
                                                          name_id_policy)
            except IOError, exc:
                response = self.create_error_response(in_response_to,
                                                      destination,
                                                      sp_entity_id,
                                                      exc, name_id)
                return ("%s" % response).split("\n")

        try:
            _authn = authn
            if (sign_assertion or sign_response) and self.sec.cert_handler.generate_cert():
                with self.lock:
                    self.sec.cert_handler.update_cert(True)
                    return self._authn_response(in_response_to,  # in_response_to
                                                destination,  # consumer_url
                                                sp_entity_id,  # sp_entity_id
                                                identity,  # identity as dictionary
                                                name_id,
                                                authn=_authn,
                                                issuer=issuer,
                                                policy=policy,
                                                sign_assertion=sign_assertion,
                                                sign_response=sign_response,
                                                best_effort=best_effort,
                                                encrypt_assertion=encrypt_assertion,
                                                encrypt_cert=encrypt_cert)
            return self._authn_response(in_response_to,  # in_response_to
                                        destination,  # consumer_url
                                        sp_entity_id,  # sp_entity_id
                                        identity,  # identity as dictionary
                                        name_id,
                                        authn=_authn,
                                        issuer=issuer,
                                        policy=policy,
                                        sign_assertion=sign_assertion,
                                        sign_response=sign_response,
                                        best_effort=best_effort,
                                        encrypt_assertion=encrypt_assertion,
                                        encrypt_cert=encrypt_cert)

        except MissingValue, exc:
            return self.create_error_response(in_response_to, destination,
                                              sp_entity_id, exc, name_id)

    def create_authn_request_response(self, identity, in_response_to,
                                      destination, sp_entity_id,
                                      name_id_policy=None, userid=None,
                                      name_id=None, authn=None, authn_decl=None,
                                      issuer=None, sign_response=False,
                                      sign_assertion=False, **kwargs):

        return self.create_authn_response(identity, in_response_to, destination,
                                          sp_entity_id, name_id_policy, userid,
                                          name_id, authn, issuer,
                                          sign_response, sign_assertion,
                                          authn_decl=authn_decl)

    #noinspection PyUnusedLocal
    def create_assertion_id_request_response(self, assertion_id, sign=False,
                                             **kwargs):
        """

        :param assertion_id:
        :param sign:
        :return:
        """

        try:
            (assertion, to_sign) = self.session_db.get_assertion(assertion_id)
        except KeyError:
            raise Unknown

        if to_sign:
            if assertion.signature is None:
                assertion.signature = pre_signature_part(assertion.id,
                                                         self.sec.my_cert, 1)

            return signed_instance_factory(assertion, self.sec, to_sign)
        else:
            return assertion

    #noinspection PyUnusedLocal
    def create_name_id_mapping_response(self, name_id=None, encrypted_id=None,
                                        in_response_to=None,
                                        issuer=None, sign_response=False,
                                        status=None, **kwargs):
        """
        protocol for mapping a principal's name identifier into a
        different name identifier for the same principal.
        Done over soap.

        :param name_id:
        :param encrypted_id:
        :param in_response_to:
        :param issuer:
        :param sign_response:
        :param status:
        :return:
        """
        # Done over SOAP

        ms_args = self.message_args()

        _resp = NameIDMappingResponse(name_id, encrypted_id,
                                      in_response_to=in_response_to, **ms_args)

        if sign_response:
            return self.sign(_resp)
        else:
            logger.info("Message: %s" % _resp)
            return _resp

    def create_authn_query_response(self, subject, session_index=None,
                                    requested_context=None, in_response_to=None,
                                    issuer=None, sign_response=False,
                                    status=None, **kwargs):
        """
        A successful <Response> will contain one or more assertions containing
        authentication statements.

        :return:
        """

        margs = self.message_args()
        asserts = []
        for statement in self.session_db.get_authn_statements(
                subject.name_id, session_index, requested_context):
            asserts.append(saml.Assertion(authn_statement=statement,
                                          subject=subject, **margs))

        if asserts:
            args = {"assertion": asserts}
        else:
            args = {}

        return self._response(in_response_to, "", status, issuer,
                              sign_response, to_sign=[], **args)

    # ---------

    def parse_ecp_authn_request(self):
        pass

    def create_ecp_authn_request_response(self, acs_url, identity,
                                          in_response_to, destination,
                                          sp_entity_id, name_id_policy=None,
                                          userid=None, name_id=None, authn=None,
                                          issuer=None, sign_response=False,
                                          sign_assertion=False, **kwargs):

        # ----------------------------------------
        # <ecp:Response
        # ----------------------------------------

        ecp_response = ecp.Response(assertion_consumer_service_url=acs_url)
        header = soapenv.Header()
        header.extension_elements = [element_to_extension_element(ecp_response)]

        # ----------------------------------------
        # <samlp:Response
        # ----------------------------------------

        response = self.create_authn_response(identity, in_response_to,
                                              destination, sp_entity_id,
                                              name_id_policy, userid, name_id,
                                              authn, issuer,
                                              sign_response, sign_assertion)
        body = soapenv.Body()
        body.extension_elements = [element_to_extension_element(response)]

        soap_envelope = soapenv.Envelope(header=header, body=body)

        return "%s" % soap_envelope

########NEW FILE########
__FILENAME__ = sigver
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

""" Functions connected to signing and verifying.
Based on the use of xmlsec1 binaries and not the python xmlsec module.
"""

import base64
from binascii import hexlify
import hashlib
import logging
import random
import os
import ssl
from time import mktime
import urllib
from Crypto.PublicKey.RSA import importKey
from Crypto.Signature import PKCS1_v1_5
from Crypto.Util.asn1 import DerSequence
from Crypto.PublicKey import RSA
from saml2.cert import OpenSSLWrapper
from saml2.extension import pefim
from saml2.saml import EncryptedAssertion
from saml2.samlp import Response

import xmldsig as ds

from saml2 import samlp
from saml2 import SAMLError
from saml2 import extension_elements_to_elements
from saml2 import class_name
from saml2 import saml
from saml2 import ExtensionElement
from saml2 import VERSION

from saml2.s_utils import sid
from saml2.s_utils import Unsupported

from saml2.time_util import instant
from saml2.time_util import utc_now
from saml2.time_util import str_to_time

from tempfile import NamedTemporaryFile
from subprocess import Popen, PIPE
from xmlenc import EncryptionMethod
from xmlenc import EncryptedKey
from xmlenc import CipherData
from xmlenc import CipherValue
from xmlenc import EncryptedData

from Crypto.Hash import SHA256
from Crypto.Hash import SHA384
from Crypto.Hash import SHA512
from Crypto.Hash import SHA

logger = logging.getLogger(__name__)

SIG = "{%s#}%s" % (ds.NAMESPACE, "Signature")

RSA_SHA1 = "http://www.w3.org/2000/09/xmldsig#rsa-sha1"
RSA_1_5 = "http://www.w3.org/2001/04/xmlenc#rsa-1_5"
TRIPLE_DES_CBC = "http://www.w3.org/2001/04/xmlenc#tripledes-cbc"
XMLTAG = "<?xml version='1.0'?>"
PREFIX1 = "<?xml version='1.0' encoding='UTF-8'?>"
PREFIX2 = '<?xml version="1.0" encoding="UTF-8"?>'


class SigverError(SAMLError):
    pass


class CertificateTooOld(SigverError):
    pass


class SignatureError(SigverError):
    pass


class XmlsecError(SigverError):
    pass


class MissingKey(SigverError):
    pass


class DecryptError(XmlsecError):
    pass


class EncryptError(XmlsecError):
    pass


class BadSignature(SigverError):
    """The signature is invalid."""
    pass


class CertificateError(SigverError):
    pass


def rm_xmltag(statement):
    try:
        _t = statement.startswith(XMLTAG)
    except TypeError:
        statement = statement.decode("utf8")
        _t = statement.startswith(XMLTAG)

    if _t:
        statement = statement[len(XMLTAG):]
        if statement[0] == '\n':
            statement = statement[1:]
    elif statement.startswith(PREFIX1):
        statement = statement[len(PREFIX1):]
        if statement[0] == '\n':
            statement = statement[1:]
    elif statement.startswith(PREFIX2):
        statement = statement[len(PREFIX2):]
        if statement[0] == '\n':
            statement = statement[1:]

    return statement


def signed(item):
    if SIG in item.c_children.keys() and item.signature:
        return True
    else:
        for prop in item.c_child_order:
            child = getattr(item, prop, None)
            if isinstance(child, list):
                for chi in child:
                    if signed(chi):
                        return True
            elif child and signed(child):
                return True

    return False


def get_xmlsec_binary(paths=None):
    """
    Tries to find the xmlsec1 binary.

    :param paths: Non-system path paths which should be searched when
        looking for xmlsec1
    :return: full name of the xmlsec1 binary found. If no binaries are
        found then an exception is raised.
    """
    if os.name == "posix":
        bin_name = ["xmlsec1"]
    elif os.name == "nt":
        bin_name = ["xmlsec.exe", "xmlsec1.exe"]
    else:  # Default !?
        bin_name = ["xmlsec1"]

    if paths:
        for bname in bin_name:
            for path in paths:
                fil = os.path.join(path, bname)
                try:
                    if os.lstat(fil):
                        return fil
                except OSError:
                    pass

    for path in os.environ["PATH"].split(os.pathsep):
        for bname in bin_name:
            fil = os.path.join(path, bname)
            try:
                if os.lstat(fil):
                    return fil
            except OSError:
                pass

    raise SigverError("Can't find %s" % bin_name)


def _get_xmlsec_cryptobackend(path=None, search_paths=None, debug=False):
    """
    Initialize a CryptoBackendXmlSec1 crypto backend.

    This function is now internal to this module.
    """
    if path is None:
        path = get_xmlsec_binary(paths=search_paths)
    return CryptoBackendXmlSec1(path, debug=debug)


ID_ATTR = "ID"
NODE_NAME = "urn:oasis:names:tc:SAML:2.0:assertion:Assertion"
ENC_NODE_NAME = "urn:oasis:names:tc:SAML:2.0:assertion:EncryptedAssertion"
ENC_KEY_CLASS = "EncryptedKey"

_TEST_ = True


# --------------------------------------------------------------------------


def _make_vals(val, klass, seccont, klass_inst=None, prop=None, part=False,
               base64encode=False, elements_to_sign=None):
    """
    Creates a class instance with a specified value, the specified
    class instance may be a value on a property in a defined class instance.

    :param val: The value
    :param klass: The value class
    :param klass_inst: The class instance which has a property on which
        what this function returns is a value.
    :param prop: The property which the value should be assigned to.
    :param part: If the value is one of a possible list of values it should be
        handled slightly different compared to if it isn't.
    :return: Value class instance
    """
    cinst = None

    #print "make_vals(%s, %s)" % (val, klass)

    if isinstance(val, dict):
        cinst = _instance(klass, val, seccont, base64encode=base64encode,
                          elements_to_sign=elements_to_sign)
    else:
        try:
            cinst = klass().set_text(val)
        except ValueError:
            if not part:
                cis = [_make_vals(sval, klass, seccont, klass_inst, prop,
                                  True, base64encode, elements_to_sign) for sval
                       in val]
                setattr(klass_inst, prop, cis)
            else:
                raise

    if part:
        return cinst
    else:
        if cinst:
            cis = [cinst]
            setattr(klass_inst, prop, cis)


def _instance(klass, ava, seccont, base64encode=False, elements_to_sign=None):
    instance = klass()

    for prop in instance.c_attributes.values():
        #print "# %s" % (prop)
        if prop in ava:
            if isinstance(ava[prop], bool):
                setattr(instance, prop, "%s" % ava[prop])
            elif isinstance(ava[prop], int):
                setattr(instance, prop, "%d" % ava[prop])
            else:
                setattr(instance, prop, ava[prop])

    if "text" in ava:
        instance.set_text(ava["text"], base64encode)

    for prop, klassdef in instance.c_children.values():
        #print "## %s, %s" % (prop, klassdef)
        if prop in ava:
            #print "### %s" % ava[prop]
            if isinstance(klassdef, list):
                # means there can be a list of values
                _make_vals(ava[prop], klassdef[0], seccont, instance, prop,
                           base64encode=base64encode,
                           elements_to_sign=elements_to_sign)
            else:
                cis = _make_vals(ava[prop], klassdef, seccont, instance, prop,
                                 True, base64encode, elements_to_sign)
                setattr(instance, prop, cis)

    if "extension_elements" in ava:
        for item in ava["extension_elements"]:
            instance.extension_elements.append(
                ExtensionElement(item["tag"]).loadd(item))

    if "extension_attributes" in ava:
        for key, val in ava["extension_attributes"].items():
            instance.extension_attributes[key] = val

    if "signature" in ava:
        elements_to_sign.append((class_name(instance), instance.id))

    return instance


def signed_instance_factory(instance, seccont, elements_to_sign=None):
    """

    :param instance: The instance to be signed or not
    :param seccont: The security context
    :param elements_to_sign: Which parts if any that should be signed
    :return: A class instance if not signed otherwise a string
    """
    if elements_to_sign:
        signed_xml = "%s" % instance
        for (node_name, nodeid) in elements_to_sign:
            signed_xml = seccont.sign_statement(
                signed_xml, class_name=node_name, node_id=nodeid)

        #print "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        #print "%s" % signed_xml
        #print "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        return signed_xml
    else:
        return instance


# --------------------------------------------------------------------------


def create_id():
    """ Create a string of 40 random characters from the set [a-p],
    can be used as a unique identifier of objects.

    :return: The string of random characters
    """
    ret = ""
    for _ in range(40):
        ret += chr(random.randint(0, 15) + ord('a'))
    return ret


def make_temp(string, suffix="", decode=True, delete=True):
    """ xmlsec needs files in some cases where only strings exist, hence the
    need for this function. It creates a temporary file with the
    string as only content.

    :param string: The information to be placed in the file
    :param suffix: The temporary file might have to have a specific
        suffix in certain circumstances.
    :param decode: The input string might be base64 coded. If so it
        must, in some cases, be decoded before being placed in the file.
    :return: 2-tuple with file pointer ( so the calling function can
        close the file) and filename (which is for instance needed by the
        xmlsec function).
    """
    ntf = NamedTemporaryFile(suffix=suffix, delete=delete)
    if decode:
        ntf.write(base64.b64decode(string))
    else:
        ntf.write(string)
    ntf.seek(0)
    return ntf, ntf.name


def split_len(seq, length):
    return [seq[i:i + length] for i in range(0, len(seq), length)]

# --------------------------------------------------------------------------

M2_TIME_FORMAT = "%b %d %H:%M:%S %Y"


def to_time(_time):
    assert _time.endswith(" GMT")
    _time = _time[:-4]
    return mktime(str_to_time(_time, M2_TIME_FORMAT))


def active_cert(key):
    """
    Verifies that a key is active that is present time is after not_before
    and before not_after.

    :param key: The Key
    :return: True if the key is active else False
    """
    cert_str = pem_format(key)
    certificate = importKey(cert_str)
    try:
        not_before = to_time(str(certificate.get_not_before()))
        not_after = to_time(str(certificate.get_not_after()))
        assert not_before < utc_now()
        assert not_after > utc_now()
        return True
    except AssertionError:
        return False
    except AttributeError:
        return False


def cert_from_key_info(key_info, ignore_age=False):
    """ Get all X509 certs from a KeyInfo instance. Care is taken to make sure
    that the certs are continues sequences of bytes.

    All certificates appearing in an X509Data element MUST relate to the
    validation key by either containing it or being part of a certification
    chain that terminates in a certificate containing the validation key.

    :param key_info: The KeyInfo instance
    :return: A possibly empty list of certs
    """
    res = []
    for x509_data in key_info.x509_data:
        #print "X509Data",x509_data
        x509_certificate = x509_data.x509_certificate
        cert = x509_certificate.text.strip()
        cert = "\n".join(split_len("".join([s.strip() for s in
                                            cert.split()]), 64))
        if ignore_age or active_cert(cert):
            res.append(cert)
        else:
            logger.info("Inactive cert")
    return res


def cert_from_key_info_dict(key_info, ignore_age=False):
    """ Get all X509 certs from a KeyInfo dictionary. Care is taken to make sure
    that the certs are continues sequences of bytes.

    All certificates appearing in an X509Data element MUST relate to the
    validation key by either containing it or being part of a certification
    chain that terminates in a certificate containing the validation key.

    :param key_info: The KeyInfo dictionary
    :return: A possibly empty list of certs in their text representation
    """
    res = []
    if not "x509_data" in key_info:
        return res

    for x509_data in key_info["x509_data"]:
        x509_certificate = x509_data["x509_certificate"]
        cert = x509_certificate["text"].strip()
        cert = "\n".join(split_len("".join([s.strip() for s in
                                            cert.split()]), 64))
        if ignore_age or active_cert(cert):
            res.append(cert)
        else:
            logger.info("Inactive cert")
    return res


def cert_from_instance(instance):
    """ Find certificates that are part of an instance

    :param instance: An instance
    :return: possible empty list of certificates
    """
    if instance.signature:
        if instance.signature.key_info:
            return cert_from_key_info(instance.signature.key_info,
                                      ignore_age=True)
    return []


# =============================================================================


def intarr2long(arr):
    return long(''.join(["%02x" % byte for byte in arr]), 16)


def dehexlify(bi):
    s = hexlify(bi)
    return [int(s[i] + s[i + 1], 16) for i in range(0, len(s), 2)]


def base64_to_long(data):
    _d = base64.urlsafe_b64decode(data + '==')
    return intarr2long(dehexlify(_d))


def key_from_key_value(key_info):
    res = []
    for value in key_info.key_value:
        if value.rsa_key_value:
            e = base64_to_long(value.rsa_key_value.exponent)
            m = base64_to_long(value.rsa_key_value.modulus)
            key = RSA.construct((m, e))
            res.append(key)
    return res


def key_from_key_value_dict(key_info):
    res = []
    if not "key_value" in key_info:
        return res

    for value in key_info["key_value"]:
        if "rsa_key_value" in value:
            e = base64_to_long(value["rsa_key_value"]["exponent"])
            m = base64_to_long(value["rsa_key_value"]["modulus"])
            key = RSA.construct((m, e))
            res.append(key)
    return res


# =============================================================================


#def rsa_load(filename):
#    """Read a PEM-encoded RSA key pair from a file."""
#    return M2Crypto.RSA.load_key(filename, M2Crypto.util
# .no_passphrase_callback)
#
#
#def rsa_loads(key):
#    """Read a PEM-encoded RSA key pair from a string."""
#    return M2Crypto.RSA.load_key_string(key,
#                                        M2Crypto.util.no_passphrase_callback)


def rsa_eq(key1, key2):
    # Check if two RSA keys are in fact the same
    if key1.n == key2.n and key1.e == key2.e:
        return True
    else:
        return False


def extract_rsa_key_from_x509_cert(pem):
    # Convert from PEM to DER
    der = ssl.PEM_cert_to_DER_cert(pem)

    # Extract subjectPublicKeyInfo field from X.509 certificate (see RFC3280)
    cert = DerSequence()
    cert.decode(der)
    tbsCertificate = DerSequence()
    tbsCertificate.decode(cert[0])
    subjectPublicKeyInfo = tbsCertificate[6]

    # Initialize RSA key
    rsa_key = RSA.importKey(subjectPublicKeyInfo)
    return rsa_key


def pem_format(key):
    return "\n".join(["-----BEGIN CERTIFICATE-----",
                      key, "-----END CERTIFICATE-----"])


def import_rsa_key_from_file(filename):
    return RSA.importKey(open(filename, 'r').read())


def parse_xmlsec_output(output):
    """ Parse the output from xmlsec to try to find out if the
    command was successfull or not.

    :param output: The output from Popen
    :return: A boolean; True if the command was a success otherwise False
    """
    for line in output.split("\n"):
        if line == "OK":
            return True
        elif line == "FAIL":
            raise XmlsecError(output)
    raise XmlsecError(output)


def sha1_digest(msg):
    return hashlib.sha1(msg).digest()


class Signer(object):
    """Abstract base class for signing algorithms."""

    def sign(self, msg, key):
        """Sign ``msg`` with ``key`` and return the signature."""
        raise NotImplementedError

    def verify(self, msg, sig, key):
        """Return True if ``sig`` is a valid signature for ``msg``."""
        raise NotImplementedError


class RSASigner(Signer):
    def __init__(self, digest):
        self.digest = digest

    def sign(self, msg, key):
        h = self.digest.new(msg)
        signer = PKCS1_v1_5.new(key)
        return signer.sign(h)

    def verify(self, msg, sig, key):
        h = self.digest.new(msg)
        verifier = PKCS1_v1_5.new(key)
        return verifier.verify(h, sig)


SIGNER_ALGS = {
    RSA_SHA1: RSASigner(SHA),
    "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256": RSASigner(SHA256),
    "http://www.w3.org/2001/04/xmldsig-more#rsa-sha384": RSASigner(SHA384),
    "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512": RSASigner(SHA512),
}

REQ_ORDER = ["SAMLRequest", "RelayState", "SigAlg"]
RESP_ORDER = ["SAMLResponse", "RelayState", "SigAlg"]


def verify_redirect_signature(saml_msg, cert):
    """

    :param saml_msg: A dictionary as produced by parse_qs, means all values are
        lists.
    :param cert: A certificate to use when verifying the signature
    :return: True, if signature verified
    """

    try:
        signer = SIGNER_ALGS[saml_msg["SigAlg"][0]]
    except KeyError:
        raise Unsupported("Signature algorithm: %s" % saml_msg["SigAlg"])
    else:
        if saml_msg["SigAlg"][0] == RSA_SHA1:
            if "SAMLRequest" in saml_msg:
                _order = REQ_ORDER
            elif "SAMLResponse" in saml_msg:
                _order = RESP_ORDER
            else:
                raise Unsupported(
                    "Verifying signature on something that should not be "
                    "signed")
            args = saml_msg.copy()
            del args["Signature"]  # everything but the signature
            string = "&".join(
                [urllib.urlencode({k: args[k][0]}) for k in _order])
            _key = extract_rsa_key_from_x509_cert(pem_format(cert))
            _sign = base64.b64decode(saml_msg["Signature"][0])
            try:
                signer.verify(string, _sign, _key)
                return True
            except BadSignature:
                return False


LOG_LINE = 60 * "=" + "\n%s\n" + 60 * "-" + "\n%s" + 60 * "="
LOG_LINE_2 = 60 * "=" + "\n%s\n%s\n" + 60 * "-" + "\n%s" + 60 * "="


# ---------------------------------------------------------------------------


def read_cert_from_file(cert_file, cert_type):
    """ Reads a certificate from a file. The assumption is that there is
    only one certificate in the file

    :param cert_file: The name of the file
    :param cert_type: The certificate type
    :return: A base64 encoded certificate as a string or the empty string
    """
    if not cert_file:
        return ""

    if cert_type == "pem":
        line = open(cert_file).read().split("\n")
        if line[0] == "-----BEGIN CERTIFICATE-----":
            line = line[1:]
        elif line[0] == "-----BEGIN PUBLIC KEY-----":
            line = line[1:]
        else:
            raise CertificateError("Strange beginning of PEM file")

        while line[-1] == "":
            line = line[:-1]

        if line[-1] == "-----END CERTIFICATE-----":
            line = line[:-1]
        elif line[-1] == "-----END PUBLIC KEY-----":
            line = line[:-1]
        else:
            raise CertificateError("Strange end of PEM file")
        return "".join(line)

    if cert_type in ["der", "cer", "crt"]:
        data = open(cert_file).read()
        return base64.b64encode(str(data))


class CryptoBackend():
    def __init__(self, debug=False):
        self.debug = debug

    def version(self):
        raise NotImplementedError()

    def encrypt(self, text, recv_key, template, key_type):
        raise NotImplementedError()

    def encrypt_assertion(self, statement, recv_key, key_type, xpath=""):
        raise NotImplementedError()

    def decrypt(self, enctext, key_file):
        raise NotImplementedError()

    def sign_statement(self, statement, class_name, key_file, node_id,
                       id_attr):
        raise NotImplementedError()

    def validate_signature(self, enctext, cert_file, cert_type, node_name,
                           node_id, id_attr):
        raise NotImplementedError()


ASSERT_XPATH = ''.join(["/*[local-name()=\"%s\"]" % v for v in [
    "Response", "EncryptedAssertion", "Assertion"]])


class CryptoBackendXmlSec1(CryptoBackend):
    """
    CryptoBackend implementation using external binary xmlsec1 to sign
    and verify XML documents.
    """

    __DEBUG = 0

    def __init__(self, xmlsec_binary, **kwargs):
        CryptoBackend.__init__(self, **kwargs)
        assert (isinstance(xmlsec_binary, basestring))
        self.xmlsec = xmlsec_binary

    def version(self):
        com_list = [self.xmlsec, "--version"]
        pof = Popen(com_list, stderr=PIPE, stdout=PIPE)
        try:
            return pof.stdout.read().split(" ")[1]
        except IndexError:
            return ""

    def encrypt(self, text, recv_key, template, session_key_type, xpath=""):
        """

        :param text: The text to be compiled
        :param recv_key: Filename of a file where the key resides
        :param template: Filename of a file with the pre-encryption part
        :param session_key_type: Type and size of a new session key
            "des-192" generates a new 192 bits DES key for DES3 encryption
        :param xpath: What should be encrypted
        :return:
        """
        logger.debug("Encryption input len: %d" % len(text))
        _, fil = make_temp("%s" % text, decode=False)

        com_list = [self.xmlsec, "--encrypt", "--pubkey-cert-pem", recv_key,
                    "--session-key", session_key_type, "--xml-data", fil]

        if xpath:
            com_list.extend(['--node-xpath', xpath])

        (_stdout, _stderr, output) = self._run_xmlsec(com_list, [template],
                                                      exception=DecryptError,
                                                      validate_output=False)
        return output

    def encrypt_assertion(self, statement, enc_key, template,
                          key_type="des-192"):
        """
        --pubkey-cert-pem ../../example/idp2/pki/mycert.pem \
    --session-key des-192 --xml-data pre_saml2_assertion.xml \
    --node-xpath '/*[local-name()="Response"]/*[local-name(
    )="EncryptedAssertion"]/*[local-name()="Assertion"]' \
    enc-element-3des-kt-rsa1_5.tmpl > enc_3des_rsa_assertion.xml

        :param statement:
        :param cert_file:
        :param cert_type:
        :return:
        """
        statement = pre_encrypt_assertion(statement)
        _, fil = make_temp("%s" % statement, decode=False, delete=False)
        _, tmpl = make_temp("%s" % template, decode=False)

        com_list = [self.xmlsec, "encrypt", "--pubkey-cert-pem", enc_key,
                    "--session-key", key_type, "--xml-data", fil,
                    "--node-xpath", ASSERT_XPATH]

        (_stdout, _stderr, output) = self._run_xmlsec(
            com_list, [tmpl], exception=EncryptError, validate_output=False)

        os.unlink(fil)
        if not output:
            raise EncryptError(_stderr)

        return output

    def decrypt(self, enctext, key_file):
        logger.debug("Decrypt input len: %d" % len(enctext))
        _, fil = make_temp("%s" % enctext, decode=False)

        com_list = [self.xmlsec, "--decrypt", "--privkey-pem",
                    key_file, "--id-attr:%s" % ID_ATTR, ENC_KEY_CLASS]

        (_stdout, _stderr, output) = self._run_xmlsec(com_list, [fil],
                                                      exception=DecryptError,
                                                      validate_output=False)
        return output

    def sign_statement(self, statement, class_name, key_file, node_id,
                       id_attr):
        """
        Sign an XML statement.

        :param statement: The statement to be signed
        :param class_name: string like 'urn:oasis:names:...:Assertion'
        :param key_file: The file where the key can be found
        :param node_id:
        :param id_attr: The attribute name for the identifier, normally one of
            'id','Id' or 'ID'
        :return: The signed statement
        """

        _, fil = make_temp("%s" % statement, decode=False)

        com_list = [self.xmlsec, "--sign",
                    "--privkey-pem", key_file,
                    "--id-attr:%s" % id_attr, class_name]
        if node_id:
            com_list.extend(["--node-id", node_id])

        try:
            (stdout, stderr, signed_statement) = \
                self._run_xmlsec(com_list, [fil], validate_output=False)
            # this doesn't work if --store-signatures are used
            if stdout == "":
                if signed_statement:
                    return signed_statement
            logger.error(
                "Signing operation failed :\nstdout : %s\nstderr : %s" % (
                    stdout, stderr))
            raise SigverError("Signing failed")
        except DecryptError:
            raise SigverError("Signing failed")

    def validate_signature(self, signedtext, cert_file, cert_type, node_name,
                           node_id, id_attr):
        """
        Validate signature on XML document.

        :param signedtext: The XML document as a string
        :param cert_file: The public key that was used to sign the document
        :param cert_type: The file type of the certificate
        :param node_name: The name of the class that is signed
        :param node_id: The identifier of the node
        :param id_attr: Should normally be one of "id", "Id" or "ID"
        :return: Boolean True if the signature was correct otherwise False.
        """
        _, fil = make_temp(signedtext, decode=False)

        com_list = [self.xmlsec, "--verify",
                    "--pubkey-cert-%s" % cert_type, cert_file,
                    "--id-attr:%s" % id_attr, node_name]

        if self.debug:
            com_list.append("--store-signatures")

        if node_id:
            com_list.extend(["--node-id", node_id])

        if self.__DEBUG:
            try:
                print " ".join(com_list)
            except TypeError:
                print "cert_type", cert_type
                print "cert_file", cert_file
                print "node_name", node_name
                print "fil", fil
                raise
            print "%s: %s" % (cert_file, os.access(cert_file, os.F_OK))
            print "%s: %s" % (fil, os.access(fil, os.F_OK))

        (_stdout, stderr, _output) = self._run_xmlsec(com_list, [fil],
                                                      exception=SignatureError)
        return parse_xmlsec_output(stderr)

    def _run_xmlsec(self, com_list, extra_args, validate_output=True,
                    exception=XmlsecError):
        """
        Common code to invoke xmlsec and parse the output.
        :param com_list: Key-value parameter list for xmlsec
        :param extra_args: Positional parameters to be appended after all
            key-value parameters
        :param validate_output: Parse and validate the output
        :param exception: The exception class to raise on errors
        :result: Whatever xmlsec wrote to an --output temporary file
        """
        ntf = NamedTemporaryFile()
        com_list.extend(["--output", ntf.name])
        com_list += extra_args

        logger.debug("xmlsec command: %s" % " ".join(com_list))

        pof = Popen(com_list, stderr=PIPE, stdout=PIPE)

        p_out = pof.stdout.read()
        p_err = pof.stderr.read()
        try:
            if validate_output:
                parse_xmlsec_output(p_err)
        except XmlsecError, exc:
            logger.error(LOG_LINE_2 % (p_out, p_err, exc))
            raise exception("%s" % (exc,))

        ntf.seek(0)
        return p_out, p_err, ntf.read()


class CryptoBackendXMLSecurity(CryptoBackend):
    """
    CryptoBackend implementation using pyXMLSecurity to sign and verify
    XML documents.

    Encrypt and decrypt is currently unsupported by pyXMLSecurity.

    pyXMLSecurity uses lxml (libxml2) to parse XML data, but otherwise
    try to get by with native Python code. It does native Python RSA
    signatures, or alternatively PyKCS11 to offload cryptographic work
    to an external PKCS#11 module.
    """

    def __init__(self, debug=False):
        CryptoBackend.__init__(self)
        self.debug = debug

    def version(self):
        # XXX if XMLSecurity.__init__ included a __version__, that would be
        # better than static 0.0 here.
        return "XMLSecurity 0.0"

    def sign_statement(self, statement, _class_name, key_file, node_id,
                       _id_attr):
        """
        Sign an XML statement.

        The parameters actually used in this CryptoBackend
        implementation are :

        :param statement: XML as string
        :param key_file: xmlsec key_spec string(), filename,
            "pkcs11://" URI or PEM data
        :returns: Signed XML as string
        """
        import xmlsec
        import lxml.etree

        xml = xmlsec.parse_xml(statement)
        signed = xmlsec.sign(xml, key_file)
        return lxml.etree.tostring(signed, xml_declaration=True)

    def validate_signature(self, signedtext, cert_file, cert_type, node_name,
                           node_id, id_attr):
        """
        Validate signature on XML document.

        The parameters actually used in this CryptoBackend
        implementation are :

        :param signedtext: The signed XML data as string
        :param cert_file: xmlsec key_spec string(), filename,
            "pkcs11://" URI or PEM data
        :param cert_type: string, must be 'pem' for now
        :returns: True on successful validation, False otherwise
        """
        if cert_type != "pem":
            raise Unsupported("Only PEM certs supported here")
        import xmlsec

        xml = xmlsec.parse_xml(signedtext)
        try:
            return xmlsec.verify(xml, cert_file)
        except xmlsec.XMLSigException:
            return False


def security_context(conf, debug=None):
    """ Creates a security context based on the configuration

    :param conf: The configuration
    :return: A SecurityContext instance
    """
    if not conf:
        return None

    if debug is None:
        debug = conf.debug

    metadata = conf.metadata

    _only_md = conf.only_use_keys_in_metadata
    if _only_md is None:
        _only_md = False

    if conf.crypto_backend == 'xmlsec1':
        xmlsec_binary = conf.xmlsec_binary
        if not xmlsec_binary:
            try:
                _path = conf.xmlsec_path
            except AttributeError:
                _path = []
            xmlsec_binary = get_xmlsec_binary(_path)
            # verify that xmlsec is where it's supposed to be
        if not os.path.exists(xmlsec_binary):
            #if not os.access(, os.F_OK):
            raise SigverError(
                "xmlsec binary not in '%s' !" % xmlsec_binary)
        crypto = _get_xmlsec_cryptobackend(xmlsec_binary, debug=debug)
    elif conf.crypto_backend == 'XMLSecurity':
        # new and somewhat untested pyXMLSecurity crypto backend.
        crypto = CryptoBackendXMLSecurity(debug=debug)
    else:
        raise SigverError('Unknown crypto_backend %s' % (
            repr(conf.crypto_backend)))

    return SecurityContext(
        crypto, conf.key_file, cert_file=conf.cert_file, metadata=metadata,
        debug=debug, only_use_keys_in_metadata=_only_md,
        cert_handler_extra_class=conf.cert_handler_extra_class,
        generate_cert_info=conf.generate_cert_info,
        tmp_cert_file=conf.tmp_cert_file,
        tmp_key_file=conf.tmp_key_file,
        validate_certificate=conf.validate_certificate)


def encrypt_cert_from_item(item):
    _encrypt_cert = None
    try:
        _elem = extension_elements_to_elements(item.extension_elements[0].children,
                                               [pefim, ds])
        if len(_elem) == 1:
            _encrypt_cert = _elem[0].x509_data[0].x509_certificate.text
        else:
            certs = cert_from_instance(item)
            if len(certs) > 0:
                _encrypt_cert = certs[0]
        if _encrypt_cert is not None:
            if _encrypt_cert.find("-----BEGIN CERTIFICATE-----\n") == -1:
                _encrypt_cert = "-----BEGIN CERTIFICATE-----\n" + _encrypt_cert
            if _encrypt_cert.find("-----END CERTIFICATE-----\n") == -1:
                _encrypt_cert = _encrypt_cert + "-----END CERTIFICATE-----\n"
    except Exception:
        return None
    return _encrypt_cert


class CertHandlerExtra(object):
    def __init__(self):
        pass

    def use_generate_cert_func(self):
        raise Exception("use_generate_cert_func function must be implemented")

    def generate_cert(self, generate_cert_info, root_cert_string,
                      root_key_string):
        raise Exception("generate_cert function must be implemented")
        #Excepts to return (cert_string, key_string)

    def use_validate_cert_func(self):
        raise Exception("use_validate_cert_func function must be implemented")

    def validate_cert(self, cert_str, root_cert_string, root_key_string):
        raise Exception("validate_cert function must be implemented")
        #Excepts to return True/False


class CertHandler(object):
    def __init__(self, security_context, cert_file=None, cert_type="pem",
                 key_file=None, key_type="pem", generate_cert_info=None,
                 cert_handler_extra_class=None, tmp_cert_file=None,
                 tmp_key_file=None, verify_cert=False):
        """
        Initiates the class for handling certificates. Enables the certificates
        to either be a single certificate as base functionality or makes it
        possible to generate a new certificate for each call to the function.

        :param security_context:
        :param cert_file:
        :param cert_type:
        :param key_file:
        :param key_type:
        :param generate_cert_info:
        :param cert_handler_extra_class:
        :param tmp_cert_file:
        :param tmp_key_file:
        :param verify_cert:
        """

        self._verify_cert = False
        self._generate_cert = False
        #This cert do not have to be valid, it is just the last cert to be
        # validated.
        self._last_cert_verified = None
        if cert_type == "pem" and key_type == "pem":
            self._verify_cert = verify_cert is True
            self._security_context = security_context
            self._osw = OpenSSLWrapper()
            if key_file is not None and os.path.isfile(key_file):
                self._key_str = self._osw.read_str_from_file(key_file, key_type)
            else:
                self._key_str = ""
            if cert_file is not None:
                self._cert_str = self._osw.read_str_from_file(cert_file,
                                                              cert_type)
            else:
                self._cert_str = ""

            self._tmp_cert_str = self._cert_str
            self._tmp_key_str = self._key_str
            self._tmp_cert_file = tmp_cert_file
            self._tmp_key_file = tmp_key_file

            self._cert_info = None
            self._generate_cert_func_active = False
            if generate_cert_info is not None and len(self._cert_str) > 0 and \
                            len(self._key_str) > 0 and tmp_key_file is not \
                    None and tmp_cert_file is not None:
                self._generate_cert = True
                self._cert_info = generate_cert_info
                self._cert_handler_extra_class = cert_handler_extra_class

    def verify_cert(self, cert_file):
        if self._verify_cert:
            cert_str = self._osw.read_str_from_file(cert_file, "pem")
            self._last_validated_cert = cert_str
            if self._cert_handler_extra_class is not None and \
                    self._cert_handler_extra_class.use_validate_cert_func():
                self._cert_handler_extra_class.validate_cert(
                    cert_str, self._cert_str, self._key_str)
            else:
                valid, mess = self._osw.verify(self._cert_str, cert_str)
                logger.info("CertHandler.verify_cert: %s" % mess)
                return valid
        return True

    def generate_cert(self):
        return self._generate_cert

    def update_cert(self, active=False, client_crt=None):
        if (self._generate_cert and active) or client_crt is not None:
            if client_crt is not None:
                self._tmp_cert_str = client_crt
                #No private key for signing
                self._tmp_key_str = ""
            elif self._cert_handler_extra_class is not None and \
                    self._cert_handler_extra_class.use_generate_cert_func():
                (self._tmp_cert_str, self._tmp_key_str) = \
                    self._cert_handler_extra_class.generate_cert(
                        self._cert_info, self._cert_str, self._key_str)
            else:
                self._tmp_cert_str, self._tmp_key_str = self._osw\
                    .create_certificate(
                    self._cert_info, request=True)
                self._tmp_cert_str = self._osw.create_cert_signed_certificate(
                    self._cert_str, self._key_str, self._tmp_cert_str)
                valid, mess = self._osw.verify(self._cert_str,
                                               self._tmp_cert_str)
            self._osw.write_str_to_file(self._tmp_cert_file, self._tmp_cert_str)
            self._osw.write_str_to_file(self._tmp_key_file, self._tmp_key_str)
            self._security_context.key_file = self._tmp_key_file
            self._security_context.cert_file = self._tmp_cert_file
            self._security_context.key_type = "pem"
            self._security_context.cert_type = "pem"
            self._security_context.my_cert = read_cert_from_file(
                self._security_context.cert_file,
                self._security_context.cert_type)


# How to get a rsa pub key fingerprint from a certificate
# openssl x509 -inform pem -noout -in server.crt -pubkey > publickey.pem
# openssl rsa -inform pem -noout -in publickey.pem -pubin -modulus
class SecurityContext(object):
    my_cert = None

    def __init__(self, crypto, key_file="", key_type="pem",
                 cert_file="", cert_type="pem", metadata=None,
                 debug=False, template="", encrypt_key_type="des-192",
                 only_use_keys_in_metadata=False, cert_handler_extra_class=None,
                 generate_cert_info=None, tmp_cert_file=None,
                 tmp_key_file=None, validate_certificate=None):

        self.crypto = crypto
        assert (isinstance(self.crypto, CryptoBackend))

        # Your private key
        self.key_file = key_file
        self.key_type = key_type

        # Your public key
        self.cert_file = cert_file
        self.cert_type = cert_type

        self.my_cert = read_cert_from_file(cert_file, cert_type)

        self.cert_handler = CertHandler(self, cert_file, cert_type, key_file,
                                        key_type, generate_cert_info,
                                        cert_handler_extra_class, tmp_cert_file,
                                        tmp_key_file, validate_certificate)

        self.cert_handler.update_cert(True)

        self.metadata = metadata
        self.only_use_keys_in_metadata = only_use_keys_in_metadata
        self.debug = debug

        if not template:
            this_dir, this_filename = os.path.split(__file__)
            self.template = os.path.join(this_dir, "xml", "template.xml")
        else:
            self.template = template

        self.encrypt_key_type = encrypt_key_type

    def correctly_signed(self, xml, must=False):
        logger.debug("verify correct signature")
        return self.correctly_signed_response(xml, must)

    def encrypt(self, text, recv_key="", template="", key_type=""):
        """
        xmlsec encrypt --pubkey-pem pub-userkey.pem
            --session-key aes128-cbc --xml-data doc-plain.xml
            --output doc-encrypted.xml session-key-template.xml

        :param text: Text to encrypt
        :param recv_key: A file containing the receivers public key
        :param template: A file containing the XMLSEC template
        :param key_type: The type of session key to use
        :result: An encrypted XML text
        """
        if not key_type:
            key_type = self.encrypt_key_type
        if not template:
            template = self.template

        return self.crypto.encrypt(text, recv_key, template, key_type)

    def encrypt_assertion(self, statement, cert_file, cert_type="pem"):
        """
        --pubkey-cert-pem ../../example/idp2/pki/mycert.pem \
    --session-key des-192 --xml-data pre_saml2_assertion.xml \
    --node-xpath '/*[local-name()="Response"]/*[local-name(
    )="EncryptedAssertion"]/*[local-name()="Assertion"]' \
    enc-element-3des-kt-rsa1_5.tmpl > enc_3des_rsa_assertion.xml
        :param statement:
        :param cert_file:
        :param cert_type:
        :return:
        """

    def decrypt(self, enctext, key_file=None):
        """ Decrypting an encrypted text by the use of a private key.

        :param enctext: The encrypted text as a string
        :return: The decrypted text
        """
        if key_file is not None and len(key_file.strip()) > 0:
            return self.crypto.decrypt(enctext, key_file)
        return self.crypto.decrypt(enctext, self.key_file)

    def verify_signature(self, signedtext, cert_file=None, cert_type="pem",
                         node_name=NODE_NAME, node_id=None, id_attr=""):
        """ Verifies the signature of a XML document.

        :param signedtext: The XML document as a string
        :param cert_file: The public key that was used to sign the document
        :param cert_type: The file type of the certificate
        :param node_name: The name of the class that is signed
        :param node_id: The identifier of the node
        :param id_attr: Should normally be one of "id", "Id" or "ID"
        :return: Boolean True if the signature was correct otherwise False.
        """
        # This is only for testing purposes, otherwise when would you receive
        # stuff that is signed with your key !?
        if not cert_file:
            cert_file = self.cert_file
            cert_type = self.cert_type

        if not id_attr:
            id_attr = ID_ATTR

        return self.crypto.validate_signature(signedtext, cert_file=cert_file,
                                              cert_type=cert_type,
                                              node_name=node_name,
                                              node_id=node_id, id_attr=id_attr)

    def _check_signature(self, decoded_xml, item, node_name=NODE_NAME,
                         origdoc=None, id_attr="", must=False,
                         only_valid_cert=False):
        #print item
        try:
            issuer = item.issuer.text.strip()
        except AttributeError:
            issuer = None

        # More trust in certs from metadata then certs in the XML document
        if self.metadata:
            try:
                _certs = self.metadata.certs(issuer, "any", "signing")
            except KeyError:
                _certs = []
            certs = []
            for cert in _certs:
                if isinstance(cert, basestring):
                    certs.append(make_temp(pem_format(cert), ".pem", False))
                else:
                    certs.append(cert)
        else:
            certs = []

        if not certs and not self.only_use_keys_in_metadata:
            logger.debug("==== Certs from instance ====")
            certs = [make_temp(pem_format(cert), ".pem",
                               False) for cert in cert_from_instance(item)]
        else:
            logger.debug("==== Certs from metadata ==== %s: %s ====" % (issuer,
                                                                        certs))

        if not certs:
            raise MissingKey("%s" % issuer)

        #print certs

        verified = False
        last_pem_file = None
        for _, pem_file in certs:
            try:
                last_pem_file = pem_file
                if origdoc is not None:
                    try:
                        if self.verify_signature(origdoc, pem_file,
                                                 node_name=node_name,
                                                 node_id=item.id,
                                                 id_attr=id_attr):
                            verified = True
                            break
                    except Exception:
                        if self.verify_signature(decoded_xml, pem_file,
                                                 node_name=node_name,
                                                 node_id=item.id,
                                                 id_attr=id_attr):
                            verified = True
                            break
                else:
                    if self.verify_signature(decoded_xml, pem_file,
                                             node_name=node_name,
                                             node_id=item.id, id_attr=id_attr):
                        verified = True
                        break
            except XmlsecError, exc:
                logger.error("check_sig: %s" % exc)
                pass
            except SignatureError, exc:
                logger.error("check_sig: %s" % exc)
                pass
            except Exception, exc:
                logger.error("check_sig: %s" % exc)
                raise

        if (not verified) and (not only_valid_cert):
            raise SignatureError("Failed to verify signature")
        else:
            if not self.cert_handler.verify_cert(last_pem_file):
                raise CertificateError("Invalid certificate!")

        return item

    def check_signature(self, item, node_name=NODE_NAME, origdoc=None,
                        id_attr="", must=False):
        """

        :param item: Parsed entity
        :param node_name:
        :param origdoc: The original XML string
        :param id_attr:
        :param must:
        :return:
        """
        return self._check_signature(origdoc, item, node_name, origdoc,
                                     id_attr=id_attr, must=must)

    def correctly_signed_message(self, decoded_xml, msgtype, must=False,
                                 origdoc=None, only_valid_cert=False):
        """Check if a request is correctly signed, if we have metadata for
        the entity that sent the info use that, if not use the key that are in
        the message if any.

        :param decoded_xml: The SAML message as a XML string
        :param msgtype:
        :param must: Whether there must be a signature
        :param origdoc:
        :return:
        """

        try:
            _func = getattr(samlp, "%s_from_string" % msgtype)
        except AttributeError:
            _func = getattr(saml, "%s_from_string" % msgtype)

        msg = _func(decoded_xml)
        if not msg:
            raise TypeError("Not a %s" % msgtype)

        if not msg.signature:
            if must:
                raise SignatureError("Missing must signature")
            else:
                return msg

        return self._check_signature(decoded_xml, msg, class_name(msg),
                                     origdoc, must=must,
                                     only_valid_cert=only_valid_cert)

    def correctly_signed_authn_request(self, decoded_xml, must=False,
                                       origdoc=None, only_valid_cert=False,
                                       **kwargs):
        return self.correctly_signed_message(decoded_xml, "authn_request",
                                             must, origdoc,
                                             only_valid_cert=only_valid_cert)

    def correctly_signed_authn_query(self, decoded_xml, must=False,
                                     origdoc=None, only_valid_cert=False,
                                     **kwargs):
        return self.correctly_signed_message(decoded_xml, "authn_query",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_logout_request(self, decoded_xml, must=False,
                                        origdoc=None, only_valid_cert=False,
                                        **kwargs):
        return self.correctly_signed_message(decoded_xml, "logout_request",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_logout_response(self, decoded_xml, must=False,
                                         origdoc=None, only_valid_cert=False,
                                         **kwargs):
        return self.correctly_signed_message(decoded_xml, "logout_response",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_attribute_query(self, decoded_xml, must=False,
                                         origdoc=None, only_valid_cert=False,
                                         **kwargs):
        return self.correctly_signed_message(decoded_xml, "attribute_query",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_authz_decision_query(self, decoded_xml, must=False,
                                              origdoc=None,
                                              only_valid_cert=False,
                                              **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "authz_decision_query", must,
                                             origdoc, only_valid_cert)

    def correctly_signed_authz_decision_response(self, decoded_xml, must=False,
                                                 origdoc=None,
                                                 only_valid_cert=False,
                                                 **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "authz_decision_response", must,
                                             origdoc, only_valid_cert)

    def correctly_signed_name_id_mapping_request(self, decoded_xml, must=False,
                                                 origdoc=None,
                                                 only_valid_cert=False,
                                                 **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "name_id_mapping_request",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_name_id_mapping_response(self, decoded_xml, must=False,
                                                  origdoc=None,
                                                  only_valid_cert=False,
                                                  **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "name_id_mapping_response",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_artifact_request(self, decoded_xml, must=False,
                                          origdoc=None, only_valid_cert=False,
                                          **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "artifact_request",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_artifact_response(self, decoded_xml, must=False,
                                           origdoc=None, only_valid_cert=False,
                                           **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "artifact_response",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_manage_name_id_request(self, decoded_xml, must=False,
                                                origdoc=None,
                                                only_valid_cert=False,
                                                **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "manage_name_id_request",
                                             must, origdoc, only_valid_cert)

    def correctly_signed_manage_name_id_response(self, decoded_xml, must=False,
                                                 origdoc=None,
                                                 only_valid_cert=False,
                                                 **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "manage_name_id_response", must,
                                             origdoc, only_valid_cert)

    def correctly_signed_assertion_id_request(self, decoded_xml, must=False,
                                              origdoc=None,
                                              only_valid_cert=False,
                                              **kwargs):
        return self.correctly_signed_message(decoded_xml,
                                             "assertion_id_request", must,
                                             origdoc, only_valid_cert)

    def correctly_signed_assertion_id_response(self, decoded_xml, must=False,
                                               origdoc=None,
                                               only_valid_cert=False, **kwargs):
        return self.correctly_signed_message(decoded_xml, "assertion", must,
                                             origdoc, only_valid_cert)

    def correctly_signed_response(self, decoded_xml, must=False, origdoc=None,
                                  only_valid_cert=False,
                                  require_response_signature=False, **kwargs):
        """ Check if a instance is correctly signed, if we have metadata for
        the IdP that sent the info use that, if not use the key that are in
        the message if any.

        :param decoded_xml: The SAML message as a XML string
        :param must: Whether there must be a signature
        :param origdoc:
        :param only_valid_cert:
        :param require_response_signature:
        :return: None if the signature can not be verified otherwise an instance
        """

        response = samlp.any_response_from_string(decoded_xml)
        if not response:
            raise TypeError("Not a Response")

        if response.signature:
            self._check_signature(decoded_xml, response, class_name(response),
                                  origdoc)
        elif require_response_signature:
            raise SignatureError("Signature missing for response")

        # if isinstance(response, Response) and response.assertion:
        #     # Try to find the signing cert in the assertion
        #     for assertion in response.assertion:
        #         if not hasattr(assertion, 'signature') or not assertion.signature:
        #             logger.debug("unsigned")
        #             if must:
        #                 raise SignatureError("Signature missing for assertion")
        #             continue
        #         else:
        #             logger.debug("signed")
        #
        #         try:
        #             self._check_signature(decoded_xml, assertion,
        #                                   class_name(assertion), origdoc)
        #         except Exception, exc:
        #             logger.error("correctly_signed_response: %s" % exc)
        #             raise

        return response

    #--------------------------------------------------------------------------
    # SIGNATURE PART
    #--------------------------------------------------------------------------
    def sign_statement_using_xmlsec(self, statement, **kwargs):
        """ Deprecated function. See sign_statement(). """
        return self.sign_statement(statement, **kwargs)

    def sign_statement(self, statement, class_name, key=None,
                       key_file=None, node_id=None, id_attr=""):
        """Sign a SAML statement.

        :param statement: The statement to be signed
        :param class_name: string like 'urn:oasis:names:...:Assertion'
        :param key: The key to be used for the signing, either this or
        :param key_file: The file where the key can be found
        :param node_id:
        :param id_attr: The attribute name for the identifier, normally one of
            'id','Id' or 'ID'
        :return: The signed statement
        """
        if not id_attr:
            id_attr = ID_ATTR

        if not key_file and key:
            _, key_file = make_temp("%s" % key, ".pem")

        if not key and not key_file:
            key_file = self.key_file

        return self.crypto.sign_statement(statement, class_name, key_file,
                                          node_id, id_attr)

    def sign_assertion_using_xmlsec(self, statement, **kwargs):
        """ Deprecated function. See sign_assertion(). """
        return self.sign_statement(statement, class_name(saml.Assertion()),
                                   **kwargs)

    def sign_assertion(self, statement, **kwargs):
        """Sign a SAML assertion.

        See sign_statement() for the kwargs.

        :param statement: The statement to be signed
        :return: The signed statement
        """
        return self.sign_statement(statement, class_name(saml.Assertion()),
                                   **kwargs)

    def sign_attribute_query_using_xmlsec(self, statement, **kwargs):
        """ Deprecated function. See sign_attribute_query(). """
        return self.sign_attribute_query(statement, **kwargs)

    def sign_attribute_query(self, statement, **kwargs):
        """Sign a SAML attribute query.

        See sign_statement() for the kwargs.

        :param statement: The statement to be signed
        :return: The signed statement
        """
        return self.sign_statement(statement, class_name(
            samlp.AttributeQuery()), **kwargs)

    def multiple_signatures(self, statement, to_sign, key=None, key_file=None):
        """
        Sign multiple parts of a statement

        :param statement: The statement that should be sign, this is XML text
        :param to_sign: A list of (items, id, id attribute name) tuples that
            specifies what to sign
        :param key: A key that should be used for doing the signing
        :param key_file: A file that contains the key to be used
        :return: A possibly multiple signed statement
        """
        for (item, sid, id_attr) in to_sign:
            if not sid:
                if not item.id:
                    sid = item.id = sid()
                else:
                    sid = item.id

            if not item.signature:
                item.signature = pre_signature_part(sid, self.cert_file)

            statement = self.sign_statement(statement, class_name(item),
                                            key=key, key_file=key_file,
                                            node_id=sid, id_attr=id_attr)
        return statement


# ===========================================================================


def pre_signature_part(ident, public_key=None, identifier=None):
    """
    If an assertion is to be signed the signature part has to be preset
    with which algorithms to be used, this function returns such a
    preset part.

    :param ident: The identifier of the assertion, so you know which assertion
        was signed
    :param public_key: The base64 part of a PEM file
    :param identifier:
    :return: A preset signature part
    """

    signature_method = ds.SignatureMethod(algorithm=ds.SIG_RSA_SHA1)
    canonicalization_method = ds.CanonicalizationMethod(
        algorithm=ds.ALG_EXC_C14N)
    trans0 = ds.Transform(algorithm=ds.TRANSFORM_ENVELOPED)
    trans1 = ds.Transform(algorithm=ds.ALG_EXC_C14N)
    transforms = ds.Transforms(transform=[trans0, trans1])
    digest_method = ds.DigestMethod(algorithm=ds.DIGEST_SHA1)

    reference = ds.Reference(uri="#%s" % ident, digest_value=ds.DigestValue(),
                             transforms=transforms, digest_method=digest_method)

    signed_info = ds.SignedInfo(signature_method=signature_method,
                                canonicalization_method=canonicalization_method,
                                reference=reference)

    signature = ds.Signature(signed_info=signed_info,
                             signature_value=ds.SignatureValue())

    if identifier:
        signature.id = "Signature%d" % identifier

    if public_key:
        x509_data = ds.X509Data(
            x509_certificate=[ds.X509Certificate(text=public_key)])
        key_info = ds.KeyInfo(x509_data=x509_data)
        signature.key_info = key_info

    return signature


# <?xml version="1.0" encoding="UTF-8"?>
# <EncryptedData Id="ED" Type="http://www.w3.org/2001/04/xmlenc#Element"
# xmlns="http://www.w3.org/2001/04/xmlenc#">
#     <EncryptionMethod Algorithm="http://www.w3
# .org/2001/04/xmlenc#tripledes-cbc"/>
#     <ds:KeyInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
#       <EncryptedKey Id="EK" xmlns="http://www.w3.org/2001/04/xmlenc#">
#         <EncryptionMethod Algorithm="http://www.w3
# .org/2001/04/xmlenc#rsa-1_5"/>
#         <ds:KeyInfo xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
#           <ds:KeyName>my-rsa-key</ds:KeyName>
#         </ds:KeyInfo>
#         <CipherData>
#           <CipherValue>
#           </CipherValue>
#         </CipherData>
#         <ReferenceList>
#           <DataReference URI="#ED"/>
#         </ReferenceList>
#       </EncryptedKey>
#     </ds:KeyInfo>
#     <CipherData>
#       <CipherValue>
#       </CipherValue>
#     </CipherData>
# </EncryptedData>

def pre_encryption_part(msg_enc=TRIPLE_DES_CBC, key_enc=RSA_1_5,
                        key_name="my-rsa-key"):
    """

    :param msg_enc:
    :param key_enc:
    :param key_name:
    :return:
    """
    msg_encryption_method = EncryptionMethod(algorithm=msg_enc)
    key_encryption_method = EncryptionMethod(algorithm=key_enc)
    encrypted_key = EncryptedKey(id="EK",
                                 encryption_method=key_encryption_method,
                                 key_info=ds.KeyInfo(
                                     key_name=ds.KeyName(text=key_name)),
                                 cipher_data=CipherData(
                                     cipher_value=CipherValue(text="")))
    key_info = ds.KeyInfo(encrypted_key=encrypted_key)
    encrypted_data = EncryptedData(
        id="ED",
        type="http://www.w3.org/2001/04/xmlenc#Element",
        encryption_method=msg_encryption_method,
        key_info=key_info,
        cipher_data=CipherData(cipher_value=CipherValue(text="")))
    return encrypted_data


def pre_encrypt_assertion(response):
    """
    Move the assertion to within a encrypted_assertion
    :param response: The response with one assertion
    :return: The response but now with the assertion within an
        encrypted_assertion.
    """
    assertion = response.assertion
    response.assertion = None
    response.encrypted_assertion = EncryptedAssertion()
    if isinstance(assertion, list):
        response.encrypted_assertion.add_extension_elements(assertion)
    else:
        response.encrypted_assertion.add_extension_element(assertion)
    # txt = "%s" % response
    # _ass = "%s" % assertion
    # _ass = rm_xmltag(_ass)
    # txt.replace(
    #     "<ns1:EncryptedAssertion/>",
    #     "<ns1:EncryptedAssertion>%s</ns1:EncryptedAssertion>" % _ass)

    return response


def response_factory(sign=False, encrypt=False, **kwargs):
    response = samlp.Response(id=sid(), version=VERSION,
                              issue_instant=instant())

    if sign:
        response.signature = pre_signature_part(kwargs["id"])
    if encrypt:
        pass

    for key, val in kwargs.items():
        setattr(response, key, val)

    return response

########NEW FILE########
__FILENAME__ = soap
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Suppport for the client part of the SAML2.0 SOAP binding.
"""
import logging

from saml2 import create_class_from_element_tree
from saml2.samlp import NAMESPACE as SAMLP_NAMESPACE
from saml2.schema import soapenv

try:
    from xml.etree import cElementTree as ElementTree
except ImportError:
    try:
        import cElementTree as ElementTree
    except ImportError:
        #noinspection PyUnresolvedReferences
        from elementtree import ElementTree


logger = logging.getLogger(__name__)


class XmlParseError(Exception):
    pass


class WrongMessageType(Exception):
    pass


def parse_soap_enveloped_saml_response(text):
    tags = ['{%s}Response' % SAMLP_NAMESPACE, 
            '{%s}LogoutResponse' % SAMLP_NAMESPACE]
    return parse_soap_enveloped_saml_thingy(text, tags)


def parse_soap_enveloped_saml_logout_response(text):
    tags = ['{%s}Response' % SAMLP_NAMESPACE,
            '{%s}LogoutResponse' % SAMLP_NAMESPACE]
    return parse_soap_enveloped_saml_thingy(text, tags)


def parse_soap_enveloped_saml_attribute_query(text):
    expected_tag = '{%s}AttributeQuery' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_attribute_response(text):
    tags = ['{%s}Response' % SAMLP_NAMESPACE,
            '{%s}AttributeResponse' % SAMLP_NAMESPACE]
    return parse_soap_enveloped_saml_thingy(text, tags)


def parse_soap_enveloped_saml_logout_request(text):
    expected_tag = '{%s}LogoutRequest' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_authn_request(text):
    expected_tag = '{%s}AuthnRequest' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_artifact_resolve(text):
    expected_tag = '{%s}ArtifactResolve' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_artifact_response(text):
    expected_tag = '{%s}ArtifactResponse' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_name_id_mapping_request(text):
    expected_tag = '{%s}NameIDMappingRequest' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_name_id_mapping_response(text):
    expected_tag = '{%s}NameIDMappingResponse' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_manage_name_id_request(text):
    expected_tag = '{%s}ManageNameIDRequest' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_manage_name_id_response(text):
    expected_tag = '{%s}ManageNameIDResponse' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_assertion_id_request(text):
    expected_tag = '{%s}AssertionIDRequest' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_assertion_id_response(text):
    tags = ['{%s}Response' % SAMLP_NAMESPACE,
            '{%s}AssertionIDResponse' % SAMLP_NAMESPACE]
    return parse_soap_enveloped_saml_thingy(text, tags)


def parse_soap_enveloped_saml_authn_query(text):
    expected_tag = '{%s}AuthnQuery' % SAMLP_NAMESPACE
    return parse_soap_enveloped_saml_thingy(text, [expected_tag])


def parse_soap_enveloped_saml_authn_query_response(text):
    tags = ['{%s}Response' % SAMLP_NAMESPACE]
    return parse_soap_enveloped_saml_thingy(text, tags)


def parse_soap_enveloped_saml_authn_response(text):
    tags = ['{%s}Response' % SAMLP_NAMESPACE]
    return parse_soap_enveloped_saml_thingy(text, tags)


#def parse_soap_enveloped_saml_logout_response(text):
#    expected_tag = '{%s}LogoutResponse' % SAMLP_NAMESPACE
#    return parse_soap_enveloped_saml_thingy(text, [expected_tag])

def parse_soap_enveloped_saml_thingy(text, expected_tags):
    """Parses a SOAP enveloped SAML thing and returns the thing as
    a string.
    
    :param text: The SOAP object as XML string
    :param expected_tags: What the tag of the SAML thingy is expected to be.
    :return: SAML thingy as a string
    """
    envelope = ElementTree.fromstring(text)

    # Make sure it's a SOAP message
    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE
    
    assert len(envelope) >= 1
    body = None
    for part in envelope:
        if part.tag == '{%s}Body' % soapenv.NAMESPACE:
            assert len(part) == 1
            body = part
            break

    if body is None:
        return ""
    
    saml_part = body[0]
    if saml_part.tag in expected_tags:
        return ElementTree.tostring(saml_part, encoding="UTF-8")
    else:
        raise WrongMessageType("Was '%s' expected one of %s" % (saml_part.tag,
                                                                expected_tags))

import re

NS_AND_TAG = re.compile("\{([^}]+)\}(.*)")


def instanciate_class(item, modules):
    m = NS_AND_TAG.match(item.tag)
    ns, tag = m.groups()
    for module in modules:
        if module.NAMESPACE == ns:
            try:
                target = module.ELEMENT_BY_TAG[tag]
                return create_class_from_element_tree(target, item)
            except KeyError:
                continue
    raise Exception("Unknown class: ns='%s', tag='%s'" % (ns, tag))


def class_instances_from_soap_enveloped_saml_thingies(text, modules):
    """Parses a SOAP enveloped header and body SAML thing and returns the
    thing as a dictionary class instance.

    :param text: The SOAP object as XML
    :param modules: modules representing xsd schemas
    :return: The body and headers as class instances
    """
    try:
        envelope = ElementTree.fromstring(text)
    except Exception, exc:
        raise XmlParseError("%s" % exc)

    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE
    assert len(envelope) >= 1
    env = {"header": [], "body": None}
    
    for part in envelope:
        if part.tag == '{%s}Body' % soapenv.NAMESPACE:
            assert len(part) == 1
            env["body"] = instanciate_class(part[0], modules)
        elif part.tag == "{%s}Header" % soapenv.NAMESPACE:
            for item in part:
                env["header"].append(instanciate_class(item, modules))

    return env


def open_soap_envelope(text):
    """

    :param text: SOAP message
    :return: dictionary with two keys "body"/"header"
    """
    try:
        envelope = ElementTree.fromstring(text)
    except Exception, exc:
        raise XmlParseError("%s" % exc)

    assert envelope.tag == '{%s}Envelope' % soapenv.NAMESPACE
    assert len(envelope) >= 1
    content = {"header": [], "body": None}

    for part in envelope:
        if part.tag == '{%s}Body' % soapenv.NAMESPACE:
            assert len(part) == 1
            content["body"] = ElementTree.tostring(part[0], encoding="UTF-8")
        elif part.tag == "{%s}Header" % soapenv.NAMESPACE:
            for item in part:
                _str = ElementTree.tostring(item, encoding="UTF-8")
                content["header"].append(_str)

    return content


def make_soap_enveloped_saml_thingy(thingy, headers=None):
    """ Returns a soap envelope containing a SAML request
    as a text string.
    
    :param thingy: The SAML thingy
    :return: The SOAP envelope as a string
    """
    soap_envelope = soapenv.Envelope()

    if headers:
        _header = soapenv.Header()
        _header.add_extension_elements(headers)
        soap_envelope.header = _header

    soap_envelope.body = soapenv.Body()
    soap_envelope.body.add_extension_element(thingy)

    return "%s" % soap_envelope


def soap_fault(message=None, actor=None, code=None, detail=None):
    """ Create a SOAP Fault message

    :param message: Human readable error message
    :param actor: Who discovered the error
    :param code: Error code
    :param detail: More specific error message
    :return: A SOAP Fault message as a string
    """
    _string = _actor = _code = _detail = None

    if message:
        _string = soapenv.Fault_faultstring(text=message)
    if actor:
        _actor = soapenv.Fault_faultactor(text=actor)
    if code:
        _code = soapenv.Fault_faultcode(text=code)
    if detail:
        _detail = soapenv.Fault_detail(text=detail)

    fault = soapenv.Fault(
        faultcode=_code,
        faultstring=_string,
        faultactor=_actor,
        detail=_detail,
    )

    return "%s" % fault

########NEW FILE########
__FILENAME__ = s_utils
#!/usr/bin/env python
import logging
import random
import string

import time
import base64
import sys
import hmac

# from python 2.5
import imp
import traceback

if sys.version_info >= (2, 5):
    import hashlib
else:  # before python 2.5
    import sha

from saml2 import saml
from saml2 import samlp
from saml2 import VERSION
from saml2.time_util import instant

try:
    from hashlib import md5
except ImportError:
    from md5 import md5
import zlib

logger = logging.getLogger(__name__)


class SamlException(Exception):
    pass


class RequestVersionTooLow(SamlException):
    pass


class RequestVersionTooHigh(SamlException):
    pass


class UnknownPrincipal(SamlException):
    pass


class Unsupported(SamlException):
    pass


class UnsupportedBinding(Unsupported):
    pass


class VersionMismatch(Exception):
    pass


class Unknown(Exception):
    pass


class OtherError(Exception):
    pass


class MissingValue(Exception):
    pass


class PolicyError(Exception):
    pass


class BadRequest(Exception):
    pass


class UnravelError(Exception):
    pass


EXCEPTION2STATUS = {
    VersionMismatch: samlp.STATUS_VERSION_MISMATCH,
    UnknownPrincipal: samlp.STATUS_UNKNOWN_PRINCIPAL,
    UnsupportedBinding: samlp.STATUS_UNSUPPORTED_BINDING,
    RequestVersionTooLow: samlp.STATUS_REQUEST_VERSION_TOO_LOW,
    RequestVersionTooHigh: samlp.STATUS_REQUEST_VERSION_TOO_HIGH,
    OtherError: samlp.STATUS_UNKNOWN_PRINCIPAL,
    MissingValue: samlp.STATUS_REQUEST_UNSUPPORTED,
    # Undefined
    Exception: samlp.STATUS_AUTHN_FAILED,
}

GENERIC_DOMAINS = ["aero", "asia", "biz", "cat", "com", "coop", "edu", 
                   "gov", "info", "int", "jobs", "mil", "mobi", "museum", 
                   "name", "net", "org", "pro", "tel", "travel"]


def valid_email(emailaddress, domains=GENERIC_DOMAINS):
    """Checks for a syntactically valid email address."""

    # Email address must be at least 6 characters in total.
    # Assuming noone may have addresses of the type a@com
    if len(emailaddress) < 6:
        return False  # Address too short.

    # Split up email address into parts.
    try:
        localpart, domainname = emailaddress.rsplit('@', 1)
        host, toplevel = domainname.rsplit('.', 1)
    except ValueError:
        return False  # Address does not have enough parts.

    # Check for Country code or Generic Domain.
    if len(toplevel) != 2 and toplevel not in domains:
        return False  # Not a domain name.

    for i in '-_.%+.':
        localpart = localpart.replace(i, "")
    for i in '-_.':
        host = host.replace(i, "")

    if localpart.isalnum() and host.isalnum():
        return True  # Email address is fine.
    else:
        return False  # Email address has funny characters.
            

def decode_base64_and_inflate(string):
    """ base64 decodes and then inflates according to RFC1951 
    
    :param string: a deflated and encoded string
    :return: the string after decoding and inflating
    """

    return zlib.decompress(base64.b64decode(string), -15)


def deflate_and_base64_encode(string_val):
    """
    Deflates and the base64 encodes a string
    
    :param string_val: The string to deflate and encode
    :return: The deflated and encoded string
    """
    return base64.b64encode(zlib.compress(string_val)[2:-4])


def rndstr(size=16):
    """
    Returns a string of random ascii characters or digits

    :param size: The length of the string
    :return: string
    """
    _basech = string.ascii_letters + string.digits
    return "".join([random.choice(_basech) for _ in range(size)])


def sid(seed=""):
    """The hash of the server time + seed makes an unique SID for each session.
    128-bits long so it fulfills the SAML2 requirements which states
    128-160 bits

    :param seed: A seed string
    :return: The hex version of the digest, prefixed by 'id-' to make it 
        compliant with the NCName specification
    """
    ident = md5()
    ident.update(repr(time.time()))
    if seed:
        ident.update(seed)
    return "id-" + ident.hexdigest()


def parse_attribute_map(filenames):
    """
    Expects a file with each line being composed of the oid for the attribute
    exactly one space, a user friendly name of the attribute and then
    the type specification of the name.
    
    :param filenames: List of filenames on mapfiles.
    :return: A 2-tuple, one dictionary with the oid as keys and the friendly 
        names as values, the other one the other way around.
    """
    forward = {}
    backward = {}
    for filename in filenames:
        for line in open(filename).readlines():
            (name, friendly_name, name_format) = line.strip().split()
            forward[(name, name_format)] = friendly_name
            backward[friendly_name] = (name, name_format)
        
    return forward, backward
    

def identity_attribute(form, attribute, forward_map=None):
    if form == "friendly":
        if attribute.friendly_name:
            return attribute.friendly_name
        elif forward_map:
            try:
                return forward_map[(attribute.name, attribute.name_format)]
            except KeyError:
                return attribute.name
    # default is name
    return attribute.name        

#----------------------------------------------------------------------------
    

def error_status_factory(info):
    if isinstance(info, Exception):
        try:
            exc_val = EXCEPTION2STATUS[info.__class__]
        except KeyError:
            exc_val = samlp.STATUS_AUTHN_FAILED
        try:
            msg = info.args[0]
        except IndexError:
            msg = "%s" % info
        status = samlp.Status(
            status_message=samlp.StatusMessage(text=msg),
            status_code=samlp.StatusCode(
                value=samlp.STATUS_RESPONDER,
                status_code=samlp.StatusCode(
                    value=exc_val)))
    else:
        (errcode, text) = info
        status = samlp.Status(
            status_message=samlp.StatusMessage(text=text),
            status_code=samlp.StatusCode(
                value=samlp.STATUS_RESPONDER,
                status_code=samlp.StatusCode(value=errcode)))
        
    return status
        

def success_status_factory():
    return samlp.Status(status_code=samlp.StatusCode(
        value=samlp.STATUS_SUCCESS))
                                

def status_message_factory(message, code, fro=samlp.STATUS_RESPONDER):
    return samlp.Status(
        status_message=samlp.StatusMessage(text=message),
        status_code=samlp.StatusCode(value=fro,
                                     status_code=samlp.StatusCode(value=code)))
    

def assertion_factory(**kwargs):
    assertion = saml.Assertion(version=VERSION, id=sid(),
                               issue_instant=instant())
    for key, val in kwargs.items():
        setattr(assertion, key, val)
    return assertion


def _attrval(val, typ=""):
    if isinstance(val, list) or isinstance(val, set):
        attrval = [saml.AttributeValue(text=v) for v in val]
    elif val is None:
        attrval = None
    else:
        attrval = [saml.AttributeValue(text=val)]

    if typ:
        for ava in attrval:
            ava.set_type(typ)
            
    return attrval

# --- attribute profiles -----

# xmlns:xs="http://www.w3.org/2001/XMLSchema"
# xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"


def do_ava(val, typ=""):
    if isinstance(val, basestring):
        ava = saml.AttributeValue()
        ava.set_text(val)
        attrval = [ava]
    elif isinstance(val, list):
        attrval = [do_ava(v)[0] for v in val]
    elif val or val is False:
        ava = saml.AttributeValue()
        ava.set_text(val)        
        attrval = [ava]
    elif val is None:
        attrval = None
    else:
        raise OtherError("strange value type on: %s" % val)

    if typ:
        for ava in attrval:
            ava.set_type(typ)

    return attrval
    

def do_attribute(val, typ, key):
    attr = saml.Attribute()
    attrval = do_ava(val, typ)
    if attrval:
        attr.attribute_value = attrval

    if isinstance(key, basestring):
        attr.name = key
    elif isinstance(key, tuple):  # 3-tuple or 2-tuple
        try:
            (name, nformat, friendly) = key
        except ValueError:
            (name, nformat) = key
            friendly = ""
        if name:
            attr.name = name
        if format:
            attr.name_format = nformat
        if friendly:
            attr.friendly_name = friendly
    return attr
    

def do_attributes(identity):
    attrs = []
    if not identity:
        return attrs
    for key, spec in identity.items():
        try:
            val, typ = spec
        except ValueError:
            val = spec
            typ = ""
        except TypeError: 
            val = ""
            typ = ""
            
        attr = do_attribute(val, typ, key)
        attrs.append(attr)
    return attrs
    

def do_attribute_statement(identity):
    """
    :param identity: A dictionary with fiendly names as keys
    :return:
    """
    return saml.AttributeStatement(attribute=do_attributes(identity))


def factory(klass, **kwargs):
    instance = klass()
    for key, val in kwargs.items():
        setattr(instance, key, val)
    return instance


def signature(secret, parts):
    """Generates a signature.
    """
    if sys.version_info >= (2, 5):
        csum = hmac.new(secret, digestmod=hashlib.sha1)
    else:
        csum = hmac.new(secret, digestmod=sha)

    for part in parts:
        csum.update(part)

    return csum.hexdigest()


def verify_signature(secret, parts):
    """ Checks that the signature is correct """
    if signature(secret, parts[:-1]) == parts[-1]:
        return True
    else:
        return False


FTICKS_FORMAT = "F-TICKS/SWAMID/2.0%s#"


def fticks_log(sp, logf, idp_entity_id, user_id, secret, assertion):
    """
    'F-TICKS/' federationIdentifier '/' version *('#' attribute '=' value) '#'
    Allowed attributes:
        TS	the login time stamp
        RP	the relying party entityID
        AP	the asserting party entityID (typcially the IdP)
        PN	a sha256-hash of the local principal name and a unique key
        AM	the authentication method URN

    :param sp: Client instance
    :param logf: The log function to use
    :param idp_entity_id: IdP entity ID
    :param user_id: The user identifier
    :param secret: A salt to make the hash more secure
    :param assertion: A SAML Assertion instance gotten from the IdP
    """
    csum = hmac.new(secret, digestmod=hashlib.sha1)
    csum.update(user_id)
    ac = assertion.AuthnStatement[0].AuthnContext[0]

    info = {
        "TS": time.time(),
        "RP": sp.entity_id,
        "AP": idp_entity_id,
        "PN": csum.hexdigest(),
        "AM": ac.AuthnContextClassRef.text
    }
    logf.info(FTICKS_FORMAT % "#".join(["%s=%s" % (a, v) for a, v in info]))


def dynamic_importer(name, class_name=None):
    """
    Dynamically imports modules / classes
    """
    try:
        fp, pathname, description = imp.find_module(name)
    except ImportError:
        print "unable to locate module: " + name
        return None, None

    try:
        package = imp.load_module(name, fp, pathname, description)
    except Exception:
        raise

    if class_name:
        try:
            _class = imp.load_module("%s.%s" % (name, class_name), fp,
                                     pathname, description)
        except Exception:
            raise

        return package, _class
    else:
        return package, None


def exception_trace(exc):
    message = traceback.format_exception(*sys.exc_info())

    try:
        _exc = "Exception: %s" % exc
    except UnicodeEncodeError:
        _exc = "Exception: %s" % exc.message.encode("utf-8", "replace")

    return {"message": _exc, "content": "".join(message)}


def rec_factory(cls, **kwargs):
    _inst = cls()
    for key, val in kwargs.items():
        if key in ["text", "lang"]:
            setattr(_inst, key, val)
        elif key in _inst.c_attributes:
            try:
                val = str(val)
            except Exception:
                continue
            else:
                setattr(_inst, key, val)
        elif key in _inst.c_child_order:
            for tag, _cls in _inst.c_children.values():
                if tag == key:
                    if isinstance(_cls, list):
                        _cls = _cls[0]
                        claim = []
                        if isinstance(val, list):
                            for v in val:
                                claim.append(rec_factory(_cls, **v))
                        else:
                            claim.append(rec_factory(_cls, **val))
                    else:
                        claim = rec_factory(_cls, **val)
                    setattr(_inst, key, claim)
                    break

    return _inst

########NEW FILE########
__FILENAME__ = time_util
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009-2011 Ume University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
""" 
Implements some usefull functions when dealing with validity of 
different types of information.
"""

import calendar
import re
import time
import sys

from datetime import timedelta
from datetime import datetime

TIME_FORMAT = "%Y-%m-%dT%H:%M:%SZ"
TIME_FORMAT_WITH_FRAGMENT = re.compile(
    "^(\d{4,4}-\d{2,2}-\d{2,2}T\d{2,2}:\d{2,2}:\d{2,2})\.\d*Z$")

# ---------------------------------------------------------------------------
# I'm sure this is implemented somewhere else can't find it now though, so I
# made an attempt.
#Implemented according to 
#http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/
#adding-durations-to-dateTimes


def f_quotient(arg0, arg1, arg2=0):
    if arg2:
        return int((arg0 - arg1) / (arg2 - arg1))
    elif not arg0:
        return 0
    else:
        return int(arg0 / arg1)


def modulo(arg0, arg1, arg2=0):
    if arg2:
        return ((arg0 - arg1) % (arg2 - arg1)) + arg1
    else:
        return arg0 % arg1


def maximum_day_in_month_for(year, month):
    return calendar.monthrange(year, month)[1]


D_FORMAT = [
    ("Y", "tm_year"),
    ("M", "tm_mon"),
    ("D", "tm_mday"),
    ("T", None),
    ("H", "tm_hour"),
    ("M", "tm_min"),
    ("S", "tm_sec")
]


def parse_duration(duration):
    # (-)PnYnMnDTnHnMnS
    index = 0
    if duration[0] == '-':
        sign = '-'
        index += 1
    else:
        sign = '+'
    assert duration[index] == "P"
    index += 1
    
    dic = dict([(typ, 0) for (code, typ) in D_FORMAT if typ])
    dlen = len(duration)

    for code, typ in D_FORMAT:
        #print duration[index:], code
        if duration[index] == '-':
            raise Exception("Negation not allowed on individual items")
        if code == "T":
            if duration[index] == "T":
                index += 1
                if index == len(duration):
                    raise Exception("Not allowed to end with 'T'")
            else:
                raise Exception("Missing T")
        elif duration[index] == "T":
            continue
        else:
            try:
                mod = duration[index:].index(code)
                _val = duration[index:index + mod]
                try:
                    dic[typ] = int(_val)
                except ValueError:
                    # smallest value used may also have a decimal fraction
                    if mod + index + 1 == dlen:
                        try:
                            dic[typ] = float(_val)
                        except ValueError:
                            if "," in _val:
                                _val = _val.replace(",", ".")
                                try:
                                    dic[typ] = float(_val)
                                except ValueError:
                                    raise Exception("Not a float")
                            else:
                                raise Exception("Not a float")
                    else:
                        raise ValueError(
                            "Fraction not allowed on other than smallest value")
                index = mod + index + 1
            except ValueError:
                dic[typ] = 0

        if index == dlen:
            break
        
    return sign, dic
    

def add_duration(tid, duration):
    
    (sign, dur) = parse_duration(duration)
    
    if sign == '+':
        #Months
        temp = tid.tm_mon + dur["tm_mon"]
        month = modulo(temp, 1, 13)
        carry = f_quotient(temp, 1, 13)
        #Years
        year = tid.tm_year + dur["tm_year"] + carry
        # seconds
        temp = tid.tm_sec + dur["tm_sec"]
        secs = modulo(temp, 60)
        carry = f_quotient(temp, 60)
        # minutes
        temp = tid.tm_min + dur["tm_min"] + carry
        minutes = modulo(temp, 60)
        carry = f_quotient(temp, 60)
        # hours
        temp = tid.tm_hour + dur["tm_hour"] + carry
        hour = modulo(temp, 60)
        carry = f_quotient(temp, 60)
        # days
        if dur["tm_mday"] > maximum_day_in_month_for(year, month):
            temp_days = maximum_day_in_month_for(year, month)
        elif dur["tm_mday"] < 1:
            temp_days = 1
        else:
            temp_days = dur["tm_mday"]
        days = temp_days + tid.tm_mday + carry
        while True:
            if days < 1:
                pass
            elif days > maximum_day_in_month_for(year, month):
                days -= maximum_day_in_month_for(year, month)
                carry = 1
            else:
                break
            temp = month + carry
            month = modulo(temp, 1, 13)
            year += f_quotient(temp, 1, 13)
    
        return time.localtime(time.mktime((year, month, days, hour, minutes,
                                           secs, 0, 0, -1)))
    else:
        pass

# ---------------------------------------------------------------------------


def time_in_a_while(days=0, seconds=0, microseconds=0, milliseconds=0,
                    minutes=0, hours=0, weeks=0):
    """
    format of timedelta:
        timedelta([days[, seconds[, microseconds[, milliseconds[,
                    minutes[, hours[, weeks]]]]]]])
    :return: UTC time
    """
    delta = timedelta(days, seconds, microseconds, milliseconds,
                      minutes, hours, weeks)
    return datetime.utcnow() + delta


def time_a_while_ago(days=0, seconds=0, microseconds=0, milliseconds=0,
                     minutes=0, hours=0, weeks=0):
    """
    format of timedelta:
        timedelta([days[, seconds[, microseconds[, milliseconds[,
                    minutes[, hours[, weeks]]]]]]])
    """
    delta = timedelta(days, seconds, microseconds, milliseconds,
                      minutes, hours, weeks)
    return datetime.utcnow() - delta


def in_a_while(days=0, seconds=0, microseconds=0, milliseconds=0,
               minutes=0, hours=0, weeks=0, format=TIME_FORMAT):
    """
    format of timedelta:
        timedelta([days[, seconds[, microseconds[, milliseconds[,
                    minutes[, hours[, weeks]]]]]]])
    """
    if format is None:
        format = TIME_FORMAT
        
    return time_in_a_while(days, seconds, microseconds, milliseconds,
                           minutes, hours, weeks).strftime(format)


def a_while_ago(days=0, seconds=0, microseconds=0, milliseconds=0,
                minutes=0, hours=0, weeks=0, format=TIME_FORMAT):
    return time_a_while_ago(days, seconds, microseconds, milliseconds,
                            minutes, hours, weeks).strftime(format)

# ---------------------------------------------------------------------------


def shift_time(dtime, shift):
    """ Adds/deletes an integer amount of seconds from a datetime specification

    :param dtime: The datatime specification
    :param shift: The wanted time shift (+/-)
    :return: A shifted datatime specification
    """
    return dtime + timedelta(seconds=shift)

# ---------------------------------------------------------------------------


def str_to_time(timestr, format=TIME_FORMAT):
    """

    :param timestr:
    :param format:
    :return: UTC time
    """
    if not timestr:
        return 0
    try:
        then = time.strptime(timestr, format)
    except ValueError:  # assume it's a format problem
        try:
            elem = TIME_FORMAT_WITH_FRAGMENT.match(timestr)
        except Exception, exc:
            print >> sys.stderr, "Exception: %s on %s" % (exc, timestr)
            raise
        then = time.strptime(elem.groups()[0] + "Z", TIME_FORMAT)

    return time.gmtime(calendar.timegm(then))


def instant(format=TIME_FORMAT, time_stamp=0):
    if time_stamp:
        return time.strftime(format, time.gmtime(time_stamp))
    else:
        return time.strftime(format, time.gmtime())

# ---------------------------------------------------------------------------


def utc_now():
    return calendar.timegm(time.gmtime())

# ---------------------------------------------------------------------------


def before(point):
    """ True if point datetime specification is before now.

    NOTE: If point is specified it is supposed to be in local time.
    Not UTC/GMT !! This is because that is what gmtime() expects.
    """
    if not point:
        return True

    if isinstance(point, basestring):
        point = str_to_time(point)
    elif isinstance(point, int):
        point = time.gmtime(point)

    return time.gmtime() < point


def after(point):
    """ True if point datetime specification is equal or after now """
    if not point:
        return True
    else:
        return not before(point)


not_before = after

# 'not_on_or_after' is just an obscure name for 'before'
not_on_or_after = before

# a point is valid if it is now or sometime in the future, in other words,
# if it is not before now
valid = before


def later_than(after, before):
    """ True if then is later or equal to that """
    if isinstance(after, basestring):
        after = str_to_time(after)
    elif isinstance(after, int):
        after = time.gmtime(after)

    if isinstance(before, basestring):
        before = str_to_time(before)
    elif isinstance(before, int):
        before = time.gmtime(before)

    return after >= before

########NEW FILE########
__FILENAME__ = ldapinfo
import ldap
from ldap import SCOPE_SUBTREE
from saml2.userinfo import UserInfo


class UserInfoLDAP(UserInfo):
    def __init__(self, uri, base, filter_pattern, scope=SCOPE_SUBTREE,
                 tls=False, user="", passwd="", attr=None, attrsonly=False):
        UserInfo.__init__(self)
        self.ldapuri = uri
        self.base = base
        self.filter_pattern = filter_pattern
        self.scope = scope
        self.tls = tls
        self.attr = attr
        self.attrsonly = attrsonly
        self.ld = ldap.initialize(uri)
        self.ld.protocol_version = ldap.VERSION3
        self.ld.simple_bind_s(user, passwd)

    def __call__(self, userid, base="", filter_pattern="", scope=SCOPE_SUBTREE,
                 tls=False, attr=None, attrsonly=False, **kwargs):

        if filter_pattern:
            _filter = filter_pattern % userid
        else:
            _filter = self.filter_pattern % userid

        _base = base or self.base
        _scope = scope or self.scope
        _attr = attr or self.attr
        _attrsonly = attrsonly or self.attrsonly
        arg = [_base, _scope, _filter, _attr, _attrsonly]
        res = self.ld.search_s(*arg)
        # should only be one entry and the information per entry is
        # the tuple (dn, ava)
        return res[0][1]
########NEW FILE########
__FILENAME__ = validate
import calendar
import urlparse
import re
import time_util
import struct
import base64

# Also defined in saml2.saml but can't import from there
XSI_NAMESPACE = 'http://www.w3.org/2001/XMLSchema-instance'
XSI_NIL = '{%s}nil' % XSI_NAMESPACE
# ---------------------------------------------------------


class NotValid(Exception):
    pass


class OutsideCardinality(Exception):
    pass


class MustValueError(ValueError):
    pass


class ShouldValueError(ValueError):
    pass

# --------------------- validators -------------------------------------
#

NCNAME = re.compile("(?P<NCName>[a-zA-Z_](\w|[_.-])*)")


def valid_ncname(name):
    match = NCNAME.match(name)
    if not match:
        raise NotValid("NCName")
    return True


def valid_id(oid):
    valid_ncname(oid)


def valid_any_uri(item):
    """very simplistic, ..."""
    try:
        part = urlparse.urlparse(item)
    except Exception:
        raise NotValid("AnyURI")

    if part[0] == "urn" and part[1] == "":  # A urn
        return True
    # elif part[1] == "localhost" or part[1] == "127.0.0.1":
    #     raise NotValid("AnyURI")

    return True


def valid_date_time(item):
    try:
        time_util.str_to_time(item)
    except Exception:
        raise NotValid("dateTime")
    return True


def valid_url(url):
    try:
        _ = urlparse.urlparse(url)
    except Exception:
        raise NotValid("URL")
        
    # if part[1] == "localhost" or part[1] == "127.0.0.1":
    #     raise NotValid("URL")
    return True


def validate_on_or_after(not_on_or_after, slack):
    if not_on_or_after:
        now = time_util.utc_now()
        nooa = calendar.timegm(time_util.str_to_time(not_on_or_after))
        if now > nooa + slack:
            raise Exception("Can't use it, it's too old %d > %d" %
                            (nooa, now))
        return nooa
    else:
        return False


def validate_before(not_before, slack):
    if not_before:
        now = time_util.utc_now()
        nbefore = calendar.timegm(time_util.str_to_time(not_before))
        if nbefore > now + slack:
            raise Exception("Can't use it yet %d <= %d" % (nbefore, now))

    return True


def valid_address(address):
    if not (valid_ipv4(address) or valid_ipv6(address)):
        raise NotValid("address")
    return True
    

def valid_ipv4(address):
    parts = address.split(".")
    if len(parts) != 4:
        return False
    for item in parts:
        try:
            if not 0 <= int(item) <= 255:
                raise NotValid("ipv4")
        except ValueError:
            return False
    return True
    
# 
IPV6_PATTERN = re.compile(r"""
    ^
    \s*                         # Leading whitespace
    (?!.*::.*::)                # Only a single wildcard allowed
    (?:(?!:)|:(?=:))            # Colon iff it would be part of a wildcard
    (?:                         # Repeat 6 times:
        [0-9a-f]{0,4}           #   A group of at most four hexadecimal digits
        (?:(?<=::)|(?<!::):)    #   Colon unless preceeded by wildcard
    ){6}                        #
    (?:                         # Either
        [0-9a-f]{0,4}           #   Another group
        (?:(?<=::)|(?<!::):)    #   Colon unless preceeded by wildcard
        [0-9a-f]{0,4}           #   Last group
        (?: (?<=::)             #   Colon iff preceeded by exacly one colon
         |  (?<!:)              #
         |  (?<=:) (?<!::) :    #
         )                      # OR
     |                          #   A v4 address with NO leading zeros 
        (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]?\d)
        (?: \.
            (?:25[0-4]|2[0-4]\d|1\d\d|[1-9]?\d)
        ){3}
    )
    \s*                         # Trailing whitespace
    $
""", re.VERBOSE | re.IGNORECASE | re.DOTALL)
    

def valid_ipv6(address):
    """Validates IPv6 addresses. """
    return IPV6_PATTERN.match(address) is not None


def valid_boolean(val):
    vall = val.lower()
    if vall in ["true", "false", "0", "1"]:
        return True
    else:
        raise NotValid("boolean")
        

def valid_duration(val):
    try:
        time_util.parse_duration(val)
    except Exception:
        raise NotValid("duration")
    return True


def valid_string(val):
    """ Expects unicode 
    Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | 
                    [#x10000-#x10FFFF]
    """
    for char in val:
        try:
            char = ord(char)
        except TypeError:
            raise NotValid("string")
        if char == 0x09 or char == 0x0A or char == 0x0D:
            continue
        elif 0x20 <= char <= 0xD7FF:
            continue
        elif 0xE000 <= char <= 0xFFFD:
            continue
        elif 0x10000 <= char <= 0x10FFFF:
            continue
        else:
            raise NotValid("string")
    return True
    

def valid_unsigned_short(val):
    try:
        struct.pack("H", int(val))
    except struct.error:
        raise NotValid("unsigned short")
    except ValueError:
        raise NotValid("unsigned short")
        
    return True
    

def valid_positive_integer(val):
    try:
        integer = int(val)
    except ValueError:
        raise NotValid("positive integer")

    if integer > 0:
        return True
    else:
        raise NotValid("positive integer")


def valid_non_negative_integer(val):
    try:
        integer = int(val)
    except ValueError:
        raise NotValid("non negative integer")
        
    if integer < 0:
        raise NotValid("non negative integer")
    return True


def valid_integer(val):
    try:
        int(val)
    except ValueError:
        raise NotValid("integer")
    return True
    

def valid_base64(val):
    try:
        base64.b64decode(val)
    except Exception:
        raise NotValid("base64")
    return True


def valid_qname(val):
    """ A qname is either 
        NCName or 
        NCName ':' NCName
    """
    
    try:
        (prefix, localpart) = val.split(":")
        return valid_ncname(prefix) and valid_ncname(localpart)
    except ValueError:
        return valid_ncname(val)


def valid_anytype(val):
    """ Goes through all known type validators 
    
    :param val: The value to validate
    :return: True is value is valid otherwise an exception is raised
    """
    for validator in VALIDATOR.values():
        if validator == valid_anytype:  # To hinder recursion
            continue
        try:
            if validator(val):
                return True
        except NotValid:
            pass
    
    if isinstance(val, type):
        return True
        
    raise NotValid("AnyType")
    
# -----------------------------------------------------------------------------

VALIDATOR = {
    "ID": valid_id,
    "NCName": valid_ncname,
    "dateTime": valid_date_time,
    "anyURI": valid_any_uri,
    "nonNegativeInteger": valid_non_negative_integer,
    "PositiveInteger": valid_positive_integer,
    "boolean": valid_boolean,
    "unsignedShort": valid_unsigned_short,
    "duration": valid_duration,
    "base64Binary": valid_base64,
    "integer": valid_integer,
    "QName": valid_qname,
    "anyType": valid_anytype,
    "string": valid_string,
}

# -----------------------------------------------------------------------------


def validate_value_type(value, spec):
    """
    c_value_type = {'base': 'string', 'enumeration': ['Permit', 'Deny',
                                                      'Indeterminate']}
        {'member': 'anyURI', 'base': 'list'}
        {'base': 'anyURI'}
        {'base': 'NCName'}
        {'base': 'string'}
    """
    if "maxlen" in spec:
        return len(value) <= spec["maxlen"]
        
    if spec["base"] == "string":
        if "enumeration" in spec:
            if value not in spec["enumeration"]:
                raise NotValid("value not in enumeration")
        else:
            return valid_string(value)
    elif spec["base"] == "list":  # comma separated list of values
        for val in [v.strip() for v in value.split(",")]:
            valid(spec["member"], val)
    else:
        return valid(spec["base"], value)
        
    return True


def valid(typ, value):
    try:
        return VALIDATOR[typ](value)
    except KeyError:
        try:
            (_namespace, typ) = typ.split(":")
        except ValueError:
            if typ == "":
                typ = "string"
        return VALIDATOR[typ](value)


def _valid_instance(instance, val):
    try:
        val.verify()
    except NotValid, exc:
        raise NotValid("Class '%s' instance: %s" % (
            instance.__class__.__name__, exc.args[0]))
    except OutsideCardinality, exc:
        raise NotValid(
            "Class '%s' instance cardinality error: %s" % (
                instance.__class__.__name__, exc.args[0]))

ERROR_TEXT = "Wrong type of value '%s' on attribute '%s' expected it to be %s"


def valid_instance(instance):
    instclass = instance.__class__
    class_name = instclass.__name__

    # if instance.text:
    #     _has_val = True
    # else:
    #     _has_val = False

    if instclass.c_value_type and instance.text:
        try:
            validate_value_type(instance.text.strip(),
                                instclass.c_value_type)
        except NotValid, exc:
            raise NotValid("Class '%s' instance: %s" % (class_name,
                                                        exc.args[0]))

    for (name, typ, required) in instclass.c_attributes.values():
        value = getattr(instance, name, '')
        if required and not value:
            txt = "Required value on property '%s' missing" % name
            raise MustValueError("Class '%s' instance: %s" % (class_name, txt))
        
        if value:
            try:
                if isinstance(typ, type):
                    if typ.c_value_type:
                        spec = typ.c_value_type
                    else:
                        spec = {"base": "string"}  # do I need a default
              
                    validate_value_type(value, spec)
                else:
                    valid(typ, value)
            except (NotValid, ValueError), exc:
                txt = ERROR_TEXT % (value, name, exc.args[0])
                raise NotValid("Class '%s' instance: %s" % (class_name, txt))
        
    for (name, _spec) in instclass.c_children.values():
        value = getattr(instance, name, '')

        try:
            _card = instclass.c_cardinality[name]
            try:
                _cmin = _card["min"]
            except KeyError:
                _cmin = None
            try:
                _cmax = _card["max"]
            except KeyError:
                _cmax = None
        except KeyError:
            _cmin = _cmax = _card = None

        if value:
            #_has_val = True
            if isinstance(value, list):
                _list = True
                vlen = len(value)
            else:
                _list = False
                vlen = 1

            if _card:
                if _cmin is not None and _cmin > vlen:
                    raise NotValid(
                        "Class '%s' instance cardinality error: %s" % (
                            class_name, "less then min (%s<%s)" % (vlen,
                                                                   _cmin)))
                if _cmax is not None and vlen > _cmax:
                    raise NotValid(
                        "Class '%s' instance cardinality error: %s" % (
                            class_name, "more then max (%s>%s)" % (vlen,
                                                                   _cmax)))
            
            if _list:
                for val in value:
                    # That it is the right class is handled elsewhere
                    _valid_instance(instance, val)
            else:
                _valid_instance(instance, value)
        else:
            if _cmin:
                raise NotValid(
                    "Class '%s' instance cardinality error: %s" % (
                        class_name, "too few values on %s" % name))

#    if not _has_val:
#        if class_name != "RequestedAttribute":
#            # Not allow unless xsi:nil="true"
#            assert instance.extension_attributes
#            assert instance.extension_attributes[XSI_NIL] == "true"

    return True


def valid_domain_name(dns_name):
    m = re.match(
        "^[a-z0-9]+([-.]{ 1 }[a-z0-9]+).[a-z]{2,5}(:[0-9]{1,5})?(\/.)?$",
        dns_name, "ix")
    if not m:
        raise ValueError("Not a proper domain name")
########NEW FILE########
__FILENAME__ = virtual_org
import logging
from saml2.attribute_resolver import AttributeResolver
from saml2.saml import NAMEID_FORMAT_PERSISTENT

logger = logging.getLogger(__name__)


class VirtualOrg(object):
    def __init__(self, sp, vorg, cnf):
        self.sp = sp  # The parent SP client instance
        self._name = vorg
        self.common_identifier = cnf["common_identifier"]
        try:
            self.member = cnf["member"]
        except KeyError:
            self.member = []
        try:
            self.nameid_format = cnf["nameid_format"]
        except KeyError:
            self.nameid_format = NAMEID_FORMAT_PERSISTENT

    def _cache_session(self, session_info):
        return True
        
    def _affiliation_members(self):
        """
        Get the member of the Virtual Organization from the metadata, 
        more specifically from AffiliationDescriptor.
        """
        return self.sp.config.metadata.vo_members(self._name)

    def members_to_ask(self, name_id):
        """Find the member of the Virtual Organization that I haven't already 
        spoken too 
        """

        vo_members = self._affiliation_members()
        for member in self.member:
            if member not in vo_members:
                vo_members.append(member)

        # Remove the ones I have cached data from about this subject
        vo_members = [m for m in vo_members if not self.sp.users.cache.active(
            name_id, m)]
        logger.info("VO members (not cached): %s" % vo_members)
        return vo_members
    
    def get_common_identifier(self, name_id):
        (ava, _) = self.sp.users.get_identity(name_id)
        if ava == {}:
            return None
            
        ident = self.common_identifier

        try:
            return ava[ident][0]
        except KeyError:
            return None
        
    def do_aggregation(self, name_id):

        logger.info("** Do VO aggregation **\nSubjectID: %s, VO:%s" % (
            name_id, self._name))
        
        to_ask = self.members_to_ask(name_id)
        if to_ask:
            com_identifier = self.get_common_identifier(name_id)
                
            resolver = AttributeResolver(self.sp)
            # extends returns a list of session_infos      
            for session_info in resolver.extend(
                    com_identifier, self.sp.config.entityid, to_ask):
                _ = self._cache_session(session_info)

            logger.info(">Issuers: %s" % self.sp.users.issuers_of_info(name_id))
            logger.info("AVA: %s" % (self.sp.users.get_identity(name_id),))
            
            return True
        else:
            return False
########NEW FILE########
__FILENAME__ = aa_conf

from saml2 import BINDING_SOAP, BINDING_HTTP_REDIRECT, NAME_FORMAT_URI
BASE = "http://localhost:8089/"

from pathutils import full_path


CONFIG={
    "service":{
        "aa":{
            "endpoints" : {
                "attribute_service" : [(BASE + "as", BINDING_HTTP_REDIRECT)],
                "single_logout_service": [(BASE+"slo", BINDING_SOAP)]
            },
            "release_policy": {
                "default": {
                    "lifetime": {"minutes":15},
                    "attribute_restrictions": None, # means all I have
                    "name_form": NAME_FORMAT_URI,
                },
            },
            "subject_data": full_path("aa.db"),
        }
    },
    "entityid" : BASE+ "aa",
    "name" : "Rolands AA",
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    #"xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("metadata.xml"), full_path("vo_metadata.xml")],
    },
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel AB","se"),("Example Co.","en")],
        "url":"http://www.example.com/roland",
    },
    "contact_person": [{
        "given_name":"John",
        "sur_name": "Smith",
        "email_address": ["john.smith@example.com"],
        "contact_type": "technical",
        },
    ],
}


########NEW FILE########
__FILENAME__ = basic

MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:basic",
    "fro": {
        'urn:mace:dir:attribute-def:aRecord': 'aRecord',
        'urn:mace:dir:attribute-def:aliasedEntryName': 'aliasedEntryName',
        'urn:mace:dir:attribute-def:aliasedObjectName': 'aliasedObjectName',
        'urn:mace:dir:attribute-def:associatedDomain': 'associatedDomain',
        'urn:mace:dir:attribute-def:associatedName': 'associatedName',
        'urn:mace:dir:attribute-def:audio': 'audio',
        'urn:mace:dir:attribute-def:authorityRevocationList': 'authorityRevocationList',
        'urn:mace:dir:attribute-def:buildingName': 'buildingName',
        'urn:mace:dir:attribute-def:businessCategory': 'businessCategory',
        'urn:mace:dir:attribute-def:c': 'c',
        'urn:mace:dir:attribute-def:cACertificate': 'cACertificate',
        'urn:mace:dir:attribute-def:cNAMERecord': 'cNAMERecord',
        'urn:mace:dir:attribute-def:carLicense': 'carLicense',
        'urn:mace:dir:attribute-def:certificateRevocationList': 'certificateRevocationList',
        'urn:mace:dir:attribute-def:cn': 'cn',
        'urn:mace:dir:attribute-def:co': 'co',
        'urn:mace:dir:attribute-def:commonName': 'commonName',
        'urn:mace:dir:attribute-def:countryName': 'countryName',
        'urn:mace:dir:attribute-def:crossCertificatePair': 'crossCertificatePair',
        'urn:mace:dir:attribute-def:dITRedirect': 'dITRedirect',
        'urn:mace:dir:attribute-def:dSAQuality': 'dSAQuality',
        'urn:mace:dir:attribute-def:dc': 'dc',
        'urn:mace:dir:attribute-def:deltaRevocationList': 'deltaRevocationList',
        'urn:mace:dir:attribute-def:departmentNumber': 'departmentNumber',
        'urn:mace:dir:attribute-def:description': 'description',
        'urn:mace:dir:attribute-def:destinationIndicator': 'destinationIndicator',
        'urn:mace:dir:attribute-def:displayName': 'displayName',
        'urn:mace:dir:attribute-def:distinguishedName': 'distinguishedName',
        'urn:mace:dir:attribute-def:dmdName': 'dmdName',
        'urn:mace:dir:attribute-def:dnQualifier': 'dnQualifier',
        'urn:mace:dir:attribute-def:documentAuthor': 'documentAuthor',
        'urn:mace:dir:attribute-def:documentIdentifier': 'documentIdentifier',
        'urn:mace:dir:attribute-def:documentLocation': 'documentLocation',
        'urn:mace:dir:attribute-def:documentPublisher': 'documentPublisher',
        'urn:mace:dir:attribute-def:documentTitle': 'documentTitle',
        'urn:mace:dir:attribute-def:documentVersion': 'documentVersion',
        'urn:mace:dir:attribute-def:domainComponent': 'domainComponent',
        'urn:mace:dir:attribute-def:drink': 'drink',
        'urn:mace:dir:attribute-def:eduOrgHomePageURI': 'eduOrgHomePageURI',
        'urn:mace:dir:attribute-def:eduOrgIdentityAuthNPolicyURI': 'eduOrgIdentityAuthNPolicyURI',
        'urn:mace:dir:attribute-def:eduOrgLegalName': 'eduOrgLegalName',
        'urn:mace:dir:attribute-def:eduOrgSuperiorURI': 'eduOrgSuperiorURI',
        'urn:mace:dir:attribute-def:eduOrgWhitePagesURI': 'eduOrgWhitePagesURI',
        'urn:mace:dir:attribute-def:eduPersonAffiliation': 'eduPersonAffiliation',
        'urn:mace:dir:attribute-def:eduPersonEntitlement': 'eduPersonEntitlement',
        'urn:mace:dir:attribute-def:eduPersonNickname': 'eduPersonNickname',
        'urn:mace:dir:attribute-def:eduPersonOrgDN': 'eduPersonOrgDN',
        'urn:mace:dir:attribute-def:eduPersonOrgUnitDN': 'eduPersonOrgUnitDN',
        'urn:mace:dir:attribute-def:eduPersonPrimaryAffiliation': 'eduPersonPrimaryAffiliation',
        'urn:mace:dir:attribute-def:eduPersonPrimaryOrgUnitDN': 'eduPersonPrimaryOrgUnitDN',
        'urn:mace:dir:attribute-def:eduPersonPrincipalName': 'eduPersonPrincipalName',
        'urn:mace:dir:attribute-def:eduPersonScopedAffiliation': 'eduPersonScopedAffiliation',
        'urn:mace:dir:attribute-def:eduPersonTargetedID': 'eduPersonTargetedID',
        'urn:mace:dir:attribute-def:email': 'email',
        'urn:mace:dir:attribute-def:emailAddress': 'emailAddress',
        'urn:mace:dir:attribute-def:employeeNumber': 'employeeNumber',
        'urn:mace:dir:attribute-def:employeeType': 'employeeType',
        'urn:mace:dir:attribute-def:enhancedSearchGuide': 'enhancedSearchGuide',
        'urn:mace:dir:attribute-def:facsimileTelephoneNumber': 'facsimileTelephoneNumber',
        'urn:mace:dir:attribute-def:favouriteDrink': 'favouriteDrink',
        'urn:mace:dir:attribute-def:fax': 'fax',
        'urn:mace:dir:attribute-def:federationFeideSchemaVersion': 'federationFeideSchemaVersion',
        'urn:mace:dir:attribute-def:friendlyCountryName': 'friendlyCountryName',
        'urn:mace:dir:attribute-def:generationQualifier': 'generationQualifier',
        'urn:mace:dir:attribute-def:givenName': 'givenName',
        'urn:mace:dir:attribute-def:gn': 'gn',
        'urn:mace:dir:attribute-def:homePhone': 'homePhone',
        'urn:mace:dir:attribute-def:homePostalAddress': 'homePostalAddress',
        'urn:mace:dir:attribute-def:homeTelephoneNumber': 'homeTelephoneNumber',
        'urn:mace:dir:attribute-def:host': 'host',
        'urn:mace:dir:attribute-def:houseIdentifier': 'houseIdentifier',
        'urn:mace:dir:attribute-def:info': 'info',
        'urn:mace:dir:attribute-def:initials': 'initials',
        'urn:mace:dir:attribute-def:internationaliSDNNumber': 'internationaliSDNNumber',
        'urn:mace:dir:attribute-def:janetMailbox': 'janetMailbox',
        'urn:mace:dir:attribute-def:jpegPhoto': 'jpegPhoto',
        'urn:mace:dir:attribute-def:knowledgeInformation': 'knowledgeInformation',
        'urn:mace:dir:attribute-def:l': 'l',
        'urn:mace:dir:attribute-def:labeledURI': 'labeledURI',
        'urn:mace:dir:attribute-def:localityName': 'localityName',
        'urn:mace:dir:attribute-def:mDRecord': 'mDRecord',
        'urn:mace:dir:attribute-def:mXRecord': 'mXRecord',
        'urn:mace:dir:attribute-def:mail': 'mail',
        'urn:mace:dir:attribute-def:mailPreferenceOption': 'mailPreferenceOption',
        'urn:mace:dir:attribute-def:manager': 'manager',
        'urn:mace:dir:attribute-def:member': 'member',
        'urn:mace:dir:attribute-def:mobile': 'mobile',
        'urn:mace:dir:attribute-def:mobileTelephoneNumber': 'mobileTelephoneNumber',
        'urn:mace:dir:attribute-def:nSRecord': 'nSRecord',
        'urn:mace:dir:attribute-def:name': 'name',
        'urn:mace:dir:attribute-def:norEduOrgAcronym': 'norEduOrgAcronym',
        'urn:mace:dir:attribute-def:norEduOrgNIN': 'norEduOrgNIN',
        'urn:mace:dir:attribute-def:norEduOrgSchemaVersion': 'norEduOrgSchemaVersion',
        'urn:mace:dir:attribute-def:norEduOrgUniqueIdentifier': 'norEduOrgUniqueIdentifier',
        'urn:mace:dir:attribute-def:norEduOrgUniqueNumber': 'norEduOrgUniqueNumber',
        'urn:mace:dir:attribute-def:norEduOrgUnitUniqueIdentifier': 'norEduOrgUnitUniqueIdentifier',
        'urn:mace:dir:attribute-def:norEduOrgUnitUniqueNumber': 'norEduOrgUnitUniqueNumber',
        'urn:mace:dir:attribute-def:norEduPersonBirthDate': 'norEduPersonBirthDate',
        'urn:mace:dir:attribute-def:norEduPersonLIN': 'norEduPersonLIN',
        'urn:mace:dir:attribute-def:norEduPersonNIN': 'norEduPersonNIN',
        'urn:mace:dir:attribute-def:o': 'o',
        'urn:mace:dir:attribute-def:objectClass': 'objectClass',
        'urn:mace:dir:attribute-def:organizationName': 'organizationName',
        'urn:mace:dir:attribute-def:organizationalStatus': 'organizationalStatus',
        'urn:mace:dir:attribute-def:organizationalUnitName': 'organizationalUnitName',
        'urn:mace:dir:attribute-def:otherMailbox': 'otherMailbox',
        'urn:mace:dir:attribute-def:ou': 'ou',
        'urn:mace:dir:attribute-def:owner': 'owner',
        'urn:mace:dir:attribute-def:pager': 'pager',
        'urn:mace:dir:attribute-def:pagerTelephoneNumber': 'pagerTelephoneNumber',
        'urn:mace:dir:attribute-def:personalSignature': 'personalSignature',
        'urn:mace:dir:attribute-def:personalTitle': 'personalTitle',
        'urn:mace:dir:attribute-def:photo': 'photo',
        'urn:mace:dir:attribute-def:physicalDeliveryOfficeName': 'physicalDeliveryOfficeName',
        'urn:mace:dir:attribute-def:pkcs9email': 'pkcs9email',
        'urn:mace:dir:attribute-def:postOfficeBox': 'postOfficeBox',
        'urn:mace:dir:attribute-def:postalAddress': 'postalAddress',
        'urn:mace:dir:attribute-def:postalCode': 'postalCode',
        'urn:mace:dir:attribute-def:preferredDeliveryMethod': 'preferredDeliveryMethod',
        'urn:mace:dir:attribute-def:preferredLanguage': 'preferredLanguage',
        'urn:mace:dir:attribute-def:presentationAddress': 'presentationAddress',
        'urn:mace:dir:attribute-def:protocolInformation': 'protocolInformation',
        'urn:mace:dir:attribute-def:pseudonym': 'pseudonym',
        'urn:mace:dir:attribute-def:registeredAddress': 'registeredAddress',
        'urn:mace:dir:attribute-def:rfc822Mailbox': 'rfc822Mailbox',
        'urn:mace:dir:attribute-def:roleOccupant': 'roleOccupant',
        'urn:mace:dir:attribute-def:roomNumber': 'roomNumber',
        'urn:mace:dir:attribute-def:sOARecord': 'sOARecord',
        'urn:mace:dir:attribute-def:searchGuide': 'searchGuide',
        'urn:mace:dir:attribute-def:secretary': 'secretary',
        'urn:mace:dir:attribute-def:seeAlso': 'seeAlso',
        'urn:mace:dir:attribute-def:serialNumber': 'serialNumber',
        'urn:mace:dir:attribute-def:singleLevelQuality': 'singleLevelQuality',
        'urn:mace:dir:attribute-def:sn': 'sn',
        'urn:mace:dir:attribute-def:st': 'st',
        'urn:mace:dir:attribute-def:stateOrProvinceName': 'stateOrProvinceName',
        'urn:mace:dir:attribute-def:street': 'street',
        'urn:mace:dir:attribute-def:streetAddress': 'streetAddress',
        'urn:mace:dir:attribute-def:subtreeMaximumQuality': 'subtreeMaximumQuality',
        'urn:mace:dir:attribute-def:subtreeMinimumQuality': 'subtreeMinimumQuality',
        'urn:mace:dir:attribute-def:supportedAlgorithms': 'supportedAlgorithms',
        'urn:mace:dir:attribute-def:supportedApplicationContext': 'supportedApplicationContext',
        'urn:mace:dir:attribute-def:surname': 'surname',
        'urn:mace:dir:attribute-def:telephoneNumber': 'telephoneNumber',
        'urn:mace:dir:attribute-def:teletexTerminalIdentifier': 'teletexTerminalIdentifier',
        'urn:mace:dir:attribute-def:telexNumber': 'telexNumber',
        'urn:mace:dir:attribute-def:textEncodedORAddress': 'textEncodedORAddress',
        'urn:mace:dir:attribute-def:title': 'title',
        'urn:mace:dir:attribute-def:uid': 'uid',
        'urn:mace:dir:attribute-def:uniqueIdentifier': 'uniqueIdentifier',
        'urn:mace:dir:attribute-def:uniqueMember': 'uniqueMember',
        'urn:mace:dir:attribute-def:userCertificate': 'userCertificate',
        'urn:mace:dir:attribute-def:userClass': 'userClass',
        'urn:mace:dir:attribute-def:userPKCS12': 'userPKCS12',
        'urn:mace:dir:attribute-def:userPassword': 'userPassword',
        'urn:mace:dir:attribute-def:userSMIMECertificate': 'userSMIMECertificate',
        'urn:mace:dir:attribute-def:userid': 'userid',
        'urn:mace:dir:attribute-def:x121Address': 'x121Address',
        'urn:mace:dir:attribute-def:x500UniqueIdentifier': 'x500UniqueIdentifier',
        },
    "to": {
        'aRecord': 'urn:mace:dir:attribute-def:aRecord',
        'aliasedEntryName': 'urn:mace:dir:attribute-def:aliasedEntryName',
        'aliasedObjectName': 'urn:mace:dir:attribute-def:aliasedObjectName',
        'associatedDomain': 'urn:mace:dir:attribute-def:associatedDomain',
        'associatedName': 'urn:mace:dir:attribute-def:associatedName',
        'audio': 'urn:mace:dir:attribute-def:audio',
        'authorityRevocationList': 'urn:mace:dir:attribute-def:authorityRevocationList',
        'buildingName': 'urn:mace:dir:attribute-def:buildingName',
        'businessCategory': 'urn:mace:dir:attribute-def:businessCategory',
        'c': 'urn:mace:dir:attribute-def:c',
        'cACertificate': 'urn:mace:dir:attribute-def:cACertificate',
        'cNAMERecord': 'urn:mace:dir:attribute-def:cNAMERecord',
        'carLicense': 'urn:mace:dir:attribute-def:carLicense',
        'certificateRevocationList': 'urn:mace:dir:attribute-def:certificateRevocationList',
        'cn': 'urn:mace:dir:attribute-def:cn',
        'co': 'urn:mace:dir:attribute-def:co',
        'commonName': 'urn:mace:dir:attribute-def:commonName',
        'countryName': 'urn:mace:dir:attribute-def:countryName',
        'crossCertificatePair': 'urn:mace:dir:attribute-def:crossCertificatePair',
        'dITRedirect': 'urn:mace:dir:attribute-def:dITRedirect',
        'dSAQuality': 'urn:mace:dir:attribute-def:dSAQuality',
        'dc': 'urn:mace:dir:attribute-def:dc',
        'deltaRevocationList': 'urn:mace:dir:attribute-def:deltaRevocationList',
        'departmentNumber': 'urn:mace:dir:attribute-def:departmentNumber',
        'description': 'urn:mace:dir:attribute-def:description',
        'destinationIndicator': 'urn:mace:dir:attribute-def:destinationIndicator',
        'displayName': 'urn:mace:dir:attribute-def:displayName',
        'distinguishedName': 'urn:mace:dir:attribute-def:distinguishedName',
        'dmdName': 'urn:mace:dir:attribute-def:dmdName',
        'dnQualifier': 'urn:mace:dir:attribute-def:dnQualifier',
        'documentAuthor': 'urn:mace:dir:attribute-def:documentAuthor',
        'documentIdentifier': 'urn:mace:dir:attribute-def:documentIdentifier',
        'documentLocation': 'urn:mace:dir:attribute-def:documentLocation',
        'documentPublisher': 'urn:mace:dir:attribute-def:documentPublisher',
        'documentTitle': 'urn:mace:dir:attribute-def:documentTitle',
        'documentVersion': 'urn:mace:dir:attribute-def:documentVersion',
        'domainComponent': 'urn:mace:dir:attribute-def:domainComponent',
        'drink': 'urn:mace:dir:attribute-def:drink',
        'eduOrgHomePageURI': 'urn:mace:dir:attribute-def:eduOrgHomePageURI',
        'eduOrgIdentityAuthNPolicyURI': 'urn:mace:dir:attribute-def:eduOrgIdentityAuthNPolicyURI',
        'eduOrgLegalName': 'urn:mace:dir:attribute-def:eduOrgLegalName',
        'eduOrgSuperiorURI': 'urn:mace:dir:attribute-def:eduOrgSuperiorURI',
        'eduOrgWhitePagesURI': 'urn:mace:dir:attribute-def:eduOrgWhitePagesURI',
        'eduPersonAffiliation': 'urn:mace:dir:attribute-def:eduPersonAffiliation',
        'eduPersonEntitlement': 'urn:mace:dir:attribute-def:eduPersonEntitlement',
        'eduPersonNickname': 'urn:mace:dir:attribute-def:eduPersonNickname',
        'eduPersonOrgDN': 'urn:mace:dir:attribute-def:eduPersonOrgDN',
        'eduPersonOrgUnitDN': 'urn:mace:dir:attribute-def:eduPersonOrgUnitDN',
        'eduPersonPrimaryAffiliation': 'urn:mace:dir:attribute-def:eduPersonPrimaryAffiliation',
        'eduPersonPrimaryOrgUnitDN': 'urn:mace:dir:attribute-def:eduPersonPrimaryOrgUnitDN',
        'eduPersonPrincipalName': 'urn:mace:dir:attribute-def:eduPersonPrincipalName',
        'eduPersonScopedAffiliation': 'urn:mace:dir:attribute-def:eduPersonScopedAffiliation',
        'eduPersonTargetedID': 'urn:mace:dir:attribute-def:eduPersonTargetedID',
        'email': 'urn:mace:dir:attribute-def:email',
        'emailAddress': 'urn:mace:dir:attribute-def:emailAddress',
        'employeeNumber': 'urn:mace:dir:attribute-def:employeeNumber',
        'employeeType': 'urn:mace:dir:attribute-def:employeeType',
        'enhancedSearchGuide': 'urn:mace:dir:attribute-def:enhancedSearchGuide',
        'facsimileTelephoneNumber': 'urn:mace:dir:attribute-def:facsimileTelephoneNumber',
        'favouriteDrink': 'urn:mace:dir:attribute-def:favouriteDrink',
        'fax': 'urn:mace:dir:attribute-def:fax',
        'federationFeideSchemaVersion': 'urn:mace:dir:attribute-def:federationFeideSchemaVersion',
        'friendlyCountryName': 'urn:mace:dir:attribute-def:friendlyCountryName',
        'generationQualifier': 'urn:mace:dir:attribute-def:generationQualifier',
        'givenName': 'urn:mace:dir:attribute-def:givenName',
        'gn': 'urn:mace:dir:attribute-def:gn',
        'homePhone': 'urn:mace:dir:attribute-def:homePhone',
        'homePostalAddress': 'urn:mace:dir:attribute-def:homePostalAddress',
        'homeTelephoneNumber': 'urn:mace:dir:attribute-def:homeTelephoneNumber',
        'host': 'urn:mace:dir:attribute-def:host',
        'houseIdentifier': 'urn:mace:dir:attribute-def:houseIdentifier',
        'info': 'urn:mace:dir:attribute-def:info',
        'initials': 'urn:mace:dir:attribute-def:initials',
        'internationaliSDNNumber': 'urn:mace:dir:attribute-def:internationaliSDNNumber',
        'janetMailbox': 'urn:mace:dir:attribute-def:janetMailbox',
        'jpegPhoto': 'urn:mace:dir:attribute-def:jpegPhoto',
        'knowledgeInformation': 'urn:mace:dir:attribute-def:knowledgeInformation',
        'l': 'urn:mace:dir:attribute-def:l',
        'labeledURI': 'urn:mace:dir:attribute-def:labeledURI',
        'localityName': 'urn:mace:dir:attribute-def:localityName',
        'mDRecord': 'urn:mace:dir:attribute-def:mDRecord',
        'mXRecord': 'urn:mace:dir:attribute-def:mXRecord',
        'mail': 'urn:mace:dir:attribute-def:mail',
        'mailPreferenceOption': 'urn:mace:dir:attribute-def:mailPreferenceOption',
        'manager': 'urn:mace:dir:attribute-def:manager',
        'member': 'urn:mace:dir:attribute-def:member',
        'mobile': 'urn:mace:dir:attribute-def:mobile',
        'mobileTelephoneNumber': 'urn:mace:dir:attribute-def:mobileTelephoneNumber',
        'nSRecord': 'urn:mace:dir:attribute-def:nSRecord',
        'name': 'urn:mace:dir:attribute-def:name',
        'norEduOrgAcronym': 'urn:mace:dir:attribute-def:norEduOrgAcronym',
        'norEduOrgNIN': 'urn:mace:dir:attribute-def:norEduOrgNIN',
        'norEduOrgSchemaVersion': 'urn:mace:dir:attribute-def:norEduOrgSchemaVersion',
        'norEduOrgUniqueIdentifier': 'urn:mace:dir:attribute-def:norEduOrgUniqueIdentifier',
        'norEduOrgUniqueNumber': 'urn:mace:dir:attribute-def:norEduOrgUniqueNumber',
        'norEduOrgUnitUniqueIdentifier': 'urn:mace:dir:attribute-def:norEduOrgUnitUniqueIdentifier',
        'norEduOrgUnitUniqueNumber': 'urn:mace:dir:attribute-def:norEduOrgUnitUniqueNumber',
        'norEduPersonBirthDate': 'urn:mace:dir:attribute-def:norEduPersonBirthDate',
        'norEduPersonLIN': 'urn:mace:dir:attribute-def:norEduPersonLIN',
        'norEduPersonNIN': 'urn:mace:dir:attribute-def:norEduPersonNIN',
        'o': 'urn:mace:dir:attribute-def:o',
        'objectClass': 'urn:mace:dir:attribute-def:objectClass',
        'organizationName': 'urn:mace:dir:attribute-def:organizationName',
        'organizationalStatus': 'urn:mace:dir:attribute-def:organizationalStatus',
        'organizationalUnitName': 'urn:mace:dir:attribute-def:organizationalUnitName',
        'otherMailbox': 'urn:mace:dir:attribute-def:otherMailbox',
        'ou': 'urn:mace:dir:attribute-def:ou',
        'owner': 'urn:mace:dir:attribute-def:owner',
        'pager': 'urn:mace:dir:attribute-def:pager',
        'pagerTelephoneNumber': 'urn:mace:dir:attribute-def:pagerTelephoneNumber',
        'personalSignature': 'urn:mace:dir:attribute-def:personalSignature',
        'personalTitle': 'urn:mace:dir:attribute-def:personalTitle',
        'photo': 'urn:mace:dir:attribute-def:photo',
        'physicalDeliveryOfficeName': 'urn:mace:dir:attribute-def:physicalDeliveryOfficeName',
        'pkcs9email': 'urn:mace:dir:attribute-def:pkcs9email',
        'postOfficeBox': 'urn:mace:dir:attribute-def:postOfficeBox',
        'postalAddress': 'urn:mace:dir:attribute-def:postalAddress',
        'postalCode': 'urn:mace:dir:attribute-def:postalCode',
        'preferredDeliveryMethod': 'urn:mace:dir:attribute-def:preferredDeliveryMethod',
        'preferredLanguage': 'urn:mace:dir:attribute-def:preferredLanguage',
        'presentationAddress': 'urn:mace:dir:attribute-def:presentationAddress',
        'protocolInformation': 'urn:mace:dir:attribute-def:protocolInformation',
        'pseudonym': 'urn:mace:dir:attribute-def:pseudonym',
        'registeredAddress': 'urn:mace:dir:attribute-def:registeredAddress',
        'rfc822Mailbox': 'urn:mace:dir:attribute-def:rfc822Mailbox',
        'roleOccupant': 'urn:mace:dir:attribute-def:roleOccupant',
        'roomNumber': 'urn:mace:dir:attribute-def:roomNumber',
        'sOARecord': 'urn:mace:dir:attribute-def:sOARecord',
        'searchGuide': 'urn:mace:dir:attribute-def:searchGuide',
        'secretary': 'urn:mace:dir:attribute-def:secretary',
        'seeAlso': 'urn:mace:dir:attribute-def:seeAlso',
        'serialNumber': 'urn:mace:dir:attribute-def:serialNumber',
        'singleLevelQuality': 'urn:mace:dir:attribute-def:singleLevelQuality',
        'sn': 'urn:mace:dir:attribute-def:sn',
        'st': 'urn:mace:dir:attribute-def:st',
        'stateOrProvinceName': 'urn:mace:dir:attribute-def:stateOrProvinceName',
        'street': 'urn:mace:dir:attribute-def:street',
        'streetAddress': 'urn:mace:dir:attribute-def:streetAddress',
        'subtreeMaximumQuality': 'urn:mace:dir:attribute-def:subtreeMaximumQuality',
        'subtreeMinimumQuality': 'urn:mace:dir:attribute-def:subtreeMinimumQuality',
        'supportedAlgorithms': 'urn:mace:dir:attribute-def:supportedAlgorithms',
        'supportedApplicationContext': 'urn:mace:dir:attribute-def:supportedApplicationContext',
        'surname': 'urn:mace:dir:attribute-def:surname',
        'telephoneNumber': 'urn:mace:dir:attribute-def:telephoneNumber',
        'teletexTerminalIdentifier': 'urn:mace:dir:attribute-def:teletexTerminalIdentifier',
        'telexNumber': 'urn:mace:dir:attribute-def:telexNumber',
        'textEncodedORAddress': 'urn:mace:dir:attribute-def:textEncodedORAddress',
        'title': 'urn:mace:dir:attribute-def:title',
        'uid': 'urn:mace:dir:attribute-def:uid',
        'uniqueIdentifier': 'urn:mace:dir:attribute-def:uniqueIdentifier',
        'uniqueMember': 'urn:mace:dir:attribute-def:uniqueMember',
        'userCertificate': 'urn:mace:dir:attribute-def:userCertificate',
        'userClass': 'urn:mace:dir:attribute-def:userClass',
        'userPKCS12': 'urn:mace:dir:attribute-def:userPKCS12',
        'userPassword': 'urn:mace:dir:attribute-def:userPassword',
        'userSMIMECertificate': 'urn:mace:dir:attribute-def:userSMIMECertificate',
        'userid': 'urn:mace:dir:attribute-def:userid',
        'x121Address': 'urn:mace:dir:attribute-def:x121Address',
        'x500UniqueIdentifier': 'urn:mace:dir:attribute-def:x500UniqueIdentifier',
    }
}

########NEW FILE########
__FILENAME__ = saml_uri
__author__ = 'rolandh'

EDUPERSON_OID = "urn:oid:1.3.6.1.4.1.5923.1.1.1."
X500ATTR_OID = "urn:oid:2.5.4."
NOREDUPERSON_OID = "urn:oid:1.3.6.1.4.1.2428.90.1."
NETSCAPE_LDAP = "urn:oid:2.16.840.1.113730.3.1."
UCL_DIR_PILOT = 'urn:oid:0.9.2342.19200300.100.1.'
PKCS_9 = "urn:oid:1.2.840.113549.1.9.1."
UMICH = "urn:oid:1.3.6.1.4.1.250.1.57."

MAP = {
    "identifier": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
    "fro": {
        EDUPERSON_OID+'2': 'eduPersonNickname',
        EDUPERSON_OID+'9': 'eduPersonScopedAffiliation',
        EDUPERSON_OID+'11': 'eduPersonAssurance',
        EDUPERSON_OID+'10': 'eduPersonTargetedID',
        EDUPERSON_OID+'4': 'eduPersonOrgUnitDN',
        NOREDUPERSON_OID+'6': 'norEduOrgAcronym',
        NOREDUPERSON_OID+'7': 'norEduOrgUniqueIdentifier',
        NOREDUPERSON_OID+'4': 'norEduPersonLIN',
        EDUPERSON_OID+'1': 'eduPersonAffiliation',
        NOREDUPERSON_OID+'2': 'norEduOrgUnitUniqueNumber',
        NETSCAPE_LDAP+'40': 'userSMIMECertificate',
        NOREDUPERSON_OID+'1': 'norEduOrgUniqueNumber',
        NETSCAPE_LDAP+'241': 'displayName',
        UCL_DIR_PILOT+'37': 'associatedDomain',
        EDUPERSON_OID+'6': 'eduPersonPrincipalName',
        NOREDUPERSON_OID+'8': 'norEduOrgUnitUniqueIdentifier',
        NOREDUPERSON_OID+'9': 'federationFeideSchemaVersion',
        X500ATTR_OID+'53': 'deltaRevocationList',
        X500ATTR_OID+'52': 'supportedAlgorithms',
        X500ATTR_OID+'51': 'houseIdentifier',
        X500ATTR_OID+'50': 'uniqueMember',
        X500ATTR_OID+'19': 'physicalDeliveryOfficeName',
        X500ATTR_OID+'18': 'postOfficeBox',
        X500ATTR_OID+'17': 'postalCode',
        X500ATTR_OID+'16': 'postalAddress',
        X500ATTR_OID+'15': 'businessCategory',
        X500ATTR_OID+'14': 'searchGuide',
        EDUPERSON_OID+'5': 'eduPersonPrimaryAffiliation',
        X500ATTR_OID+'12': 'title',
        X500ATTR_OID+'11': 'ou',
        X500ATTR_OID+'10': 'o',
        X500ATTR_OID+'37': 'cACertificate',
        X500ATTR_OID+'36': 'userCertificate',
        X500ATTR_OID+'31': 'member',
        X500ATTR_OID+'30': 'supportedApplicationContext',
        X500ATTR_OID+'33': 'roleOccupant',
        X500ATTR_OID+'32': 'owner',
        NETSCAPE_LDAP+'1': 'carLicense',
        PKCS_9+'1': 'email',
        NETSCAPE_LDAP+'3': 'employeeNumber',
        NETSCAPE_LDAP+'2': 'departmentNumber',
        X500ATTR_OID+'39': 'certificateRevocationList',
        X500ATTR_OID+'38': 'authorityRevocationList',
        NETSCAPE_LDAP+'216': 'userPKCS12',
        EDUPERSON_OID+'8': 'eduPersonPrimaryOrgUnitDN',
        X500ATTR_OID+'9': 'street',
        X500ATTR_OID+'8': 'st',
        NETSCAPE_LDAP+'39': 'preferredLanguage',
        EDUPERSON_OID+'7': 'eduPersonEntitlement',
        X500ATTR_OID+'2': 'knowledgeInformation',
        X500ATTR_OID+'7': 'l',
        X500ATTR_OID+'6': 'c',
        X500ATTR_OID+'5': 'serialNumber',
        X500ATTR_OID+'4': 'sn',
        UCL_DIR_PILOT+'60': 'jpegPhoto',
        X500ATTR_OID+'65': 'pseudonym',
        NOREDUPERSON_OID+'5': 'norEduPersonNIN',
        UCL_DIR_PILOT+'3': 'mail',
        UCL_DIR_PILOT+'25': 'dc',
        X500ATTR_OID+'40': 'crossCertificatePair',
        X500ATTR_OID+'42': 'givenName',
        X500ATTR_OID+'43': 'initials',
        X500ATTR_OID+'44': 'generationQualifier',
        X500ATTR_OID+'45': 'x500UniqueIdentifier',
        X500ATTR_OID+'46': 'dnQualifier',
        X500ATTR_OID+'47': 'enhancedSearchGuide',
        X500ATTR_OID+'48': 'protocolInformation',
        X500ATTR_OID+'54': 'dmdName',
        NETSCAPE_LDAP+'4': 'employeeType',
        X500ATTR_OID+'22': 'teletexTerminalIdentifier',
        X500ATTR_OID+'23': 'facsimileTelephoneNumber',
        X500ATTR_OID+'20': 'telephoneNumber',
        X500ATTR_OID+'21': 'telexNumber',
        X500ATTR_OID+'26': 'registeredAddress',
        X500ATTR_OID+'27': 'destinationIndicator',
        X500ATTR_OID+'24': 'x121Address',
        X500ATTR_OID+'25': 'internationaliSDNNumber',
        X500ATTR_OID+'28': 'preferredDeliveryMethod',
        X500ATTR_OID+'29': 'presentationAddress',
        EDUPERSON_OID+'3': 'eduPersonOrgDN',
        NOREDUPERSON_OID+'3': 'norEduPersonBirthDate',
        UMICH+'57': 'labeledURI',
        UCL_DIR_PILOT+'1': 'uid',
    },
    "to": {
        'roleOccupant': X500ATTR_OID+'33',
        'gn': X500ATTR_OID+'42',
        'norEduPersonNIN': NOREDUPERSON_OID+'5',
        'title': X500ATTR_OID+'12',
        'facsimileTelephoneNumber': X500ATTR_OID+'23',
        'mail': UCL_DIR_PILOT+'3',
        'postOfficeBox': X500ATTR_OID+'18',
        'fax': X500ATTR_OID+'23',
        'telephoneNumber': X500ATTR_OID+'20',
        'norEduPersonBirthDate': NOREDUPERSON_OID+'3',
        'rfc822Mailbox': UCL_DIR_PILOT+'3',
        'dc': UCL_DIR_PILOT+'25',
        'countryName': X500ATTR_OID+'6',
        'emailAddress': PKCS_9+'1',
        'employeeNumber': NETSCAPE_LDAP+'3',
        'organizationName': X500ATTR_OID+'10',
        'eduPersonAssurance': EDUPERSON_OID+'11',
        'norEduOrgAcronym': NOREDUPERSON_OID+'6',
        'registeredAddress': X500ATTR_OID+'26',
        'physicalDeliveryOfficeName': X500ATTR_OID+'19',
        'associatedDomain': UCL_DIR_PILOT+'37',
        'l': X500ATTR_OID+'7',
        'stateOrProvinceName': X500ATTR_OID+'8',
        'federationFeideSchemaVersion': NOREDUPERSON_OID+'9',
        'pkcs9email': PKCS_9+'1',
        'givenName': X500ATTR_OID+'42',
        'givenname': X500ATTR_OID+'42',
        'x500UniqueIdentifier': X500ATTR_OID+'45',
        'eduPersonNickname': EDUPERSON_OID+'2',
        'houseIdentifier': X500ATTR_OID+'51',
        'street': X500ATTR_OID+'9',
        'supportedAlgorithms': X500ATTR_OID+'52',
        'preferredLanguage': NETSCAPE_LDAP+'39',
        'postalAddress': X500ATTR_OID+'16',
        'email': PKCS_9+'1',
        'norEduOrgUnitUniqueIdentifier': NOREDUPERSON_OID+'8',
        'eduPersonPrimaryOrgUnitDN': EDUPERSON_OID+'8',
        'c': X500ATTR_OID+'6',
        'teletexTerminalIdentifier': X500ATTR_OID+'22',
        'o': X500ATTR_OID+'10',
        'cACertificate': X500ATTR_OID+'37',
        'telexNumber': X500ATTR_OID+'21',
        'ou': X500ATTR_OID+'11',
        'initials': X500ATTR_OID+'43',
        'eduPersonOrgUnitDN': EDUPERSON_OID+'4',
        'deltaRevocationList': X500ATTR_OID+'53',
        'norEduPersonLIN': NOREDUPERSON_OID+'4',
        'supportedApplicationContext': X500ATTR_OID+'30',
        'eduPersonEntitlement': EDUPERSON_OID+'7',
        'generationQualifier': X500ATTR_OID+'44',
        'eduPersonAffiliation': EDUPERSON_OID+'1',
        'eduPersonPrincipalName': EDUPERSON_OID+'6',
        'edupersonprincipalname': EDUPERSON_OID+'6',
        'localityName': X500ATTR_OID+'7',
        'owner': X500ATTR_OID+'32',
        'norEduOrgUnitUniqueNumber': NOREDUPERSON_OID+'2',
        'searchGuide': X500ATTR_OID+'14',
        'certificateRevocationList': X500ATTR_OID+'39',
        'organizationalUnitName': X500ATTR_OID+'11',
        'userCertificate': X500ATTR_OID+'36',
        'preferredDeliveryMethod': X500ATTR_OID+'28',
        'internationaliSDNNumber': X500ATTR_OID+'25',
        'uniqueMember': X500ATTR_OID+'50',
        'departmentNumber': NETSCAPE_LDAP+'2',
        'enhancedSearchGuide': X500ATTR_OID+'47',
        'userPKCS12': NETSCAPE_LDAP+'216',
        'eduPersonTargetedID': EDUPERSON_OID+'10',
        'norEduOrgUniqueNumber': NOREDUPERSON_OID+'1',
        'x121Address': X500ATTR_OID+'24',
        'destinationIndicator': X500ATTR_OID+'27',
        'eduPersonPrimaryAffiliation': EDUPERSON_OID+'5',
        'surname': X500ATTR_OID+'4',
        'jpegPhoto': UCL_DIR_PILOT+'60',
        'eduPersonScopedAffiliation': EDUPERSON_OID+'9',
        'edupersonscopedaffiliation': EDUPERSON_OID+'9',
        'protocolInformation': X500ATTR_OID+'48',
        'knowledgeInformation': X500ATTR_OID+'2',
        'employeeType': NETSCAPE_LDAP+'4',
        'userSMIMECertificate': NETSCAPE_LDAP+'40',
        'member': X500ATTR_OID+'31',
        'streetAddress': X500ATTR_OID+'9',
        'dmdName': X500ATTR_OID+'54',
        'postalCode': X500ATTR_OID+'17',
        'pseudonym': X500ATTR_OID+'65',
        'dnQualifier': X500ATTR_OID+'46',
        'crossCertificatePair': X500ATTR_OID+'40',
        'eduPersonOrgDN': EDUPERSON_OID+'3',
        'authorityRevocationList': X500ATTR_OID+'38',
        'displayName': NETSCAPE_LDAP+'241',
        'businessCategory': X500ATTR_OID+'15',
        'serialNumber': X500ATTR_OID+'5',
        'norEduOrgUniqueIdentifier': NOREDUPERSON_OID+'7',
        'st': X500ATTR_OID+'8',
        'carLicense': NETSCAPE_LDAP+'1',
        'presentationAddress': X500ATTR_OID+'29',
        'sn': X500ATTR_OID+'4',
        'domainComponent': UCL_DIR_PILOT+'25',
        'labeledURI': UMICH+'57',
        'uid': UCL_DIR_PILOT+'1'
    }
}  

########NEW FILE########
__FILENAME__ = shibboleth_uri
EDUPERSON_OID = "urn:oid:1.3.6.1.4.1.5923.1.1.1."
X500ATTR = "urn:oid:2.5.4."
NOREDUPERSON_OID = "urn:oid:1.3.6.1.4.1.2428.90.1."
NETSCAPE_LDAP = "urn:oid:2.16.840.1.113730.3.1."
UCL_DIR_PILOT = "urn:oid:0.9.2342.19200300.100.1."
PKCS_9 = "urn:oid:1.2.840.113549.1.9."
UMICH = "urn:oid:1.3.6.1.4.1.250.1.57."

MAP = {
    "identifier": "urn:mace:shibboleth:1.0:attributeNamespace:uri",
    "fro": {
        EDUPERSON_OID+'2': 'eduPersonNickname',
        EDUPERSON_OID+'9': 'eduPersonScopedAffiliation',
        EDUPERSON_OID+'11': 'eduPersonAssurance',
        EDUPERSON_OID+'10': 'eduPersonTargetedID',
        EDUPERSON_OID+'4': 'eduPersonOrgUnitDN',
        NOREDUPERSON_OID+'6': 'norEduOrgAcronym',
        NOREDUPERSON_OID+'7': 'norEduOrgUniqueIdentifier',
        NOREDUPERSON_OID+'4': 'norEduPersonLIN',
        EDUPERSON_OID+'1': 'eduPersonAffiliation',
        NOREDUPERSON_OID+'2': 'norEduOrgUnitUniqueNumber',
        NETSCAPE_LDAP+'40': 'userSMIMECertificate',
        NOREDUPERSON_OID+'1': 'norEduOrgUniqueNumber',
        NETSCAPE_LDAP+'241': 'displayName',
        UCL_DIR_PILOT+'37': 'associatedDomain',
        EDUPERSON_OID+'6': 'eduPersonPrincipalName',
        NOREDUPERSON_OID+'8': 'norEduOrgUnitUniqueIdentifier',
        NOREDUPERSON_OID+'9': 'federationFeideSchemaVersion',
        X500ATTR+'53': 'deltaRevocationList',
        X500ATTR+'52': 'supportedAlgorithms',
        X500ATTR+'51': 'houseIdentifier',
        X500ATTR+'50': 'uniqueMember',
        X500ATTR+'19': 'physicalDeliveryOfficeName',
        X500ATTR+'18': 'postOfficeBox',
        X500ATTR+'17': 'postalCode',
        X500ATTR+'16': 'postalAddress',
        X500ATTR+'15': 'businessCategory',
        X500ATTR+'14': 'searchGuide',
        EDUPERSON_OID+'5': 'eduPersonPrimaryAffiliation',
        X500ATTR+'12': 'title',
        X500ATTR+'11': 'ou',
        X500ATTR+'10': 'o',
        X500ATTR+'37': 'cACertificate',
        X500ATTR+'36': 'userCertificate',
        X500ATTR+'31': 'member',
        X500ATTR+'30': 'supportedApplicationContext',
        X500ATTR+'33': 'roleOccupant',
        X500ATTR+'32': 'owner',
        NETSCAPE_LDAP+'1': 'carLicense',
        PKCS_9+'1': 'email',
        NETSCAPE_LDAP+'3': 'employeeNumber',
        NETSCAPE_LDAP+'2': 'departmentNumber',
        X500ATTR+'39': 'certificateRevocationList',
        X500ATTR+'38': 'authorityRevocationList',
        NETSCAPE_LDAP+'216': 'userPKCS12',
        EDUPERSON_OID+'8': 'eduPersonPrimaryOrgUnitDN',
        X500ATTR+'9': 'street',
        X500ATTR+'8': 'st',
        NETSCAPE_LDAP+'39': 'preferredLanguage',
        EDUPERSON_OID+'7': 'eduPersonEntitlement',
        X500ATTR+'2': 'knowledgeInformation',
        X500ATTR+'7': 'l',
        X500ATTR+'6': 'c',
        X500ATTR+'5': 'serialNumber',
        X500ATTR+'4': 'sn',
        UCL_DIR_PILOT+'60': 'jpegPhoto',
        X500ATTR+'65': 'pseudonym',
        NOREDUPERSON_OID+'5': 'norEduPersonNIN',
        UCL_DIR_PILOT+'3': 'mail',
        UCL_DIR_PILOT+'25': 'dc',
        X500ATTR+'40': 'crossCertificatePair',
        X500ATTR+'42': 'givenName',
        X500ATTR+'43': 'initials',
        X500ATTR+'44': 'generationQualifier',
        X500ATTR+'45': 'x500UniqueIdentifier',
        X500ATTR+'46': 'dnQualifier',
        X500ATTR+'47': 'enhancedSearchGuide',
        X500ATTR+'48': 'protocolInformation',
        X500ATTR+'54': 'dmdName',
        NETSCAPE_LDAP+'4': 'employeeType',
        X500ATTR+'22': 'teletexTerminalIdentifier',
        X500ATTR+'23': 'facsimileTelephoneNumber',
        X500ATTR+'20': 'telephoneNumber',
        X500ATTR+'21': 'telexNumber',
        X500ATTR+'26': 'registeredAddress',
        X500ATTR+'27': 'destinationIndicator',
        X500ATTR+'24': 'x121Address',
        X500ATTR+'25': 'internationaliSDNNumber',
        X500ATTR+'28': 'preferredDeliveryMethod',
        X500ATTR+'29': 'presentationAddress',
        EDUPERSON_OID+'3': 'eduPersonOrgDN',
        NOREDUPERSON_OID+'3': 'norEduPersonBirthDate',
    },
    "to":{
        'roleOccupant': X500ATTR+'33',
        'gn': X500ATTR+'42',
        'norEduPersonNIN': NOREDUPERSON_OID+'5',
        'title': X500ATTR+'12',
        'facsimileTelephoneNumber': X500ATTR+'23',
        'mail': UCL_DIR_PILOT+'3',
        'postOfficeBox': X500ATTR+'18',
        'fax': X500ATTR+'23',
        'telephoneNumber': X500ATTR+'20',
        'norEduPersonBirthDate': NOREDUPERSON_OID+'3',
        'rfc822Mailbox': UCL_DIR_PILOT+'3',
        'dc': UCL_DIR_PILOT+'25',
        'countryName': X500ATTR+'6',
        'emailAddress': PKCS_9+'1',
        'employeeNumber': NETSCAPE_LDAP+'3',
        'organizationName': X500ATTR+'10',
        'eduPersonAssurance': EDUPERSON_OID+'11',
        'norEduOrgAcronym': NOREDUPERSON_OID+'6',
        'registeredAddress': X500ATTR+'26',
        'physicalDeliveryOfficeName': X500ATTR+'19',
        'associatedDomain': UCL_DIR_PILOT+'37',
        'l': X500ATTR+'7',
        'stateOrProvinceName': X500ATTR+'8',
        'federationFeideSchemaVersion': NOREDUPERSON_OID+'9',
        'pkcs9email': PKCS_9+'1',
        'givenName': X500ATTR+'42',
        'x500UniqueIdentifier': X500ATTR+'45',
        'eduPersonNickname': EDUPERSON_OID+'2',
        'houseIdentifier': X500ATTR+'51',
        'street': X500ATTR+'9',
        'supportedAlgorithms': X500ATTR+'52',
        'preferredLanguage': NETSCAPE_LDAP+'39',
        'postalAddress': X500ATTR+'16',
        'email': PKCS_9+'1',
        'norEduOrgUnitUniqueIdentifier': NOREDUPERSON_OID+'8',
        'eduPersonPrimaryOrgUnitDN': EDUPERSON_OID+'8',
        'c': X500ATTR+'6',
        'teletexTerminalIdentifier': X500ATTR+'22',
        'o': X500ATTR+'10',
        'cACertificate': X500ATTR+'37',
        'telexNumber': X500ATTR+'21',
        'ou': X500ATTR+'11',
        'initials': X500ATTR+'43',
        'eduPersonOrgUnitDN': EDUPERSON_OID+'4',
        'deltaRevocationList': X500ATTR+'53',
        'norEduPersonLIN': NOREDUPERSON_OID+'4',
        'supportedApplicationContext': X500ATTR+'30',
        'eduPersonEntitlement': EDUPERSON_OID+'7',
        'generationQualifier': X500ATTR+'44',
        'eduPersonAffiliation': EDUPERSON_OID+'1',
        'eduPersonPrincipalName': EDUPERSON_OID+'6',
        'localityName': X500ATTR+'7',
        'owner': X500ATTR+'32',
        'norEduOrgUnitUniqueNumber': NOREDUPERSON_OID+'2',
        'searchGuide': X500ATTR+'14',
        'certificateRevocationList': X500ATTR+'39',
        'organizationalUnitName': X500ATTR+'11',
        'userCertificate': X500ATTR+'36',
        'preferredDeliveryMethod': X500ATTR+'28',
        'internationaliSDNNumber': X500ATTR+'25',
        'uniqueMember': X500ATTR+'50',
        'departmentNumber': NETSCAPE_LDAP+'2',
        'enhancedSearchGuide': X500ATTR+'47',
        'userPKCS12': NETSCAPE_LDAP+'216',
        'eduPersonTargetedID': EDUPERSON_OID+'10',
        'norEduOrgUniqueNumber': NOREDUPERSON_OID+'1',
        'x121Address': X500ATTR+'24',
        'destinationIndicator': X500ATTR+'27',
        'eduPersonPrimaryAffiliation': EDUPERSON_OID+'5',
        'surname': X500ATTR+'4',
        'jpegPhoto': UCL_DIR_PILOT+'60',
        'eduPersonScopedAffiliation': EDUPERSON_OID+'9',
        'protocolInformation': X500ATTR+'48',
        'knowledgeInformation': X500ATTR+'2',
        'employeeType': NETSCAPE_LDAP+'4',
        'userSMIMECertificate': NETSCAPE_LDAP+'40',
        'member': X500ATTR+'31',
        'streetAddress': X500ATTR+'9',
        'dmdName': X500ATTR+'54',
        'postalCode': X500ATTR+'17',
        'pseudonym': X500ATTR+'65',
        'dnQualifier': X500ATTR+'46',
        'crossCertificatePair': X500ATTR+'40',
        'eduPersonOrgDN': EDUPERSON_OID+'3',
        'authorityRevocationList': X500ATTR+'38',
        'displayName': NETSCAPE_LDAP+'241',
        'businessCategory': X500ATTR+'15',
        'serialNumber': X500ATTR+'5',
        'norEduOrgUniqueIdentifier': NOREDUPERSON_OID+'7',
        'st': X500ATTR+'8',
        'carLicense': NETSCAPE_LDAP+'1',
        'presentationAddress': X500ATTR+'29',
        'sn': X500ATTR+'4',
        'domainComponent': UCL_DIR_PILOT+'25',
    }
}

########NEW FILE########
__FILENAME__ = attribute_statement_data
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Testdata for attribute converters """

STATEMENT1 = """<?xml version="1.0" encoding="utf-8"?>
<ns1:AttributeStatement xmlns:ns1="urn:oasis:names:tc:SAML:2.0:assertion">
    <ns1:Attribute Name="urn:mace:dir:attribute-def:eduPersonPrincipalName"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>rohe0002@umu.se</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:eduPersonTargetedID"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>a139b2116ad1dd7b91c129a32a242fcc5fd9e821</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:displayName" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>Hedberg, Roland</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:uid" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>rohe0002</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:eduPersonNickname" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>rohe0002</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:cn" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>Roland Hedberg</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:eduPersonAffiliation" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>member</ns1:AttributeValue>
        <ns1:AttributeValue>employee</ns1:AttributeValue>
        <ns1:AttributeValue>staff</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:street" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>Ume universitet</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:postalCode" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>901 87</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:eduPersonScopedAffiliation" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>employee@umu.se</ns1:AttributeValue>
        <ns1:AttributeValue>staff@umu.se</ns1:AttributeValue>
        <ns1:AttributeValue>member@umu.se</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:physicalDeliveryOfficeName" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>Vstra flygeln, plan 4</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:employeeType" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>IT-arkitekt</ns1:AttributeValue>
        <ns1:AttributeValue>vrig/annan befattning</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:ou" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>Ladokenheten</ns1:AttributeValue>
        <ns1:AttributeValue>IT-enheten</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:givenName" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>Roland</ns1:AttributeValue>
    </ns1:Attribute>
    <ns1:Attribute Name="urn:mace:dir:attribute-def:sn" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <ns1:AttributeValue>Hedberg</ns1:AttributeValue>
    </ns1:Attribute>
</ns1:AttributeStatement>"""


STATEMENT2 = """<?xml version="1.0" encoding="utf-8"?>
<saml2:AttributeStatement xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion">
    <saml2:Attribute FriendlyName="uid" Name="urn:oid:0.9.2342.19200300.100.1.1" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            xsi:type="xs:string">demouser</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute FriendlyName="surname"
        Name="urn:oid:2.5.4.4" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue 
            xmlns:xs="http://www.w3.org/2001/XMLSchema" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            xsi:type="xs:string">SWITCHaai</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute FriendlyName="givenName" 
        Name="urn:oid:2.5.4.42" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue 
            xmlns:xs="http://www.w3.org/2001/XMLSchema" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            xsi:type="xs:string">Demouser</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute FriendlyName="eduPersonAffiliation" 
        Name="urn:oid:1.3.6.1.4.1.5923.1.1.1.1" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue 
            xmlns:xs="http://www.w3.org/2001/XMLSchema" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            xsi:type="xs:string">staff</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute FriendlyName="eduPersonEntitlement" 
        Name="urn:oid:1.3.6.1.4.1.5923.1.1.1.7" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue 
            xmlns:xs="http://www.w3.org/2001/XMLSchema" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            xsi:type="xs:string">http://example.org/res/99999</saml2:AttributeValue>
        <saml2:AttributeValue 
            xmlns:xs="http://www.w3.org/2001/XMLSchema" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            xsi:type="xs:string">http://publisher-xy.com/e-journals</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute FriendlyName="mail" 
        Name="urn:oid:0.9.2342.19200300.100.1.3" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue 
            xmlns:xs="http://www.w3.org/2001/XMLSchema" 
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
            xsi:type="xs:string">demouser@example.org</saml2:AttributeValue>
    </saml2:Attribute>
</saml2:AttributeStatement>"""

STATEMENT3 = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:AttributeStatement xmlns:ns0="urn:oasis:names:tc:SAML:2.0:assertion">
    <ns0:Attribute Name="umuselin">
        <ns0:AttributeValue>1234567890</ns0:AttributeValue>
    </ns0:Attribute>
    <ns0:Attribute Name="edupersonaffiliation">
        <ns0:AttributeValue>staff</ns0:AttributeValue>
    </ns0:Attribute>
    <ns0:Attribute FriendlyName="surname" Name="urn:oid:2.5.4.4" 
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <ns0:AttributeValue>Hedberg</ns0:AttributeValue>
    </ns0:Attribute>
    <ns0:Attribute Name="uid">
        <ns0:AttributeValue>roland</ns0:AttributeValue>
    </ns0:Attribute>
    <ns0:Attribute Name="givenname">
        <ns0:AttributeValue>Roland</ns0:AttributeValue>
    </ns0:Attribute>
</ns0:AttributeStatement>"""

STATEMENT4 = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:AttributeStatement xmlns:ns0="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <ns0:Attribute Name="user_id" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified">
        <ns0:AttributeValue xsi:type="xs:string">bob</ns0:AttributeValue>
    </ns0:Attribute>
    <ns0:Attribute Name="NameID" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified">
        <ns0:AttributeValue xsi:type="xs:string">bobsnameagain</ns0:AttributeValue>
    </ns0:Attribute>
</ns0:AttributeStatement>"""

STATEMENT_MIXED = """<?xml version="1.0" encoding="utf-8"?>
<saml2:AttributeStatement xmlns:saml2="urn:oasis:names:tc:SAML:2.0:assertion">
    <saml2:Attribute FriendlyName="uid" Name="urn:oid:0.9.2342.19200300.100.1.1"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:type="xs:string">demouser</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute FriendlyName="swissEduPersonHomeOrganizationType"
        Name="urn:oid:2.16.756.1.2.5.1.1.5"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue
            xmlns:xs="http://www.w3.org/2001/XMLSchema"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:type="xs:string">others</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute Name="urn:mace:dir:attribute-def:givenName"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <saml2:AttributeValue>Roland</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute Name="urn:mace:dir:attribute-def:sn"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
        <saml2:AttributeValue>Hedberg</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute FriendlyName="eduPersonAffiliation"
        Name="urn:oid:1.3.6.1.4.1.5923.1.1.1.1"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri">
        <saml2:AttributeValue
            xmlns:xs="http://www.w3.org/2001/XMLSchema"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:type="xs:string">staff</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute Name="urn:example:com:foo"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:example">
        <saml2:AttributeValue>Thing</saml2:AttributeValue>
    </saml2:Attribute>
    <saml2:Attribute Name="user_id"
        NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified">
        <saml2:AttributeValue>bob</saml2:AttributeValue>
    </saml2:Attribute>
</saml2:AttributeStatement>"""

########NEW FILE########
__FILENAME__ = conftest
import os

#TODO: On my system this function seems to be returning an incorrect location
def pytest_funcarg__xmlsec(request):
    for path in os.environ["PATH"].split(":"):
        fil = os.path.join(path, "xmlsec1")
        if os.access(fil,os.X_OK):
            return fil

    raise Exception("Can't find xmlsec1")
    
def pytest_funcarg__AVA(request):
    return [
        {
            "surName": ["Jeter"],
            "givenName": ["Derek"],
        },
        {
            "surName": ["Howard"],
            "givenName": ["Ryan"],
        },
        {
            "surName": ["Suzuki"],
            "givenName": ["Ischiro"],
        },
        {
            "surName": ["Hedberg"],
            "givenName": ["Roland"],
        },
    ]    

########NEW FILE########
__FILENAME__ = disco_conf
from saml2.extension.idpdisc import BINDING_DISCO

from pathutils import full_path
from pathutils import xmlsec_path

BASE = "http://localhost:8088"

CONFIG = {
    "entityid": "%s/disco.xml" % BASE,
    "name": "Rolands Discoserver",
    "service": {
        "ds": {
            "endpoints": {
                "disco_service": [
                    ("%s/disco" % BASE, BINDING_DISCO),
                ]
            },
        },
    },
    "debug": 1,
    "xmlsec_binary": xmlsec_path,
    "metadata": {
        "local": [full_path("servera.xml")],
    },
}

########NEW FILE########
__FILENAME__ = ds_data
#!/usr/bin/env python
#
# Copyright (C) 2007 SIOS Technology, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Test data for ds"""

__author__ = 'tmatsuo@example.com (Takashi MATSUO)'

TEST_OBJECT = """<?xml version="1.0" encoding="utf-8"?>
<Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64"
  xmlns="http://www.w3.org/2000/09/xmldsig#">
  V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
</Object>
"""

TEST_MGMT_DATA = """<?xml version="1.0" encoding="utf-8"?>
<MgmtData xmlns="http://www.w3.org/2000/09/xmldsig#">
  mgmt data
</MgmtData>
"""

TEST_SPKI_SEXP = """<?xml version="1.0" encoding="utf-8"?>
<SPKISexp xmlns="http://www.w3.org/2000/09/xmldsig#">
  spki sexp
</SPKISexp>
"""

TEST_SPKI_DATA = """<?xml version="1.0" encoding="utf-8"?>
<SPKIData xmlns="http://www.w3.org/2000/09/xmldsig#">
  <SPKISexp>spki sexp</SPKISexp>
  <SPKISexp>spki sexp2</SPKISexp>
</SPKIData>  
"""

TEST_PGP_DATA = """<?xml version="1.0" encoding="utf-8"?>
<PGPData xmlns="http://www.w3.org/2000/09/xmldsig#">
  <PGPKeyID>pgp key id</PGPKeyID>
  <PGPKeyPacket>pgp key packet</PGPKeyPacket>
</PGPData>
"""

TEST_X509_ISSUER_SERIAL = """<?xml version="1.0" encoding="utf-8"?>
<X509IssuerSerial xmlns="http://www.w3.org/2000/09/xmldsig#">
  <X509IssuerName>issuer name</X509IssuerName>
  <X509SerialNumber>1</X509SerialNumber>
</X509IssuerSerial>
"""

TEST_X509_DATA = """<?xml version="1.0" encoding="utf-8"?>
<X509Data xmlns="http://www.w3.org/2000/09/xmldsig#">
  <X509IssuerSerial>
    <X509IssuerName>issuer name</X509IssuerName>
    <X509IssuerNumber>1</X509IssuerNumber>
  </X509IssuerSerial>
  <X509SKI>x509 ski</X509SKI>
  <X509SubjectName>x509 subject name</X509SubjectName>
  <X509Certificate>x509 certificate</X509Certificate>
  <X509CRL>x509 crl</X509CRL>
</X509Data>
"""

TEST_TRANSFORM = """<?xml version="1.0" encoding="utf-8"?>
<Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature"
  xmlns="http://www.w3.org/2000/09/xmldsig#">
  <XPath>xpath</XPath>
</Transform>
"""

TEST_TRANSFORMS = """<?xml version="1.0" encoding="utf-8"?>
<Transforms xmlns="http://www.w3.org/2000/09/xmldsig#">
  <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
    <XPath>xpath</XPath>
  </Transform>
  <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
    <XPath>xpath</XPath>
  </Transform>
</Transforms>
"""

TEST_RETRIEVAL_METHOD = """<?xml version="1.0" encoding="utf-8"?>
<RetrievalMethod xmlns="http://www.w3.org/2000/09/xmldsig#"
  URI="http://www.example.com/URI"
  Type="http://www.example.com/Type">
  <Transforms>
    <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
      <XPath>xpath</XPath>
    </Transform>
    <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
      <XPath>xpath</XPath>
    </Transform>
  </Transforms>
</RetrievalMethod>
"""

TEST_RSA_KEY_VALUE = """<?xml version="1.0" encoding="utf-8"?>
<RSAKeyValue xmlns="http://www.w3.org/2000/09/xmldsig#">
  <Modulus>modulus</Modulus>
  <Exponent>exponent</Exponent>
</RSAKeyValue>
"""

TEST_DSA_KEY_VALUE = """<?xml version="1.0" encoding="utf-8"?>
<DSAKeyValue xmlns="http://www.w3.org/2000/09/xmldsig#">
  <P>p</P>
  <Q>q</Q>
  <G>g</G>
  <Y>y</Y>
  <J>j</J>
  <Seed>seed</Seed>
  <PgenCounter>pgen counter</PgenCounter>
</DSAKeyValue>
"""

TEST_KEY_VALUE1 = """<?xml version="1.0" encoding="utf-8"?>
<KeyValue xmlns="http://www.w3.org/2000/09/xmldsig#">
  <DSAKeyValue>
    <P>p</P>
    <Q>q</Q>
    <G>g</G>
    <Y>y</Y>
    <J>j</J>
    <Seed>seed</Seed>
    <PgenCounter>pgen counter</PgenCounter>
  </DSAKeyValue>
</KeyValue>
"""

TEST_KEY_VALUE2 = """<?xml version="1.0" encoding="utf-8"?>
<KeyValue xmlns="http://www.w3.org/2000/09/xmldsig#">
  <RSAKeyValue xmlns="http://www.w3.org/2000/09/xmldsig#">
    <Modulus>modulus</Modulus>
    <Exponent>exponent</Exponent>
  </RSAKeyValue>
</KeyValue>
"""

TEST_KEY_NAME = """<?xml version="1.0" encoding="utf-8"?>
<KeyName xmlns="http://www.w3.org/2000/09/xmldsig#">
  key name
</KeyName>
"""

TEST_KEY_INFO = """<?xml version="1.0" encoding="utf-8"?>
<KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <KeyName>
    key name
  </KeyName>
  <KeyValue>
    <DSAKeyValue>
      <P>p</P>
      <Q>q</Q>
      <G>g</G>
      <Y>y</Y>
      <J>j</J>
      <Seed>seed</Seed>
      <PgenCounter>pgen counter</PgenCounter>
    </DSAKeyValue>
  </KeyValue>
  <RetrievalMethod URI="http://www.example.com/URI"
    Type="http://www.example.com/Type">
    <Transforms>
      <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
        <XPath>xpath</XPath>
      </Transform>
      <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
        <XPath>xpath</XPath>
      </Transform>
    </Transforms>
  </RetrievalMethod>
  <X509Data>
    <X509IssuerSerial>
      <X509IssuerName>issuer name</X509IssuerName>
      <X509IssuerNumber>1</X509IssuerNumber>
    </X509IssuerSerial>
    <X509SKI>x509 ski</X509SKI>
    <X509SubjectName>x509 subject name</X509SubjectName>
    <X509Certificate>x509 certificate</X509Certificate>
    <X509CRL>x509 crl</X509CRL>
  </X509Data>
  <PGPData>
    <PGPKeyID>pgp key id</PGPKeyID>
    <PGPKeyPacket>pgp key packet</PGPKeyPacket>
  </PGPData>
  <MgmtData>
    mgmt data
  </MgmtData>
  <SPKIData>
    <SPKISexp>spki sexp</SPKISexp>
    <SPKISexp>spki sexp2</SPKISexp>
  </SPKIData>  
</KeyInfo>
"""

TEST_DIGEST_VALUE = """<?xml version="1.0" encoding="utf-8"?>
<DigestValue xmlns="http://www.w3.org/2000/09/xmldsig#">
  digest value
</DigestValue>
"""

TEST_DIGEST_METHOD = """<?xml version="1.0" encoding="utf-8"?>
<DigestMethod xmlns="http://www.w3.org/2000/09/xmldsig#"
  Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
"""

TEST_REFERENCE = """<?xml version="1.0" encoding="utf-8"?>
<Reference xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id"
  URI="http://www.example.com/URI"
  Type="http://www.example.com/Type">
  <Transforms>
    <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
      <XPath>xpath</XPath>
    </Transform>
    <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
      <XPath>xpath</XPath>
    </Transform>
  </Transforms>
  <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
  <DigestValue>digest value</DigestValue>
</Reference>
"""

TEST_SIGNATURE_METHOD = """<?xml version="1.0" encoding="utf-8"?>
<SignatureMethod xmlns="http://www.w3.org/2000/09/xmldsig#"
  Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
  <HMACOutputLength>8</HMACOutputLength>
</SignatureMethod>
"""

TEST_CANONICALIZATION_METHOD = """<?xml version="1.0" encoding="utf-8"?>
<CanonicalizationMethod xmlns="http://www.w3.org/2000/09/xmldsig#"
  Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
</CanonicalizationMethod>
"""

TEST_SIGNED_INFO = """<?xml version="1.0" encoding="utf-8"?>
<SignedInfo xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <CanonicalizationMethod
    Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
  </CanonicalizationMethod>
  <SignatureMethod
    Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
    <HMACOutputLength>8</HMACOutputLength>
  </SignatureMethod>
  <Reference Id="id" URI="http://www.example.com/URI"
    Type="http://www.example.com/Type">
    <Transforms>
      <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
        <XPath>xpath</XPath>
      </Transform>
      <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
        <XPath>xpath</XPath>
      </Transform>
    </Transforms>
    <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
    <DigestValue>digest value</DigestValue>
  </Reference>
</SignedInfo>
"""

TEST_SIGNATURE_VALUE = """<?xml version="1.0" encoding="utf-8"?>
<SignatureValue xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  signature value
</SignatureValue>
"""

TEST_SIGNATURE = """<?xml version="1.0" encoding="utf-8"?>
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <SignedInfo Id="id">
    <CanonicalizationMethod
      Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
    </CanonicalizationMethod>
    <SignatureMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
      <HMACOutputLength>8</HMACOutputLength>
    </SignatureMethod>
    <Reference Id="id" URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
      <DigestValue>digest value</DigestValue>
    </Reference>
  </SignedInfo>
  <SignatureValue Id="id">
    signature value
  </SignatureValue>
  <KeyInfo Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
    V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
  </Object>
</Signature>
"""

########NEW FILE########
__FILENAME__ = fakeIDP
from urlparse import parse_qs
from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.samlp import attribute_query_from_string, logout_request_from_string
from saml2 import BINDING_HTTP_REDIRECT, pack
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_SOAP
from saml2.server import Server
from saml2.soap import parse_soap_enveloped_saml_attribute_query
from saml2.soap import parse_soap_enveloped_saml_logout_request
from saml2.soap import make_soap_enveloped_saml_thingy

__author__ = 'rolandh'

TYP = {
    "GET": [BINDING_HTTP_REDIRECT],
    "POST": [BINDING_HTTP_POST, BINDING_SOAP]
}


AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


def unpack_form(_str, ver="SAMLRequest"):
    SR_STR = "name=\"%s\" value=\"" % ver
    RS_STR = 'name="RelayState" value="'

    i = _str.find(SR_STR)
    i += len(SR_STR)
    j = _str.find('"', i)

    sr = _str[i:j]

    k = _str.find(RS_STR, j)
    k += len(RS_STR)
    l = _str.find('"', k)

    rs = _str[k:l]

    return {ver: sr, "RelayState": rs}


class DummyResponse(object):
    def __init__(self, code, data, headers=None):
        self.status_code = code
        self.text = data
        self.headers = headers or []


class FakeIDP(Server):
    def __init__(self, config_file=""):
        Server.__init__(self, config_file)
        #self.sign = False

    def receive(self, url, method="GET", **kwargs):
        """
        Interface to receive HTTP calls on

        :param url:
        :param method:
        :param kwargs:
        :return:
        """

        if method == "GET":
            path, query = url.split("?")
            qs_dict = parse_qs(kwargs["data"])
            req = qs_dict["SAMLRequest"][0]
            rstate = qs_dict["RelayState"][0]
        else:
            # Could be either POST or SOAP
            path = url
            try:
                qs_dict = parse_qs(kwargs["data"])
                req = qs_dict["SAMLRequest"][0]
                rstate = qs_dict["RelayState"][0]
            except KeyError:
                req = kwargs["data"]
                rstate = ""

        response = ""

        # Get service from path

        for key, vals in self.config.getattr("endpoints", "idp").items():
            for endp, binding in vals:
                if path == endp:
                    assert binding in TYP[method]
                    if key == "single_sign_on_service":
                        return self.authn_request_endpoint(req, binding,
                                                           rstate)
                    elif key == "single_logout_service":
                        return self.logout_endpoint(req, binding)

        for key, vals in self.config.getattr("endpoints", "aa").items():
            for endp, binding in vals:
                if path == endp:
                    assert binding in TYP[method]
                    if key == "attribute_service":
                        return self.attribute_query_endpoint(req, binding)

        return response

    def authn_request_endpoint(self, req, binding, relay_state):
        req = self.parse_authn_request(req, binding)
        if req.message.protocol_binding == BINDING_HTTP_REDIRECT:
            _binding = BINDING_HTTP_POST
        else:
            _binding = req.message.protocol_binding

        try:
            resp_args = self.response_args(req.message, [_binding])
        except Exception:
            raise

        identity = {"surName": "Hedberg", "givenName": "Roland",
                    "title": "supertramp", "mail": "roland@example.com"}
        userid = "Pavill"

        authn_resp = self.create_authn_response(identity,
                                                userid=userid,
                                                authn=AUTHN,
                                                **resp_args)

        response = "%s" % authn_resp

        _dict = pack.factory(_binding, response,
                             resp_args["destination"], relay_state,
                             "SAMLResponse")
        return DummyResponse(200, **_dict)

    def attribute_query_endpoint(self, xml_str, binding):
        if binding == BINDING_SOAP:
            _str = parse_soap_enveloped_saml_attribute_query(xml_str)
        else:
            _str = xml_str

        aquery = attribute_query_from_string(_str)
        extra = {"eduPersonAffiliation": "faculty"}
        #userid = "Pavill"

        name_id = aquery.subject.name_id
        attr_resp = self.create_attribute_response(extra, aquery.id,
                                                   None,
                                                   sp_entity_id=aquery.issuer
                                                   .text,
                                                   name_id=name_id,
                                                   attributes=aquery.attribute)

        if binding == BINDING_SOAP:
            # SOAP packing
            #headers = {"content-type": "application/soap+xml"}
            soap_message = make_soap_enveloped_saml_thingy(attr_resp)
            #            if self.sign and self.sec:
            #                _signed = self.sec.sign_statement_using_xmlsec(soap_message,
            #                                                               class_name(attr_resp),
            #                                                               nodeid=attr_resp.id)
            #                soap_message = _signed
            response = "%s" % soap_message
        else:  # Just POST
            response = "%s" % attr_resp

        return DummyResponse(200, response)

    def logout_endpoint(self, xml_str, binding):
        if binding == BINDING_SOAP:
            _str = parse_soap_enveloped_saml_logout_request(xml_str)
        else:
            _str = xml_str

        req = logout_request_from_string(_str)

        _resp = self.create_logout_response(req, [binding])

        if binding == BINDING_SOAP:
            # SOAP packing
            #headers = {"content-type": "application/soap+xml"}
            soap_message = make_soap_enveloped_saml_thingy(_resp)
            #            if self.sign and self.sec:
            #                _signed = self.sec.sign_statement_using_xmlsec(soap_message,
            #                                                               class_name(attr_resp),
            #                                                               nodeid=attr_resp.id)
            #                soap_message = _signed
            response = "%s" % soap_message
        else: # Just POST
            response = "%s" % _resp

        return DummyResponse(200, response)

########NEW FILE########
__FILENAME__ = idp_all_conf
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from saml2 import BINDING_SOAP, BINDING_URI
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_ARTIFACT
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAME_FORMAT_URI

from pathutils import full_path

BASE = "http://localhost:8088"

CONFIG = {
    "entityid": "urn:mace:example.com:saml:roland:idp",
    "name": "Rolands IdP",
    "service": {
        "aa": {
            "endpoints": {
                "attribute_service": [
                    ("%s/aap" % BASE, BINDING_HTTP_POST),
                    ("%s/aas" % BASE, BINDING_SOAP)
                ]
            },
        },
        "aq": {
            "endpoints": {
                "authn_query_service": [
                    ("%s/aqs" % BASE, BINDING_SOAP)
                ]
            },
        },
        "idp": {
            "endpoints": {
                "single_sign_on_service": [
                    ("%s/sso/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/sso/post" % BASE, BINDING_HTTP_POST),
                    ("%s/sso/art" % BASE, BINDING_HTTP_ARTIFACT),
                    ("%s/sso/paos" % BASE, BINDING_SOAP)
                ],
                "single_logout_service": [
                    ("%s/slo/soap" % BASE, BINDING_SOAP),
                    ("%s/slo/post" % BASE, BINDING_HTTP_POST)
                ],
                "artifact_resolution_service": [
                    ("%s/ars" % BASE, BINDING_SOAP)
                ],
                "assertion_id_request_service": [
                    ("%s/airs" % BASE, BINDING_URI)
                ],
                "authn_query_service": [
                    ("%s/aqs" % BASE, BINDING_SOAP)
                ],
                "manage_name_id_service": [
                    ("%s/mni/soap" % BASE, BINDING_SOAP),
                    ("%s/mni/post" % BASE, BINDING_HTTP_POST),
                    ("%s/mni/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/mni/art" % BASE, BINDING_HTTP_ARTIFACT)
                ],
                "name_id_mapping_service": [
                    ("%s/nim/soap" % BASE, BINDING_SOAP),
                    ("%s/nim/post" % BASE, BINDING_HTTP_POST),
                    ("%s/nim/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/nim/art" % BASE, BINDING_HTTP_ARTIFACT)
                ]
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes": 15},
                    "attribute_restrictions": None, # means all I have
                    "name_form": NAME_FORMAT_URI,
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "nameid_format": NAMEID_FORMAT_PERSISTENT,
                    # "attribute_restrictions":{
                    #     "givenName": None,
                    #     "surName": None,
                    # }
                }
            },
            #"subject_data": ("mongodb", "foo"),
            "scope": ["example.com"]
        },
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "xmlsec_path": ["/usr/local/bin", "/opt/local/bin"],
    "metadata": {
        "local": [full_path("servera.xml"),
                  full_path("vo_metadata.xml")],
    },
    "attribute_map_dir": full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel B", "se"), ("Example Co.", "en")],
        "url": "http://www.example.com/roland",
    },
    "contact_person": [
        {
            "given_name": "John",
            "sur_name": "Smith",
            "email_address": ["john.smith@example.com"],
            "contact_type": "technical",
        },
    ],
}

########NEW FILE########
__FILENAME__ = idp_conf
from saml2 import BINDING_SOAP
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAME_FORMAT_URI

from pathutils import full_path
from pathutils import xmlsec_path

BASE = "http://localhost:8088"

CONFIG = {
    "entityid": "urn:mace:example.com:saml:roland:idp",
    "name": "Rolands IdP",
    "service": {
        "idp": {
            "endpoints": {
                "single_sign_on_service": [
                    ("%s/sso" % BASE, BINDING_HTTP_REDIRECT)],
                "single_logout_service": [
                    ("%s/slo" % BASE, BINDING_SOAP),
                    ("%s/slop" % BASE, BINDING_HTTP_POST)]
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes": 15},
                    "attribute_restrictions": None,  # means all I have
                    "name_form": NAME_FORMAT_URI,
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "nameid_format": NAMEID_FORMAT_PERSISTENT,
                    # "attribute_restrictions":{
                    #     "givenName": None,
                    #     "surName": None,
                    # }
                }
            },
            "subject_data": full_path("subject_data.db"),
            #"domain": "umu.se",
            #"name_qualifier": ""
        },
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "xmlsec_binary": xmlsec_path,
    "metadata": {
        "local": [full_path("metadata_sp_1.xml"),
                  full_path("vo_metadata.xml")],
    },
    "attribute_map_dir": full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel AB", "se"), ("Example Co.", "en")],
        "url": "http://www.example.com/roland",
    },
    "contact_person": [
        {
            "given_name": "John",
            "sur_name": "Smith",
            "email_address": ["john.smith@example.com"],
            "contact_type": "technical",
        },
    ],
}

########NEW FILE########
__FILENAME__ = idp_conf_ec
from saml2.sigver import get_xmlsec_binary
from saml2 import BINDING_SOAP
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2.saml import NAME_FORMAT_URI

from pathutils import full_path

xmlsec_path = get_xmlsec_binary(["/opt/local/bin"])

BASE = "http://localhost:8088"

CONFIG = {
    "entityid": "urn:mace:example.com:saml:roland:idp",
    "name": "Rolands IdP",
    "service": {
        "idp": {
            "endpoints": {
                "single_sign_on_service": [
                    ("%s/sso" % BASE, BINDING_HTTP_REDIRECT)],
                "single_logout_service": [
                    ("%s/slo" % BASE, BINDING_SOAP),
                    ("%s/slop" % BASE, BINDING_HTTP_POST)]
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes": 15},
                    "entity_categories": ["swamid", "edugain"],
                    "name_form": NAME_FORMAT_URI,
                }
            },
            "subject_data": full_path("subject_data.db"),
            #"domain": "umu.se",
            #"name_qualifier": ""
        },
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "xmlsec_binary": xmlsec_path,
    "metadata": {
        "local": [full_path("metadata_sp_1.xml"),
                  full_path("vo_metadata.xml")],
    },
    "attribute_map_dir": full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel AB", "se"), ("Example Co.", "en")],
        "url": "http://www.example.com/roland",
    },
    "contact_person": [
        {
            "given_name": "John",
            "sur_name": "Smith",
            "email_address": ["john.smith@example.com"],
            "contact_type": "technical",
        },
    ],
}

########NEW FILE########
__FILENAME__ = idp_conf_mdb
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from saml2 import BINDING_SOAP, BINDING_URI
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_ARTIFACT
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAME_FORMAT_URI

from pathutils import full_path

BASE = "http://localhost:8088"

CONFIG = {
    "entityid": "%s/saml/idp" % BASE,
    "name": "Rolands IdP",
    "service": {
        "aa": {
            "endpoints": {
                "attribute_service": [
                    ("%s/aap" % BASE, BINDING_HTTP_POST),
                    ("%s/aas" % BASE, BINDING_SOAP)
                ]
            },
        },
        "aq": {
            "endpoints": {
                "authn_query_service": [
                    ("%s/aqs" % BASE, BINDING_SOAP)
                ]
            },
        },
        "idp": {
            "endpoints": {
                "single_sign_on_service": [
                    ("%s/sso/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/sso/post" % BASE, BINDING_HTTP_POST),
                    ("%s/sso/art" % BASE, BINDING_HTTP_ARTIFACT),
                    ("%s/sso/paos" % BASE, BINDING_SOAP)
                ],
                "single_logout_service": [
                    ("%s/slo/soap" % BASE, BINDING_SOAP),
                    ("%s/slo/post" % BASE, BINDING_HTTP_POST)
                ],
                "artifact_resolution_service": [
                    ("%s/ars" % BASE, BINDING_SOAP)
                ],
                "assertion_id_request_service": [
                    ("%s/airs" % BASE, BINDING_URI)
                ],
                "authn_query_service": [
                    ("%s/aqs" % BASE, BINDING_SOAP)
                ],
                "manage_name_id_service": [
                    ("%s/mni/soap" % BASE, BINDING_SOAP),
                    ("%s/mni/post" % BASE, BINDING_HTTP_POST),
                    ("%s/mni/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/mni/art" % BASE, BINDING_HTTP_ARTIFACT)
                ],
                "name_id_mapping_service": [
                    ("%s/nim/soap" % BASE, BINDING_SOAP),
                    ("%s/nim/post" % BASE, BINDING_HTTP_POST),
                    ("%s/nim/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/nim/art" % BASE, BINDING_HTTP_ARTIFACT)
                ]
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes": 15},
                    "attribute_restrictions": None,  # means all I have
                    "name_form": NAME_FORMAT_URI,
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "nameid_format": NAMEID_FORMAT_PERSISTENT,
                    # "attribute_restrictions":{
                    #     "givenName": None,
                    #     "surName": None,
                    # }
                }
            },
            "subject_data": ("mongodb", "subject"),
            "session_storage": ("mongodb", "session")
        },
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    #"xmlsec_binary": None,
    "xmlsec_path": ["/opt/local/bin", "usr/local/bin"],
    "metadata": {
        "local": [full_path("servera.xml"),
                  full_path("vo_metadata.xml")],
    },
    "attribute_map_dir": full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel B", "se"), ("Example Co.", "en")],
        "url": "http://www.example.com/roland",
    },
    "contact_person": [
        {
            "given_name":"John",
            "sur_name": "Smith",
            "email_address": ["john.smith@example.com"],
            "contact_type": "technical",
        },
    ],
}


########NEW FILE########
__FILENAME__ = idp_conf_mdb2
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from saml2 import BINDING_SOAP, BINDING_URI
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_ARTIFACT
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAME_FORMAT_URI

from pathutils import full_path

BASE = "http://localhost:8089"

CONFIG = {
    "entityid": "%s/saml/idp2" % BASE,
    "name": "Rolands 2nd IdP",
    "service": {
        "aa": {
            "endpoints": {
                "attribute_service": [
                    ("%s/aap" % BASE, BINDING_HTTP_POST),
                    ("%s/aas" % BASE, BINDING_SOAP)
                ]
            },
        },
        "aq": {
            "endpoints": {
                "authn_query_service": [
                    ("%s/aqs" % BASE, BINDING_SOAP)
                ]
            },
        },
        "idp": {
            "endpoints": {
                "single_sign_on_service": [
                    ("%s/sso/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/sso/post" % BASE, BINDING_HTTP_POST),
                    ("%s/sso/art" % BASE, BINDING_HTTP_ARTIFACT),
                    ("%s/sso/paos" % BASE, BINDING_SOAP)
                ],
                "single_logout_service": [
                    ("%s/slo/soap" % BASE, BINDING_SOAP),
                    ("%s/slo/post" % BASE, BINDING_HTTP_POST)
                ],
                "artifact_resolution_service": [
                    ("%s/ars" % BASE, BINDING_SOAP)
                ],
                "assertion_id_request_service": [
                    ("%s/airs" % BASE, BINDING_URI)
                ],
                "authn_query_service": [
                    ("%s/aqs" % BASE, BINDING_SOAP)
                ],
                "manage_name_id_service": [
                    ("%s/mni/soap" % BASE, BINDING_SOAP),
                    ("%s/mni/post" % BASE, BINDING_HTTP_POST),
                    ("%s/mni/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/mni/art" % BASE, BINDING_HTTP_ARTIFACT)
                ],
                "name_id_mapping_service": [
                    ("%s/nim/soap" % BASE, BINDING_SOAP),
                    ("%s/nim/post" % BASE, BINDING_HTTP_POST),
                    ("%s/nim/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/nim/art" % BASE, BINDING_HTTP_ARTIFACT)
                ]
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes": 15},
                    "attribute_restrictions": None,  # means all I have
                    "name_form": NAME_FORMAT_URI,
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "nameid_format": NAMEID_FORMAT_PERSISTENT,
                    # "attribute_restrictions":{
                    #     "givenName": None,
                    #     "surName": None,
                    # }
                }
            },
            "subject_data": ("mongodb", "subject"),
            "session_storage": ("mongodb", "session")
        },
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "xmlsec_binary": None,
    "metadata": {
        "local": [full_path("servera.xml"),
                  full_path("vo_metadata.xml")],
    },
    "attribute_map_dir": full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel B", "se"), ("Example Co.", "en")],
        "url": "http://www.example.com/roland",
    },
    "contact_person": [
        {
            "given_name":"John",
            "sur_name": "Smith",
            "email_address": ["john.smith@example.com"],
            "contact_type": "technical",
        },
    ],
}


########NEW FILE########
__FILENAME__ = idp_slo_redirect_conf
from saml2 import BINDING_HTTP_REDIRECT
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAME_FORMAT_URI

from pathutils import full_path

CONFIG = {
    "entityid" : "urn:mace:example.com:saml:roland:idp",
    "name" : "Rolands IdP",
    "service": {
        "idp": {
            "endpoints" : {
                "single_sign_on_service" : [
                        ("http://localhost:8088/sso", BINDING_HTTP_REDIRECT)],
                "single_logout_service": [
                        ("http://localhost:8088/slo", BINDING_HTTP_REDIRECT)]
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes":15},
                    "attribute_restrictions": None, # means all I have
                    "name_form": NAME_FORMAT_URI
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "nameid_format": NAMEID_FORMAT_PERSISTENT,
                }
            },
            "subject_data": full_path("subject_data.db"),
        }
    },
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    "xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("sp_slo_redirect.xml")],
    },
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel AB","se"),("Example Co.","en")],
        "url":"http://www.example.com/roland",
    },
    "contact_person": [{
        "given_name":"John",
        "sur_name": "Smith",
        "email_address": ["john.smith@example.com"],
        "contact_type": "technical",
        },
    ],
}

########NEW FILE########
__FILENAME__ = idp_soap_conf
from saml2 import BINDING_SOAP, BINDING_HTTP_REDIRECT
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAME_FORMAT_URI

from pathutils import full_path

CONFIG={
    "entityid" : "urn:mace:example.com:saml:roland:idp",
    "name" : "Rolands IdP",
    "service": {
        "idp": {
            "endpoints" : {
                "single_sign_on_service" : [
                        ("http://localhost:8088/sso", BINDING_HTTP_REDIRECT)],
                "single_logout_service": [
                        ("http://localhost:8088/slo", BINDING_SOAP)]
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes":15},
                    "attribute_restrictions": None, # means all I have
                    "name_form": NAME_FORMAT_URI,
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "nameid_format": NAMEID_FORMAT_PERSISTENT,
                    # "attribute_restrictions":{
                    #     "givenName": None,
                    #     "surName": None,
                    # }
                }
            },
            "subject_data": full_path("subject_data.db"),
        }
    },
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    #"xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("metadata.xml"), full_path("vo_metadata.xml")],
    },
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel AB","se"),("Example Co.","en")],
        "url":"http://www.example.com/roland",
    },
    "contact_person": [{
        "given_name":"John",
        "sur_name": "Smith",
        "email_address": ["john.smith@example.com"],
        "contact_type": "technical",
        },
    ],
}

########NEW FILE########
__FILENAME__ = idp_sp_conf
__author__ = 'rolandh'

from saml2 import BINDING_SOAP, BINDING_HTTP_REDIRECT, BINDING_HTTP_POST
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAME_FORMAT_URI

BASE = "http://localhost:8088/"

from pathutils import full_path

CONFIG = {
    "entityid" : "urn:mace:example.com:saml:roland:idp",
    "name" : "Rolands IdP",
    "service": {
        "idp": {
            "endpoints" : {
                "single_sign_on_service" : [
                        (BASE+"sso", BINDING_HTTP_REDIRECT)],
                "single_logout_service": [
                        (BASE+"slo", BINDING_SOAP),
                        (BASE+"slop",BINDING_HTTP_POST)]
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes":15},
                    "attribute_restrictions": None, # means all I have
                    "name_form": NAME_FORMAT_URI,
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "nameid_format": NAMEID_FORMAT_PERSISTENT,
                    # "attribute_restrictions":{
                    #     "givenName": None,
                    #     "surName": None,
                    # }
                }
            },
            "subject_data": full_path("subject_data.db"),
        },
        "sp": {
            "endpoints":{
                "assertion_consumer_service": [(BASE, BINDING_HTTP_REDIRECT)
                ],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
        }
    },
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    "xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("metadata.xml"), full_path("vo_metadata.xml")],
    },
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel AB","se"),("Example Co.","en")],
        "url":"http://www.example.com/roland",
    },
    "contact_person": [{
        "given_name":"John",
        "sur_name": "Smith",
        "email_address": ["john.smith@example.com"],
        "contact_type": "technical",
        },
    ],
}

########NEW FILE########
__FILENAME__ = md_data
#!/usr/bin/env python
#
# Copyright (C) 2007 SIOS Technology, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Test data for md"""

__author__ = 'tmatsuo@example.com (Takashi MATSUO)'

TEST_ENDPOINT = """<?xml version="1.0" encoding="utf-8"?>
<EndpointType xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""

TEST_SINGLE_LOGOUT_SERVICE = """<?xml version="1.0" encoding="utf-8"?>
<SingleLogoutService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""


TEST_MANAGE_NAMEID_SERVICE = """<?xml version="1.0" encoding="utf-8"?>
<ManageNameIDService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""


TEST_SINGLE_SIGN_ON_SERVICE = """<?xml version="1.0" encoding="utf-8"?>
<SingleSignOnService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""


TEST_NAME_ID_MAPPING_SERVICE = """<?xml version="1.0" encoding="utf-8"?>
<NameIDMappingService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""


TEST_ASSERTION_ID_REQUEST_SERVICE = """<?xml version="1.0" encoding="utf-8"?>
<AssertionIDRequestService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""


TEST_INDEXED_ENDPOINT = """<?xml version="1.0" encoding="utf-8"?>
<IndexedEndpointType xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  index="1"
  isDefault="false"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""

TEST_ARTIFACT_RESOLUTION_SERVICE = """<?xml version="1.0" encoding="utf-8"?>
<ArtifactResolutionService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  index="1"
  isDefault="false"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""

TEST_ASSERTION_CONSUMER_SERVICE = """<?xml version="1.0" encoding="utf-8"?>
<AssertionConsumerService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  index="1"
  isDefault="false"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
"""

TEST_NAME_ID_FORMAT = """<?xml version="1.0" encoding="utf-8"?>
<NameIDFormat xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress
</NameIDFormat>
"""

TEST_ATTRIBUTE_PROFILE = """<?xml version="1.0" encoding="utf-8"?>
<AttributeProfile xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  urn:oasis:names:tc:SAML:2.0:profiles:attribute:basic
</AttributeProfile>
"""

TEST_ORGANIZATION_NAME = """<?xml version="1.0" encoding="utf-8"?>
<OrganizationName xmlns="urn:oasis:names:tc:SAML:2.0:metadata" 
    xml:lang="se">
  Catalogix
</OrganizationName>
"""

TEST_ORGANIZATION_DISPLAY_NAME = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:OrganizationDisplayName xml:lang="se" xmlns:ns0="urn:oasis:names:tc:SAML:2.0:metadata">
Catalogix
</ns0:OrganizationDisplayName>
"""

TEST_ORGANIZATION_URL = """<?xml version="1.0" encoding="utf-8"?>
<OrganizationURL xmlns="urn:oasis:names:tc:SAML:2.0:metadata" 
    xml:lang="no">
  http://www.example.com/
</OrganizationURL>
"""

TEST_ORGANIZATION = """<?xml version="1.0" encoding="utf-8"?>
<Organization xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <OrganizationName 
    xml:lang="se">
    Catalogix AB
  </OrganizationName>
  <OrganizationDisplayName xml:lang="no">
    Catalogix AS
  </OrganizationDisplayName>
  <OrganizationURL 
    xml:lang="en">
    http://www.example.com/
  </OrganizationURL>
</Organization>
"""

TEST_CONTACT_PERSON = """<?xml version="1.0" encoding="utf-8"?>
<ContactPerson xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  contactType="technical">
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <Company>SIOS Technology, Inc.</Company>
  <GivenName>Takashi</GivenName>
  <SurName>Matsuo</SurName>
  <EmailAddress>tmatsuo@example.com</EmailAddress>
  <EmailAddress>tmatsuo@shehas.net</EmailAddress>
  <TelephoneNumber>00-0000-0000</TelephoneNumber>
</ContactPerson>
"""

TEST_ADDITIONAL_METADATA_LOCATION = """<?xml version="1.0" encoding="utf-8"?>
<AdditionalMetadataLocation xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  namespace="http://www.example.com/namespace">
  http://www.example.com/AdditionalMetadataLocation
</AdditionalMetadataLocation>
"""

TEST_KEY_SIZE = """<?xml version="1.0" encoding="utf-8"?>
<KeySize xmlns="http://www.w3.org/2001/04/xmlenc#">128</KeySize>
"""

TEST_OAEP_PARAMS = """<?xml version="1.0" encoding="utf-8"?>
<OAEPparams xmlns="http://www.w3.org/2001/04/xmlenc#">
  9lWu3Q==
</OAEPparams>
"""

TEST_ENCRYPTION_METHOD = """<?xml version="1.0" encoding="utf-8"?>
<EncryptionMethod
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p">
  <OAEPparams xmlns="http://www.w3.org/2001/04/xmlenc#">
    9lWu3Q==
  </OAEPparams>
  <DigestMethod
    Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"
    xmlns="http://www.w3.org/2000/09/xmldsig#"/>
</EncryptionMethod>
"""

TEST_KEY_DESCRIPTOR = """<?xml version="1.0" encoding="utf-8"?>
<KeyDescriptor
  use="signing"
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <EncryptionMethod
    xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
    Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p">
    <OAEPparams xmlns="http://www.w3.org/2001/04/xmlenc#">
      9lWu3Q==
    </OAEPparams>
    <DigestMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"
      xmlns="http://www.w3.org/2000/09/xmldsig#"/>
  </EncryptionMethod>
</KeyDescriptor>
"""


TEST_ROLE_DESCRIPTOR = """<?xml version="1.0" encoding="utf-8"?>
<RoleDescriptor
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  ID="ID"
  validUntil="2008-09-14T01:05:02Z"
  cacheDuration="10:00:00:00"
  protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"
  errorURL="http://www.example.com/errorURL">
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <SignedInfo Id="id">
    <CanonicalizationMethod
      Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
    </CanonicalizationMethod>
    <SignatureMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
      <HMACOutputLength>8</HMACOutputLength>
    </SignatureMethod>
    <Reference Id="id" URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
      <DigestValue>digest value</DigestValue>
    </Reference>
  </SignedInfo>
  <SignatureValue Id="id">
    signature value
  </SignatureValue>
  <KeyInfo Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
    V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
  </Object>
</Signature>
<Extensions>
  <foo xmlns="http://www.example.com/someNameSpace">bar</foo>
</Extensions>
<KeyDescriptor
  use="signing"
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <EncryptionMethod
    xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
    Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p">
    <OAEPparams xmlns="http://www.w3.org/2001/04/xmlenc#">
      9lWu3Q==
    </OAEPparams>
    <DigestMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"
      xmlns="http://www.w3.org/2000/09/xmldsig#"/>
  </EncryptionMethod>
</KeyDescriptor>
<Organization>
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <OrganizationName xml:lang="en">
    SIOS Technology, Inc.
  </OrganizationName>
  <OrganizationDisplayName xml:lang="en">
    SIOS
  </OrganizationDisplayName>
  <OrganizationURL xml:lang="ja">
    http://www.example.com/
  </OrganizationURL>
</Organization>
<ContactPerson contactType="technical">
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <Company>SIOS Technology, Inc.</Company>
  <GivenName>Takashi</GivenName>
  <SurName>Matsuo</SurName>
  <EmailAddress>tmatsuo@example.com</EmailAddress>
  <EmailAddress>tmatsuo@shehas.net</EmailAddress>
  <TelephoneNumber>00-0000-0000</TelephoneNumber>
</ContactPerson>
</RoleDescriptor>
"""


TEST_SSO_DESCRIPTOR = """<?xml version="1.0" encoding="utf-8"?>
<SSODescriptorType
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  ID="ID"
  validUntil="2008-09-14T01:05:02Z"
  cacheDuration="10:00:00:00"
  protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"
  errorURL="http://www.example.com/errorURL">
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <SignedInfo Id="id">
    <CanonicalizationMethod
      Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
    </CanonicalizationMethod>
    <SignatureMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
      <HMACOutputLength>8</HMACOutputLength>
    </SignatureMethod>
    <Reference Id="id" URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
      <DigestValue>digest value</DigestValue>
    </Reference>
  </SignedInfo>
  <SignatureValue Id="id">
    signature value
  </SignatureValue>
  <KeyInfo Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
    V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
  </Object>
</Signature>
<Extensions>
  <foo xmlns="http://www.example.com/someNameSpace">bar</foo>
</Extensions>
<KeyDescriptor
  use="signing"
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <EncryptionMethod
    xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
    Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p">
    <OAEPparams xmlns="http://www.w3.org/2001/04/xmlenc#">
      9lWu3Q==
    </OAEPparams>
    <DigestMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"
      xmlns="http://www.w3.org/2000/09/xmldsig#"/>
  </EncryptionMethod>
</KeyDescriptor>
<Organization>
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <OrganizationName xml:lang="en">
    SIOS Technology, Inc.
  </OrganizationName>
  <OrganizationDisplayName xml:lang="en">
    SIOS
  </OrganizationDisplayName>
  <OrganizationURL xml:lang="ja">
    http://www.example.com/
  </OrganizationURL>
</Organization>
<ContactPerson contactType="technical">
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <Company>SIOS Technology, Inc.</Company>
  <GivenName>Takashi</GivenName>
  <SurName>Matsuo</SurName>
  <EmailAddress>tmatsuo@example.com</EmailAddress>
  <EmailAddress>tmatsuo@shehas.net</EmailAddress>
  <TelephoneNumber>00-0000-0000</TelephoneNumber>
</ContactPerson>
<ArtifactResolutionService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  index="1"
  isDefault="false"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<SingleLogoutService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<ManageNameIDService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<NameIDFormat xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress
</NameIDFormat>
</SSODescriptorType>
"""


TEST_IDP_SSO_DESCRIPTOR = """<?xml version="1.0" encoding="utf-8"?>
<IDPSSODescriptor
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  ID="ID"
  validUntil="2008-09-14T01:05:02Z"
  cacheDuration="10:00:00:00"
  protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"
  errorURL="http://www.example.com/errorURL"
  WantAuthnRequestsSigned="true">
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <SignedInfo Id="id">
    <CanonicalizationMethod
      Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
    </CanonicalizationMethod>
    <SignatureMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
      <HMACOutputLength>8</HMACOutputLength>
    </SignatureMethod>
    <Reference Id="id" URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
      <DigestValue>digest value</DigestValue>
    </Reference>
  </SignedInfo>
  <SignatureValue Id="id">
    signature value
  </SignatureValue>
  <KeyInfo Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
    V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
  </Object>
</Signature>
<Extensions>
  <foo xmlns="http://www.example.com/someNameSpace">bar</foo>
</Extensions>
<KeyDescriptor
  use="signing"
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <EncryptionMethod
    xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
    Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p">
    <OAEPparams xmlns="http://www.w3.org/2001/04/xmlenc#">
      9lWu3Q==
    </OAEPparams>
    <DigestMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"
      xmlns="http://www.w3.org/2000/09/xmldsig#"/>
  </EncryptionMethod>
</KeyDescriptor>
<Organization>
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <OrganizationName xml:lang="en">
    SIOS Technology, Inc.
  </OrganizationName>
  <OrganizationDisplayName xml:lang="en">
    SIOS
  </OrganizationDisplayName>
  <OrganizationURL xml:lang="ja">
    http://www.example.com/
  </OrganizationURL>
</Organization>
<ContactPerson contactType="technical">
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <Company>SIOS Technology, Inc.</Company>
  <GivenName>Takashi</GivenName>
  <SurName>Matsuo</SurName>
  <EmailAddress>tmatsuo@example.com</EmailAddress>
  <EmailAddress>tmatsuo@shehas.net</EmailAddress>
  <TelephoneNumber>00-0000-0000</TelephoneNumber>
</ContactPerson>
<ArtifactResolutionService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  index="1"
  isDefault="false"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<SingleLogoutService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<ManageNameIDService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<NameIDFormat xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress
</NameIDFormat>
<SingleSignOnService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<NameIDMappingService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<AssertionIDRequestService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<AttributeProfile xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  urn:oasis:names:tc:SAML:2.0:profiles:attribute:basic
</AttributeProfile>
<Attribute Name="testAttribute"
  NameFormat="urn:oasis:names:tc:SAML:2.0:attrnam-format:unspecified"
  FriendlyName="test attribute"
  xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  <AttributeValue >value1 of test attribute</AttributeValue>
  <AttributeValue >value2 of test attribute</AttributeValue>
</Attribute>
</IDPSSODescriptor>
"""

TEST_REQUESTED_ATTRIBUTE = """<?xml version="1.0" encoding="utf-8"?>
<RequestedAttribute Name="testAttribute"
  NameFormat="urn:oasis:names:tc:SAML:2.0:attrnam-format:unspecified"
  FriendlyName="test attribute"
  isRequired="true"
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  <AttributeValue xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    value1 of test attribute
  </AttributeValue>
  <AttributeValue xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    value2 of test attribute
  </AttributeValue>
</RequestedAttribute>
"""

TEST_SERVICE_NAME = """<?xml version="1.0" encoding="utf-8"?>
<ServiceName xmlns="urn:oasis:names:tc:SAML:2.0:metadata" 
    xml:lang="en">
  Catalogix Whois
</ServiceName>
"""

TEST_SERVICE_DESCRIPTION = """<?xml version="1.0" encoding="utf-8"?>
<ServiceDescription xmlns="urn:oasis:names:tc:SAML:2.0:metadata" 
    xml:lang="en">
Catalogix Whois Service
</ServiceDescription>
"""

TEST_ATTRIBUTE_CONSUMING_SERVICE = """<?xml version="1.0" encoding="utf-8"?>
<AttributeConsumingService
  index="1"
  isDefault="true"
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
<ServiceName xml:lang="en">SIOS mail</ServiceName>
<ServiceDescription  xml:lang="en">SIOS mail service</ServiceDescription>
<RequestedAttribute Name="testAttribute"
  NameFormat="urn:oasis:names:tc:SAML:2.0:attrnam-format:unspecified"
  FriendlyName="test attribute"
  isRequired="true">
  <AttributeValue xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    value1 of test attribute
  </AttributeValue>
  <AttributeValue xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    value2 of test attribute
  </AttributeValue>
</RequestedAttribute>
</AttributeConsumingService>
"""


TEST_SP_SSO_DESCRIPTOR = """<?xml version="1.0" encoding="utf-8"?>
<SPSSODescriptor
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  ID="ID"
  validUntil="2008-09-14T01:05:02Z"
  cacheDuration="10:00:00:00"
  protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol"
  errorURL="http://www.example.com/errorURL"
  AuthnRequestsSigned="true"
  WantAssertionsSigned="true">
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <SignedInfo Id="id">
    <CanonicalizationMethod
      Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
    </CanonicalizationMethod>
    <SignatureMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
      <HMACOutputLength>8</HMACOutputLength>
    </SignatureMethod>
    <Reference Id="id" URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
      <DigestValue>digest value</DigestValue>
    </Reference>
  </SignedInfo>
  <SignatureValue Id="id">
    signature value
  </SignatureValue>
  <KeyInfo Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
    V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
  </Object>
</Signature>
<Extensions>
  <idpdisc:DiscoveryResponse 
    xmlns:idpdisc="urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol"
    index="1"
    Binding="urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol"
    Location="http://geneva.rutgers.edu/Shibboleth.sso/DS"/>
  <idpdisc:DiscoveryResponse 
    xmlns:idpdisc="urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol"
    index="2" 
    Binding="urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol"
    Location="https://geneva.rutgers.edu/Shibboleth.sso/DS"/>
</Extensions>
<KeyDescriptor
  use="signing"
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  <KeyInfo xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <EncryptionMethod
    xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
    Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p">
    <OAEPparams xmlns="http://www.w3.org/2001/04/xmlenc#">
      9lWu3Q==
    </OAEPparams>
    <DigestMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"
      xmlns="http://www.w3.org/2000/09/xmldsig#"/>
  </EncryptionMethod>
</KeyDescriptor>
<Organization>
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <OrganizationName xml:lang="en">
    SIOS Technology, Inc.
  </OrganizationName>
  <OrganizationDisplayName xml:lang="en">
    SIOS
  </OrganizationDisplayName>
  <OrganizationURL xml:lang="ja">
    http://www.example.com/
  </OrganizationURL>
</Organization>
<ContactPerson contactType="technical">
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <Company>SIOS Technology, Inc.</Company>
  <GivenName>Takashi</GivenName>
  <SurName>Matsuo</SurName>
  <EmailAddress>tmatsuo@example.com</EmailAddress>
  <EmailAddress>tmatsuo@shehas.net</EmailAddress>
  <TelephoneNumber>00-0000-0000</TelephoneNumber>
</ContactPerson>
<ArtifactResolutionService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  index="1"
  isDefault="false"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<SingleLogoutService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<ManageNameIDService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<NameIDFormat xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
  urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress
</NameIDFormat>
<AssertionConsumerService xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  index="1"
  isDefault="false"
  Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  Location="http://www.example.com/endpoint"
  ResponseLocation = "http://www.example.com/response"
/>
<AttributeConsumingService
  index="1"
  isDefault="true"
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata">
<ServiceName xml:lang="en">SIOS mail</ServiceName>
<ServiceDescription  xml:lang="en">SIOS mail service</ServiceDescription>
<RequestedAttribute Name="testAttribute"
  NameFormat="urn:oasis:names:tc:SAML:2.0:attrnam-format:unspecified"
  FriendlyName="test attribute"
  isRequired="true">
  <AttributeValue xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    value1 of test attribute
  </AttributeValue>
  <AttributeValue xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    value2 of test attribute
  </AttributeValue>
</RequestedAttribute>
</AttributeConsumingService>
</SPSSODescriptor>
"""

TEST_ENTITY_DESCRIPTOR = """<?xml version="1.0" encoding="utf-8"?>
<EntityDescriptor
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  entityID="entityID"
  ID="ID"
  validUntil="2008-09-14T01:05:02Z"
  cacheDuration="10:00:00:00">
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <SignedInfo Id="id">
    <CanonicalizationMethod
      Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
    </CanonicalizationMethod>
    <SignatureMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
      <HMACOutputLength>8</HMACOutputLength>
    </SignatureMethod>
    <Reference Id="id" URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
      <DigestValue>digest value</DigestValue>
    </Reference>
  </SignedInfo>
  <SignatureValue Id="id">
    signature value
  </SignatureValue>
  <KeyInfo Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
    V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
  </Object>
</Signature>
<Extensions>
  <foo xmlns="http://www.example.com/someNameSpace">bar</foo>
</Extensions>
<RoleDescriptor/>
<IDPSSODescriptor/>
<SPSSODescriptor/>
<Organization>
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <OrganizationName xml:lang="en">
    SIOS Technology, Inc.
  </OrganizationName>
  <OrganizationDisplayName xml:lang="en">
    SIOS
  </OrganizationDisplayName>
  <OrganizationURL xml:lang="ja">
    http://www.example.com/
  </OrganizationURL>
</Organization>
<ContactPerson contactType="technical">
  <Extensions>
    <hoge xmlns="http://hoge.example.com/">hogehoge</hoge>
  </Extensions>
  <Company>SIOS Technology, Inc.</Company>
  <GivenName>Takashi</GivenName>
  <SurName>Matsuo</SurName>
  <EmailAddress>tmatsuo@example.com</EmailAddress>
  <EmailAddress>tmatsuo@shehas.net</EmailAddress>
  <TelephoneNumber>00-0000-0000</TelephoneNumber>
</ContactPerson>
<AdditionalMetadataLocation xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  namespace="http://www.example.com/namespace">
  http://www.example.com/AdditionalMetadataLocation
</AdditionalMetadataLocation>
</EntityDescriptor>
"""

TEST_ENTITIES_DESCRIPTOR = """<?xml version="1.0" encoding="utf-8"?>
<EntitiesDescriptor
  xmlns="urn:oasis:names:tc:SAML:2.0:metadata"
  Name="name"
  ID="ID"
  validUntil="2008-09-14T01:05:02Z"
  cacheDuration="10:00:00:00">
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
  <SignedInfo Id="id">
    <CanonicalizationMethod
      Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
    </CanonicalizationMethod>
    <SignatureMethod
      Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
      <HMACOutputLength>8</HMACOutputLength>
    </SignatureMethod>
    <Reference Id="id" URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
      <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
      <DigestValue>digest value</DigestValue>
    </Reference>
  </SignedInfo>
  <SignatureValue Id="id">
    signature value
  </SignatureValue>
  <KeyInfo Id="id">
    <KeyName>
      key name
    </KeyName>
    <KeyValue>
      <DSAKeyValue>
        <P>p</P>
        <Q>q</Q>
        <G>g</G>
        <Y>y</Y>
        <J>j</J>
        <Seed>seed</Seed>
        <PgenCounter>pgen counter</PgenCounter>
      </DSAKeyValue>
    </KeyValue>
    <RetrievalMethod URI="http://www.example.com/URI"
      Type="http://www.example.com/Type">
      <Transforms>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
        <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
          <XPath>xpath</XPath>
        </Transform>
      </Transforms>
    </RetrievalMethod>
    <X509Data>
      <X509IssuerSerial>
        <X509IssuerName>issuer name</X509IssuerName>
        <X509IssuerNumber>1</X509IssuerNumber>
      </X509IssuerSerial>
      <X509SKI>x509 ski</X509SKI>
      <X509SubjectName>x509 subject name</X509SubjectName>
      <X509Certificate>x509 certificate</X509Certificate>
      <X509CRL>x509 crl</X509CRL>
    </X509Data>
    <PGPData>
      <PGPKeyID>pgp key id</PGPKeyID>
      <PGPKeyPacket>pgp key packet</PGPKeyPacket>
    </PGPData>
    <MgmtData>
      mgmt data
    </MgmtData>
    <SPKIData>
      <SPKISexp>spki sexp</SPKISexp>
      <SPKISexp>spki sexp2</SPKISexp>
    </SPKIData>  
  </KeyInfo>
  <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
    V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
  </Object>
</Signature>
<Extensions>
  <foo xmlns="http://www.example.com/someNameSpace">bar</foo>
</Extensions>
<EntityDescriptor/>
<EntitiesDescriptor/>
</EntitiesDescriptor>
"""

########NEW FILE########
__FILENAME__ = otest_61_makemeta
import saml2
from saml2 import mdstore
from saml2 import md
from saml2 import BINDING_HTTP_POST
from saml2 import extension_elements_to_elements

from saml2.extension import shibmd
from saml2.extension import mdui
from saml2.extension import idpdisc

from saml2.attribute_converter import ac_factory
from saml2.saml import NAME_FORMAT_URI
from saml2.config import SPConfig, IdPConfig

def _eq(l1,l2):
    return set(l1) == set(l2)

SP = {
    "name" : "Rolands SP",
    "description": "One of the best SPs in business",
    "service": {
        "sp": {
            "endpoints": {
                "single_logout_service" : ["http://localhost:8087/logout"],
                "assertion_consumer_service" : [{"location":"http://localhost:8087/",
                                                "binding":BINDING_HTTP_POST},]
            },
            "required_attributes": ["sn", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp": {
                "" : "https://example.com/saml2/idp/SSOService.php",
            },
        }
    },
    "metadata": {
        "local": ["foo.xml"],
    },
    "attribute_map_dir" : "attributemaps",
}

IDP = {
    "name" : "Rolands IdP",
    "service": {
        "idp": {
            "endpoints": {
                "single_sign_on_service" : ["http://localhost:8088/sso"],
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes":15},
                    "attribute_restrictions": None, # means all I have
                    "name_form": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "nameid_format": "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent",
                }
            },
            "scope": ["example.org"],
            "ui_info": {
                "privacy_statement_url":
                            "http://example.com/saml2/privacyStatement.html",
                "information_url": "http://example.com/saml2/info.html",
                "logo": {
                    "height": "40",
                    "width" : "30",
                    "text": "http://example.com/logo.jpg"
                },
                "display_name": "Example Co.",
                "description" : {"text":"Exempel bolag","lang":"se"},
                "keywords": {"lang":"en", "text":["foo", "bar"]}
            },
        }
    },
    "metadata": {
        "local": ["bar.xml"],
    },
}

def test_org_1():
    desc = {
        "name": [("Example Company","en"), ("Exempel AB","se"), "Example",],
        "display_name": ["Example AS", ("Voorbeeld AZ", "")],
        "url": [("http://example.com","en")],
    }
    org = metadata.do_organization_info(desc)
    print org
    assert isinstance(org, md.Organization)
    print org.keyswv()
    assert _eq(org.keyswv(), ['organization_name',
                'organization_display_name','organization_url'])
    assert len(org.organization_name) == 3
    assert len(org.organization_display_name) == 2
    assert len(org.organization_url) == 1

def test_org_2():
    desc = {
        "name": [("Example Company","en"), ("Exempel AB","se"), "Example",],
        "display_name": "Example AS",
        "url": ("http://example.com","en"),
    }
    org = metadata.do_organization_info(desc)
    print org
    assert _eq(org.keyswv(), ['organization_name',
                'organization_display_name','organization_url'])
    assert len(org.organization_name) == 3
    assert len(org.organization_display_name) == 1
    assert org.organization_display_name[0].text == 'Example AS'
    assert len(org.organization_url) == 1
    assert isinstance(org.organization_url[0], md.OrganizationURL)
    assert org.organization_url[0].lang == "en"
    assert org.organization_url[0].text == 'http://example.com'

def test_org_3():
    desc = { "display_name": ["Rolands SAML"] }
    org = metadata.do_organization_info(desc)
    assert _eq(org.keyswv(), ['organization_display_name'])
    assert len(org.organization_display_name) == 1
                                                
def test_contact_0():
    conf = [{
        "given_name":"Roland",
        "sur_name": "Hedberg",
        "telephone_number": "+46 70 100 00 00",
        "email_address": ["foo@eample.com", "foo@example.org"],
        "contact_type": "technical"
        }]
    contact_person = metadata.do_contact_person_info(conf)
    assert _eq(contact_person[0].keyswv(), ['given_name', 'sur_name', 
                                            'contact_type', 'telephone_number',
                                            "email_address"])
    print contact_person[0]
    person = contact_person[0]
    assert person.contact_type == "technical"
    assert isinstance(person.given_name, md.GivenName)
    assert person.given_name.text == "Roland"
    assert isinstance(person.sur_name, md.SurName)
    assert person.sur_name.text == "Hedberg"
    assert isinstance(person.telephone_number[0], md.TelephoneNumber)
    assert person.telephone_number[0].text == "+46 70 100 00 00"
    assert len(person.email_address) == 2
    assert isinstance(person.email_address[0], md.EmailAddress)
    assert person.email_address[0].text == "foo@eample.com"
    
def test_do_endpoints():
    eps = metadata.do_endpoints(SP["service"]["sp"]["endpoints"],
                                    metadata.ENDPOINTS["sp"])
    print eps
    assert _eq(eps.keys(), ["assertion_consumer_service", 
                            "single_logout_service"])
                            
    assert len(eps["single_logout_service"]) == 1
    sls = eps["single_logout_service"][0]
    assert sls.location == "http://localhost:8087/logout"
    assert sls.binding == BINDING_HTTP_POST
    
    assert len(eps["assertion_consumer_service"]) == 1
    acs = eps["assertion_consumer_service"][0]
    assert acs.location == "http://localhost:8087/"
    assert acs.binding == BINDING_HTTP_POST
    
    assert "artifact_resolution_service" not in eps
    assert "manage_name_id_service" not in eps
    
def test_required_attributes():
    attrconverters = ac_factory("../tests/attributemaps")
    ras = metadata.do_requested_attribute(
                                SP["service"]["sp"]["required_attributes"],
                                attrconverters, is_required="true")
    assert len(ras) == len(SP["service"]["sp"]["required_attributes"])
    print ras[0]
    assert ras[0].name == 'urn:oid:2.5.4.4'
    assert ras[0].name_format == NAME_FORMAT_URI
    assert ras[0].is_required == "true"

def test_optional_attributes():
    attrconverters = ac_factory("../tests/attributemaps")
    ras = metadata.do_requested_attribute(
                                SP["service"]["sp"]["optional_attributes"],
                                attrconverters)
    assert len(ras) == len(SP["service"]["sp"]["optional_attributes"])
    print ras[0]
    assert ras[0].name == 'urn:oid:2.5.4.12'
    assert ras[0].name_format == NAME_FORMAT_URI
    assert ras[0].is_required == "false"
    
def test_do_sp_sso_descriptor():
    conf = SPConfig().load(SP, metadata_construction=True)
    spsso = metadata.do_spsso_descriptor(conf)
    
    assert isinstance(spsso, md.SPSSODescriptor)
    assert _eq(spsso.keyswv(), ['authn_requests_signed', 
                                'attribute_consuming_service', 
                                'single_logout_service', 
                                'protocol_support_enumeration', 
                                'assertion_consumer_service', 
                                'want_assertions_signed'])
                                
    assert spsso.authn_requests_signed == "false"
    assert spsso.want_assertions_signed == "true"
    assert len (spsso.attribute_consuming_service) == 1
    acs = spsso.attribute_consuming_service[0]
    print acs.keyswv()
    assert _eq(acs.keyswv(), ['requested_attribute', 'service_name',
                                 'service_description', 'index'])
    assert acs.service_name[0].text == SP["name"]
    assert acs.service_description[0].text == SP["description"]
    assert len(acs.requested_attribute) == 4
    assert acs.requested_attribute[0].friendly_name == "sn"
    assert acs.requested_attribute[0].name == 'urn:oid:2.5.4.4'
    assert acs.requested_attribute[0].name_format == NAME_FORMAT_URI
    assert acs.requested_attribute[0].is_required == "true"

def test_do_sp_sso_descriptor_2():
    SP["service"]["sp"]["discovery_response"] = "http://example.com/sp/ds"
    
    conf = SPConfig().load(SP, metadata_construction=True)
    spsso = metadata.do_spsso_descriptor(conf)

    assert isinstance(spsso, md.SPSSODescriptor)
    print spsso.keyswv()
    assert _eq(spsso.keyswv(), ['authn_requests_signed',
                                'attribute_consuming_service',
                                'single_logout_service',
                                'protocol_support_enumeration',
                                'assertion_consumer_service',
                                'want_assertions_signed',
                                'extensions'])

    exts = spsso.extensions.extension_elements
    assert len(exts) == 1
    print exts
    idpd = saml2.extension_element_to_element(exts[0],
                                              idpdisc.ELEMENT_FROM_STRING,
                                              namespace=idpdisc.NAMESPACE)
    print idpd
    assert idpd.location == "http://example.com/sp/ds"
    assert idpd.index == "0"
    assert idpd.binding == "urn:oasis:names:tc:SAML:profiles:SSO:idp-discovery-protocol"

def test_entity_description():
    #confd = eval(open("../tests/server.config").read())
    confd = SPConfig().load_file("server_conf")
    print confd.attribute_converters
    entd = metadata.entity_descriptor(confd)
    assert entd is not None
    print entd.keyswv()
    assert _eq(entd.keyswv(), ['valid_until', 'entity_id', 'contact_person',
                                'spsso_descriptor', 'organization'])
    print entd
    assert entd.entity_id == "urn:mace:example.com:saml:roland:sp"

def test_do_idp_sso_descriptor():
    conf = IdPConfig().load(IDP, metadata_construction=True)
    idpsso = metadata.do_idpsso_descriptor(conf)

    assert isinstance(idpsso, md.IDPSSODescriptor)
    assert _eq(idpsso.keyswv(), ['protocol_support_enumeration', 
                                'single_sign_on_service', 
                                'want_authn_requests_signed',
                                "extensions"])
    exts = idpsso.extensions.extension_elements
    assert len(exts) == 2
    print exts
    inst = saml2.extension_element_to_element(exts[0],
                                              shibmd.ELEMENT_FROM_STRING,
                                              namespace=shibmd.NAMESPACE)
    assert isinstance(inst, shibmd.Scope)
    assert inst.text == "example.org"
    assert inst.regexp == "false"

    uiinfo = saml2.extension_element_to_element(exts[1],
                                              mdui.ELEMENT_FROM_STRING,
                                              namespace=mdui.NAMESPACE)

    assert uiinfo
    assert _eq(uiinfo.keyswv(), ['display_name', 'description',
                                 'information_url', 'privacy_statement_url',
                                 'keywords', 'logo'])

    assert len(uiinfo.privacy_statement_url) == 1
    assert uiinfo.privacy_statement_url[0].text == "http://example.com/saml2/privacyStatement.html"
    assert len(uiinfo.description) == 1
    assert uiinfo.description[0].text == "Exempel bolag"
    assert uiinfo.description[0].lang == "se"

    res = extension_elements_to_elements(exts,[shibmd, mdui])

    assert len(res) == 2
    # one is a shibmd.Scope instance and the other a mdui.UIInfo instance
    if isinstance(res[0], shibmd.Scope):
        assert isinstance(res[1], mdui.UIInfo)
    elif isinstance(res[1], shibmd.Scope):
        assert isinstance(res[0], mdui.UIInfo)

    found = idpsso.extensions.find_extensions(mdui.UIInfo.c_tag,
                                              mdui.NAMESPACE)
    assert len(found) == 1

    elem = idpsso.extensions.extensions_as_elements(mdui.UIInfo.c_tag, mdui)
    assert len(elem) == 1
    assert isinstance(elem[0], mdui.UIInfo)


########NEW FILE########
__FILENAME__ = pathutils
import os.path

BASEDIR = os.path.abspath(os.path.dirname(__file__))


def full_path(local_file):
    return os.path.join(BASEDIR, local_file)


def dotname(module):
    if not BASEDIR.endswith('tests'):
        return 'tests.' + module
    else:
        return module

try:
    from saml2.sigver import get_xmlsec_binary
except ImportError:
    get_xmlsec_binary = None

if get_xmlsec_binary:
    xmlsec_path = get_xmlsec_binary(["/opt/local/bin"])
else:
    xmlsec_path = '/usr/bin/xmlsec1'

########NEW FILE########
__FILENAME__ = restrictive_idp_conf
from saml2 import BINDING_SOAP, BINDING_HTTP_REDIRECT
from saml2.saml import NAME_FORMAT_URI

BASE = "http://localhost:8089/"

from pathutils import full_path

CONFIG = {
    "entityid" : "urn:mace:example.com:saml:roland:idpr",
    "name" : "Rolands restrictied IdP",
    "service": {
        "idp": {
            "endpoints" : {
                "single_sign_on_service" : [
                        (BASE+"sso", BINDING_HTTP_REDIRECT)],
                "attribute_service" : [
                        (BASE+"aa", BINDING_SOAP)],
            },
            "policy": {
                "default": {
                    "lifetime": {"minutes":15},
                    "name_form": NAME_FORMAT_URI
                },
                "urn:mace:example.com:saml:roland:sp": {
                    "lifetime": {"minutes": 5},
                    "attribute_restrictions":{
                        "givenName": None,
                        "surName": None,
                        "mail": [".*@example.com"],
                        "eduPersonAffiliation": ["(employee|staff|faculty)"],
                    }
                }
            },
            "subject_data": full_path("subject_data.db"),
        }
    },
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    "xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("sp_0.metadata")],
    },
    "attribute_map_dir" : full_path("attributemaps"),
}

########NEW FILE########
__FILENAME__ = saml2_data
#!/usr/bin/env python
#
# Copyright (C) 2007 SIOS Technology, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Test data for saml2"""

__author__ = 'tmatsuo@example.com (Takashi MATSUO)'

TEST_NAME_ID = """<?xml version="1.0" encoding="utf-8"?>
<NameID xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
  Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
  SPProvidedID="sp provided id">
  tmatsuo@example.com
</NameID>
"""

TEST_ISSUER = """<?xml version="1.0" encoding="utf-8"?>
<Issuer xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  http://www.example.com/test
</Issuer>
"""

TEST_SUBJECT_LOCALITY = """<?xml version="1.0" encoding="utf-8"?>
<SubjectLocality xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
  Address="127.0.0.1" DNSName="localhost"/>
"""

TEST_AUTHN_CONTEXT_CLASS_REF = """<?xml version="1.0" encoding="utf-8"?>
<AuthnContextClassRef xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  http://www.example.com/authnContextClassRef
</AuthnContextClassRef>
"""

TEST_AUTHN_CONTEXT_DECL_REF = """<?xml version="1.0" encoding="utf-8"?>
<AuthnContextDeclRef xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  http://www.example.com/authnContextDeclRef
</AuthnContextDeclRef>
"""

TEST_AUTHN_CONTEXT_DECL = """<?xml version="1.0" encoding="utf-8"?>
<AuthnContextDecl xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  http://www.example.com/authnContextDecl
</AuthnContextDecl>
"""

TEST_AUTHENTICATING_AUTHORITY = """<?xml version="1.0" encoding="utf-8"?>
<AuthenticatingAuthority xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  http://www.example.com/authenticatingAuthority
</AuthenticatingAuthority>
"""

TEST_AUTHN_CONTEXT = """<?xml version="1.0" encoding="utf-8"?>
<AuthnContext xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  <AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:Password</AuthnContextClassRef>
</AuthnContext>
"""

TEST_AUTHN_STATEMENT = """<?xml version="1.0" encoding="utf-8"?>
<AuthnStatement xmlns="urn:oasis:names:tc:SAML:2.0:assertion" AuthnInstant="2007-08-31T01:05:02Z" SessionNotOnOrAfter="2007-09-14T01:05:02Z">
  <AuthnContext>
    <AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:Password</AuthnContextClassRef>
  </AuthnContext>
</AuthnStatement>
"""

TEST_ATTRIBUTE_VALUE = """<?xml version="1.0" encoding="utf-8"?>
<AttributeValue xmlns="urn:oasis:names:tc:SAML:2.0:assertion">value for test attribute</AttributeValue>
"""

TEST_ATTRIBUTE = """<?xml version="1.0" encoding="utf-8"?>
<Attribute Name="testAttribute"
  NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified"
  FriendlyName="test attribute"
  xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  <AttributeValue >value1 of test attribute</AttributeValue>
  <AttributeValue >value2 of test attribute</AttributeValue>
</Attribute>
"""

TEST_ATTRIBUTE_STATEMENT = """<?xml version="1.0" encoding="utf-8"?>
<AttributeStatement xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  <Attribute Name="testAttribute"
    NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified"
    FriendlyName="test attribute">
    <AttributeValue >value1 of test attribute</AttributeValue>
    <AttributeValue >value2 of test attribute</AttributeValue>
  </Attribute>
  <Attribute Name="http://www.example.com/testAttribute2"
    NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"
    FriendlyName="test attribute2">
    <AttributeValue >value1 of test attribute2</AttributeValue>
    <AttributeValue >value2 of test attribute2</AttributeValue>
  </Attribute>
</AttributeStatement>
"""

TEST_SUBJECT_CONFIRMATION_DATA = """<?xml version="1.0" encoding="utf-8"?>
<SubjectConfirmationData
  NotBefore="2007-08-31T01:05:02Z"
  NotOnOrAfter="2007-09-14T01:05:02Z"
  Recipient="recipient"
  InResponseTo="responseID"
  Address="127.0.0.1"
  xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
</SubjectConfirmationData>
"""

TEST_SUBJECT_CONFIRMATION = """<?xml version="1.0" encoding="utf-8"?>
<SubjectConfirmation
  Method="urn:oasis:names:tc:SAML:2.0:cm:bearer"
  xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  <NameID xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
    Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    SPProvidedID="sp provided id">
    tmatsuo@example.com
  </NameID>
  <SubjectConfirmationData
    NotBefore="2007-08-31T01:05:02Z"
    NotOnOrAfter="2007-09-14T01:05:02Z"
    Recipient="recipient"
    InResponseTo="responseID"
    Address="127.0.0.1">
  </SubjectConfirmationData>
</SubjectConfirmation>
"""

TEST_SUBJECT = """<?xml version="1.0" encoding="utf-8"?>
<Subject xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  <NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    SPProvidedID="sp provided id">
    tmatsuo@example.com
  </NameID>
  <SubjectConfirmation
    Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
    <NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
      SPProvidedID="sp provided id2">
      admin@example.com
    </NameID>
    <SubjectConfirmationData
      NotBefore="2007-08-31T01:05:02Z"
      NotOnOrAfter="2007-09-14T01:05:02Z"
      Recipient="recipient"
      InResponseTo="responseID"
      Address="127.0.0.1">
    </SubjectConfirmationData>
  </SubjectConfirmation>
</Subject>
"""

TEST_CONDITION = """<?xml version="1.0" encoding="utf-8"?>
<Condition xmlns="urn:oasis:names:tc:SAML:2.0:assertion" xsi:type="test" ExtendedAttribute="value" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>
"""

TEST_AUDIENCE = """<?xml version="1.0" encoding="utf-8"?>
<Audience xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  http://www.example.com/Audience
</Audience>
"""

TEST_AUDIENCE_RESTRICTION = """<?xml version="1.0" encoding="utf-8"?>
<AudienceRestriction xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  <Audience>
    http://www.example.com/Audience
  </Audience>
</AudienceRestriction>
"""

TEST_ONE_TIME_USE = """<?xml version="1.0" encoding="utf-8"?>
<OneTimeUse xmlns="urn:oasis:names:tc:SAML:2.0:assertion"/>
"""

TEST_PROXY_RESTRICTION = """<?xml version="1.0" encoding="utf-8"?>
<ProxyRestriction xmlns="urn:oasis:names:tc:SAML:2.0:assertion" Count="2">
  <Audience>http://www.example.com/Audience</Audience>
</ProxyRestriction>
"""

TEST_CONDITIONS = """<?xml version="1.0" encoding="utf-8"?>
<Conditions
  xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
  NotBefore="2007-08-31T01:05:02Z"
  NotOnOrAfter="2007-09-14T01:05:02Z">
  <Condition
    xsi:type="test"
    ExtendedAttribute="value"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>
  <AudienceRestriction>
    <Audience>
      http://www.example.com/Audience
    </Audience>
  </AudienceRestriction>
  <OneTimeUse />
  <ProxyRestriction  Count="2">
    <Audience>http://www.example.com/Audience</Audience>
  </ProxyRestriction>
</Conditions>
"""

TEST_ASSERTION_ID_REF = """<?xml version="1.0" encoding="utf-8"?>
<AssertionIDRef xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  zzlieajngjbkjggjldmgindkckkolcblndbghlhm
</AssertionIDRef>
"""

TEST_ASSERTION_URI_REF = """<?xml version="1.0" encoding="utf-8"?>
<AssertionURIRef xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  http://www.example.com/AssertionURIRef
</AssertionURIRef>
"""

TEST_ACTION = """<?xml version="1.0" encoding="utf-8"?>
<Action xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
  Namespace="http://www.example.com/Namespace"/>
"""


########NEW FILE########
__FILENAME__ = samlp_data
#!/usr/bin/env python
#
# Copyright (C) 2007 SIOS Technology, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Test data for saml2"""

__author__ = 'tmatsuo@example.com (Takashi MATSUO)'

TEST_STATUS_CODE = """<?xml version="1.0" encoding="utf-8"?>
<StatusCode xmlns="urn:oasis:names:tc:SAML:2.0:protocol"
  Value="urn:oasis:names:tc:SAML:2.0:status:Responder">
  <StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:RequestDenied" />
</StatusCode>
"""

TEST_STATUS = """<?xml version="1.0" encoding="utf-8"?>
<Status xmlns="urn:oasis:names:tc:SAML:2.0:protocol">
  <StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Responder">
    <StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:UnsupportedBinding" />
  </StatusCode>
  <StatusMessage>status message</StatusMessage>
  <StatusDetail><foo bar="bar" /></StatusDetail>
</Status>
"""

TEST_NAME_ID_POLICY = """<?xml version="1.0" encoding="utf-8"?>
<NameIDPolicy xmlns="urn:oasis:names:tc:SAML:2.0:protocol"
  Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
  SPNameQualifier="urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
  AllowCreate="false"
/>
"""

TEST_IDP_ENTRY = """<?xml version="1.0" encoding="utf-8"?>
<IDPEntry xmlns="urn:oasis:names:tc:SAML:2.0:protocol"
  ProviderID="http://www.example.com/provider"
  Name="the provider"
  Loc="http://www.example.com/Loc"
/>
"""

TEST_IDP_LIST = """<?xml version="1.0" encoding="utf-8"?>
<IDPList xmlns="urn:oasis:names:tc:SAML:2.0:protocol">
  <IDPEntry ProviderID="http://www.example.com/provider"
    Name="the provider"
    Loc="http://www.example.com/Loc" />
  <GetComplete>http://www.example.com/GetComplete</GetComplete>
</IDPList>
"""

TEST_SCOPING = """<?xml version="1.0" encoding="utf-8"?>
<Scoping xmlns="urn:oasis:names:tc:SAML:2.0:protocol" ProxyCount="1">
  <IDPList>
    <IDPEntry ProviderID="http://www.example.com/provider"
      Name="the provider"
      Loc="http://www.example.com/Loc" />
    <GetComplete>http://www.example.com/GetComplete</GetComplete>
  </IDPList>
  <RequesterID>http://www.example.com/RequesterID</RequesterID>
</Scoping>
"""

TEST_REQUESTED_AUTHN_CONTEXT = """<?xml version="1.0" encoding="utf-8"?>
<RequestedAuthnContext xmlns="urn:oasis:names:tc:SAML:2.0:protocol"
  Comparison="exact">
  <AuthnContextClassRef xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    http://www.example.com/authnContextClassRef
  </AuthnContextClassRef>
  <AuthnContextDeclRef xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    http://www.example.com/authnContextDeclRef
  </AuthnContextDeclRef>
</RequestedAuthnContext>
"""

TEST_AUTHN_REQUEST = """<?xml version="1.0" encoding="utf-8"?>
<AuthnRequest
  ID="request id"
  Version="2.0"
  IssueInstant="2007-09-14T01:05:02Z"
  Destination="http://www.example.com/Destination"
  Consent="urn:oasis:names:tc:SAML:2.0:consent:unspecified"
  ForceAuthn="true"
  IsPassive="true"
  AssertionConsumerServiceIndex="1"
  AssertionConsumerServiceURL="http://www.example.com/acs"
  ProtocolBinding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
  AttributeConsumingServiceIndex="2"
  ProviderName="provider name"
  xmlns="urn:oasis:names:tc:SAML:2.0:protocol">
  <Issuer xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    http://www.example.com/test
  </Issuer>
  <Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
    <SignedInfo Id="id">
      <CanonicalizationMethod
        Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
      </CanonicalizationMethod>
      <SignatureMethod
        Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
        <HMACOutputLength>8</HMACOutputLength>
      </SignatureMethod>
      <Reference Id="id" URI="http://www.example.com/URI"
        Type="http://www.example.com/Type">
        <Transforms>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
        </Transforms>
        <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
        <DigestValue>digest value</DigestValue>
      </Reference>
    </SignedInfo>
    <SignatureValue Id="id">
      signature value
    </SignatureValue>
    <KeyInfo Id="id">
      <KeyName>
        key name
      </KeyName>
      <KeyValue>
        <DSAKeyValue>
          <P>p</P>
          <Q>q</Q>
          <G>g</G>
          <Y>y</Y>
          <J>j</J>
          <Seed>seed</Seed>
          <PgenCounter>pgen counter</PgenCounter>
        </DSAKeyValue>
      </KeyValue>
      <RetrievalMethod URI="http://www.example.com/URI"
        Type="http://www.example.com/Type">
        <Transforms>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
        </Transforms>
      </RetrievalMethod>
      <X509Data>
        <X509IssuerSerial>
          <X509IssuerName>issuer name</X509IssuerName>
          <X509IssuerNumber>1</X509IssuerNumber>
        </X509IssuerSerial>
        <X509SKI>x509 ski</X509SKI>
        <X509SubjectName>x509 subject name</X509SubjectName>
        <X509Certificate>x509 certificate</X509Certificate>
        <X509CRL>x509 crl</X509CRL>
      </X509Data>
      <PGPData>
        <PGPKeyID>pgp key id</PGPKeyID>
        <PGPKeyPacket>pgp key packet</PGPKeyPacket>
      </PGPData>
      <MgmtData>
        mgmt data
      </MgmtData>
      <SPKIData>
        <SPKISexp>spki sexp</SPKISexp>
        <SPKISexp>spki sexp2</SPKISexp>
      </SPKIData>  
    </KeyInfo>
    <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
      V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
    </Object>
  </Signature>
  <Extensions><test/></Extensions>
  <Subject xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    <NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
      SPProvidedID="sp provided id">
      tmatsuo@example.com
    </NameID>
    <SubjectConfirmation
      Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
      <NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
        SPProvidedID="sp provided id2">
        admin@example.com
      </NameID>
      <SubjectConfirmationData
        NotBefore="2007-08-31T01:05:02Z"
        NotOnOrAfter="2007-09-14T01:05:02Z"
        Recipient="recipient"
        InResponseTo="responseID"
        Address="127.0.0.1">
      </SubjectConfirmationData>
    </SubjectConfirmation>
  </Subject>
  <NameIDPolicy xmlns="urn:oasis:names:tc:SAML:2.0:protocol"
    Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    SPNameQualifier="urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
    AllowCreate="false"/>
  <Conditions
    xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
    NotBefore="2007-08-31T01:05:02Z"
    NotOnOrAfter="2007-09-14T01:05:02Z">
    <Condition
      xsi:type="test"
      ExtendedAttribute="value"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>
    <AudienceRestriction>
      <Audience>
        http://www.example.com/Audience
      </Audience>
    </AudienceRestriction>
    <OneTimeUse />
    <ProxyRestriction  Count="2">
      <Audience>http://www.example.com/Audience</Audience>
    </ProxyRestriction>
  </Conditions>
  <RequestedAuthnContext xmlns="urn:oasis:names:tc:SAML:2.0:protocol"
    Comparison="exact">
    <AuthnContextClassRef xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
      http://www.example.com/authnContextClassRef
    </AuthnContextClassRef>
    <AuthnContextDeclRef xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
      http://www.example.com/authnContextDeclRef
    </AuthnContextDeclRef>
  </RequestedAuthnContext>
  <Scoping xmlns="urn:oasis:names:tc:SAML:2.0:protocol" ProxyCount="1">
    <IDPList>
      <IDPEntry ProviderID="http://www.example.com/provider"
        Name="the provider"
        Loc="http://www.example.com/Loc" />
      <GetComplete>http://www.example.com/GetComplete</GetComplete>
    </IDPList>
    <RequesterID>http://www.example.com/RequesterID</RequesterID>
  </Scoping>
</AuthnRequest>
"""

TEST_LOGOUT_REQUEST = """<?xml version="1.0" encoding="utf-8"?>
<LogoutRequest
  ID="request id"
  Version="2.0"
  IssueInstant="2007-09-14T01:05:02Z"
  Destination="http://www.example.com/Destination"
  Consent="urn:oasis:names:tc:SAML:2.0:consent:unspecified"
  NotOnOrAfter="2007-10-14T01:05:02Z"
  Reason="http://www.example.com/Reason"
  xmlns="urn:oasis:names:tc:SAML:2.0:protocol">
  <Issuer xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    http://www.example.com/test
  </Issuer>
  <Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
    <SignedInfo Id="id">
      <CanonicalizationMethod
        Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
      </CanonicalizationMethod>
      <SignatureMethod
        Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
        <HMACOutputLength>8</HMACOutputLength>
      </SignatureMethod>
      <Reference Id="id" URI="http://www.example.com/URI"
        Type="http://www.example.com/Type">
        <Transforms>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
        </Transforms>
        <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
        <DigestValue>digest value</DigestValue>
      </Reference>
    </SignedInfo>
    <SignatureValue Id="id">
      signature value
    </SignatureValue>
    <KeyInfo Id="id">
      <KeyName>
        key name
      </KeyName>
      <KeyValue>
        <DSAKeyValue>
          <P>p</P>
          <Q>q</Q>
          <G>g</G>
          <Y>y</Y>
          <J>j</J>
          <Seed>seed</Seed>
          <PgenCounter>pgen counter</PgenCounter>
        </DSAKeyValue>
      </KeyValue>
      <RetrievalMethod URI="http://www.example.com/URI"
        Type="http://www.example.com/Type">
        <Transforms>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
        </Transforms>
      </RetrievalMethod>
      <X509Data>
        <X509IssuerSerial>
          <X509IssuerName>issuer name</X509IssuerName>
          <X509IssuerNumber>1</X509IssuerNumber>
        </X509IssuerSerial>
        <X509SKI>x509 ski</X509SKI>
        <X509SubjectName>x509 subject name</X509SubjectName>
        <X509Certificate>x509 certificate</X509Certificate>
        <X509CRL>x509 crl</X509CRL>
      </X509Data>
      <PGPData>
        <PGPKeyID>pgp key id</PGPKeyID>
        <PGPKeyPacket>pgp key packet</PGPKeyPacket>
      </PGPData>
      <MgmtData>
        mgmt data
      </MgmtData>
      <SPKIData>
        <SPKISexp>spki sexp</SPKISexp>
        <SPKISexp>spki sexp2</SPKISexp>
      </SPKIData>  
    </KeyInfo>
    <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
      V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
    </Object>
  </Signature>
  <Extensions><test/></Extensions>
  <BaseID xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
    Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    SPProvidedID="sp provided id">
    tmatsuo@example.com
  </BaseID>
  <NameID xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
    Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    SPProvidedID="sp provided id">
    tmatsuo@example.com
  </NameID>
  <EncryptedID xmlns="urn:oasis:names:tc:SAML:2.0:assertion" />
  <SessionIndex>session index</SessionIndex>
</LogoutRequest>
"""

TEST_LOGOUT_RESPONSE = """<?xml version="1.0" encoding="utf-8"?>
<LogoutResponse
  ID="response id"
  InResponseTo="request id"
  Version="2.0"
  IssueInstant="2007-09-14T01:05:02Z"
  Destination="http://www.example.com/Destination"
  Consent="urn:oasis:names:tc:SAML:2.0:consent:unspecified"
  xmlns="urn:oasis:names:tc:SAML:2.0:protocol">
  <Issuer xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
    http://www.example.com/test
  </Issuer>
  <Signature xmlns="http://www.w3.org/2000/09/xmldsig#" Id="id">
    <SignedInfo Id="id">
      <CanonicalizationMethod
        Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments">
      </CanonicalizationMethod>
      <SignatureMethod
        Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1">
        <HMACOutputLength>8</HMACOutputLength>
      </SignatureMethod>
      <Reference Id="id" URI="http://www.example.com/URI"
        Type="http://www.example.com/Type">
        <Transforms>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
        </Transforms>
        <DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"/>
        <DigestValue>digest value</DigestValue>
      </Reference>
    </SignedInfo>
    <SignatureValue Id="id">
      signature value
    </SignatureValue>
    <KeyInfo Id="id">
      <KeyName>
        key name
      </KeyName>
      <KeyValue>
        <DSAKeyValue>
          <P>p</P>
          <Q>q</Q>
          <G>g</G>
          <Y>y</Y>
          <J>j</J>
          <Seed>seed</Seed>
          <PgenCounter>pgen counter</PgenCounter>
        </DSAKeyValue>
      </KeyValue>
      <RetrievalMethod URI="http://www.example.com/URI"
        Type="http://www.example.com/Type">
        <Transforms>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
          <Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature">
            <XPath>xpath</XPath>
          </Transform>
        </Transforms>
      </RetrievalMethod>
      <X509Data>
        <X509IssuerSerial>
          <X509IssuerName>issuer name</X509IssuerName>
          <X509IssuerNumber>1</X509IssuerNumber>
        </X509IssuerSerial>
        <X509SKI>x509 ski</X509SKI>
        <X509SubjectName>x509 subject name</X509SubjectName>
        <X509Certificate>x509 certificate</X509Certificate>
        <X509CRL>x509 crl</X509CRL>
      </X509Data>
      <PGPData>
        <PGPKeyID>pgp key id</PGPKeyID>
        <PGPKeyPacket>pgp key packet</PGPKeyPacket>
      </PGPData>
      <MgmtData>
        mgmt data
      </MgmtData>
      <SPKIData>
        <SPKISexp>spki sexp</SPKISexp>
        <SPKISexp>spki sexp2</SPKISexp>
      </SPKIData>  
    </KeyInfo>
    <Object Id="object_id" Encoding="http://www.w3.org/2000/09/xmldsig#base64">
      V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo
    </Object>
  </Signature>
  <Extensions><test/></Extensions>
  <Status>
    <StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Responder">
      <StatusCode
        Value="urn:oasis:names:tc:SAML:2.0:status:UnsupportedBinding" />
    </StatusCode>
    <StatusMessage>status message</StatusMessage>
    <StatusDetail><foo bar="bar" /></StatusDetail>
  </Status>
</LogoutResponse>
"""

########NEW FILE########
__FILENAME__ = server2_conf
from pathutils import full_path

CONFIG = {
    "entityid" : "urn:mace:example.com:saml:roland:sp",
    "name" : "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints":{
                "assertion_consumer_service": ["http://lingon.catalogix.se:8087/"],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp":["urn:mace:example.com:saml:roland:idp"],
            "subject_data": "subject_data.db",
        }
    },
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    "xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("idp_soap.xml"), full_path("vo_metadata.xml")],
    },
    "virtual_organization" : {
        "urn:mace:example.com:it:tek":{
            "nameid_format" : "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
        }
    },
    "accepted_time_diff": 60,
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
    },
    "contact_person": [{
            "given_name": "Roland",
            "sur_name": "Hedberg",
            "telephone_number": "+46 70 100 0000",
            "email_address": ["tech@example.com", "tech@example.org"],
            "contact_type": "technical"
        },
    ]
}

########NEW FILE########
__FILENAME__ = server3_conf
from pathutils import full_path

CONFIG = {
    "entityid" : "urn:mace:example.com:saml:roland:sp",
    "name" : "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints":{
                "assertion_consumer_service": ["http://lingon.catalogix.se:8087/"],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp":["urn:mace:example.com:saml:roland:idp"],
            "subject_data": full_path("subject_data.db"),
        }
    },
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    "xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("idp_aa.xml"), full_path("vo_metadata.xml")],
    },
    "virtual_organization" : {
        "urn:mace:example.com:it:tek":{
            "nameid_format" : "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
        }
    },
    "accepted_time_diff": 60,
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
    },
    "contact_person": [{
            "given_name": "Roland",
            "sur_name": "Hedberg",
            "telephone_number": "+46 70 100 0000",
            "email_address": ["tech@example.com", "tech@example.org"],
            "contact_type": "technical"
        },
    ]
}

########NEW FILE########
__FILENAME__ = servera_conf
from saml2.extension.idpdisc import BINDING_DISCO
from saml2 import BINDING_SOAP
from saml2 import BINDING_PAOS
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_ARTIFACT
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2.saml import NAMEID_FORMAT_PERSISTENT

from pathutils import full_path
from pathutils import xmlsec_path

BASE = "http://lingon.catalogix.se:8087"

CONFIG = {
    "entityid": "urn:mace:example.com:saml:roland:sp",
    "name": "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints": {
                "assertion_consumer_service": [
                    ("%s/" % BASE, BINDING_HTTP_POST),
                    ("%s/paos" % BASE, BINDING_PAOS),
                    ("%s/redirect" % BASE, BINDING_HTTP_REDIRECT)],
                "artifact_resolution_service": [
                    ("%s/ars" % BASE, BINDING_SOAP)
                ],
                "manage_name_id_service": [
                    ("%s/mni/soap" % BASE, BINDING_SOAP),
                    ("%s/mni/post" % BASE, BINDING_HTTP_POST),
                    ("%s/mni/redirect" % BASE, BINDING_HTTP_REDIRECT),
                    ("%s/mni/art" % BASE, BINDING_HTTP_ARTIFACT)
                ],
                "single_logout_service": [
                    ("%s/sls" % BASE, BINDING_SOAP)
                ],
                "discovery_response": [
                    ("%s/disco" % BASE, BINDING_DISCO)
                ]
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title", "eduPersonAffiliation"],
            "idp": ["urn:mace:example.com:saml:roland:idp"],
            "name_id_format": [NAMEID_FORMAT_TRANSIENT,
                               NAMEID_FORMAT_PERSISTENT]
        }
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "ca_certs": full_path("cacerts.txt"),
    "xmlsec_binary": xmlsec_path,
    "metadata": {
        "local": [full_path("idp_all.xml"), full_path("vo_metadata.xml")],
    },
    "virtual_organization": {
        "urn:mace:example.com:it:tek": {
            "nameid_format": "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
        }
    },
    "subject_data": "subject_data.db",
    "accepted_time_diff": 60,
    "attribute_map_dir": full_path("attributemaps"),
    "entity_category": ["http://www.swamid.se/category/sfs-1993-1153",
                        #"http://www.swamid.se/category/research-and-education",
                        "http://www.swamid.se/category/hei-service"],
    #"valid_for": 6,
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
    },
    "contact_person": [
        {
            "given_name": "Roland",
            "sur_name": "Hedberg",
            "telephone_number": "+46 70 100 0000",
            "email_address": ["tech@eample.com", "tech@example.org"],
            "contact_type": "technical"
        },
    ],
    "logger": {
        "rotating": {
            "filename": "sp.log",
            "maxBytes": 500000,
            "backupCount": 5,
        },
        "loglevel": "info",
    }
}

########NEW FILE########
__FILENAME__ = server_conf
from pathutils import full_path
from pathutils import xmlsec_path

CONFIG = {
    "entityid": "urn:mace:example.com:saml:roland:sp",
    "name": "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints": {
                "assertion_consumer_service": [
                    "http://lingon.catalogix.se:8087/"],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp": ["urn:mace:example.com:saml:roland:idp"],
        }
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "ca_certs": full_path("cacerts.txt"),
    "xmlsec_binary": xmlsec_path,
    "metadata": {
        "local": [full_path("idp.xml"), full_path("vo_metadata.xml")],
    },
    "virtual_organization": {
        "urn:mace:example.com:it:tek": {
            "nameid_format": "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
        }
    },
    "subject_data": "subject_data.db",
    "accepted_time_diff": 60,
    "attribute_map_dir": full_path("attributemaps"),
    "valid_for": 6,
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
    },
    "contact_person": [{
                           "given_name": "Roland",
                           "sur_name": "Hedberg",
                           "telephone_number": "+46 70 100 0000",
                           "email_address": ["tech@eample.com",
                                             "tech@example.org"],
                           "contact_type": "technical"
                       },
    ],
    "logger": {
        "rotating": {
            "filename": full_path("sp.log"),
            "maxBytes": 100000,
            "backupCount": 5,
        },
        "loglevel": "info",
    }
}

########NEW FILE########
__FILENAME__ = server_conf_syslog
__author__ = 'rolandh'

from pathutils import full_path


CONFIG={
    "entityid" : "urn:mace:example.com:saml:roland:sp",
    "name" : "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints":{
                "assertion_consumer_service": ["http://lingon.catalogix.se:8087/"],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp": ["urn:mace:example.com:saml:roland:idp"],
        }
    },
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    #"xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("idp.xml"), full_path("vo_metadata.xml")],
    },
    "virtual_organization" : {
        "urn:mace:example.com:it:tek":{
            "nameid_format" : "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
        }
    },
    "subject_data": full_path("subject_data.db"),
    "accepted_time_diff": 60,
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
    },
    "contact_person": [{
            "given_name": "Roland",
            "sur_name": "Hedberg",
            "telephone_number": "+46 70 100 0000",
            "email_address": ["tech@eample.com", "tech@example.org"],
            "contact_type": "technical"
        },
    ],
    "logger": {
        "syslog": {
            "address": ("localhost", 514),
            "facility": "local3",
            "socktype": "dgram",
        },
        "loglevel": "info",
    }
}

########NEW FILE########
__FILENAME__ = sp_1_conf
from pathutils import full_path


CONFIG = {
    "entityid": "urn:mace:example.com:saml:roland:sp",
    "name": "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints": {
                "assertion_consumer_service": [
                    "http://lingon.catalogix.se:8087/"],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp": ["urn:mace:example.com:saml:roland:idp"],
        }
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "xmlsec_binary": None,
    "metadata": {
        "local": [full_path("idp.xml"), full_path("vo_metadata.xml")],
    },
    "virtual_organization": {
        "urn:mace:example.com:it:tek": {
            "nameid_format": "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
        }
    },
    "subject_data": full_path("subject_data.db"),
    "accepted_time_diff": 60,
    "attribute_map_dir": full_path("attributemaps"),
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
    },
    "contact_person": [{
                           "given_name": "Roland",
                           "sur_name": "Hedberg",
                           "telephone_number": "+46 70 100 0000",
                           "email_address": ["tech@eample.com",
                                             "tech@example.org"],
                           "contact_type": "technical"
                       },
    ],
    "secret": "0123456789",
}  

########NEW FILE########
__FILENAME__ = sp_2_conf
from pathutils import full_path

CONFIG = {
    "entityid" : "urn:mace:example.com:saml:roland:sp",
    "name" : "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints":{
                "assertion_consumer_service": ["http://lingon.catalogix.se:8087/"],
                },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp": ["urn:mace:example.com:saml:roland:idp"],
            }
    },
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    "xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("idp_2.xml")],
        },
    "virtual_organization" : {
        "urn:mace:example.com:it:tek":{
            "nameid_format" : "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
            }
    },
    "subject_data": full_path("subject_data.db"),
    "accepted_time_diff": 60,
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
        },
    "contact_person": [{
        "given_name": "Roland",
        "sur_name": "Hedberg",
        "telephone_number": "+46 70 100 0000",
        "email_address": ["tech@eample.com", "tech@example.org"],
        "contact_type": "technical"
    },
    ],
    "secret": "0123456789",
    "only_use_keys_in_metadata": True
    }

########NEW FILE########
__FILENAME__ = sp_mdext_conf
from pathutils import full_path

CONFIG = {
    "entityid": "urn:mace:example.com:saml:roland:sp",
    "name": "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints": {
                "assertion_consumer_service": [
                    "http://lingon.catalogix.se:8087/"],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp": ["urn:mace:example.com:saml:roland:idp"],
            "extensions": {
                "mdui": {
                    "UIInfo": {
                        "display_name": {"text": "NORDUnet", "lang": "en"},
                        "description": {
                            "text": "The NORDUnet A/S Identity Provider ..",
                            "lang": "en"},
                        "logo": {
                            "text": "https://www.nordu"
                                    ".net/resources/NORDUnet2.jpg",
                            "lang": "en", "height": 46, "width": 203}
                    },
                    "DiscoHints": {
                        "domain_hint": {"text": "nordu.net"}
                    }
                },
                "shibmd": {
                    "Scope": {"regexp": "false", "text": "nordu.net"}
                },
            }
        }
    },
    "debug": 1,
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "xmlsec_binary": None,
    "metadata": {
        "local": [full_path("idp_2.xml")],
    },
    "virtual_organization": {
        "urn:mace:example.com:it:tek": {
            "nameid_format": "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
        }
    },
    "subject_data": full_path("subject_data.db"),
    "accepted_time_diff": 60,
    "attribute_map_dir": full_path("attributemaps"),
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
    },
    "contact_person": [
        {
            "given_name": "Roland",
            "sur_name": "Hedberg",
            "telephone_number": "+46 70 100 0000",
            "email_address": ["tech@eample.com", "tech@example.org"],
            "contact_type": "technical"
        },
    ],
    "secret": "0123456789",
    "only_use_keys_in_metadata": True,
}

########NEW FILE########
__FILENAME__ = sp_slo_redirect_conf
from saml2 import BINDING_HTTP_REDIRECT
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAME_FORMAT_URI

from pathutils import full_path

HOME = "http://lingon.catalogix.se:8087/"
CONFIG = {
    "entityid" : "urn:mace:example.com:saml:roland:sp",
    "name" : "urn:mace:example.com:saml:roland:sp",
    "description": "My own SP",
    "service": {
        "sp": {
            "endpoints":{
                "assertion_consumer_service": [
                            (HOME, BINDING_HTTP_REDIRECT)],
                "single_logout_service" : [
                            (HOME+"slo",BINDING_HTTP_REDIRECT)],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp": ["urn:mace:example.com:saml:roland:idp"],
            "subject_data": full_path("subject_data.db"),
        }
    },
    "debug" : 1,
    "key_file" : full_path("test.key"),
    "cert_file" : full_path("test.pem"),
    "xmlsec_binary" : None,
    "metadata": {
        "local": [full_path("idp_slo_redirect.xml")],
    },
    "virtual_organization" : {
        "urn:mace:example.com:it:tek":{
            "nameid_format" : "urn:oid:1.3.6.1.4.1.1466.115.121.1.15-NameID",
            "common_identifier": "umuselin",
        }
    },
    "accepted_time_diff": 60,
    "attribute_map_dir" : full_path("attributemaps"),
    "organization": {
        "name": ("AB Exempel", "se"),
        "display_name": ("AB Exempel", "se"),
        "url": "http://www.example.org",
    },
    "contact_person": [{
            "given_name": "Roland",
            "sur_name": "Hedberg",
            "telephone_number": "+46 70 100 0000",
            "email_address": ["tech@eample.com", "tech@example.org"],
            "contact_type": "technical"
        },
    ]
}

########NEW FILE########
__FILENAME__ = test_00_xmldsig
#!/usr/bin/env python
#
# Copyright (C) 2007 SIOS Technology, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for xmldsig"""

__author__ = 'tmatsuo@example.com (Takashi MATSUO)'

import unittest
try:
  from xml.etree import ElementTree
except ImportError:
  from elementtree import ElementTree
import ds_data
import xmldsig as ds

class TestObject:

  def setup_class(self):
    self.object = ds.Object()

  def testAccessors(self):
    """Test for Object accessors"""
    self.object.id = "object_id"
    self.object.mime_type = "test/plain; charset=UTF-8"
    self.object.encoding = ds.ENCODING_BASE64
    new_object = ds.object_from_string(self.object.to_string())
    assert new_object.id == "object_id"
    assert new_object.mime_type == "test/plain; charset=UTF-8"
    assert new_object.encoding == ds.ENCODING_BASE64

  def testUsingTestData(self):
    """Test for object_from_string() using test data"""
    new_object = ds.object_from_string(ds_data.TEST_OBJECT)
    assert new_object.id == "object_id"
    assert new_object.encoding == ds.ENCODING_BASE64
    assert new_object.text.strip() == \
                 "V2VkIEp1biAgNCAxMjoxMTowMyBFRFQgMjAwMwo"
    

class TestMgmtData:

  def setup_class(self):
    self.mgmt_data = ds.MgmtData()

  def testAccessors(self):
    """Test for MgmtData accessors"""
    self.mgmt_data.text = "mgmt data"
    new_mgmt_data = ds.mgmt_data_from_string(self.mgmt_data.to_string())
    assert new_mgmt_data.text.strip() == "mgmt data"

  def testUsingTestData(self):
    """Test for mgmt_data_from_string() using test data"""
    new_mgmt_data = ds.mgmt_data_from_string(ds_data.TEST_MGMT_DATA)
    assert new_mgmt_data.text.strip() == "mgmt data"


class TestSPKISexp:

  def setup_class(self):
    self.spki_sexp = ds.SPKISexp()

  def testAccessors(self):
    """Test for SPKISexp accessors"""
    self.spki_sexp.text = "spki sexp"
    new_spki_sexp = ds.spki_sexp_from_string(self.spki_sexp.to_string())
    assert new_spki_sexp.text.strip() == "spki sexp"

  def testUsingTestData(self):
    """Test for spki_sexp_from_string() using test data"""
    new_spki_sexp = ds.spki_sexp_from_string(ds_data.TEST_SPKI_SEXP)
    assert new_spki_sexp.text.strip() == "spki sexp"


class TestSPKIData:

  def setup_class(self):
    self.spki_data = ds.SPKIData()

  def testAccessors(self):
    """Test for SPKIData accessors"""
    self.spki_data.spki_sexp.append(
      ds.spki_sexp_from_string(ds_data.TEST_SPKI_SEXP))
    new_spki_data = ds.spki_data_from_string(self.spki_data.to_string())
    assert new_spki_data.spki_sexp[0].text.strip() == "spki sexp"

  def testUsingTestData(self):
    """Test for spki_data_from_string() using test data"""
    new_spki_data = ds.spki_data_from_string(ds_data.TEST_SPKI_DATA)
    print new_spki_data
    assert new_spki_data.spki_sexp[0].text.strip() == "spki sexp"
    assert new_spki_data.spki_sexp[1].text.strip() == "spki sexp2"


class TestPGPData:

  def setup_class(self):
    self.pgp_data = ds.PGPData()

  def testAccessors(self):
    """Test for PGPData accessors"""
    self.pgp_data.pgp_key_id = ds.PGPKeyID(text="pgp key id")
    self.pgp_data.pgp_key_packet = ds.PGPKeyPacket(text="pgp key packet")
    new_pgp_data = ds.pgp_data_from_string(self.pgp_data.to_string())
    assert isinstance(new_pgp_data.pgp_key_id, ds.PGPKeyID)
    assert isinstance(new_pgp_data.pgp_key_packet, ds.PGPKeyPacket)
    assert new_pgp_data.pgp_key_id.text.strip() == "pgp key id"
    assert new_pgp_data.pgp_key_packet.text.strip() == "pgp key packet"

  def testUsingTestData(self):
    """Test for pgp_data_from_string() using test data"""
    new_pgp_data = ds.pgp_data_from_string(ds_data.TEST_PGP_DATA)
    assert isinstance(new_pgp_data.pgp_key_id, ds.PGPKeyID)
    assert isinstance(new_pgp_data.pgp_key_packet, ds.PGPKeyPacket)
    assert new_pgp_data.pgp_key_id.text.strip() == "pgp key id"
    assert new_pgp_data.pgp_key_packet.text.strip() == "pgp key packet"


class TestX509IssuerSerial:

  def setup_class(self):
    self.x509_issuer_serial = ds.X509IssuerSerialType_()

  def testAccessors(self):
    """Test for X509SerialNumber accessors"""
    self.x509_issuer_serial.x509_issuer_name = ds.X509IssuerName(
      text="issuer name")
    self.x509_issuer_serial.x509_serial_number = ds.X509SerialNumber(text="1")
    new_x509_issuer_serial = ds.x509_issuer_serial_type__from_string(
       self.x509_issuer_serial.to_string())
    assert new_x509_issuer_serial.x509_issuer_name.text.strip() == \
                 "issuer name"
    assert new_x509_issuer_serial.x509_serial_number.text.strip() == "1"

  def testUsingTestData(self):
    """Test for x509_issuer_serial_from_string() using test data"""
    new_x509_issuer_serial = ds.x509_issuer_serial_from_string(
      ds_data.TEST_X509_ISSUER_SERIAL)
    assert new_x509_issuer_serial.x509_issuer_name.text.strip() == \
                 "issuer name"
    assert new_x509_issuer_serial.x509_serial_number.text.strip() == "1"


class TestX509Data:

  def setup_class(self):
    self.x509_data = ds.X509Data()

  def testAccessors(self):
    """Test for X509Data accessors"""
    st = ds.x509_issuer_serial_from_string(ds_data.TEST_X509_ISSUER_SERIAL)
    print st
    self.x509_data.x509_issuer_serial= st
    self.x509_data.x509_ski = ds.X509SKI(text="x509 ski")
    self.x509_data.x509_subject_name = ds.X509SubjectName(
                                                text="x509 subject name")
    self.x509_data.x509_certificate = ds.X509Certificate(
                                                text="x509 certificate")
    self.x509_data.x509_crl = ds.X509CRL(text="x509 crl")
    
    new_x509_data = ds.x509_data_from_string(self.x509_data.to_string())
    print new_x509_data.keyswv()
    print new_x509_data.__dict__.keys()
    assert new_x509_data.x509_issuer_serial
    assert isinstance(new_x509_data.x509_issuer_serial, ds.X509IssuerSerial)
    assert new_x509_data.x509_ski.text.strip() == "x509 ski"
    assert isinstance(new_x509_data.x509_ski, ds.X509SKI)
    assert new_x509_data.x509_subject_name.text.strip() == \
                 "x509 subject name"
    assert isinstance(new_x509_data.x509_subject_name, ds.X509SubjectName)
    assert new_x509_data.x509_certificate.text.strip() == \
                 "x509 certificate"
    assert isinstance(new_x509_data.x509_certificate, ds.X509Certificate)
    assert new_x509_data.x509_crl.text.strip() == "x509 crl"
    assert isinstance(new_x509_data.x509_crl,ds.X509CRL)

  def testUsingTestData(self):
    """Test for x509_data_from_string() using test data"""
    new_x509_data = ds.x509_data_from_string(ds_data.TEST_X509_DATA)
    assert isinstance(new_x509_data.x509_issuer_serial, ds.X509IssuerSerial)
    assert new_x509_data.x509_ski.text.strip() == "x509 ski"
    assert isinstance(new_x509_data.x509_ski, ds.X509SKI)
    assert new_x509_data.x509_subject_name.text.strip() == \
                 "x509 subject name"
    assert isinstance(new_x509_data.x509_subject_name, ds.X509SubjectName)
    assert new_x509_data.x509_certificate.text.strip() == \
                 "x509 certificate"
    assert isinstance(new_x509_data.x509_certificate, ds.X509Certificate)
    assert new_x509_data.x509_crl.text.strip() == "x509 crl"
    assert isinstance(new_x509_data.x509_crl,ds.X509CRL)


class TestTransform:

  def setup_class(self):
    self.transform = ds.Transform()

  def testAccessors(self):
    """Test for Transform accessors"""
    self.transform.x_path.append(ds.TransformType_XPath(text="xpath"))
    self.transform.algorithm = ds.TRANSFORM_ENVELOPED
    new_transform = ds.transform_from_string(self.transform.to_string())
    assert isinstance(new_transform.x_path[0], ds.TransformType_XPath)
    assert new_transform.x_path[0].text.strip() == "xpath"
    assert new_transform.algorithm == ds.TRANSFORM_ENVELOPED

  def testUsingTestData(self):
    """Test for transform_from_string() using test data"""
    new_transform = ds.transform_from_string(ds_data.TEST_TRANSFORM)
    assert isinstance(new_transform.x_path[0], ds.TransformType_XPath)
    assert new_transform.x_path[0].text.strip() == "xpath"
    assert new_transform.algorithm == ds.TRANSFORM_ENVELOPED


class TestTransforms:

  def setup_class(self):
    self.transforms = ds.Transforms()

  def testAccessors(self):
    """Test for Transforms accessors"""
    self.transforms.transform.append(
      ds.transform_from_string(ds_data.TEST_TRANSFORM))
    self.transforms.transform.append(
      ds.transform_from_string(ds_data.TEST_TRANSFORM))
    new_transforms = ds.transforms_from_string(self.transforms.to_string())
    assert isinstance(new_transforms.transform[0], ds.Transform)
    assert isinstance(new_transforms.transform[1], ds.Transform)
    assert new_transforms.transform[0].algorithm == \
                 ds.TRANSFORM_ENVELOPED
    assert new_transforms.transform[1].algorithm == \
                 ds.TRANSFORM_ENVELOPED
    assert new_transforms.transform[0].x_path[0].text.strip() == "xpath"
    assert new_transforms.transform[1].x_path[0].text.strip() == "xpath"
    
  def testUsingTestData(self):
    """Test for transform_from_string() using test data"""
    new_transforms = ds.transforms_from_string(ds_data.TEST_TRANSFORMS)
    assert isinstance(new_transforms.transform[0], ds.Transform)
    assert isinstance(new_transforms.transform[1], ds.Transform)
    assert new_transforms.transform[0].algorithm == \
                 ds.TRANSFORM_ENVELOPED
    assert new_transforms.transform[1].algorithm == \
                 ds.TRANSFORM_ENVELOPED
    assert new_transforms.transform[0].x_path[0].text.strip() == "xpath"
    assert new_transforms.transform[1].x_path[0].text.strip() == "xpath"


class TestRetrievalMethod:

  def setup_class(self):
    self.retrieval_method = ds.RetrievalMethod()

  def testAccessors(self):
    """Test for RetrievalMethod accessors"""
    self.retrieval_method.uri = "http://www.example.com/URI"
    self.retrieval_method.type = "http://www.example.com/Type"
    self.retrieval_method.transforms = ds.transforms_from_string(
      ds_data.TEST_TRANSFORMS)
    new_retrieval_method = ds.retrieval_method_from_string(
      self.retrieval_method.to_string())
    assert new_retrieval_method.uri == "http://www.example.com/URI"
    assert new_retrieval_method.type == "http://www.example.com/Type"
    assert isinstance(new_retrieval_method.transforms, ds.Transforms)
    
  def testUsingTestData(self):
    """Test for retrieval_method_from_string() using test data"""
    new_retrieval_method = ds.retrieval_method_from_string(
      ds_data.TEST_RETRIEVAL_METHOD)
    assert new_retrieval_method.uri == "http://www.example.com/URI"
    assert new_retrieval_method.type == "http://www.example.com/Type"
    assert isinstance(new_retrieval_method.transforms, ds.Transforms)


class TestRSAKeyValue:

  def setup_class(self):
    self.rsa_key_value = ds.RSAKeyValue()

  def testAccessors(self):
    """Test for RSAKeyValue accessors"""
    self.rsa_key_value.modulus = ds.Modulus(text="modulus")
    self.rsa_key_value.exponent = ds.Exponent(text="exponent")
    new_rsa_key_value = ds.rsa_key_value_from_string(self.rsa_key_value.to_string())
    assert isinstance(new_rsa_key_value.modulus, ds.Modulus)
    assert isinstance(new_rsa_key_value.exponent, ds.Exponent)
    assert new_rsa_key_value.modulus.text.strip() == "modulus"
    assert new_rsa_key_value.exponent.text.strip() == "exponent"
    
  def testUsingTestData(self):
    """Test for rsa_key_value_from_string() using test data"""
    new_rsa_key_value = ds.rsa_key_value_from_string(
      ds_data.TEST_RSA_KEY_VALUE)
    assert isinstance(new_rsa_key_value.modulus, ds.Modulus)
    assert isinstance(new_rsa_key_value.exponent, ds.Exponent)
    assert new_rsa_key_value.modulus.text.strip() == "modulus"
    assert new_rsa_key_value.exponent.text.strip() == "exponent"


class TestDSAKeyValue:

  def setup_class(self):
    self.dsa_key_value = ds.DSAKeyValue()

  def testAccessors(self):
    """Test for DSAKeyValue accessors"""
    self.dsa_key_value.p = ds.P(text="p")
    self.dsa_key_value.q = ds.Q(text="q")
    self.dsa_key_value.g = ds.G(text="g")
    self.dsa_key_value.y = ds.Y(text="y")
    self.dsa_key_value.j = ds.J(text="j")
    self.dsa_key_value.seed = ds.Seed(text="seed")
    self.dsa_key_value.pgen_counter = ds.PgenCounter(text="pgen counter")
    new_dsa_key_value = ds.dsa_key_value_from_string(self.dsa_key_value.to_string())
    assert isinstance(new_dsa_key_value.p, ds.P)
    assert isinstance(new_dsa_key_value.q, ds.Q)
    assert isinstance(new_dsa_key_value.g, ds.G)
    assert isinstance(new_dsa_key_value.y, ds.Y)
    assert isinstance(new_dsa_key_value.j, ds.J)
    assert isinstance(new_dsa_key_value.seed, ds.Seed)
    assert isinstance(new_dsa_key_value.pgen_counter, ds.PgenCounter)
    assert new_dsa_key_value.p.text.strip() == "p"
    assert new_dsa_key_value.q.text.strip() == "q"
    assert new_dsa_key_value.g.text.strip() == "g"
    assert new_dsa_key_value.y.text.strip() == "y"
    assert new_dsa_key_value.j.text.strip() == "j"
    assert new_dsa_key_value.seed.text.strip() == "seed"
    assert new_dsa_key_value.pgen_counter.text.strip() == "pgen counter"
    
  def testUsingTestData(self):
    """Test for dsa_key_value_from_string() using test data"""
    new_dsa_key_value = ds.dsa_key_value_from_string(
      ds_data.TEST_DSA_KEY_VALUE)
    assert isinstance(new_dsa_key_value.p, ds.P)
    assert isinstance(new_dsa_key_value.q, ds.Q)
    assert isinstance(new_dsa_key_value.g, ds.G)
    assert isinstance(new_dsa_key_value.y, ds.Y)
    assert isinstance(new_dsa_key_value.j, ds.J)
    assert isinstance(new_dsa_key_value.seed, ds.Seed)
    assert isinstance(new_dsa_key_value.pgen_counter, ds.PgenCounter)
    assert new_dsa_key_value.p.text.strip() == "p"
    assert new_dsa_key_value.q.text.strip() == "q"
    assert new_dsa_key_value.g.text.strip() == "g"
    assert new_dsa_key_value.y.text.strip() == "y"
    assert new_dsa_key_value.j.text.strip() == "j"
    assert new_dsa_key_value.seed.text.strip() == "seed"
    assert new_dsa_key_value.pgen_counter.text.strip() == "pgen counter"


class TestKeyValue:

  def setup_class(self):
    self.key_value = ds.KeyValue()

  def testAccessors(self):
    """Test for KeyValue accessors"""
    self.key_value.dsa_key_value = ds.dsa_key_value_from_string(
      ds_data.TEST_DSA_KEY_VALUE)
    new_key_value = ds.key_value_from_string(self.key_value.to_string())
    assert isinstance(new_key_value.dsa_key_value, ds.DSAKeyValue)
    self.key_value.dsa_key_value = None
    self.key_value.rsa_key_value = ds.rsa_key_value_from_string(
      ds_data.TEST_RSA_KEY_VALUE)
    new_key_value = ds.key_value_from_string(self.key_value.to_string())
    assert isinstance(new_key_value.rsa_key_value, ds.RSAKeyValue)
    
  def testUsingTestData(self):
    """Test for key_value_from_string() using test data"""
    new_key_value = ds.key_value_from_string(ds_data.TEST_KEY_VALUE1)
    assert isinstance(new_key_value.dsa_key_value, ds.DSAKeyValue)
    self.key_value.dsa_key_value = None
    self.key_value.rsa_key_value = ds.rsa_key_value_from_string(
      ds_data.TEST_RSA_KEY_VALUE)
    new_key_value = ds.key_value_from_string(ds_data.TEST_KEY_VALUE2)
    assert isinstance(new_key_value.rsa_key_value, ds.RSAKeyValue)


class TestKeyName:

  def setup_class(self):
    self.key_name = ds.KeyName()

  def testAccessors(self):
    """Test for KeyName accessors"""
    self.key_name.text = "key name"
    new_key_name = ds.key_name_from_string(self.key_name.to_string())
    assert new_key_name.text.strip() == "key name"
    
  def testUsingTestData(self):
    """Test for key_name_from_string() using test data"""
    new_key_name = ds.key_name_from_string(ds_data.TEST_KEY_NAME)
    assert new_key_name.text.strip() == "key name"


class TestKeyInfo:
  def setup_class(self):
    self.key_info = ds.KeyInfo()

  def testAccessors(self):
    """Test for KeyInfo accessors"""
    self.key_info.key_name.append(
      ds.key_name_from_string(ds_data.TEST_KEY_NAME))
    self.key_info.key_value.append(
      ds.key_value_from_string(ds_data.TEST_KEY_VALUE1))
    self.key_info.retrieval_method.append(
      ds.retrieval_method_from_string(ds_data.TEST_RETRIEVAL_METHOD))
    self.key_info.x509_data.append(
      ds.x509_data_from_string(ds_data.TEST_X509_DATA))
    self.key_info.pgp_data.append(
      ds.pgp_data_from_string(ds_data.TEST_PGP_DATA))
    self.key_info.spki_data.append(
      ds.spki_data_from_string(ds_data.TEST_SPKI_DATA))
    self.key_info.mgmt_data.append(
      ds.mgmt_data_from_string(ds_data.TEST_MGMT_DATA))
    self.key_info.id = "id"
    new_key_info = ds.key_info_from_string(self.key_info.to_string())

    assert isinstance(new_key_info.key_name[0], ds.KeyName)
    assert isinstance(new_key_info.key_value[0], ds.KeyValue)
    assert isinstance(new_key_info.retrieval_method[0],
                            ds.RetrievalMethod)
    assert isinstance(new_key_info.x509_data[0], ds.X509Data)
    assert isinstance(new_key_info.pgp_data[0], ds.PGPData)
    assert isinstance(new_key_info.spki_data[0], ds.SPKIData)
    assert isinstance(new_key_info.mgmt_data[0], ds.MgmtData)
    assert new_key_info.id == "id"
    
  def testUsingTestData(self):
    """Test for key_info_from_string() using test data"""
    new_key_info = ds.key_info_from_string(ds_data.TEST_KEY_INFO)
    assert isinstance(new_key_info.key_name[0], ds.KeyName)
    assert isinstance(new_key_info.key_value[0], ds.KeyValue)
    assert isinstance(new_key_info.retrieval_method[0],
                            ds.RetrievalMethod)
    assert isinstance(new_key_info.x509_data[0], ds.X509Data)
    assert isinstance(new_key_info.pgp_data[0], ds.PGPData)
    assert isinstance(new_key_info.spki_data[0], ds.SPKIData)
    assert isinstance(new_key_info.mgmt_data[0], ds.MgmtData)
    assert new_key_info.id == "id"
  

class TestDigestValue:

  def setup_class(self):
    self.digest_value = ds.DigestValue()

  def testAccessors(self):
    """Test for DigestValue accessors"""
    self.digest_value.text = "digest value"
    new_digest_value = ds.digest_value_from_string(self.digest_value.to_string())
    assert new_digest_value.text.strip() == "digest value"
    
  def testUsingTestData(self):
    """Test for digest_value_from_string() using test data"""
    new_digest_value = ds.digest_value_from_string(ds_data.TEST_DIGEST_VALUE)
    assert new_digest_value.text.strip() == "digest value"


class TestDigestMethod:

  def setup_class(self):
    self.digest_method = ds.DigestMethod()

  def testAccessors(self):
    """Test for DigestMethod accessors"""
    self.digest_method.algorithm = ds.DIGEST_SHA1
    new_digest_method = ds.digest_method_from_string(
      self.digest_method.to_string())
    assert new_digest_method.algorithm == ds.DIGEST_SHA1
    
  def testUsingTestData(self):
    """Test for digest_method_from_string() using test data"""
    new_digest_method = ds.digest_method_from_string(
      ds_data.TEST_DIGEST_METHOD)
    assert new_digest_method.algorithm == ds.DIGEST_SHA1


class TestReference:

  def setup_class(self):
    self.reference = ds.Reference()

  def testAccessors(self):
    """Test for Reference accessors"""
    self.reference.transforms = ds.transforms_from_string(
      ds_data.TEST_TRANSFORMS)
    self.reference.digest_method = ds.digest_method_from_string(
      ds_data.TEST_DIGEST_METHOD)
    self.reference.digest_value = ds.digest_value_from_string(
      ds_data.TEST_DIGEST_VALUE)
    self.reference.id = "id"
    self.reference.uri = "http://www.example.com/URI"
    self.reference.type = "http://www.example.com/Type"
    new_reference = ds.reference_from_string(self.reference.to_string())
    assert isinstance(new_reference.transforms, ds.Transforms)
    assert isinstance(new_reference.digest_method, ds.DigestMethod)
    assert isinstance(new_reference.digest_value, ds.DigestValue)
    assert new_reference.id == "id"
    assert new_reference.uri == "http://www.example.com/URI"
    assert new_reference.type == "http://www.example.com/Type"
    
  def testUsingTestData(self):
    """Test for reference_from_string() using test data"""
    new_reference = ds.reference_from_string(ds_data.TEST_REFERENCE)
    assert isinstance(new_reference.transforms, ds.Transforms)
    assert isinstance(new_reference.digest_method, ds.DigestMethod)
    assert isinstance(new_reference.digest_value, ds.DigestValue)
    assert new_reference.id == "id"
    assert new_reference.uri == "http://www.example.com/URI"
    assert new_reference.type == "http://www.example.com/Type"


class TestSignatureMethod:

  def setup_class(self):
    self.signature_method = ds.SignatureMethod()

  def testAccessors(self):
    """Test for SignatureMethod accessors"""
    self.signature_method.algorithm = ds.SIG_RSA_SHA1
    self.signature_method.hmac_output_length = ds.HMACOutputLength(text="8")
    new_signature_method = ds.signature_method_from_string(
      self.signature_method.to_string())
    assert isinstance(new_signature_method.hmac_output_length,
                      ds.HMACOutputLength)
    assert new_signature_method.hmac_output_length.text.strip() == "8"
    assert new_signature_method.algorithm == ds.SIG_RSA_SHA1
    
  def testUsingTestData(self):
    """Test for signature_method_from_string() using test data"""
    new_signature_method = ds.signature_method_from_string(
                        ds_data.TEST_SIGNATURE_METHOD)
    assert isinstance(new_signature_method.hmac_output_length,
                      ds.HMACOutputLength)
    assert new_signature_method.hmac_output_length.text.strip() == "8"
    assert new_signature_method.algorithm == ds.SIG_RSA_SHA1


class TestCanonicalizationMethod:

  def setup_class(self):
    self.canonicalization_method = ds.CanonicalizationMethod()

  def testAccessors(self):
    """Test for CanonicalizationMethod accessors"""
    self.canonicalization_method.algorithm = ds.C14N_WITH_C
    new_canonicalization_method = ds.canonicalization_method_from_string(
      self.canonicalization_method.to_string())
    assert new_canonicalization_method.algorithm == ds.C14N_WITH_C
    
  def testUsingTestData(self):
    """Test for canonicalization_method_from_string() using test data"""
    new_canonicalization_method = ds.canonicalization_method_from_string(
      ds_data.TEST_CANONICALIZATION_METHOD)
    assert new_canonicalization_method.algorithm == ds.C14N_WITH_C


class TestSignedInfo:

  def setup_class(self):
    self.si = ds.SignedInfo()

  def testAccessors(self):
    """Test for SignedInfo accessors"""
    self.si.id = "id"
    self.si.canonicalization_method = ds.canonicalization_method_from_string(
      ds_data.TEST_CANONICALIZATION_METHOD)
    self.si.signature_method = ds.signature_method_from_string(
      ds_data.TEST_SIGNATURE_METHOD)
    self.si.reference.append(ds.reference_from_string(
      ds_data.TEST_REFERENCE))
    new_si = ds.signed_info_from_string(self.si.to_string())
    assert new_si.id == "id"
    assert isinstance(new_si.canonicalization_method,
                            ds.CanonicalizationMethod)
    assert isinstance(new_si.signature_method, ds.SignatureMethod)
    assert isinstance(new_si.reference[0], ds.Reference)
    
  def testUsingTestData(self):
    """Test for signed_info_from_string() using test data"""
    new_si = ds.signed_info_from_string(ds_data.TEST_SIGNED_INFO)
    assert new_si.id == "id"
    assert isinstance(new_si.canonicalization_method,
                            ds.CanonicalizationMethod)
    assert isinstance(new_si.signature_method, ds.SignatureMethod)
    assert isinstance(new_si.reference[0], ds.Reference)

class TestSignatureValue:

  def setup_class(self):
    self.signature_value = ds.SignatureValue()

  def testAccessors(self):
    """Test for SignatureValue accessors"""
    self.signature_value.id = "id"
    self.signature_value.text = "signature value"
    new_signature_value = ds.signature_value_from_string(
      self.signature_value.to_string())
    assert new_signature_value.id == "id"
    assert new_signature_value.text.strip() == "signature value"
    
  def testUsingTestData(self):
    """Test for signature_value_from_string() using test data"""
    new_signature_value = ds.signature_value_from_string(
      ds_data.TEST_SIGNATURE_VALUE)
    assert new_signature_value.id == "id"
    assert new_signature_value.text.strip() == "signature value"


class TestSignature:

  def setup_class(self):
    self.signature = ds.Signature()

  def testAccessors(self):
    """Test for Signature accessors"""
    self.signature.id = "id"
    self.signature.signed_info = ds.signed_info_from_string(
      ds_data.TEST_SIGNED_INFO)
    self.signature.signature_value = ds.signature_value_from_string(
      ds_data.TEST_SIGNATURE_VALUE)
    self.signature.key_info = ds.key_info_from_string(ds_data.TEST_KEY_INFO)
    self.signature.object.append(ds.object_from_string(ds_data.TEST_OBJECT))

    new_signature = ds.signature_from_string(self.signature.to_string())
    assert new_signature.id == "id"
    assert isinstance(new_signature.signed_info, ds.SignedInfo)
    assert isinstance(new_signature.signature_value, ds.SignatureValue)
    assert isinstance(new_signature.key_info, ds.KeyInfo)
    assert isinstance(new_signature.object[0], ds.Object)
    
  def testUsingTestData(self):
    """Test for signature_value_from_string() using test data"""
    new_signature = ds.signature_from_string(ds_data.TEST_SIGNATURE)
    assert new_signature.id == "id"
    assert isinstance(new_signature.signed_info, ds.SignedInfo)
    assert isinstance(new_signature.signature_value, ds.SignatureValue)
    assert isinstance(new_signature.key_info, ds.KeyInfo)
    assert isinstance(new_signature.object[0], ds.Object)


if __name__ == '__main__':
  unittest.main()

########NEW FILE########
__FILENAME__ = test_01_xmlenc
import saml2
import xmlenc as xenc
import xmldsig

data1 = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:EncryptedData MimeType="text/xml" xmlns:ns0="http://www.w3.org/2001/04/xmlenc#">
    <ns0:CipherData>
        <ns0:CipherValue>A23B45C56</ns0:CipherValue>
    </ns0:CipherData>
</ns0:EncryptedData>"""


def test_1():
    ed = xenc.encrypted_data_from_string(data1)
    assert ed
    assert ed.mime_type == "text/xml"
    assert ed.cipher_data is not None
    cd = ed.cipher_data
    assert cd.cipher_value is not None
    assert cd.cipher_value.text == "A23B45C56"
    
data2 = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:EncryptedData 
    Type="http://www.w3.org/2001/04/xmlenc#Element" 
    xmlns:ns0="http://www.w3.org/2001/04/xmlenc#">
    <ns0:EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#tripledes-cbc" />
    <ns1:KeyInfo xmlns:ns1="http://www.w3.org/2000/09/xmldsig#">
        <ns1:KeyName>John Smith</ns1:KeyName>
    </ns1:KeyInfo>
    <ns0:CipherData>
        <ns0:CipherValue>DEADBEEF</ns0:CipherValue>
    </ns0:CipherData>
</ns0:EncryptedData>"""

# data2 = """<EncryptedData xmlns='http://www.w3.org/2001/04/xmlenc#'
#         Type='http://www.w3.org/2001/04/xmlenc#Element'>
#     <EncryptionMethod
#         Algorithm='http://www.w3.org/2001/04/xmlenc#tripledes-cbc'/>
#     <ds:KeyInfo xmlns:ds='http://www.w3.org/2000/09/xmldsig#'>
#         <ds:KeyName>John Smith</ds:KeyName>
#     </ds:KeyInfo>
#     <CipherData><CipherValue>DEADBEEF</CipherValue></CipherData>
# </EncryptedData>"""

def test_2():
    ed = xenc.encrypted_data_from_string(data2)
    assert ed
    print ed
    assert ed.type == "http://www.w3.org/2001/04/xmlenc#Element"
    assert ed.encryption_method is not None
    em = ed.encryption_method
    assert em.algorithm == 'http://www.w3.org/2001/04/xmlenc#tripledes-cbc'
    assert ed.key_info is not None
    ki = ed.key_info
    assert ki.key_name[0].text == "John Smith"
    assert ed.cipher_data is not None
    cd = ed.cipher_data
    assert cd.cipher_value is not None
    assert cd.cipher_value.text == "DEADBEEF"

data3 = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:EncryptedData 
    Id="ED" 
    xmlns:ns0="http://www.w3.org/2001/04/xmlenc#">
    <ns0:EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc" />
    <ns1:KeyInfo xmlns:ns1="http://www.w3.org/2000/09/xmldsig#">
        <ns1:RetrievalMethod URI='#EK'
            Type="http://www.w3.org/2001/04/xmlenc#EncryptedKey"/>
        <ns1:KeyName>Sally Doe</ns1:KeyName>
    </ns1:KeyInfo>
    <ns0:CipherData>
        <ns0:CipherValue>DEADBEEF</ns0:CipherValue>
    </ns0:CipherData>
</ns0:EncryptedData>"""

def test_3():
    ed = xenc.encrypted_data_from_string(data3)
    assert ed
    print ed
    assert ed.encryption_method != None
    em = ed.encryption_method
    assert em.algorithm == 'http://www.w3.org/2001/04/xmlenc#aes128-cbc'
    assert ed.key_info != None
    ki = ed.key_info
    assert ki.key_name[0].text == "Sally Doe"
    assert len(ki.retrieval_method) == 1
    rm = ki.retrieval_method[0]
    assert rm.uri == "#EK"
    assert rm.type == "http://www.w3.org/2001/04/xmlenc#EncryptedKey"
    assert ed.cipher_data != None
    cd = ed.cipher_data
    assert cd.cipher_value != None
    assert cd.cipher_value.text == "DEADBEEF"

data4 = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:EncryptedKey 
    Id="EK" 
    xmlns:ns0="http://www.w3.org/2001/04/xmlenc#">
    <ns0:EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5" />
    <ns1:KeyInfo xmlns:ns1="http://www.w3.org/2000/09/xmldsig#">
        <ns1:KeyName>John Smith</ns1:KeyName>
    </ns1:KeyInfo>
    <ns0:CipherData>
        <ns0:CipherValue>xyzabc</ns0:CipherValue>
    </ns0:CipherData>
    <ns0:ReferenceList>
        <ns0:DataReference URI='#ED'/>
    </ns0:ReferenceList>
    <ns0:CarriedKeyName>Sally Doe</ns0:CarriedKeyName>
</ns0:EncryptedKey>"""


# data4 = """<EncryptedKey Id='EK' xmlns='http://www.w3.org/2001/04/xmlenc#'>
#     <EncryptionMethod 
#            Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5"/>
#     <ds:KeyInfo xmlns:ds='http://www.w3.org/2000/09/xmldsig#'>
#         <ds:KeyName>John Smith</ds:KeyName>
#     </ds:KeyInfo>
#     <CipherData><CipherValue>xyzabc</CipherValue></CipherData>
#     <ReferenceList>
#         <DataReference URI='#ED'/>
#     </ReferenceList>
#     <CarriedKeyName>Sally Doe</CarriedKeyName>
# </EncryptedKey>"""

def test_4():
    ek = xenc.encrypted_key_from_string(data4)
    assert ek
    print ek
    assert ek.encryption_method != None
    em = ek.encryption_method
    assert em.algorithm == 'http://www.w3.org/2001/04/xmlenc#rsa-1_5'
    assert ek.key_info != None
    ki = ek.key_info
    assert ki.key_name[0].text == "John Smith"
    assert ek.reference_list != None
    rl = ek.reference_list
    assert len(rl.data_reference)
    dr = rl.data_reference[0]
    assert dr.uri == "#ED"
    assert ek.cipher_data != None
    cd = ek.cipher_data
    assert cd.cipher_value != None
    assert cd.cipher_value.text == "xyzabc"

data5 = """<CipherReference URI="http://www.example.com/CipherValues.xml"
    xmlns="http://www.w3.org/2001/04/xmlenc#">
    <Transforms xmlns:ds='http://www.w3.org/2000/09/xmldsig#'>
        <ds:Transform 
           Algorithm="http://www.w3.org/TR/1999/REC-xpath-19991116">
           <ds:XPath xmlns:rep="http://www.example.org/repository">
             self::text()[parent::rep:CipherValue[@Id="example1"]]
           </ds:XPath>
        </ds:Transform>
        <ds:Transform Algorithm="http://www.w3.org/2000/09/xmldsig#base64"/>
    </Transforms>
</CipherReference>"""

def test_5():
    cr = xenc.cipher_reference_from_string(data5)
    assert cr
    print cr
    print cr.keyswv()
    trs = cr.transforms
    assert len(trs.transform) == 2
    tr = trs.transform[0]
    assert tr.algorithm in ["http://www.w3.org/TR/1999/REC-xpath-19991116",
            "http://www.w3.org/2000/09/xmldsig#base64"]
    if tr.algorithm == "http://www.w3.org/2000/09/xmldsig#base64":
        pass
    elif tr.algorithm == "http://www.w3.org/TR/1999/REC-xpath-19991116":
        assert len(tr.x_path) == 1
        xp = tr.x_path[0]
        assert xp.text.strip() == """self::text()[parent::rep:CipherValue[@Id="example1"]]"""
        
        
data6 = """<ReferenceList xmlns="http://www.w3.org/2001/04/xmlenc#">
    <DataReference URI="#invoice34">
      <ds:Transforms xmlns:ds='http://www.w3.org/2000/09/xmldsig#'>
        <ds:Transform Algorithm="http://www.w3.org/TR/1999/REC-xpath-19991116">
          <ds:XPath xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
              self::xenc:EncryptedData[@Id="example1"]
          </ds:XPath>
        </ds:Transform>
      </ds:Transforms>
    </DataReference>
</ReferenceList>"""

def test_6():
    rl = xenc.reference_list_from_string(data6)
    assert rl
    print rl
    assert len(rl.data_reference) == 1
    dr = rl.data_reference[0]
    assert dr.uri == "#invoice34"
    assert len(dr.extension_elements) == 1
    ee = dr.extension_elements[0]
    assert ee.tag == "Transforms"
    assert ee.namespace == "http://www.w3.org/2000/09/xmldsig#"
    trs = saml2.extension_element_to_element(ee, xmldsig.ELEMENT_FROM_STRING,
                                        namespace=xmldsig.NAMESPACE)
    
    assert trs
    assert len(trs.transform) == 1
    tr = trs.transform[0]
    assert tr.algorithm == "http://www.w3.org/TR/1999/REC-xpath-19991116"
    assert len(tr.x_path) == 1
    assert tr.x_path[0].text.strip() == """self::xenc:EncryptedData[@Id="example1"]"""


########NEW FILE########
__FILENAME__ = test_02_saml
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010 Ume University.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for saml2.saml"""

__author__ = 'roland.hedberg@adm.umu.se (Roland Hedberg)'

try:
    from xml.etree import ElementTree
except ImportError:
    from elementtree import ElementTree

import saml2
import saml2_data, ds_data

import xmldsig as ds

from saml2 import saml

from py.test import raises

from saml2.saml import Issuer
from saml2.saml import Attribute
from saml2.saml import AttributeValue
from saml2.saml import NAMEID_FORMAT_EMAILADDRESS


class TestExtensionElement:
    def test_loadd(self):
        ava = {
            "attributes": {"attr": "loa", "info": "source"},
            "tag": "tag",
            "namespace": "urn:mace:example.com",
            "text": "free text"
        }

        ee = saml2.ExtensionElement(ava["tag"])
        ee.loadd(ava)

        del ava["tag"]
        print ava
        ee = saml2.ExtensionElement("")

        raises(KeyError, "ee.loadd(ava)")

        ava["tag"] = "foo"
        del ava["namespace"]

        ee = saml2.ExtensionElement("")
        raises(KeyError, "ee.loadd(ava)")

    def test_find_children(self):
        ava = {
            "attributes": {"attr": "loa", "info": "source"},
            "tag": "tag",
            "namespace": "urn:mace:example.com",
            "text": "free text",
            "children": [{
                             "attributes": {"foo": "bar", "special": "app"},
                             "tag": "tag2",
                             "namespace": "urn:mace:example.com",
                             "text": "Just a line"
                         },
                         {
                             "attributes": {"static": "attribute",
                                            "dynamic": "orgname"},
                             "tag": "tag3",
                             "namespace": "urn:mace:example.com",
                             "text": "Another line of text",
                             "children": [{
                                              "tag": "subtag",
                                              "namespace": "urn:mace:example.org",

                                              "text": "grandchild"
                                          }]
                         },
                         {
                             "attributes": {"entitlement": "xyz"},
                             "tag": "tag4",
                             "namespace": "urn:mace:example.org",
                             "text": "A comment"
                         }
            ]
        }

        ee = saml2.ExtensionElement(ava["tag"])
        ee.loadd(ava)

        c = ee.find_children(tag="tag")
        assert len(c) == 0
        c = ee.find_children(tag="tag2")
        assert len(c) == 1
        c = ee.find_children(tag="tag3")
        assert len(c) == 1
        # Grandchild
        gc = c[0].find_children(tag="subtag")
        assert len(gc) == 1
        # only do immediate children
        gc = ee.find_children(tag="subtag")
        assert len(gc) == 0

        c = ee.find_children(tag="tag2", namespace="urn:mace:example.com")
        assert len(c) == 1
        c = ee.find_children(tag="tag2", namespace="urn:mace:example.org")
        assert len(c) == 0
        c = ee.find_children(tag="subtag", namespace="urn:mace:example.org")
        assert len(c) == 0

        c = ee.find_children(namespace="urn:mace:example.com")
        assert len(c) == 2
        c = ee.find_children(namespace="urn:mace:example.org")
        assert len(c) == 1

        c = ee.find_children()
        assert len(c) == 3


class TestExtensionContainer:
    def test_find_extensions(self):
        avas = [{
                    "attributes": {"foo": "bar", "special": "app"},
                    "tag": "tag2",
                    "namespace": "urn:mace:example.com",
                    "text": "Just a line"
                },
                {
                    "attributes": {"static": "attribute", "dynamic": "orgname"},
                    "tag": "tag3",
                    "namespace": "urn:mace:example.com",
                    "text": "Another line of text",
                    "children": [{
                                     "tag": "subtag",
                                     "namespace": "urn:mace:example.org",
                                     "text": "grandchild"
                                 }]
                },
                {
                    "attributes": {"entitlement": "xyz"},
                    "tag": "tag4",
                    "namespace": "urn:mace:example.org",
                    "text": "A comment"
                }]

        ees = [saml2.ExtensionElement("").loadd(a) for a in avas]
        print ees
        ec = saml2.ExtensionContainer(extension_elements=ees)
        esl = ec.find_extensions(tag="tag2")
        assert len(esl) == 1
        esl = ec.find_extensions(tag="tag3")
        assert len(esl) == 1
        esl = ec.find_extensions(tag="tag4")
        assert len(esl) == 1
        esl = ec.find_extensions(tag="tag2", namespace="urn:mace:example.com")
        assert len(esl) == 1
        esl = ec.find_extensions(tag="tag2", namespace="urn:mace:example.org")
        assert len(esl) == 0
        esl = ec.find_extensions(namespace="urn:mace:example.com")
        assert len(esl) == 2
        esl = ec.find_extensions(namespace="urn:mace:example.org")
        assert len(esl) == 1
        esl = ec.find_extensions()
        assert len(esl) == 3

    def test_add_extension_elements(self):
        items = [saml.NameID(sp_name_qualifier="sp0", text="foo"),
                 saml.NameID(sp_name_qualifier="sp1", text="bar"),
                 saml.Audience(text="http://example.org")]

        ec = saml2.ExtensionContainer()
        ec.add_extension_elements(items)
        esl = ec.find_extensions(tag="NameID")
        assert len(esl) == 2
        esl = ec.find_extensions(tag="Audience")
        assert len(esl) == 1
        esl = ec.find_extensions(namespace=saml.NAMESPACE)
        assert len(esl) == 3
        esl = ec.find_extensions()
        assert len(esl) == 3

    def test_add_extension_attribute(self):
        ec = saml2.ExtensionContainer()
        ec.add_extension_attribute("foo", "bar")
        assert len(ec.extension_attributes) == 1
        assert ec.extension_attributes.keys()[0] == "foo"


class TestSAMLBase:
    def test_make_vals_dict(self):
        ava = {
            "sp_name_qualifier": "loa",
            "format": NAMEID_FORMAT_EMAILADDRESS,
            "text": "free text"
        }

        foo = saml2.make_vals(ava, Issuer, part=True)
        print foo
        assert foo.format == NAMEID_FORMAT_EMAILADDRESS
        assert foo.sp_name_qualifier == "loa"
        assert foo.text == "free text"

    def test_make_vals_str(self):
        ava = "free text"

        foo = saml2.make_vals(ava, Issuer, part=True)
        print foo
        assert foo.keyswv() == ["text"]
        assert foo.text == "free text"

    def test_make_vals_multi_dict(self):
        ava = ["foo", "bar", "lions", "saints"]

        raises(Exception,
               "saml2.make_vals(ava, AttributeValue, Attribute(), part=True)")

        attr = Attribute()
        saml2.make_vals(ava, AttributeValue, attr, prop="attribute_value")
        assert attr.keyswv() == ["attribute_value"]
        assert len(attr.attribute_value) == 4

    def test_to_string_nspair(self):
        foo = saml2.make_vals("lions", AttributeValue, part=True)
        txt = foo.to_string()
        nsstr = foo.to_string({"saml": saml.NAMESPACE})
        assert nsstr != txt
        print txt
        print nsstr
        assert "saml:AttributeValue" in nsstr
        assert "saml:AttributeValue" not in txt

    def test_set_text(self):
        av = AttributeValue()
        av.set_text(True)
        assert av.text == "true"
        av.set_text(False)
        assert av.text == "false"
        # can't change value to another type
        raises(AssertionError, "av.set_text(491)")

        av = AttributeValue()
        av.set_text(None)
        assert av.text == ""

    def test_make_vals_div(self):
        foo = saml2.make_vals(666, AttributeValue, part=True)
        assert foo.text == "666"

        foo = saml2.make_vals(True, AttributeValue, part=True)
        assert foo.text == "true"

        foo = saml2.make_vals(False, AttributeValue, part=True)
        assert foo.text == "false"


class TestNameID:
    def setup_class(self):
        self.name_id = saml.NameID()

    def testEmptyExtensionsList(self):
        """Test if NameID has empty extensions list"""
        assert isinstance(self.name_id.extension_elements, list)
        assert len(self.name_id.extension_elements) == 0

    def testFormatAttribute(self):
        """Test for Format attribute accessors"""
        self.name_id.format = saml.NAMEID_FORMAT_EMAILADDRESS
        assert self.name_id.format == saml.NAMEID_FORMAT_EMAILADDRESS
        assert len(self.name_id.extension_elements) == 0
        new_name_id = saml.name_id_from_string(self.name_id.to_string())
        assert len(new_name_id.extension_elements) == 0

        self.name_id.extension_elements.append(saml2.ExtensionElement(
            'foo', text='bar'))
        assert len(self.name_id.extension_elements) == 1
        assert self.name_id.format == saml.NAMEID_FORMAT_EMAILADDRESS

    def testNameIDText(self):
        """Test text value of NameID element"""
        self.name_id.text = "tmatsuo@example.com"
        assert self.name_id.text == "tmatsuo@example.com"

    def testSPProvidedID(self):
        """Test for SPProvidedID attribute accessors"""
        self.name_id.sp_provided_id = "provided id"
        assert self.name_id.sp_provided_id == "provided id"

    def testEmptyNameIDToAndFromStringMatch(self):
        """Test name_id_from_string() with empty NameID"""
        string_from_name_id = self.name_id.to_string()
        new_name_id = saml.name_id_from_string(string_from_name_id)
        string_from_new_name_id = new_name_id.to_string()
        assert string_from_name_id == string_from_new_name_id

    def testNameIDToAndFromStringMatch(self):
        """Test name_id_from_string() with data"""
        self.name_id.format = saml.NAMEID_FORMAT_EMAILADDRESS
        self.name_id.text = "tmatsuo@example.com"
        self.name_id.name_qualifier = "name_qualifier"
        self.name_id.sp_name_qualifier = "sp_name_qualifier"
        string_from_name_id = self.name_id.to_string()
        new_name_id = saml.name_id_from_string(string_from_name_id)
        assert new_name_id.name_qualifier == "name_qualifier"
        assert new_name_id.sp_name_qualifier == "sp_name_qualifier"
        string_from_new_name_id = new_name_id.to_string()
        assert string_from_name_id == string_from_new_name_id

    def testExtensionAttributes(self):
        """Test extension attributes"""
        self.name_id.extension_attributes['hoge'] = 'fuga'
        self.name_id.extension_attributes['moge'] = 'muga'
        assert self.name_id.extension_attributes['hoge'] == 'fuga'
        assert self.name_id.extension_attributes['moge'] == 'muga'
        new_name_id = saml.name_id_from_string(self.name_id.to_string())
        assert new_name_id.extension_attributes['hoge'] == 'fuga'
        assert new_name_id.extension_attributes['moge'] == 'muga'

    def testname_id_from_string(self):
        """Test name_id_from_string() using test data"""
        name_id = saml.name_id_from_string(saml2_data.TEST_NAME_ID)
        assert name_id.format == saml.NAMEID_FORMAT_EMAILADDRESS
        assert name_id.text.strip() == "tmatsuo@example.com"
        assert name_id.sp_provided_id == "sp provided id"


class TestIssuer:
    def setup_class(self):
        self.issuer = saml.Issuer()

    def testIssuerToAndFromString(self):
        """Test issuer_from_string()"""
        self.issuer.text = "http://www.example.com/test"
        self.issuer.name_qualifier = "name_qualifier"
        self.issuer.sp_name_qualifier = "sp_name_qualifier"
        new_issuer = saml.issuer_from_string(self.issuer.to_string())
        assert self.issuer.text == new_issuer.text
        assert self.issuer.name_qualifier == new_issuer.name_qualifier
        assert self.issuer.sp_name_qualifier == new_issuer.sp_name_qualifier
        assert self.issuer.extension_elements == new_issuer.extension_elements

    def testUsingTestData(self):
        """Test issuer_from_string() using test data"""
        issuer = saml.issuer_from_string(saml2_data.TEST_ISSUER)
        assert issuer.text.strip() == "http://www.example.com/test"
        new_issuer = saml.issuer_from_string(issuer.to_string())
        assert issuer.text == new_issuer.text
        assert issuer.extension_elements == new_issuer.extension_elements


class TestSubjectLocality:
    def setup_class(self):
        self.subject_locality = saml.SubjectLocality()

    def testAccessors(self):
        """Test for SubjectLocality accessors"""
        self.subject_locality.address = "127.0.0.1"
        self.subject_locality.dns_name = "localhost"
        assert self.subject_locality.address == "127.0.0.1"
        assert self.subject_locality.dns_name == "localhost"
        new_subject_locality = saml.subject_locality_from_string(
            self.subject_locality.to_string())
        assert new_subject_locality.address == "127.0.0.1"
        assert new_subject_locality.dns_name == "localhost"

    def testUsingTestData(self):
        """Test SubjectLocalityFromString() using test data"""

        subject_locality = saml.subject_locality_from_string(
            saml2_data.TEST_SUBJECT_LOCALITY)
        assert subject_locality.address == "127.0.0.1"
        assert subject_locality.dns_name == "localhost"

        new_subject_locality = saml.subject_locality_from_string(
            subject_locality.to_string())
        assert new_subject_locality.address == "127.0.0.1"
        assert new_subject_locality.dns_name == "localhost"
        assert subject_locality.to_string() == new_subject_locality.to_string()


class TestAuthnContextClassRef:
    def setup_class(self):
        self.authn_context_class_ref = saml.AuthnContextClassRef()
        self.text = "http://www.example.com/authnContextClassRef"

    def testAccessors(self):
        """Test for AuthnContextClassRef accessors"""
        self.authn_context_class_ref.text = self.text
        assert self.authn_context_class_ref.text == self.text
        new_authn_context_class_ref = saml.authn_context_class_ref_from_string(
            self.authn_context_class_ref.to_string())
        assert new_authn_context_class_ref.text == self.text
        assert self.authn_context_class_ref.to_string() == \
               new_authn_context_class_ref.to_string()

    def testUsingTestData(self):
        """Test authn_context_class_ref_from_string() using test data"""
        authn_context_class_ref = saml.authn_context_class_ref_from_string(
            saml2_data.TEST_AUTHN_CONTEXT_CLASS_REF)
        assert authn_context_class_ref.text.strip() == self.text


class TestAuthnContextDeclRef:
    def setup_class(self):
        self.authn_context_decl_ref = saml.AuthnContextDeclRef()
        self.ref = "http://www.example.com/authnContextDeclRef"

    def testAccessors(self):
        """Test for AuthnContextDeclRef accessors"""
        self.authn_context_decl_ref.text = self.ref
        assert self.authn_context_decl_ref.text == self.ref
        new_authn_context_decl_ref = saml.authn_context_decl_ref_from_string(
            self.authn_context_decl_ref.to_string())
        assert new_authn_context_decl_ref.text == self.ref
        assert self.authn_context_decl_ref.to_string() == \
               new_authn_context_decl_ref.to_string()

    def testUsingTestData(self):
        """Test authn_context_decl_ref_from_string() using test data"""
        authn_context_decl_ref = saml.authn_context_decl_ref_from_string(
            saml2_data.TEST_AUTHN_CONTEXT_DECL_REF)
        assert authn_context_decl_ref.text.strip() == self.ref


class TestAuthnContextDecl:
    def setup_class(self):
        self.authn_context_decl = saml.AuthnContextDecl()
        self.text = "http://www.example.com/authnContextDecl"

    def testAccessors(self):
        """Test for AuthnContextDecl accessors"""
        self.authn_context_decl.text = self.text
        assert self.authn_context_decl.text == self.text
        new_authn_context_decl = saml.authn_context_decl_from_string(
            self.authn_context_decl.to_string())
        assert new_authn_context_decl.text == self.text
        assert self.authn_context_decl.to_string() == \
               new_authn_context_decl.to_string()

    def testUsingTestData(self):
        """Test authn_context_decl_from_string() using test data"""
        authn_context_decl = saml.authn_context_decl_from_string(
            saml2_data.TEST_AUTHN_CONTEXT_DECL)
        assert authn_context_decl.text.strip() == self.text


class TestAuthenticatingAuthority:
    def setup_class(self):
        self.authenticating_authority = saml.AuthenticatingAuthority()
        self.text = "http://www.example.com/authenticatingAuthority"

    def testAccessors(self):
        """Test for AuthenticatingAuthority accessors"""
        self.authenticating_authority.text = self.text
        assert self.authenticating_authority.text == self.text
        new_authenticating_authority = saml.authenticating_authority_from_string(
            self.authenticating_authority.to_string())
        assert new_authenticating_authority.text == self.text
        assert self.authenticating_authority.to_string() == \
               new_authenticating_authority.to_string()

    def testUsingTestData(self):
        """Test authenticating_authority_from_string() using test data"""
        authenticating_authority = saml.authenticating_authority_from_string(
            saml2_data.TEST_AUTHENTICATING_AUTHORITY)
        assert authenticating_authority.text.strip() == self.text


class TestAuthnContext:
    def setup_class(self):
        self.authn_context = saml.AuthnContext()

    def testAccessors(self):
        """Test for AuthnContext accessors"""
        self.authn_context.authn_context_class_ref = \
            saml.authn_context_class_ref_from_string(
                saml2_data.TEST_AUTHN_CONTEXT_CLASS_REF)
        self.authn_context.authn_context_decl_ref = \
            saml.authn_context_decl_ref_from_string(
                saml2_data.TEST_AUTHN_CONTEXT_DECL_REF)
        self.authn_context.authn_context_decl = \
            saml.authn_context_decl_from_string(
                saml2_data.TEST_AUTHN_CONTEXT_DECL)
        self.authn_context.authenticating_authority.append(
            saml.authenticating_authority_from_string(
                saml2_data.TEST_AUTHENTICATING_AUTHORITY))
        assert self.authn_context.authn_context_class_ref.text.strip() == \
               "http://www.example.com/authnContextClassRef"
        assert self.authn_context.authn_context_decl_ref.text.strip() == \
               "http://www.example.com/authnContextDeclRef"
        assert self.authn_context.authn_context_decl.text.strip() == \
               "http://www.example.com/authnContextDecl"
        assert self.authn_context.authenticating_authority[0].text.strip() == \
               "http://www.example.com/authenticatingAuthority"
        new_authn_context = saml.authn_context_from_string(
            self.authn_context.to_string())
        assert self.authn_context.to_string() == new_authn_context.to_string()

    def testUsingTestData(self):
        """Test authn_context_from_string() using test data"""
        authn_context = saml.authn_context_from_string(
            saml2_data.TEST_AUTHN_CONTEXT)
        assert authn_context.authn_context_class_ref.text.strip() == \
               saml.AUTHN_PASSWORD


class TestAuthnStatement:
    def setup_class(self):
        self.authn_statem = saml.AuthnStatement()

    def testAccessors(self):
        """Test for AuthnStatement accessors"""
        self.authn_statem.authn_instant = "2007-08-31T01:05:02Z"
        self.authn_statem.session_not_on_or_after = "2007-09-14T01:05:02Z"
        self.authn_statem.session_index = "sessionindex"
        self.authn_statem.authn_context = saml.AuthnContext()
        self.authn_statem.authn_context.authn_context_class_ref = \
            saml.authn_context_class_ref_from_string(
                saml2_data.TEST_AUTHN_CONTEXT_CLASS_REF)
        self.authn_statem.authn_context.authn_context_decl_ref = \
            saml.authn_context_decl_ref_from_string(
                saml2_data.TEST_AUTHN_CONTEXT_DECL_REF)
        self.authn_statem.authn_context.authn_context_decl = \
            saml.authn_context_decl_from_string(
                saml2_data.TEST_AUTHN_CONTEXT_DECL)
        self.authn_statem.authn_context.authenticating_authority.append(
            saml.authenticating_authority_from_string(
                saml2_data.TEST_AUTHENTICATING_AUTHORITY))

        new_as = saml.authn_statement_from_string(self.authn_statem.to_string())
        assert new_as.authn_instant == "2007-08-31T01:05:02Z"
        assert new_as.session_index == "sessionindex"
        assert new_as.session_not_on_or_after == "2007-09-14T01:05:02Z"
        assert new_as.authn_context.authn_context_class_ref.text.strip() == \
               "http://www.example.com/authnContextClassRef"
        assert new_as.authn_context.authn_context_decl_ref.text.strip() == \
               "http://www.example.com/authnContextDeclRef"
        assert new_as.authn_context.authn_context_decl.text.strip() == \
               "http://www.example.com/authnContextDecl"
        assert new_as.authn_context.authenticating_authority[0].text.strip() \
               == "http://www.example.com/authenticatingAuthority"
        assert self.authn_statem.to_string() == new_as.to_string()

    def testUsingTestData(self):
        """Test authn_statement_from_string() using test data"""
        authn_statem = saml.authn_statement_from_string(
            saml2_data.TEST_AUTHN_STATEMENT)
        assert authn_statem.authn_instant == "2007-08-31T01:05:02Z"
        assert authn_statem.session_not_on_or_after == "2007-09-14T01:05:02Z"
        assert authn_statem.authn_context.authn_context_class_ref.text.strip() == \
               saml.AUTHN_PASSWORD


class TestAttributeValue:
    def setup_class(self):
        self.attribute_value = saml.AttributeValue()
        self.text = "value for test attribute"

    def testAccessors(self):
        """Test for AttributeValue accessors"""

        self.attribute_value.text = self.text
        new_attribute_value = saml.attribute_value_from_string(
            self.attribute_value.to_string())
        assert new_attribute_value.text.strip() == self.text

    def testUsingTestData(self):
        """Test attribute_value_from_string() using test data"""

        attribute_value = saml.attribute_value_from_string(
            saml2_data.TEST_ATTRIBUTE_VALUE)
        assert attribute_value.text.strip() == self.text


BASIC_STR_AV = """<?xml version="1.0" encoding="utf-8"?>
<Attribute xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
Name="FirstName">
<AttributeValue xsi:type="xs:string">By-Tor</AttributeValue>
</Attribute>"""

BASIC_INT_AV = """<?xml version="1.0" encoding="utf-8"?>
<Attribute xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
Name="age">
<AttributeValue xsi:type="xs:int">23</AttributeValue>
</Attribute>"""

BASIC_NOT_INT_AV = """<?xml version="1.0" encoding="utf-8"?>
<Attribute xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
Name="age">
<AttributeValue xsi:type="xs:int">foo</AttributeValue>
</Attribute>"""

BASIC_BOOLEAN_TRUE_AV = """<?xml version="1.0" encoding="utf-8"?>
<Attribute xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
Name="on-off">
<AttributeValue xsi:type="xs:boolean">true</AttributeValue>
</Attribute>"""

BASIC_BOOLEAN_FALSE_AV = """<?xml version="1.0" encoding="utf-8"?>
<Attribute xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
Name="on-off">
<AttributeValue xsi:type="xs:boolean">false</AttributeValue>
</Attribute>"""

BASIC_BASE64_AV = """<?xml version="1.0" encoding="utf-8"?>
<Attribute xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
Name="FirstName">
<AttributeValue 
xsi:type="xs:base64Binary">VU5JTkVUVA==</AttributeValue>
</Attribute>"""

X500_AV = """<?xml version="1.0" encoding="utf-8"?>
<Attribute xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
xmlns:x500="urn:oasis:names:tc:SAML:2.0:profiles:attribute:X500"
NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"
Name="urn:oid:2.5.4.42" FriendlyName="givenName">
<AttributeValue xsi:type="xs:string" x500:Encoding="LDAP">Steven
</AttributeValue>
</Attribute>"""

UUID_AV = """<?xml version="1.0" encoding="utf-8"?>
<Attribute xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"
Name="urn:uuid:6c9d0ec8-dd2d-11cc-abdd-080009353559"
FriendlyName="pre_auth_req">
<AttributeValue xsi:type="xs:integer">1</AttributeValue>
</Attribute>"""


class TestAttribute:
    def setup_class(self):
        self.attribute = saml.Attribute()
        self.text = ["value of test attribute",
                     "value1 of test attribute",
                     "value2 of test attribute"]

    def testAccessors(self):
        """Test for Attribute accessors"""
        self.attribute.name = "testAttribute"
        self.attribute.name_format = saml.NAME_FORMAT_URI
        self.attribute.friendly_name = "test attribute"
        self.attribute.attribute_value.append(saml.AttributeValue())
        self.attribute.attribute_value[0].text = self.text[0]

        new_attribute = saml.attribute_from_string(self.attribute.to_string())
        assert new_attribute.name == "testAttribute"
        assert new_attribute.name_format == saml.NAME_FORMAT_URI
        assert new_attribute.friendly_name == "test attribute"
        assert new_attribute.attribute_value[0].text.strip() == self.text[0]

    def testUsingTestData(self):
        """Test attribute_from_string() using test data"""
        attribute = saml.attribute_from_string(saml2_data.TEST_ATTRIBUTE)
        assert attribute.name == "testAttribute"
        assert attribute.name_format == saml.NAME_FORMAT_UNSPECIFIED
        assert attribute.friendly_name == "test attribute"
        assert attribute.attribute_value[0].text.strip() == self.text[1]
        assert attribute.attribute_value[1].text.strip() == self.text[2]
        # test again
        attribute = saml.attribute_from_string(attribute.to_string())
        assert attribute.name == "testAttribute"
        assert attribute.name_format == saml.NAME_FORMAT_UNSPECIFIED
        assert attribute.friendly_name == "test attribute"
        assert attribute.attribute_value[0].text.strip() == self.text[1]
        assert attribute.attribute_value[1].text.strip() == self.text[2]

    def test_basic_str(self):
        attribute = saml.attribute_from_string(BASIC_STR_AV)
        print attribute
        assert attribute.attribute_value[0].text.strip() == "By-Tor"

    def test_basic_int(self):
        attribute = saml.attribute_from_string(BASIC_INT_AV)
        print attribute
        assert attribute.attribute_value[0].text == "23"

    def test_basic_base64(self):
        attribute = saml.attribute_from_string(BASIC_BASE64_AV)
        print attribute
        assert attribute.attribute_value[0].text == "VU5JTkVUVA=="
        assert attribute.attribute_value[0].get_type() == "xs:base64Binary"

    def test_basic_boolean_true(self):
        attribute = saml.attribute_from_string(BASIC_BOOLEAN_TRUE_AV)
        print attribute
        assert attribute.attribute_value[0].text.lower() == "true"

    def test_basic_boolean_false(self):
        attribute = saml.attribute_from_string(BASIC_BOOLEAN_FALSE_AV)
        print attribute
        assert attribute.attribute_value[0].text.lower() == "false"


class TestAttributeStatement:
    def setup_class(self):
        self.attr_statem = saml.AttributeStatement()
        self.text = ["value of test attribute",
                     "value1 of test attribute",
                     "value2 of test attribute",
                     "value1 of test attribute2",
                     "value2 of test attribute2", ]

    def testAccessors(self):
        """Test for Attribute accessors"""
        self.attr_statem.attribute.append(saml.Attribute())
        self.attr_statem.attribute.append(saml.Attribute())
        self.attr_statem.attribute[0].name = "testAttribute"
        self.attr_statem.attribute[0].name_format = saml.NAME_FORMAT_URI
        self.attr_statem.attribute[0].friendly_name = "test attribute"
        self.attr_statem.attribute[0].attribute_value.append(
            saml.AttributeValue())
        self.attr_statem.attribute[0].attribute_value[0].text = self.text[0]

        self.attr_statem.attribute[1].name = "testAttribute2"
        self.attr_statem.attribute[1].name_format = saml.NAME_FORMAT_UNSPECIFIED
        self.attr_statem.attribute[1].friendly_name = self.text[2]
        self.attr_statem.attribute[1].attribute_value.append(
            saml.AttributeValue())
        self.attr_statem.attribute[1].attribute_value[0].text = self.text[2]

        new_as = saml.attribute_statement_from_string(
            self.attr_statem.to_string())
        assert new_as.attribute[0].name == "testAttribute"
        assert new_as.attribute[0].name_format == saml.NAME_FORMAT_URI
        assert new_as.attribute[0].friendly_name == "test attribute"
        assert new_as.attribute[0].attribute_value[0].text.strip() == self.text[
            0]
        assert new_as.attribute[1].name == "testAttribute2"
        assert new_as.attribute[1].name_format == saml.NAME_FORMAT_UNSPECIFIED
        assert new_as.attribute[1].friendly_name == "value2 of test attribute"
        assert new_as.attribute[1].attribute_value[0].text.strip() == self.text[
            2]

    def testUsingTestData(self):
        """Test attribute_statement_from_string() using test data"""
        attr_statem = saml.attribute_statement_from_string( \
            saml2_data.TEST_ATTRIBUTE_STATEMENT)
        assert attr_statem.attribute[0].name == "testAttribute"
        assert attr_statem.attribute[
                   0].name_format == saml.NAME_FORMAT_UNSPECIFIED
        assert attr_statem.attribute[0].friendly_name == "test attribute"
        assert attr_statem.attribute[0].attribute_value[0].text.strip() == \
               self.text[1]
        assert attr_statem.attribute[0].attribute_value[1].text.strip() == \
               self.text[2]
        assert attr_statem.attribute[
                   1].name == "http://www.example.com/testAttribute2"
        assert attr_statem.attribute[1].name_format == saml.NAME_FORMAT_URI
        assert attr_statem.attribute[1].friendly_name == "test attribute2"
        assert attr_statem.attribute[1].attribute_value[0].text.strip() == \
               self.text[3]
        assert attr_statem.attribute[1].attribute_value[1].text.strip() == \
               self.text[4]

        # test again
        attr_statem2 = saml.attribute_statement_from_string(
            attr_statem.to_string())
        assert attr_statem2.attribute[0].name == "testAttribute"
        assert attr_statem2.attribute[
                   0].name_format == saml.NAME_FORMAT_UNSPECIFIED
        assert attr_statem2.attribute[0].friendly_name == "test attribute"
        assert attr_statem2.attribute[0].attribute_value[0].text.strip() == \
               self.text[1]
        assert attr_statem2.attribute[0].attribute_value[1].text.strip() == \
               self.text[2]
        assert attr_statem2.attribute[
                   1].name == "http://www.example.com/testAttribute2"
        assert attr_statem2.attribute[1].name_format == saml.NAME_FORMAT_URI
        assert attr_statem2.attribute[1].friendly_name == "test attribute2"
        assert attr_statem2.attribute[1].attribute_value[0].text.strip() == \
               self.text[3]
        assert attr_statem2.attribute[1].attribute_value[1].text.strip() == \
               self.text[4]


class TestSubjectConfirmationData:
    def setup_class(self):
        self.scd = saml.SubjectConfirmationData()

    def testAccessors(self):
        """Test for SubjectConfirmationData accessors"""

        self.scd.not_before = "2007-08-31T01:05:02Z"
        self.scd.not_on_or_after = "2007-09-14T01:05:02Z"
        self.scd.recipient = "recipient"
        self.scd.in_response_to = "responseID"
        self.scd.address = "127.0.0.1"
        new_scd = saml.subject_confirmation_data_from_string(
            self.scd.to_string())
        assert new_scd.not_before == "2007-08-31T01:05:02Z"
        assert new_scd.not_on_or_after == "2007-09-14T01:05:02Z"
        assert new_scd.recipient == "recipient"
        assert new_scd.in_response_to == "responseID"
        assert new_scd.address == "127.0.0.1"

    def testUsingTestData(self):
        """Test subject_confirmation_data_from_string() using test data"""

        scd = saml.subject_confirmation_data_from_string(
            saml2_data.TEST_SUBJECT_CONFIRMATION_DATA)
        assert scd.not_before == "2007-08-31T01:05:02Z"
        assert scd.not_on_or_after == "2007-09-14T01:05:02Z"
        assert scd.recipient == "recipient"
        assert scd.in_response_to == "responseID"
        assert scd.address == "127.0.0.1"


class TestSubjectConfirmation:
    def setup_class(self):
        self.sc = saml.SubjectConfirmation()

    def testAccessors(self):
        """Test for SubjectConfirmation accessors"""
        self.sc.name_id = saml.name_id_from_string(saml2_data.TEST_NAME_ID)
        self.sc.method = saml.SCM_BEARER
        self.sc.subject_confirmation_data = saml.subject_confirmation_data_from_string(
            saml2_data.TEST_SUBJECT_CONFIRMATION_DATA)
        new_sc = saml.subject_confirmation_from_string(self.sc.to_string())
        assert new_sc.name_id.sp_provided_id == "sp provided id"
        assert new_sc.method == saml.SCM_BEARER
        assert new_sc.subject_confirmation_data.not_before == \
               "2007-08-31T01:05:02Z"
        assert new_sc.subject_confirmation_data.not_on_or_after == \
               "2007-09-14T01:05:02Z"
        assert new_sc.subject_confirmation_data.recipient == "recipient"
        assert new_sc.subject_confirmation_data.in_response_to == "responseID"
        assert new_sc.subject_confirmation_data.address == "127.0.0.1"

    def testUsingTestData(self):
        """Test subject_confirmation_from_string() using test data"""

        sc = saml.subject_confirmation_from_string(
            saml2_data.TEST_SUBJECT_CONFIRMATION)
        assert sc.name_id.sp_provided_id == "sp provided id"
        assert sc.method == saml.SCM_BEARER
        assert sc.subject_confirmation_data.not_before == "2007-08-31T01:05:02Z"
        assert sc.subject_confirmation_data.not_on_or_after == "2007-09-14T01:05:02Z"
        assert sc.subject_confirmation_data.recipient == "recipient"
        assert sc.subject_confirmation_data.in_response_to == "responseID"
        assert sc.subject_confirmation_data.address == "127.0.0.1"


class TestSubject:
    def setup_class(self):
        self.subject = saml.Subject()

    def testAccessors(self):
        """Test for Subject accessors"""
        self.subject.name_id = saml.name_id_from_string(saml2_data.TEST_NAME_ID)
        self.subject.subject_confirmation.append(
            saml.subject_confirmation_from_string(
                saml2_data.TEST_SUBJECT_CONFIRMATION))
        new_subject = saml.subject_from_string(self.subject.to_string())
        assert new_subject.name_id.sp_provided_id == "sp provided id"
        assert new_subject.name_id.text.strip() == "tmatsuo@example.com"
        assert new_subject.name_id.format == saml.NAMEID_FORMAT_EMAILADDRESS
        assert isinstance(new_subject.subject_confirmation[0],
                          saml.SubjectConfirmation)

    def testUsingTestData(self):
        """Test for subject_from_string() using test data."""

        subject = saml.subject_from_string(saml2_data.TEST_SUBJECT)
        assert subject.name_id.sp_provided_id == "sp provided id"
        assert subject.name_id.text.strip() == "tmatsuo@example.com"
        assert subject.name_id.format == saml.NAMEID_FORMAT_EMAILADDRESS
        assert isinstance(subject.subject_confirmation[0],
                          saml.SubjectConfirmation)


class TestCondition:
    def setup_class(self):
        self.condition = saml.Condition()
        self.name = "{%s}type" % saml.XSI_NAMESPACE

    def testAccessors(self):
        """Test for Condition accessors."""
        self.condition.extension_attributes[self.name] = "test"
        self.condition.extension_attributes['ExtendedAttribute'] = "value"
        new_condition = saml.condition_from_string(self.condition.to_string())
        assert new_condition.extension_attributes[self.name] == "test"
        assert new_condition.extension_attributes[
                   "ExtendedAttribute"] == "value"

    def testUsingTestData(self):
        """Test for condition_from_string() using test data."""
        condition = saml.condition_from_string(saml2_data.TEST_CONDITION)
        assert condition.extension_attributes[self.name] == "test"
        assert condition.extension_attributes["ExtendedAttribute"] == "value"


class TestAudience:
    def setup_class(self):
        self.audience = saml.Audience()

    def testAccessors(self):
        """Test for Audience accessors"""

        self.audience.text = "http://www.example.com/Audience"
        new_audience = saml.audience_from_string(self.audience.to_string())
        assert new_audience.text.strip() == "http://www.example.com/Audience"

    def testUsingTestData(self):
        """Test audience_from_string using test data"""

        audience = saml.audience_from_string(saml2_data.TEST_AUDIENCE)
        assert audience.text.strip() == "http://www.example.com/Audience"


class TestAudienceRestriction:
    def setup_class(self):
        self.audience_restriction = saml.AudienceRestriction()

    def testAccessors(self):
        """Test for AudienceRestriction accessors"""

        self.audience_restriction.audience = \
            saml.audience_from_string(saml2_data.TEST_AUDIENCE)
        new_audience = saml.audience_restriction_from_string(
            self.audience_restriction.to_string())
        assert self.audience_restriction.audience.text.strip() == \
               "http://www.example.com/Audience"

    def testUsingTestData(self):
        """Test audience_restriction_from_string using test data"""

        audience_restriction = saml.audience_restriction_from_string(
            saml2_data.TEST_AUDIENCE_RESTRICTION)
        assert audience_restriction.audience[0].text.strip() == \
               "http://www.example.com/Audience"


class TestOneTimeUse:
    def setup_class(self):
        self.one_time_use = saml.OneTimeUse()

    def testAccessors(self):
        """Test for OneTimeUse accessors"""
        assert isinstance(self.one_time_use, saml.OneTimeUse)
        assert isinstance(self.one_time_use, saml.ConditionAbstractType_)

    def testUsingTestData(self):
        """Test one_time_use_from_string() using test data"""
        one_time_use = saml.one_time_use_from_string(
            saml2_data.TEST_ONE_TIME_USE)
        assert isinstance(one_time_use, saml.OneTimeUse)
        assert isinstance(one_time_use, saml.ConditionAbstractType_)


class TestProxyRestriction:
    def setup_class(self):
        self.proxy_restriction = saml.ProxyRestriction()

    def testAccessors(self):
        """Test for ProxyRestriction accessors"""

        assert isinstance(self.proxy_restriction, saml.ConditionAbstractType_)
        self.proxy_restriction.count = "2"
        self.proxy_restriction.audience.append(saml.audience_from_string(
            saml2_data.TEST_AUDIENCE))
        new_proxy_restriction = saml.proxy_restriction_from_string(
            self.proxy_restriction.to_string())
        assert new_proxy_restriction.count == "2"
        assert new_proxy_restriction.audience[0].text.strip() == \
               "http://www.example.com/Audience"

    def testUsingTestData(self):
        """Test proxy_restriction_from_string() using test data"""

        proxy_restriction = saml.proxy_restriction_from_string(
            saml2_data.TEST_PROXY_RESTRICTION)
        assert proxy_restriction.count == "2"
        assert proxy_restriction.audience[0].text.strip() == \
               "http://www.example.com/Audience"


class TestConditions:
    def setup_class(self):
        self.conditions = saml.Conditions()

    def testAccessors(self):
        """Test for Conditions accessors"""
        self.conditions.not_before = "2007-08-31T01:05:02Z"
        self.conditions.not_on_or_after = "2007-09-14T01:05:02Z"
        self.conditions.condition.append(saml.Condition())
        self.conditions.audience_restriction.append(saml.AudienceRestriction())
        self.conditions.one_time_use.append(saml.OneTimeUse())
        self.conditions.proxy_restriction.append(saml.ProxyRestriction())
        new_conditions = saml.conditions_from_string(
            self.conditions.to_string())
        assert new_conditions.not_before == "2007-08-31T01:05:02Z"
        assert new_conditions.not_on_or_after == "2007-09-14T01:05:02Z"
        assert isinstance(new_conditions.condition[0], saml.Condition)
        assert isinstance(new_conditions.audience_restriction[0],
                          saml.AudienceRestriction)
        assert isinstance(new_conditions.one_time_use[0],
                          saml.OneTimeUse)
        assert isinstance(new_conditions.proxy_restriction[0],
                          saml.ProxyRestriction)

    def testUsingTestData(self):
        """Test conditions_from_string() using test data"""
        new_conditions = saml.conditions_from_string(saml2_data.TEST_CONDITIONS)
        assert new_conditions.not_before == "2007-08-31T01:05:02Z"
        assert new_conditions.not_on_or_after == "2007-09-14T01:05:02Z"
        assert isinstance(new_conditions.condition[0], saml.Condition)
        assert isinstance(new_conditions.audience_restriction[0],
                          saml.AudienceRestriction)
        assert isinstance(new_conditions.one_time_use[0],
                          saml.OneTimeUse)
        assert isinstance(new_conditions.proxy_restriction[0],
                          saml.ProxyRestriction)


class TestAssertionIDRef:
    def setup_class(self):
        self.assertion_id_ref = saml.AssertionIDRef()

    def testAccessors(self):
        """Test for AssertionIDRef accessors"""
        self.assertion_id_ref.text = "zzlieajngjbkjggjldmgindkckkolcblndbghlhm"
        new_assertion_id_ref = saml.assertion_id_ref_from_string(
            self.assertion_id_ref.to_string())
        assert new_assertion_id_ref.text == \
               "zzlieajngjbkjggjldmgindkckkolcblndbghlhm"

    def testUsingTestData(self):
        """Test assertion_id_ref_from_string() using test data"""
        new_assertion_id_ref = saml.assertion_id_ref_from_string(
            saml2_data.TEST_ASSERTION_ID_REF)
        assert new_assertion_id_ref.text.strip() == \
               "zzlieajngjbkjggjldmgindkckkolcblndbghlhm"


class TestAssertionURIRef:
    def setup_class(self):
        self.assertion_uri_ref = saml.AssertionURIRef()

    def testAccessors(self):
        """Test for AssertionURIRef accessors"""
        self.assertion_uri_ref.text = "http://www.example.com/AssertionURIRef"
        new_assertion_uri_ref = saml.assertion_uri_ref_from_string(
            self.assertion_uri_ref.to_string())
        assert new_assertion_uri_ref.text == \
               "http://www.example.com/AssertionURIRef"

    def testUsingTestData(self):
        """Test assertion_uri_ref_from_string() using test data"""
        new_assertion_uri_ref = saml.assertion_uri_ref_from_string(
            saml2_data.TEST_ASSERTION_URI_REF)
        assert new_assertion_uri_ref.text.strip() == \
               "http://www.example.com/AssertionURIRef"


class TestAction:
    def setup_class(self):
        self.action = saml.Action()

    def testAccessors(self):
        """Test for Action accessors"""
        self.action.namespace = "http://www.example.com/Namespace"
        new_action = saml.action_from_string(self.action.to_string())
        assert new_action.namespace == "http://www.example.com/Namespace"

    def testUsingTestData(self):
        """Test action_from_string() using test data"""
        new_action = saml.action_from_string(saml2_data.TEST_ACTION)
        assert new_action.namespace == "http://www.example.com/Namespace"


class TestEvidence:
    def setup_class(self):
        self.evidence = saml.Evidence()

    def testAccessors(self):
        """Test for Evidence accessors"""
        self.evidence.assertion_id_ref.append(saml.AssertionIDRef())
        self.evidence.assertion_uri_ref.append(saml.AssertionURIRef())
        self.evidence.assertion.append(saml.Assertion())
        self.evidence.encrypted_assertion.append(saml.EncryptedAssertion())
        new_evidence = saml.evidence_from_string(self.evidence.to_string())
        print new_evidence
        assert self.evidence.to_string() == new_evidence.to_string()
        assert isinstance(new_evidence.assertion_id_ref[0],
                          saml.AssertionIDRef)
        assert isinstance(new_evidence.assertion_uri_ref[0],
                          saml.AssertionURIRef)
        assert len(new_evidence.assertion) == 1
        assert isinstance(new_evidence.assertion[0], saml.Assertion)
        assert len(new_evidence.encrypted_assertion) == 1
        assert isinstance(new_evidence.encrypted_assertion[0],
                          saml.EncryptedAssertion)

    def testUsingTestData(self):
        """Test evidence_from_string() using test data"""
        # TODO:
        pass


class TestAuthzDecisionStatement:
    def setup_class(self):
        self.authz_decision_statement = saml.AuthzDecisionStatement()

    def testAccessors(self):
        """Test for AuthzDecisionStatement accessors"""
        self.authz_decision_statement.resource = "http://www.example.com/Resource"
        self.authz_decision_statement.decision = saml.DECISION_TYPE_PERMIT
        self.authz_decision_statement.action.append(saml.Action())
        self.authz_decision_statement.evidence = saml.Evidence()
        new_authz_decision_statement = saml.authz_decision_statement_from_string(
            self.authz_decision_statement.to_string())
        assert self.authz_decision_statement.to_string() == \
               new_authz_decision_statement.to_string()
        assert new_authz_decision_statement.resource == \
               "http://www.example.com/Resource"
        assert new_authz_decision_statement.decision == \
               saml.DECISION_TYPE_PERMIT
        assert isinstance(new_authz_decision_statement.action[0],
                          saml.Action)
        assert isinstance(new_authz_decision_statement.evidence,
                          saml.Evidence)


    def testUsingTestData(self):
        """Test authz_decision_statement_from_string() using test data"""
        # TODO:
        pass


class TestAdvice:
    def setup_class(self):
        self.advice = saml.Advice()

    def testAccessors(self):
        """Test for Advice accessors"""
        self.advice.assertion_id_ref.append(saml.AssertionIDRef())
        self.advice.assertion_uri_ref.append(saml.AssertionURIRef())
        self.advice.assertion.append(saml.Assertion())
        self.advice.encrypted_assertion.append(saml.EncryptedAssertion())
        new_advice = saml.advice_from_string(self.advice.to_string())
        assert self.advice.to_string() == new_advice.to_string()
        assert isinstance(new_advice.assertion_id_ref[0],
                          saml.AssertionIDRef)
        assert isinstance(new_advice.assertion_uri_ref[0],
                          saml.AssertionURIRef)
        assert isinstance(new_advice.assertion[0], saml.Assertion)
        assert isinstance(new_advice.encrypted_assertion[0],
                          saml.EncryptedAssertion)

    def testUsingTestData(self):
        """Test advice_from_string() using test data"""
        # TODO:
        pass


class TestAssertion:
    def setup_class(self):
        self.assertion = saml.Assertion()

    def testAccessors(self):
        """Test for Assertion accessors"""
        self.assertion.id = "assertion id"
        self.assertion.version = saml2.VERSION
        self.assertion.issue_instant = "2007-08-31T01:05:02Z"
        self.assertion.issuer = saml.issuer_from_string(saml2_data.TEST_ISSUER)
        self.assertion.signature = ds.signature_from_string(
            ds_data.TEST_SIGNATURE)
        self.assertion.subject = saml.subject_from_string(
            saml2_data.TEST_SUBJECT)
        self.assertion.conditions = saml.conditions_from_string(
            saml2_data.TEST_CONDITIONS)
        self.assertion.advice = saml.Advice()
        self.assertion.statement.append(saml.Statement())
        self.assertion.authn_statement.append(saml.authn_statement_from_string(
            saml2_data.TEST_AUTHN_STATEMENT))
        self.assertion.authz_decision_statement.append(
            saml.AuthzDecisionStatement())
        self.assertion.attribute_statement.append(
            saml.attribute_statement_from_string(
                saml2_data.TEST_ATTRIBUTE_STATEMENT))

        new_assertion = saml.assertion_from_string(self.assertion.to_string())
        assert new_assertion.id == "assertion id"
        assert new_assertion.version == saml2.VERSION
        assert new_assertion.issue_instant == "2007-08-31T01:05:02Z"
        assert isinstance(new_assertion.issuer, saml.Issuer)
        assert isinstance(new_assertion.signature, ds.Signature)
        assert isinstance(new_assertion.subject, saml.Subject)
        assert isinstance(new_assertion.conditions, saml.Conditions)
        assert isinstance(new_assertion.advice, saml.Advice)
        assert isinstance(new_assertion.statement[0], saml.Statement)
        assert isinstance(new_assertion.authn_statement[0],
                          saml.AuthnStatement)
        assert isinstance(new_assertion.authz_decision_statement[0],
                          saml.AuthzDecisionStatement)
        assert isinstance(new_assertion.attribute_statement[0],
                          saml.AttributeStatement)


    def testUsingTestData(self):
        """Test assertion_from_string() using test data"""
        # TODO
        pass

########NEW FILE########
__FILENAME__ = test_03_saml2
#!/usr/bin/env python

import saml2

from saml2 import create_class_from_xml_string, class_name, make_vals, md
from saml2.saml import NameID, Issuer, SubjectLocality, AuthnContextClassRef
from saml2.saml import SubjectConfirmationData, SubjectConfirmation
from saml2.saml import Attribute

from py.test import raises
import saml2_data

try:
    from xml.etree import cElementTree as ElementTree
except ImportError:
    try:
        import cElementTree as ElementTree
    except ImportError:
        from elementtree import ElementTree

ITEMS = {
    NameID: ["""<?xml version="1.0" encoding="utf-8"?>
<NameID xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
  Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
  SPProvidedID="sp provided id">
  roland@example.com
</NameID>
""", """<?xml version="1.0" encoding="utf-8"?>
<NameID xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
  SPNameQualifier="https://foo.example.com/sp" 
  Format="urn:oasis:names:tc:SAML:2.0:nameid-format:transient">_1632879f09d08ea5ede2dc667cbed7e429ebc4335c</NameID>
""", """<?xml version="1.0" encoding="utf-8"?>
<NameID xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
Format="urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
NameQualifier="http://authentic.example.com/saml/metadata"
SPNameQualifier="http://auth.example.com/saml/metadata">test
</NameID>"""],
    Issuer: """<?xml version="1.0" encoding="utf-8"?>
<Issuer xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
  http://www.example.com/test
</Issuer>
""",
    SubjectLocality: """<?xml version="1.0" encoding="utf-8"?>
<SubjectLocality xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
  Address="127.0.0.1" DNSName="localhost"/>
""",
    SubjectConfirmationData:
        """<?xml version="1.0" encoding="utf-8"?>
<SubjectConfirmationData xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
InResponseTo="_1683146e27983964fbe7bf8f08961108d166a652e5" 
NotOnOrAfter="2010-02-18T13:52:13.959Z" 
NotBefore="2010-01-16T12:00:00Z" 
Recipient="http://192.168.0.10/saml/sp" />""",
    SubjectConfirmation:
        """<?xml version="1.0" encoding="utf-8"?>
<SubjectConfirmation xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
Method="urn:oasis:names:tc:SAML:2.0:cm:bearer"><NameID
Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
NameQualifier="http://authentic.example.com/saml/metadata">test@example.com
</NameID>
<SubjectConfirmationData
NotOnOrAfter="2010-02-17T17:02:38Z"
Recipient="http://auth.example.com/saml/proxySingleSignOnRedirect"
InResponseTo="_59B3A01B03334032C31E434C63F89E3E"/></SubjectConfirmation>"""
}

#def pytest_generate_tests(metafunc):
#    if "target_class" in metafunc.funcargnames:
#        for tcl,xml in ITEMS.items():
#            metafunc.addcall(funcargs={"target_class":tcl,"xml_string":xml})

def _eq(l1, l2):
    return set(l1) == set(l2)


def test_create_class_from_xml_string_nameid():
    kl = create_class_from_xml_string(NameID, ITEMS[NameID][0])
    assert kl != None
    assert kl.format == "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    assert kl.sp_provided_id == "sp provided id"
    assert kl.text.strip() == "roland@example.com"
    assert _eq(kl.keyswv(), ['sp_provided_id', 'format', 'text'])
    assert class_name(kl) == "urn:oasis:names:tc:SAML:2.0:assertion:NameID"
    assert _eq(kl.keys(), ['sp_provided_id', 'sp_name_qualifier',
                           'name_qualifier', 'format', 'text'])

    kl = create_class_from_xml_string(NameID, ITEMS[NameID][1])
    assert kl != None
    assert kl.format == "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
    assert kl.sp_name_qualifier == "https://foo.example.com/sp"
    assert kl.text.strip() == "_1632879f09d08ea5ede2dc667cbed7e429ebc4335c"
    assert _eq(kl.keyswv(), ['sp_name_qualifier', 'format', 'text'])
    assert class_name(kl) == "urn:oasis:names:tc:SAML:2.0:assertion:NameID"

    kl = create_class_from_xml_string(NameID, ITEMS[NameID][2])
    assert kl != None
    assert kl.format == "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
    assert kl.name_qualifier == "http://authentic.example.com/saml/metadata"
    assert kl.sp_name_qualifier == "http://auth.example.com/saml/metadata"
    assert kl.text.strip() == "test"
    assert _eq(kl.keyswv(), ['sp_name_qualifier', 'format', 'name_qualifier',
                             'text'])
    assert class_name(kl) == "urn:oasis:names:tc:SAML:2.0:assertion:NameID"


def test_create_class_from_xml_string_issuer():
    kl = create_class_from_xml_string(Issuer, ITEMS[Issuer])
    assert kl != None
    assert kl.text.strip() == "http://www.example.com/test"
    assert _eq(kl.keyswv(), ['text'])
    assert class_name(kl) == "urn:oasis:names:tc:SAML:2.0:assertion:Issuer"


def test_create_class_from_xml_string_subject_locality():
    kl = create_class_from_xml_string(SubjectLocality, ITEMS[SubjectLocality])
    assert kl != None
    assert _eq(kl.keyswv(), ['address', "dns_name"])
    assert kl.address == "127.0.0.1"
    assert kl.dns_name == "localhost"
    assert class_name(
        kl) == "urn:oasis:names:tc:SAML:2.0:assertion:SubjectLocality"


def test_create_class_from_xml_string_subject_confirmation_data():
    kl = create_class_from_xml_string(SubjectConfirmationData,
                                      ITEMS[SubjectConfirmationData])
    assert kl != None
    assert _eq(kl.keyswv(), ['in_response_to', 'not_on_or_after',
                             'not_before', 'recipient'])
    assert kl.in_response_to == "_1683146e27983964fbe7bf8f08961108d166a652e5"
    assert kl.not_on_or_after == "2010-02-18T13:52:13.959Z"
    assert kl.not_before == "2010-01-16T12:00:00Z"
    assert kl.recipient == "http://192.168.0.10/saml/sp"
    assert class_name(kl) == \
           "urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmationData"


def test_create_class_from_xml_string_subject_confirmation():
    kl = create_class_from_xml_string(SubjectConfirmation,
                                      ITEMS[SubjectConfirmation])
    assert kl != None
    assert _eq(kl.keyswv(), ['method', 'name_id',
                             'subject_confirmation_data'])
    assert kl.method == "urn:oasis:names:tc:SAML:2.0:cm:bearer"
    name_id = kl.name_id
    assert _eq(name_id.keyswv(), ['format', 'name_qualifier', 'text'])
    assert name_id.format == "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    assert name_id.name_qualifier == "http://authentic.example.com/saml/metadata"
    assert name_id.text.strip() == "test@example.com"
    subject_confirmation_data = kl.subject_confirmation_data
    assert _eq(subject_confirmation_data.keyswv(), ['not_on_or_after',
                                                    'recipient',
                                                    'in_response_to'])
    assert subject_confirmation_data.recipient == \
           "http://auth.example.com/saml/proxySingleSignOnRedirect"
    assert subject_confirmation_data.not_on_or_after == "2010-02-17T17:02:38Z"
    assert subject_confirmation_data.in_response_to == \
           "_59B3A01B03334032C31E434C63F89E3E"
    assert class_name(kl) == \
           "urn:oasis:names:tc:SAML:2.0:assertion:SubjectConfirmation"


def test_create_class_from_xml_string_wrong_class_spec():
    kl = create_class_from_xml_string(SubjectConfirmationData,
                                      ITEMS[SubjectConfirmation])
    assert kl == None


def test_ee_1():
    ee = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?><foo>bar</foo>""")
    assert ee != None
    print ee.__dict__
    assert ee.attributes == {}
    assert ee.tag == "foo"
    assert ee.namespace == None
    assert ee.children == []
    assert ee.text == "bar"


def test_ee_2():
    ee = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?><foo id="xyz">bar</foo>""")
    assert ee != None
    print ee.__dict__
    assert ee.attributes == {"id": "xyz"}
    assert ee.tag == "foo"
    assert ee.namespace == None
    assert ee.children == []
    assert ee.text == "bar"


def test_ee_3():
    ee = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?>
        <foo xmlns="urn:mace:example.com:saml:ns" 
        id="xyz">bar</foo>""")
    assert ee != None
    print ee.__dict__
    assert ee.attributes == {"id": "xyz"}
    assert ee.tag == "foo"
    assert ee.namespace == "urn:mace:example.com:saml:ns"
    assert ee.children == []
    assert ee.text == "bar"


def test_ee_4():
    ee = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?>
        <foo xmlns="urn:mace:example.com:saml:ns">
        <id>xyz</id><bar>tre</bar></foo>""")
    assert ee != None
    print ee.__dict__
    assert ee.attributes == {}
    assert ee.tag == "foo"
    assert ee.namespace == "urn:mace:example.com:saml:ns"
    assert len(ee.children) == 2
    assert ee.text.strip() == ""
    cid = ee.find_children("id", "urn:mace:example.com:saml:namespace")
    assert cid == []
    ids = ee.find_children("id", "urn:mace:example.com:saml:ns")
    assert ids != []
    cid = ids[0]
    print cid.__dict__
    assert cid.attributes == {}
    assert cid.tag == "id"
    assert cid.namespace == "urn:mace:example.com:saml:ns"
    assert cid.children == []
    assert cid.text.strip() == "xyz"


def test_ee_5():
    ee = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?>
        <foo xmlns="urn:mace:example.com:saml:ns">bar</foo>""")

    ce = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?>
        <educause xmlns="urn:mace:example.com:saml:cu">rev</educause>""")

    ee.children.append(ce)

    assert ee != None
    print ee.__dict__
    assert ee.attributes == {}
    assert ee.tag == "foo"
    assert ee.namespace == "urn:mace:example.com:saml:ns"
    assert len(ee.children) == 1
    assert ee.text.strip() == "bar"

    c = ee.children[0]
    print c.__dict__

    child = ee.find_children(namespace="urn:mace:example.com:saml:cu")
    assert len(child) == 1
    child = ee.find_children(namespace="urn:mace:example.com:saml:ns")
    assert len(child) == 0
    child = ee.find_children("educause", "urn:mace:example.com:saml:cu")
    assert len(child) == 1
    child = ee.find_children("edugain", "urn:mace:example.com:saml:cu")
    assert len(child) == 0
    print ee.to_string()


def test_ee_6():
    ee = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?>
        <foo xmlns="urn:mace:example.com:saml:ns">bar</foo>""")

    ce = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?>
        <educause xmlns="urn:mace:example.com:saml:cu">rev</educause>""")

    et = ee.transfer_to_element_tree()
    ce.become_child_element_of(et)

    pee = saml2._extension_element_from_element_tree(et)

    assert pee != None
    print pee.__dict__
    assert pee.attributes == {}
    assert pee.tag == "foo"
    assert pee.namespace == "urn:mace:example.com:saml:ns"
    assert len(pee.children) == 1
    assert pee.text.strip() == "bar"

    c = pee.children[0]
    print c.__dict__

    child = pee.find_children(namespace="urn:mace:example.com:saml:cu")
    assert len(child) == 1
    child = pee.find_children(namespace="urn:mace:example.com:saml:ns")
    assert len(child) == 0
    child = pee.find_children("educause", "urn:mace:example.com:saml:cu")
    assert len(child) == 1
    child = pee.find_children("edugain", "urn:mace:example.com:saml:cu")
    assert len(child) == 0
    print pee.to_string()


NAMEID_WITH_ATTRIBUTE_EXTENSION = """<?xml version="1.0" encoding="utf-8"?>
<NameID xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
  xmlns:local="urn:mace:example.com:saml:assertion"
  Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
  SPProvidedID="sp provided id"
  local:Foo="BAR">
  roland@example.com
</NameID>
"""


def test_nameid_with_extension():
    kl = create_class_from_xml_string(NameID, NAMEID_WITH_ATTRIBUTE_EXTENSION)
    assert kl != None
    print kl.__dict__
    assert kl.format == "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    assert kl.sp_provided_id == "sp provided id"
    assert kl.text.strip() == "roland@example.com"
    assert _eq(kl.keyswv(), ['sp_provided_id', 'format',
                             'extension_attributes', 'text'])
    assert class_name(kl) == "urn:oasis:names:tc:SAML:2.0:assertion:NameID"
    assert _eq(kl.keys(), ['sp_provided_id', 'sp_name_qualifier',
                           'name_qualifier', 'format', 'text'])
    assert kl.extension_attributes == {
        '{urn:mace:example.com:saml:assertion}Foo': 'BAR'}


SUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION = """<?xml version="1.0" encoding="utf-8"?>
<SubjectConfirmation xmlns="urn:oasis:names:tc:SAML:2.0:assertion"
Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
<NameID
Format="urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
NameQualifier="http://authentic.example.com/saml/metadata">test@example.com
</NameID>
<SubjectConfirmationData
NotOnOrAfter="2010-02-17T17:02:38Z"
Recipient="http://auth.example.com/saml/proxySingleSignOnRedirect"
InResponseTo="_59B3A01B03334032C31E434C63F89E3E"/>
<local:Trustlevel xmlns:local="urn:mace:example.com:saml:assertion">
Excellent
</local:Trustlevel>
</SubjectConfirmation>"""


def test_subject_confirmation_with_extension():
    kl = create_class_from_xml_string(SubjectConfirmation,
                                      SUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION)
    assert kl != None
    print kl.__dict__
    assert kl.extension_attributes == {}
    assert kl.method == "urn:oasis:names:tc:SAML:2.0:cm:bearer"
    name_id = kl.name_id
    assert _eq(name_id.keyswv(), ['format', 'name_qualifier', 'text'])
    assert name_id.format == "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
    assert name_id.name_qualifier == "http://authentic.example.com/saml/metadata"
    assert name_id.text.strip() == "test@example.com"
    subject_confirmation_data = kl.subject_confirmation_data
    assert _eq(subject_confirmation_data.keyswv(), ['not_on_or_after',
                                                    'recipient',
                                                    'in_response_to'])
    assert subject_confirmation_data.recipient == \
           "http://auth.example.com/saml/proxySingleSignOnRedirect"
    assert subject_confirmation_data.not_on_or_after == "2010-02-17T17:02:38Z"
    assert subject_confirmation_data.in_response_to == \
           "_59B3A01B03334032C31E434C63F89E3E"
    assert len(kl.extension_elements) == 1
    ee = kl.extension_elements[0]
    assert ee.tag == "Trustlevel"
    assert ee.namespace == "urn:mace:example.com:saml:assertion"
    assert ee.text.strip() == "Excellent"


def test_to_fro_string_1():
    kl = create_class_from_xml_string(SubjectConfirmation,
                                      SUBJECT_CONFIRMATION_WITH_MEMBER_EXTENSION)
    txt = kl.to_string()
    cpy = create_class_from_xml_string(SubjectConfirmation, txt)

    print kl.__dict__
    print cpy.__dict__

    assert kl.text.strip() == cpy.text.strip()
    assert _eq(kl.keyswv(), cpy.keyswv())
    assert len(kl.extension_elements) == len(cpy.extension_elements)
    klee = kl.extension_elements[0]
    cpyee = cpy.extension_elements[0]
    assert klee.text.strip() == cpyee.text.strip()
    assert klee.tag == cpyee.tag
    assert klee.namespace == cpyee.namespace


def test_make_vals_str():
    kl = make_vals("Jeter", md.GivenName, part=True)
    assert isinstance(kl, md.GivenName)
    assert kl.text == "Jeter"


def test_make_vals_list_of_strs():
    cp = md.ContactPerson()
    make_vals(["Derek", "Sanderson"], md.GivenName, cp, "given_name")
    assert len(cp.given_name) == 2
    assert _eq([i.text for i in cp.given_name], ["Sanderson", "Derek"])


def test_attribute_element_to_extension_element():
    attr = create_class_from_xml_string(Attribute, saml2_data.TEST_ATTRIBUTE)
    ee = saml2.element_to_extension_element(attr)
    print ee.__dict__
    assert ee.tag == "Attribute"
    assert ee.namespace == 'urn:oasis:names:tc:SAML:2.0:assertion'
    assert _eq(ee.attributes.keys(), ['FriendlyName', 'Name', 'NameFormat'])
    assert ee.attributes["FriendlyName"] == 'test attribute'
    assert ee.attributes["Name"] == "testAttribute"
    assert ee.attributes["NameFormat"] == \
           'urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified'
    assert len(ee.children) == 2
    for child in ee.children:
        # children are also extension element instances
        assert child.namespace == 'urn:oasis:names:tc:SAML:2.0:assertion'
        assert child.tag == "AttributeValue"


def test_ee_7():
    ee = saml2.extension_element_from_string(
        """<?xml version='1.0' encoding='UTF-8'?>
   <ExternalEntityAttributeAuthority
       xmlns="urn:oasis:names:tc:SAML:metadata:dynamicsaml">
       <AssertingEntity>
           <NameID Format="urn:oasis:names:tc:SAML:2.0:nameid-format:entity">
               http://federationX.org
           </NameID>
       </AssertingEntity>
       <RetrievalEndpoint>
           https://federationX.org/?ID=a87s76a5765da76576a57as
       </RetrievalEndpoint>
   </ExternalEntityAttributeAuthority>
""")

    print ee.__dict__
    assert len(ee.children) == 2
    for child in ee.children:
        assert child.namespace == "urn:oasis:names:tc:SAML:metadata:dynamicsaml"
    assert _eq(["AssertingEntity", "RetrievalEndpoint"],
               [c.tag for c in ee.children])
    aes = [c for c in ee.children if c.tag == "AssertingEntity"]
    assert len(aes) == 1
    assert len(aes[0].children) == 1
    assert _eq(aes[0].attributes.keys(), [])
    nid = aes[0].children[0]
    assert nid.tag == "NameID"
    assert nid.namespace == "urn:oasis:names:tc:SAML:metadata:dynamicsaml"
    assert len(nid.children) == 0
    assert _eq(nid.attributes.keys(), ["Format"])
    assert nid.text.strip() == "http://federationX.org"


def test_extension_element_loadd():
    ava = {'attributes': {},
           'tag': 'ExternalEntityAttributeAuthority',
           'namespace': 'urn:oasis:names:tc:SAML:metadata:dynamicsaml',
           'children': [{
                            "tag": "AssertingEntity",
                            "namespace": "urn:oasis:names:tc:SAML:metadata:dynamicsaml",

                            "children": [{
                                             "tag": "NameID",
                                             "namespace": "urn:oasis:names:tc:SAML:metadata:dynamicsaml",
                                             "text": "http://federationX.org",
                                             "attributes": {
                                                 "Format": "urn:oasis:names:tc:SAML:2.0:nameid-format:entity"
                                             },
                                         }]
                        }, {
                            "tag": "RetrievalEndpoint",
                            "namespace": "urn:oasis:names:tc:SAML:metadata"
                                         ":dynamicsaml",
                            "text": "https://federationX.org/?ID=a87s76a5765da76576a57as",
                        }],
    }

    ee = saml2.ExtensionElement(ava["tag"]).loadd(ava)
    print ee.__dict__
    assert len(ee.children) == 2
    for child in ee.children:
        assert child.namespace == "urn:oasis:names:tc:SAML:metadata:dynamicsaml"
    assert _eq(["AssertingEntity", "RetrievalEndpoint"],
               [c.tag for c in ee.children])
    aes = [c for c in ee.children if c.tag == "AssertingEntity"]
    assert len(aes) == 1
    assert len(aes[0].children) == 1
    assert _eq(aes[0].attributes.keys(), [])
    nid = aes[0].children[0]
    assert nid.tag == "NameID"
    assert nid.namespace == "urn:oasis:names:tc:SAML:metadata:dynamicsaml"
    assert len(nid.children) == 0
    assert _eq(nid.attributes.keys(), ["Format"])
    assert nid.text.strip() == "http://federationX.org"


def test_extensions_loadd():
    ava = {"extension_elements": [
        {
            'attributes': {},
            'tag': 'ExternalEntityAttributeAuthority',
            'namespace': 'urn:oasis:names:tc:SAML:metadata:dynamicsaml',
            'children': [
                {"tag": "AssertingEntity",
                 "namespace": "urn:oasis:names:tc:SAML:metadata:dynamicsaml",
                 "children": [
                     {"tag": "NameID",
                      "namespace": "urn:oasis:names:tc:SAML:metadata:dynamicsaml",
                      "text": "http://federationX.org",
                      "attributes": {
                          "Format": "urn:oasis:names:tc:SAML:2.0:nameid-format:entity"
                          },
                      }]
                },
                {
                    "tag": "RetrievalEndpoint",
                    "namespace": "urn:oasis:names:tc:SAML:metadata:dynamicsaml",
                    "text": "https://federationX.org/?ID=a87s76a5765da76576a57as",
                }],
            }],
           "extension_attributes": {
               "foo": "bar",
           }
    }

    extension = saml2.SamlBase()
    extension.loadd(ava)

    print extension.__dict__
    assert len(extension.extension_elements) == 1
    ee = extension.extension_elements[0]
    assert len(ee.children) == 2
    for child in ee.children:
        assert child.namespace == "urn:oasis:names:tc:SAML:metadata:dynamicsaml"
    assert _eq(["AssertingEntity", "RetrievalEndpoint"],
               [c.tag for c in ee.children])
    aes = [c for c in ee.children if c.tag == "AssertingEntity"]
    assert len(aes) == 1
    assert len(aes[0].children) == 1
    assert _eq(aes[0].attributes.keys(), [])
    nid = aes[0].children[0]
    assert nid.tag == "NameID"
    assert nid.namespace == "urn:oasis:names:tc:SAML:metadata:dynamicsaml"
    assert len(nid.children) == 0
    assert _eq(nid.attributes.keys(), ["Format"])
    assert nid.text.strip() == "http://federationX.org"

    assert extension.extension_attributes.keys() == ["foo"]
    assert extension.extension_attributes["foo"] == "bar"

########NEW FILE########
__FILENAME__ = test_04_samlp
#!/usr/bin/env pythony
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009 Ume University.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for saml2.samlp"""

__author__ = 'roland.hedberg@adm.umu.se (Roland Hedberg)'

import unittest
try:
  from xml.etree import ElementTree
except ImportError:
  from elementtree import ElementTree
import saml2

import saml2_data, ds_data, samlp_data

from saml2 import saml
from saml2 import samlp
import xmldsig as ds


# class TestRequestAbstractType:
# 
#     def setup_class(self):
#         self.ar = samlp.RequestAbstractType_()
# 
#     def testAccessors(self):
#         """Test for RequestAbstractType accessors"""
#         self.ar.id = "request id"
#         self.ar.version = saml2.VERSION
#         self.ar.issue_instant = "2007-09-14T01:05:02Z"
#         self.ar.destination = "http://www.example.com/Destination"
#         self.ar.consent = saml.CONSENT_UNSPECIFIED
#         self.ar.issuer = saml.Issuer()
#         self.ar.signature = ds.Signature()
#         self.ar.extensions = samlp.Extensions()
# 
#         new_ar = samlp.request_abstract_type__from_string(self.ar.to_string())
#         assert new_ar.id == "request id"
#         assert new_ar.version == saml2.VERSION
#         assert new_ar.issue_instant == "2007-09-14T01:05:02Z"
#         assert new_ar.destination == "http://www.example.com/Destination"
#         assert new_ar.consent == saml.CONSENT_UNSPECIFIED
#         assert isinstance(new_ar.issuer, saml.Issuer)
#         assert isinstance(new_ar.signature, ds.Signature)
#         assert isinstance(new_ar.extensions, samlp.Extensions)
#         
#     def testUsingTestData(self):
#         """Test for request_abstract_type_from_string() using test data"""
#         # TODO:
#         pass

class TestStatusDetail:

    def setup_class(self):
        self.status_detail = samlp.StatusDetail()

    def testAccessors(self):
        """Test for StatusDetail accessors"""
        # TODO:
        pass
    

class TestStatusMessage:

    def setup_class(self):
        self.status_message = samlp.StatusMessage()

    def testAccessors(self):
        """Test for StatusMessage accessors"""
        # TODO:
        pass
    

class TestStatusCode:

    def setup_class(self):
        self.status_code = samlp.StatusCode()

    def testAccessors(self):
        """Test for StatusCode accessors"""
        self.status_code.value = samlp.STATUS_RESPONDER
        self.status_code.status_code = samlp.StatusCode(
            value=samlp.STATUS_REQUEST_DENIED)
        print self.status_code.__dict__
        new_status_code = samlp.status_code_from_string(self.status_code.to_string())
        assert new_status_code.value == samlp.STATUS_RESPONDER
        assert new_status_code.status_code.value == \
                                 samlp.STATUS_REQUEST_DENIED

    def testUsingTestData(self):
        """Test for status_code_from_string() using test data"""
        new_status_code = samlp.status_code_from_string(
            samlp_data.TEST_STATUS_CODE)
        assert new_status_code.value == samlp.STATUS_RESPONDER
        assert new_status_code.status_code.value == \
                                 samlp.STATUS_REQUEST_DENIED


class TestStatus:

    def setup_class(self):
        self.status = samlp.Status()

    def testAccessors(self):
        """Test for Status accessors"""
        self.status.status_code = samlp.StatusCode()
        self.status.status_message = samlp.StatusMessage()
        self.status.status_detail = samlp.StatusDetail()
        new_status = samlp.status_from_string(self.status.to_string())
        assert isinstance(new_status.status_code, samlp.StatusCode)
        assert isinstance(new_status.status_message, samlp.StatusMessage)
        assert isinstance(new_status.status_detail, samlp.StatusDetail)

    def testUsingTestData(self):
        """Test for status_from_string using test data"""
        new_status = samlp.status_from_string(samlp_data.TEST_STATUS)
        assert isinstance(new_status.status_code, samlp.StatusCode)
        assert isinstance(new_status.status_code.status_code,
                                                        samlp.StatusCode)
        assert isinstance(new_status.status_message, samlp.StatusMessage)
        assert isinstance(new_status.status_detail, samlp.StatusDetail)

# class TestStatusResponseType:
# 
#     def setup_class(self):
#         self.sr = samlp.StatusResponseType()
# 
#     def testAccessors(self):
#         """Test for StatusResponseType accessors"""
#         self.sr.id = "response id"
#         self.sr.in_response_to = "request id"
#         self.sr.version = saml2.VERSION
#         self.sr.issue_instant = "2007-09-14T01:05:02Z"
#         self.sr.destination = "http://www.example.com/Destination"
#         self.sr.consent = saml.CONSENT_UNSPECIFIED
#         self.sr.issuer = saml.Issuer()
#         self.sr.signature = ds.Signature()
#         self.sr.extensions = samlp.Extensions()
#         self.sr.status = samlp.Status()
# 
#         new_sr = samlp.status_response_type_from_string(self.sr.to_string())
#         assert new_sr.id == "response id"
#         assert new_sr.in_response_to == "request id"
#         assert new_sr.version == saml2.VERSION
#         assert new_sr.issue_instant == "2007-09-14T01:05:02Z"
#         assert new_sr.destination == "http://www.example.com/Destination"
#         assert new_sr.consent == saml.CONSENT_UNSPECIFIED
#         assert isinstance(new_sr.issuer, saml.Issuer)
#         assert isinstance(new_sr.signature, ds.Signature)
#         assert isinstance(new_sr.extensions, samlp.Extensions)
#         assert isinstance(new_sr.status, samlp.Status)
#         
#     def testUsingTestData(self):
#         """Test for status_response_from_string() using test data"""
#         # TODO:
#         pass


class TestResponse:

    def setup_class(self):
        self.response = samlp.Response()

    def testAccessors(self):
        """Test for Response accessors"""
        self.response.id = "response id"
        self.response.in_response_to = "request id"
        self.response.version = saml2.VERSION
        self.response.issue_instant = "2007-09-14T01:05:02Z"
        self.response.destination = "http://www.example.com/Destination"
        self.response.consent = saml.CONSENT_UNSPECIFIED
        self.response.issuer = saml.Issuer()
        self.response.signature = ds.Signature()
        self.response.extensions = samlp.Extensions()
        self.response.status = samlp.Status()
        self.response.assertion.append(saml.Assertion())
        self.response.encrypted_assertion.append(saml.EncryptedAssertion())

        new_response = samlp.response_from_string(self.response.to_string())
        assert new_response.id == "response id"
        assert new_response.in_response_to == "request id"
        assert new_response.version == saml2.VERSION
        assert new_response.issue_instant == "2007-09-14T01:05:02Z"
        assert new_response.destination == "http://www.example.com/Destination"
        assert new_response.consent == saml.CONSENT_UNSPECIFIED
        assert isinstance(new_response.issuer, saml.Issuer)
        assert isinstance(new_response.signature, ds.Signature)
        assert isinstance(new_response.extensions, samlp.Extensions)
        assert isinstance(new_response.status, samlp.Status)

        assert isinstance(new_response.assertion[0], saml.Assertion)
        assert isinstance(new_response.encrypted_assertion[0],
                                                        saml.EncryptedAssertion)

    def testUsingTestData(self):
        """Test for response_from_string() using test data"""
        # TODO:
        pass

class TestNameIDPolicy:

    def setup_class(self):
        self.name_id_policy = samlp.NameIDPolicy()

    def testAccessors(self):
        """Test for NameIDPolicy accessors"""
        self.name_id_policy.format = saml.NAMEID_FORMAT_EMAILADDRESS
        self.name_id_policy.sp_name_qualifier = saml.NAMEID_FORMAT_PERSISTENT
        self.name_id_policy.allow_create = 'false'

        new_name_id_policy = samlp.name_id_policy_from_string(
            self.name_id_policy.to_string())

        assert new_name_id_policy.format == saml.NAMEID_FORMAT_EMAILADDRESS
        assert new_name_id_policy.sp_name_qualifier == \
                                 saml.NAMEID_FORMAT_PERSISTENT
        assert new_name_id_policy.allow_create == 'false'

    def testUsingTestData(self):
        """Test for name_id_policy_from_string() using test data"""
        new_name_id_policy = samlp.name_id_policy_from_string(
            samlp_data.TEST_NAME_ID_POLICY)

        assert new_name_id_policy.format == saml.NAMEID_FORMAT_EMAILADDRESS
        assert new_name_id_policy.sp_name_qualifier == \
                                 saml.NAMEID_FORMAT_PERSISTENT
        assert new_name_id_policy.allow_create == 'false'


class TestIDPEntry:

    def setup_class(self):
        self.idp_entry = samlp.IDPEntry()

    def testAccessors(self):
        """Test for IDPEntry accessors"""
        self.idp_entry.provider_id = "http://www.example.com/provider"
        self.idp_entry.name = "the provider"
        self.idp_entry.loc = "http://www.example.com/Loc"

        new_idp_entry = samlp.idp_entry_from_string(self.idp_entry.to_string())
        assert new_idp_entry.provider_id == "http://www.example.com/provider"
        assert new_idp_entry.name == "the provider"
        assert new_idp_entry.loc == "http://www.example.com/Loc"

    def testUsingTestData(self):
        """Test for idp_entry_from_string() using test data"""
        new_idp_entry = samlp.idp_entry_from_string(samlp_data.TEST_IDP_ENTRY)
        assert new_idp_entry.provider_id == "http://www.example.com/provider"
        assert new_idp_entry.name == "the provider"
        assert new_idp_entry.loc == "http://www.example.com/Loc"


class TestIDPList:

    def setup_class(self):
        self.idp_list = samlp.IDPList()

    def testAccessors(self):
        """Test for IDPList accessors"""
        self.idp_list.idp_entry.append(samlp.idp_entry_from_string(
            samlp_data.TEST_IDP_ENTRY))
        self.idp_list.get_complete = samlp.GetComplete(
            text="http://www.example.com/GetComplete")
        new_idp_list = samlp.idp_list_from_string(self.idp_list.to_string())
        assert isinstance(new_idp_list.idp_entry[0], samlp.IDPEntry)
        assert new_idp_list.get_complete.text.strip() == \
                                 "http://www.example.com/GetComplete"

    def testUsingTestData(self):
        """Test for idp_list_from_string() using test data"""
        new_idp_list = samlp.idp_list_from_string(samlp_data.TEST_IDP_LIST)
        assert isinstance(new_idp_list.idp_entry[0], samlp.IDPEntry)
        assert new_idp_list.get_complete.text.strip() == \
                                 "http://www.example.com/GetComplete"


class TestScoping:

    def setup_class(self):
        self.scoping = samlp.Scoping()

    def testAccessors(self):
        """Test for Scoping accessors"""

        self.scoping.proxy_count = "1"
        self.scoping.idp_list = samlp.IDPList()
        self.scoping.requester_id.append(samlp.RequesterID())

        new_scoping = samlp.scoping_from_string(self.scoping.to_string())

        assert new_scoping.proxy_count == "1"
        assert isinstance(new_scoping.idp_list, samlp.IDPList)
        assert isinstance(new_scoping.requester_id[0], samlp.RequesterID)

    def testUsingTestData(self):
        """Test for scoping_from_string() using test data"""
        new_scoping = samlp.scoping_from_string(samlp_data.TEST_SCOPING)

        assert new_scoping.proxy_count == "1"
        assert isinstance(new_scoping.idp_list, samlp.IDPList)
        assert isinstance(new_scoping.requester_id[0], samlp.RequesterID)


class TestRequestedAuthnContext:

    def setup_class(self):
        self.context = samlp.RequestedAuthnContext()

    def testAccessors(self):
        """Test for RequestedAuthnContext accessors"""

        self.context.authn_context_class_ref.append(saml.AuthnContextClassRef())
        self.context.authn_context_decl_ref.append(saml.AuthnContextDeclRef())
        self.context.comparison = "exact"

        new_context = samlp.requested_authn_context_from_string(
            self.context.to_string())

        assert isinstance(new_context.authn_context_class_ref[0],
                                                        saml.AuthnContextClassRef)
        assert isinstance(new_context.authn_context_decl_ref[0],
                                                        saml.AuthnContextDeclRef)
        assert new_context.comparison == "exact"

    def testUsingTestData(self):
        """Test for requested_authn_context_from_string() using test data"""
        new_context = samlp.requested_authn_context_from_string(
            samlp_data.TEST_REQUESTED_AUTHN_CONTEXT)

        assert isinstance(new_context.authn_context_class_ref[0],
                                                        saml.AuthnContextClassRef)
        assert isinstance(new_context.authn_context_decl_ref[0],
                                                        saml.AuthnContextDeclRef)
        assert new_context.comparison == "exact"


class TestAuthnRequest:

    def setup_class(self):
        self.ar = samlp.AuthnRequest()

    def testAccessors(self):
        """Test for AuthnRequest accessors"""
        self.ar.id = "request id"
        self.ar.version = saml2.VERSION
        self.ar.issue_instant = "2007-09-14T01:05:02Z"
        self.ar.destination = "http://www.example.com/Destination"
        self.ar.consent = saml.CONSENT_UNSPECIFIED
        self.ar.issuer = saml.Issuer()
        self.ar.signature = ds.Signature()
        self.ar.extensions = samlp.Extensions()

        self.ar.subject = saml.Subject()
        self.ar.name_id_policy = samlp.NameIDPolicy()
        self.ar.conditions = saml.Conditions()
        self.ar.requested_authn_context = samlp.RequestedAuthnContext()
        self.ar.scoping = samlp.Scoping()
        self.ar.force_authn = 'true'
        self.ar.is_passive = 'true'
        self.ar.assertion_consumer_service_index = "1"
        self.ar.assertion_consumer_service_url = "http://www.example.com/acs"
        self.ar.protocol_binding = saml2.BINDING_HTTP_POST
        self.ar.attribute_consuming_service_index = "2"
        self.ar.provider_name = "provider name"

        new_ar = samlp.authn_request_from_string(self.ar.to_string())
        assert new_ar.id == "request id"
        assert new_ar.version == saml2.VERSION
        assert new_ar.issue_instant == "2007-09-14T01:05:02Z"
        assert new_ar.destination == "http://www.example.com/Destination"
        assert new_ar.consent == saml.CONSENT_UNSPECIFIED
        assert isinstance(new_ar.issuer, saml.Issuer)
        assert isinstance(new_ar.signature, ds.Signature)
        assert isinstance(new_ar.extensions, samlp.Extensions)

        assert isinstance(new_ar.subject, saml.Subject)
        assert isinstance(new_ar.name_id_policy, samlp.NameIDPolicy)
        assert isinstance(new_ar.conditions, saml.Conditions)
        assert isinstance(new_ar.requested_authn_context,
                                                        samlp.RequestedAuthnContext)
        assert isinstance(new_ar.scoping, samlp.Scoping)
        assert new_ar.force_authn == 'true'
        assert new_ar.is_passive == 'true'
        assert new_ar.assertion_consumer_service_index == '1'
        assert new_ar.assertion_consumer_service_url == \
                                 'http://www.example.com/acs'
        assert new_ar.protocol_binding == saml2.BINDING_HTTP_POST
        assert new_ar.attribute_consuming_service_index == '2'
        assert new_ar.provider_name == "provider name"

    def testUsingTestData(self):
        """Test for authn_request_from_string() using test data"""
        new_ar = samlp.authn_request_from_string(samlp_data.TEST_AUTHN_REQUEST)
        assert new_ar.id == "request id"
        assert new_ar.version == saml2.VERSION
        assert new_ar.issue_instant == "2007-09-14T01:05:02Z"
        assert new_ar.destination == "http://www.example.com/Destination"
        assert new_ar.consent == saml.CONSENT_UNSPECIFIED
        assert isinstance(new_ar.issuer, saml.Issuer)
        assert isinstance(new_ar.signature, ds.Signature)
        assert isinstance(new_ar.extensions, samlp.Extensions)

        assert isinstance(new_ar.subject, saml.Subject)
        assert isinstance(new_ar.name_id_policy, samlp.NameIDPolicy)
        assert isinstance(new_ar.conditions, saml.Conditions)
        assert isinstance(new_ar.requested_authn_context,
                                                        samlp.RequestedAuthnContext)
        assert isinstance(new_ar.scoping, samlp.Scoping)
        assert new_ar.force_authn == 'true'
        assert new_ar.is_passive == 'true'
        assert new_ar.assertion_consumer_service_index == '1'
        assert new_ar.assertion_consumer_service_url == \
                                 'http://www.example.com/acs'
        assert new_ar.protocol_binding == saml2.BINDING_HTTP_POST
        assert new_ar.attribute_consuming_service_index == '2'
        assert new_ar.provider_name == "provider name"


class TestLogoutRequest:

    def setup_class(self):
        self.lr = samlp.LogoutRequest()

    def testAccessors(self):
        """Test for LogoutRequest accessors"""
        self.lr.id = "request id"
        self.lr.version = saml2.VERSION
        self.lr.issue_instant = "2007-09-14T01:05:02Z"
        self.lr.destination = "http://www.example.com/Destination"
        self.lr.consent = saml.CONSENT_UNSPECIFIED
        self.lr.issuer = saml.Issuer()
        self.lr.signature = ds.Signature()
        self.lr.extensions = samlp.Extensions()

        self.lr.not_on_or_after = "2007-10-14T01:05:02Z"
        self.lr.reason = "http://www.example.com/Reason"
        self.lr.base_id = saml.BaseID()
        self.lr.name_id = saml.NameID()
        self.lr.encrypted_id = saml.EncryptedID()
        self.lr.session_index = samlp.SessionIndex()

        new_lr = samlp.logout_request_from_string(self.lr.to_string())
        assert new_lr.id == "request id"
        assert new_lr.version == saml2.VERSION
        assert new_lr.issue_instant == "2007-09-14T01:05:02Z"
        assert new_lr.destination == "http://www.example.com/Destination"
        assert new_lr.consent == saml.CONSENT_UNSPECIFIED
        assert isinstance(new_lr.issuer, saml.Issuer)
        assert isinstance(new_lr.signature, ds.Signature)
        assert isinstance(new_lr.extensions, samlp.Extensions)
        assert new_lr.not_on_or_after == "2007-10-14T01:05:02Z"
        assert new_lr.reason == "http://www.example.com/Reason"
        assert isinstance(new_lr.base_id, saml.BaseID)
        assert isinstance(new_lr.name_id, saml.NameID)
        assert isinstance(new_lr.encrypted_id, saml.EncryptedID)
        assert isinstance(new_lr.session_index[0], samlp.SessionIndex)

    def testUsingTestData(self):
        """Test for logout_request_from_string() using test data"""
        new_lr = samlp.logout_request_from_string(samlp_data.TEST_LOGOUT_REQUEST)
        assert new_lr.id == "request id"
        assert new_lr.version == saml2.VERSION
        assert new_lr.issue_instant == "2007-09-14T01:05:02Z"
        assert new_lr.destination == "http://www.example.com/Destination"
        assert new_lr.consent == saml.CONSENT_UNSPECIFIED
        assert isinstance(new_lr.issuer, saml.Issuer)
        assert isinstance(new_lr.signature, ds.Signature)
        assert isinstance(new_lr.extensions, samlp.Extensions)
        assert new_lr.not_on_or_after == "2007-10-14T01:05:02Z"
        assert new_lr.reason == "http://www.example.com/Reason"
        assert isinstance(new_lr.base_id, saml.BaseID)
        assert isinstance(new_lr.name_id, saml.NameID)
        assert isinstance(new_lr.encrypted_id, saml.EncryptedID)
        assert isinstance(new_lr.session_index[0], samlp.SessionIndex)
        assert new_lr.session_index[0].text.strip() == "session index"


class TestLogoutResponse:
    
    def setup_class(self):
        self.lr = samlp.LogoutResponse()

    def testAccessors(self):
        """Test for LogoutResponse accessors"""
        self.lr.id = "response id"
        self.lr.in_response_to = "request id"
        self.lr.version = saml2.VERSION
        self.lr.issue_instant = "2007-09-14T01:05:02Z"
        self.lr.destination = "http://www.example.com/Destination"
        self.lr.consent = saml.CONSENT_UNSPECIFIED
        self.lr.issuer = saml.Issuer()
        self.lr.signature = ds.Signature()
        self.lr.extensions = samlp.Extensions()
        self.lr.status = samlp.Status()

        new_lr = samlp.logout_response_from_string(self.lr.to_string())
        assert new_lr.id == "response id"
        assert new_lr.in_response_to == "request id"
        assert new_lr.version == saml2.VERSION
        assert new_lr.issue_instant == "2007-09-14T01:05:02Z"
        assert new_lr.destination == "http://www.example.com/Destination"
        assert new_lr.consent == saml.CONSENT_UNSPECIFIED
        assert isinstance(new_lr.issuer, saml.Issuer)
        assert isinstance(new_lr.signature, ds.Signature)
        assert isinstance(new_lr.extensions, samlp.Extensions)
        assert isinstance(new_lr.status, samlp.Status)
        
    def testUsingTestData(self):
        """Test for logout_response_from_string() using test data"""
        new_lr = samlp.logout_response_from_string(
            samlp_data.TEST_LOGOUT_RESPONSE)
        assert new_lr.id == "response id"
        assert new_lr.in_response_to == "request id"
        assert new_lr.version == saml2.VERSION
        assert new_lr.issue_instant == "2007-09-14T01:05:02Z"
        assert new_lr.destination == "http://www.example.com/Destination"
        assert new_lr.consent == saml.CONSENT_UNSPECIFIED
        assert isinstance(new_lr.issuer, saml.Issuer)
        assert isinstance(new_lr.signature, ds.Signature)
        assert isinstance(new_lr.extensions, samlp.Extensions)
        assert isinstance(new_lr.status, samlp.Status)


########NEW FILE########
__FILENAME__ = test_05_md
#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2009 Ume University.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for saml2.md"""

__author__ = 'roland.hedberg@umu.se (Roland Hedberg)'

import unittest
try:
  from xml.etree import ElementTree
except ImportError:
  from elementtree import ElementTree

import saml2
import xmldsig as ds

from saml2 import saml
from saml2 import samlp
from saml2 import md 
from saml2.extension import idpdisc
from saml2.extension import shibmd

from saml2 import extension_element_to_element
import md_data, ds_data

class TestEndpointType:

  def setup_class(self):
    self.endpoint = md.EndpointType_()

  def testAccessors(self):
    """Test for EndpointType accessors"""
    self.endpoint.binding = saml2.BINDING_HTTP_POST
    self.endpoint.location = "http://www.example.com/endpoint"
    self.endpoint.response_location = "http://www.example.com/response"
    print self.endpoint.__class__.c_attributes.items()
    new_endpoint = md.endpoint_type__from_string(self.endpoint.to_string())
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

  def testUsingTestData(self):
    """Test for endpoint_type_from_string() using test data."""
    new_endpoint = md.endpoint_type__from_string(md_data.TEST_ENDPOINT)
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"
    

class TestIndexedEndpointType:

  def setup_class(self):
    self.i_e = md.IndexedEndpointType_()

  def testAccessors(self):
    """Test for IndexedEndpointType accessors"""
    self.i_e.binding = saml2.BINDING_HTTP_POST
    self.i_e.location = "http://www.example.com/endpoint"
    self.i_e.response_location = "http://www.example.com/response"
    self.i_e.index = "1"
    self.i_e.is_default = "false"
    new_i_e = md.indexed_endpoint_type__from_string(self.i_e.to_string())
    assert new_i_e.binding == saml2.BINDING_HTTP_POST
    assert new_i_e.location == "http://www.example.com/endpoint"
    assert new_i_e.response_location == "http://www.example.com/response"
    assert new_i_e.index == "1"
    assert new_i_e.is_default == "false"

  def testUsingTestData(self):
    """Test for indexed_endpoint_type_from_string() using test data."""
    new_i_e = md.indexed_endpoint_type__from_string(md_data.TEST_INDEXED_ENDPOINT)
    assert new_i_e.binding == saml2.BINDING_HTTP_POST
    assert new_i_e.location == "http://www.example.com/endpoint"
    assert new_i_e.response_location == "http://www.example.com/response"
    assert new_i_e.index == "1"
    assert new_i_e.is_default == "false"


class TestExtensions:

  def setup_class(self):
    self.extensions = md.Extensions()

  def testAccessors(self):
    """Test for Extensions accessors"""
    self.extensions.extension_elements.append(
      saml2.extension_element_from_string(
      """<?xml version='1.0' encoding='UTF-8'?>
      <hoge>fuga</hoge>
      """))
    new_extensions = md.extensions_from_string(self.extensions.to_string())
    assert new_extensions.extension_elements[0].tag == "hoge"
    assert new_extensions.extension_elements[0].text.strip() == "fuga"


class TestOrganizationName:

  def setup_class(self):
    self.organization_name = md.OrganizationName()

  def testAccessors(self):
    """Test for OrganizationName accessors"""
    self.organization_name.lang = "en"
    self.organization_name.text = "SIOS Technology, Inc."
    new_organization_name = md.organization_name_from_string(
      self.organization_name.to_string())
    assert new_organization_name.lang == "en"
    assert new_organization_name.text.strip() == "SIOS Technology, Inc."

  def testUsingTestData(self):
    """Test for organization_name_from_string() using test data."""
    new_organization_name = md.organization_name_from_string(
      md_data.TEST_ORGANIZATION_NAME)
    print new_organization_name.keyswv()
    assert new_organization_name.lang == "se"
    assert new_organization_name.text.strip() == "Catalogix"


class TestOrganizationDisplayName:

  def setup_class(self):
    self.od_name = md.OrganizationDisplayName()

  def testAccessors(self):
    """Test for OrganizationDisplayName accessors"""
    self.od_name.lang = "en"
    self.od_name.text = "SIOS"
    new_od_name = md.organization_display_name_from_string(
      self.od_name.to_string())
    assert new_od_name.lang == "en"
    assert new_od_name.text.strip() == "SIOS"

  def testUsingTestData(self):
    """Test for organization_display_name_from_string() using test data."""
    new_od_name = md.organization_display_name_from_string(
      md_data.TEST_ORGANIZATION_DISPLAY_NAME)
    assert new_od_name.lang == "se"
    assert new_od_name.text.strip() == "Catalogix"


class TestOrganizationURL:

  def setup_class(self):
    self.organization_url = md.OrganizationURL()

  def testAccessors(self):
    """Test for OrganizationURL accessors"""
    self.organization_url.lang = "ja"
    self.organization_url.text = "http://www.example.com/"
    print self.organization_url.to_string()
    new_organization_url = md.organization_url_from_string(
      self.organization_url.to_string())
    assert new_organization_url.lang == "ja"
    assert new_organization_url.text.strip() == "http://www.example.com/"

  def testUsingTestData(self):
    """Test for organization_url_from_string() using test data."""
    new_organization_url = md.organization_url_from_string(
      md_data.TEST_ORGANIZATION_URL)
    assert new_organization_url.lang == "no"
    assert new_organization_url.text.strip() == "http://www.example.com/"


class TestOrganization:

  def setup_class(self):
    self.organization = md.Organization()

  def testAccessors(self):
    """Test for Organization accessors"""
    self.organization.extensions = md.Extensions()
    self.organization.organization_name.append(
      md.organization_name_from_string(md_data.TEST_ORGANIZATION_NAME))
    self.organization.organization_display_name.append(
      md.organization_display_name_from_string(
      md_data.TEST_ORGANIZATION_DISPLAY_NAME))
    self.organization.organization_url.append(
      md.organization_url_from_string(md_data.TEST_ORGANIZATION_URL))
    new_organization = md.organization_from_string(self.organization.to_string())
    assert isinstance(new_organization.extensions, md.Extensions)
    assert isinstance(new_organization.organization_name[0],
                            md.OrganizationName)
    assert isinstance(new_organization.organization_display_name[0],
                            md.OrganizationDisplayName)
    assert isinstance(new_organization.organization_url[0],
                            md.OrganizationURL)
    assert new_organization.organization_name[0].text.strip() == "Catalogix"
    assert new_organization.organization_name[0].lang == "se"
    assert new_organization.organization_display_name[0].text.strip() == "Catalogix"
    assert new_organization.organization_display_name[0].lang == "se"
    assert new_organization.organization_url[0].text.strip() == "http://www.example.com/"
    assert new_organization.organization_url[0].lang == "no"
    

  def testUsingTestData(self):
    """Test for organization_from_string() using test data."""
    new_organization = md.organization_from_string(
      md_data.TEST_ORGANIZATION)
    assert isinstance(new_organization.extensions, md.Extensions)
    assert isinstance(new_organization.organization_name[0],
                            md.OrganizationName)
    assert isinstance(new_organization.organization_display_name[0],
                            md.OrganizationDisplayName)
    assert isinstance(new_organization.organization_url[0],
                            md.OrganizationURL)
    assert new_organization.organization_name[0].text.strip() == "Catalogix AB"
    assert new_organization.organization_name[0].lang == "se"
    assert new_organization.organization_display_name[0].text.strip() == "Catalogix AS"
    assert new_organization.organization_display_name[0].lang == "no"
    assert new_organization.organization_url[0].text.strip() == "http://www.example.com/"
    assert new_organization.organization_url[0].lang == "en"


class TestContactPerson:

  def setup_class(self):
    self.contact_person = md.ContactPerson()

  def testAccessors(self):
    """Test for ContactPerson accessors"""
    self.contact_person.contact_type = "technical"
    self.contact_person.extensions = md.Extensions()
    self.contact_person.company = md.Company(text="SIOS Technology, Inc.")
    self.contact_person.given_name = md.GivenName(text="Takashi")
    self.contact_person.sur_name = md.SurName(text="Matsuo")
    self.contact_person.email_address.append(
      md.EmailAddress(text="tmatsuo@example.com"))
    self.contact_person.email_address.append(
      md.EmailAddress(text="tmatsuo@shehas.net"))
    self.contact_person.telephone_number.append(
      md.TelephoneNumber(text="00-0000-0000"))
    new_contact_person = md.contact_person_from_string(
      self.contact_person.to_string())
    assert new_contact_person.contact_type == "technical"
    assert isinstance(new_contact_person.extensions, md.Extensions)
    assert new_contact_person.company.text.strip() == "SIOS Technology, Inc."
    assert new_contact_person.given_name.text.strip() == "Takashi"
    assert new_contact_person.sur_name.text.strip() == "Matsuo"
    assert new_contact_person.email_address[0].text.strip() == "tmatsuo@example.com"
    assert new_contact_person.email_address[1].text.strip() == "tmatsuo@shehas.net"
    assert new_contact_person.telephone_number[0].text.strip() == "00-0000-0000"

  def testUsingTestData(self):
    """Test for contact_person_from_string() using test data."""
    new_contact_person = md.contact_person_from_string(
      md_data.TEST_CONTACT_PERSON)
    assert new_contact_person.contact_type == "technical"
    assert isinstance(new_contact_person.extensions, md.Extensions)
    assert new_contact_person.company.text.strip() == "SIOS Technology, Inc."
    assert new_contact_person.given_name.text.strip() == "Takashi"
    assert new_contact_person.sur_name.text.strip() == "Matsuo"
    assert new_contact_person.email_address[0].text.strip() == "tmatsuo@example.com"
    assert new_contact_person.email_address[1].text.strip() == "tmatsuo@shehas.net"
    assert new_contact_person.telephone_number[0].text.strip() == "00-0000-0000"

class TestAdditionalMetadataLocation:

  def setup_class(self):
    self.additional_metadata_location = md.AdditionalMetadataLocation()

  def testAccessors(self):
    """Test for AdditionalMetadataLocation accessors"""
    self.additional_metadata_location.namespace = (
      "http://www.example.com/namespace")
    self.additional_metadata_location.text = (
      "http://www.example.com/AdditionalMetadataLocation")
    new_additional_metadata_location = md.additional_metadata_location_from_string(
      self.additional_metadata_location.to_string())
    assert new_additional_metadata_location.namespace == "http://www.example.com/namespace"
    assert new_additional_metadata_location.text.strip() == "http://www.example.com/AdditionalMetadataLocation"

  def testUsingTestData(self):
    """Test for additional_metadata_location_from_string() using test data."""
    new_additional_metadata_location = md.additional_metadata_location_from_string(
      md_data.TEST_ADDITIONAL_METADATA_LOCATION)
    assert new_additional_metadata_location.namespace == "http://www.example.com/namespace"
    assert new_additional_metadata_location.text.strip() == "http://www.example.com/AdditionalMetadataLocation"

# class TestKeySize:
# 
#   def setup_class(self):
#     self.key_size = md.KeySize()
# 
#   def testAccessors(self):
#     """Test for KeySize accessors"""
#     self.key_size.text = "128"
#     new_key_size = md.key_size_from_string(self.key_size.to_string())
#     assert new_key_size.text.strip() == "128"
# 
#   def testUsingTestData(self):
#     """Test for key_size_from_string() using test data."""
#     new_key_size = md.key_size_from_string(md_data.TEST_KEY_SIZE)
#     assert new_key_size.text.strip() == "128"
    

# class TestOAEPparams:
# 
#   def setup_class(self):
#     self.oaep_params = md.OAEPparams()
# 
#   def testAccessors(self):
#     """Test for OAEPparams accessors"""
#     self.oaep_params.text = "9lWu3Q=="
#     new_oaep_params = md.oae_pparams_from_string(self.oaep_params.to_string())
#     assert new_oaep_params.text.strip() == "9lWu3Q=="
# 
#   def testUsingTestData(self):
#     """Test for oae_pparams_from_string() using test data."""
#     new_oaep_params = md.oae_pparams_from_string(md_data.TEST_OAEP_PARAMS)
#     assert new_oaep_params.text.strip() == "9lWu3Q=="


class TestEncryptionMethod:

  def setup_class(self):
    self.encryption_method = md.EncryptionMethod()

  def testAccessors(self):
    """Test for EncryptionMethod accessors"""
    self.encryption_method.algorithm = (
      "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p")
    new_encryption_method = md.encryption_method_from_string(
      self.encryption_method.to_string())
    assert new_encryption_method.algorithm == "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p"

  def testUsingTestData(self):
    """Test for encryption_method_from_string() using test data."""
    new_encryption_method = md.encryption_method_from_string(
      md_data.TEST_ENCRYPTION_METHOD)
    assert new_encryption_method.algorithm == "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p"
    assert new_encryption_method.oae_pparams.text.strip() == "9lWu3Q=="


class TestKeyDescriptor:

  def setup_class(self):
    self.key_descriptor = md.KeyDescriptor()

  def testAccessors(self):
    """Test for KeyDescriptor accessors"""

    self.key_descriptor.use = "signing"
    self.key_descriptor.key_info = ds.key_info_from_string(
      ds_data.TEST_KEY_INFO)
    self.key_descriptor.encryption_method.append(md.encryption_method_from_string(
      md_data.TEST_ENCRYPTION_METHOD))
    new_key_descriptor = md.key_descriptor_from_string(
      self.key_descriptor.to_string())
    assert new_key_descriptor.use == "signing"
    assert isinstance(new_key_descriptor.key_info, ds.KeyInfo)
    assert isinstance(new_key_descriptor.encryption_method[0], 
                            md.EncryptionMethod)

  def testUsingTestData(self):
    """Test for key_descriptor_from_string() using test data."""
    new_key_descriptor = md.key_descriptor_from_string(
      md_data.TEST_KEY_DESCRIPTOR)
    assert new_key_descriptor.use == "signing"
    assert isinstance(new_key_descriptor.key_info, ds.KeyInfo)
    assert isinstance(new_key_descriptor.encryption_method[0],
                            md.EncryptionMethod)


class TestRoleDescriptor:
  def setup_class(self):
    self.role_descriptor = md.RoleDescriptor()

  def testAccessors(self):
    """Test for RoleDescriptor accessors"""
    self.role_descriptor.id = "ID"
    self.role_descriptor.valid_until = "2008-09-14T01:05:02Z"
    self.role_descriptor.cache_duration = "10:00:00:00"
    self.role_descriptor.protocol_support_enumeration = samlp.NAMESPACE
    self.role_descriptor.error_url = "http://www.example.com/errorURL"
    self.role_descriptor.signature = ds.Signature()
    self.role_descriptor.extensions = md.Extensions()
    self.role_descriptor.key_descriptor.append(md.key_descriptor_from_string(
      md_data.TEST_KEY_DESCRIPTOR))
    self.role_descriptor.organization = md.Organization()
    self.role_descriptor.contact_person.append(md.ContactPerson())

    new_role_descriptor = md.role_descriptor_from_string(
      self.role_descriptor.to_string())
    assert new_role_descriptor.id == "ID"
    assert new_role_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_role_descriptor.cache_duration == "10:00:00:00"
    assert new_role_descriptor.protocol_support_enumeration == samlp.NAMESPACE
    assert new_role_descriptor.error_url == "http://www.example.com/errorURL"
    assert isinstance(new_role_descriptor.signature, ds.Signature)
    assert isinstance(new_role_descriptor.extensions, md.Extensions)
    assert isinstance(new_role_descriptor.key_descriptor[0],
                            md.KeyDescriptor)
    assert isinstance(new_role_descriptor.organization, md.Organization)
    assert isinstance(new_role_descriptor.contact_person[0],
                            md.ContactPerson)

  def testUsingTestData(self):
    """Test for role_descriptor_from_string() using test data."""
    new_role_descriptor = md.role_descriptor_from_string(
      md_data.TEST_ROLE_DESCRIPTOR)
    assert new_role_descriptor.id == "ID"
    assert new_role_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_role_descriptor.cache_duration == "10:00:00:00"
    assert new_role_descriptor.protocol_support_enumeration == samlp.NAMESPACE
    assert new_role_descriptor.error_url == "http://www.example.com/errorURL"
    assert isinstance(new_role_descriptor.signature, ds.Signature)
    assert isinstance(new_role_descriptor.extensions, md.Extensions)
    assert isinstance(new_role_descriptor.key_descriptor[0],
                            md.KeyDescriptor)
    assert isinstance(new_role_descriptor.organization, md.Organization)
    assert isinstance(new_role_descriptor.contact_person[0],
                            md.ContactPerson)

# class TestSSODescriptor:
#   def setup_class(self):
#     self.sso_descriptor = md.SSODescriptorType_()
# 
#   def testAccessors(self):
#     """Test for SSODescriptorType accessors"""
#     self.sso_descriptor.id = "ID"
#     self.sso_descriptor.valid_until = "2008-09-14T01:05:02Z"
#     self.sso_descriptor.cache_duration = "10:00:00:00"
#     self.sso_descriptor.protocol_support_enumeration = samlp.NAMESPACE
#     self.sso_descriptor.error_url = "http://www.example.com/errorURL"
#     self.sso_descriptor.signature = ds.Signature()
#     self.sso_descriptor.extensions = md.Extensions()
#     self.sso_descriptor.key_descriptor.append(md.key_descriptor_from_string(
#       md_data.TEST_KEY_DESCRIPTOR))
#     self.sso_descriptor.organization = md.Organization()
#     self.sso_descriptor.contact_person.append(md.ContactPerson())
#     self.sso_descriptor.artifact_resolution_service.append(
#       md.ArtifactResolutionService())
#     self.sso_descriptor.single_logout_service.append(
#       md.SingleLogoutService())
#     self.sso_descriptor.manage_name_id_service.append(
#       md.ManageNameIDService())
#     self.sso_descriptor.name_id_format.append(
#       md.NameIDFormat())
# 
#     new_sso_descriptor = md.sso_descriptor_type__from_string(
#       self.sso_descriptor.to_string())
#     assert new_sso_descriptor.id == "ID"
#     assert new_sso_descriptor.valid_until == "2008-09-14T01:05:02Z"
#     assert new_sso_descriptor.cache_duration == "10:00:00:00"
#     assert new_sso_descriptor.protocol_support_enumeration == samlp.NAMESPACE
#     assert new_sso_descriptor.error_url == "http://www.example.com/errorURL"
#     assert isinstance(new_sso_descriptor.signature, ds.Signature)
#     assert isinstance(new_sso_descriptor.extensions, md.Extensions)
#     assert isinstance(new_sso_descriptor.key_descriptor[0],
#                             md.KeyDescriptor)
#     assert isinstance(new_sso_descriptor.organization, md.Organization)
#     assert isinstance(new_sso_descriptor.contact_person[0],
#                             md.ContactPerson)
#     assert isinstance(new_sso_descriptor.artifact_resolution_service[0],
#                             md.ArtifactResolutionService)
#     assert isinstance(new_sso_descriptor.single_logout_service[0],
#                             md.SingleLogoutService)
#     assert isinstance(new_sso_descriptor.manage_name_id_service[0],
#                             md.ManageNameIDService)
#     assert isinstance(new_sso_descriptor.name_id_format[0],
#                             md.NameIDFormat)
# 

class TestArtifactResolutionService:

  def setup_class(self):
    self.i_e = md.ArtifactResolutionService()

  def testAccessors(self):
    """Test for ArtifactResolutionService accessors"""
    self.i_e.binding = saml2.BINDING_HTTP_POST
    self.i_e.location = "http://www.example.com/endpoint"
    self.i_e.response_location = "http://www.example.com/response"
    self.i_e.index = "1"
    self.i_e.is_default = "false"
    new_i_e = md.artifact_resolution_service_from_string(self.i_e.to_string())
    assert new_i_e.binding == saml2.BINDING_HTTP_POST
    assert new_i_e.location == "http://www.example.com/endpoint"
    assert new_i_e.response_location == "http://www.example.com/response"
    assert new_i_e.index == "1"
    assert new_i_e.is_default == "false"

  def testUsingTestData(self):
    """Test for artifact_resolution_service_from_string() using test data."""
    new_i_e = md.artifact_resolution_service_from_string(
      md_data.TEST_ARTIFACT_RESOLUTION_SERVICE)
    assert new_i_e.binding == saml2.BINDING_HTTP_POST
    assert new_i_e.location == "http://www.example.com/endpoint"
    assert new_i_e.response_location == "http://www.example.com/response"
    assert new_i_e.index == "1"
    assert new_i_e.is_default == "false"


class TestSingleLogout:

  def setup_class(self):
    self.endpoint = md.SingleLogoutService()

  def testAccessors(self):
    """Test for SingleLogoutService accessors"""
    self.endpoint.binding = saml2.BINDING_HTTP_POST
    self.endpoint.location = "http://www.example.com/endpoint"
    self.endpoint.response_location = "http://www.example.com/response"
    new_endpoint = md.single_logout_service_from_string(self.endpoint.to_string())
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

  def testUsingTestData(self):
    """Test for single_logout_service_from_string() using test data."""
    new_endpoint = md.single_logout_service_from_string(
      md_data.TEST_SINGLE_LOGOUT_SERVICE)
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"
    

class TestManageNameIDService:

  def setup_class(self):
    self.endpoint = md.ManageNameIDService()

  def testAccessors(self):
    """Test for ManageNameIDService accessors"""
    self.endpoint.binding = saml2.BINDING_HTTP_POST
    self.endpoint.location = "http://www.example.com/endpoint"
    self.endpoint.response_location = "http://www.example.com/response"
    new_endpoint = md.manage_name_id_service_from_string(self.endpoint.to_string())
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

  def testUsingTestData(self):
    """Test for manage_name_id_service_from_string() using test data."""
    new_endpoint = md.manage_name_id_service_from_string(
      md_data.TEST_MANAGE_NAMEID_SERVICE)
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"
    

class TestNameIDFormat:

  def setup_class(self):
    self.name_id_format = md.NameIDFormat()

  def testAccessors(self):
    """Test for NameIDFormat accessors"""
    self.name_id_format.text = saml.NAMEID_FORMAT_EMAILADDRESS
    new_name_id_format = md.name_id_format_from_string(
      self.name_id_format.to_string())
    assert new_name_id_format.text.strip() == saml.NAMEID_FORMAT_EMAILADDRESS

  def testUsingTestData(self):
    """Test for name_id_format_from_string() using test data."""
    new_name_id_format = md.name_id_format_from_string(
      md_data.TEST_NAME_ID_FORMAT)
    assert new_name_id_format.text.strip() == saml.NAMEID_FORMAT_EMAILADDRESS
  

class TestSingleSignOnService:

  def setup_class(self):
    self.endpoint = md.SingleSignOnService()

  def testAccessors(self):
    """Test for SingelSignOnService accessors"""
    self.endpoint.binding = saml2.BINDING_HTTP_POST
    self.endpoint.location = "http://www.example.com/endpoint"
    self.endpoint.response_location = "http://www.example.com/response"
    new_endpoint = md.single_sign_on_service_from_string(self.endpoint.to_string())
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

  def testUsingTestData(self):
    """Test for SingelSignOn_service_from_string() using test data."""
    new_endpoint = md.single_sign_on_service_from_string(
      md_data.TEST_SINGLE_SIGN_ON_SERVICE)
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

class TestNameIDMappingService:

  def setup_class(self):
    self.endpoint = md.NameIDMappingService()

  def testAccessors(self):
    """Test for NameIDMappingService accessors"""
    self.endpoint.binding = saml2.BINDING_HTTP_POST
    self.endpoint.location = "http://www.example.com/endpoint"
    self.endpoint.response_location = "http://www.example.com/response"
    new_endpoint = md.name_id_mapping_service_from_string(self.endpoint.to_string())
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

  def testUsingTestData(self):
    """Test for name_id_mapping_service_from_string() using test data."""
    new_endpoint = md.name_id_mapping_service_from_string(
      md_data.TEST_NAME_ID_MAPPING_SERVICE)
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

class TestAssertionIDRequestService:

  def setup_class(self):
    self.endpoint = md.AssertionIDRequestService()

  def testAccessors(self):
    """Test for AssertionIDRequestService accessors"""
    self.endpoint.binding = saml2.BINDING_HTTP_POST
    self.endpoint.location = "http://www.example.com/endpoint"
    self.endpoint.response_location = "http://www.example.com/response"
    new_endpoint = md.assertion_id_request_service_from_string(
      self.endpoint.to_string())
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

  def testUsingTestData(self):
    """Test for assertion_id_request_service_from_string() using test data."""
    new_endpoint = md.assertion_id_request_service_from_string(
      md_data.TEST_ASSERTION_ID_REQUEST_SERVICE)
    assert new_endpoint.binding == saml2.BINDING_HTTP_POST
    assert new_endpoint.location == "http://www.example.com/endpoint"
    assert new_endpoint.response_location == "http://www.example.com/response"

class TestAttributeProfile:

  def setup_class(self):
    self.attribute_profile = md.AttributeProfile()

  def testAccessors(self):
    """Test for AttributeProfile accessors"""
    self.attribute_profile.text = saml.PROFILE_ATTRIBUTE_BASIC
    new_attribute_profile = md.attribute_profile_from_string(
      self.attribute_profile.to_string())
    assert new_attribute_profile.text.strip() == saml.PROFILE_ATTRIBUTE_BASIC

  def testUsingTestData(self):
    """Test for name_id_format_from_string() using test data."""
    new_attribute_profile = md.attribute_profile_from_string(
      md_data.TEST_ATTRIBUTE_PROFILE)
    assert new_attribute_profile.text.strip() == saml.PROFILE_ATTRIBUTE_BASIC
  

class TestIDPSSODescriptor:
  def setup_class(self):
    self.idp_sso_descriptor = md.IDPSSODescriptor()

  def testAccessors(self):
    """Test for IDPSSODescriptor accessors"""
    self.idp_sso_descriptor.id = "ID"
    self.idp_sso_descriptor.valid_until = "2008-09-14T01:05:02Z"
    self.idp_sso_descriptor.cache_duration = "10:00:00:00"
    self.idp_sso_descriptor.protocol_support_enumeration = \
                                                         samlp.NAMESPACE
    self.idp_sso_descriptor.error_url = "http://www.example.com/errorURL"
    self.idp_sso_descriptor.signature = ds.Signature()
    self.idp_sso_descriptor.extensions = md.Extensions()
    self.idp_sso_descriptor.key_descriptor.append(md.key_descriptor_from_string(
      md_data.TEST_KEY_DESCRIPTOR))
    self.idp_sso_descriptor.organization = md.Organization()
    self.idp_sso_descriptor.contact_person.append(md.ContactPerson())
    self.idp_sso_descriptor.artifact_resolution_service.append(
      md.ArtifactResolutionService())
    self.idp_sso_descriptor.single_logout_service.append(
      md.SingleLogoutService())
    self.idp_sso_descriptor.manage_name_id_service.append(
      md.ManageNameIDService())
    self.idp_sso_descriptor.name_id_format.append(
      md.NameIDFormat())
    self.idp_sso_descriptor.want_authn_requests_signed = 'true'
    self.idp_sso_descriptor.single_sign_on_service.append(
      md.SingleSignOnService())
    self.idp_sso_descriptor.name_id_mapping_service.append(
      md.NameIDMappingService())
    self.idp_sso_descriptor.assertion_id_request_service.append(
      md.AssertionIDRequestService())
    self.idp_sso_descriptor.attribute_profile.append(
      md.AttributeProfile())
    self.idp_sso_descriptor.attribute.append(saml.Attribute())

    new_idp_sso_descriptor = md.idpsso_descriptor_from_string(
      self.idp_sso_descriptor.to_string())
    assert new_idp_sso_descriptor.id == "ID"
    assert new_idp_sso_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_idp_sso_descriptor.cache_duration == "10:00:00:00"
    assert new_idp_sso_descriptor.protocol_support_enumeration == samlp.NAMESPACE
    assert new_idp_sso_descriptor.error_url == "http://www.example.com/errorURL"
    assert isinstance(new_idp_sso_descriptor.signature, ds.Signature)
    assert isinstance(new_idp_sso_descriptor.extensions, md.Extensions)
    assert isinstance(new_idp_sso_descriptor.key_descriptor[0],
                            md.KeyDescriptor)
    assert isinstance(new_idp_sso_descriptor.organization,
                            md.Organization)
    assert isinstance(new_idp_sso_descriptor.contact_person[0],
                            md.ContactPerson)
    assert isinstance(
      new_idp_sso_descriptor.artifact_resolution_service[0],
      md.ArtifactResolutionService)
    assert isinstance(new_idp_sso_descriptor.single_logout_service[0],
                            md.SingleLogoutService)
    assert isinstance(new_idp_sso_descriptor.manage_name_id_service[0],
                            md.ManageNameIDService)
    assert isinstance(new_idp_sso_descriptor.name_id_format[0],
                            md.NameIDFormat)
    assert new_idp_sso_descriptor.want_authn_requests_signed == "true"
    assert isinstance(new_idp_sso_descriptor.single_sign_on_service[0],
                            md.SingleSignOnService)
    assert isinstance(new_idp_sso_descriptor.name_id_mapping_service[0],
                            md.NameIDMappingService)
    assert isinstance(
      new_idp_sso_descriptor.assertion_id_request_service[0],
      md.AssertionIDRequestService)
    assert isinstance(new_idp_sso_descriptor.attribute_profile[0],
                            md.AttributeProfile)
    assert isinstance(new_idp_sso_descriptor.attribute[0],
                            saml.Attribute)

  def testUsingTestData(self):
    """Test for idpsso_descriptor_from_string() using test data."""
    new_idp_sso_descriptor = md.idpsso_descriptor_from_string(
      md_data.TEST_IDP_SSO_DESCRIPTOR)
    assert new_idp_sso_descriptor.id == "ID"
    assert new_idp_sso_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_idp_sso_descriptor.cache_duration == "10:00:00:00"
    assert new_idp_sso_descriptor.protocol_support_enumeration == samlp.NAMESPACE
    assert new_idp_sso_descriptor.error_url == "http://www.example.com/errorURL"
    assert isinstance(new_idp_sso_descriptor.signature, ds.Signature)
    assert isinstance(new_idp_sso_descriptor.extensions, md.Extensions)
    assert isinstance(new_idp_sso_descriptor.key_descriptor[0],
                            md.KeyDescriptor)
    assert isinstance(new_idp_sso_descriptor.organization,
                            md.Organization)
    assert isinstance(new_idp_sso_descriptor.contact_person[0],
                            md.ContactPerson)
    assert isinstance(
      new_idp_sso_descriptor.artifact_resolution_service[0],
      md.ArtifactResolutionService)
    assert isinstance(new_idp_sso_descriptor.single_logout_service[0],
                            md.SingleLogoutService)
    assert isinstance(new_idp_sso_descriptor.manage_name_id_service[0],
                            md.ManageNameIDService)
    assert isinstance(new_idp_sso_descriptor.name_id_format[0],
                            md.NameIDFormat)
    assert new_idp_sso_descriptor.want_authn_requests_signed == "true"
    assert isinstance(new_idp_sso_descriptor.single_sign_on_service[0],
                            md.SingleSignOnService)
    assert isinstance(new_idp_sso_descriptor.name_id_mapping_service[0],
                            md.NameIDMappingService)
    assert isinstance(
      new_idp_sso_descriptor.assertion_id_request_service[0],
      md.AssertionIDRequestService)
    assert isinstance(new_idp_sso_descriptor.attribute_profile[0],
                            md.AttributeProfile)
    assert isinstance(new_idp_sso_descriptor.attribute[0],
                            saml.Attribute)

  def testUsingScope(self):
      descriptor = md.IDPSSODescriptor()
      scope = shibmd.Scope()
      scope.text = "example.org"
      scope.regexp = "false"
      descriptor.extensions = md.Extensions()
      ext = saml2.element_to_extension_element(scope)
      descriptor.extensions.extension_elements.append(ext)
      exts = descriptor.extensions
      assert len(exts.extension_elements) == 1
      elem = exts.extension_elements[0]
      inst = saml2.extension_element_to_element(elem,
                                                shibmd.ELEMENT_FROM_STRING,
                                                namespace=shibmd.NAMESPACE)
      assert isinstance(inst, shibmd.Scope)
      assert inst.text == "example.org"
      assert inst.regexp == "false"
      
class TestAssertionConsumerService:

  def setup_class(self):
    self.i_e = md.AssertionConsumerService()

  def testAccessors(self):
    """Test for AssertionConsumerService accessors"""
    self.i_e.binding = saml2.BINDING_HTTP_POST
    self.i_e.location = "http://www.example.com/endpoint"
    self.i_e.response_location = "http://www.example.com/response"
    self.i_e.index = "1"
    self.i_e.is_default = "false"
    new_i_e = md.assertion_consumer_service_from_string(self.i_e.to_string())
    assert new_i_e.binding == saml2.BINDING_HTTP_POST
    assert new_i_e.location == "http://www.example.com/endpoint"
    assert new_i_e.response_location == "http://www.example.com/response"
    assert new_i_e.index == "1"
    assert new_i_e.is_default == "false"

  def testUsingTestData(self):
    """Test for assertion_consumer_service_from_string() using test data."""
    new_i_e = md.assertion_consumer_service_from_string(
      md_data.TEST_ASSERTION_CONSUMER_SERVICE)
    assert new_i_e.binding == saml2.BINDING_HTTP_POST
    assert new_i_e.location == "http://www.example.com/endpoint"
    assert new_i_e.response_location == "http://www.example.com/response"
    assert new_i_e.index == "1"
    assert new_i_e.is_default == "false"


class TestRequestedAttribute:

  def setup_class(self):
    self.requested_attribute = md.RequestedAttribute()

  def testAccessors(self):
    """Test for RequestedAttribute accessors"""
    assert isinstance(self.requested_attribute, saml.AttributeType_)
    assert isinstance(self.requested_attribute, md.RequestedAttribute)
    assert self.requested_attribute.is_required is None
    self.requested_attribute.is_required = "true"
    new_requested_attribute = md.requested_attribute_from_string(
      self.requested_attribute.to_string())
    assert new_requested_attribute.is_required == "true"
    assert isinstance(new_requested_attribute, saml.AttributeType_)
    assert isinstance(new_requested_attribute, md.RequestedAttribute)

  def testUsingTestData(self):
    """Test for requested_attribute_from_string() using test data."""
    new_requested_attribute = md.requested_attribute_from_string(
      md_data.TEST_REQUESTED_ATTRIBUTE)
    assert new_requested_attribute.is_required == "true"
    assert isinstance(new_requested_attribute, saml.AttributeType_)
    assert isinstance(new_requested_attribute, md.RequestedAttribute)


class TestServiceName:

  def setup_class(self):
    self.service_name = md.ServiceName()

  def testAccessors(self):
    """Test for ServiceName accessors"""
    self.service_name.lang = "en"
    self.service_name.text = "SIOS mail"
    new_service_name = md.service_name_from_string(self.service_name.to_string())
    assert new_service_name.lang == "en"
    assert new_service_name.text.strip() == "SIOS mail"

  def testUsingTestData(self):
    """Test for organization_name_from_string() using test data."""
    new_service_name = md.service_name_from_string(md_data.TEST_SERVICE_NAME)
    assert new_service_name.lang == "en"
    assert new_service_name.text.strip() == "Catalogix Whois"


class TestServiceDescription:

  def setup_class(self):
    self.service_description = md.ServiceDescription()

  def testAccessors(self):
    """Test for ServiceDescription accessors"""
    self.service_description.lang = "en"
    self.service_description.text = "SIOS mail service"
    new_service_description = md.service_description_from_string(
      self.service_description.to_string())
    assert new_service_description.lang == "en"
    assert new_service_description.text.strip() == "SIOS mail service"

  def testUsingTestData(self):
    """Test for organization_name_from_string() using test data."""
    new_service_description = md.service_description_from_string(
      md_data.TEST_SERVICE_DESCRIPTION)
    assert new_service_description.lang == "en"
    assert new_service_description.text.strip() == "Catalogix Whois Service"


class TestAttributeConsumingService:

  def setup_class(self):
    self.attribute_consuming_service = md.AttributeConsumingService()

  def testAccessors(self):
    """Test for AttributeConsumingService accessors"""
    self.attribute_consuming_service.service_name.append(md.ServiceName())
    self.attribute_consuming_service.service_description.append(
      md.ServiceDescription())
    self.attribute_consuming_service.requested_attribute.append(
      md.RequestedAttribute())
    self.attribute_consuming_service.index = "1"
    self.attribute_consuming_service.is_default = "true"

    new_attribute_consuming_service = md.attribute_consuming_service_from_string(
      self.attribute_consuming_service.to_string())
    assert new_attribute_consuming_service.index == "1"
    assert new_attribute_consuming_service.is_default == "true"
    assert isinstance(new_attribute_consuming_service.service_name[0],
                 md.ServiceName)
    assert isinstance(
      new_attribute_consuming_service.service_description[0],
      md.ServiceDescription)
    assert isinstance(
      new_attribute_consuming_service.requested_attribute[0],
      md.RequestedAttribute)

  def testUsingTestData(self):
    """Test for attribute_consuming_service_from_string() using test data."""
    new_attribute_consuming_service = md.attribute_consuming_service_from_string(
      md_data.TEST_ATTRIBUTE_CONSUMING_SERVICE)
    assert new_attribute_consuming_service.index == "1"
    assert new_attribute_consuming_service.is_default == "true"
    assert isinstance(new_attribute_consuming_service.service_name[0],
                 md.ServiceName)
    assert isinstance(
      new_attribute_consuming_service.service_description[0],
      md.ServiceDescription)
    assert isinstance(
      new_attribute_consuming_service.requested_attribute[0],
      md.RequestedAttribute)


class TestSPSSODescriptor:
  def setup_class(self):
    self.sp_sso_descriptor = md.SPSSODescriptor()

  def testAccessors(self):
    """Test for SPSSODescriptor accessors"""
    self.sp_sso_descriptor.id = "ID"
    self.sp_sso_descriptor.valid_until = "2008-09-14T01:05:02Z"
    self.sp_sso_descriptor.cache_duration = "10:00:00:00"
    self.sp_sso_descriptor.protocol_support_enumeration = \
                                                         samlp.NAMESPACE
    self.sp_sso_descriptor.error_url = "http://www.example.com/errorURL"
    self.sp_sso_descriptor.signature = ds.Signature()
    self.sp_sso_descriptor.extensions = md.Extensions()
    self.sp_sso_descriptor.key_descriptor.append(md.key_descriptor_from_string(
      md_data.TEST_KEY_DESCRIPTOR))
    self.sp_sso_descriptor.organization = md.Organization()
    self.sp_sso_descriptor.contact_person.append(md.ContactPerson())
    self.sp_sso_descriptor.artifact_resolution_service.append(
      md.ArtifactResolutionService())
    self.sp_sso_descriptor.single_logout_service.append(
      md.SingleLogoutService())
    self.sp_sso_descriptor.manage_name_id_service.append(
      md.ManageNameIDService())
    self.sp_sso_descriptor.name_id_format.append(
      md.NameIDFormat())
    self.sp_sso_descriptor.authn_requests_signed = "true"
    self.sp_sso_descriptor.want_assertions_signed = "true"
    self.sp_sso_descriptor.assertion_consumer_service.append(
      md.AssertionConsumerService())
    self.sp_sso_descriptor.attribute_consuming_service.append(
      md.AttributeConsumingService())

    print self.sp_sso_descriptor
    new_sp_sso_descriptor = md.spsso_descriptor_from_string(
      self.sp_sso_descriptor.to_string())
    print new_sp_sso_descriptor
    assert new_sp_sso_descriptor.id == "ID"
    assert new_sp_sso_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_sp_sso_descriptor.cache_duration == "10:00:00:00"
    assert new_sp_sso_descriptor.protocol_support_enumeration == samlp.NAMESPACE
    assert new_sp_sso_descriptor.error_url == "http://www.example.com/errorURL"
    assert isinstance(new_sp_sso_descriptor.signature, ds.Signature)
    assert isinstance(new_sp_sso_descriptor.extensions, md.Extensions)
    assert isinstance(new_sp_sso_descriptor.key_descriptor[0],
                            md.KeyDescriptor)
    assert isinstance(new_sp_sso_descriptor.organization,
                            md.Organization)
    assert isinstance(new_sp_sso_descriptor.contact_person[0],
                            md.ContactPerson)
    assert isinstance(
      new_sp_sso_descriptor.artifact_resolution_service[0],
      md.ArtifactResolutionService)
    assert isinstance(new_sp_sso_descriptor.single_logout_service[0],
                            md.SingleLogoutService)
    assert isinstance(new_sp_sso_descriptor.manage_name_id_service[0],
                            md.ManageNameIDService)
    assert isinstance(new_sp_sso_descriptor.name_id_format[0],
                            md.NameIDFormat)
    assert new_sp_sso_descriptor.authn_requests_signed == "true"
    assert new_sp_sso_descriptor.want_assertions_signed == "true"
    assert isinstance(
      new_sp_sso_descriptor.assertion_consumer_service[0],
      md.AssertionConsumerService)
    assert isinstance(
      new_sp_sso_descriptor.attribute_consuming_service[0],
      md.AttributeConsumingService)

  def testUsingTestData(self):
    """Test for spsso_descriptor_from_string() using test data."""
    new_sp_sso_descriptor = md.spsso_descriptor_from_string(
      md_data.TEST_SP_SSO_DESCRIPTOR)
    assert new_sp_sso_descriptor.id == "ID"
    assert new_sp_sso_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_sp_sso_descriptor.cache_duration == "10:00:00:00"
    assert new_sp_sso_descriptor.protocol_support_enumeration == samlp.NAMESPACE
    assert new_sp_sso_descriptor.error_url == "http://www.example.com/errorURL"
    assert isinstance(new_sp_sso_descriptor.signature, ds.Signature)
    assert isinstance(new_sp_sso_descriptor.extensions, md.Extensions)
    print new_sp_sso_descriptor.extensions.__dict__
    assert len(new_sp_sso_descriptor.extensions.extension_elements) == 2
    for eelem in new_sp_sso_descriptor.extensions.extension_elements:
        print "EE",eelem.__dict__
        dp = extension_element_to_element(eelem, idpdisc.ELEMENT_FROM_STRING,
                                            idpdisc.NAMESPACE)
        print "DP",dp.c_tag, dp.c_namespace,dp.__dict__
        assert isinstance(dp, idpdisc.DiscoveryResponse)
    assert isinstance(new_sp_sso_descriptor.key_descriptor[0],
                            md.KeyDescriptor)
    assert isinstance(new_sp_sso_descriptor.organization,
                            md.Organization)
    assert isinstance(new_sp_sso_descriptor.contact_person[0],
                            md.ContactPerson)
    assert isinstance(
      new_sp_sso_descriptor.artifact_resolution_service[0],
      md.ArtifactResolutionService)
    assert isinstance(new_sp_sso_descriptor.single_logout_service[0],
                            md.SingleLogoutService)
    assert isinstance(new_sp_sso_descriptor.manage_name_id_service[0],
                            md.ManageNameIDService)
    assert isinstance(new_sp_sso_descriptor.name_id_format[0],
                            md.NameIDFormat)
    assert new_sp_sso_descriptor.authn_requests_signed == "true"
    assert new_sp_sso_descriptor.want_assertions_signed == "true"
    assert isinstance(
      new_sp_sso_descriptor.assertion_consumer_service[0],
      md.AssertionConsumerService)
    assert isinstance(
      new_sp_sso_descriptor.attribute_consuming_service[0],
      md.AttributeConsumingService)


class TestEntityDescriptor:
  def setup_class(self):
    self.entity_descriptor = md.EntityDescriptor()

  def testAccessors(self):
    """Test for RoleDescriptor accessors"""
    self.entity_descriptor.id = "ID"
    self.entity_descriptor.entity_id = "entityID"
    self.entity_descriptor.valid_until = "2008-09-14T01:05:02Z"
    self.entity_descriptor.cache_duration = "10:00:00:00"

    self.entity_descriptor.signature = ds.Signature()
    self.entity_descriptor.extensions = md.Extensions()
    self.entity_descriptor.role_descriptor.append(md.RoleDescriptor())
    self.entity_descriptor.idpsso_descriptor.append(md.IDPSSODescriptor())
    self.entity_descriptor.spsso_descriptor.append(md.SPSSODescriptor())
    self.entity_descriptor.organization = md.Organization()
    self.entity_descriptor.contact_person.append(md.ContactPerson())
    self.entity_descriptor.additional_metadata_location.append(
      md.AdditionalMetadataLocation())

    new_entity_descriptor = md.entity_descriptor_from_string(
      self.entity_descriptor.to_string())
    assert new_entity_descriptor.id == "ID"
    assert new_entity_descriptor.entity_id == "entityID"
    assert new_entity_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_entity_descriptor.cache_duration == "10:00:00:00"
    assert isinstance(new_entity_descriptor.signature, ds.Signature)
    assert isinstance(new_entity_descriptor.extensions, md.Extensions)
    assert isinstance(new_entity_descriptor.role_descriptor[0],
                            md.RoleDescriptor)
    assert isinstance(new_entity_descriptor.idpsso_descriptor[0],
                            md.IDPSSODescriptor)
    assert isinstance(new_entity_descriptor.spsso_descriptor[0],
                            md.SPSSODescriptor)
    assert isinstance(new_entity_descriptor.organization,
                            md.Organization)
    assert isinstance(new_entity_descriptor.contact_person[0],
                            md.ContactPerson)
    assert isinstance(
      new_entity_descriptor.additional_metadata_location[0],
      md.AdditionalMetadataLocation)

  def testUsingTestData(self):
    """Test for entity_descriptor_from_string() using test data."""
    new_entity_descriptor = md.entity_descriptor_from_string(
      md_data.TEST_ENTITY_DESCRIPTOR)
    assert new_entity_descriptor.id == "ID"
    assert new_entity_descriptor.entity_id == "entityID"
    assert new_entity_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_entity_descriptor.cache_duration == "10:00:00:00"
    assert isinstance(new_entity_descriptor.signature, ds.Signature)
    assert isinstance(new_entity_descriptor.extensions, md.Extensions)
    assert isinstance(new_entity_descriptor.role_descriptor[0],
                            md.RoleDescriptor)
    assert isinstance(new_entity_descriptor.idpsso_descriptor[0],
                            md.IDPSSODescriptor)
    assert isinstance(new_entity_descriptor.spsso_descriptor[0],
                            md.SPSSODescriptor)
    assert isinstance(new_entity_descriptor.organization,
                            md.Organization)
    assert isinstance(new_entity_descriptor.contact_person[0],
                            md.ContactPerson)
    assert isinstance(new_entity_descriptor.additional_metadata_location[0],
                            md.AdditionalMetadataLocation)


class TestEntitiesDescriptor:
  def setup_class(self):
    self.entities_descriptor = md.EntitiesDescriptor()

  def testAccessors(self):
    """Test for EntitiesDescriptor accessors"""
    self.entities_descriptor.id = "ID"
    self.entities_descriptor.name = "name"
    self.entities_descriptor.valid_until = "2008-09-14T01:05:02Z"
    self.entities_descriptor.cache_duration = "10:00:00:00"

    self.entities_descriptor.signature = ds.Signature()
    self.entities_descriptor.extensions = md.Extensions()
    self.entities_descriptor.entity_descriptor.append(md.EntityDescriptor())
    self.entities_descriptor.entities_descriptor.append(
      md.EntitiesDescriptor())

    new_entities_descriptor = md.entities_descriptor_from_string(
      self.entities_descriptor.to_string())
    assert new_entities_descriptor.id == "ID"
    assert new_entities_descriptor.name == "name"
    assert new_entities_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_entities_descriptor.cache_duration == "10:00:00:00"
    assert isinstance(new_entities_descriptor.signature, ds.Signature)
    assert isinstance(new_entities_descriptor.extensions, md.Extensions)
    assert isinstance(new_entities_descriptor.entity_descriptor[0],
                            md.EntityDescriptor)
    assert isinstance(new_entities_descriptor.entities_descriptor[0],
                            md.EntitiesDescriptor)

  def testUsingTestData(self):
    """Test for entities_descriptor_from_string() using test data."""
    new_entities_descriptor = md.entities_descriptor_from_string(
      md_data.TEST_ENTITIES_DESCRIPTOR)
    assert new_entities_descriptor.id == "ID"
    assert new_entities_descriptor.name == "name"
    assert new_entities_descriptor.valid_until == "2008-09-14T01:05:02Z"
    assert new_entities_descriptor.cache_duration == "10:00:00:00"
    assert isinstance(new_entities_descriptor.signature, ds.Signature)
    assert isinstance(new_entities_descriptor.extensions, md.Extensions)
    assert isinstance(new_entities_descriptor.entity_descriptor[0],
                            md.EntityDescriptor)
    assert isinstance(new_entities_descriptor.entities_descriptor[0],
                            md.EntitiesDescriptor)



########NEW FILE########
__FILENAME__ = test_10_time_util
#!/usr/bin/env python

import calendar
import datetime
import time
from saml2.time_util import f_quotient, modulo, parse_duration, add_duration
from saml2.time_util import str_to_time, instant, valid, in_a_while
from saml2.time_util import before, after, not_before, not_on_or_after


def test_f_quotient():
    assert f_quotient(-1, 3) == -1
    assert f_quotient(0, 3) == 0
    assert f_quotient(1, 3) == 0
    assert f_quotient(2, 3) == 0
    assert f_quotient(3, 3) == 1
    assert f_quotient(3.123, 3) == 1


def test_modulo():
    assert modulo(-1, 3) == 2
    assert modulo(0, 3) == 0
    assert modulo(1, 3) == 1
    assert modulo(2, 3) == 2
    assert modulo(3, 3) == 0
    x = 3.123
    assert modulo(3.123, 3) == x - 3


def test_f_quotient_2():
    assert f_quotient(0, 1, 13) == -1
    for i in range(1, 13):
        assert f_quotient(i, 1, 13) == 0
    assert f_quotient(13, 1, 13) == 1
    assert f_quotient(13.123, 1, 13) == 1


def test_modulo_2():
    assert modulo(0, 1, 13) == 12
    for i in range(1, 13):
        assert modulo(i, 1, 13) == i
    assert modulo(13, 1, 13) == 1
    #x = 0.123
    #assert modulo(13+x, 1, 13) == 1+x


def test_parse_duration():
    (sign, d) = parse_duration("P1Y3M5DT7H10M3.3S")
    assert sign == "+"
    assert d['tm_sec'] == 3.3
    assert d['tm_mon'] == 3
    assert d['tm_hour'] == 7
    assert d['tm_mday'] == 5
    assert d['tm_year'] == 1
    assert d['tm_min'] == 10


def test_parse_duration2():
    (sign, d) = parse_duration("PT30M")
    assert sign == "+"
    assert d['tm_sec'] == 0
    assert d['tm_mon'] == 0
    assert d['tm_hour'] == 0
    assert d['tm_mday'] == 0
    assert d['tm_year'] == 0
    assert d['tm_min'] == 30


PATTERNS = {
    "P3Y6M4DT12H30M5S": {'tm_sec': 5, 'tm_hour': 12, 'tm_mday': 4,
                         'tm_year': 3, 'tm_mon': 6, 'tm_min': 30},
    "P23DT23H": {'tm_sec': 0, 'tm_hour': 23, 'tm_mday': 23, 'tm_year': 0,
                 'tm_mon': 0, 'tm_min': 0},
    "P4Y": {'tm_sec': 0, 'tm_hour': 0, 'tm_mday': 0, 'tm_year': 4,
            'tm_mon': 0, 'tm_min': 0},
    "P1M": {'tm_sec': 0, 'tm_hour': 0, 'tm_mday': 0, 'tm_year': 0,
            'tm_mon': 1, 'tm_min': 0},
    "PT1M": {'tm_sec': 0, 'tm_hour': 0, 'tm_mday': 0, 'tm_year': 0,
             'tm_mon': 0, 'tm_min': 1},
    "P0.5Y": {'tm_sec': 0, 'tm_hour': 0, 'tm_mday': 0, 'tm_year': 0.5,
              'tm_mon': 0, 'tm_min': 0},
    "P0,5Y": {'tm_sec': 0, 'tm_hour': 0, 'tm_mday': 0, 'tm_year': 0.5,
              'tm_mon': 0, 'tm_min': 0},
    "PT36H": {'tm_sec': 0, 'tm_hour': 36, 'tm_mday': 0, 'tm_year': 0,
              'tm_mon': 0, 'tm_min': 0},
    "P1DT12H": {'tm_sec': 0, 'tm_hour': 12, 'tm_mday': 1, 'tm_year': 0,
                'tm_mon': 0, 'tm_min': 0}
}


def test_parse_duration_n():
    for dur, _val in PATTERNS.items():
        (sign, d) = parse_duration(dur)
        assert d == _val

def test_add_duration_1():
    #2000-01-12T12:13:14Z	P1Y3M5DT7H10M3S	2001-04-17T19:23:17Z    
    t = add_duration(str_to_time("2000-01-12T12:13:14Z"), "P1Y3M5DT7H10M3S")
    assert t.tm_year == 2001
    assert t.tm_mon == 4
    assert t.tm_mday == 17
    assert t.tm_hour == 19
    assert t.tm_min == 23
    assert t.tm_sec == 17


def test_add_duration_2():
    #2000-01-12 PT33H   2000-01-13
    t = add_duration(str_to_time("2000-01-12T00:00:00Z"), "PT33H")
    assert t.tm_year == 2000
    assert t.tm_mon == 1
    assert t.tm_mday == 14
    assert t.tm_hour == 9
    assert t.tm_min == 0
    assert t.tm_sec == 0


def test_str_to_time():
    t = calendar.timegm(str_to_time("2000-01-12T00:00:00Z"))
    #TODO: Find all instances of time.mktime(.....)
    #t = time.mktime(str_to_time("2000-01-12T00:00:00Z"))
    #assert t == 947631600.0
    #TODO: add something to show how this time was arrived at
    # do this as an external method in the 
    assert t == 947635200


def test_instant():
    inst = str_to_time(instant())
    now = time.gmtime()

    assert now >= inst


def test_valid():
    assert valid("2000-01-12T00:00:00Z") == False
    current_year = datetime.datetime.today().year
    assert valid("%d-01-12T00:00:00Z" % (current_year + 1)) == True
    this_instance = instant()
    time.sleep(1)
    assert valid(this_instance) == False  # unless on a very fast machine :-)
    soon = in_a_while(seconds=10)
    assert valid(soon) == True


def test_timeout():
    soon = in_a_while(seconds=1)
    time.sleep(2)
    assert valid(soon) == False


def test_before():
    current_year = datetime.datetime.today().year
    assert before("%d-01-01T00:00:00Z" % (current_year - 1)) == False
    assert before("%d-01-01T00:00:00Z" % (current_year + 1)) == True


def test_after():
    current_year = datetime.datetime.today().year
    assert after("%d-01-01T00:00:00Z" % (current_year + 1)) == False
    assert after("%d-01-01T00:00:00Z" % (current_year - 1)) == True


def test_not_before():
    current_year = datetime.datetime.today().year
    assert not_before("%d-01-01T00:00:00Z" % (current_year + 1)) == False
    assert not_before("%d-01-01T00:00:00Z" % (current_year - 1)) == True


def test_not_on_or_after():
    current_year = datetime.datetime.today().year
    assert not_on_or_after("%d-01-01T00:00:00Z" % (current_year + 1)) == True
    assert not_on_or_after("%d-01-01T00:00:00Z" % (current_year - 1)) == False


if __name__ == "__main__":
    test_parse_duration_n()

########NEW FILE########
__FILENAME__ = test_12_s_utils
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import zlib
import base64
import gzip

from saml2 import make_instance
from saml2 import s_utils as utils
from saml2 import saml
from saml2 import samlp
from saml2 import md

from saml2.s_utils import do_attribute_statement

from saml2.sigver import make_temp

from saml2.saml import Attribute, NAME_FORMAT_URI, AttributeValue

from py.test import raises

from pathutils import full_path

SUCCESS_STATUS = """<?xml version=\'1.0\' encoding=\'UTF-8\'?>
<ns0:Status xmlns:ns0="urn:oasis:names:tc:SAML:2.0:protocol"><ns0:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success" /></ns0:Status>"""

ERROR_STATUS = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:Status xmlns:ns0="urn:oasis:names:tc:SAML:2.0:protocol"><ns0:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Responder"><ns0:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:UnknownPrincipal" /></ns0:StatusCode><ns0:StatusMessage>Error resolving principal</ns0:StatusMessage></ns0:Status>"""


def _eq(l1,l2):
    return set(l1) == set(l2)

def _oeq(l1,l2):
    if len(l1) != len(l2):
        print "Different number of items"
        return False
    for item in l1:
        if item not in l2:
            print "%s not in l2" % (item,)
            for ite in l2:
                print "\t%s" % (ite,)
            return False
    return True
    
def test_inflate_then_deflate():
    str = """Selma Lagerlf (1858-1940) was born in stra Emterwik, Vrmland, 
    Sweden. She was brought up on Mrbacka, the family estate, which she did 
    not leave until 1881, when she went to a teachers' college at Stockholm"""
    
    interm = utils.deflate_and_base64_encode(str)
    bis = utils.decode_base64_and_inflate(interm)    
    assert bis == str
    
def test_status_success():
    status = utils.success_status_factory()
    status_text = "%s" % status
    assert status_text == SUCCESS_STATUS
    assert status.status_code.value == samlp.STATUS_SUCCESS
    
def test_error_status():
    status = utils.status_message_factory("Error resolving principal",
                                        samlp.STATUS_UNKNOWN_PRINCIPAL,
                                        samlp.STATUS_RESPONDER)
        
    status_text = "%s" % status
    print status_text
    assert status_text == ERROR_STATUS

def test_status_from_exception():
    e = utils.UnknownPrincipal("Error resolving principal")
    stat = utils.error_status_factory(e)
    status_text = "%s" % stat
    print status_text
    assert status_text == ERROR_STATUS
    
def test_attribute_sn():
    attr = utils.do_attributes({"surName":("Jeter", "")})
    assert len(attr) == 1
    print attr
    inst = attr[0]
    assert inst.name == "surName"
    assert len(inst.attribute_value) == 1
    av = inst.attribute_value[0]
    assert av.text == "Jeter"

def test_attribute_age():
    attr = utils.do_attributes({"age":(37, "")})
    
    assert len(attr) == 1
    inst = attr[0]
    print inst
    assert inst.name == "age"
    assert len(inst.attribute_value) == 1
    av = inst.attribute_value[0]
    assert av.text == "37"
    assert av.get_type() == "xs:integer"

def test_attribute_onoff():
    attr = utils.do_attributes({"onoff":(False, "")})
    
    assert len(attr) == 1
    inst = attr[0]
    print inst
    assert inst.name == "onoff"
    assert len(inst.attribute_value) == 1
    av = inst.attribute_value[0]
    assert av.text == "false"
    assert av.get_type() == "xs:boolean"

def test_attribute_base64():
    b64sl = base64.b64encode("Selma Lagerlf")
    attr = utils.do_attributes({"name":(b64sl, "xs:base64Binary")})
    
    assert len(attr) == 1
    inst = attr[0]
    print inst
    assert inst.name == "name"
    assert len(inst.attribute_value) == 1
    av = inst.attribute_value[0]
    assert av.get_type() == "xs:base64Binary"
    assert av.text.strip() == b64sl
    
def test_attribute_statement():
    statement = do_attribute_statement({"surName":("Jeter", ""),
                                        "givenName":("Derek", "")})
    print statement
    assert statement.keyswv() == ["attribute"]
    assert len(statement.attribute) == 2
    attr0 = statement.attribute[0]
    assert _eq(attr0.keyswv(), ["name","attribute_value"])
    assert len(attr0.attribute_value) == 1
    attr1 = statement.attribute[1]
    assert _eq(attr1.keyswv(), ["name","attribute_value"])
    assert len(attr1.attribute_value) == 1
    if attr0.name == "givenName":
        assert attr0.attribute_value[0].text == "Derek"
        assert attr1.name == "surName"
        assert attr1.attribute_value[0].text == "Jeter"
    else:
        assert attr0.name == "surName"
        assert attr0.attribute_value[0].text == "Jeter"
        assert attr1.name == "givenName"
        assert attr1.attribute_value[0].text == "Derek"

def test_audience():
    aud_restr = utils.factory(saml.AudienceRestriction,
                    audience=utils.factory(saml.Audience,text="urn:foo:bar"))
            
    assert aud_restr.keyswv() == ["audience"]
    assert aud_restr.audience.text == "urn:foo:bar"
    
def test_conditions():
    conditions = utils.factory(saml.Conditions,
                    not_before="2009-10-30T07:58:10.852Z",
                    not_on_or_after="2009-10-30T08:03:10.852Z", 
                    audience_restriction=[utils.factory(saml.AudienceRestriction,
                                        audience=utils.factory(saml.Audience,
                                                        text="urn:foo:bar"))])
                    
    assert _eq(conditions.keyswv(), ["not_before", "not_on_or_after",
                                "audience_restriction"])
    assert conditions.not_before == "2009-10-30T07:58:10.852Z" 
    assert conditions.not_on_or_after == "2009-10-30T08:03:10.852Z"
    assert conditions.audience_restriction[0].audience.text == "urn:foo:bar"
    
def test_value_1():
    #FriendlyName="givenName" Name="urn:oid:2.5.4.42" 
    # NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"
    attribute = utils.factory(saml.Attribute, name="urn:oid:2.5.4.42",
                                name_format=NAME_FORMAT_URI)
    assert _eq(attribute.keyswv(),["name","name_format"])
    assert attribute.name == "urn:oid:2.5.4.42"
    assert attribute.name_format == saml.NAME_FORMAT_URI

def test_value_2():
    attribute = utils.factory(saml.Attribute, name="urn:oid:2.5.4.42",
                            name_format=NAME_FORMAT_URI, 
                            friendly_name="givenName")
    assert _eq(attribute.keyswv(),["name","name_format","friendly_name"])
    assert attribute.name == "urn:oid:2.5.4.42"
    assert attribute.name_format == NAME_FORMAT_URI
    assert attribute.friendly_name == "givenName"

def test_value_3():
    attribute = utils.factory(saml.Attribute, 
                                attribute_value=[utils.factory(
                                            saml.AttributeValue, text="Derek")],
                                name="urn:oid:2.5.4.42",
                                name_format=NAME_FORMAT_URI,
                                friendly_name="givenName")

    assert _eq(attribute.keyswv(),["name", "name_format",
                                    "friendly_name", "attribute_value"])
    assert attribute.name == "urn:oid:2.5.4.42"
    assert attribute.name_format == NAME_FORMAT_URI
    assert attribute.friendly_name == "givenName"
    assert len(attribute.attribute_value) == 1
    assert attribute.attribute_value[0].text == "Derek"

def test_value_4():
    attribute = utils.factory(saml.Attribute, 
                            attribute_value=[utils.factory(
                                        saml.AttributeValue, text="Derek")],
                            friendly_name="givenName")

    assert _eq(attribute.keyswv(),["friendly_name", "attribute_value"])
    assert attribute.friendly_name == "givenName"
    assert len(attribute.attribute_value) == 1
    assert attribute.attribute_value[0].text == "Derek"

def test_do_attribute_statement_0():
    statement = do_attribute_statement({"vo_attr":("foobar", "")})

    assert statement.keyswv() == ["attribute"]
    assert len(statement.attribute) == 1
    attr0 = statement.attribute[0]
    assert _eq(attr0.keyswv(), ["name","attribute_value"])
    assert attr0.name == "vo_attr"
    assert len(attr0.attribute_value) == 1
    assert attr0.attribute_value[0].text == "foobar"

def test_do_attribute_statement():
    statement = do_attribute_statement({"surName":("Jeter", ""),
                                        "givenName":(["Derek",
                                                    "Sanderson"], "")})

    assert statement.keyswv() == ["attribute"]
    assert len(statement.attribute) == 2
    attr0 = statement.attribute[0]
    assert _eq(attr0.keyswv(), ["name","attribute_value"])
    attr1 = statement.attribute[1]
    assert _eq(attr1.keyswv(), ["name","attribute_value"])
    if attr0.name == "givenName":
        assert len(attr0.attribute_value) == 2
        assert _eq([av.text for av in attr0.attribute_value],
                    ["Derek","Sanderson"])
        assert attr1.name == "surName"
        assert attr1.attribute_value[0].text == "Jeter"
        assert len(attr1.attribute_value) == 1
    else:
        assert attr0.name == "surName"
        assert attr0.attribute_value[0].text == "Jeter"
        assert len(attr0.attribute_value) == 1
        assert attr1.name == "givenName"
        assert len(attr1.attribute_value) == 2
        assert _eq([av.text for av in attr1.attribute_value],
                    ["Derek","Sanderson"])
    
def test_do_attribute_statement_multi():
    statement = do_attribute_statement(
                {( "urn:oid:1.3.6.1.4.1.5923.1.1.1.7",
                    "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                    "eduPersonEntitlement"):("Jeter", "")})

    assert statement.keyswv() == ["attribute"]
    assert len(statement.attribute)
    assert _eq(statement.attribute[0].keyswv(),
                ["name","name_format","friendly_name","attribute_value"])
    attribute = statement.attribute[0]
    assert attribute.name == "urn:oid:1.3.6.1.4.1.5923.1.1.1.7"
    assert attribute.name_format == (
                "urn:oasis:names:tc:SAML:2.0:attrname-format:uri")
    assert attribute.friendly_name == "eduPersonEntitlement"

def test_subject():
    subject = utils.factory(saml.Subject, text="_aaa", 
                            name_id=saml.NameID(
                                        text=saml.NAMEID_FORMAT_TRANSIENT))

    assert _eq(subject.keyswv(),["text", "name_id"])
    assert subject.text == "_aaa"
    assert subject.name_id.text == saml.NAMEID_FORMAT_TRANSIENT

# ---------------------------------------------------------------------------

def test_parse_attribute_map():
    (forward, backward) = utils.parse_attribute_map([full_path("attribute.map")])
    
    assert _eq(forward.keys(), backward.values())
    assert _eq(forward.values(), backward.keys())
    print forward.keys()
    assert _oeq(forward.keys(), [
            ('urn:oid:1.3.6.1.4.1.5923.1.1.1.7', NAME_FORMAT_URI), 
            ('urn:oid:0.9.2342.19200300.100.1.1', NAME_FORMAT_URI), 
            ('urn:oid:1.3.6.1.4.1.5923.1.1.1.1', NAME_FORMAT_URI), 
            ('urn:oid:2.5.4.42', NAME_FORMAT_URI),
            ('urn:oid:2.5.4.4', NAME_FORMAT_URI),
            ('urn:oid:0.9.2342.19200300.100.1.3', NAME_FORMAT_URI), 
            ('urn:oid:2.5.4.12', NAME_FORMAT_URI)])
    assert _eq(forward.keys(), [
            ('urn:oid:1.3.6.1.4.1.5923.1.1.1.7', NAME_FORMAT_URI), 
            ('urn:oid:0.9.2342.19200300.100.1.1', NAME_FORMAT_URI), 
            ('urn:oid:1.3.6.1.4.1.5923.1.1.1.1', NAME_FORMAT_URI), 
            ('urn:oid:2.5.4.42', NAME_FORMAT_URI),
            ('urn:oid:2.5.4.4', NAME_FORMAT_URI),
            ('urn:oid:0.9.2342.19200300.100.1.3', NAME_FORMAT_URI), 
            ('urn:oid:2.5.4.12', NAME_FORMAT_URI)])
    assert _eq(backward.keys(),["surName","givenName","title","uid","mail",
                                    "eduPersonAffiliation",
                                    "eduPersonEntitlement"])
                                    

def test_identity_attribute_0():
    (forward, backward) = utils.parse_attribute_map([full_path("attribute.map")])
    a = Attribute(name="urn:oid:2.5.4.4", name_format=NAME_FORMAT_URI,
                    friendly_name="surName")
    
    assert utils.identity_attribute("name",a,forward) == "urn:oid:2.5.4.4"
    assert utils.identity_attribute("friendly",a,forward) == "surName"
                                    
def test_identity_attribute_1():
    (forward, backward) = utils.parse_attribute_map([full_path("attribute.map")])
    a = Attribute(name="urn:oid:2.5.4.4", name_format=NAME_FORMAT_URI)
    
    assert utils.identity_attribute("name",a,forward) == "urn:oid:2.5.4.4"
    assert utils.identity_attribute("friendly",a,forward) == "surName"

def test_identity_attribute_2():
    (forward, backward) = utils.parse_attribute_map([full_path("attribute.map")])
    a = Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI)
    
    assert utils.identity_attribute("name",a,forward) == "urn:oid:2.5.4.5"
    # if there would be a map it would be serialNumber
    assert utils.identity_attribute("friendly",a,forward) == "urn:oid:2.5.4.5"

def test_identity_attribute_3():
    a = Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI)
    
    assert utils.identity_attribute("name",a) == "urn:oid:2.5.4.5"
    # if there would be a map it would be serialNumber
    assert utils.identity_attribute("friendly",a) == "urn:oid:2.5.4.5"

def test_identity_attribute_4():
    a = Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                    friendly_name="serialNumber")
    
    assert utils.identity_attribute("name",a) == "urn:oid:2.5.4.5"
    # if there would be a map it would be serialNumber
    assert utils.identity_attribute("friendly",a) == "serialNumber"
        
def _givenName(a):
    assert a["name"] == "urn:oid:2.5.4.42"
    assert a["friendly_name"] == "givenName"
    assert len(a["attribute_value"]) == 1
    assert a["attribute_value"] == [{"text":"Derek"}]

def _surName(a):
    assert a["name"] == "urn:oid:2.5.4.4"
    assert a["friendly_name"] == "surName"
    assert len(a["attribute_value"]) == 1
    assert a["attribute_value"] == [{"text":"Jeter"}]
        
def test_nameformat_email():
    assert utils.valid_email("foo@example.com")
    assert utils.valid_email("a@b.com")
    assert utils.valid_email("a@b.se")
    assert utils.valid_email("john@doe@johndoe.com") == False
    
def test_attribute():
    a = utils.factory(saml.Attribute,
                friendly_name="eduPersonScopedAffiliation",
                name="urn:oid:1.3.6.1.4.1.5923.1.1.1.9",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")
        
    assert _eq(a.keyswv(), ["friendly_name","name", "name_format"])

    a = utils.factory(saml.Attribute,
        friendly_name="eduPersonScopedAffiliation",    
        name="urn:oid:1.3.6.1.4.1.5923.1.1.1.9",
        name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
        attribute_value=[saml.AttributeValue(text="member@example.com")])
        
    assert _eq(a.keyswv(), ["friendly_name","name", "name_format",
                            "attribute_value"])
                            
def test_attribute_statement():
    statement = utils.factory( saml.Statement,
                attribute=[
                    utils.factory(saml.Attribute,
                                    attribute_value=[
                                        utils.factory(
                                            saml.AttributeValue,text="Derek")],
                                    friendly_name="givenName"),
                    utils.factory(saml.Attribute,
                                    attribute_value=[
                                        utils.factory(
                                            saml.AttributeValue,text="Jeter")], 
                                    friendly_name="surName"),
                ])
    assert statement.keyswv() == ["attribute"]
    assert len(statement.attribute) == 2
    
def test_subject_confirmation_data():
    s = utils.factory( saml.SubjectConfirmation,
                in_response_to="_12345678", 
                not_before="2010-02-11T07:30:00Z",
                not_on_or_after="2010-02-11T07:35:00Z",
                recipient="http://example.com/sp/",
                address="192.168.0.10")
                
    assert _eq(s.keyswv(),["in_response_to","not_before","not_on_or_after",
                        "recipient", "address"])
    
def test_subject_confirmation():
    s = utils.factory( saml.SubjectConfirmation,
                    method="urn:oasis:names:tc:SAML:2.0:profiles:SSO:browser",
                    base_id="1234",
                    name_id="abcd",
                    subject_confirmation_data=utils.factory(
                            saml.SubjectConfirmationData,
                            in_response_to="_1234567890",
                            recipient="http://example.com/sp/"))

    assert _eq(s.keyswv(),
                ["method","base_id","name_id","subject_confirmation_data"])
    assert s.method == "urn:oasis:names:tc:SAML:2.0:profiles:SSO:browser"
    

def test_authn_context_class_ref():
    a = utils.factory( saml.AuthnContextClassRef,
                text="urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified")
    assert a.keyswv() == ["text"]
    assert a.text == "urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified"
            
def test_authn_context():
    accr = utils.factory( saml.AuthnContext,
            text="urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified")
    a = utils.factory(saml.AuthnContext, authn_context_class_ref=accr)

    assert a.keyswv() == ["authn_context_class_ref"]
    
def test_authn_statement():
    accr = utils.factory( saml.AuthnContextClassRef,
            text="urn:oasis:names:tc:SAML:2.0:ac:classes:unspecified")
    ac = utils.factory( saml.AuthnContext,
            authn_context_class_ref=accr)
    ast = utils.factory( saml.AuthnStatement,
                        authn_instant="2010-03-10T12:33:00Z",
                        session_index="_12345",
                        session_not_on_or_after="2010-03-11T12:00:00Z",
                        authn_context=ac
                        )
    assert _eq(ast.keyswv(),["authn_instant","session_index",
                            "session_not_on_or_after",
                            "authn_context"])
                            
def test_signature():
    arr = ["foobar", "1234567890"]
    csum = utils.signature("abcdef", arr)
    arr.append(csum)
    
    assert utils.verify_signature("abcdef", arr)

    

########NEW FILE########
__FILENAME__ = test_13_validate
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import saml2
import xmldsig as ds

from saml2 import saml
from saml2 import samlp
from saml2 import md
from saml2.validate import valid_duration, MustValueError
from saml2.validate import valid_unsigned_short
from saml2.validate import valid_non_negative_integer
from saml2.validate import valid_string
from saml2.validate import valid_instance
from saml2.validate import valid_any_uri
from saml2.validate import NotValid
from saml2.validate import valid_anytype

from py.test import raises


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_duration():
    assert valid_duration("P1Y2M3DT10H30M")
    assert valid_duration("P1Y2M3DT10H30M1.567S")
    assert valid_duration("-P120D")
    assert valid_duration("P1347Y")
    assert valid_duration("P1347M")
    assert valid_duration("P1Y2MT2H")
    assert valid_duration("P0Y1347M")
    assert valid_duration("P0Y1347M0D")
    assert valid_duration("-P1347M")
    assert valid_duration("P1Y2MT2.5H")

    raises(NotValid, 'valid_duration("P-1347M")')
    raises(NotValid, ' valid_duration("P1Y2MT")')
    raises(NotValid, ' valid_duration("P1Y2MT2xH")')


def test_unsigned_short():
    assert valid_unsigned_short("1234")

    raises(NotValid, ' valid_unsigned_short("-1234")')
    raises(NotValid, ' valid_unsigned_short("1234567890")')


def test_valid_non_negative_integer():
    assert valid_non_negative_integer("1234567890")

    raises(NotValid, 'valid_non_negative_integer("-123")')
    raises(NotValid, 'valid_non_negative_integer("123.56")')
    assert valid_non_negative_integer("12345678901234567890")


def test_valid_string():
    assert valid_string(u'example')

    raises(NotValid, 'valid_string("02656c6c6f".decode("hex"))')


def test_valid_anyuri():
    assert valid_any_uri("urn:oasis:names:tc:SAML:2.0:attrname-format:uri")


def test_valid_instance():
    attr_statem = saml.AttributeStatement()
    text = ["value of test attribute",
            "value1 of test attribute",
            "value2 of test attribute",
            "value1 of test attribute2",
            "value2 of test attribute2", ]

    attr_statem.attribute.append(saml.Attribute())
    attr_statem.attribute.append(saml.Attribute())
    attr_statem.attribute[0].name = "testAttribute"
    attr_statem.attribute[0].name_format = saml.NAME_FORMAT_URI
    attr_statem.attribute[0].friendly_name = "test attribute"
    attr_statem.attribute[0].attribute_value.append(saml.AttributeValue())
    attr_statem.attribute[0].attribute_value[0].text = text[0]

    attr_statem.attribute[1].name = "testAttribute2"
    attr_statem.attribute[1].name_format = saml.NAME_FORMAT_UNSPECIFIED
    attr_statem.attribute[1].friendly_name = text[2]
    attr_statem.attribute[1].attribute_value.append(saml.AttributeValue())
    attr_statem.attribute[1].attribute_value[0].text = text[2]

    assert valid_instance(attr_statem)

    response = samlp.Response()
    response.id = "response id"
    response.in_response_to = "request id"
    response.version = saml2.VERSION
    response.issue_instant = "2007-09-14T01:05:02Z"
    response.destination = "http://www.example.com/Destination"
    response.consent = saml.CONSENT_UNSPECIFIED
    response.issuer = saml.Issuer()
    response.status = samlp.Status()
    response.assertion.append(saml.Assertion())

    raises(MustValueError, 'valid_instance(response)')


def test_valid_anytype():
    assert valid_anytype("130.239.16.3")
    assert valid_anytype("textstring")
    assert valid_anytype("12345678")
    assert valid_anytype("-1234")
    assert valid_anytype("P1Y2M3DT10H30M")
    assert valid_anytype("urn:oasis:names:tc:SAML:2.0:attrname-format:uri")


########NEW FILE########
__FILENAME__ = test_19_attribute_converter
#!/usr/bin/env python

from saml2 import attribute_converter, saml

from attribute_statement_data import *

from pathutils import full_path
from saml2.attribute_converter import AttributeConverterNOOP
from saml2.attribute_converter import to_local
from saml2.saml import attribute_from_string


def _eq(l1,l2):
    return set(l1) == set(l2)

BASIC_NF = 'urn:oasis:names:tc:SAML:2.0:attrname-format:basic'
URI_NF = 'urn:oasis:names:tc:SAML:2.0:attrname-format:uri'
SAML1 = 'urn:mace:shibboleth:1.0:attributeNamespace:uri'


def test_default():
    acs = attribute_converter.ac_factory()
    assert acs


class TestAC():
    def setup_class(self):
        self.acs = attribute_converter.ac_factory(full_path("attributemaps"))
        
    def test_setup(self):
        print self.acs
        assert len(self.acs) == 3
        assert _eq([a.name_format for a in self.acs],[BASIC_NF, URI_NF, SAML1] )

    def test_ava_fro_1(self):
        ats = saml.attribute_statement_from_string(STATEMENT1)
        #print ats
        ava = None

        for ac in self.acs:
            try:
                ava = ac.fro(ats)
            except attribute_converter.UnknownNameFormat:
                pass
            # break if we have something
            if ava:
                break
        print ava.keys()
        assert _eq(ava.keys(), ['givenName', 'displayName', 'uid',
                                'eduPersonNickname', 'street',
                                'eduPersonScopedAffiliation',
                                'employeeType', 'eduPersonAffiliation',
                                'eduPersonPrincipalName', 'sn', 'postalCode',
                                'physicalDeliveryOfficeName', 'ou',
                                'eduPersonTargetedID', 'cn'])

    def test_ava_fro_2(self):
        ats = saml.attribute_statement_from_string(STATEMENT2)
        #print ats
        ava = {}
        for ac in self.acs:
            ava.update(ac.fro(ats))

        print ava.keys()
        assert _eq(ava.keys(), ['eduPersonEntitlement', 'eduPersonAffiliation',
                                'uid', 'mail', 'givenName', 'sn'])

    def test_to_attrstat_1(self):
        ava = { "givenName": "Roland", "sn": "Hedberg" }
        
        statement = attribute_converter.from_local(self.acs, ava, BASIC_NF)
        
        assert statement is not None
        assert len(statement) == 2
        a0 = statement[0]
        a1 = statement[1]
        if a0.friendly_name == 'sn':
            assert a0.name == 'urn:mace:dir:attribute-def:sn'
            assert a0.name_format == BASIC_NF
            assert a1.friendly_name == "givenName"
            assert a1.name == 'urn:mace:dir:attribute-def:givenName'
            assert a1.name_format == BASIC_NF
        elif a0.friendly_name == 'givenname':
            assert a0.name == 'urn:mace:dir:attribute-def:givenName'
            assert a0.name_format == BASIC_NF
            assert a1.friendly_name == "sn"
            assert a1.name == 'urn:mace:dir:attribute-def:sn'
            assert a1.name_format == BASIC_NF
        else:
            assert False
        
    def test_to_attrstat_2(self):
        ava = { "givenName": "Roland", "surname": "Hedberg" }
        
        statement = attribute_converter.from_local(self.acs, ava, URI_NF)
                
        assert len(statement) == 2
        a0 = statement[0]
        a1 = statement[1]
        if a0.friendly_name == 'surname':
            assert a0.name == 'urn:oid:2.5.4.4'
            assert a0.name_format == URI_NF
            assert a1.friendly_name == "givenName"
            assert a1.name == 'urn:oid:2.5.4.42'
            assert a1.name_format == URI_NF
        elif a0.friendly_name == 'givenname':
            assert a0.name == 'urn:oid:2.5.4.42'
            assert a0.name_format == URI_NF
            assert a1.friendly_name == "surname"
            assert a1.name == 'urn:oid:2.5.4.4'
            assert a1.name_format == URI_NF
        else:
            assert False
                
    def test_to_local_name(self):
    
        attr = [
            saml.Attribute(
                friendly_name="surName",
                name="urn:oid:2.5.4.4",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
            saml.Attribute(
                friendly_name="efternamn",
                name="urn:oid:2.5.4.42",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
            saml.Attribute(
                friendly_name="titel",
                name="urn:oid:2.5.4.12",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")]
                
        lan = [attribute_converter.to_local_name(self.acs, a) for a in attr]
        
        assert _eq(lan, ['sn', 'givenName', 'title'])

    # def test_ava_fro_1(self):
    #
    #     attr = [saml.Attribute(friendly_name="surName",
    #             name="urn:oid:2.5.4.4",
    #             name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
    #         saml.Attribute(friendly_name="efternamn",
    #             name="urn:oid:2.5.4.42",
    #             name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
    #         saml.Attribute(friendly_name="titel",
    #             name="urn:oid:2.5.4.12",
    #             name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")]
    #
    #     result = attribute_converter.ava_fro(self.acs, attr)
    #
    #     print result
    #     assert result == {'givenName': [], 'sn': [], 'title': []}

    def test_to_local_name_from_basic(self):
        attr = [saml.Attribute(
                name="urn:mace:dir:attribute-def:eduPersonPrimaryOrgUnitDN")]

        lan = [attribute_converter.to_local_name(self.acs, a) for a in attr]

        assert _eq(lan, ['eduPersonPrimaryOrgUnitDN'])

    def test_to_and_for(self):
        ava = { "givenName": "Roland", "surname": "Hedberg" }

        basic_ac = [a for a in self.acs if a.name_format == BASIC_NF][0]

        attr_state = saml.AttributeStatement(basic_ac.to_(ava))

        oava = basic_ac.fro(attr_state)

        assert _eq(ava.keys(), oava.keys())

    def test_unspecified_name_format(self):
        ats = saml.attribute_statement_from_string(STATEMENT4)
        ava = to_local(self.acs, ats)
        assert ava == {'user_id': ['bob'], 'NameID': ['bobsnameagain']}

    def test_mixed_attributes_1(self):
        ats = saml.attribute_statement_from_string(STATEMENT_MIXED)
        ava = to_local(self.acs, ats)
        assert ava == {'eduPersonAffiliation': ['staff'],
                       'givenName': ['Roland'], 'sn': ['Hedberg'],
                       'uid': ['demouser'], 'user_id': ['bob']}

        # Allow unknown
        ava = to_local(self.acs, ats, True)
        assert ava == {'eduPersonAffiliation': ['staff'],
                       'givenName': ['Roland'], 'sn': ['Hedberg'],
                       'swissEduPersonHomeOrganizationType': ['others'],
                       'uid': ['demouser'], 'urn:example:com:foo': ['Thing'],
                       'user_id': ['bob']}


def test_noop_attribute_conversion():
    ava = {"urn:oid:2.5.4.4": "Roland", "urn:oid:2.5.4.42": "Hedberg" }
    aconv = AttributeConverterNOOP(URI_NF)
    res = aconv.to_(ava)

    print res
    assert len(res) == 2
    for attr in res:
        assert len(attr.attribute_value) == 1
        if attr.name == "urn:oid:2.5.4.42":
            assert attr.name_format == URI_NF
            assert attr.attribute_value[0].text == "Hedberg"
        elif attr.name == "urn:oid:2.5.4.4":
            assert attr.name_format == URI_NF
            assert attr.attribute_value[0].text == "Roland"


ava = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:Attribute xmlns:ns0="urn:oasis:names:tc:SAML:2.0:assertion" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" FriendlyName="schacHomeOrganization" Name="urn:oid:1.3.6.1.4.1.25178.1.2.9" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"><ns0:AttributeValue xsi:nil="true" xsi:type="xs:string">uu.se</ns0:AttributeValue></ns0:Attribute>"""


def test_schac():
    attr = attribute_from_string(ava)
    acs = attribute_converter.ac_factory()
    for ac in acs:
        try:
            res = ac.ava_from(attr)
            assert res[0] == "schacHomeOrganization"
        except KeyError:
            pass


if __name__ == "__main__":
    # t = TestAC()
    # t.setup_class()
    # t.test_mixed_attributes_1()
    test_schac()

########NEW FILE########
__FILENAME__ = test_20_assertion
# coding=utf-8
from saml2.authn_context import pword
from saml2.mdie import to_dict
from saml2 import md, assertion
from saml2.saml import Attribute
from saml2.saml import Issuer
from saml2.saml import NAMEID_FORMAT_ENTITY
from saml2.saml import NAME_FORMAT_URI
from saml2.saml import AttributeValue
from saml2.saml import NameID
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2.assertion import Policy
from saml2.assertion import Assertion
from saml2.assertion import filter_on_attributes
from saml2.assertion import filter_attribute_value_assertions
from saml2.assertion import from_local
from saml2.s_utils import MissingValue
from saml2 import attribute_converter
from saml2.attribute_converter import ac_factory, AttributeConverterNOOP

from py.test import raises

from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
from saml2 import saml
import xmldsig
import xmlenc

from pathutils import full_path

ONTS = [saml, mdui, mdattr, dri, ui, idpdisc, md, xmldsig, xmlenc]


def _eq(l1, l2):
    return set(l1) == set(l2)


gn = to_dict(md.RequestedAttribute(name="urn:oid:2.5.4.42",
                                   friendly_name="givenName",
                                   name_format=NAME_FORMAT_URI), ONTS)

sn = to_dict(md.RequestedAttribute(name="urn:oid:2.5.4.4",
                                   friendly_name="surName",
                                   name_format=NAME_FORMAT_URI), ONTS)

mail = to_dict(md.RequestedAttribute(name="urn:oid:0.9.2342.19200300.100.1.3",
                                     friendly_name="mail",
                                     name_format=NAME_FORMAT_URI), ONTS)

# ---------------------------------------------------------------------------


def test_filter_on_attributes_0():
    a = to_dict(Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                          friendly_name="serialNumber"), ONTS)

    required = [a]
    ava = {"serialNumber": ["12345"]}

    ava = filter_on_attributes(ava, required)
    assert ava.keys() == ["serialNumber"]
    assert ava["serialNumber"] == ["12345"]


def test_filter_on_attributes_1():
    a = to_dict(Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                          friendly_name="serialNumber"), ONTS)

    required = [a]
    ava = {"serialNumber": ["12345"], "givenName": ["Lars"]}

    ava = filter_on_attributes(ava, required)
    assert ava.keys() == ["serialNumber"]
    assert ava["serialNumber"] == ["12345"]

# ----------------------------------------------------------------------

def test_lifetime_1():
    conf = {
        "default": {
            "lifetime": {"minutes": 15},
            "attribute_restrictions": None  # means all I have
        },
        "urn:mace:umu.se:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "givenName": None,
                "surName": None,
                "mail": [".*@.*\.umu\.se"],
            }
        }}

    r = Policy(conf)
    assert r is not None

    assert r.get_lifetime("urn:mace:umu.se:saml:roland:sp") == {"minutes": 5}
    assert r.get_lifetime("urn:mace:example.se:saml:sp") == {"minutes": 15}


def test_lifetime_2():
    conf = {
        "default": {
            "attribute_restrictions": None  # means all I have
        },
        "urn:mace:umu.se:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "givenName": None,
                "surName": None,
                "mail": [".*@.*\.umu\.se"],
            }
        }}

    r = Policy(conf)
    assert r is not None

    assert r.get_lifetime("urn:mace:umu.se:saml:roland:sp") == {"minutes": 5}
    assert r.get_lifetime("urn:mace:example.se:saml:sp") == {"hours": 1}


def test_ava_filter_1():
    conf = {
        "default": {
            "lifetime": {"minutes": 15},
            "attribute_restrictions": None  # means all I have
        },
        "urn:mace:umu.se:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "givenName": None,
                "surName": None,
                "mail": [".*@.*\.umu\.se"],
            }
        }}

    r = Policy(conf)

    ava = {"givenName": "Derek",
           "surName": "Jeter",
           "mail": "derek@example.com"}

    ava = r.filter(ava, "urn:mace:umu.se:saml:roland:sp", None, None)
    assert _eq(ava.keys(), ["givenName", "surName"])

    ava = {"givenName": "Derek",
           "mail": "derek@nyy.umu.se"}

    assert _eq(ava.keys(), ["givenName", "mail"])


def test_ava_filter_2():
    conf = {
        "default": {
            "lifetime": {"minutes": 15},
            "attribute_restrictions": None  # means all I have
        },
        "urn:mace:umu.se:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "givenName": None,
                "surName": None,
                "mail": [".*@.*\.umu\.se"],
            }
        }}

    policy = Policy(conf)

    ava = {"givenName": "Derek",
           "surName": "Jeter",
           "mail": "derek@example.com"}

    # mail removed because it doesn't match the regular expression
    # So this should fail.
    raises(MissingValue, policy.filter, ava, 'urn:mace:umu.se:saml:roland:sp',
           None, [mail], [gn, sn])

    ava = {"givenName": "Derek",
           "surName": "Jeter"}

    # it wasn't there to begin with
    raises(Exception, policy.filter, ava, 'urn:mace:umu.se:saml:roland:sp',
           None, [gn, sn, mail])


def test_ava_filter_dont_fail():
    conf = {
        "default": {
            "lifetime": {"minutes": 15},
            "attribute_restrictions": None,  # means all I have
            "fail_on_missing_requested": False
        },
        "urn:mace:umu.se:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "givenName": None,
                "surName": None,
                "mail": [".*@.*\.umu\.se"],
            },
            "fail_on_missing_requested": False
        }}

    policy = Policy(conf)

    ava = {"givenName": "Derek",
           "surName": "Jeter",
           "mail": "derek@example.com"}

    # mail removed because it doesn't match the regular expression
    # So it should fail if the 'fail_on_ ...' flag wasn't set
    _ava = policy.filter(ava,'urn:mace:umu.se:saml:roland:sp', None,
                         [mail], [gn, sn])

    assert _ava

    ava = {"givenName": "Derek",
           "surName": "Jeter"}

    # it wasn't there to begin with
    _ava = policy.filter(ava, 'urn:mace:umu.se:saml:roland:sp',
                         None, [gn, sn, mail])

    assert _ava

def test_filter_attribute_value_assertions_0(AVA):
    p = Policy({
        "default": {
            "attribute_restrictions": {
                "surName": [".*berg"],
            }
        }
    })

    ava = filter_attribute_value_assertions(AVA[3].copy(),
                                            p.get_attribute_restrictions(""))

    print ava
    assert ava.keys() == ["surName"]
    assert ava["surName"] == ["Hedberg"]


def test_filter_attribute_value_assertions_1(AVA):
    p = Policy({
        "default": {
            "attribute_restrictions": {
                "surName": None,
                "givenName": [".*er.*"],
            }
        }
    })

    ava = filter_attribute_value_assertions(AVA[0].copy(),
                                            p.get_attribute_restrictions(""))

    print ava
    assert _eq(ava.keys(), ["givenName", "surName"])
    assert ava["surName"] == ["Jeter"]
    assert ava["givenName"] == ["Derek"]

    ava = filter_attribute_value_assertions(AVA[1].copy(),
                                            p.get_attribute_restrictions(""))

    print ava
    assert _eq(ava.keys(), ["surName"])
    assert ava["surName"] == ["Howard"]


def test_filter_attribute_value_assertions_2(AVA):
    p = Policy({
        "default": {
            "attribute_restrictions": {
                "givenName": ["^R.*"],
            }
        }
    })

    ava = filter_attribute_value_assertions(AVA[0].copy(),
                                            p.get_attribute_restrictions(""))

    print ava
    assert _eq(ava.keys(), [])

    ava = filter_attribute_value_assertions(AVA[1].copy(),
                                            p.get_attribute_restrictions(""))

    print ava
    assert _eq(ava.keys(), ["givenName"])
    assert ava["givenName"] == ["Ryan"]

    ava = filter_attribute_value_assertions(AVA[3].copy(),
                                            p.get_attribute_restrictions(""))

    print ava
    assert _eq(ava.keys(), ["givenName"])
    assert ava["givenName"] == ["Roland"]


# ----------------------------------------------------------------------------


def test_assertion_1(AVA):
    ava = Assertion(AVA[0])

    print ava
    print ava.__dict__

    policy = Policy({
        "default": {
            "attribute_restrictions": {
                "givenName": ["^R.*"],
            }
        }
    })

    ava = ava.apply_policy("", policy)

    print ava
    assert _eq(ava.keys(), [])

    ava = Assertion(AVA[1].copy())
    ava = ava.apply_policy("", policy)
    assert _eq(ava.keys(), ["givenName"])
    assert ava["givenName"] == ["Ryan"]

    ava = Assertion(AVA[3].copy())
    ava = ava.apply_policy("", policy)
    assert _eq(ava.keys(), ["givenName"])
    assert ava["givenName"] == ["Roland"]


def test_assertion_2():
    AVA = {'mail': u'roland.hedberg@adm.umu.se',
           'eduPersonTargetedID': 'http://lingon.ladok.umu'
                                  '.se:8090/idp!http://lingon.ladok.umu'
                                  '.se:8088/sp!95e9ae91dbe62d35198fbbd5e1fb0976',
           'displayName': u'Roland Hedberg',
           'uid': 'http://roland.hedberg.myopenid.com/'}

    ava = Assertion(AVA)

    policy = Policy({
        "default": {
            "lifetime": {"minutes": 240},
            "attribute_restrictions": None,  # means all I have
            "name_form": NAME_FORMAT_URI
        },
    })

    ava = ava.apply_policy("", policy)
    acs = ac_factory(full_path("attributemaps"))
    attribute = from_local(acs, ava, policy.get_name_form(""))

    assert len(attribute) == 4
    names = [attr.name for attr in attribute]
    assert _eq(names, ['urn:oid:0.9.2342.19200300.100.1.3',
                       'urn:oid:1.3.6.1.4.1.5923.1.1.1.10',
                       'urn:oid:2.16.840.1.113730.3.1.241',
                       'urn:oid:0.9.2342.19200300.100.1.1'])


# ----------------------------------------------------------------------------


def test_filter_values_req_2():
    a1 = to_dict(Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                           friendly_name="serialNumber"), ONTS)
    a2 = to_dict(Attribute(name="urn:oid:2.5.4.4", name_format=NAME_FORMAT_URI,
                           friendly_name="surName"), ONTS)

    required = [a1, a2]
    ava = {"serialNumber": ["12345"], "givenName": ["Lars"]}

    raises(MissingValue, filter_on_attributes, ava, required)


def test_filter_values_req_3():
    a = to_dict(
        Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                  friendly_name="serialNumber",
                  attribute_value=[AttributeValue(text="12345")]), ONTS)

    required = [a]
    ava = {"serialNumber": ["12345"]}

    ava = filter_on_attributes(ava, required)
    assert ava.keys() == ["serialNumber"]
    assert ava["serialNumber"] == ["12345"]


def test_filter_values_req_4():
    a = to_dict(
        Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                  friendly_name="serialNumber",
                  attribute_value=[AttributeValue(text="54321")]), ONTS)

    required = [a]
    ava = {"serialNumber": ["12345"]}

    raises(MissingValue, filter_on_attributes, ava, required)


def test_filter_values_req_5():
    a = to_dict(
        Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                  friendly_name="serialNumber",
                  attribute_value=[AttributeValue(text="12345")]), ONTS)

    required = [a]
    ava = {"serialNumber": ["12345", "54321"]}

    ava = filter_on_attributes(ava, required)
    assert ava.keys() == ["serialNumber"]
    assert ava["serialNumber"] == ["12345"]


def test_filter_values_req_6():
    a = to_dict(
        Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                  friendly_name="serialNumber",
                  attribute_value=[AttributeValue(text="54321")]), ONTS)

    required = [a]
    ava = {"serialNumber": ["12345", "54321"]}

    ava = filter_on_attributes(ava, required)
    assert ava.keys() == ["serialNumber"]
    assert ava["serialNumber"] == ["54321"]


def test_filter_values_req_opt_0():
    r = to_dict(
        Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                  friendly_name="serialNumber",
                  attribute_value=[AttributeValue(text="54321")]), ONTS)
    o = to_dict(
        Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                  friendly_name="serialNumber",
                  attribute_value=[AttributeValue(text="12345")]), ONTS)

    ava = {"serialNumber": ["12345", "54321"]}

    ava = filter_on_attributes(ava, [r], [o])
    assert ava.keys() == ["serialNumber"]
    assert _eq(ava["serialNumber"], ["12345", "54321"])


def test_filter_values_req_opt_1():
    r = to_dict(
        Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                  friendly_name="serialNumber",
                  attribute_value=[AttributeValue(text="54321")]), ONTS)
    o = to_dict(
        Attribute(name="urn:oid:2.5.4.5", name_format=NAME_FORMAT_URI,
                  friendly_name="serialNumber",
                  attribute_value=[AttributeValue(text="12345"),
                                   AttributeValue(text="abcd0")]), ONTS)

    ava = {"serialNumber": ["12345", "54321"]}

    ava = filter_on_attributes(ava, [r], [o])
    assert ava.keys() == ["serialNumber"]
    assert _eq(ava["serialNumber"], ["12345", "54321"])


def test_filter_values_req_opt_2():
    r = [
        to_dict(
            Attribute(
                friendly_name="surName",
                name="urn:oid:2.5.4.4",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
            ONTS),
        to_dict(
            Attribute(
                friendly_name="givenName",
                name="urn:oid:2.5.4.42",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
            ONTS),
        to_dict(
            Attribute(
                friendly_name="mail",
                name="urn:oid:0.9.2342.19200300.100.1.3",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
            ONTS)]
    o = [
        to_dict(
            Attribute(
                friendly_name="title",
                name="urn:oid:2.5.4.12",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
            ONTS)]

    ava = {"surname": ["Hedberg"], "givenName": ["Roland"],
           "eduPersonAffiliation": ["staff"], "uid": ["rohe0002"]}

    raises(MissingValue, "filter_on_attributes(ava, r, o)")


# ---------------------------------------------------------------------------


def test_filter_values_req_opt_4():
    r = [
        Attribute(
            friendly_name="surName",
            name="urn:oid:2.5.4.4",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
        Attribute(
            friendly_name="givenName",
            name="urn:oid:2.5.4.42",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")]
    o = [
        Attribute(
            friendly_name="title",
            name="urn:oid:2.5.4.12",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")]

    acs = attribute_converter.ac_factory(full_path("attributemaps"))

    rava = attribute_converter.list_to_local(acs, r)
    oava = attribute_converter.list_to_local(acs, o)

    ava = {"sn": ["Hedberg"], "givenName": ["Roland"],
           "eduPersonAffiliation": ["staff"], "uid": ["rohe0002"]}

    ava = assertion.filter_on_demands(ava, rava, oava)
    print ava
    assert _eq(ava.keys(), ['givenName', 'sn'])
    assert ava == {'givenName': ['Roland'], 'sn': ['Hedberg']}


# ---------------------------------------------------------------------------


def test_filter_ava_0():
    policy = Policy(
        {
            "default": {
                "lifetime": {"minutes": 15},
                "attribute_restrictions": None  # means all I have
            },
            "urn:mace:example.com:saml:roland:sp": {
                "lifetime": {"minutes": 5},
            }
        }
    )

    ava = {"givenName": ["Derek"], "surName": ["Jeter"],
           "mail": ["derek@nyy.mlb.com"]}

    # No restrictions apply
    ava = policy.filter(ava, "urn:mace:example.com:saml:roland:sp", [], [])

    assert _eq(ava.keys(), ["givenName", "surName", "mail"])
    assert ava["givenName"] == ["Derek"]
    assert ava["surName"] == ["Jeter"]
    assert ava["mail"] == ["derek@nyy.mlb.com"]


def test_filter_ava_1():
    """ No mail address returned """
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            "attribute_restrictions": None  # means all I have
        },
        "urn:mace:example.com:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "givenName": None,
                "surName": None,
            }
        }})

    ava = {"givenName": ["Derek"], "surName": ["Jeter"],
           "mail": ["derek@nyy.mlb.com"]}

    # No restrictions apply
    ava = policy.filter(ava, "urn:mace:example.com:saml:roland:sp", [], [])

    assert _eq(ava.keys(), ["givenName", "surName"])
    assert ava["givenName"] == ["Derek"]
    assert ava["surName"] == ["Jeter"]


def test_filter_ava_2():
    """ Only mail returned """
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            "attribute_restrictions": None  # means all I have
        },
        "urn:mace:example.com:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "mail": None,
            }
        }})

    ava = {"givenName": ["Derek"], "surName": ["Jeter"],
           "mail": ["derek@nyy.mlb.com"]}

    # No restrictions apply
    ava = policy.filter(ava, "urn:mace:example.com:saml:roland:sp", [], [])

    assert _eq(ava.keys(), ["mail"])
    assert ava["mail"] == ["derek@nyy.mlb.com"]


def test_filter_ava_3():
    """ Only example.com mail addresses returned """
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            "attribute_restrictions": None  # means all I have
        },
        "urn:mace:example.com:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "mail": [".*@example\.com$"],
            }
        }})

    ava = {"givenName": ["Derek"], "surName": ["Jeter"],
           "mail": ["derek@nyy.mlb.com", "dj@example.com"]}

    # No restrictions apply
    ava = policy.filter(ava, "urn:mace:example.com:saml:roland:sp", [], [])

    assert _eq(ava.keys(), ["mail"])
    assert ava["mail"] == ["dj@example.com"]


def test_filter_ava_4():
    """ Return everything as default policy is used """
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            "attribute_restrictions": None  # means all I have
        },
        "urn:mace:example.com:saml:roland:sp": {
            "lifetime": {"minutes": 5},
            "attribute_restrictions": {
                "mail": [".*@example\.com$"],
            }
        }})

    ava = {"givenName": ["Derek"], "surName": ["Jeter"],
           "mail": ["derek@nyy.mlb.com", "dj@example.com"]}

    # No restrictions apply
    ava = policy.filter(ava, "urn:mace:example.com:saml:curt:sp", [], [])

    assert _eq(ava.keys(), ['mail', 'givenName', 'surName'])
    assert _eq(ava["mail"], ["derek@nyy.mlb.com", "dj@example.com"])


def test_req_opt():
    req = [
        to_dict(
            md.RequestedAttribute(
                friendly_name="surname", name="urn:oid:2.5.4.4",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                is_required="true"), ONTS),
        to_dict(
            md.RequestedAttribute(
                friendly_name="givenname",
                name="urn:oid:2.5.4.42",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                is_required="true"), ONTS),
        to_dict(
            md.RequestedAttribute(
                friendly_name="edupersonaffiliation",
                name="urn:oid:1.3.6.1.4.1.5923.1.1.1.1",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                is_required="true"), ONTS)]

    opt = [
        to_dict(
            md.RequestedAttribute(
                friendly_name="title",
                name="urn:oid:2.5.4.12",
                name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                is_required="false"), ONTS)]

    policy = Policy()
    ava = {'givenname': 'Roland', 'surname': 'Hedberg',
           'uid': 'rohe0002', 'edupersonaffiliation': 'staff'}

    sp_entity_id = "urn:mace:example.com:saml:curt:sp"
    fava = policy.filter(ava, sp_entity_id, None, req, opt)
    assert fava


def test_filter_on_wire_representation_1():
    r = [
        Attribute(
            friendly_name="surName",
            name="urn:oid:2.5.4.4",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
        Attribute(
            friendly_name="givenName",
            name="urn:oid:2.5.4.42",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")]
    o = [
        Attribute(
            friendly_name="title",
            name="urn:oid:2.5.4.12",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")]

    acs = attribute_converter.ac_factory(full_path("attributemaps"))

    ava = {"sn": ["Hedberg"], "givenname": ["Roland"],
           "edupersonaffiliation": ["staff"], "uid": ["rohe0002"]}

    ava = assertion.filter_on_wire_representation(ava, acs, r, o)
    assert _eq(ava.keys(), ["sn", "givenname"])


def test_filter_on_wire_representation_2():
    r = [
        Attribute(
            friendly_name="surName",
            name="urn:oid:2.5.4.4",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"),
        Attribute(
            friendly_name="givenName",
            name="urn:oid:2.5.4.42",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")]
    o = [
        Attribute(
            friendly_name="title",
            name="urn:oid:2.5.4.12",
            name_format="urn:oasis:names:tc:SAML:2.0:attrname-format:uri")]

    acs = attribute_converter.ac_factory(full_path("attributemaps"))

    ava = {"sn": ["Hedberg"], "givenname": ["Roland"],
           "title": ["Master"], "uid": ["rohe0002"]}

    ava = assertion.filter_on_wire_representation(ava, acs, r, o)
    assert _eq(ava.keys(), ["sn", "givenname", "title"])


length = pword.Length(min="4")
restricted_password = pword.RestrictedPassword(length=length)
authenticator = pword.Authenticator(restricted_password=restricted_password)
authn_method = pword.AuthnMethod(authenticator=authenticator)
ACD = pword.AuthenticationContextDeclaration(authn_method=authn_method)


def test_assertion_with_noop_attribute_conv():
    ava = {"urn:oid:2.5.4.4": "Roland", "urn:oid:2.5.4.42": "Hedberg"}
    ast = Assertion(ava)
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 240},
            "attribute_restrictions": None,  # means all I have
            "name_form": NAME_FORMAT_URI
        },
    })
    name_id = NameID(format=NAMEID_FORMAT_TRANSIENT, text="foobar")
    issuer = Issuer(text="entityid", format=NAMEID_FORMAT_ENTITY)
    msg = ast.construct("sp_entity_id", "in_response_to", "consumer_url",
                        name_id, [AttributeConverterNOOP(NAME_FORMAT_URI)],
                        policy, issuer=issuer, authn_decl=ACD,
                        authn_auth="authn_authn")

    print msg
    for attr in msg.attribute_statement[0].attribute:
        assert attr.name_format == NAME_FORMAT_URI
        assert len(attr.attribute_value) == 1
        if attr.name == "urn:oid:2.5.4.42":
            assert attr.attribute_value[0].text == "Hedberg"
        elif attr.name == "urn:oid:2.5.4.4":
            assert attr.attribute_value[0].text == "Roland"


# THis test doesn't work without a MetadataStore instance
#def test_filter_ava_5():
#    policy = Policy({
#        "default": {
#            "lifetime": {"minutes": 15},
#            #"attribute_restrictions": None  # means all I have
#            "entity_categories": ["swamid", "edugain"]
#        }
#    })
#
#    ava = {"givenName": ["Derek"], "surName": ["Jeter"],
#           "mail": ["derek@nyy.mlb.com", "dj@example.com"]}
#
#    ava = policy.filter(ava, "urn:mace:example.com:saml:curt:sp", None, [], [])
#
#    # using entity_categories means there *always* are restrictions
#    # in this case the only allowed attribute is eduPersonTargetedID
#    # which isn't available in the ava hence zip is returned.
#    assert ava == {}


def test_assertion_with_zero_attributes():
    ava = {}
    ast = Assertion(ava)
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 240},
            "attribute_restrictions": None,  # means all I have
            "name_form": NAME_FORMAT_URI
        },
    })
    name_id = NameID(format=NAMEID_FORMAT_TRANSIENT, text="foobar")
    issuer = Issuer(text="entityid", format=NAMEID_FORMAT_ENTITY)
    msg = ast.construct("sp_entity_id", "in_response_to", "consumer_url",
                        name_id, [AttributeConverterNOOP(NAME_FORMAT_URI)],
                        policy, issuer=issuer, authn_decl=ACD,
                        authn_auth="authn_authn")

    print msg
    assert msg.attribute_statement == []


def test_assertion_with_authn_instant():
    ava = {}
    ast = Assertion(ava)
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 240},
            "attribute_restrictions": None,  # means all I have
            "name_form": NAME_FORMAT_URI
        },
    })
    name_id = NameID(format=NAMEID_FORMAT_TRANSIENT, text="foobar")
    issuer = Issuer(text="entityid", format=NAMEID_FORMAT_ENTITY)
    msg = ast.construct("sp_entity_id", "in_response_to", "consumer_url",
                        name_id, [AttributeConverterNOOP(NAME_FORMAT_URI)],
                        policy, issuer=issuer, authn_decl=ACD,
                        authn_auth="authn_authn",
                        authn_instant=1234567890)

    print msg
    assert msg.authn_statement[0].authn_instant == "2009-02-13T23:31:30Z"


if __name__ == "__main__":
    test_ava_filter_dont_fail()

########NEW FILE########
__FILENAME__ = test_22_mdie
__author__ = 'rolandh'

from saml2 import md
from saml2.mdie import from_dict

from saml2 import saml

from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
import xmldsig
import xmlenc

ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc
}


def _eq(l1, l2):
    return set(l1) == set(l2)


def _class(cls):
    return "%s&%s" % (cls.c_namespace, cls.c_tag)


def test_construct_contact():
    c = from_dict({
        "__class__": _class(md.ContactPerson),
        "given_name": {"text": "Roland", "__class__": _class(md.GivenName)},
        "sur_name": {"text": "Hedberg", "__class__": _class(md.SurName)},
        "email_address": [{"text":"roland@catalogix.se",
                          "__class__": _class(md.EmailAddress)}],
    }, ONTS)

    print c
    assert c.given_name.text == "Roland"
    assert c.sur_name.text == "Hedberg"
    assert c.email_address[0].text == "roland@catalogix.se"
    assert _eq(c.keyswv(), ["given_name", "sur_name", "email_address"])

########NEW FILE########
__FILENAME__ = test_30_mdstore
# -*- coding: utf-8 -*-
import datetime
import re

from saml2.mdstore import MetadataStore
from saml2.mdstore import destinations
from saml2.mdstore import name

from saml2 import md
from saml2 import sigver
from saml2 import BINDING_SOAP
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_ARTIFACT
from saml2 import saml
from saml2 import config
from saml2.attribute_converter import ac_factory
from saml2.attribute_converter import d_to_local_name

from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
from saml2.s_utils import UnknownPrincipal
import xmldsig
import xmlenc

from pathutils import full_path

sec_config = config.Config()
#sec_config.xmlsec_binary = sigver.get_xmlsec_binary(["/opt/local/bin"])

ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc
}

ATTRCONV = ac_factory(full_path("attributemaps"))

METADATACONF = {
    "1": {
        "local": [full_path("swamid-1.0.xml")]
    },
    "2": {
        "local": [full_path("InCommon-metadata.xml")]
    },
    "3": {
        "local": [full_path("extended.xml")]
    },
    "7": {
        "local": [full_path("metadata_sp_1.xml"),
                  full_path("InCommon-metadata.xml")],
        "remote": [
            {"url": "https://kalmar2.org/simplesaml/module.php/aggregator/?id=kalmarcentral2&set=saml2",
             "cert": full_path("kalmar2.pem")}]
    },
    "4": {
        "local": [full_path("metadata_example.xml")]
    },
    "5": {
        "local": [full_path("metadata.aaitest.xml")]
    },
    "8": {
        "mdfile": [full_path("swamid.md")]
    }
}


def _eq(l1, l2):
    return set(l1) == set(l2)


def _fix_valid_until(xmlstring):
    new_date = datetime.datetime.now() + datetime.timedelta(days=1)
    new_date = new_date.strftime("%Y-%m-%dT%H:%M:%SZ")
    return re.sub(r' validUntil=".*?"', ' validUntil="%s"' % new_date,
                  xmlstring)


def test_swami_1():
    UMU_IDP = 'https://idp.umu.se/saml2/idp/metadata.php'
    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)

    mds.imp(METADATACONF["1"])
    assert len(mds) == 1  # One source
    idps = mds.with_descriptor("idpsso")
    assert idps.keys()
    idpsso = mds.single_sign_on_service(UMU_IDP)
    assert len(idpsso) == 1
    assert destinations(idpsso) == [
        'https://idp.umu.se/saml2/idp/SSOService.php']

    _name = name(mds[UMU_IDP])
    assert _name == u'Ume University (SAML2)'
    certs = mds.certs(UMU_IDP, "idpsso", "signing")
    assert len(certs) == 1

    sps = mds.with_descriptor("spsso")
    assert len(sps) == 108

    wants = mds.attribute_requirement('https://connect8.sunet.se/shibboleth')
    lnamn = [d_to_local_name(mds.attrc, attr) for attr in wants["optional"]]
    assert _eq(lnamn, ['eduPersonPrincipalName', 'mail', 'givenName', 'sn',
                       'eduPersonScopedAffiliation'])
                
    wants = mds.attribute_requirement('https://beta.lobber.se/shibboleth')
    assert wants["required"] == []
    lnamn = [d_to_local_name(mds.attrc, attr) for attr in wants["optional"]]
    assert _eq(lnamn, ['eduPersonPrincipalName', 'mail', 'givenName', 'sn',
                       'eduPersonScopedAffiliation', 'eduPersonEntitlement'])
                

def test_incommon_1():
    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)

    mds.imp(METADATACONF["2"])

    print mds.entities()
    assert mds.entities() > 1700
    idps = mds.with_descriptor("idpsso")
    print idps.keys()
    assert len(idps) > 300  # ~ 18%
    try:
        _ = mds.single_sign_on_service('urn:mace:incommon:uiuc.edu')
    except UnknownPrincipal:
        pass

    idpsso = mds.single_sign_on_service('urn:mace:incommon:alaska.edu')
    assert len(idpsso) == 1
    print idpsso
    assert destinations(idpsso) == [
        'https://idp.alaska.edu/idp/profile/SAML2/Redirect/SSO']

    sps = mds.with_descriptor("spsso")

    acs_sp = []
    for nam, desc in sps.items():
        if "attribute_consuming_service" in desc:
            acs_sp.append(nam)

    assert len(acs_sp) == 0

    # Look for attribute authorities
    aas = mds.with_descriptor("attribute_authority")

    print aas.keys()
    assert len(aas) == 180


def test_ext_2():
    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)

    mds.imp(METADATACONF["3"])
    # No specific binding defined

    ents = mds.with_descriptor("spsso")
    for binding in [BINDING_SOAP, BINDING_HTTP_POST, BINDING_HTTP_ARTIFACT,
                    BINDING_HTTP_REDIRECT]:
        assert mds.single_logout_service(ents.keys()[0], binding, "spsso")


def test_example():
    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)

    mds.imp(METADATACONF["4"])
    assert len(mds.keys()) == 1
    idps = mds.with_descriptor("idpsso")

    assert idps.keys() == [
        'http://xenosmilus.umdc.umu.se/simplesaml/saml2/idp/metadata.php']
    certs = mds.certs(
        'http://xenosmilus.umdc.umu.se/simplesaml/saml2/idp/metadata.php',
        "idpsso", "signing")
    assert len(certs) == 1


def test_switch_1():
    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)

    mds.imp(METADATACONF["5"])
    assert len(mds.keys()) > 160
    idps = mds.with_descriptor("idpsso")
    print idps.keys()
    idpsso = mds.single_sign_on_service(
        'https://aai-demo-idp.switch.ch/idp/shibboleth')
    assert len(idpsso) == 1
    print idpsso
    assert destinations(idpsso) == [
        'https://aai-demo-idp.switch.ch/idp/profile/SAML2/Redirect/SSO']
    assert len(idps) > 30
    aas = mds.with_descriptor("attribute_authority")
    print aas.keys()
    aad = aas['https://aai-demo-idp.switch.ch/idp/shibboleth']
    print aad.keys()
    assert len(aad["attribute_authority_descriptor"]) == 1
    assert len(aad["idpsso_descriptor"]) == 1

    sps = mds.with_descriptor("spsso")
    dual = [eid for eid, ent in idps.items() if eid in sps]
    print len(dual)
    assert len(dual) == 0


def test_metadata_file():
    sec_config.xmlsec_binary = sigver.get_xmlsec_binary(["/opt/local/bin"])
    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)

    mds.imp(METADATACONF["8"])
    print len(mds.keys())
    assert len(mds.keys()) == 560

if __name__ == "__main__":
    test_metadata_file()

########NEW FILE########
__FILENAME__ = test_31_config
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import logging
from saml2.mdstore import MetadataStore, name

from saml2 import BINDING_HTTP_REDIRECT, BINDING_SOAP, BINDING_HTTP_POST
from saml2.config import SPConfig, IdPConfig, Config
from py.test import raises

from saml2 import root_logger

from pathutils import dotname, full_path

sp1 = {
    "entityid": "urn:mace:umu.se:saml:roland:sp",
    "service": {
        "sp": {
            "endpoints": {
                "assertion_consumer_service": [
                    "http://lingon.catalogix.se:8087/"],
            },
            "name": "test",
            "idp": {
                "urn:mace:example.com:saml:roland:idp": {
                    'single_sign_on_service':
                        {'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect':
                             'http://localhost:8088/sso/'}},
            }
        }
    },
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "metadata": {
        "local": [full_path("metadata.xml"),
                  full_path("urn-mace-swami.se-swamid-test-1.0-metadata.xml")],
    },
    "virtual_organization": {
        "coip": {
            "nameid_format": "urn:oasis:names:tc:SAML:2.0:nameid-format:transient",
            "common_identifier": "eduPersonPrincipalName",
            "attribute_auth": [
                "https://coip-test.sunet.se/idp/shibboleth",
            ]
        }
    },
    "attribute_map_dir": full_path("attributemaps"),
    "only_use_keys_in_metadata": True,
    "xmlsec_path": ["/opt/local/bin"]
}

sp2 = {
    "entityid": "urn:mace:umu.se:saml:roland:sp",
    "name": "Rolands SP",
    "service": {
        "sp": {
            "endpoints": {
                "assertion_consumer_service": [
                    "http://lingon.catalogix.se:8087/"],
            },
            "required_attributes": ["surName", "givenName", "mail"],
            "optional_attributes": ["title"],
            "idp": {
                "": "https://example.com/saml2/idp/SSOService.php",
            }
        }
    },
    #"xmlsec_binary" : "/opt/local/bin/xmlsec1",
}

IDP1 = {
    "entityid": "urn:mace:umu.se:saml:roland:idp",
    "name": "Rolands IdP",
    "service": {
        "idp": {
            "endpoints": {
                "single_sign_on_service": ["http://localhost:8088/"],
            },
            "policy": {
                "default": {
                    "attribute_restrictions": {
                        "givenName": None,
                        "surName": None,
                        "eduPersonAffiliation": ["(member|staff)"],
                        "mail": [".*@example.com"],
                    }
                },
                "urn:mace:umu.se:saml:roland:sp": None
            },
        }
    },
    #"xmlsec_binary" : "/usr/local/bin/xmlsec1",
}

IDP2 = {
    "entityid": "urn:mace:umu.se:saml:roland:idp",
    "name": "Rolands IdP",
    "service": {
        "idp": {
            "endpoints": {
                "single_sign_on_service": ["http://localhost:8088/"],
                "single_logout_service": [
                    ("http://localhost:8088/", BINDING_HTTP_REDIRECT)],
            },
            "policy": {
                "default": {
                    "attribute_restrictions": {
                        "givenName": None,
                        "surName": None,
                        "eduPersonAffiliation": ["(member|staff)"],
                        "mail": [".*@example.com"],
                    }
                },
                "urn:mace:umu.se:saml:roland:sp": None
            },
        }
    },
    #"xmlsec_binary" : "/usr/local/bin/xmlsec1",
}

PDP = {
    "entityid": "http://example.org/pysaml2/pdp",
    "name": "Rolands PdP",
    "service": {
        "pdp": {
            "endpoints": {
                "authz_service": [("http://example.org/pysaml2/pdp/authz",
                                   BINDING_SOAP)],
            },
        }
    },
    "key_file": full_path("test.key"),
    "cert_file": full_path("test.pem"),
    "organization": {
        "name": "Exempel AB",
        "display_name": [("Exempel AB", "se"), ("Example Co.", "en")],
        "url": "http://www.example.com/roland",
    },
    "contact_person": [{
                           "given_name": "John",
                           "sur_name": "Smith",
                           "email_address": ["john.smith@example.com"],
                           "contact_type": "technical",
                       },
    ],
}

ECP_SP = {
    "entityid": "urn:mace:umu.se:saml:roland:ecpsp",
    "name": "Rolands ECP_SP",
    "service": {
        "sp": {
            "endpoints": {
                "assertion_consumer_service": [
                    "http://lingon.catalogix.se:8087/"],
            },
            "ecp": {
                "130.239.": "http://example.com/idp",
            }
        }
    },
    #"xmlsec_binary" : "/opt/local/bin/xmlsec1",
}


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_1():
    c = SPConfig().load(sp1)
    c.context = "sp"
    print c
    assert c._sp_endpoints
    assert c._sp_name
    assert c._sp_idp
    md = c.metadata
    assert isinstance(md, MetadataStore)

    assert len(c._sp_idp) == 1
    assert c._sp_idp.keys() == ["urn:mace:example.com:saml:roland:idp"]
    assert c._sp_idp.values() == [{'single_sign_on_service':
                                       {
                                           'urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect':
                                               'http://localhost:8088/sso/'}}]

    assert c.only_use_keys_in_metadata


def test_2():
    c = SPConfig().load(sp2)
    c.context = "sp"

    print c
    assert c._sp_endpoints
    assert c.getattr("endpoints", "sp")
    assert c._sp_idp
    assert c._sp_optional_attributes
    assert c.name
    assert c._sp_required_attributes

    assert len(c._sp_idp) == 1
    assert c._sp_idp.keys() == [""]
    assert c._sp_idp.values() == [
        "https://example.com/saml2/idp/SSOService.php"]
    assert c.only_use_keys_in_metadata is True


def test_minimum():
    minimum = {
        "entityid": "urn:mace:example.com:saml:roland:sp",
        "service": {
            "sp": {
                "endpoints": {
                    "assertion_consumer_service": ["http://sp.example.org/"],
                },
                "name": "test",
                "idp": {
                    "": "https://example.com/idp/SSOService.php",
                },
            }
        },
        #"xmlsec_binary" : "/usr/local/bin/xmlsec1",
    }

    c = SPConfig().load(minimum)
    c.context = "sp"

    assert c is not None


def test_idp_1():
    c = IdPConfig().load(IDP1)
    c.context = "idp"

    print c
    assert c.endpoint("single_sign_on_service")[0] == 'http://localhost:8088/'

    attribute_restrictions = c.getattr("policy",
                                       "idp").get_attribute_restrictions("")
    assert attribute_restrictions["edupersonaffiliation"][0].match("staff")


def test_idp_2():
    c = IdPConfig().load(IDP2)
    c.context = "idp"

    print c
    assert c.endpoint("single_logout_service",
                      BINDING_SOAP) == []
    assert c.endpoint("single_logout_service",
                      BINDING_HTTP_REDIRECT) == ["http://localhost:8088/"]

    attribute_restrictions = c.getattr("policy",
                                       "idp").get_attribute_restrictions("")
    assert attribute_restrictions["edupersonaffiliation"][0].match("staff")


def test_wayf():
    c = SPConfig().load_file("server_conf")
    c.context = "sp"

    idps = c.metadata.with_descriptor("idpsso")
    ent = idps.values()[0]
    assert name(ent) == 'Example Co.'
    assert name(ent, "se") == 'Exempel AB'

    c.setup_logger()

    assert root_logger.level != logging.NOTSET
    assert root_logger.level == logging.INFO
    assert len(root_logger.handlers) == 1
    assert isinstance(root_logger.handlers[0],
                      logging.handlers.RotatingFileHandler)
    handler = root_logger.handlers[0]
    assert handler.backupCount == 5
    try:
        assert handler.maxBytes == 100000
    except AssertionError:
        assert handler.maxBytes == 500000
    assert handler.mode == "a"
    assert root_logger.name == "saml2"
    assert root_logger.level == 20


def test_conf_syslog():
    c = SPConfig().load_file("server_conf_syslog")
    c.context = "sp"

    # otherwise the logger setting is not changed
    root_logger.level = logging.NOTSET
    root_logger.handlers = []

    print c.logger
    c.setup_logger()

    assert root_logger.level != logging.NOTSET
    assert root_logger.level == logging.INFO
    assert len(root_logger.handlers) == 1
    assert isinstance(root_logger.handlers[0],
                      logging.handlers.SysLogHandler)
    handler = root_logger.handlers[0]
    print handler.__dict__
    assert handler.facility == "local3"
    assert handler.address == ('localhost', 514)
    if sys.version >= (2, 7):
        assert handler.socktype == 2
    else:
        pass
    assert root_logger.name == "saml2"
    assert root_logger.level == 20

#noinspection PyUnresolvedReferences
def test_3():
    cnf = Config()
    cnf.load_file(dotname("sp_1_conf"))
    assert cnf.entityid == "urn:mace:example.com:saml:roland:sp"
    assert cnf.debug == 1
    assert cnf.key_file == full_path("test.key")
    assert cnf.cert_file == full_path("test.pem")
    #assert cnf.xmlsec_binary ==  "/usr/local/bin/xmlsec1"
    assert cnf.accepted_time_diff == 60
    assert cnf.secret == "0123456789"
    assert cnf.metadata is not None
    assert cnf.attribute_converters is not None


def test_sp():
    cnf = SPConfig()
    cnf.load_file(dotname("sp_1_conf"))
    assert cnf.endpoint("assertion_consumer_service") == \
           ["http://lingon.catalogix.se:8087/"]


def test_dual():
    cnf = Config().load_file(dotname("idp_sp_conf"))

    spe = cnf.getattr("endpoints", "sp")
    idpe = cnf.getattr("endpoints", "idp")
    assert spe
    assert idpe
    assert spe != idpe


def test_ecp():
    cnf = SPConfig()
    cnf.load(ECP_SP)
    assert cnf.endpoint("assertion_consumer_service") == \
           ["http://lingon.catalogix.se:8087/"]
    eid = cnf.ecp_endpoint("130.239.16.3")
    assert eid == "http://example.com/idp"
    eid = cnf.ecp_endpoint("130.238.20.20")
    assert eid is None


def test_assertion_consumer_service():
    c = IdPConfig()
    c.load_file(dotname("idp_conf"))
    c.context = "idp"

    c.metadata.load("local", full_path("InCommon-metadata.xml"))

    entity_id = "https://www.zimride.com/shibboleth"
    acs = c.metadata.assertion_consumer_service(entity_id)
    assert len(acs) == 1
    assert acs[0][
        "location"] == 'https://www.zimride.com/Shibboleth.sso/SAML2/POST'

if __name__ == "__main__":
    test_1()

########NEW FILE########
__FILENAME__ = test_32_cache
#!/usr/bin/env python

import time
import py
from saml2.saml import NameID, NAMEID_FORMAT_TRANSIENT
from saml2.cache import Cache
from saml2.time_util import in_a_while, str_to_time
from saml2.ident import code

SESSION_INFO_PATTERN = {"ava":{}, "came from":"", "not_on_or_after":0,
                    "issuer":"", "session_id":-1}


def _eq(l1,l2):
    return set(l1) == set(l2)

def nid_eq(l1, l2):
    return _eq([code(c) for c in l1], [code(c) for c in l2])

nid = [
    NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT, text="1234"),
    NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT, text="9876"),
    NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT, text="1000")]

class TestClass:
    def setup_class(self):
        self.cache = Cache()
        
        
    def test_set(self):
        not_on_or_after = str_to_time(in_a_while(days=1))
        session_info = SESSION_INFO_PATTERN.copy()
        session_info["ava"] = {"givenName":["Derek"]}
        self.cache.set(nid[0], "abcd", session_info, not_on_or_after)
                        
        (ava, inactive) = self.cache.get_identity(nid[0])
        assert inactive == []
        assert ava.keys() == ["givenName"]
        assert ava["givenName"] == ["Derek"]
        
    def test_add_ava_info(self):        
        not_on_or_after = str_to_time(in_a_while(days=1))
        session_info = SESSION_INFO_PATTERN.copy()
        session_info["ava"] = {"surName":["Jeter"]}
        self.cache.set(nid[0], "bcde", session_info, not_on_or_after)
                        
        (ava, inactive) = self.cache.get_identity(nid[0])
        assert inactive == []
        assert _eq(ava.keys(), ["givenName","surName"])
        assert ava["givenName"] == ["Derek"]
        assert ava["surName"] == ["Jeter"]

    def test_from_one_target_source(self):        
        session_info = self.cache.get(nid[0], "bcde")
        ava = session_info["ava"]
        assert _eq(ava.keys(), ["surName"])
        assert ava["surName"] == ["Jeter"]
        session_info = self.cache.get(nid[0], "abcd")
        ava = session_info["ava"]
        assert _eq(ava.keys(), ["givenName"])
        assert ava["givenName"] == ["Derek"]
        
    def test_entities(self):
        assert _eq(self.cache.entities(nid[0]), ["abcd", "bcde"])
        py.test.raises(Exception, "self.cache.entities('6666')")
        
    def test_remove_info(self):
        self.cache.reset(nid[0], "bcde")
        assert self.cache.active(nid[0], "bcde") == False
        assert self.cache.active(nid[0], "abcd")
        
        (ava, inactive) = self.cache.get_identity(nid[0])
        assert inactive == ['bcde']
        assert _eq(ava.keys(), ["givenName"])
        assert ava["givenName"] == ["Derek"]
    
    def test_active(self):
        assert self.cache.active(nid[0], "bcde") == False
        assert self.cache.active(nid[0], "abcd")
        
    def test_subjects(self):
        assert nid_eq(self.cache.subjects(), [nid[0]])
        
    def test_second_subject(self):
        not_on_or_after = str_to_time(in_a_while(days=1))
        session_info = SESSION_INFO_PATTERN.copy()
        session_info["ava"] = {"givenName":["Ichiro"],
                                "surName":["Suzuki"]}
        self.cache.set(nid[1], "abcd", session_info,
                        not_on_or_after)

        (ava, inactive) = self.cache.get_identity(nid[1])
        assert inactive == []
        assert _eq(ava.keys(), ["givenName","surName"])
        assert ava["givenName"] == ["Ichiro"]
        assert ava["surName"] == ["Suzuki"]
        assert nid_eq(self.cache.subjects(), [nid[0], nid[1]])
        
    def test_receivers(self):
        assert _eq(self.cache.receivers(nid[1]), ["abcd"])
        
        not_on_or_after = str_to_time(in_a_while(days=1))
        session_info = SESSION_INFO_PATTERN.copy()
        session_info["ava"] = {"givenName":["Ichiro"],
                                "surName":["Suzuki"]}
        self.cache.set(nid[1], "bcde", session_info,
                        not_on_or_after)
        
        assert _eq(self.cache.receivers(nid[1]), ["abcd", "bcde"])
        assert nid_eq(self.cache.subjects(), nid[0:2])
        
    def test_timeout(self):
        not_on_or_after = str_to_time(in_a_while(seconds=1))
        session_info = SESSION_INFO_PATTERN.copy()
        session_info["ava"] = {"givenName":["Alex"],
                                "surName":["Rodriguez"]}
        self.cache.set(nid[2], "bcde", session_info,
                        not_on_or_after)
                        
        time.sleep(2)
        (ava, inactive) = self.cache.get_identity(nid[2])
        assert inactive == ["bcde"]
        assert ava == {}


########NEW FILE########
__FILENAME__ = test_33_identifier
#!/usr/bin/env python
import os

from saml2 import samlp
from saml2.saml import NAMEID_FORMAT_PERSISTENT, NAMEID_FORMAT_TRANSIENT
from saml2.config import IdPConfig
from saml2.ident import IdentDB
from saml2.assertion import Policy

def _eq(l1,l2):
    return set(l1) == set(l2)

CONFIG = IdPConfig().load({
    "entityid" :  "urn:mace:example.com:idp:2",
    "name" : "test",
    "service": {
        "idp": {
            "endpoints" : {
                "single_sign_on_service" : ["http://idp.example.org/"],
                },
            "policy": {
                "default": {
                    "lifetime": {"minutes":15},
                    "attribute_restrictions": None, # means all I have
                    "name_form": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                    "nameid_format": NAMEID_FORMAT_PERSISTENT
                }
            }
        }
    },
    "virtual_organization" : {
        "http://vo.example.org/biomed":{
            "nameid_format" : "urn:oid:2.16.756.1.2.5.1.1.1-NameID",
            "common_identifier": "uid",
        },
        "http://vo.example.org/design":{
            "nameid_format" : NAMEID_FORMAT_PERSISTENT,
            "common_identifier": "uid",
        }
    }
})

NAME_ID_POLICY_1 = """<?xml version="1.0" encoding="utf-8"?>
<NameIDPolicy xmlns="urn:oasis:names:tc:SAML:2.0:protocol"
  SPNameQualifier="http://vo.example.org/biomed"
/>
"""

NAME_ID_POLICY_2 = """<?xml version="1.0" encoding="utf-8"?>
<NameIDPolicy xmlns="urn:oasis:names:tc:SAML:2.0:protocol"
  SPNameQualifier="http://vo.example.org/design"
/>
"""


class TestIdentifier():
    def setup_class(self):
        self.id = IdentDB("subject.db", "example.com", "example")
        
    def test_persistent_1(self):
        policy = Policy({
            "default": {
                "name_form": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                "nameid_format": NAMEID_FORMAT_PERSISTENT,
                "attribute_restrictions": {
                    "surName": [".*berg"],
                }
            }
        })
        
        nameid = self.id.construct_nameid("foobar", policy,
                                          "urn:mace:example.com:sp:1")
        
        assert _eq(nameid.keyswv(), ['format', 'text', 'sp_name_qualifier',
                                     'name_qualifier'])
        assert nameid.sp_name_qualifier == "urn:mace:example.com:sp:1"
        assert nameid.format == NAMEID_FORMAT_PERSISTENT
        
        id = self.id.find_local_id(nameid)
        
        assert id == "foobar"

    def test_transient_1(self):
        policy = Policy({
            "default": {
                "name_form": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                "nameid_format": NAMEID_FORMAT_TRANSIENT,
                "attribute_restrictions": {
                    "surName": [".*berg"],
                }
            }
        })
        nameid = self.id.construct_nameid("foobar", policy,
                                          "urn:mace:example.com:sp:1")
        
        assert _eq(nameid.keyswv(), ['text', 'format', 'sp_name_qualifier',
                                     'name_qualifier'])
        assert nameid.format == NAMEID_FORMAT_TRANSIENT
        assert nameid.text != "foobar"
        
    def test_vo_1(self):
        policy = Policy({
            "default": {
                "name_form": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                "nameid_format": NAMEID_FORMAT_PERSISTENT,
                "attribute_restrictions": {
                    "surName": [".*berg"],
                }
            }
        })
        
        name_id_policy = samlp.name_id_policy_from_string(NAME_ID_POLICY_1)
        print name_id_policy
        nameid = self.id.construct_nameid("foobar", policy,
                                          'http://vo.example.org/biomed',
                                          name_id_policy)

        print nameid
        assert _eq(nameid.keyswv(), ['text', 'sp_name_qualifier', 'format',
                                     'name_qualifier'])
        assert nameid.sp_name_qualifier == 'http://vo.example.org/biomed'
        assert nameid.format == NAMEID_FORMAT_PERSISTENT
        # we want to keep the user identifier in the nameid node
        assert nameid.text == "foobar"

    def test_vo_2(self):
        policy = Policy({
            "default": {
                "name_form": "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                "nameid_format": NAMEID_FORMAT_PERSISTENT,
                "attribute_restrictions": {
                    "surName": [".*berg"],
                }
            }
        })
        
        name_id_policy = samlp.name_id_policy_from_string(NAME_ID_POLICY_2)
        
        nameid = self.id.construct_nameid("foobar", policy,
                                          'http://vo.example.org/design',
                                          name_id_policy)
        
        assert _eq(nameid.keyswv(), ['text', 'sp_name_qualifier', 'format',
                                     'name_qualifier'])
        assert nameid.sp_name_qualifier == 'http://vo.example.org/design'
        assert nameid.format == NAMEID_FORMAT_PERSISTENT
        assert nameid.text != "foobar01"


    def test_persistent_nameid(self):
        sp_id = "urn:mace:umu.se:sp"
        nameid = self.id.persistent_nameid("abcd0001", sp_id)
        remote_id = nameid.text.strip()
        print remote_id
        local = self.id.find_local_id(nameid)
        assert local == "abcd0001"

        # Always get the same
        nameid2 = self.id.persistent_nameid("abcd0001", sp_id)
        assert nameid.text.strip() == nameid2.text.strip()

    def test_transient_nameid(self):
        sp_id = "urn:mace:umu.se:sp"
        nameid = self.id.transient_nameid("abcd0001", sp_id)
        remote_id = nameid.text.strip()
        print remote_id
        local = self.id.find_local_id(nameid)
        assert local == "abcd0001"

        # Getting a new, means really getting a new !
        nameid2 = self.id.transient_nameid(sp_id, "abcd0001")
        assert nameid.text.strip() != nameid2.text.strip()

    def teardown_class(self):
        if os.path.exists("foobar.db"):
            os.unlink("foobar.db")


########NEW FILE########
__FILENAME__ = test_34_population
#!/usr/bin/env python
from saml2.ident import code
from saml2.saml import NAMEID_FORMAT_TRANSIENT, NameID

from saml2.population import Population
from saml2.time_util import in_a_while

IDP_ONE = "urn:mace:example.com:saml:one:idp"
IDP_OTHER = "urn:mace:example.com:saml:other:idp"

nid = NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT, 
             text="123456")
nida = NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT,
             text="abcdef")

cnid = code(nid)
cnida = code(nida)

def _eq(l1, l2):
    return set(l1) == set(l2)

class TestPopulationMemoryBased():
    def setup_class(self):
        self.population = Population()
        
    def test_add_person(self):
        session_info = {
            "name_id": nid,
            "issuer": IDP_ONE,
            "not_on_or_after": in_a_while(minutes=15),
            "ava": {
                "givenName": "Anders",
                "surName": "Andersson",
                "mail": "anders.andersson@example.com"
            }
        }
        self.population.add_information_about_person(session_info)
        
        issuers = self.population.issuers_of_info(nid)
        assert issuers == [IDP_ONE]
        subjects = [code(c) for c in self.population.subjects()]
        assert subjects == [cnid]
        # Are any of the sources gone stale
        stales = self.population.stale_sources_for_person(nid)
        assert stales == []
        # are any of the possible sources not used or gone stale
        possible = [IDP_ONE, IDP_OTHER]
        stales = self.population.stale_sources_for_person(nid, possible)
        assert stales == [IDP_OTHER]

        (identity, stale) = self.population.get_identity(nid)
        assert stale == []
        assert identity == {'mail': 'anders.andersson@example.com', 
                            'givenName': 'Anders', 
                            'surName': 'Andersson'}

        info = self.population.get_info_from(nid, IDP_ONE)
        assert info.keys() == ["not_on_or_after", "name_id", "ava"]
        assert info["name_id"] == nid 
        assert info["ava"] == {'mail': 'anders.andersson@example.com', 
                                'givenName': 'Anders', 
                                'surName': 'Andersson'}

    def test_extend_person(self):
        session_info = {
            "name_id": nid,
            "issuer": IDP_OTHER,
            "not_on_or_after": in_a_while(minutes=15),
            "ava": {
                "eduPersonEntitlement": "Anka"
            }
        }
        
        self.population.add_information_about_person(session_info)
        
        issuers = self.population.issuers_of_info(nid)
        assert _eq(issuers, [IDP_ONE, IDP_OTHER])
        subjects = [code(c) for c in self.population.subjects()]
        assert subjects == [cnid]
        # Are any of the sources gone stale
        stales = self.population.stale_sources_for_person(nid)
        assert stales == []
        # are any of the possible sources not used or gone stale
        possible = [IDP_ONE, IDP_OTHER]
        stales = self.population.stale_sources_for_person(nid, possible)
        assert stales == []

        (identity, stale) = self.population.get_identity(nid)
        assert stale == []
        assert identity == {'mail': 'anders.andersson@example.com', 
                            'givenName': 'Anders', 
                            'surName': 'Andersson',
                            "eduPersonEntitlement": "Anka"}

        info = self.population.get_info_from(nid, IDP_OTHER)
        assert info.keys() == ["not_on_or_after", "name_id", "ava"]
        assert info["name_id"] == nid
        assert info["ava"] == {"eduPersonEntitlement": "Anka"}
    
    def test_add_another_person(self):
        session_info = {
            "name_id": nida,
            "issuer": IDP_ONE,
            "not_on_or_after": in_a_while(minutes=15),
            "ava": {
                "givenName": "Bertil",
                "surName": "Bertilsson",
                "mail": "bertil.bertilsson@example.com"
            }
        }
        self.population.add_information_about_person(session_info)

        issuers = self.population.issuers_of_info(nida)
        assert issuers == [IDP_ONE]
        subjects = [code(c) for c in self.population.subjects()]
        assert _eq(subjects, [cnid, cnida])
        
        stales = self.population.stale_sources_for_person(nida)
        assert stales == []
        # are any of the possible sources not used or gone stale
        possible = [IDP_ONE, IDP_OTHER]
        stales = self.population.stale_sources_for_person(nida, possible)
        assert stales == [IDP_OTHER]

        (identity, stale) = self.population.get_identity(nida)
        assert stale == []
        assert identity == {"givenName": "Bertil",
                            "surName": "Bertilsson",
                            "mail": "bertil.bertilsson@example.com"
                            }

        info = self.population.get_info_from(nida, IDP_ONE)
        assert info.keys() == ["not_on_or_after", "name_id", "ava"]
        assert info["name_id"] == nida
        assert info["ava"] == {"givenName": "Bertil",
                                "surName": "Bertilsson",
                                "mail": "bertil.bertilsson@example.com"
                                }

    def test_modify_person(self):
        session_info = {
            "name_id": nid,
            "issuer": IDP_ONE,
            "not_on_or_after": in_a_while(minutes=15),
            "ava": {
                "givenName": "Arne",
                "surName": "Andersson",
                "mail": "arne.andersson@example.com"
            }
        }
        self.population.add_information_about_person(session_info)
        
        issuers = self.population.issuers_of_info(nid)
        assert _eq(issuers, [IDP_ONE, IDP_OTHER])
        subjects = [code(c) for c in self.population.subjects()]
        assert _eq(subjects, [cnid, cnida])
        # Are any of the sources gone stale
        stales = self.population.stale_sources_for_person(nid)
        assert stales == []
        # are any of the possible sources not used or gone stale
        possible = [IDP_ONE, IDP_OTHER]
        stales = self.population.stale_sources_for_person(nid, possible)
        assert stales == []

        (identity, stale) = self.population.get_identity(nid)
        assert stale == []
        assert identity == {'mail': 'arne.andersson@example.com', 
                            'givenName': 'Arne', 
                            'surName': 'Andersson',
                            "eduPersonEntitlement": "Anka"}

        info = self.population.get_info_from(nid, IDP_OTHER)
        assert info.keys() == ["not_on_or_after", "name_id", "ava"]
        assert info["name_id"] == nid
        assert info["ava"] == {"eduPersonEntitlement": "Anka"}

########NEW FILE########
__FILENAME__ = test_36_mdbcache
#!/usr/bin/env python

__author__ = 'rolandh'

import time
from saml2.cache import ToOld
from saml2.mdbcache import Cache
from saml2.time_util import in_a_while, str_to_time
from pytest import raises

SESSION_INFO_PATTERN = {"ava":{}, "came from":"", "not_on_or_after":0,
                    "issuer":"", "session_id":-1}

class TestMongoDBCache():
    def setup_class(self):
        try:
            self.cache = Cache()
            self.cache.clear()
        except Exception:
            self.cache = None

    def test_set_get_1(self):
        if self.cache is not None:
            not_on_or_after = str_to_time(in_a_while(days=1))
            session_info = SESSION_INFO_PATTERN.copy()
            session_info["ava"] = {"givenName":["Derek"]}
            # subject_id, entity_id, info, timestamp
            self.cache.set("1234", "abcd", session_info, not_on_or_after)

            info = self.cache.get("1234", "abcd")
            #{u'issuer': u'', u'came from': u'', u'ava': {u'givenName': [u'Derek']}, u'session_id': -1, u'not_on_or_after': 0}
            ava = info["ava"]
            print ava
            assert ava.keys() == ["givenName"]
            assert ava["givenName"] == ["Derek"]

    def test_set_get_2(self):
        if self.cache is not None:
            not_on_or_after = str_to_time(in_a_while(seconds=1))
            session_info = SESSION_INFO_PATTERN.copy()
            session_info["ava"] = {"givenName":["Mariano"]}
            # subject_id, entity_id, info, timestamp
            self.cache.set("1235", "abcd", session_info,
                            not_on_or_after)
            time.sleep(2)

            raises(ToOld, 'self.cache.get("1235", "abcd")')
            info = self.cache.get("1235", "abcd", False)
            assert info != {}

    def test_remove(self):
        if self.cache is not None:
            self.cache.delete("1234")

            info = self.cache.get("1234", "abcd")
            print info
            assert info == {}

    def test_subjects(self):
        if self.cache is not None:
            slist = self.cache.subjects()
            assert len(slist) == 1
            assert slist == ["1235"]

    def test_identity(self):
        if self.cache is not None:
            not_on_or_after = str_to_time(in_a_while(days=1))
            session_info = SESSION_INFO_PATTERN.copy()
            session_info["ava"] = {"givenName":["Derek"]}
            self.cache.set("1234", "abcd", session_info, not_on_or_after)

            not_on_or_after = str_to_time(in_a_while(days=1))
            session_info = SESSION_INFO_PATTERN.copy()
            session_info["ava"] = {"mail":["Derek.Jeter@mlb.com"]}
            self.cache.set("1234", "xyzv", session_info, not_on_or_after)

            (ident, _) = self.cache.get_identity("1234")
            print ident
            assert len(ident.keys()) == 2
            assert "givenName" in ident.keys()
            assert "mail" in ident.keys()
            assert ident["mail"] == ["Derek.Jeter@mlb.com"]
            assert ident["givenName"] == ["Derek"]

    def test_remove_2(self):
        if self.cache is not None:
            self.cache.delete("1234")

            info = self.cache.get("1234", "xyzv")
            print info
            assert info == {}

########NEW FILE########
__FILENAME__ = test_37_entity_categories
from saml2 import saml, sigver
from saml2 import md
from saml2 import config
from saml2.assertion import Policy
from saml2.attribute_converter import ac_factory
from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
from pathutils import full_path
from saml2.mdstore import MetadataStore
from saml2.server import Server
import xmldsig
import xmlenc

ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc
}

ATTRCONV = ac_factory(full_path("attributemaps"))
sec_config = config.Config()
sec_config.xmlsec_binary = sigver.get_xmlsec_binary(["/opt/local/bin"])

__author__ = 'rolandh'

MDS = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                    disable_ssl_certificate_validation=True)
MDS.imp({"mdfile": [full_path("swamid.md")]})


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_filter_ava():
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            #"attribute_restrictions": None  # means all I have
            "entity_categories": ["swamid"]
        }
    })

    ava = {"givenName": ["Derek"], "sn": ["Jeter"],
           "mail": ["derek@nyy.mlb.com", "dj@example.com"], "c": ["USA"]}

    ava = policy.filter(ava, "https://connect.sunet.se/shibboleth", MDS)

    assert _eq(ava.keys(), ['mail', 'givenName', 'sn', 'c'])
    assert _eq(ava["mail"], ["derek@nyy.mlb.com", "dj@example.com"])


def test_filter_ava2():
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            #"attribute_restrictions": None  # means all I have
            "entity_categories": ["edugain"]
        }
    })

    ava = {"givenName": ["Derek"], "sn": ["Jeter"],
           "mail": ["derek@nyy.mlb.com"], "c": ["USA"],
           "eduPersonTargetedID": "foo!bar!xyz"}

    ava = policy.filter(ava, "https://connect.sunet.se/shibboleth", MDS)

    # Mismatch, policy deals with eduGAIN, metadata says SWAMID
    # So only minimum should come out
    assert _eq(ava.keys(), ['eduPersonTargetedID'])


def test_filter_ava3():
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            #"attribute_restrictions": None  # means all I have
            "entity_categories": ["swamid"]
        }
    })

    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)
    mds.imp({"local": [full_path("entity_cat_sfs_hei.xml")]})

    ava = {"givenName": ["Derek"], "sn": ["Jeter"],
           "mail": ["derek@nyy.mlb.com"], "c": ["USA"],
           "eduPersonTargetedID": "foo!bar!xyz",
           "norEduPersonNIN": "19800101134"}

    ava = policy.filter(ava, "urn:mace:example.com:saml:roland:sp", mds)

    assert _eq(ava.keys(), ['eduPersonTargetedID', "norEduPersonNIN"])


def test_filter_ava4():
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            #"attribute_restrictions": None  # means all I have
            "entity_categories": ["swamid"]
        }
    })

    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)
    mds.imp({"local": [full_path("entity_cat_re_nren.xml")]})

    ava = {"givenName": ["Derek"], "sn": ["Jeter"],
           "mail": ["derek@nyy.mlb.com"], "c": ["USA"],
           "eduPersonTargetedID": "foo!bar!xyz",
           "norEduPersonNIN": "19800101134"}

    ava = policy.filter(ava, "urn:mace:example.com:saml:roland:sp", mds)

    assert _eq(ava.keys(), ['eduPersonTargetedID', "givenName", "c", "mail",
                            "sn"])


def test_filter_ava5():
    policy = Policy({
        "default": {
            "lifetime": {"minutes": 15},
            #"attribute_restrictions": None  # means all I have
            "entity_categories": ["swamid"]
        }
    })

    mds = MetadataStore(ONTS.values(), ATTRCONV, sec_config,
                        disable_ssl_certificate_validation=True)
    mds.imp({"local": [full_path("entity_cat_re.xml")]})

    ava = {"givenName": ["Derek"], "sn": ["Jeter"],
           "mail": ["derek@nyy.mlb.com"], "c": ["USA"],
           "eduPersonTargetedID": "foo!bar!xyz",
           "norEduPersonNIN": "19800101134"}

    ava = policy.filter(ava, "urn:mace:example.com:saml:roland:sp", mds)

    assert _eq(ava.keys(), ['eduPersonTargetedID'])


def test_idp_policy_filter():
    idp = Server("idp_conf_ec")

    ava = {"givenName": ["Derek"], "sn": ["Jeter"],
           "mail": ["derek@nyy.mlb.com"], "c": ["USA"],
           "eduPersonTargetedID": "foo!bar!xyz",
           "norEduPersonNIN": "19800101134"}

    policy = idp.config.getattr("policy", "idp")
    policy.filter(ava, "urn:mace:example.com:saml:roland:sp", idp.metadata)

    print ava
    assert ava.keys() == ["eduPersonTargetedID"]  # because no entity category

if __name__ == "__main__":
    test_idp_policy_filter()

########NEW FILE########
__FILENAME__ = test_40_sigver
#!/usr/bin/env python

import base64
from saml2.sigver import pre_encryption_part, make_temp
from saml2.mdstore import MetadataStore
from saml2.saml import assertion_from_string, EncryptedAssertion
from saml2.samlp import response_from_string

from saml2 import sigver, extension_elements_to_elements
from saml2 import class_name
from saml2 import time_util
from saml2 import saml, samlp
from saml2 import config
from saml2.s_utils import factory, do_attribute_statement

from py.test import raises

from pathutils import full_path

SIGNED = full_path("saml_signed.xml")
UNSIGNED = full_path("saml_unsigned.xml")
SIMPLE_SAML_PHP_RESPONSE = full_path("simplesamlphp_authnresponse.xml")

PUB_KEY = full_path("test.pem")
PRIV_KEY = full_path("test.key")


def _eq(l1, l2):
    return set(l1) == set(l2)


CERT1 = """MIICsDCCAhmgAwIBAgIJAJrzqSSwmDY9MA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV
BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX
aWRnaXRzIFB0eSBMdGQwHhcNMDkxMDA2MTk0OTQxWhcNMDkxMTA1MTk0OTQxWjBF
MQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50
ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB
gQDJg2cms7MqjniT8Fi/XkNHZNPbNVQyMUMXE9tXOdqwYCA1cc8vQdzkihscQMXy
3iPw2cMggBu6gjMTOSOxECkuvX5ZCclKr8pXAJM5cY6gVOaVO2PdTZcvDBKGbiaN
efiEw5hnoZomqZGp8wHNLAUkwtH9vjqqvxyS/vclc6k2ewIDAQABo4GnMIGkMB0G
A1UdDgQWBBRePsKHKYJsiojE78ZWXccK9K4aJTB1BgNVHSMEbjBsgBRePsKHKYJs
iojE78ZWXccK9K4aJaFJpEcwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUt
U3RhdGUxITAfBgNVBAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAJrzqSSw
mDY9MAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADgYEAJSrKOEzHO7TL5cy6
h3qh+3+JAk8HbGBW+cbX6KBCAw/mzU8flK25vnWwXS3dv2FF3Aod0/S7AWNfKib5
U/SA9nJaz/mWeF9S0farz9AQFc8/NSzAzaVq7YbM4F6f6N2FRl7GikdXRCed45j6
mrPzGzk3ECbupFnqyREH3+ZPSdk="""

CERT_SSP = """MIICizCCAfQCCQCY8tKaMc0BMjANBgkqhkiG9w0BAQUFADCBiTELMAkGA1UEBhMC
Tk8xEjAQBgNVBAgTCVRyb25kaGVpbTEQMA4GA1UEChMHVU5JTkVUVDEOMAwGA1UE
CxMFRmVpZGUxGTAXBgNVBAMTEG9wZW5pZHAuZmVpZGUubm8xKTAnBgkqhkiG9w0B
CQEWGmFuZHJlYXMuc29sYmVyZ0B1bmluZXR0Lm5vMB4XDTA4MDUwODA5MjI0OFoX
DTM1MDkyMzA5MjI0OFowgYkxCzAJBgNVBAYTAk5PMRIwEAYDVQQIEwlUcm9uZGhl
aW0xEDAOBgNVBAoTB1VOSU5FVFQxDjAMBgNVBAsTBUZlaWRlMRkwFwYDVQQDExBv
cGVuaWRwLmZlaWRlLm5vMSkwJwYJKoZIhvcNAQkBFhphbmRyZWFzLnNvbGJlcmdA
dW5pbmV0dC5ubzCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAt8jLoqI1VTlx
AZ2axiDIThWcAOXdu8KkVUWaN/SooO9O0QQ7KRUjSGKN9JK65AFRDXQkWPAu4Hln
O4noYlFSLnYyDxI66LCr71x4lgFJjqLeAvB/GqBqFfIZ3YK/NrhnUqFwZu63nLrZ
jcUZxNaPjOOSRSDaXpv1kb5k3jOiSGECAwEAATANBgkqhkiG9w0BAQUFAAOBgQBQ
Yj4cAafWaYfjBU2zi1ElwStIaJ5nyp/s/8B8SAPK2T79McMyccP3wSW13LHkmM1j
wKe3ACFXBvqGQN0IbcH49hu0FKhYFM/GPDJcIHFBsiyMBXChpye9vBaTNEBCtU3K
jjyG0hRT2mAQ9h+bkPmOvlEo/aH0xR68Z9hw4PF13w=="""

from pyasn1.codec.der import decoder


def test_cert_from_instance_1():
    xml_response = open(SIGNED).read()
    response = samlp.response_from_string(xml_response)
    assertion = response.assertion[0]
    certs = sigver.cert_from_instance(assertion)
    assert len(certs) == 1
    print certs[0]
    assert certs[0] == CERT1


def test_cert_from_instance_ssp():
    xml_response = open(SIMPLE_SAML_PHP_RESPONSE).read()
    response = samlp.response_from_string(xml_response)
    assertion = response.assertion[0]
    certs = sigver.cert_from_instance(assertion)
    assert len(certs) == 1
    assert certs[0] == CERT_SSP
    der = base64.b64decode(certs[0])
    print str(decoder.decode(der)).replace('.', "\n.")
    assert decoder.decode(der)


class FakeConfig():
    """
    Configuration parameters for signature validation test cases.
    """
    xmlsec_binary = None
    crypto_backend = 'xmlsec1'
    only_use_keys_in_metadata = False
    metadata = None
    cert_file = PUB_KEY
    key_file = PRIV_KEY
    debug = False
    cert_handler_extra_class = None
    generate_cert_func = None
    generate_cert_info = False
    tmp_cert_file = None
    tmp_key_file = None
    validate_certificate = False


class TestSecurity():
    def setup_class(self):
        # This would be one way to initialize the security context :
        #
        #    conf = config.SPConfig()
        #    conf.load_file("server_conf")
        #    conf.only_use_keys_in_metadata = False
        #
        # but instead, FakeConfig() is used to really only use the minimal
        # set of parameters needed for these test cases. Other test cases
        # (TestSecurityMetadata below) excersise the SPConfig() mechanism.
        #
        conf = FakeConfig()
        self.sec = sigver.security_context(FakeConfig())

        self._assertion = factory(
            saml.Assertion,
            version="2.0",
            id="11111",
            issue_instant="2009-10-30T13:20:28Z",
            signature=sigver.pre_signature_part("11111", self.sec.my_cert, 1),
            attribute_statement=do_attribute_statement({
                ("", "", "surName"): ("Foo", ""),
                ("", "", "givenName"): ("Bar", ""),
            })
        )

    def test_verify_1(self):
        xml_response = open(SIGNED).read()
        response = self.sec.correctly_signed_response(xml_response)
        assert response

    def test_non_verify_1(self):
        """ unsigned is OK """
        xml_response = open(UNSIGNED).read()
        response = self.sec.correctly_signed_response(xml_response)
        assert response

    def test_sign_assertion(self):
        ass = self._assertion
        print ass
        sign_ass = self.sec.sign_assertion("%s" % ass, node_id=ass.id)
        #print sign_ass
        sass = saml.assertion_from_string(sign_ass)
        #print sass
        assert _eq(sass.keyswv(), ['attribute_statement', 'issue_instant',
                                   'version', 'signature', 'id'])
        assert sass.version == "2.0"
        assert sass.id == "11111"
        assert time_util.str_to_time(sass.issue_instant)

        print "Crypto version : %s" % (self.sec.crypto.version())

        item = self.sec.check_signature(sass, class_name(sass), sign_ass)

        assert isinstance(item, saml.Assertion)

    def test_multiple_signatures_assertion(self):
        ass = self._assertion
        # basic test with two of the same
        to_sign = [(ass, ass.id, ''),
                   (ass, ass.id, '')
        ]
        sign_ass = self.sec.multiple_signatures("%s" % ass, to_sign)
        sass = saml.assertion_from_string(sign_ass)
        assert _eq(sass.keyswv(), ['attribute_statement', 'issue_instant',
                                   'version', 'signature', 'id'])
        assert sass.version == "2.0"
        assert sass.id == "11111"
        assert time_util.str_to_time(sass.issue_instant)

        print "Crypto version : %s" % (self.sec.crypto.version())

        item = self.sec.check_signature(sass, class_name(sass),
                                        sign_ass, must=True)

        assert isinstance(item, saml.Assertion)

    def test_multiple_signatures_response(self):
        response = factory(samlp.Response,
                           assertion=self._assertion,
                           id="22222",
                           signature=sigver.pre_signature_part(
                               "22222", self.sec.my_cert))

        # order is important, we can't validate if the signatures are made
        # in the reverse order
        to_sign = [(self._assertion, self._assertion.id, ''),
                   (response, response.id, '')]

        s_response = self.sec.multiple_signatures("%s" % response, to_sign)
        assert s_response is not None
        response = response_from_string(s_response)

        item = self.sec.check_signature(response, class_name(response),
                                        s_response, must=True)
        assert item == response
        assert item.id == "22222"

        s_assertion = item.assertion[0]
        assert isinstance(s_assertion, saml.Assertion)
        # make sure the assertion was modified when we supposedly signed it
        assert s_assertion != self._assertion

        ci = "".join(sigver.cert_from_instance(s_assertion)[0].split())
        assert ci == self.sec.my_cert

        res = self.sec.check_signature(s_assertion, class_name(s_assertion),
                                       s_response, must=True)
        assert res == s_assertion
        assert s_assertion.id == "11111"
        assert s_assertion.version == "2.0"
        assert _eq(s_assertion.keyswv(), ['attribute_statement',
                                          'issue_instant',
                                          'version', 'signature', 'id'])

    def test_sign_response(self):
        response = factory(samlp.Response,
                           assertion=self._assertion,
                           id="22222",
                           signature=sigver.pre_signature_part("22222",
                                                               self.sec
                                                               .my_cert))

        to_sign = [(class_name(self._assertion), self._assertion.id),
                   (class_name(response), response.id)]
        s_response = sigver.signed_instance_factory(response, self.sec, to_sign)

        assert s_response is not None
        print s_response
        response = response_from_string(s_response)
        sass = response.assertion[0]

        print sass
        assert _eq(sass.keyswv(), ['attribute_statement', 'issue_instant',
                                   'version', 'signature', 'id'])
        assert sass.version == "2.0"
        assert sass.id == "11111"

        item = self.sec.check_signature(response, class_name(response),
                                        s_response)
        assert isinstance(item, samlp.Response)
        assert item.id == "22222"

    def test_sign_response_2(self):
        assertion2 = factory(saml.Assertion,
                             version="2.0",
                             id="11122",
                             issue_instant="2009-10-30T13:20:28Z",
                             signature=sigver.pre_signature_part("11122",
                                                                 self.sec
                                                                 .my_cert),
                             attribute_statement=do_attribute_statement({
                                 ("", "", "surName"): ("Fox", ""),
                                 ("", "", "givenName"): ("Bear", ""),
                             })
        )
        response = factory(samlp.Response,
                           assertion=assertion2,
                           id="22233",
                           signature=sigver.pre_signature_part("22233",
                                                               self.sec
                                                               .my_cert))

        to_sign = [(class_name(assertion2), assertion2.id),
                   (class_name(response), response.id)]

        s_response = sigver.signed_instance_factory(response, self.sec, to_sign)

        assert s_response is not None
        response2 = response_from_string(s_response)

        sass = response2.assertion[0]
        assert _eq(sass.keyswv(), ['attribute_statement', 'issue_instant',
                                   'version', 'signature', 'id'])
        assert sass.version == "2.0"
        assert sass.id == "11122"

        item = self.sec.check_signature(response2, class_name(response),
                                        s_response)

        assert isinstance(item, samlp.Response)

    def test_sign_verify(self):
        response = factory(samlp.Response,
                           assertion=self._assertion,
                           id="22233",
                           signature=sigver.pre_signature_part("22233",
                                                               self.sec
                                                               .my_cert))

        to_sign = [(class_name(self._assertion), self._assertion.id),
                   (class_name(response), response.id)]

        s_response = sigver.signed_instance_factory(response, self.sec, to_sign)

        print s_response
        res = self.sec.verify_signature("%s" % s_response,
                                        node_name=class_name(samlp.Response()))

        print res
        assert res

    def test_sign_verify_with_cert_from_instance(self):
        response = factory(samlp.Response,
                           assertion=self._assertion,
                           id="22222",
                           signature=sigver.pre_signature_part("22222",
                                                               self.sec
                                                               .my_cert))

        to_sign = [(class_name(self._assertion), self._assertion.id),
                   (class_name(response), response.id)]

        s_response = sigver.signed_instance_factory(response, self.sec, to_sign)

        response2 = response_from_string(s_response)

        ci = "".join(sigver.cert_from_instance(response2)[0].split())

        assert ci == self.sec.my_cert

        res = self.sec.verify_signature("%s" % s_response,
                                        node_name=class_name(samlp.Response()))

        assert res

        res = self.sec._check_signature(s_response, response2,
                                        class_name(response2), s_response)
        assert res == response2

    def test_sign_verify_assertion_with_cert_from_instance(self):
        assertion = factory(saml.Assertion,
                            version="2.0",
                            id="11100",
                            issue_instant="2009-10-30T13:20:28Z",
                            signature=sigver.pre_signature_part("11100",
                                                                self.sec
                                                                .my_cert),
                            attribute_statement=do_attribute_statement({
                                ("", "", "surName"): ("Fox", ""),
                                ("", "", "givenName"): ("Bear", ""),
                            })
        )

        to_sign = [(class_name(assertion), assertion.id)]
        s_assertion = sigver.signed_instance_factory(assertion, self.sec,
                                                     to_sign)
        print s_assertion
        ass = assertion_from_string(s_assertion)
        ci = "".join(sigver.cert_from_instance(ass)[0].split())
        assert ci == self.sec.my_cert

        res = self.sec.verify_signature("%s" % s_assertion,
                                        node_name=class_name(ass))
        assert res

        res = self.sec._check_signature(s_assertion, ass, class_name(ass))

        assert res

    def test_exception_sign_verify_with_cert_from_instance(self):
        assertion = factory(saml.Assertion,
                            version="2.0",
                            id="11100",
                            issue_instant="2009-10-30T13:20:28Z",
                            #signature= sigver.pre_signature_part("11100",
                            # self.sec.my_cert),
                            attribute_statement=do_attribute_statement({
                                ("", "", "surName"): ("Foo", ""),
                                ("", "", "givenName"): ("Bar", ""),
                            })
        )

        response = factory(samlp.Response,
                           assertion=assertion,
                           id="22222",
                           signature=sigver.pre_signature_part("22222",
                                                               self.sec
                                                               .my_cert))

        to_sign = [(class_name(response), response.id)]

        s_response = sigver.signed_instance_factory(response, self.sec, to_sign)

        response2 = response_from_string(s_response)
        # Change something that should make everything fail
        response2.id = "23456"
        raises(sigver.SignatureError, self.sec._check_signature,
               s_response, response2, class_name(response2))



class TestSecurityMetadata():
    def setup_class(self):
        conf = config.SPConfig()
        conf.load_file("server_conf")
        md = MetadataStore([saml, samlp], None, conf)
        md.load("local", full_path("metadata_cert.xml"))

        conf.metadata = md
        conf.only_use_keys_in_metadata = False
        self.sec = sigver.security_context(conf)

        assertion = factory(
            saml.Assertion, version="2.0", id="11111",
            issue_instant="2009-10-30T13:20:28Z",
            signature=sigver.pre_signature_part("11111", self.sec.my_cert, 1),
            attribute_statement=do_attribute_statement(
                {("", "", "surName"): ("Foo", ""),
                 ("", "", "givenName"): ("Bar", ""), })
        )


def test_xbox():
    conf = config.SPConfig()
    conf.load_file("server_conf")
    md = MetadataStore([saml, samlp], None, conf)
    md.load("local", full_path("idp_example.xml"))

    conf.metadata = md
    conf.only_use_keys_in_metadata = False
    sec = sigver.security_context(conf)

    assertion = factory(
        saml.Assertion, version="2.0", id="11111",
        issue_instant="2009-10-30T13:20:28Z",
        signature=sigver.pre_signature_part("11111", sec.my_cert, 1),
        attribute_statement=do_attribute_statement(
            {("", "", "surName"): ("Foo", ""),
             ("", "", "givenName"): ("Bar", ""), })
    )

    sigass = sec.sign_statement(assertion, class_name(assertion),
                                key_file="pki/mykey.pem", node_id=assertion.id)

    _ass0 = saml.assertion_from_string(sigass)

    encrypted_assertion = EncryptedAssertion()
    encrypted_assertion.add_extension_element(_ass0)

    _, pre = make_temp("%s" % pre_encryption_part(), decode=False)
    enctext = sec.crypto.encrypt(
        "%s" % encrypted_assertion, conf.cert_file, pre, "des-192",
        '/*[local-name()="EncryptedAssertion"]/*[local-name()="Assertion"]')


    decr_text = sec.decrypt(enctext)
    _seass = saml.encrypted_assertion_from_string(decr_text)
    assertions = []
    assers = extension_elements_to_elements(_seass.extension_elements,
                                            [saml, samlp])

    sign_cert_file = "pki/mycert.pem"

    for ass in assers:
        _ass = "%s" % ass
        #_ass = _ass.replace('xsi:nil="true" ', '')
        #assert sigass == _ass
        _txt = sec.verify_signature(_ass, sign_cert_file,
                                    node_name=class_name(assertion))
        if _txt:
            assertions.append(ass)

    print assertions


if __name__ == "__main__":
    t = TestSecurity()
    t.setup_class()
    t.test_non_verify_2()

########NEW FILE########
__FILENAME__ = test_41_response
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from saml2 import config
from saml2.authn_context import INTERNETPROTOCOLPASSWORD

from saml2.server import Server
from saml2.response import response_factory
from saml2.response import StatusResponse
from saml2.response import AuthnResponse
from saml2.sigver import security_context, SignatureError
from saml2.sigver import MissingKey

from pytest import raises

FALSE_ASSERT_SIGNED = "saml_false_signed.xml"


def _eq(l1, l2):
    return set(l1) == set(l2)


IDENTITY = {"eduPersonAffiliation": ["staff", "member"],
            "surName": ["Jeter"], "givenName": ["Derek"],
            "mail": ["foo@gmail.com"],
            "title": ["shortstop"]}

AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


class TestResponse:
    def setup_class(self):
        server = Server("idp_conf")
        name_id = server.ident.transient_nameid(
            "urn:mace:example.com:saml:roland:sp", "id12")

        self._resp_ = server.create_authn_response(
            IDENTITY,
            "id12",  # in_response_to
            "http://lingon.catalogix.se:8087/",
            # consumer_url
            "urn:mace:example.com:saml:roland:sp",
            # sp_entity_id
            name_id=name_id)

        self._sign_resp_ = server.create_authn_response(
            IDENTITY,
            "id12",  # in_response_to
            "http://lingon.catalogix.se:8087/",  # consumer_url
            "urn:mace:example.com:saml:roland:sp",  # sp_entity_id
            name_id=name_id,
            sign_assertion=True)

        self._resp_authn = server.create_authn_response(
            IDENTITY,
            "id12",  # in_response_to
            "http://lingon.catalogix.se:8087/",  # consumer_url
            "urn:mace:example.com:saml:roland:sp",  # sp_entity_id
            name_id=name_id,
            authn=AUTHN)

        conf = config.SPConfig()
        conf.load_file("server_conf")
        self.conf = conf

    def test_1(self):
        xml_response = ("%s" % (self._resp_,))
        resp = response_factory(xml_response, self.conf,
                                return_addrs=[
                                    "http://lingon.catalogix.se:8087/"],
                                outstanding_queries={
                                    "id12": "http://localhost:8088/sso"},
                                timeslack=10000, decode=False)

        assert isinstance(resp, StatusResponse)
        assert isinstance(resp, AuthnResponse)

    def test_2(self):
        xml_response = self._sign_resp_
        resp = response_factory(xml_response, self.conf,
                                return_addrs=[
                                    "http://lingon.catalogix.se:8087/"],
                                outstanding_queries={
                                    "id12": "http://localhost:8088/sso"},
                                timeslack=10000, decode=False)

        assert isinstance(resp, StatusResponse)
        assert isinstance(resp, AuthnResponse)

    def test_false_sign(self):
        xml_response = open(FALSE_ASSERT_SIGNED).read()
        resp = response_factory(
            xml_response, self.conf,
            return_addrs=["http://lingon.catalogix.se:8087/"],
            outstanding_queries={
                "bahigehogffohiphlfmplepdpcohkhhmheppcdie":
                    "http://localhost:8088/sso"},
            timeslack=10000, decode=False)

        assert isinstance(resp, StatusResponse)
        assert isinstance(resp, AuthnResponse)
        try:
            resp.verify()
        except SignatureError:
            pass
        else:
            assert False

if __name__ == "__main__":
    t = TestResponse()
    t.setup_class()
    t.test_false_sign()

########NEW FILE########
__FILENAME__ = test_42_enc
from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.server import Server
from saml2.sigver import pre_encryption_part, ASSERT_XPATH, EncryptError
from saml2.sigver import CryptoBackendXmlSec1
from saml2.sigver import pre_encrypt_assertion
from pathutils import xmlsec_path
from pathutils import full_path

__author__ = 'roland'

TMPL = """<?xml version='1.0' encoding='UTF-8'?>
<ns0:EncryptedData xmlns:ns0="http://www.w3.org/2001/04/xmlenc#" xmlns:ns1="http://www.w3.org/2000/09/xmldsig#" Id="ED" Type="http://www.w3.org/2001/04/xmlenc#Element"><ns0:EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#tripledes-cbc" /><ns1:KeyInfo><ns0:EncryptedKey Id="EK"><ns0:EncryptionMethod Algorithm="http://www.w3.org/2001/04/xmlenc#rsa-1_5" /><ns1:KeyInfo><ns1:KeyName>my-rsa-key</ns1:KeyName></ns1:KeyInfo><ns0:CipherData><ns0:CipherValue /></ns0:CipherData></ns0:EncryptedKey></ns1:KeyInfo><ns0:CipherData><ns0:CipherValue /></ns0:CipherData></ns0:EncryptedData>"""

IDENTITY = {"eduPersonAffiliation": ["staff", "member"],
            "surName": ["Jeter"], "givenName": ["Derek"],
            "mail": ["foo@gmail.com"],
            "title": ["shortstop"]}


AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


def test_pre_enc():
    tmpl = pre_encryption_part()
    print tmpl
    assert "%s" % tmpl == TMPL


def test_reshuffle_response():
    server = Server("idp_conf")
    name_id = server.ident.transient_nameid(
        "urn:mace:example.com:saml:roland:sp", "id12")

    resp_ = server.create_authn_response(
        IDENTITY, "id12", "http://lingon.catalogix.se:8087/",
        "urn:mace:example.com:saml:roland:sp", name_id=name_id)

    resp2 = pre_encrypt_assertion(resp_)

    print resp2
    assert resp2.encrypted_assertion.extension_elements


def test_enc1():
    server = Server("idp_conf")
    name_id = server.ident.transient_nameid(
        "urn:mace:example.com:saml:roland:sp", "id12")

    resp_ = server.create_authn_response(
        IDENTITY, "id12", "http://lingon.catalogix.se:8087/",
        "urn:mace:example.com:saml:roland:sp", name_id=name_id)

    statement = pre_encrypt_assertion(resp_)

    tmpl = "enc_tmpl.xml"
    # tmpl_file = open(tmpl, "w")
    # tmpl_file.write("%s" % pre_encryption_part())
    # tmpl_file.close()

    data = "pre_enc.xml"
    # data_file = open(data, "w")
    # data_file.write("%s" % statement)
    # data_file.close()

    key_type = "des-192"
    com_list = [xmlsec_path, "encrypt", "--pubkey-cert-pem", full_path("pubkey.pem"),
                "--session-key", key_type, "--xml-data", data,
                "--node-xpath", ASSERT_XPATH]

    crypto = CryptoBackendXmlSec1(xmlsec_path)
    (_stdout, _stderr, output) = crypto._run_xmlsec(
        com_list, [tmpl], exception=EncryptError, validate_output=False)

    print output
    assert _stderr == ""
    assert _stdout == ""


def test_enc2():
    crypto = CryptoBackendXmlSec1(xmlsec_path)

    server = Server("idp_conf")
    name_id = server.ident.transient_nameid(
        "urn:mace:example.com:saml:roland:sp", "id12")

    resp_ = server.create_authn_response(
        IDENTITY, "id12", "http://lingon.catalogix.se:8087/",
        "urn:mace:example.com:saml:roland:sp", name_id=name_id)

    enc_resp = crypto.encrypt_assertion(resp_, full_path("pubkey.pem"),
                                        pre_encryption_part())

    print enc_resp
    assert enc_resp

if __name__ == "__main__":
    test_enc1()

########NEW FILE########
__FILENAME__ = test_43_soap
#!/usr/bin/env python

try:
    from xml.etree import cElementTree as ElementTree
    if ElementTree.VERSION < '1.3.0':
        # cElementTree has no support for register_namespace
        # neither _namespace_map, thus we sacrify performance
        # for correctness
        from xml.etree import ElementTree
except ImportError:
    try:
        import cElementTree as ElementTree
    except ImportError:
        from elementtree import ElementTree

import saml2.samlp as samlp
from saml2.samlp import NAMESPACE as SAMLP_NAMESPACE

NAMESPACE = "http://schemas.xmlsoap.org/soap/envelope/"

example = """<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/">
    <Body>
        <samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol" 
            xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion" 
            ID="_6c3a4f8b9c2d" Version="2.0" IssueInstant="2004-03-27T08:42:00Z">
        <saml:Issuer>https://www.example.com/SAML</saml:Issuer>
        <Status>
        <StatusCode Value='urn:oasis:names:tc:SAML:2.0:status:Success'/>
        </Status>
        <saml:Assertion>
        <saml:Subject></saml:Subject>
        <saml:AttributeStatement></saml:AttributeStatement>
        </saml:Assertion>
        </samlp:Response>
    </Body>
</Envelope>
"""


def test_parse_soap_envelope():
    envelope = ElementTree.fromstring(example)
    assert envelope.tag == '{%s}Envelope' % NAMESPACE
    # How to check that it's the right type ?
    assert len(envelope) == 1
    body = envelope[0]
    assert body.tag == '{%s}Body' % NAMESPACE
    assert len(body) == 1
    saml_part = body[0]
    assert saml_part.tag == '{%s}Response' % SAMLP_NAMESPACE
    # {http://schemas.xmlsoap.org/soap/envelope/}Envelope


def test_make_soap_envelope():
    envelope = ElementTree.Element('')
    envelope.tag = '{%s}Envelope' % NAMESPACE
    body = ElementTree.Element('')
    body.tag = '{%s}Body' % NAMESPACE
    envelope.append(body)    
    request = samlp.AuthnRequest()
    request.become_child_element_of(body)

    assert envelope.tag == '{%s}Envelope' % NAMESPACE
    assert len(envelope) == 1
    body = envelope[0]
    assert body.tag == '{%s}Body' % NAMESPACE
    assert len(body) == 1
    saml_part = body[0]
    assert saml_part.tag == '{%s}AuthnRequest' % SAMLP_NAMESPACE

########NEW FILE########
__FILENAME__ = test_44_authnresp
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from saml2.authn_context import INTERNETPROTOCOLPASSWORD

from saml2.server import Server
from saml2.response import authn_response
from saml2.config import config_factory

from pathutils import dotname, full_path

XML_RESPONSE_FILE = full_path("saml_signed.xml")
XML_RESPONSE_FILE2 = full_path("saml2_response.xml")


def _eq(l1, l2):
    return set(l1) == set(l2)

IDENTITY = {"eduPersonAffiliation": ["staff", "member"],
            "surName": ["Jeter"], "givenName": ["Derek"],
            "mail": ["foo@gmail.com"],
            "title": ["shortstop"]}

AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


class TestAuthnResponse:
    def setup_class(self):
        server = Server(dotname("idp_conf"))
        name_id = server.ident.transient_nameid(
                            "urn:mace:example.com:saml:roland:sp","id12")

        self._resp_ = server.create_authn_response(
                            IDENTITY,
                            "id12",                       # in_response_to
                            "http://lingon.catalogix.se:8087/",   # consumer_url
                            "urn:mace:example.com:saml:roland:sp", # sp_entity_id
                            name_id=name_id,
                            authn=AUTHN)
                
        self._sign_resp_ = server.create_authn_response(
                            IDENTITY,
                            "id12",                       # in_response_to
                            "http://lingon.catalogix.se:8087/",   # consumer_url
                            "urn:mace:example.com:saml:roland:sp", # sp_entity_id
                            name_id=name_id, sign_assertion=True,
                            authn=AUTHN)

        self._resp_authn = server.create_authn_response(
                            IDENTITY,
                            "id12",                       # in_response_to
                            "http://lingon.catalogix.se:8087/",   # consumer_url
                            "urn:mace:example.com:saml:roland:sp", # sp_entity_id
                            name_id=name_id,
                            authn=AUTHN)

        self.conf = config_factory("sp", dotname("server_conf"))
        self.conf.only_use_keys_in_metadata = False
        self.ar = authn_response(self.conf, "http://lingon.catalogix.se:8087/")
    
    def test_verify_1(self):
        xml_response = "%s" % (self._resp_,)
        print xml_response
        self.ar.outstanding_queries = {"id12": "http://localhost:8088/sso"}
        self.ar.timeslack = 10000
        self.ar.loads(xml_response, decode=False)
        self.ar.verify()
        
        print self.ar.__dict__
        assert self.ar.came_from == 'http://localhost:8088/sso'
        assert self.ar.session_id() == "id12"
        assert self.ar.ava["eduPersonAffiliation"] == IDENTITY["eduPersonAffiliation"]
        assert self.ar.name_id
        assert self.ar.issuer() == 'urn:mace:example.com:saml:roland:idp'
    
    def test_verify_signed_1(self):
        xml_response = self._sign_resp_
        print xml_response
        
        self.ar.outstanding_queries = {"id12": "http://localhost:8088/sso"}
        self.ar.timeslack = 10000
        self.ar.loads(xml_response, decode=False)
        self.ar.verify()
        
        print self.ar.__dict__
        assert self.ar.came_from == 'http://localhost:8088/sso'
        assert self.ar.session_id() == "id12"
        assert self.ar.ava["sn"] == IDENTITY["surName"]
        assert self.ar.issuer() == 'urn:mace:example.com:saml:roland:idp'
        assert self.ar.name_id

    def test_parse_2(self):
        xml_response = open(XML_RESPONSE_FILE).read()
        ID = "bahigehogffohiphlfmplepdpcohkhhmheppcdie"
        self.ar.outstanding_queries = {ID: "http://localhost:8088/foo"}    
        self.ar.return_addr = "http://xenosmilus.umdc.umu.se:8087/login"
        self.ar.entity_id = "xenosmilus.umdc.umu.se"
        # roughly a year, should create the response on the fly
        self.ar.timeslack = 315360000 # indecent long time
        self.ar.loads(xml_response, decode=False)
        self.ar.verify()
        
        print self.ar.__dict__
        assert self.ar.came_from == 'http://localhost:8088/foo'
        assert self.ar.session_id() == ID
        assert self.ar.name_id

    def test_verify_w_authn(self):
        xml_response = "%s" % (self._resp_authn,)
        self.ar.outstanding_queries = {"id12": "http://localhost:8088/sso"}
        self.ar.return_addr = "http://lingon.catalogix.se:8087/"
        self.ar.entity_id = "urn:mace:example.com:saml:roland:sp"
        self.ar.timeslack = 10000
        self.ar.loads(xml_response, decode=False)
        self.ar.verify()

        print self.ar.assertion
        assert len(self.ar.assertion.authn_statement) == 1
        authn_info = self.ar.authn_info()
        assert len(authn_info) == 1
        assert authn_info[0][0] == INTERNETPROTOCOLPASSWORD
        assert authn_info[0][1] == ["http://www.example.com/login"]
        session_info = self.ar.session_info()
        assert session_info["authn_info"] == authn_info

if __name__ == "__main__":
    t = TestAuthnResponse()
    t.setup_class()
    t.test_verify_1()
########NEW FILE########
__FILENAME__ = test_50_server
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import base64
from urlparse import parse_qs
from saml2.sigver import pre_encryption_part
from saml2.assertion import Policy
from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.saml import NameID, NAMEID_FORMAT_TRANSIENT
from saml2.samlp import response_from_string

from saml2.server import Server
from saml2 import samlp
from saml2 import saml
from saml2 import client
from saml2 import config
from saml2 import class_name
from saml2 import extension_elements_to_elements
from saml2 import s_utils
from saml2 import sigver
from saml2 import time_util
from saml2.s_utils import OtherError
from saml2.s_utils import do_attribute_statement
from saml2.s_utils import factory
from saml2.soap import make_soap_enveloped_saml_thingy
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_REDIRECT

from py.test import raises

nid = NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT,
             text="123456")

AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


def _eq(l1, l2):
    return set(l1) == set(l2)


class TestServer1():
    def setup_class(self):
        self.server = Server("idp_conf")

        conf = config.SPConfig()
        conf.load_file("server_conf")
        self.client = client.Saml2Client(conf)

    def teardown_class(self):
        self.server.ident.close()

    def test_issuer(self):
        issuer = self.server._issuer()
        assert isinstance(issuer, saml.Issuer)
        assert _eq(issuer.keyswv(), ["text", "format"])
        assert issuer.format == saml.NAMEID_FORMAT_ENTITY
        assert issuer.text == self.server.config.entityid

    def test_assertion(self):
        assertion = s_utils.assertion_factory(
            subject=factory(
                saml.Subject, text="_aaa",
                name_id=factory(saml.NameID,
                                format=saml.NAMEID_FORMAT_TRANSIENT)),
            attribute_statement=do_attribute_statement(
                {
                    ("", "", "surName"): ("Jeter", ""),
                    ("", "", "givenName"): ("Derek", ""),
                }
            ),
            issuer=self.server._issuer(),
        )

        assert _eq(assertion.keyswv(), ['attribute_statement', 'issuer', 'id',
                                        'subject', 'issue_instant', 'version'])
        assert assertion.version == "2.0"
        assert assertion.issuer.text == "urn:mace:example.com:saml:roland:idp"
        #
        assert assertion.attribute_statement
        attribute_statement = assertion.attribute_statement
        assert len(attribute_statement.attribute) == 2
        attr0 = attribute_statement.attribute[0]
        attr1 = attribute_statement.attribute[1]
        if attr0.attribute_value[0].text == "Derek":
            assert attr0.friendly_name == "givenName"
            assert attr1.friendly_name == "surName"
            assert attr1.attribute_value[0].text == "Jeter"
        else:
            assert attr1.friendly_name == "givenName"
            assert attr1.attribute_value[0].text == "Derek"
            assert attr0.friendly_name == "surName"
            assert attr0.attribute_value[0].text == "Jeter"
        # 
        subject = assertion.subject
        assert _eq(subject.keyswv(), ["text", "name_id"])
        assert subject.text == "_aaa"
        assert subject.name_id.format == saml.NAMEID_FORMAT_TRANSIENT

    def test_response(self):
        response = sigver.response_factory(
            in_response_to="_012345",
            destination="https:#www.example.com",
            status=s_utils.success_status_factory(),
            assertion=s_utils.assertion_factory(
                subject=factory(saml.Subject, text="_aaa",
                                name_id=saml.NAMEID_FORMAT_TRANSIENT),
                attribute_statement=do_attribute_statement(
                    {
                        ("", "", "surName"): ("Jeter", ""),
                        ("", "", "givenName"): ("Derek", ""),
                    }
                ),
                issuer=self.server._issuer(),
            ),
            issuer=self.server._issuer(),
        )

        print response.keyswv()
        assert _eq(response.keyswv(), ['destination', 'assertion', 'status',
                                       'in_response_to', 'issue_instant',
                                       'version', 'issuer', 'id'])
        assert response.version == "2.0"
        assert response.issuer.text == "urn:mace:example.com:saml:roland:idp"
        assert response.destination == "https:#www.example.com"
        assert response.in_response_to == "_012345"
        #
        status = response.status
        print status
        assert status.status_code.value == samlp.STATUS_SUCCESS

    def test_parse_faulty_request(self):
        req_id, authn_request = self.client.create_authn_request(
            destination="http://www.example.com", id="id1")

        # should raise an error because faulty spentityid
        binding = BINDING_HTTP_REDIRECT
        htargs = self.client.apply_binding(
            binding, "%s" % authn_request, "http://www.example.com", "abcd")
        _dict = parse_qs(htargs["headers"][0][1].split('?')[1])
        print _dict
        raises(OtherError, self.server.parse_authn_request,
               _dict["SAMLRequest"][0], binding)

    def test_parse_faulty_request_to_err_status(self):
        req_id, authn_request = self.client.create_authn_request(
            destination="http://www.example.com")

        binding = BINDING_HTTP_REDIRECT
        htargs = self.client.apply_binding(binding, "%s" % authn_request,
                                           "http://www.example.com", "abcd")
        _dict = parse_qs(htargs["headers"][0][1].split('?')[1])
        print _dict

        try:
            self.server.parse_authn_request(_dict["SAMLRequest"][0], binding)
            status = None
        except OtherError, oe:
            print oe.args
            status = s_utils.error_status_factory(oe)

        assert status
        print status
        assert _eq(status.keyswv(), ["status_code", "status_message"])
        assert status.status_message.text == 'Not destined for me!'
        status_code = status.status_code
        assert _eq(status_code.keyswv(), ["status_code", "value"])
        assert status_code.value == samlp.STATUS_RESPONDER
        assert status_code.status_code.value == samlp.STATUS_UNKNOWN_PRINCIPAL

    def test_parse_ok_request(self):
        req_id, authn_request = self.client.create_authn_request(
            message_id="id1", destination="http://localhost:8088/sso")

        print authn_request
        binding = BINDING_HTTP_REDIRECT
        htargs = self.client.apply_binding(binding, "%s" % authn_request,
                                           "http://www.example.com", "abcd")
        _dict = parse_qs(htargs["headers"][0][1].split('?')[1])
        print _dict

        req = self.server.parse_authn_request(_dict["SAMLRequest"][0], binding)
        # returns a dictionary
        print req
        resp_args = self.server.response_args(req.message, [BINDING_HTTP_POST])
        assert resp_args["destination"] == "http://lingon.catalogix.se:8087/"
        assert resp_args["in_response_to"] == "id1"
        name_id_policy = resp_args["name_id_policy"]
        assert _eq(name_id_policy.keyswv(), ["format", "allow_create"])
        assert name_id_policy.format == saml.NAMEID_FORMAT_TRANSIENT
        assert resp_args[
                   "sp_entity_id"] == "urn:mace:example.com:saml:roland:sp"

    def test_sso_response_with_identity(self):
        name_id = self.server.ident.transient_nameid(
            "urn:mace:example.com:saml:roland:sp", "id12")
        resp = self.server.create_authn_response(
            {
                "eduPersonEntitlement": "Short stop",
                "surName": "Jeter",
                "givenName": "Derek",
                "mail": "derek.jeter@nyy.mlb.com",
                "title": "The man"
            },
            "id12",  # in_response_to
            "http://localhost:8087/",  # destination
            "urn:mace:example.com:saml:roland:sp",  # sp_entity_id
            name_id=name_id,
            authn=AUTHN
        )

        print resp.keyswv()
        assert _eq(resp.keyswv(), ['status', 'destination', 'assertion',
                                   'in_response_to', 'issue_instant',
                                   'version', 'id', 'issuer'])
        assert resp.destination == "http://localhost:8087/"
        assert resp.in_response_to == "id12"
        assert resp.status
        assert resp.status.status_code.value == samlp.STATUS_SUCCESS
        assert resp.assertion
        assert resp.assertion
        assertion = resp.assertion
        print assertion
        assert assertion.authn_statement
        assert assertion.conditions
        assert assertion.attribute_statement
        attribute_statement = assertion.attribute_statement
        print attribute_statement
        assert len(attribute_statement[0].attribute) == 5
        # Pick out one attribute
        attr = None
        for attr in attribute_statement[0].attribute:
            if attr.friendly_name == "edupersonentitlement":
                break
        assert len(attr.attribute_value) == 1
        assert attr.name == "urn:oid:1.3.6.1.4.1.5923.1.1.1.7"
        assert attr.name_format == "urn:oasis:names:tc:SAML:2" \
                                   ".0:attrname-format:uri"
        value = attr.attribute_value[0]
        assert value.text.strip() == "Short stop"
        assert value.get_type() == "xs:string"
        assert assertion.subject
        assert assertion.subject.name_id
        assert assertion.subject.subject_confirmation
        confirmation = assertion.subject.subject_confirmation[0]
        print confirmation.keyswv()
        print confirmation.subject_confirmation_data
        assert confirmation.subject_confirmation_data.in_response_to == "id12"

    def test_sso_response_without_identity(self):
        resp = self.server.create_authn_response(
            {},
              "id12",  # in_response_to
              "http://localhost:8087/",  # consumer_url
              "urn:mace:example.com:saml:roland:sp",  # sp_entity_id
              userid="USER1",
              authn=AUTHN,
              release_policy=Policy(),
              best_effort=True
        )

        print resp.keyswv()
        assert _eq(resp.keyswv(), ['status', 'destination', 'in_response_to',
                                   'issue_instant', 'version', 'id', 'issuer',
                                   'assertion'])
        assert resp.destination == "http://localhost:8087/"
        assert resp.in_response_to == "id12"
        assert resp.status
        assert resp.status.status_code.value == samlp.STATUS_SUCCESS
        assert resp.issuer.text == "urn:mace:example.com:saml:roland:idp"
        assert not resp.assertion.attribute_statement

    def test_sso_response_specific_instant(self):
        _authn = AUTHN.copy()
        _authn["authn_instant"] = 1234567890

        resp = self.server.create_authn_response(
            {},
              "id12",  # in_response_to
              "http://localhost:8087/",  # consumer_url
              "urn:mace:example.com:saml:roland:sp",  # sp_entity_id
              userid="USER1",
              authn=_authn,
              best_effort=True
        )

        print resp.keyswv()
        assert _eq(resp.keyswv(), ['status', 'destination', 'in_response_to',
                                   'issue_instant', 'version', 'id', 'issuer',
                                   'assertion'])
        authn_statement = resp.assertion.authn_statement[0]
        assert authn_statement.authn_instant == '2009-02-13T23:31:30Z'

    def test_sso_failure_response(self):
        exc = s_utils.MissingValue("eduPersonAffiliation missing")
        resp = self.server.create_error_response(
            "id12", "http://localhost:8087/", exc)

        print resp.keyswv()
        assert _eq(resp.keyswv(), ['status', 'destination', 'in_response_to',
                                   'issue_instant', 'version', 'id', 'issuer'])
        assert resp.destination == "http://localhost:8087/"
        assert resp.in_response_to == "id12"
        assert resp.status
        print resp.status
        assert resp.status.status_code.value == samlp.STATUS_RESPONDER
        assert resp.status.status_code.status_code.value == \
               samlp.STATUS_REQUEST_UNSUPPORTED
        assert resp.status.status_message.text == \
               "eduPersonAffiliation missing"
        assert resp.issuer.text == "urn:mace:example.com:saml:roland:idp"
        assert not resp.assertion

    def test_authn_response_0(self):
        self.server = Server("idp_conf")

        conf = config.SPConfig()
        conf.load_file("server_conf")
        self.client = client.Saml2Client(conf)

        ava = {"givenName": ["Derek"], "surName": ["Jeter"],
               "mail": ["derek@nyy.mlb.com"], "title": "The man"}

        npolicy = samlp.NameIDPolicy(format=saml.NAMEID_FORMAT_TRANSIENT,
                                     allow_create="true")
        resp_str = "%s" % self.server.create_authn_response(
            ava, "id1", "http://local:8087/",
            "urn:mace:example.com:saml:roland:sp", npolicy,
            "foba0001@example.com", authn=AUTHN)

        response = samlp.response_from_string(resp_str)
        print response.keyswv()
        assert _eq(response.keyswv(), ['status', 'destination', 'assertion',
                                       'in_response_to', 'issue_instant',
                                       'version', 'issuer', 'id'])
        print response.assertion[0].keyswv()
        assert len(response.assertion) == 1
        assert _eq(response.assertion[0].keyswv(), ['attribute_statement',
                                                    'issue_instant', 'version',
                                                    'subject', 'conditions',
                                                    'id', 'issuer',
                                                    'authn_statement'])
        assertion = response.assertion[0]
        assert len(assertion.attribute_statement) == 1
        astate = assertion.attribute_statement[0]
        print astate
        assert len(astate.attribute) == 4

    def test_signed_response(self):
        name_id = self.server.ident.transient_nameid(
            "urn:mace:example.com:saml:roland:sp", "id12")
        ava = {"givenName": ["Derek"], "surName": ["Jeter"],
               "mail": ["derek@nyy.mlb.com"], "title": "The man"}

        signed_resp = self.server.create_authn_response(
            ava,
            "id12",  # in_response_to
            "http://lingon.catalogix.se:8087/",  # consumer_url
            "urn:mace:example.com:saml:roland:sp",  # sp_entity_id
            name_id=name_id,
            sign_assertion=True
        )

        print signed_resp
        assert signed_resp

        sresponse = response_from_string(signed_resp)
        # It's the assertions that are signed not the response per se
        assert len(sresponse.assertion) == 1
        assertion = sresponse.assertion[0]

        # Since the reponse is created dynamically I don't know the signature
        # value. Just that there should be one
        assert assertion.signature.signature_value.text != ""

    def test_slo_http_post(self):
        soon = time_util.in_a_while(days=1)
        sinfo = {
            "name_id": nid,
            "issuer": "urn:mace:example.com:saml:roland:idp",
            "not_on_or_after": soon,
            "user": {
                "givenName": "Leo",
                "surName": "Laport",
            }
        }
        self.client.users.add_information_about_person(sinfo)

        req_id, logout_request = self.client.create_logout_request(
            destination="http://localhost:8088/slop", name_id=nid,
            issuer_entity_id="urn:mace:example.com:saml:roland:idp",
            reason="I'm tired of this")

        intermed = base64.b64encode("%s" % logout_request)

        #saml_soap = make_soap_enveloped_saml_thingy(logout_request)
        request = self.server.parse_logout_request(intermed, BINDING_HTTP_POST)
        assert request

    def test_slo_soap(self):
        soon = time_util.in_a_while(days=1)
        sinfo = {
            "name_id": nid,
            "issuer": "urn:mace:example.com:saml:roland:idp",
            "not_on_or_after": soon,
            "user": {
                "givenName": "Leo",
                "surName": "Laport",
            }
        }

        sp = client.Saml2Client(config_file="server_conf")
        sp.users.add_information_about_person(sinfo)

        req_id, logout_request = sp.create_logout_request(
            name_id=nid, destination="http://localhost:8088/slo",
            issuer_entity_id="urn:mace:example.com:saml:roland:idp",
            reason="I'm tired of this")

        #_ = s_utils.deflate_and_base64_encode("%s" % (logout_request,))

        saml_soap = make_soap_enveloped_saml_thingy(logout_request)
        self.server.ident.close()
        idp = Server("idp_soap_conf")
        request = idp.parse_logout_request(saml_soap)
        idp.ident.close()
        assert request

#------------------------------------------------------------------------

IDENTITY = {"eduPersonAffiliation": ["staff", "member"],
            "surName": ["Jeter"], "givenName": ["Derek"],
            "mail": ["foo@gmail.com"], "title": "The man"}


class TestServer2():
    def setup_class(self):
        self.server = Server("restrictive_idp_conf")

    def teardown_class(self):
        self.server.ident.close()

    def test_do_attribute_reponse(self):
        aa_policy = self.server.config.getattr("policy", "idp")
        print aa_policy.__dict__
        response = self.server.create_attribute_response(
            IDENTITY.copy(), "aaa", "http://example.com/sp/",
            "urn:mace:example.com:sp:1")

        assert response is not None
        assert response.destination == "http://example.com/sp/"
        assert response.in_response_to == "aaa"
        assert response.version == "2.0"
        assert response.issuer.text == "urn:mace:example.com:saml:roland:idpr"
        assert response.status.status_code.value == samlp.STATUS_SUCCESS
        assert response.assertion
        assertion = response.assertion
        assert assertion.version == "2.0"
        subject = assertion.subject
        #assert subject.name_id.format == saml.NAMEID_FORMAT_TRANSIENT
        assert subject.subject_confirmation
        subject_conf = subject.subject_confirmation[0]
        assert subject_conf.subject_confirmation_data.in_response_to == "aaa"


def _logout_request(conf_file):
    conf = config.SPConfig()
    conf.load_file(conf_file)
    sp = client.Saml2Client(conf)

    soon = time_util.in_a_while(days=1)
    sinfo = {
        "name_id": nid,
        "issuer": "urn:mace:example.com:saml:roland:idp",
        "not_on_or_after": soon,
        "user": {
            "givenName": "Leo",
            "surName": "Laport",
        }
    }
    sp.users.add_information_about_person(sinfo)

    return sp.create_logout_request(
        name_id=nid,
        destination="http://localhost:8088/slo",
        issuer_entity_id="urn:mace:example.com:saml:roland:idp",
        reason="I'm tired of this")


class TestServerLogout():
    def test_1(self):
        server = Server("idp_slo_redirect_conf")
        req_id, request = _logout_request("sp_slo_redirect_conf")
        print request
        bindings = [BINDING_HTTP_REDIRECT]
        response = server.create_logout_response(request, bindings)
        binding, destination = server.pick_binding("single_logout_service",
                                                   bindings, "spsso",
                                                   request)

        http_args = server.apply_binding(binding, "%s" % response, destination,
                                         "relay_state", response=True)

        assert len(http_args) == 4
        assert http_args["headers"][0][0] == "Location"
        assert http_args["data"] == []


if __name__ == "__main__":
    ts = TestServer1()
    ts.setup_class()

########NEW FILE########
__FILENAME__ = test_51_client
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import base64
import urllib
import urlparse
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_HTTP_REDIRECT
from saml2 import config
from saml2 import class_name
from saml2 import extension_elements_to_elements
from saml2 import saml
from saml2 import samlp
from saml2 import sigver
from saml2 import s_utils
from saml2.assertion import Assertion

from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.client import Saml2Client
from saml2.config import SPConfig
from saml2.response import LogoutResponse
from saml2.saml import NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2.saml import NameID
from saml2.server import Server
from saml2.sigver import pre_encryption_part
from saml2.s_utils import do_attribute_statement
from saml2.s_utils import factory
from saml2.time_util import in_a_while

from fakeIDP import FakeIDP
from fakeIDP import unpack_form


AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


def for_me(condition, me):
    for restriction in condition.audience_restriction:
        audience = restriction.audience
        if audience.text.strip() == me:
            return True


def ava(attribute_statement):
    result = {}
    for attribute in attribute_statement.attribute:
        # Check name_format ??
        name = attribute.name.strip()
        result[name] = []
        for value in attribute.attribute_value:
            result[name].append(value.text.strip())
    return result


def _leq(l1, l2):
    return set(l1) == set(l2)

# def test_parse_3():
#     xml_response = open(XML_RESPONSE_FILE3).read()
#     response = samlp.response_from_string(xml_response)
#     client = Saml2Client({})
#     (ava, name_id, real_uri) = \
#             client.do_response(response, "xenosmilus.umdc.umu.se")
#     print 40*"="
#     print ava
#     print 40*","
#     print name_id
#     assert False

REQ1 = {"1.2.14": """<?xml version='1.0' encoding='UTF-8'?>
<ns0:AttributeQuery Destination="https://idp.example.com/idp/" ID="id1"
IssueInstant="%s" Version="2.0" xmlns:ns0="urn:oasis:names:tc:SAML:2
.0:protocol"><ns1:Issuer Format="urn:oasis:names:tc:SAML:2
.0:nameid-format:entity" xmlns:ns1="urn:oasis:names:tc:SAML:2
.0:assertion">urn:mace:example.com:saml:roland:sp</ns1:Issuer><ns1:Subject
xmlns:ns1="urn:oasis:names:tc:SAML:2.0:assertion"><ns1:NameID
Format="urn:oasis:names:tc:SAML:2
.0:nameid-format:persistent">E8042FB4-4D5B-48C3-8E14-8EDD852790DD</ns1:NameID
></ns1:Subject></ns0:AttributeQuery>""",
        "1.2.16": """<?xml version='1.0' encoding='UTF-8'?>
<ns0:AttributeQuery xmlns:ns0="urn:oasis:names:tc:SAML:2.0:protocol"
xmlns:ns1="urn:oasis:names:tc:SAML:2.0:assertion" Destination="https://idp
.example.com/idp/" ID="id1" IssueInstant="%s" Version="2.0"><ns1:Issuer
Format="urn:oasis:names:tc:SAML:2.0:nameid-format:entity">urn:mace:example
.com:saml:roland:sp</ns1:Issuer><ns1:Subject><ns1:NameID
Format="urn:oasis:names:tc:SAML:2
.0:nameid-format:persistent">E8042FB4-4D5B-48C3-8E14-8EDD852790DD</ns1:NameID
></ns1:Subject></ns0:AttributeQuery>"""}

nid = NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT,
             text="123456")


class TestClient:
    def setup_class(self):
        self.server = Server("idp_conf")

        conf = config.SPConfig()
        conf.load_file("server_conf")
        self.client = Saml2Client(conf)

    def test_create_attribute_query1(self):
        req_id, req = self.client.create_attribute_query(
            "https://idp.example.com/idp/",
            "E8042FB4-4D5B-48C3-8E14-8EDD852790DD",
            format=saml.NAMEID_FORMAT_PERSISTENT,
            message_id="id1")
        reqstr = "%s" % req.to_string()

        assert req.destination == "https://idp.example.com/idp/"
        assert req.id == "id1"
        assert req.version == "2.0"
        subject = req.subject
        name_id = subject.name_id
        assert name_id.format == saml.NAMEID_FORMAT_PERSISTENT
        assert name_id.text == "E8042FB4-4D5B-48C3-8E14-8EDD852790DD"
        issuer = req.issuer
        assert issuer.text == "urn:mace:example.com:saml:roland:sp"

        attrq = samlp.attribute_query_from_string(reqstr)

        print attrq.keyswv()
        assert _leq(attrq.keyswv(), ['destination', 'subject', 'issue_instant',
                                     'version', 'id', 'issuer'])

        assert attrq.destination == req.destination
        assert attrq.id == req.id
        assert attrq.version == req.version
        assert attrq.issuer.text == issuer.text
        assert attrq.issue_instant == req.issue_instant
        assert attrq.subject.name_id.format == name_id.format
        assert attrq.subject.name_id.text == name_id.text

    def test_create_attribute_query2(self):
        req_id, req = self.client.create_attribute_query(
            "https://idp.example.com/idp/",
            "E8042FB4-4D5B-48C3-8E14-8EDD852790DD",
            attribute={
                ("urn:oid:2.5.4.42",
                 "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                 "givenName"): None,
                ("urn:oid:2.5.4.4",
                 "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
                 "surname"): None,
                ("urn:oid:1.2.840.113549.1.9.1",
                 "urn:oasis:names:tc:SAML:2.0:attrname-format:uri"): None,
            },
            format=saml.NAMEID_FORMAT_PERSISTENT,
            message_id="id1")

        print req.to_string()
        assert req.destination == "https://idp.example.com/idp/"
        assert req.id == "id1"
        assert req.version == "2.0"
        subject = req.subject
        name_id = subject.name_id
        assert name_id.format == saml.NAMEID_FORMAT_PERSISTENT
        assert name_id.text == "E8042FB4-4D5B-48C3-8E14-8EDD852790DD"
        assert len(req.attribute) == 3
        # one is givenName
        seen = []
        for attribute in req.attribute:
            if attribute.name == "urn:oid:2.5.4.42":
                assert attribute.name_format == saml.NAME_FORMAT_URI
                assert attribute.friendly_name == "givenName"
                seen.append("givenName")
            elif attribute.name == "urn:oid:2.5.4.4":
                assert attribute.name_format == saml.NAME_FORMAT_URI
                assert attribute.friendly_name == "surname"
                seen.append("surname")
            elif attribute.name == "urn:oid:1.2.840.113549.1.9.1":
                assert attribute.name_format == saml.NAME_FORMAT_URI
                if getattr(attribute, "friendly_name"):
                    assert False
                seen.append("email")
        assert _leq(seen, ["givenName", "surname", "email"])

    def test_create_attribute_query_3(self):
        req_id, req = self.client.create_attribute_query(
            "https://aai-demo-idp.switch.ch/idp/shibboleth",
            "_e7b68a04488f715cda642fbdd90099f5",
            format=saml.NAMEID_FORMAT_TRANSIENT,
            message_id="id1")

        assert isinstance(req, samlp.AttributeQuery)
        assert req.destination == "https://aai-demo-idp.switch" \
                                  ".ch/idp/shibboleth"
        assert req.id == "id1"
        assert req.version == "2.0"
        assert req.issue_instant
        assert req.issuer.text == "urn:mace:example.com:saml:roland:sp"
        nameid = req.subject.name_id
        assert nameid.format == saml.NAMEID_FORMAT_TRANSIENT
        assert nameid.text == "_e7b68a04488f715cda642fbdd90099f5"

    def test_create_auth_request_0(self):
        ar_str = "%s" % self.client.create_authn_request(
            "http://www.example.com/sso", message_id="id1")[1]

        ar = samlp.authn_request_from_string(ar_str)
        print ar
        assert ar.assertion_consumer_service_url == ("http://lingon.catalogix"
                                                     ".se:8087/")
        assert ar.destination == "http://www.example.com/sso"
        assert ar.protocol_binding == BINDING_HTTP_POST
        assert ar.version == "2.0"
        assert ar.provider_name == "urn:mace:example.com:saml:roland:sp"
        assert ar.issuer.text == "urn:mace:example.com:saml:roland:sp"
        nid_policy = ar.name_id_policy
        assert nid_policy.allow_create == "false"
        assert nid_policy.format == saml.NAMEID_FORMAT_TRANSIENT

    def test_create_auth_request_vo(self):
        assert self.client.config.vorg.keys() == [
            "urn:mace:example.com:it:tek"]

        ar_str = "%s" % self.client.create_authn_request(
            "http://www.example.com/sso",
            "urn:mace:example.com:it:tek",  # vo
            nameid_format=NAMEID_FORMAT_PERSISTENT,
            message_id="666")[1]

        ar = samlp.authn_request_from_string(ar_str)
        print ar
        assert ar.id == "666"
        assert ar.assertion_consumer_service_url == "http://lingon.catalogix" \
                                                    ".se:8087/"
        assert ar.destination == "http://www.example.com/sso"
        assert ar.protocol_binding == BINDING_HTTP_POST
        assert ar.version == "2.0"
        assert ar.provider_name == "urn:mace:example.com:saml:roland:sp"
        assert ar.issuer.text == "urn:mace:example.com:saml:roland:sp"
        nid_policy = ar.name_id_policy
        assert nid_policy.allow_create == "false"
        assert nid_policy.format == saml.NAMEID_FORMAT_PERSISTENT
        assert nid_policy.sp_name_qualifier == "urn:mace:example.com:it:tek"

    def test_sign_auth_request_0(self):
        #print self.client.config

        req_id, areq = self.client.create_authn_request(
            "http://www.example.com/sso", sign=True, message_id="id1")

        ar_str = "%s" % areq
        ar = samlp.authn_request_from_string(ar_str)

        assert ar
        assert ar.signature
        assert ar.signature.signature_value
        signed_info = ar.signature.signed_info
        #print signed_info
        assert len(signed_info.reference) == 1
        assert signed_info.reference[0].uri == "#id1"
        assert signed_info.reference[0].digest_value
        print "------------------------------------------------"
        try:
            assert self.client.sec.correctly_signed_authn_request(
                ar_str, self.client.config.xmlsec_binary,
                self.client.config.metadata)
        except Exception:  # missing certificate
            self.client.sec.verify_signature(ar_str, node_name=class_name(ar))

    def test_response(self):
        IDP = "urn:mace:example.com:saml:roland:idp"

        ava = {"givenName": ["Derek"], "surName": ["Jeter"],
               "mail": ["derek@nyy.mlb.com"], "title": ["The man"]}

        nameid_policy = samlp.NameIDPolicy(allow_create="false",
                                           format=saml.NAMEID_FORMAT_PERSISTENT)

        resp = self.server.create_authn_response(
            identity=ava,
            in_response_to="id1",
            destination="http://lingon.catalogix.se:8087/",
            sp_entity_id="urn:mace:example.com:saml:roland:sp",
            name_id_policy=nameid_policy,
            userid="foba0001@example.com",
            authn=AUTHN)

        resp_str = "%s" % resp

        resp_str = base64.encodestring(resp_str)

        authn_response = self.client.parse_authn_request_response(
            resp_str, BINDING_HTTP_POST,
            {"id1": "http://foo.example.com/service"})

        assert authn_response is not None
        assert authn_response.issuer() == IDP
        assert authn_response.response.assertion[0].issuer.text == IDP
        session_info = authn_response.session_info()

        print session_info
        assert session_info["ava"] == {'mail': ['derek@nyy.mlb.com'],
                                       'givenName': ['Derek'],
                                       'sn': ['Jeter'],
                                       'title': ["The man"]}
        assert session_info["issuer"] == IDP
        assert session_info["came_from"] == "http://foo.example.com/service"
        response = samlp.response_from_string(authn_response.xmlstr)
        assert response.destination == "http://lingon.catalogix.se:8087/"

        # One person in the cache
        assert len(self.client.users.subjects()) == 1
        subject_id = self.client.users.subjects()[0]
        print "||||", self.client.users.get_info_from(subject_id, IDP)
        # The information I have about the subject comes from one source
        assert self.client.users.issuers_of_info(subject_id) == [IDP]

        # --- authenticate another person

        ava = {"givenName": ["Alfonson"], "surName": ["Soriano"],
               "mail": ["alfonson@chc.mlb.com"], "title": ["outfielder"]}

        resp_str = "%s" % self.server.create_authn_response(
            identity=ava,
            in_response_to="id2",
            destination="http://lingon.catalogix.se:8087/",
            sp_entity_id="urn:mace:example.com:saml:roland:sp",
            name_id_policy=nameid_policy,
            userid="also0001@example.com",
            authn=AUTHN)

        resp_str = base64.encodestring(resp_str)

        self.client.parse_authn_request_response(
            resp_str, BINDING_HTTP_POST,
            {"id2": "http://foo.example.com/service"})

        # Two persons in the cache
        assert len(self.client.users.subjects()) == 2
        issuers = [self.client.users.issuers_of_info(s) for s in
                   self.client.users.subjects()]
        # The information I have about the subjects comes from the same source
        print issuers
        assert issuers == [[IDP], [IDP]]

    def test_init_values(self):
        entityid = self.client.config.entityid
        print entityid
        assert entityid == "urn:mace:example.com:saml:roland:sp"
        print self.client.metadata.with_descriptor("idpsso")
        location = self.client._sso_location()
        print location
        assert location == 'http://localhost:8088/sso'
        my_name = self.client._my_name()
        print my_name
        assert my_name == "urn:mace:example.com:saml:roland:sp"

    def test_sign_then_encrypt_assertion(self):
        # Begin with the IdPs side
        _sec = self.server.sec

        assertion = s_utils.assertion_factory(
            subject=factory(saml.Subject, text="_aaa",
                            name_id=factory(
                                saml.NameID,
                                format=saml.NAMEID_FORMAT_TRANSIENT)),
            attribute_statement=do_attribute_statement(
                {
                    ("", "", "surName"): ("Jeter", ""),
                    ("", "", "givenName"): ("Derek", ""),
                }
            ),
            issuer=self.server._issuer(),
        )

        assertion.signature = sigver.pre_signature_part(
            assertion.id, _sec.my_cert, 1)

        sigass = _sec.sign_statement(assertion, class_name(assertion),
                                     key_file="pki/mykey.pem",
                                     node_id=assertion.id)
        # Create an Assertion instance from the signed assertion
        _ass = saml.assertion_from_string(sigass)

        response = sigver.response_factory(
            in_response_to="_012345",
            destination="https:#www.example.com",
            status=s_utils.success_status_factory(),
            issuer=self.server._issuer(),
            assertion=_ass
        )

        enctext = _sec.crypto.encrypt_assertion(response, _sec.cert_file,
                                                pre_encryption_part())

        seresp = samlp.response_from_string(enctext)

        # Now over to the client side
        _csec = self.client.sec
        if seresp.encrypted_assertion:
            decr_text = _csec.decrypt(enctext)
            seresp = samlp.response_from_string(decr_text)
            resp_ass = []

            sign_cert_file = "pki/mycert.pem"
            for enc_ass in seresp.encrypted_assertion:
                assers = extension_elements_to_elements(
                    enc_ass.extension_elements, [saml, samlp])
                for ass in assers:
                    if ass.signature:
                        if not _csec.verify_signature("%s" % ass,
                                                      sign_cert_file,
                                                      node_name=class_name(ass)):
                            continue
                    resp_ass.append(ass)

            seresp.assertion = resp_ass
            seresp.encrypted_assertion = None
            #print _sresp

        assert seresp.assertion

    def test_sign_then_encrypt_assertion2(self):
        # Begin with the IdPs side
        _sec = self.server.sec

        nameid_policy = samlp.NameIDPolicy(allow_create="false",
                                           format=saml.NAMEID_FORMAT_PERSISTENT)

        asser = Assertion({"givenName": "Derek", "surName": "Jeter"})
        assertion = asser.construct(
            self.client.config.entityid, "_012345",
            "http://lingon.catalogix.se:8087/",
            factory(saml.NameID, format=saml.NAMEID_FORMAT_TRANSIENT),
            policy=self.server.config.getattr("policy", "idp"),
            issuer=self.server._issuer(),
            attrconvs=self.server.config.attribute_converters,
            authn_class=INTERNETPROTOCOLPASSWORD,
            authn_auth="http://www.example.com/login")

        assertion.signature = sigver.pre_signature_part(
            assertion.id, _sec.my_cert, 1)

        sigass = _sec.sign_statement(assertion, class_name(assertion),
                                     #key_file="pki/mykey.pem",
                                     key_file="test.key",
                                     node_id=assertion.id)
        # Create an Assertion instance from the signed assertion
        _ass = saml.assertion_from_string(sigass)

        response = sigver.response_factory(
            in_response_to="_012345",
            destination="https://www.example.com",
            status=s_utils.success_status_factory(),
            issuer=self.server._issuer(),
            assertion=_ass
        )

        enctext = _sec.crypto.encrypt_assertion(response, _sec.cert_file,
                                                pre_encryption_part())

        #seresp = samlp.response_from_string(enctext)

        resp_str = base64.encodestring(enctext)
        # Now over to the client side
        resp = self.client.parse_authn_request_response(
            resp_str, BINDING_HTTP_POST,
            {"_012345": "http://foo.example.com/service"})

        #assert resp.encrypted_assertion == []
        assert resp.assertion
        assert resp.ava == {'givenName': ['Derek'], 'sn': ['Jeter']}

# Below can only be done with dummy Server
IDP = "urn:mace:example.com:saml:roland:idp"


class TestClientWithDummy():
    def setup_class(self):
        self.server = FakeIDP("idp_all_conf")

        conf = SPConfig()
        conf.load_file("servera_conf")
        self.client = Saml2Client(conf)

        self.client.send = self.server.receive

    def test_do_authn(self):
        binding = BINDING_HTTP_REDIRECT
        response_binding = BINDING_HTTP_POST
        sid, http_args = self.client.prepare_for_authenticate(
            IDP, "http://www.example.com/relay_state",
            binding=binding, response_binding=response_binding)

        assert isinstance(sid, basestring)
        assert len(http_args) == 4
        assert http_args["headers"][0][0] == "Location"
        assert http_args["data"] == []
        redirect_url = http_args["headers"][0][1]
        _, _, _, _, qs, _ = urlparse.urlparse(redirect_url)
        qs_dict = urlparse.parse_qs(qs)
        req = self.server.parse_authn_request(qs_dict["SAMLRequest"][0],
                                              binding)
        resp_args = self.server.response_args(req.message, [response_binding])
        assert resp_args["binding"] == response_binding

    def test_do_attribute_query(self):
        response = self.client.do_attribute_query(
            IDP, "_e7b68a04488f715cda642fbdd90099f5",
            attribute={"eduPersonAffiliation": None},
            nameid_format=NAMEID_FORMAT_TRANSIENT)

    def test_logout_1(self):
        """ one IdP/AA logout from"""

        # information about the user from an IdP
        session_info = {
            "name_id": nid,
            "issuer": "urn:mace:example.com:saml:roland:idp",
            "not_on_or_after": in_a_while(minutes=15),
            "ava": {
                "givenName": "Anders",
                "surName": "Andersson",
                "mail": "anders.andersson@example.com"
            }
        }
        self.client.users.add_information_about_person(session_info)
        entity_ids = self.client.users.issuers_of_info(nid)
        assert entity_ids == ["urn:mace:example.com:saml:roland:idp"]
        resp = self.client.global_logout(nid, "Tired", in_a_while(minutes=5))
        print resp
        assert resp
        assert len(resp) == 1
        assert resp.keys() == entity_ids
        response = resp[entity_ids[0]]
        assert isinstance(response, LogoutResponse)

    def test_post_sso(self):
        binding = BINDING_HTTP_POST
        response_binding = BINDING_HTTP_POST
        sid, http_args = self.client.prepare_for_authenticate(
            "urn:mace:example.com:saml:roland:idp", relay_state="really",
            binding=binding, response_binding=response_binding)
        _dic = unpack_form(http_args["data"][3])

        req = self.server.parse_authn_request(_dic["SAMLRequest"], binding)
        resp_args = self.server.response_args(req.message, [response_binding])
        assert resp_args["binding"] == response_binding

        # Normally a response would now be sent back to the users web client
        # Here I fake what the client will do
        # create the form post

        http_args["data"] = urllib.urlencode(_dic)
        http_args["method"] = "POST"
        http_args["dummy"] = _dic["SAMLRequest"]
        http_args["headers"] = [('Content-type',
                                 'application/x-www-form-urlencoded')]

        response = self.client.send(**http_args)
        print response.text
        _dic = unpack_form(response.text[3], "SAMLResponse")
        resp = self.client.parse_authn_request_response(_dic["SAMLResponse"],
                                                        BINDING_HTTP_POST,
                                                        {sid: "/"})
        ac = resp.assertion.authn_statement[0].authn_context
        assert ac.authenticating_authority[0].text == \
               'http://www.example.com/login'
        assert ac.authn_context_class_ref.text == INTERNETPROTOCOLPASSWORD


# if __name__ == "__main__":
#     tc = TestClient()
#     tc.setup_class()
#     tc.test_response()

if __name__ == "__main__":
    tc = TestClient()
    tc.setup_class()
    tc.test_sign_then_encrypt_assertion2()

########NEW FILE########
__FILENAME__ = test_60_sp
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import base64
from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2.samlp import NameIDPolicy
from s2repoze.plugins.sp import make_plugin
from saml2.server import Server

ENV1 = {'SERVER_SOFTWARE': 'CherryPy/3.1.2 WSGI Server', 
    'SCRIPT_NAME': '', 
    'ACTUAL_SERVER_PROTOCOL': 'HTTP/1.1', 
    'REQUEST_METHOD': 'GET', 
    'PATH_INFO': '/krissms', 
    'SERVER_PROTOCOL': 'HTTP/1.1', 
    'QUERY_STRING': '', 
    'REMOTE_ADDR': '127.0.0.1', 
    'HTTP_USER_AGENT': 
        'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_2; en-us) ', 
    'HTTP_CONNECTION': 'keep-alive', 
    'SERVER_NAME': 'lingon-catalogix-se-2.local', 
    'REMOTE_PORT': '57309', 
    'wsgi.url_scheme': 'http', 
    'SERVER_PORT': '8087', 
    'HTTP_HOST': '127.0.0.1:8087', 
    'wsgi.multithread': True, 
    'HTTP_ACCEPT': 
        'application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5', 
    'wsgi.version': (1, 0), 
    'wsgi.run_once': False, 
    'wsgi.multiprocess': False, 
    'HTTP_ACCEPT_LANGUAGE': 'en-us', 
    'HTTP_ACCEPT_ENCODING': 'gzip, deflate'}

trans_name_policy = NameIDPolicy(format=NAMEID_FORMAT_TRANSIENT,
                                 allow_create="true")

AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


class TestSP():
    def setup_class(self):
        self.sp = make_plugin("rem", saml_conf="server_conf")
        self.server = Server(config_file="idp_conf")

    def test_setup(self):
        assert self.sp
        
    def test_identify(self):

        # Create a SAMLResponse
        ava = { "givenName": ["Derek"], "surName": ["Jeter"],
                "mail": ["derek@nyy.mlb.com"], "title":["The man"]}

        resp_str = "%s" % self.server.create_authn_response(
            ava, "id1", "http://lingon.catalogix.se:8087/",
            "urn:mace:example.com:saml:roland:sp", trans_name_policy,
            "foba0001@example.com", authn=AUTHN)

        resp_str = base64.encodestring(resp_str)
        self.sp.outstanding_queries = {"id1":"http://www.example.com/service"}
        session_info = self.sp._eval_authn_response({},
            {"SAMLResponse": resp_str})
        
        assert len(session_info) > 1
        assert session_info["came_from"] == 'http://www.example.com/service'
        assert session_info["ava"] == {'givenName': ['Derek'], 
                                        'mail': ['derek@nyy.mlb.com'], 
                                        'sn': ['Jeter'],
                                        'title': ['The man']}


if __name__ == "__main__":
    _sp = TestSP()
    _sp.setup_class()
    _sp.test_identify()

########NEW FILE########
__FILENAME__ = test_62_vo
from saml2.saml import NameID
from saml2.saml import NAMEID_FORMAT_TRANSIENT

__author__ = 'rolandh'

from saml2 import config
from saml2.client import Saml2Client
from saml2.time_util import str_to_time, in_a_while

SESSION_INFO_PATTERN = {"ava": {}, "came from": "", "not_on_or_after": 0,
                        "issuer": "", "session_id": -1}

nid = NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT,
             text="abcdefgh")
nid0 = NameID(name_qualifier="foo", format=NAMEID_FORMAT_TRANSIENT,
              text="01234567")


def add_derek_info(sp):
    not_on_or_after = str_to_time(in_a_while(days=1))
    session_info = SESSION_INFO_PATTERN.copy()
    session_info["ava"] = {"givenName": ["Derek"], "umuselin": ["deje0001"]}
    session_info["issuer"] = "urn:mace:example.com:saml:idp"
    session_info["name_id"] = nid
    session_info["not_on_or_after"] = not_on_or_after
    # subject_id, entity_id, info, timestamp
    sp.users.add_information_about_person(session_info)


class TestVirtualOrg():
    def setup_class(self):
        conf = config.SPConfig()
        conf.load_file("server_conf")
        self.sp = Saml2Client(conf)

        vo_name = conf.vorg.keys()[0]
        self.vo = conf.vorg[vo_name]
        add_derek_info(self.sp)

    def test_mta(self):
        aas = self.vo.members_to_ask(nid)
        print aas
        assert len(aas) == 1
        assert 'urn:mace:example.com:saml:aa' in aas

    def test_unknown_subject(self):
        aas = self.vo.members_to_ask(nid0)
        print aas
        assert len(aas) == 2

    def test_id(self):
        cid = self.vo.get_common_identifier(nid)
        print cid
        assert cid == "deje0001"

    def test_id_unknown(self):
        cid = self.vo.get_common_identifier(nid0)
        assert cid is None


class TestVirtualOrg_2():
    def setup_class(self):
        conf = config.SPConfig()
        conf.load_file("server_conf")
        vo_name = conf.vorg.keys()[0]
        self.sp = Saml2Client(conf, virtual_organization=vo_name)
        add_derek_info(self.sp)

    def test_mta(self):
        aas = self.sp.vorg.members_to_ask(nid)
        print aas
        assert len(aas) == 1
        assert 'urn:mace:example.com:saml:aa' in aas

    def test_unknown_subject(self):
        aas = self.sp.vorg.members_to_ask(nid0)
        print aas
        assert len(aas) == 2

    def test_id(self):
        cid = self.sp.vorg.get_common_identifier(nid)
        print cid
        assert cid == "deje0001"

    def test_id_unknown(self):
        cid = self.sp.vorg.get_common_identifier(nid0)
        assert cid is None

########NEW FILE########
__FILENAME__ = test_63_ecp
from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.httpbase import set_list2dict
from saml2.profile.ecp import RelayState
from saml2.profile.paos import Request
from saml2.server import Server
from saml2.samlp import Response
from saml2.samlp import STATUS_SUCCESS
from saml2.samlp import AuthnRequest
from saml2 import ecp_client
from saml2 import BINDING_SOAP
from saml2 import BINDING_PAOS
from saml2 import create_class_from_xml_string

from saml2.profile import ecp as ecp_prof
from saml2.client import Saml2Client

from pathutils import dotname, full_path

__author__ = 'rolandh'


AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}

def _eq(l1, l2):
    if len(l1) == len(l2):
        return set(l1) == set(l2)
    else:
        return len(l1) == len(l2)


class DummyResponse(object):
    def __init__(self, headers):
        self.headers = headers


def test_complete_flow():
    client = ecp_client.Client("user", "password",
                               metadata_file=full_path("idp_all.xml"))

    sp = Saml2Client(config_file=dotname("servera_conf"))
    idp = Server(config_file=dotname("idp_all_conf"))

    IDP_ENTITY_ID = idp.config.entityid
    #SP_ENTITY_ID = sp.config.entityid

    # ------------ @Client -----------------------------

    headers = client.add_paos_headers([])

    assert len(headers) == 2

    # ------------ @SP -----------------------------

    response = DummyResponse(set_list2dict(headers))

    assert sp.can_handle_ecp_response(response)

    sid, message = sp.create_ecp_authn_request(IDP_ENTITY_ID, relay_state="XYZ")

    # ------------ @Client -----------------------------

    respdict = client.parse_soap_message(message)

    cargs = client.parse_sp_ecp_response(respdict)

    assert isinstance(respdict["body"], AuthnRequest)
    assert len(respdict["header"]) == 2
    item0 = respdict["header"][0]
    assert isinstance(item0, Request) or isinstance(item0, RelayState)

    destination = respdict["body"].destination

    ht_args = client.apply_binding(BINDING_SOAP, respdict["body"], destination)

    # Time to send to the IDP
    # ----------- @IDP -------------------------------

    req = idp.parse_authn_request(ht_args["data"], BINDING_SOAP)

    assert isinstance(req.message, AuthnRequest)

    # create Response and return in the SOAP response
    sp_entity_id = req.sender()

    name_id = idp.ident.transient_nameid( "id12", sp.config.entityid)
    binding, destination = idp.pick_binding("assertion_consumer_service",
                                            [BINDING_PAOS],
                                            entity_id=sp_entity_id)

    resp = idp.create_ecp_authn_request_response(
        destination, {"eduPersonEntitlement": "Short stop",
                      "surName": "Jeter",
                      "givenName": "Derek",
                      "mail": "derek.jeter@nyy.mlb.com",
                      "title": "The man"
                      },
        req.message.id, destination, sp_entity_id,
        name_id=name_id, authn=AUTHN)

    # ------------ @Client -----------------------------
    # The client got the response from the IDP repackage and send it to the SP

    respdict = client.parse_soap_message(resp)
    idp_response = respdict["body"]

    assert isinstance(idp_response, Response)
    assert len(respdict["header"]) == 1

    _ecp_response = None
    for item in respdict["header"]:
        if item.c_tag == "Response" and item.c_namespace == ecp_prof.NAMESPACE:
            _ecp_response = item

    #_acs_url = _ecp_response.assertion_consumer_service_url

    # done phase2 at the client

    ht_args = client.use_soap(idp_response, cargs["rc_url"],
                              [cargs["relay_state"]])

    print ht_args

    # ------------ @SP -----------------------------

    respdict = sp.unpack_soap_message(ht_args["data"])

    # verify the relay_state

    for header in respdict["header"]:
        inst = create_class_from_xml_string(RelayState, header)
        if isinstance(inst, RelayState):
            assert inst.text == "XYZ"

    # parse the response

    resp = sp.parse_authn_request_response(respdict["body"], None, {sid: "/"})

    print resp.response

    assert resp.response.destination == "http://lingon.catalogix.se:8087/paos"
    assert resp.response.status.status_code.value == STATUS_SUCCESS

########NEW FILE########
__FILENAME__ = test_64_artifact
import base64
from hashlib import sha1
from urlparse import urlparse
from urlparse import parse_qs
from saml2 import BINDING_HTTP_ARTIFACT
from saml2 import BINDING_SOAP
from saml2 import BINDING_HTTP_POST
from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.client import Saml2Client

from saml2.entity import create_artifact
from saml2.entity import ARTIFACT_TYPECODE
from saml2.s_utils import sid
from saml2.server import Server

__author__ = 'rolandh'

TAG1 = "name=\"SAMLRequest\" value="


AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


def get_msg(hinfo, binding, response=False):
    if binding == BINDING_SOAP:
        msg = hinfo["data"]
    elif binding == BINDING_HTTP_POST:
        _inp = hinfo["data"][3]
        i = _inp.find(TAG1)
        i += len(TAG1) + 1
        j = _inp.find('"', i)
        msg = _inp[i:j]
    elif binding == BINDING_HTTP_ARTIFACT:
        # either by POST or by redirect
        if hinfo["data"]:
            _inp = hinfo["data"][3]
            i = _inp.find(TAG1)
            i += len(TAG1) + 1
            j = _inp.find('"', i)
            msg = _inp[i:j]
        else:
            parts = urlparse(hinfo["url"])
            msg = parse_qs(parts.query)["SAMLart"][0]
    else: # BINDING_HTTP_REDIRECT
        parts = urlparse(hinfo["headers"][0][1])
        msg = parse_qs(parts.query)["SAMLRequest"][0]

    return msg


def test_create_artifact():
    b64art = create_artifact("http://sp.example.com/saml.xml",
                             "aabbccddeeffgghhiijj")

    art = base64.b64decode(b64art)

    assert art[:2] == '\x00\x04'
    assert int(art[2:4]) == 0

    s = sha1("http://sp.example.com/saml.xml")
    assert art[4:24] == s.digest()

SP = 'urn:mace:example.com:saml:roland:sp'


def test_create_artifact_resolve():
    b64art = create_artifact(SP, "aabbccddeeffgghhiijj", 1)
    artifact = base64.b64decode(b64art)

    #assert artifact[:2] == '\x00\x04'
    #assert int(artifact[2:4]) == 0
    #
    s = sha1(SP)
    assert artifact[4:24] == s.digest()

    idp = Server(config_file="idp_all_conf")

    typecode = artifact[:2]
    assert typecode == ARTIFACT_TYPECODE

    destination = idp.artifact2destination(b64art, "spsso")

    msg_id, msg = idp.create_artifact_resolve(b64art, destination, sid())

    print msg

    args = idp.use_soap(msg, destination, None, False)

    sp = Saml2Client(config_file="servera_conf")

    ar = sp.parse_artifact_resolve(args["data"])

    print ar

    assert ar.artifact.text == b64art


def test_artifact_flow():
    #SP = 'urn:mace:example.com:saml:roland:sp'
    sp = Saml2Client(config_file="servera_conf")
    idp = Server(config_file="idp_all_conf")

    # original request

    binding, destination = sp.pick_binding("single_sign_on_service",
                                           entity_id=idp.config.entityid)
    relay_state = "RS0"
    req_id, req = sp.create_authn_request(destination, id="id1")

    artifact = sp.use_artifact(req, 1)

    binding, destination = sp.pick_binding("single_sign_on_service",
                                           [BINDING_HTTP_ARTIFACT],
                                           entity_id=idp.config.entityid)

    hinfo = sp.apply_binding(binding, "%s" % artifact, destination, relay_state)

    # ========== @IDP ============

    artifact2 = get_msg(hinfo, binding)

    assert artifact == artifact2

    # The IDP now wants to replace the artifact with the real request

    destination = idp.artifact2destination(artifact2, "spsso")

    msg_id, msg = idp.create_artifact_resolve(artifact2, destination, sid())

    hinfo = idp.use_soap(msg, destination, None, False)

    # ======== @SP ==========

    msg = get_msg(hinfo, BINDING_SOAP)

    ar = sp.parse_artifact_resolve(msg)

    assert ar.artifact.text == artifact

    # The SP picks the request out of the repository with the artifact as the key
    oreq = sp.artifact[ar.artifact.text]
    # Should be the same as req above

    # Returns the information over the existing SOAP connection so
    # no transport information needed

    msg = sp.create_artifact_response(ar, ar.artifact.text)
    hinfo = sp.use_soap(msg, destination)

    # ========== @IDP ============

    msg = get_msg(hinfo, BINDING_SOAP)

    # The IDP untangles the request from the artifact resolve response
    spreq = idp.parse_artifact_resolve_response(msg)

    # should be the same as req above

    assert spreq.id == req.id

    # That was one way, the Request from the SP
    # ---------------------------------------------#
    # Now for the other, the response from the IDP

    name_id = idp.ident.transient_nameid(sp.config.entityid, "derek")

    resp_args = idp.response_args(spreq, [BINDING_HTTP_POST])

    response = idp.create_authn_response({"eduPersonEntitlement": "Short stop",
                                          "surName": "Jeter", "givenName": "Derek",
                                          "mail": "derek.jeter@nyy.mlb.com",
                                          "title": "The man"},
                                         name_id=name_id,
                                         authn=AUTHN,
                                         **resp_args)

    print response

    # with the response in hand create an artifact

    artifact = idp.use_artifact(response, 1)

    binding, destination = sp.pick_binding("single_sign_on_service",
                                           [BINDING_HTTP_ARTIFACT],
                                           entity_id=idp.config.entityid)

    hinfo = sp.apply_binding(binding, "%s" % artifact, destination, relay_state,
                             response=True)

    # ========== SP =========

    artifact3 = get_msg(hinfo, binding)

    assert artifact == artifact3

    destination = sp.artifact2destination(artifact3, "idpsso")

    # Got an artifact want to replace it with the real message
    msg_id, msg = sp.create_artifact_resolve(artifact3, destination, sid())

    print msg

    hinfo = sp.use_soap(msg, destination, None, False)

    # ======== IDP ==========

    msg = get_msg(hinfo, BINDING_SOAP)

    ar = idp.parse_artifact_resolve(msg)

    print ar

    assert ar.artifact.text == artifact3

    # The IDP retrieves the response from the database using the artifact as the key
    #oreq = idp.artifact[ar.artifact.text]

    binding, destination = idp.pick_binding("artifact_resolution_service",
                                            entity_id=sp.config.entityid)

    resp = idp.create_artifact_response(ar, ar.artifact.text)
    hinfo = idp.use_soap(resp, destination)

    # ========== SP ============

    msg = get_msg(hinfo, BINDING_SOAP)
    sp_resp = sp.parse_artifact_resolve_response(msg)

    assert sp_resp.id == response.id

########NEW FILE########
__FILENAME__ = test_65_authn_query
from urlparse import urlparse, parse_qs
from saml2 import BINDING_SOAP, BINDING_HTTP_POST

__author__ = 'rolandh'

from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.authn_context import requested_authn_context
from saml2.samlp import AuthnRequest
from saml2.samlp import NameIDPolicy
from saml2.samlp import AuthnQuery
from saml2.client import Saml2Client
from saml2.saml import Subject
from saml2.saml import NameID
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2.server import Server

TAG1 = "name=\"SAMLRequest\" value="


AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


def get_msg(hinfo, binding):
    if binding == BINDING_SOAP:
        xmlstr = hinfo["data"]
    elif binding == BINDING_HTTP_POST:
        _inp = hinfo["data"][3]
        i = _inp.find(TAG1)
        i += len(TAG1) + 1
        j = _inp.find('"', i)
        xmlstr = _inp[i:j]
    else:  # BINDING_HTTP_REDIRECT
        parts = urlparse(hinfo["headers"][0][1])
        xmlstr = parse_qs(parts.query)["SAMLRequest"][0]

    return xmlstr

# ------------------------------------------------------------------------


def test_basic():
    sp = Saml2Client(config_file="servera_conf")
    idp = Server(config_file="idp_all_conf")

    srvs = sp.metadata.authn_query_service(idp.config.entityid)

    destination = srvs[0]["location"]
    authn_context = requested_authn_context(INTERNETPROTOCOLPASSWORD)

    subject = Subject(text="abc",
                      name_id=NameID(format=NAMEID_FORMAT_TRANSIENT))

    _id, aq = sp.create_authn_query(subject, destination, authn_context)

    print aq

    assert isinstance(aq, AuthnQuery)


def test_flow():
    sp = Saml2Client(config_file="servera_conf")
    idp = Server(config_file="idp_all_conf")

    relay_state = "FOO"
    # -- dummy request ---
    orig_req = AuthnRequest(
        issuer=sp._issuer(),
        name_id_policy=NameIDPolicy(allow_create="true",
                                    format=NAMEID_FORMAT_TRANSIENT))

    # == Create an AuthnRequest response

    name_id = idp.ident.transient_nameid(sp.config.entityid, "id12")
    binding, destination = idp.pick_binding("assertion_consumer_service",
                                            entity_id=sp.config.entityid)
    resp = idp.create_authn_response({"eduPersonEntitlement": "Short stop",
                                      "surName": "Jeter",
                                      "givenName": "Derek",
                                      "mail": "derek.jeter@nyy.mlb.com",
                                      "title": "The man"},
                                     "id-123456789",
                                     destination,
                                     sp.config.entityid,
                                     name_id=name_id,
                                     authn=AUTHN)

    hinfo = idp.apply_binding(binding, "%s" % resp, destination, relay_state)

    # ------- @SP ----------

    xmlstr = get_msg(hinfo, binding)
    aresp = sp.parse_authn_request_response(xmlstr, binding,
                                            {resp.in_response_to: "/"})

    binding, destination = sp.pick_binding("authn_query_service",
                                           entity_id=idp.config.entityid)

    authn_context = requested_authn_context(INTERNETPROTOCOLPASSWORD)

    subject = aresp.assertion.subject

    aq_id, aq = sp.create_authn_query(subject, destination, authn_context)

    print aq

    assert isinstance(aq, AuthnQuery)
    binding = BINDING_SOAP

    hinfo = sp.apply_binding(binding, "%s" % aq, destination, "state2")

    # -------- @IDP ----------

    xmlstr = get_msg(hinfo, binding)

    pm = idp.parse_authn_query(xmlstr, binding)

    msg = pm.message
    assert msg.id == aq.id

    p_res = idp.create_authn_query_response(msg.subject, msg.session_index,
                                            msg.requested_authn_context)

    print p_res

    hinfo = idp.apply_binding(binding, "%s" % p_res, "", "state2",
                              response=True)

    # ------- @SP ----------

    xmlstr = get_msg(hinfo, binding)

    final = sp.parse_authn_query_response(xmlstr, binding)

    print final

    assert final.response.id == p_res.id

if __name__ == "__main__":
    test_flow()

########NEW FILE########
__FILENAME__ = test_66_name_id_mapping
__author__ = 'rolandh'

from saml2.client import Saml2Client
from saml2.saml import NameID, NAMEID_FORMAT_PERSISTENT
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2.server import Server
from saml2.samlp import NameIDPolicy
from saml2.samlp import NameIDMappingRequest


def test_base_request():
    sp = Saml2Client(config_file="servera_conf")
    idp = Server(config_file="idp_all_conf")

    binding, destination = sp.pick_binding("name_id_mapping_service",
                                           entity_id=idp.config.entityid)

    policy = NameIDPolicy(format=NAMEID_FORMAT_TRANSIENT,
                          sp_name_qualifier="urn:mace:swamid:junk",
                          allow_create="true")

    nameid = NameID(format=NAMEID_FORMAT_TRANSIENT, text="foobar")

    mid, nmr = sp.create_name_id_mapping_request(policy, nameid, destination)

    print nmr

    assert isinstance(nmr, NameIDMappingRequest)


def test_request_response():
    sp = Saml2Client(config_file="servera_conf")
    idp = Server(config_file="idp_all_conf")

    binding, destination = sp.pick_binding("name_id_mapping_service",
                                           entity_id=idp.config.entityid)

    policy = NameIDPolicy(format=NAMEID_FORMAT_TRANSIENT,
                          sp_name_qualifier="urn:mace:swamid:junk",
                          allow_create="true")

    nameid = NameID(format=NAMEID_FORMAT_TRANSIENT, text="foobar")

    mid, nmr = sp.create_name_id_mapping_request(policy, nameid, destination)

    print nmr

    args = sp.use_soap(nmr, destination)

    # ------- IDP ------------

    req = idp.parse_name_id_mapping_request(args["data"], binding)

    in_response_to = req.message.id
    name_id = NameID(format=NAMEID_FORMAT_PERSISTENT, text="foobar")

    idp_response = idp.create_name_id_mapping_response(
        name_id, in_response_to=in_response_to)

    print idp_response

    ht_args = sp.use_soap(idp_response)

    # ------- SP ------------

    _resp = sp.parse_name_id_mapping_request_response(ht_args["data"], binding)

    print _resp.response

    r_name_id = _resp.response.name_id

    assert r_name_id.format == NAMEID_FORMAT_PERSISTENT
    assert r_name_id.text == "foobar"

########NEW FILE########
__FILENAME__ = test_67_manage_name_id
from saml2 import BINDING_SOAP
from saml2.samlp import NewID
from saml2.saml import NameID, NAMEID_FORMAT_TRANSIENT
from saml2.client import Saml2Client
from saml2.server import Server

__author__ = 'rolandh'


def test_basic():
    sp = Saml2Client(config_file="servera_conf")
    idp = Server(config_file="idp_all_conf")

    # -------- @SP ------------
    binding, destination = sp.pick_binding("manage_name_id_service",
                                           entity_id=idp.config.entityid)

    nameid = NameID(format=NAMEID_FORMAT_TRANSIENT, text="foobar")
    newid = NewID(text="Barfoo")

    mid, mreq = sp.create_manage_name_id_request(destination, name_id=nameid,
                                                 new_id=newid)

    print mreq
    rargs = sp.apply_binding(binding, "%s" % mreq, destination, "")

    # --------- @IDP --------------

    _req = idp.parse_manage_name_id_request(rargs["data"], binding)

    print _req.message

    assert mid == _req.message.id


def test_flow():
    sp = Saml2Client(config_file="servera_conf")
    idp = Server(config_file="idp_all_conf")

    binding, destination = sp.pick_binding("manage_name_id_service",
                                           entity_id=idp.config.entityid)

    nameid = NameID(format=NAMEID_FORMAT_TRANSIENT, text="foobar")
    newid = NewID(text="Barfoo")

    mid, midq = sp.create_manage_name_id_request(destination, name_id=nameid,
                                                 new_id=newid)

    print midq
    rargs = sp.apply_binding(binding, "%s" % midq, destination, "")

    # --------- @IDP --------------

    _req = idp.parse_manage_name_id_request(rargs["data"], binding)

    print _req.message

    mnir = idp.create_manage_name_id_response(_req.message, None)

    if binding != BINDING_SOAP:
        binding, destination = idp.pick_binding("manage_name_id_service",
                                                entity_id=sp.config.entityid)
    else:
        destination = ""

    respargs = idp.apply_binding(binding, "%s" % mnir, destination, "")

    print respargs

    # ---------- @SP ---------------

    _response = sp.parse_manage_name_id_request_response(respargs["data"],
                                                         binding)

    print _response.response

    assert _response.response.id == mnir.id


if __name__ == "__main__":
    test_flow()
########NEW FILE########
__FILENAME__ = test_68_assertion_id
from urlparse import parse_qs
from urlparse import urlparse
from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.samlp import AuthnRequest
from saml2.samlp import NameIDPolicy
from saml2.saml import Assertion
from saml2.saml import NAMEID_FORMAT_TRANSIENT
from saml2 import BINDING_HTTP_POST
from saml2 import BINDING_URI
from saml2 import BINDING_SOAP
from saml2.client import Saml2Client
from saml2.server import Server

__author__ = 'rolandh'

TAG1 = "name=\"SAMLRequest\" value="


AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


def get_msg(hinfo, binding, response=False):
    if binding == BINDING_SOAP:
        msg = hinfo["data"]
    elif binding == BINDING_HTTP_POST:
        _inp = hinfo["data"][3]
        i = _inp.find(TAG1)
        i += len(TAG1) + 1
        j = _inp.find('"', i)
        msg = _inp[i:j]
    elif binding == BINDING_URI:
        if response:
            msg = hinfo["data"]
        else:
            msg = ""
            return parse_qs(hinfo["url"].split("?")[1])["ID"][0]
    else:  # BINDING_HTTP_REDIRECT
        parts = urlparse(hinfo["headers"][0][1])
        msg = parse_qs(parts.query)["SAMLRequest"][0]

    return msg


def test_basic_flow():
    sp = Saml2Client(config_file="servera_conf")
    idp = Server(config_file="idp_all_conf")

    # -------- @IDP -------------

    relay_state = "FOO"
    # -- dummy request ---
    orig_req = AuthnRequest(
        issuer=sp._issuer(), name_id_policy=NameIDPolicy(
            allow_create="true", format=NAMEID_FORMAT_TRANSIENT))

    # == Create an AuthnRequest response

    name_id = idp.ident.transient_nameid("id12", sp.config.entityid)

    binding, destination = idp.pick_binding("assertion_consumer_service",
                                            entity_id=sp.config.entityid)
    resp = idp.create_authn_response({"eduPersonEntitlement": "Short stop",
                                      "surName": "Jeter",
                                      "givenName": "Derek",
                                      "mail": "derek.jeter@nyy.mlb.com",
                                      "title": "The man"},
                                     "id-123456789",
                                     destination,
                                     sp.config.entityid,
                                     name_id=name_id,
                                     authn=AUTHN)

    hinfo = idp.apply_binding(binding, "%s" % resp, destination, relay_state)

    # --------- @SP -------------

    xmlstr = get_msg(hinfo, binding)

    aresp = sp.parse_authn_request_response(xmlstr, binding,
                                            {resp.in_response_to: "/"})

    # == Look for assertion X

    asid = aresp.assertion.id

    binding, destination = sp.pick_binding("assertion_id_request_service",
                                           entity_id=idp.config.entityid)

    hinfo = sp.apply_binding(binding, asid, destination)

    # ---------- @IDP ------------

    aid = get_msg(hinfo, binding, response=False)

    # == construct response

    resp = idp.create_assertion_id_request_response(aid)

    hinfo = idp.apply_binding(binding, "%s" % resp, None, "", response=True)

    # ----------- @SP -------------

    xmlstr = get_msg(hinfo, binding, response=True)

    final = sp.parse_assertion_id_request_response(xmlstr, binding)

    print final.response
    assert isinstance(final.response, Assertion)

########NEW FILE########
__FILENAME__ = test_69_discovery
from saml2.client import Saml2Client
from saml2.discovery import DiscoveryServer

from pathutils import dotname

__author__ = 'rolandh'


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_verify():
    ds = DiscoveryServer(config_file=dotname("disco_conf"))
    assert ds
    assert ds.verify_sp_in_metadata("urn:mace:example.com:saml:roland:sp")


def test_construct_0():
    sp = Saml2Client(config_file=dotname("servera_conf"))
    url = sp.create_discovery_service_request("http://example.com/saml/disco",
                                              "https://example.com/saml/sp.xml")

    assert url == "http://example.com/saml/disco?entityID=https%3A%2F%2Fexample.com%2Fsaml%2Fsp.xml"



def test_construct_1():
    sp = Saml2Client(config_file=dotname("servera_conf"))
    url = sp.create_discovery_service_request("http://example.com/saml/disco",
                                              "https://example.com/saml/sp.xml")

    assert url == "http://example.com/saml/disco?entityID=https%3A%2F%2Fexample.com%2Fsaml%2Fsp.xml"


def test_construct_deconstruct_request():
    sp = Saml2Client(config_file=dotname("servera_conf"))
    url = sp.create_discovery_service_request(
        "http://example.com/saml/disco",
        "https://example.com/saml/sp.xml",
        is_passive=True,
        returnIDParam="foo",
        return_url="https://example.com/saml/sp/disc")

    print url

    ds = DiscoveryServer(config_file=dotname("disco_conf"))
    dsr = ds.parse_discovery_service_request(url)
    # policy is added by the parsing and verifying method
    assert _eq(dsr.keys(), ["return", "entityID", "returnIDParam",
                            "isPassive", "policy"])


def test_construct_deconstruct_response():
    sp = Saml2Client(config_file=dotname("servera_conf"))
    url = sp.create_discovery_service_request("http://example.com/saml/disco",
                                              "https://example.com/saml/sp.xml",
                                              is_passive=True,
                                              returnIDParam="foo",
                                              return_url="https://example.com/saml/sp/disc")
    ds = DiscoveryServer(config_file=dotname("disco_conf"))
    dsr = ds.parse_discovery_service_request(url)
    args = dict([(key, dsr[key]) for key in ["returnIDParam", "return"]])
    url = ds.create_discovery_service_response(
        entity_id="https://example.com/saml/idp.xml",
        **args)

    idp_id = sp.parse_discovery_service_response(url, returnIDParam="foo")
    assert idp_id == "https://example.com/saml/idp.xml"


if __name__ == "__main__":
    test_construct_deconstruct_response()

########NEW FILE########
__FILENAME__ = test_70_redirect_signing
from saml2.pack import http_redirect_message
from saml2.sigver import verify_redirect_signature
from saml2.sigver import import_rsa_key_from_file
from saml2.sigver import RSA_SHA1
from saml2.server import Server
from saml2 import BINDING_HTTP_REDIRECT
from saml2.client import Saml2Client
from saml2.config import SPConfig
from urlparse import parse_qs

from pathutils import dotname

__author__ = 'rolandh'

idp = Server(config_file=dotname("idp_all_conf"))

conf = SPConfig()
conf.load_file(dotname("servera_conf"))
sp = Saml2Client(conf)


def test():
    srvs = sp.metadata.single_sign_on_service(idp.config.entityid,
                                              BINDING_HTTP_REDIRECT)

    destination = srvs[0]["location"]
    req_id, req = sp.create_authn_request(destination, id="id1")

    try:
        key = sp.sec.key
    except AttributeError:
        key = import_rsa_key_from_file(sp.sec.key_file)

    info = http_redirect_message(req, destination, relay_state="RS",
                                 typ="SAMLRequest", sigalg=RSA_SHA1, key=key)

    verified_ok = False

    for param, val in info["headers"]:
        if param == "Location":
            _dict = parse_qs(val.split("?")[1])
            _certs = idp.metadata.certs(sp.config.entityid, "any", "signing")
            for cert in _certs:
                if verify_redirect_signature(_dict, cert):
                    verified_ok = True

    assert verified_ok

########NEW FILE########
__FILENAME__ = test_72_eptid
from saml2.eptid import Eptid, EptidShelve

__author__ = 'rolandh'


def test_eptid():
    edb = Eptid("secret")
    e1 = edb.get("idp_entity_id", "sp_entity_id", "user_id", "some other data")
    print e1
    assert e1.startswith("idp_entity_id!sp_entity_id!")
    e2 = edb.get("idp_entity_id", "sp_entity_id", "user_id", "some other data")
    assert e1 == e2

    e3 = edb.get("idp_entity_id", "sp_entity_id", "user_2", "some other data")
    print e3
    assert e1 != e3

    e4 = edb.get("idp_entity_id", "sp_entity_id2", "user_id", "some other data")
    assert e4 != e1
    assert e4 != e3


def test_eptid_shelve():
    edb = EptidShelve("secret", "eptid.db")
    e1 = edb.get("idp_entity_id", "sp_entity_id", "user_id", "some other data")
    print e1
    assert e1.startswith("idp_entity_id!sp_entity_id!")
    e2 = edb.get("idp_entity_id", "sp_entity_id", "user_id", "some other data")
    assert e1 == e2

    e3 = edb.get("idp_entity_id", "sp_entity_id", "user_2", "some other data")
    print e3
    assert e1 != e3

    e4 = edb.get("idp_entity_id", "sp_entity_id2", "user_id", "some other data")
    assert e4 != e1
    assert e4 != e3


if __name__ == "__main__":
    test_eptid_shelve()

########NEW FILE########
__FILENAME__ = test_75_mongodb
from saml2 import BINDING_HTTP_POST
from saml2.authn_context import INTERNETPROTOCOLPASSWORD
from saml2.client import Saml2Client
from saml2.server import Server
from saml2.mongo_store import EptidMDB

__author__ = 'rolandh'


AUTHN = {
    "class_ref": INTERNETPROTOCOLPASSWORD,
    "authn_auth": "http://www.example.com/login"
}


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_flow():
    sp = Saml2Client(config_file="servera_conf")
    idp1 = Server(config_file="idp_conf_mdb")
    idp2 = Server(config_file="idp_conf_mdb")

    # clean out database
    idp1.ident.mdb.db.drop()

    # -- dummy request ---
    req_id, orig_req = sp.create_authn_request(idp1.config.entityid)

    # == Create an AuthnRequest response

    rinfo = idp1.response_args(orig_req, [BINDING_HTTP_POST])

    #name_id = idp1.ident.transient_nameid("id12", rinfo["sp_entity_id"])
    resp = idp1.create_authn_response({"eduPersonEntitlement": "Short stop",
                                      "surName": "Jeter",
                                      "givenName": "Derek",
                                      "mail": "derek.jeter@nyy.mlb.com",
                                      "title": "The man"},
                                      userid="jeter",
                                      authn=AUTHN,
                                      **rinfo)

    # What's stored away is the assertion
    a_info = idp2.session_db.get_assertion(resp.assertion.id)
    # Make sure what I got back from MongoDB is the same as I put in
    assert a_info["assertion"] == resp.assertion

    # By subject
    nid = resp.assertion.subject.name_id
    _assertion = idp2.session_db.get_assertions_by_subject(nid)
    assert len(_assertion) == 1
    assert _assertion[0] == resp.assertion

    nids = idp2.ident.find_nameid("jeter")
    assert len(nids) == 1


def test_eptid_mongo_db():
    edb = EptidMDB("secret", "idp")
    e1 = edb.get("idp_entity_id", "sp_entity_id", "user_id",
                 "some other data")
    print e1
    assert e1.startswith("idp_entity_id!sp_entity_id!")
    e2 = edb.get("idp_entity_id", "sp_entity_id", "user_id",
                 "some other data")
    assert e1 == e2

    e3 = edb.get("idp_entity_id", "sp_entity_id", "user_2",
                 "some other data")
    print e3
    assert e1 != e3

    e4 = edb.get("idp_entity_id", "sp_entity_id2", "user_id",
                 "some other data")
    assert e4 != e1
    assert e4 != e3



if __name__ == "__main__":
    test_flow()

########NEW FILE########
__FILENAME__ = test_76_metadata_in_mdb
# -*- coding: utf-8 -*-

__author__ = 'rolandh'

from saml2.attribute_converter import d_to_local_name
from saml2.attribute_converter import ac_factory
from saml2.mongo_store import export_mdstore_to_mongo_db
from saml2.mongo_store import MetadataMDB
from saml2.mdstore import MetadataStore
from saml2.mdstore import destinations
from saml2.mdstore import name

from saml2 import saml
from saml2 import md
from saml2 import config

from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
import xmldsig
import xmlenc

from pathutils import full_path

ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc
}

ATTRCONV = ac_factory(full_path("attributemaps"))


def _eq(l1, l2):
    return set(l1) == set(l2)


def test_metadata():
    conf = config.Config()
    conf.load_file("idp_conf_mdb")
    UMU_IDP = 'https://idp.umu.se/saml2/idp/metadata.php'
    # Set up a Metadata store
    mds = MetadataStore(ONTS.values(), ATTRCONV, conf,
                        disable_ssl_certificate_validation=True)

    # Import metadata from local file.
    mds.imp({"local": [full_path("swamid-2.0.xml")]})
    assert len(mds) == 1  # One source

    export_mdstore_to_mongo_db(mds, "metadata", "test")

    mdmdb = MetadataMDB(ONTS, ATTRCONV, "metadata", "test")
    # replace all metadata instances with this one
    mds.metadata = {"mongo_db": mdmdb}

    idps = mds.with_descriptor("idpsso")
    assert idps.keys()
    idpsso = mds.single_sign_on_service(UMU_IDP)
    assert len(idpsso) == 1
    assert destinations(idpsso) == [
        'https://idp.umu.se/saml2/idp/SSOService.php']

    _name = name(mds[UMU_IDP])
    assert _name == u'Ume\xe5 University'
    certs = mds.certs(UMU_IDP, "idpsso", "signing")
    assert len(certs) == 1

    sps = mds.with_descriptor("spsso")
    assert len(sps) == 417

    wants = mds.attribute_requirement('https://connect.sunet.se/shibboleth')
    assert wants["optional"] == []
    lnamn = [d_to_local_name(mds.attrc, attr) for attr in wants["required"]]
    assert _eq(lnamn, ['eduPersonPrincipalName', 'mail', 'givenName', 'sn',
                       'eduPersonScopedAffiliation', 'eduPersonAffiliation'])

    wants = mds.attribute_requirement(
        "https://gidp.geant.net/sp/module.php/saml/sp/metadata.php/default-sp")
    # Optional
    lnamn = [d_to_local_name(mds.attrc, attr) for attr in wants["optional"]]
    assert _eq(lnamn, ['displayName', 'commonName', 'schacHomeOrganization',
                       'eduPersonAffiliation', 'schacHomeOrganizationType'])
    # Required
    lnamn = [d_to_local_name(mds.attrc, attr) for attr in wants["required"]]
    assert _eq(lnamn, ['eduPersonTargetedID', 'mail',
                       'eduPersonScopedAffiliation'])

if __name__ == "__main__":
    test_metadata()

########NEW FILE########
__FILENAME__ = test_77_authn_context

__author__ = 'rolandh'

ex1 = """<AuthenticationContextDeclaration
  xmlns="urn:oasis:names:tc:SAML:2.0:ac:classes:Password">
  <AuthnMethod>
    <Authenticator>
      <RestrictedPassword>
        <Length min="4"/>
      </RestrictedPassword>
    </Authenticator>
  </AuthnMethod>
</AuthenticationContextDeclaration>"""

from saml2.saml import AuthnContext
from saml2.saml import authn_context_from_string
from saml2.saml import AuthnContextClassRef
from saml2.samlp import RequestedAuthnContext
from saml2.authn_context import pword
from saml2.authn_context import ppt
from saml2.authn_context import authn_context_class_ref
from saml2.authn_context import requested_authn_context
from saml2.authn_context import PASSWORDPROTECTEDTRANSPORT
from saml2.authn_context import AL1
from saml2.authn_context import AL2
from saml2.authn_context import AL3
from saml2.authn_context import AL4
from saml2.authn_context import AuthnBroker
from saml2.authn_context import authn_context_decl_from_extension_elements
from saml2.authn_context import authn_context_factory

length = pword.Length(min="4")
restricted_password = pword.RestrictedPassword(length=length)
authenticator = pword.Authenticator(restricted_password=restricted_password)
authn_method = pword.AuthnMethod(authenticator=authenticator)
ACD = pword.AuthenticationContextDeclaration(authn_method=authn_method)

AUTHNCTXT = AuthnContext(authn_context_decl=ACD)
REQAUTHNCTXT = RequestedAuthnContext(authn_context_decl_ref=ACD.c_namespace)

def test_passwd():
    inst = ACD
    inst2 = pword.authentication_context_declaration_from_string(ex1)

    assert inst == inst2


def test_factory():
    inst_pw = pword.authentication_context_declaration_from_string(ex1)
    inst = authn_context_factory(ex1)

    assert inst_pw == inst


def test_authn_decl_in_authn_context():
    authnctxt = AuthnContext(authn_context_decl=ACD)

    acs = authn_context_from_string("%s" % authnctxt)
    if acs.extension_elements:
        cacd = authn_context_decl_from_extension_elements(
            acs.extension_elements)
        if cacd:
            acs.authn_context_decl = cacd

    assert acs.authn_context_decl == ACD


def test_authn_1():
    ac = authn_context_class_ref(PASSWORDPROTECTEDTRANSPORT)
    rac = requested_authn_context(PASSWORDPROTECTEDTRANSPORT)
    authn = AuthnBroker()
    target = "https://example.org/login"
    authn.add(ac, target, 1, "http://www.example.com")

    result = authn.pick(rac)
    assert len(result) == 1
    method, reference = result[0]
    assert target == method


def test_authn_2():
    authn = AuthnBroker()
    target = "https://example.org/login"
    authn.add(AUTHNCTXT, target, 10, "https://example.org")

    result = authn.pick(REQAUTHNCTXT)
    assert len(result) == 1
    method, reference = result[0]
    assert target == method


REF2METHOD = {
    AL1: "https://example.com/authn/pin",
    AL2: "https://example.com/authn/passwd",
    AL3: "https://example.com/authn/multifact",
    AL4: "https://example.com/authn/cert"
}


def test_authn_3():
    authn = AuthnBroker()
    level = 0
    for ref in [AL1, AL2, AL3, AL4]:
        level += 4
        ac = authn_context_class_ref(ref)

        authn.add(ac, REF2METHOD[ref], level,
                  "https://www.example.com/%s" % "al%d" % level)

    rac = requested_authn_context(AL1, "minimum")

    info = authn.pick(rac)
    assert len(info) == 4
    method, ref = info[0]
    assert REF2METHOD[AL1] == method

    rac = requested_authn_context(AL2, "minimum")

    info = authn.pick(rac)
    assert len(info) == 3
    method, ref = info[0]
    assert REF2METHOD[AL2] == method

    rac = requested_authn_context(AL3, "minimum")

    info = authn.pick(rac)
    assert len(info) == 2
    method, ref = info[0]
    assert REF2METHOD[AL3] == method

    rac = requested_authn_context(AL4, "minimum")

    info = authn.pick(rac)
    assert len(info) == 1
    method, ref = info[0]
    assert REF2METHOD[AL4] == method

    rac = requested_authn_context(AL1, "exact")

    info = authn.pick(rac)
    assert len(info) == 1
    method, ref = info[0]
    assert REF2METHOD[AL1] == method

    rac = requested_authn_context(AL1, "better")

    info = authn.pick(rac)
    assert len(info) == 3


if __name__ == "__main__":
    test_authn_3()

########NEW FILE########
__FILENAME__ = test_81_certificates
from os import remove
import os
import time

__author__ = 'haho0032'
import unittest
from saml2.cert import OpenSSLWrapper


class TestGenerateCertificates(unittest.TestCase):
    def test_validate_with_root_cert(self):

        cert_info_ca = {
            "cn": "qwerty",
            "country_code": "qw",
            "state": "qwerty",
            "city": "qwerty",
            "organization": "qwerty",
            "organization_unit": "qwerty"
        }

        cert_info = {
            "cn": "asdfgh",
            "country_code": "as",
            "state": "asdfgh",
            "city": "asdfgh",
            "organization": "asdfgh",
            "organization_unit": "asdfg"
        }

        osw = OpenSSLWrapper()

        ca_cert, ca_key = osw.create_certificate(cert_info_ca, request=False,
                                                 write_to_file=True,
                                                 cert_dir=os.path.dirname(
                                                     os.path.abspath(
                                                         __file__)) + "/pki")

        req_cert_str, req_key_str = osw.create_certificate(cert_info,
                                                           request=True)

        ca_cert_str = osw.read_str_from_file(ca_cert)
        ca_key_str = osw.read_str_from_file(ca_key)

        cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,
                                                      req_cert_str)

        valid, mess = osw.verify(ca_cert_str, cert_str)
        self.assertTrue(valid)

        false_ca_cert, false_ca_key = osw.create_certificate(cert_info_ca,
                                                             request=False,
                                                             write_to_file=False)
        false_req_cert_str_1, false_req_key_str_1 = osw.create_certificate(
            cert_info_ca, request=True)
        false_cert_str_1 = osw.create_cert_signed_certificate(false_ca_cert,
                                                              false_ca_key,
                                                              false_req_cert_str_1)
        false_req_cert_str_2, false_req_key_str_2 = osw.create_certificate(
            cert_info, request=True)
        false_cert_str_2 = osw.create_cert_signed_certificate(false_ca_cert,
                                                              false_ca_key,
                                                              false_req_cert_str_2)

        valid, mess = osw.verify(false_ca_cert, cert_str)
        self.assertFalse(valid)
        valid, mess = osw.verify(false_ca_cert, false_cert_str_1)
        self.assertFalse(valid)
        valid, mess = osw.verify(ca_cert_str, false_cert_str_2)
        self.assertFalse(valid)

        if 'z' in cert_str:
            false_cert_str = cert_str.replace('z', 'x')
            valid, mess = osw.verify(ca_cert_str, false_cert_str)
            self.assertFalse(valid)

        remove(ca_cert)
        remove(ca_key)

    def test_validate_cert_chains(self):

        cert_info_ca = {
            "cn": "qwerty",
            "country_code": "qw",
            "state": "qwerty",
            "city": "qwerty",
            "organization": "qwerty",
            "organization_unit": "qwerty"
        }

        cert_intermediate_1_info = {
            "cn": "intermediate_1",
            "country_code": "as",
            "state": "asdfgh",
            "city": "asdfgh",
            "organization": "asdfgh",
            "organization_unit": "asdfg"
        }

        cert_intermediate_2_info = {
            "cn": "intermediate_2",
            "country_code": "as",
            "state": "asdfgh",
            "city": "asdfgh",
            "organization": "asdfgh",
            "organization_unit": "asdfg"
        }

        cert_client_cert_info = {
            "cn": "intermediate_1",
            "country_code": "as",
            "state": "asdfgh",
            "city": "asdfgh",
            "organization": "asdfgh",
            "organization_unit": "asdfg"
        }

        osw = OpenSSLWrapper()

        ca_cert_str, ca_key_str = osw.create_certificate(cert_info_ca,
                                                         request=False)

        req_cert_str, intermediate_1_key_str = osw.create_certificate(
            cert_intermediate_1_info, request=True)
        intermediate_cert_1_str = osw.create_cert_signed_certificate(
            ca_cert_str, ca_key_str, req_cert_str)

        req_cert_str, intermediate_2_key_str = osw.create_certificate(
            cert_intermediate_2_info, request=True)
        intermediate_cert_2_str = osw.create_cert_signed_certificate(
            intermediate_cert_1_str, intermediate_1_key_str,
            req_cert_str)

        req_cert_str, client_key_str = osw.create_certificate(
            cert_client_cert_info, request=True)
        client_cert_str = osw.create_cert_signed_certificate(
            intermediate_cert_2_str, intermediate_2_key_str,
            req_cert_str)

        cert_chain = [intermediate_cert_2_str, intermediate_cert_1_str,
                      ca_cert_str]

        valid, mess = osw.verify_chain(cert_chain, client_cert_str)
        self.assertTrue(valid)


    def test_validate_passphrase(self):

        cert_info_ca = {
            "cn": "qwerty",
            "country_code": "qw",
            "state": "qwerty",
            "city": "qwerty",
            "organization": "qwerty",
            "organization_unit": "qwerty"
        }

        cert_info = {
            "cn": "intermediate_1",
            "country_code": "as",
            "state": "asdfgh",
            "city": "asdfgh",
            "organization": "asdfgh",
            "organization_unit": "asdfg"
        }

        osw = OpenSSLWrapper()

        ca_cert_str, ca_key_str = osw.create_certificate(
            cert_info_ca, request=False,
            cipher_passphrase={"cipher": "blowfish", "passphrase": "qwerty"})

        req_cert_str, req_key_str = osw.create_certificate(cert_info,
                                                           request=True)
        cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,
                                                      req_cert_str,
                                                      passphrase="qwerty")

        valid = False
        try:
            cert_str = osw.create_cert_signed_certificate(
                ca_cert_str, ca_key_str, req_cert_str,
                passphrase="qwertyqwerty")
        except Exception:
            valid = True

        self.assertTrue(valid)

    def test_validate_expire(self):

        cert_info_ca = {
            "cn": "qwerty",
            "country_code": "qw",
            "state": "qwerty",
            "city": "qwerty",
            "organization": "qwerty",
            "organization_unit": "qwerty"
        }

        cert_info = {
            "cn": "intermediate_1",
            "country_code": "as",
            "state": "asdfgh",
            "city": "asdfgh",
            "organization": "asdfgh",
            "organization_unit": "asdfg"
        }

        osw = OpenSSLWrapper()

        ca_cert_str, ca_key_str = osw.create_certificate(cert_info_ca,
                                                         request=False)

        req_cert_str, req_key_str = osw.create_certificate(cert_info,
                                                           request=True)
        cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,
                                                      req_cert_str)

        valid, mess = osw.verify(ca_cert_str, cert_str)

        ca_cert_str, ca_key_str = osw.create_certificate(cert_info_ca,
                                                         request=False,
                                                         valid_from=1000,
                                                         valid_to=100000)
        req_cert_str, req_key_str = osw.create_certificate(cert_info,
                                                           request=True)
        cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,
                                                      req_cert_str)
        valid, mess = osw.verify(ca_cert_str, cert_str)
        self.assertFalse(valid)

        ca_cert_str, ca_key_str = osw.create_certificate(cert_info_ca,
                                                         request=False)
        req_cert_str, req_key_str = osw.create_certificate(cert_info,
                                                           request=True)
        cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,
                                                      req_cert_str,
                                                      valid_from=1000,
                                                      valid_to=100000)
        valid, mess = osw.verify(ca_cert_str, cert_str)
        self.assertFalse(valid)

        ca_cert_str, ca_key_str = osw.create_certificate(cert_info_ca,
                                                         request=False,
                                                         valid_from=0,
                                                         valid_to=1)
        req_cert_str, req_key_str = osw.create_certificate(cert_info,
                                                           request=True)
        cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,
                                                      req_cert_str)
        time.sleep(2)
        valid, mess = osw.verify(ca_cert_str, cert_str)
        self.assertFalse(valid)

        ca_cert_str, ca_key_str = osw.create_certificate(cert_info_ca,
                                                         request=False)
        req_cert_str, req_key_str = osw.create_certificate(cert_info,
                                                           request=True)
        cert_str = osw.create_cert_signed_certificate(ca_cert_str, ca_key_str,
                                                      req_cert_str,
                                                      valid_from=0, valid_to=1)
        time.sleep(2)
        valid, mess = osw.verify(ca_cert_str, cert_str)
        self.assertFalse(valid)

########NEW FILE########
__FILENAME__ = test_82_pefim
import xmldsig as ds
from saml2 import config
from saml2 import extension_elements_to_elements
from saml2 import element_to_extension_element
from saml2 import saml
from saml2.client import Saml2Client
from saml2.extension import pefim
from saml2.extension.pefim import SPCertEnc
from saml2.samlp import Extensions
from saml2.samlp import authn_request_from_string
from saml2.sigver import read_cert_from_file
from pathutils import full_path

__author__ = 'roland'

conf = config.SPConfig()
conf.load_file("server_conf")
client = Saml2Client(conf)

# place a certificate in an authn request
cert = read_cert_from_file(full_path("test.pem"), "pem")

spcertenc = SPCertEnc(
    x509_data=ds.X509Data(
        x509_certificate=ds.X509Certificate(text=cert)))

extensions = Extensions(
    extension_elements=[element_to_extension_element(spcertenc)])

req_id, req = client.create_authn_request(
    "http://www.example.com/sso",
    "urn:mace:example.com:it:tek",
    nameid_format=saml.NAMEID_FORMAT_PERSISTENT,
    message_id="666",
    extensions=extensions)


print req

# Get a certificate from an authn request

xml = "%s" % req

parsed = authn_request_from_string(xml)

_elem = extension_elements_to_elements(parsed.extensions.extension_elements,
                                       [pefim, ds])

assert len(_elem) == 1
_spcertenc = _elem[0]
_cert = _spcertenc.x509_data[0].x509_certificate.text
assert cert == _cert

########NEW FILE########
__FILENAME__ = test_83_md_extensions
from saml2.config import Config
from saml2.metadata import entity_descriptor

__author__ = 'roland'

fil = "sp_mdext_conf.py"

cnf = Config().load_file(fil, metadata_construction=True)
ed = entity_descriptor(cnf)

print ed

assert ed.spsso_descriptor.extensions
assert len(ed.spsso_descriptor.extensions.extension_elements) == 3

########NEW FILE########
__FILENAME__ = _test_80_p11_backend
"""
Testing CryptoBackendXMLSecurity with SoftHSM as backend
"""

# Command to convert test.pem to PKCS#8 PEM format readable by softhsm :
#
#  openssl pkcs8 -topk8 -inform PEM -outform PEM -in test.key -out test.key.p8
# -nocrypt
#

__author__ = 'leifj'  # based on p11_test from pyXMLSecurity

import logging
import os
import traceback
import subprocess
import tempfile
import pytest
from pathutils import full_path

from saml2 import sigver
from saml2 import class_name
from saml2 import time_util
from saml2 import saml
from saml2.s_utils import factory, do_attribute_statement

#xmlsec = pytest.importorskip("xmlsec")

def _find_alts(alts):
    for a in alts:
        if os.path.exists(a):
            return a
    return None


PUB_KEY = full_path("test.pem")
PRIV_KEY = full_path("test.key.p8")

P11_MODULES = ['/usr/lib/libsofthsm.so', '/usr/lib/softhsm/libsofthsm.so']
P11_MODULE = _find_alts(P11_MODULES)
P11_ENGINE = '/usr/lib/engines/engine_pkcs11.so'


def _eq(l1, l2):
    return set(l1) == set(l2)


class FakeConfig():
    """
    Configuration parameters for signature validation test cases.
    """
    def __init__(self, pub_key = PUB_KEY):
        self.xmlsec_binary = None
        self.crypto_backend = 'XMLSecurity'
        self.only_use_keys_in_metadata = False
        self.metadata = None
        self.cert_file = pub_key
        self.key_file = "pkcs11://%s:0/test?pin=secret1" % P11_MODULE
        self.debug = False
        self.cert_handler_extra_class = None
        self.generate_cert_info = False
        self.generate_cert_info = False
        self.tmp_cert_file = None
        self.tmp_key_file = None
        self.validate_certificate = False


class TestPKCS11():

    def __init__(self):
        self.private_keyspec = None
        self.public_keyspec = None
        self.p11_test_files = []
        self.softhsm_conf = None
        self.softhsm_db = None
        self.configured = False
        self.sec = None
        self._assertion = None

    def setup_class(self):
        logging.debug("Creating test pkcs11 token using softhsm")
        try:
            self.softhsm_db = self._tf()
            self.softhsm_conf = self._tf()
            self.signer_cert_pem = self._tf()
            self.openssl_conf = self._tf()
            self.signer_cert_der = self._tf()

            logging.debug("Generating softhsm.conf")
            with open(self.softhsm_conf, "w") as f:
                f.write("#Generated by pysaml2 cryptobackend test\n0:%s\n" % self.softhsm_db)
            logging.debug("Initializing the token")
            self._p(['softhsm',
                    '--slot', '0',
                    '--label', 'test',
                    '--init-token',
                    '--pin', 'secret1',
                    '--so-pin', 'secret2'])

            logging.debug("Importing test key {!r} into SoftHSM".format(PRIV_KEY))
            self._p(['softhsm',
                    '--slot', '0',
                    '--label', 'test',
                    '--import', PRIV_KEY,
                    '--id', 'a1b2',
                    '--pin', 'secret1',
                    '--so-pin', 'secret2'])

            logging.debug("Transforming PEM certificate to DER")
            self._p(['openssl', 'x509',
                    '-inform', 'PEM',
                    '-outform', 'DER',
                    '-in', PUB_KEY,
                    '-out', self.signer_cert_der])

            logging.debug("Importing certificate into token")

            self._p(['pkcs11-tool',
                    '--module', P11_MODULE,
                    '-l',
                    '--slot', '0',
                    '--id', 'a1b2',
                    '--label', 'test',
                    '-y', 'cert',
                    '-w', self.signer_cert_der,
                    '--pin', 'secret1'])

            # list contents of SoftHSM
            self._p(['pkcs11-tool',
                     '--module', P11_MODULE,
                     '-l',
                     '--pin', 'secret1', '-O'])
            self._p(['pkcs11-tool',
                    '--module', P11_MODULE,
                    '-l',
                    '--pin', 'secret1', '-T'])
            self._p(['pkcs11-tool',
                    '--module', P11_MODULE,
                    '-l',
                    '--pin', 'secret1', '-L'])
            self.sec = sigver.security_context(FakeConfig(pub_key = PUB_KEY))
            self._assertion = factory(saml.Assertion,
                                      version="2.0",
                                      id="11111",
                                      issue_instant="2009-10-30T13:20:28Z",
                                      signature=sigver.pre_signature_part("11111", self.sec.my_cert, 1),
                                      attribute_statement=do_attribute_statement(
                                          {("", "", "surName"): ("Foo", ""),
                                           ("", "", "givenName"): ("Bar", ""),
                                           })
                                      )
            self.configured = True
        except Exception, ex:
            print "-" * 64
            traceback.print_exc()
            print "-" * 64
            logging.warning("PKCS11 tests disabled: unable to initialize test token: %s" % ex)
            raise

    def teardown_class(self):
        """
        Remove temporary files created in setup_class.
        """
        for o in self.p11_test_files:
            if os.path.exists(o):
                os.unlink(o)
        self.configured = False
        self.p11_test_files = []

    def _tf(self):
        f = tempfile.NamedTemporaryFile(delete=False)
        self.p11_test_files.append(f.name)
        return f.name

    def _p(self, args):
        env = {}
        if self.softhsm_conf is not None:
            env['SOFTHSM_CONF'] = self.softhsm_conf
            #print "env SOFTHSM_CONF=%s " % softhsm_conf +" ".join(args)
        logging.debug("Environment {!r}".format(env))
        logging.debug("Executing {!r}".format(args))
        args = ['ls']
        proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
        out, err = proc.communicate()
        if err is not None and len(err) > 0:
            logging.error(err)
        if out is not None and len(out) > 0:
            logging.debug(out)
        rv = proc.wait()
        if rv:
            raise RuntimeError("command exited with code != 0: %d" % rv)

    def test_SAML_sign_with_pkcs11(self):
        """
        Test signing a SAML assertion using PKCS#11 and then verifying it.
        """
        os.environ['SOFTHSM_CONF'] = self.softhsm_conf

        ass = self._assertion
        print ass
        sign_ass = self.sec.sign_assertion("%s" % ass, node_id=ass.id)
        #print sign_ass
        sass = saml.assertion_from_string(sign_ass)
        #print sass
        assert _eq(sass.keyswv(), ['attribute_statement', 'issue_instant',
                                   'version', 'signature', 'id'])
        assert sass.version == "2.0"
        assert sass.id == "11111"
        assert time_util.str_to_time(sass.issue_instant)

        print "Crypto version : %s" % (self.sec.crypto.version())

        item = self.sec.check_signature(sass, class_name(sass), sign_ass)

        assert isinstance(item, saml.Assertion)

        print "Test PASSED"


def test_xmlsec_cryptobackend():
    t = TestPKCS11()
    t.setup_class()
    t.test_SAML_sign_with_pkcs11()


if __name__ == "__main__":
    test_xmlsec_cryptobackend()

########NEW FILE########
__FILENAME__ = make_metadata
#!/usr/bin/env python
import argparse
import os
import sys
from saml2.metadata import entity_descriptor
from saml2.metadata import entities_descriptor
from saml2.metadata import sign_entity_descriptor

from saml2.sigver import security_context
from saml2.validate import valid_instance
from saml2.config import Config

# =============================================================================
# Script that creates a SAML2 metadata file from a pysaml2 entity configuration
# file
# =============================================================================

parser = argparse.ArgumentParser()
parser.add_argument('-v', dest='valid',
                    help="How long, in days, the metadata is valid from the time of creation")
parser.add_argument('-c', dest='cert', help='certificate')
parser.add_argument('-e', dest='ed', action='store_true',
                    help="Wrap the whole thing in an EntitiesDescriptor")
parser.add_argument('-i', dest='id',
                    help="The ID of the entities descriptor")
parser.add_argument('-k', dest='keyfile',
                    help="A file with a key to sign the metadata with")
parser.add_argument('-n', dest='name', default="")
parser.add_argument('-p', dest='path',
                    help="path to the configuration file")
parser.add_argument('-s', dest='sign', action='store_true',
                    help="sign the metadata")
parser.add_argument('-x', dest='xmlsec',
                    help="xmlsec binaries to be used for the signing")
parser.add_argument('-w', dest='wellknown',
                    help="Use wellknown namespace prefixes")
parser.add_argument(dest="config", nargs="+")
args = parser.parse_args()

valid_for = 0
nspair = {"xs": "http://www.w3.org/2001/XMLSchema"}
paths = [".", "/opt/local/bin"]

if args.valid:
    # translate into hours
    valid_for = int(args.valid) * 24


eds = []
for filespec in args.config:
    bas, fil = os.path.split(filespec)
    if bas != "":
        sys.path.insert(0, bas)
    if fil.endswith(".py"):
        fil = fil[:-3]
    cnf = Config().load_file(fil, metadata_construction=True)
    eds.append(entity_descriptor(cnf))

conf = Config()
conf.key_file = args.keyfile
conf.cert_file = args.cert
conf.debug = 1
conf.xmlsec_binary = args.xmlsec
secc = security_context(conf)

if args.id:
    desc = entities_descriptor(eds, valid_for, args.name, args.id,
                               args.sign, secc)
    valid_instance(desc)
    print desc.to_string(nspair)
else:
    for eid in eds:
        if args.sign:
            desc = sign_entity_descriptor(eid, id, secc)
        else:
            desc = eid
        valid_instance(desc)
        print desc.to_string(nspair)


########NEW FILE########
__FILENAME__ = mdexport
#!/usr/bin/env python
from saml2.sigver import _get_xmlsec_cryptobackend, SecurityContext
from saml2.httpbase import HTTPBase

from saml2 import saml
from saml2 import md
from saml2.attribute_converter import ac_factory
from saml2.extension import dri
from saml2.extension import idpdisc
from saml2.extension import mdattr
from saml2.extension import mdrpi
from saml2.extension import mdui
from saml2.extension import shibmd
from saml2.extension import ui
import xmldsig
import xmlenc

import argparse

from saml2.mdstore import MetaDataFile, MetaDataExtern

__author__ = 'rolandh'

"""
A script that imports and verifies metadata and then dumps it in a basic
dictionary format.
"""


ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    mdrpi.NAMESPACE: mdrpi,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc,
    shibmd.NAMESPACE: shibmd
}


parser = argparse.ArgumentParser()
parser.add_argument('-t', dest='type')
parser.add_argument('-u', dest='url')
parser.add_argument('-c', dest='cert')
parser.add_argument('-a', dest='attrsmap')
parser.add_argument('-o', dest='output')
parser.add_argument('-x', dest='xmlsec')
parser.add_argument(dest="item")
args = parser.parse_args()


metad = None

if args.type == "local":
    metad = MetaDataFile(ONTS.values(), args.item, args.item)
elif args.type == "external":
    ATTRCONV = ac_factory(args.attrsmap)
    httpc = HTTPBase()
    crypto = _get_xmlsec_cryptobackend(args.xmlsec)
    sc = SecurityContext(crypto)
    metad = MetaDataExtern(ONTS.values(), ATTRCONV, args.url,
                           sc, cert=args.cert, http=httpc)

if metad:
    metad.load()
    txt = metad.dumps()
    if args.output:
        f = open(args.output, "w")
        f.write(txt)
        f.close()
    else:
        print txt

########NEW FILE########
__FILENAME__ = mdexport_test
#!/usr/bin/env python
import sys

from saml2 import saml
from saml2 import md
from saml2.extension import mdui
from saml2.extension import idpdisc
from saml2.extension import dri
from saml2.extension import mdattr
from saml2.extension import ui
from saml2.extension import shibmd
import xmldsig
import xmlenc

from saml2.mdstore import MetaDataFile, MetaDataExtern

__author__ = 'rolandh'

"""
A script that imports and verifies metadata and then dumps it in a basic
dictionary format.
"""


ONTS = {
    saml.NAMESPACE: saml,
    mdui.NAMESPACE: mdui,
    mdattr.NAMESPACE: mdattr,
    dri.NAMESPACE: dri,
    ui.NAMESPACE: ui,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    xmldsig.NAMESPACE: xmldsig,
    xmlenc.NAMESPACE: xmlenc,
    shibmd.NAMESPACE: shibmd
}

MDIMPORT = {
    "swamid": {
        "url": "https://kalmar2.org/simplesaml/module.php/aggregator/?id=kalmarcentral2&set=saml2",
        "cert": "kalmar2.pem",
        "type": "external"
    },
    "incommon": {
        "file": "InCommon-metadata.xml",
        "type": "local"
    },
    "test": {
        "file": "mdtest.xml",
        "type": "local"
    }
}


def main():
    item = MDIMPORT[sys.argv[1]]

    metad = None

    if item["type"] == "local":
        metad = MetaDataFile(sys.argv[1], ONTS.values(), item["file"])
    elif item["type"] == "external":
        metad = MetaDataExtern(sys.argv[1], ONTS.values(),
                               item["url"], "/opt/local/bin/xmlsec1", item["cert"])

    if metad:
        metad.load()
        print metad.dumps()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = mdimport
#!/usr/bin/env python
import sys
import time
from saml2.attribute_converter import ac_factory
from saml2.mdstore import MetaDataMD, MetaDataFile

__author__ = 'rolandh'

import xmldsig
import xmlenc
from saml2 import md
from saml2 import saml
from saml2.extension import dri
from saml2.extension import idpdisc
from saml2.extension import mdattr
from saml2.extension import mdui
from saml2.extension import ui

ONTS = {
    dri.NAMESPACE: dri,
    idpdisc.NAMESPACE: idpdisc,
    md.NAMESPACE: md,
    mdattr.NAMESPACE: mdattr,
    mdui.NAMESPACE: mdui,
    saml.NAMESPACE: saml,
    ui.NAMESPACE: ui,
    xmlenc.NAMESPACE: xmlenc,
    xmldsig.NAMESPACE: xmldsig,
}

start = time.time()
for i in range(1, 10):
    mdmd = MetaDataMD(ONTS, ac_factory("../tests/attributemaps"), "swamid2.md")
    mdmd.load()

    _ = mdmd.keys()

print time.time() - start

start = time.time()
for i in range(1, 10):
    mdf = MetaDataFile(ONTS.values(), ac_factory("../tests/attributemaps"),
                      "../tests/swamid-2.0.xml")
    mdf.load()
    _ = mdf.keys()

print time.time() - start

########NEW FILE########
__FILENAME__ = parse_xsd2
#!/usr/bin/env python

import re
import time
import getopt
import imp
import sys
import types
import errno

__version__ = 0.5

from xml.etree import cElementTree as ElementTree

INDENT = 4*" "
DEBUG = False

XMLSCHEMA = "http://www.w3.org/2001/XMLSchema"
XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'

CLASS_PROP = [("c_children", ".copy()"), 
                ("c_attributes", ".copy()"),
                ("c_child_order", "[:]"),
                ("c_cardinality", ".copy()")]
                
BASE_ELEMENT = ["text", "extension_elements", "extension_attributes"]
    
class MissingPrerequisite(Exception):
    pass

def sd_copy(arg):
    try:
        return arg.copy()
    except AttributeError:
        return {}
        
# ------------------------------------------------------------------------

def class_pyify(ref):
    return ref.replace("-","_")

PROTECTED_KEYWORDS = ["import", "def", "if", "else", "return", "for",
                      "while", "not", "try", "except", "in"]


def def_init(imports, attributes):
    indent = INDENT+INDENT
    indent3 = INDENT+INDENT+INDENT
    line = ["%sdef __init__(self," % INDENT]

    for elem in attributes:
        if elem[0] in PROTECTED_KEYWORDS:
            _name = elem[0] +"_"
        else:
            _name = elem[0]

        if elem[2]:
            line.append("%s%s='%s'," % (indent3, _name, elem[2]))
        else:
            line.append("%s%s=%s," % (indent3, _name, elem[2]))

    for _, elems in imports.items():
        for elem in elems:
            if elem in PROTECTED_KEYWORDS:
                _name = elem +"_"
            else:
                _name = elem
            line.append("%s%s=None," % (indent3, _name))

    line.append("%stext=None," % indent3)
    line.append("%sextension_elements=None," % indent3)
    line.append("%sextension_attributes=None," % indent3)
    line.append("%s):" % indent)
    return line
    

def base_init(imports):
    line = []
    indent4 = INDENT+INDENT+INDENT+INDENT
    if not imports:
        line.append("%sSamlBase.__init__(self, " % (INDENT+INDENT))
        for attr in BASE_ELEMENT:
            if attr in PROTECTED_KEYWORDS:
                _name = attr + "_"
            else:
                _name = attr
            line.append("%s%s=%s," % (indent4, _name, _name))
        line.append("%s)" % indent4)
    else:
        # TODO have to keep apart which properties come from which superior
        for sup, elems in imports.items():
            line.append("%s%s.__init__(self, " % (INDENT+INDENT, sup))
            lattr = elems[:]
            lattr.extend(BASE_ELEMENT)
            for attr in lattr:
                if attr in PROTECTED_KEYWORDS:
                    _name = attr + "_"
                else:
                    _name = attr
                line.append("%s%s=%s," % (indent4, _name, _name))
            line.append("%s)" % indent4)
    return line
    

def initialize(attributes):
    indent = INDENT+INDENT
    line = []
    for prop, val, _default in attributes:
        if prop in PROTECTED_KEYWORDS:
            _name = prop +"_"
        else:
            _name = prop

        if val in PROTECTED_KEYWORDS:
            _vname = val +"_"
        else:
            _vname = val
            
        line.append("%sself.%s=%s" % (indent, _name, _vname))
    return line


def _mod_typ(prop):
    try:
        (mod, typ) = prop.type
    except ValueError:
        typ = prop.type
        mod = None
    except TypeError: # No type property
        try:
            (mod, typ) = prop.ref
        except ValueError:
            if prop.class_name:
                typ = prop.class_name
            else:
                typ = prop.ref
            mod = None
    
    return mod, typ


def _mod_cname(prop, cdict):
    if hasattr(prop, "scoped"):
        cname = prop.class_name
        mod = None
    else:
        (mod, typ) = _mod_typ(prop)
        if not mod:
            try:
                cname = cdict[typ].class_name
            except KeyError:
                cname = cdict[class_pyify(typ)].class_name
        else:
            cname = typ
        
    return mod, cname


def leading_uppercase(string):
    try:
        return string[0].upper()+string[1:]
    except IndexError:
        return string
    except TypeError:
        return ""


def leading_lowercase(string):
    try:
        return string[0].lower()+string[1:]
    except IndexError:
        return string
    except TypeError:
        return ""


def rm_duplicates(properties):
    keys = []
    clist = []
    for prop in properties:
        if prop.name in keys:
            continue
        else:
            clist.append(prop)
            keys.append(prop.name)
    return clist

# def rm_duplicates(lista):
#     res = []
#     for item in lista:
#         if item not in res:
#             res.append(item)
#     return res


def klass_namn(obj):
    if obj.class_name:
        return obj.class_name
    else:
        return obj.name
    

class PyObj(object):
    def __init__(self, name=None, pyname=None, root=None):
        self.name = name
        self.done = False
        self.local = True
        self.root = root
        self.superior = []
        self.value_type = ""
        self.properties = ([], [])
        self.abstract = False
        self.class_name = ""
        
        if pyname:
            self.pyname = pyname
        elif name:
            self.pyname = pyify(name)
        else:
            self.pyname = name

        self.type = None
            
    def child_spec(self, target_namespace, prop, mod, typ, lista):
        if mod:
            namesp = external_namespace(self.root.modul[mod])
            pkey = '{%s}%s' % (namesp, prop.name)
            typ = "%s.%s" % (mod, typ)
        else:
            pkey = '{%s}%s' % (target_namespace, prop.name)

        if lista:
            return "c_children['%s'] = ('%s', [%s])" % (
                        pkey, prop.pyname, typ)
        else:
            return "c_children['%s'] = ('%s', %s)" % (
                        pkey, prop.pyname, typ)
    
    def knamn(self, sup, cdict):
        cname = cdict[sup].class_name
        if not cname:
            (namesp, tag) = cdict[sup].name.split('.')
            if namesp:
                ctag = self.root.modul[namesp].factory(tag).__class__.__name__
                cname = '%s.%s' % (namesp, ctag)
            else:
                cname = tag + "_"
        return cname
    
    def _do_properties(self, line, cdict, ignore, target_namespace):
        args = []
        child = []

        try:
            (own, inh) = self.properties
        except AttributeError:
            (own, inh) = ([], [])
            
        for prop in own:
            if isinstance(prop, PyAttribute):
                line.append("%sc_attributes['%s'] = %s" % (INDENT, 
                                                    prop.name, prop.spec()))
                if prop.fixed:
                    args.append((prop.pyname, prop.fixed, None))
                else:
                    if prop.default:
                        args.append((prop.pyname, prop.pyname, prop.default))
                    else:
                        args.append((prop.pyname, prop.pyname, None))
                        
            elif isinstance(prop, PyElement):

                (mod, cname) = _mod_cname(prop, cdict)
                
                if prop.max == "unbounded":
                    lista = True
                    pmax = 0 # just has to be different from 1
                else:
                    pmax = int(prop.max)
                    lista = False
                    
                if prop.name in ignore:
                    pass
                else:
                    line.append("%s%s" % (INDENT, self.child_spec(
                                                        target_namespace, prop,
                                                        mod, cname,
                                                        lista)))

                pmin = int(getattr(prop, 'min', 1))

                if pmax == 1 and pmin == 1:
                    pass
                elif prop.max == "unbounded":
                    line.append( "%sc_cardinality['%s'] = {\"min\":%s}" % (
                                    INDENT, prop.pyname, pmin))
                else:
                    line.append(
                        "%sc_cardinality['%s'] = {\"min\":%s, \"max\":%d}" % (
                                    INDENT, prop.pyname, pmin, pmax))

                child.append(prop.pyname)
                if lista:
                    args.append((prop.pyname, "%s or []" % (prop.pyname,), 
                                    None))
                else:
                    args.append((prop.pyname, prop.pyname, None))
        
        return args, child, inh
        
    def _superiors(self, cdict):
        imps = {}

        try:
            superior = self.superior
            sups = []
            for sup in superior:
                klass = self.knamn(sup, cdict)
                sups.append(klass)
                
                imps[klass] = []
                for cla in cdict[sup].properties[0]:
                    if cla.pyname and cla.pyname not in imps[klass]: 
                        imps[klass].append(cla.pyname)
        except AttributeError:
            superior = []
            sups = []
        
        return superior, sups, imps
        
    def class_definition(self, target_namespace, cdict=None, ignore=None):
        line = []

        if self.root:
            if self.name not in [c.name for c in self.root.elems]:
                self.root.elems.append(self)

        (superior, sups, imps) = self._superiors(cdict)

        c_name = klass_namn(self)
            
        if not superior:
            line.append("class %s(SamlBase):" % (c_name,))
        else:
            line.append("class %s(%s):" % (c_name, ",".join(sups)))

        if hasattr(self, 'scoped'):
            pass
        else:
            line.append("%s\"\"\"The %s:%s element \"\"\"" % (INDENT, 
                                                        target_namespace,
                                                        self.name))
        line.append("")
        line.append("%sc_tag = '%s'" % (INDENT, self.name))
        line.append("%sc_namespace = NAMESPACE" % (INDENT,))
        try:
            if self.value_type:
                if isinstance(self.value_type, basestring):
                    line.append("%sc_value_type = '%s'" % (INDENT, 
                                                            self.value_type))
                else:
                    line.append("%sc_value_type = %s" % (INDENT, 
                                                        self.value_type))
        except AttributeError:
            pass

        if not superior:
            for var, cps in CLASS_PROP:
                line.append("%s%s = SamlBase.%s%s" % (INDENT, var, var, cps))
        else:
            for sup in sups:
                for var, cps in CLASS_PROP:
                    line.append("%s%s = %s.%s%s" % (INDENT, var, sup, var, 
                                                    cps))

        (args, child, inh) = self._do_properties(line, cdict, ignore, 
                                                target_namespace)
        
        if child:
            line.append("%sc_child_order.extend([%s])" % (INDENT,
                            "'"+"', '".join(child)+"'"))
            
        if args:
            if inh:
                cname = self.knamn(self.superior[0], cdict)
                imps = {cname: [c.pyname for c in inh if c.pyname]}
            line.append("")
            line.extend(def_init(imps, args))
            line.extend(base_init(imps))
            line.extend(initialize(args))
        
        line.append("")
        if not self.abstract or not self.class_name.endswith("_"):
            line.append("def %s_from_string(xml_string):" % pyify(
                                                            self.class_name))
            line.append(
                "%sreturn saml2.create_class_from_xml_string(%s, xml_string)" % (
                            INDENT, self.class_name))
            line.append("")
        
        self.done = True
        return "\n".join(line)
    
def prepend(add, orig):
    # return a list which is the lists concatenated with the second list first
    res = [add]
    if orig:
        res.extend(orig)
    return res
    
def pyobj_factory(name, value_type, elms=None):
    pyobj = PyObj(name, pyify(name))
    pyobj.value_type = value_type
    if elms:
        if name not in [c.name for c in elms]:
            elms.append(pyobj)
    return pyobj

def pyelement_factory(name, value_type, elms=None):
    obj = PyElement(name, pyify(name))
    obj.value_type = value_type
    if elms:
        if name not in [c.name for c in elms]:
            elms.append(obj)
    return obj
    
def expand_groups(properties, cdict):
    res = []
    for prop in properties:
        if isinstance(prop, PyGroup):
            # only own, what about inherited ? Not on groups ?
            cname = prop.ref[1]
            res.extend(cdict[cname].properties[0])
        else:
            res.append(prop)
            
    return res
    
class PyElement(PyObj):
    def __init__(self, name=None, pyname=None, root=None, parent=""):
        PyObj.__init__(self, name, pyname, root)
        if parent:
            self.class_name = "%s_%s" % (leading_uppercase(parent), self.name)
        else:
            self.class_name = leading_uppercase(self.name)
        self.ref = None
        self.min = 1
        self.max = 1
        self.definition = None
        self.orig = None
    
    # def prereq(self, prop):
    #     prtext = prop.text(target_namespace, cdict)
    #     if prtext == None:
    #         return []
    #     else:
    #         prop.done = True
    #         return prtext
        
    def undefined(self, cdict):
        try:
            (mod, typ) = self.type
            if not mod:
                cname = leading_uppercase(typ)
                if not cdict[cname].done:
                    return [cdict[cname]], []
        except ValueError:
            pass
        except TypeError: # could be a ref then or a PyObj instance
            if isinstance(self.type, PyType):
                return self.type.undefined(cdict)
            elif isinstance(self.ref, tuple):
                pass
            else:
                cname = leading_uppercase(self.ref)
                if not cdict[cname].done:
                    return [cdict[cname]], []
        return [], []
    
    def _local_class(self, typ, cdict, child, target_namespace, ignore):
        if typ in cdict and not cdict[typ].done:
            raise MissingPrerequisite(typ)
        else:
            self.orig = {"type": self.type}
            try:
                self.orig["superior"] = self.superior
            except AttributeError:
                self.orig["superior"] = []
            self.superior = [typ]
            req = self.class_definition(target_namespace, cdict, 
                                        ignore)
            if not child:
                req = [req]
            
            if not hasattr(self, 'scoped'):
                cdict[self.name] = self
                cdict[self.name].done = True
                if child:
                    cdict[self.name].local = True
            self.type = (None, self.name)
        
        return req
        
    def _external_class(self, mod, typ, cdict, child, target_namespace, 
                        ignore):
        # Will raise exception if class can't be found
        cname = self.root.modul[mod].factory(typ).__class__.__name__
        imp_name = "%s.%s" % (mod, cname)
            
        if imp_name not in cdict:
            # create import object so I can get the properties from it 
            # later
            impo = pyelement_factory(imp_name, None, None)
            impo.properties = [_import_attrs(self.root.modul[mod], typ, 
                                            self.root),[]]
            impo.class_name = imp_name
            cdict[imp_name] = impo
            impo.done = True
            if child:
                impo.local = True
        # and now for this object
        self.superior = [imp_name]
        text = self.class_definition(target_namespace, cdict, 
                                        ignore=ignore)
        
        return text
        
    def text(self, target_namespace, cdict, child=True, ignore=None):
        if ignore is None:
            ignore = []

        if child:
            text = []
        else:
            text = None
        req = []
        try:
            (mod, typ) = self.type
            if not mod:
                req = self._local_class(typ, cdict, child, 
                                        target_namespace, ignore)
            else:
                text = self._external_class(mod, typ, cdict, child, 
                                            target_namespace, ignore)
        except ValueError: # Simple type element
            if self.type:
                text = self.class_definition(target_namespace, cdict, 
                                                ignore=ignore)
                if child:
                    self.local = True
                self.done = True
                    
        except TypeError: # could be a ref then or a PyObj instance
            if isinstance(self.type, PyObj):
                pyobj = self.type
                pyobj.name = self.name
                pyobj.pyname = self.pyname
                pyobj.class_name = self.class_name
                cdict[self.name] = pyobj
                return pyobj.text(target_namespace, cdict, ignore=ignore)
            elif isinstance(self.ref, tuple):
                (mod, typ) = self.ref
                if mod:
                    #self.superior = ["%s.%s" % (mod, typ)]
                    if verify_import(self.root.modul[mod], typ):
                        return req, text
                    else:
                        raise Exception(
            "Import attempted on %s from %s module failed - wasn't there" % (
                                typ,mod))
                elif not child:
                    self.superior = [typ]
                    text = self.class_definition(target_namespace, cdict,
                                                    ignore=ignore)
            else:
                if not cdict[class_pyify(self.ref)].done:
                    raise MissingPrerequisite(self.ref)
                
        self.done = True
        return req, text
        
def _do(obj, target_namespace, cdict, prep):
    try:
        (req, text) = obj.text(target_namespace, cdict)
    except MissingPrerequisite:
        return [], None
        
    if text is None:
        if req:
            #prep = prepend(req, prep)
            prep.append(req)
        return prep, None
    else:
        obj.done = True
        if req:
            if isinstance(req, basestring):
                prep.append(req)
            else:
                prep.extend(req)
        if text:
            #prep = prepend(text, prep)
            prep.append(text)
    return prep

def reqursive_superior(supc, cdict):
    properties = supc.properties[0]
    for sup in supc.superior:
        rsup = cdict[sup]
        if rsup.properties[1]:
            properties.extend(rsup.properties[1])
        else:
            properties.extend(reqursive_superior(rsup, cdict))
    return properties
    
class PyType(PyObj):
    def __init__(self, name=None, pyname=None, root=None, superior=None, 
                internal=True, namespace=None):
        PyObj.__init__(self, name, pyname, root)
        self.class_name = leading_uppercase(self.name + '_')
        self.properties = ([], [])
        if superior:
            self.superior = [superior]
        else:
            self.superior = []
        self.value_type = None
        self.internal = internal
        self.namespace = namespace

    def text(self, target_namespace, cdict, _child=True, ignore=None,
             _session=None):
        if not self.properties and not self.type \
                and not self.superior:
            self.done = True
            return [], self.class_definition(target_namespace, cdict)

        if ignore is None:
            ignore = []
        req = []
        inherited_properties = []
        for sup in self.superior:
            try:
                supc = cdict[sup]
            except KeyError:
                (mod, typ) = sup.split('.')
                supc = pyobj_factory(sup, None, None)
                if mod:
                    supc.properties = [_import_attrs(self.root.modul[mod], 
                                                        typ, self.root),[]]
                cdict[sup] = supc
                supc.done = True
                
            if not supc.done:
                res = _do(supc, target_namespace, cdict, req)
                if isinstance(res, tuple):
                    return res
            
            if not self.properties[1]:
                inherited_properties = reqursive_superior(supc, cdict)
        
        if inherited_properties:
            self.properties = (self.properties[0], 
                                rm_duplicates(inherited_properties))
            
        (own, inh) = self.properties
        own = rm_duplicates(expand_groups(own, cdict))
        self.properties = (own, inh)
        for prop in own:
            if not prop.name: # Ignore
                continue 
            if not prop.done:
                if prop.name in ignore:
                    continue
                res = _do(prop, target_namespace, cdict, req)
                if res == ([], None):
                    # # Cleaning up
                    # for prp in own:
                    #     if prp == prop:
                    #         break
                    #     try:
                    #         if cdict[prp.name].local:
                    #             del cdict[prp.name]
                    #             if hasattr(prp, "orig") and prp.orig:
                    #                 for key, val in prp.orig.items():
                    #                     setattr(prp, key, val)
                    #             prp.done = False
                    #             prp.local = False
                    #     except KeyError:
                    #         pass
                    res = (req, None)
                if isinstance(res, tuple):
                    return res
        
        return req, self.class_definition(target_namespace, cdict, ignore)
    
    def undefined(self, cdict):
        undef = ([], [])

        for sup in self.superior:
            supc = cdict[sup]
            if not supc.done:
                undef[0].append(supc)

        (own, _) = self.properties
        for prop in own:
            if not prop.name: # Ignore
                continue 
            if isinstance(prop, PyAttribute):
                continue
            if not prop.done:
                undef[1].append(prop)
        return undef

class PyAttribute(PyObj):
    def __init__(self, name=None, pyname=None, root=None, external=False, 
                    namespace="", required=False, typ=""):
        PyObj.__init__(self, name, pyname, root)

        self.required = required
        self.external = external
        self.namespace = namespace
        self.base = None
        self.type = typ
        self.fixed = False
        self.default = None

    def text(self, _target_namespace, cdict, _child=True):
        if isinstance(self.type, PyObj):
            if not cdict[self.type.name].done:
                raise MissingPrerequisite(self.type.name)
                
        return [], [] # Means this elements definition is empty
        
    def spec(self):
        if isinstance(self.type, PyObj):
            return "('%s', %s, %s)" % (self.pyname, self.type.class_name, 
                                        self.required)
        else:
            if self.type:
                return "('%s', '%s', %s)" % (self.pyname, self.type, 
                                                self.required)
            else:
                return "('%s', '%s', %s)" % (self.pyname, self.base, 
                                                self.required)
       
class PyAny(PyObj):
    def __init__(self, name=None, pyname=None, _external=False, _namespace=""):
        PyObj.__init__(self, name, pyname)
        self.done = True

class PyAttributeGroup(object):
    def __init__(self, name, root):
        self.name = name
        self.root = root
        self.properties = []

class PyGroup(object):
    def __init__(self, name, root):
        self.name = name
        self.root = root
        self.properties = []
        self.done = False
        self.ref = []
    
    def text(self, _target_namespace, _dict, _child, _ignore):
        return [], []
        
    def undefined(self, _cdict):
        undef = ([], [])

        (own, _) = self.properties
        for prop in own:
            if not prop.name: # Ignore
                continue 
            if not prop.done:
                undef[1].append(prop)
        return undef
    
# -----------------------------------------------------------------------------
def verify_import(modul, tag):
    try:
        _ = modul.factory(tag)
        return True
    except Exception:
        return False
    
def external_namespace(modul):
    return modul.NAMESPACE

def _import_attrs(modul, tag, top):
    obj = modul.factory(tag)
    properties = [PyAttribute(key, val[0], top, True, obj.c_namespace, val[2],
                            val[1]) for key,val in obj.c_attributes.items()]
    for child in obj.c_child_order:
        for key, val in obj.c_children.items():
            (pyn, mul) = val
            maximum = 1
            if isinstance(mul, list):
                mul = mul[0]
                maximum = "unbounded"
            if pyn == child:
                cpy = PyElement(name=mul.c_tag, pyname=pyn, root=top) 
    #                            internal=False, ns=obj.c_namespace)
                cpy.max = maximum
                properties.append(cpy)

    return properties

# ------------------------------------------------------------------------

def _spec(elem):
    try:
        name = elem.name
    except AttributeError:
        name = "anonymous"
    txt = "%s" % name
    try:
        txt += " ref: %s" % elem.ref
    except AttributeError:
        try:
            txt += " type: %s" % elem.type
        except AttributeError:
            pass

    return txt
        
# def _klass(elem, _namespace, sup, top):
#     if elem.name in top.py_elements:
#         return None
#     else:
#         kl = PyType(elem.name, root=top)
#         top.py_elements[elem.name] = kl
#         if sup != "SamlBase":
#             kl.superior.append(sup)
#         return kl
        
def _do_from_string(name):
    print
    print "def %s_from_string(xml_string):" % pyify(name)
    print "%sreturn saml2.create_class_from_xml_string(%s, xml_string)" % (
                INDENT, name)

def _namespace_and_tag(obj, param, top):
    try:
        (namespace, tag) = param.split(":")
    except ValueError:
        namespace = ""
        tag = param
    # except AttributeError:
    #     namespace = ""
    #     tag = obj.name

    return namespace, tag
    
# -----------------------------------------------------------------------------

class Simple(object):
    def __init__(self, elem):
        self.default = None
        self.fixed = None
        self.xmlns_map = []
        self.name = ""
        self.type = None
        self.use = None
        self.ref = None
        self.scoped = False
        self.itemType = None
        
        for attribute, value in elem.attrib.iteritems():            
            self.__setattr__(attribute, value)

    def collect(self, top, sup, argv=None, parent=""):
        argv_copy = sd_copy(argv)
        rval = self.repr(top, sup, argv_copy, True, parent)
        if rval:
            return [rval], []
        else:
            return [], []

    def repr(self, _top=None, _sup=None, _argv=None, _child=True, _parent=""):
        return None
        
    def elements(self, _top):
        return []

        
class Any(Simple):
    
    def repr(self, _top=None, _sup=None, _argv=None, _child=True, _parent=""):
        return PyAny()
        
class AnyAttribute(Simple):

    def repr(self, _top=None, _sup=None, _argv=None, _child=True, _parent=""):
        return PyAny()

class Attribute(Simple):
    def repr(self, top=None, sup=None, _argv=None, _child=True, _parent=""):
        # default, fixed, use, type
                    
        if DEBUG:
            print "#ATTR", self.__dict__

        external = False
        name = ""
        try:
            (namespace, tag) = _namespace_and_tag(self, self.ref, top)
            ref = True
            pyname = tag
            if namespace in self.xmlns_map:
                if self.xmlns_map[namespace] == top.target_namespace:
                    name = tag
                else :
                    external = True
                    name = "{%s}%s" % (self.xmlns_map[namespace], tag)
            else:
                if namespace == "xml":
                    name = "{%s}%s" % (XML_NAMESPACE, tag)
        except AttributeError:
            name = self.name
            pyname = pyify(name)
            ref = False
        except ValueError: # self.ref exists but does not split into two parts
            ref = True
            if "" == top.target_namespace:
                name = self.ref
                pyname = pyify(name)
            else: # referering to what
                raise Exception("Strange reference: %s" % self.ref)
                    
        objekt = PyAttribute(name, pyname, external=external, root=top)
        
        # Initial declaration
        if not ref:
            try:
                (namespace, klass) = _namespace_and_tag(self, self.type, top)
                if self.xmlns_map[namespace] == top.target_namespace:
                    ctyp = get_type_def(klass, top.parts)
                    if not ctyp.py_class:
                        ctyp.repr(top, sup)
                    objekt.type = ctyp.py_class
                elif self.xmlns_map[namespace] == XMLSCHEMA:
                    objekt.type = klass
                else:
                    objekt.type = self.type
            except ValueError:
                if self.xmlns_map[""] == top.target_namespace:
                    ctyp = get_type_def(self.type.replace("-","_"), top.parts)
                    if not ctyp.py_class:
                        ctyp.repr(top, sup)
                    objekt.type = ctyp.py_class                    
                else:
                    objekt.type = self.type
            except AttributeError:
                objekt.type = None
        try:
            if self.use == "required":
                objekt.required = True
        except AttributeError:
            pass
            
        # in init
        try:
            objekt.default = self.default
        except AttributeError:
            pass
                
        # attr def
        try:
            objekt.fixed = self.fixed
        except AttributeError:
            pass
        
        if DEBUG:
            print "#--ATTR py_attr:%s" % (objekt,)
            
        return objekt
        
class Enumeration(Simple):
    pass
    
class Union(Simple):
    pass
    
class Import(Simple):
    pass
    
class Documentation(Simple):
    pass
    
class MaxLength(Simple):
    pass

class Length(Simple):
    pass
    
class MinInclusive(Simple):
    pass
    
class MaxInclusive(Simple):
    pass

class MinExclusive(Simple):
    pass

class MaxExclusive(Simple):
    pass
    
class List(Simple):
    pass

class Include(Simple):
    pass


# -----------------------------------------------------------------------------

def sequence(elem):
    return [evaluate(child.tag, child) for child in elem]

def name_or_ref(elem, top):
    try:
        (namespace, name) = _namespace_and_tag(elem, elem.ref, top)
        if namespace and elem.xmlns_map[namespace] == top.target_namespace:
            return name
        else:
            return elem.ref
    except AttributeError:
        return elem.name

class Complex(object):
    def __init__(self, elem):
        self.value_of = ""
        self.parts = []
        self._own = []
        self._inherited = []
        self._generated = False
        self.py_class = None
        self.properties = []
        # From Elementtree
        self.ref = None
        self.type = None
        self.xmlns_map = []
        self.maxOccurs = 1
        self.minOccurs = 1
        self.base = None
        self.scoped = False
        self.abstract = False
        
        for attribute, value in elem.attrib.iteritems():
            self.__setattr__(attribute, value)

        try:
            if elem.text.strip():
                self.value_of = elem.text.strip()
        except AttributeError:
            pass

        self.do_child(elem)
        
        try:
            self.name = self.name.replace("-","_")
        except AttributeError:
            pass

    def _extend(self, top, sup, argv=None, parent="", base=""):
        argv_copy = sd_copy(argv)
        for part in self.parts:
            (own, inh) = part.collect(top, sup, argv_copy, parent)
            if own and base:
                if len(own) == 1 and isinstance(own[0], PyAttribute):
                    own[0].base = base
            self._own.extend(own)
            self._inherited.extend(inh)
        
    def collect(self, top, sup, argv=None, parent=""):
        if self._own or self._inherited:
            return self._own, self._inherited
            
        if DEBUG:
            print self.__dict__
            print "#-- %d parts" % len(self.parts)
        
        self._extend(top, sup, argv, parent)
        
        return self._own, self._inherited
        
    def do_child(self, elem):
        for child in elem:
            self.parts.append(evaluate(child.tag, child))

    def elements(self, top):
        res = []
        # try:
        #     string = "== %s (%s)" % (self.name,self.__class__)
        # except AttributeError:
        #     string = "== (%s)" % (self.__class__,)
        # print string
        for part in self.parts:
            if isinstance(part, Element):
                res.append(name_or_ref(part, top))
            else:
                if isinstance(part, Extension):
                    res.append(part.base)
                res.extend(part.elements(top))

        return res

    def repr(self, _top=None, _sup=None, _argv=None, _child=True, parent=""):
        return None

    def significant_parts(self):
        res = []
        for p in self.parts:
            if isinstance(p, Annotation):
                continue
            else:
                res.append(p)
                
        return res
        
def min_max(cls, objekt, argv):
    try:
        objekt.max = argv["maxOccurs"]
        if cls.maxOccurs != 1:
            objekt.max = cls.maxOccurs
    except (KeyError, TypeError):
        objekt.max = cls.maxOccurs

    try:
        objekt.min = argv["minOccurs"]
        if cls.minOccurs != 1:
            objekt.min = cls.minOccurs
    except (KeyError, TypeError):
        objekt.min = cls.minOccurs
            
    
class Element(Complex):
    def __str__(self):
        return "%s" % (self.__dict__,)

    def klass(self, top):
        xns = None
        ctyp = None
        ref = False
        try:
            (namespace, name) = _namespace_and_tag(self, self.ref, top)
            ref = True
        except AttributeError:
            try:
                (namespace, name) = self.type.split(":")
            except ValueError:
                namespace = None
                name = self.type
            except AttributeError:
                namespace = name = None

        if self.xmlns_map[namespace] == top.target_namespace:
            ctyp = get_type_def(name, top.parts)
        else:
            xns = namespace

        return namespace, name, ctyp, xns, ref

    def collect(self, top, sup, argv=None, parent=""):
        """ means this element is part of a larger object, hence a property of 
        that object """
        
        try:
            argv_copy = sd_copy(argv)
            return [self.repr(top, sup, argv_copy, parent=parent)], []
        except AttributeError, exc:
            print "#!!!!", exc
            return [], []

    def elements(self, top):            
        (_namespace, name, ctyp, xns, _) = self.klass(top)
        if ctyp:
            return ctyp.elements(top)
        elif xns:
            return ["%s.%s" % (xns, name)]
        else:
            return []

    def repr(self, top=None, sup=None, argv=None, child=True, parent=""):
        #<element ref='xenc:ReferenceList' ...
        #<element name='Transforms' type='xenc:TransformsType' ...
        #<element name='CarriedKeyName' type='string' ...
        #<element name="RecipientKeyInfo" type="ds:KeyInfoType" ...
        #<element name='ReferenceList'>

        if self.py_class:
            return self.py_class
            
        try:
            myname = self.name
        except AttributeError:
            myname = ""

        if DEBUG:
            print "#Element.repr '%s' (child=%s) [%s]" % (myname, 
                                                            child, 
                                                            self._generated)

        self.py_class = objekt = PyElement(myname, root=top)
        min_max(self, objekt, argv)
                
        try:
            (namespace, superkl) = _namespace_and_tag(self, self.ref, top)
            # internal or external reference
            if not myname:
                objekt.name = superkl
                objekt.pyname = pyify(superkl)
            if self.xmlns_map[namespace] == top.target_namespace:
                objekt.ref = superkl 
            else:
                objekt.ref = (namespace, superkl)                
        except AttributeError, exc:
            if DEBUG:
                print "#===>", exc

            typ = self.type

            try:
                (namespace, klass) = _namespace_and_tag(self, typ, top)
                if self.xmlns_map[namespace] == top.target_namespace:
                    objekt.type = (None, klass)
                elif self.xmlns_map[namespace] == XMLSCHEMA:
                    objekt.type = klass
                    objekt.value_type = {"base": klass}
                else:
                    objekt.type = (namespace, klass)

            except ValueError:
                objekt.type = typ
                objekt.value_type = {"base": typ}

            except AttributeError:
                # neither type nor reference, definitely local
                if hasattr(self, "parts"):
                    if len(self.parts) == 1:
                        if isinstance(self.parts[0], ComplexType) or \
                            isinstance(self.parts[0], SimpleType):
                            self.parts[0].name = self.name
                            objekt.type = self.parts[0].repr(top, sup, 
                                                            parent=self.name)
                            objekt.scoped = True
                    elif len(self.parts) == 2:# One child might be Annotation
                        if isinstance(self.parts[0], Annotation):
                            self.parts[1].name = self.name
                            objekt.type = self.parts[1].repr(top, sup, 
                                                            parent=self.name)
                            objekt.scoped = True
                        elif isinstance(self.parts[1], Annotation):
                            self.parts[0].name = self.name
                            objekt.type = self.parts[0].repr(top, sup, 
                                                            parent=self.name)
                            objekt.scoped = True
                else:
                    if DEBUG:
                        print "$", self
                    raise 

            if parent:
                objekt.class_name = "%s_%s" % (
                                        leading_uppercase(parent),
                                        objekt.name)
                objekt.scoped = True
                
        return objekt


class SimpleType(Complex):
    def repr(self, top=None, _sup=None, _argv=None, _child=True, parent=""):
        if self.py_class:
            return self.py_class
            
        obj = PyType(self.name, root=top)
        try:
            if len(self.parts) == 1:
                part = self.parts[0]
                if isinstance(part, Restriction):
                    if part.parts:
                        if isinstance(part.parts[0], Enumeration):
                            lista = [p.value for p in part.parts]
                            obj.value_type = {"base":part.base,
                                                "enumeration":lista}
                        elif isinstance(part.parts[0], MaxLength):
                            obj.value_type = {"base":part.base,
                                                "maxlen":part.parts[0].value}
                        elif isinstance(part.parts[0], Length):
                            obj.value_type = {"base":part.base,
                                                "len":part.parts[0].value}
                    else:
                        obj.value_type = {"base":part.base}
                elif isinstance(part, List):
                    if part.itemType:
                        obj.value_type = {"base":"list", "member":part.itemType}
        except ValueError:
            pass
        
        self.py_class = obj
        return obj
        

class Sequence(Complex):
    def collect(self, top, sup, argv=None, parent=""):
        argv_copy = sd_copy(argv)
        for key, val in self.__dict__.items():
            if key not in ['xmlns_map'] and not key.startswith("_"):
                argv_copy[key] = val
    
        if DEBUG:
            print "#Sequence: %s" % argv
        return Complex.collect(self, top, sup, argv_copy, parent)


class SimpleContent(Complex):
    pass


class ComplexContent(Complex):
    pass


class Key(Complex):
    pass


class Redefine(Complex):
    pass


class Extension(Complex):
    def collect(self, top, sup, argv=None, parent=""):
        if self._own or self._inherited:
            return self._own, self._inherited
        
        if DEBUG:
            print "#!!!", self.__dict__

        try:
            base = self.base
            (namespace, tag) = _namespace_and_tag(self, base, top)
                    
            if self.xmlns_map[namespace] == top.target_namespace:
                cti = get_type_def(tag, top.parts)
                if not cti.py_class:
                    cti.repr(top, sup)
                #print "#EXT..",ct._collection
                self._inherited = cti.py_class.properties[0][:]
                self._inherited.extend(cti.py_class.properties[1])
            elif self.xmlns_map[namespace] == XMLSCHEMA: 
                base = tag
            else:
                iattr = _import_attrs(top.modul[namespace], tag, top)
                #print "#EXT..-", ia
                self._inherited = iattr
        except (AttributeError, ValueError):
            base = None

        self._extend(top, sup, argv, parent, base)

        return self._own, self._inherited

class Choice(Complex):
    def collect(self, top, sup, argv=None, parent=""):
        argv_copy = sd_copy(argv)
        for key, val in self.__dict__.items():
            if key not in ['xmlns_map'] and not key.startswith("_"):
                argv_copy[key] = val

        # A choice means each element may not be part of the choice
        argv_copy["minOccurs"] = 0
            
        if DEBUG:
            print "#Choice: %s" % argv
        return Complex.collect(self, top, sup, argv_copy, parent=parent)

class Restriction(Complex):
    pass
    # if isinstance(self.parts[0], Enumeration):
    #     values = [enum.value for enum in self.parts]

class ComplexType(Complex):
    def repr(self, top=None, sup=None, _argv=None, _child=True, parent=""):
        if self.py_class:
            return self.py_class
                    
        # looking for a pattern here
        significant_parts = self.significant_parts()
        value_type = ""
        if len(significant_parts) == 1:
            if isinstance(significant_parts[0], ComplexContent) or \
                isinstance(significant_parts[0], SimpleContent):
                cci = significant_parts[0]
                if len(cci.parts) == 1:
                    if isinstance(cci.parts[0], Extension):
                        ext = cci.parts[0]

                        (namespace, name) = _namespace_and_tag(ext, ext.base, 
                                                                top)

                        if ext.xmlns_map[namespace] == top.target_namespace:
                            new_sup = name
                            cti = get_type_def(new_sup, top.parts)
                            if cti and not cti.py_class:
                                cti.repr(top, sup)
                        elif ext.xmlns_map[namespace] == XMLSCHEMA:
                            new_sup = None
                            value_type = name
                        else:
                            new_sup = "%s.%s" % (namespace, name)
                            
                        #print "#Superior: %s" % new_sup
                        if new_sup:
                            sup = new_sup
            else:
                #print "#>>", self.parts[0].__class__
                pass
                
        try:
            self.py_class = PyType(self.name, superior=sup, 
                                    namespace=top.target_namespace, root=top)
        except AttributeError: # No name 
            self.py_class = PyType("", superior=sup, 
                                    namespace=top.target_namespace, root=top)

        try:
            self.py_class.abstract = self.abstract
        except AttributeError:
            pass
        
        if value_type:
            self.py_class.value_type = {"base": value_type}
            
        try:
            if not parent:
                try:
                    parent = self.name
                except AttributeError:
                    parent = ""
            
            self.py_class.properties = self.collect(top, sup, parent=parent)
        except ValueError:
            pass
            
        return self.py_class 
        
class Annotation(Complex):
    pass

class All(Complex):
    pass

class Group(Complex):
    def collect(self, top, sup, argv=None, parent=""):
        """ means this element is part of a larger object, hence a property of 
        that object """
        
        try:
            #objekt = PyGroup("", root=top)
            (namespace, tag) = _namespace_and_tag(self, self.ref, top)
    
            try:
                if self.xmlns_map[namespace] == top.target_namespace:
                    cti = get_type_def(tag, top.parts)
                    try:
                        return cti.py_class.properties
                    except ValueError:
                        return cti.collect(top, sup) 
                else:
                    raise Exception(
                        "Reference to group in other XSD file, not supported")
            except KeyError:
                raise Exception("Missing namespace definition")            
        except AttributeError, exc:
            print "#!!!!", exc
            return [], []

    def repr(self, top=None, sup=None, argv=None, _child=True, parent=""):
        if self.py_class:
            return self.py_class

        self.py_class = objekt = PyGroup(self.name, root=top)

        min_max(self, objekt, argv)
        
        try:
            self._extend(top, sup, argv)
            objekt.properties = (self._own, self._inherited)
        except ValueError:
            pass
            
        return objekt

class Unique(Complex):
    pass

class Selector(Complex):
    pass

class Field(Complex):
    pass

class AttributeGroup(Complex):
    def collect(self, top, sup, argv=None, parent=""):
        try:
            (_namespace, typ) = _namespace_and_tag(self, self.ref, top)
            # TODO: use definitions in other XSD
            cti = get_type_def(typ, top.parts)
            return cti.collect(top, sup)
        except AttributeError:
            if self._own or self._inherited:
                return self._own, self._inherited
            
            argv_copy = sd_copy(argv)
            
            for prop in self.parts:
                if isinstance(prop, Attribute):
                    self._own.append(prop.repr(top, sup, argv_copy, parent))

            return self._own, self._inherited

    def repr(self, top=None, sup=None, _argv=None, _child=True, parent=""):
        if self.py_class:
            return self.py_class
            
        self.py_class = PyAttributeGroup(self.name, root=top)

        try:
            self.py_class.properties = self.collect(top, sup)
        except ValueError:
            pass
            
        return self.py_class 

def pyify_0(name):
    res = ""
    match = re.match(
            r"^(([A-Z])[a-z]+)(([A-Z])[a-z]+)?(([A-Z])[a-z]+)?(([A-Z])[a-z]+)?",
            name)
    res += match.group(1).lower()
    for num in range(3, len(match.groups()), 2):
        try:
            res += "_"+match.group(num+1).lower()+match.group(num)[1:]
        except AttributeError:
            break
    
    res = res.replace("-","_")
    if res in ["class"]:
        res += "_"
    return res


def pyify(name):
    # AssertionIDRef
    res = []
    
    upc = []
    pre = ""
    for char in name:
        if "A" <= char <= "Z":
            upc.append(char)
        elif char == "-":
            upc.append("_")
        else:
            if upc:
                if len(upc) == 1:
                    res.append(pre+upc[0].lower())
                else:
                    if pre:
                        res.append(pre)
                    for uch in upc[:-1]:
                        res.append(uch.lower())
                    res.append("_"+upc[-1].lower())
                        
                upc = []
            res.append(char)
            pre = "_"
    if upc:
        if len(upc) == len(name):
            return name.lower()
        else:
            res.append("_"+("".join(upc).lower()))
        
    return "".join(res)


def get_type_def( typ, defs):
    for cdef in defs:
        try:
            if cdef.name == typ:
                return cdef
        except AttributeError:
            pass
    return None
    

def sort_elements(els):
    res = []
    
    diff = False
    for key, val in els.items():
        if not val:
            res.append(key)
            del els[key]
            diff = True
    
    res.sort()
    while diff:
        diff = False
        for key, val in els.items():
            pres = [v for v in val if v not in res and ':' not in v]
            els[key] = pres
            if pres != val:
                diff = True

        #print els
        partres = []
        for key, val in els.items():
            if not val:
                partres.append(key)
                del els[key]
                diff = True
        partres.sort()
        res.extend(partres)
        
    return res, els


def output(elem, target_namespace, eldict, ignore=None):
    done = 0

    if ignore is None:
        ignore = []
        
    try:
        (preps, text) = elem.text(target_namespace, eldict, False, ignore)
    except TypeError:
        return done
    except MissingPrerequisite:
        return done
    
    for prep in preps:
        if prep:
            done = 1
            if isinstance(prep, basestring):
                print prep
            else:
                for item in prep:
                    print item
                    print
            print 

    if text:
        done = 1
        elem.done = True
        print text
        print
    
    return done
    

def intro():
    print """#!/usr/bin/env python

#
# Generated %s by parse_xsd.py version %s.
#

import saml2
from saml2 import SamlBase
""" % (time.ctime(), __version__)

#NAMESPACE = 'http://www.w3.org/2000/09/xmldsig#'
    

def block_items(objekt, block, eldict):
    if objekt not in block:
        if isinstance(objekt.type, PyType):
            if objekt.type not in block:
                block.append(objekt.type)
        block.append(objekt)
        if isinstance(objekt, PyType):
            others = [p for p in eldict.values() if isinstance(p, 
                                    PyElement) and p.type[1] == objekt.name]
            for item in others:
                if item not in block:
                    block.append(item)
    return block

    
def find_parent(elm, eldict):
    if isinstance(elm, PyElement):
        if elm.type:
            sup = eldict[elm.type[1]]
            return find_parent(sup, eldict)
        elif elm.ref:
            sup = eldict[elm.ref]
            if sup.name == elm.name:
                return elm
            return find_parent(sup, eldict)
    else:
        if elm.superior:
            sup = eldict[elm.superior[0]]
            if sup.done:
                return elm
            return find_parent(sup, eldict)
    
    return elm
    

class Schema(Complex):

    def __init__(self, elem, impo, add, modul, defs):
        Complex.__init__(self, elem)
        self.impo = impo
        self.add = add
        self.modul = modul
        self.py_elements = {}
        self.py_attributes = {}
        self.elems = []
        self.attrgrp = []
        self.defs = []
        try:
            self.target_namespace = self.targetNamespace
        except AttributeError:
            self.target_namespace = ""
        for def_file in defs:
            self.defs.append(open(def_file).read())

    def _mk_list(self, objekt, alla, eldict):
        tup = []
        for prop in alla:
            (mod, cname) = _mod_cname(prop, eldict)

            if prop.max == "unbounded":
                lista = True
            else:
                lista = False

            spec = objekt.child_spec(self.target_namespace, 
                                        prop, mod, cname, 
                                        lista)
            lines = ["%s.%s" % (objekt.class_name, spec)]
            tup.append((prop, lines, spec))
        
        return tup
        
    def adjust(self, eldict, block):
        udict = {}
        for elem in self.elems:
            if isinstance(elem, PyAttribute) or isinstance(elem, PyGroup):
                elem.done = True
                continue
            if elem in block:
                continue
            if not elem.done:
                udict[elem] = elem.undefined(eldict)

        keys = [k.name for k in udict.keys()]
        print "#", keys
        res = (None, [])
        if not udict:
            return res
        level = 1
        rblocked = [p.name for p in block]
        while True:
            non_child = 0
            for objekt, (sup, elems) in udict.items():
                if sup:
                    continue
                else:
                    non_child += 1
                    signif = []
                    other = []
                    for elem in elems:
                        if elem.name in keys:
                            signif.append(elem)
                        elif elem.ref in rblocked:
                            other.append(elem)
                    if len(signif) <= level:
                        alla = signif
                        alla.extend(other)
                        tup = self._mk_list(objekt, alla, eldict)
                        res = (objekt, tup)
                        break
            if res[0]:
                ref = res[0].name
                tups = res[1]
                for objekt, (sups, elems) in udict.items():
                    if sups:
                        for sup in sups:
                            if sup.name == ref:
                                for tup in tups:
                                    tup[1].append("%s.%s" % (objekt.class_name,
                                                            tup[2]))
                                break
                    else:
                        pass
            elif not non_child or level > 10:
                elm = udict.keys()[0]
                parent = find_parent(elm, eldict)
                signif = []
                other = []
                tot = parent.properties[0]
                tot.extend(parent.properties[1])
                alla = []
                for elem in tot:
                    if isinstance(elem, PyAttribute):
                        continue
                    else:
                        alla.append(elem)
                tup = self._mk_list(parent, alla, eldict)
                res = (parent, tup)
                
            if res[0]:
                break
            else:
                level += 1
        return res

    def _do(self, eldict):
        not_done = 1
        undone = 0
        while not_done:
            not_done = 0
            undone = 0
            for elem in self.elems:
                if isinstance(elem, PyGroup) or elem.done:
                    continue
                undone += 1
                not_done += output(elem, self.target_namespace, eldict)
        return undone
        
    def _element_from_string(self):
        print "ELEMENT_FROM_STRING = {"
        for elem in self.elems:
            if isinstance(elem, PyAttribute) or isinstance(elem, PyGroup):
                continue
            if elem.abstract:
                continue
            print "%s%s.c_tag: %s_from_string," % (INDENT, elem.class_name, 
                                                    pyify(elem.class_name))
        print "}"
        print
        
    def _element_by_tag(self):
        print "ELEMENT_BY_TAG = {"
        listed = []
        for elem in self.elems:
            if isinstance(elem, PyAttribute) or isinstance(elem, PyGroup):
                continue
            if elem.abstract:
                continue
            lcen = elem.name
            print "%s'%s': %s," % (INDENT, lcen, elem.class_name)
            listed.append(lcen)
        for elem in self.elems:
            if isinstance(elem, PyAttribute) or isinstance(elem, PyGroup):
                continue
            lcen = elem.name
            if elem.abstract and lcen not in listed:
                print "%s'%s': %s," % (INDENT, lcen, elem.class_name)
                listed.append(lcen)
        print "}"
        print
        
    def out(self):
        for part in self.parts:
            if isinstance(part, Import):
                continue
            if part is None:
                continue
                
            elem = part.repr(self, "", {}, False)
            if elem:
                if isinstance(elem, PyAttributeGroup):
                    self.attrgrp.append(elem)
                else:
                    self.elems.append(elem)
        
        eldict = {}
        for elem in self.elems:
            eldict[elem.name] = elem

        #print eldict.keys()
        
        intro()
        for modul in self.add:
            print "from %s import *" % modul
        for _namespace, (mod, namn) in self.impo.items():
            if namn:
                print "import %s as %s" % (mod, namn)
        print        
        print "NAMESPACE = '%s'" % self.target_namespace
        print

        for defs in self.defs:
            print defs
            print
        
        exceptions = []
        block = []
        while self._do(eldict):
            print "#.................."
            (objekt, tups) = self.adjust(eldict, block)
            if not objekt:
                break
            ignore = [p.name for (p, _l, _s) in tups]
            done = output(objekt, self.target_namespace, eldict, ignore)
            if done:
                for (prop, lines, _) in tups:
                    exceptions.extend(lines)
                block = []
            else:
                block = block_items(objekt, block, eldict)

        if exceptions:
            print "#", 70*'+'
            for line in exceptions:
                print line
            print "#", 70*'+'
            print
        
        for attrgrp in self.attrgrp:
            print "AG_%s = [" % attrgrp.name
            for prop in attrgrp.properties[0]:
                if isinstance(prop.type, PyObj):
                    print "%s('%s', %s_, %s)," % (INDENT, prop.name, 
                                                prop.type.name, prop.required)
                else:
                    print "%s('%s', '%s', %s)," % (INDENT, prop.name, 
                                                    prop.type, prop.required)
            print "]"
            print
           
        self._element_from_string() 
        self._element_by_tag()
        print
        print "def factory(tag, **kwargs):"
        print "    return ELEMENT_BY_TAG[tag](**kwargs)"
        print
        
        
# -----------------------------------------------------------------------------


NAMESPACE_BASE = ["http://www.w3.org/2001/XMLSchema",
    "http://www.w3.org/2000/10/XMLSchema"]

_MAP = {    
    "element": Element,
    "complexType": ComplexType,
    "sequence": Sequence,
    "any": Any,
    "all": All,
    "anyAttribute": AnyAttribute,
    "simpleContent": SimpleContent,
    "extension": Extension,
    "union": Union,
    "restriction": Restriction,
    "enumeration": Enumeration,
    "import": Import,
    "annotation": Annotation,
    "attributeGroup":AttributeGroup,
    "attribute":Attribute,
    "choice": Choice,
    "complexContent": ComplexContent,
    "documentation": Documentation,
    "simpleType": SimpleType,
    "maxLength": MaxLength,
    "list": List,
    "unique": Unique,
    "group": Group,
    "selector": Selector,
    "field": Field,
    "key": Key,
    "include": Include,
    "redefine": Redefine
    }
    
ELEMENTFUNCTION = {}

for nsp in NAMESPACE_BASE:
    for nskey, func in _MAP.items():
        ELEMENTFUNCTION["{%s}%s" % (nsp, nskey)] = func

    
def evaluate(typ, elem):
    try:
        return ELEMENTFUNCTION[typ](elem)
    except KeyError:
        print "Unknown type", typ
        
    
NS_MAP = "xmlns_map"

def parse_nsmap(fil):
    events = "start", "start-ns", "end-ns"

    root = None
    ns_map = []

    for event, elem in ElementTree.iterparse(fil, events):
        if event == "start-ns":
            ns_map.append(elem)
        elif event == "end-ns":
            ns_map.pop()
        elif event == "start":
            if root is None:
                root = elem
            elem.set(NS_MAP, dict(ns_map))

    return ElementTree.ElementTree(root)

def usage():
    print "Usage: parse_xsd [-i <module:as>] xsd.file > module.py"
    
def recursive_find_module(name, path=None):
    parts = name.split(".")

    mod_a = None
    for part in parts:
        #print "$$", part, path
        try:
            (fil, pathname, desc) = imp.find_module(part, path)
        except ImportError:
            raise 

        mod_a = imp.load_module(name, fil, pathname, desc)
        sys.modules[name] = mod_a
        path = mod_a.__path__

    return mod_a

def get_mod(name, path=None):
    try:
        mod_a = sys.modules[name]
        if not isinstance(mod_a, types.ModuleType):
            raise KeyError
    except KeyError:
        try:
            (fil, pathname, desc) = imp.find_module(name, path)
            mod_a = imp.load_module(name, fil, pathname, desc)
        except ImportError:
            if "." in name:
                mod_a = recursive_find_module(name, path)
            else:
                raise
        sys.modules[name] = mod_a
    return mod_a


def recursive_add_xmlns_map(_sch, base):
    for _part in _sch.parts:
        _part.xmlns_map.update(base.xmlns_map)
        if isinstance(_part, Complex):
            recursive_add_xmlns_map(_part, base)

def find_and_replace(base, mods):
    base.xmlns_map = mods.xmlns_map
    recursive_add_xmlns_map(base, mods)
    rm = []
    for part in mods.parts:
        try:
            _name = part.name
        except AttributeError:
            continue
        for _part in base.parts:
            try:
                if _name == _part.name:
                    rm.append(_part)
            except AttributeError:
                continue
    for part in rm:
        base.parts.remove(part)
    base.parts.extend(mods.parts)
    return base

def read_schema(doc, add, defs, impo, modul, ignore, sdir):
    for path in sdir:
        fil = "%s%s" % (path, doc)
        try:
            fp = open(fil)
            fp.close()
            break
        except IOError as e:
            if e.errno == errno.EACCES:
                continue
    else:
        raise Exception("Could not find schema file")

    tree = parse_nsmap(fil)

    known = NAMESPACE_BASE[:]
    known.append(XML_NAMESPACE)
    for key, namespace in tree._root.attrib["xmlns_map"].items():
        if namespace in known:
            continue
        else:
            try:
                modul[key] = modul[namespace]
                impo[namespace][1] = key
            except KeyError:
                if namespace == tree._root.attrib["targetNamespace"]:
                    continue
                elif namespace in ignore:
                    continue
                else:
                    raise Exception("Undefined namespace: %s" % namespace)

    _schema =  Schema(tree._root, impo, add, modul, defs)
    _included_parts = []
    _remove_parts = []
    _replace = []
    for part in _schema.parts:
        if isinstance(part, Include):
            _sch = read_schema(part.schemaLocation, add, defs, impo, modul,
                               ignore, sdir)
            # Add namespace information
            recursive_add_xmlns_map(_sch, _schema)
            _included_parts.extend(_sch.parts)
            _remove_parts.append(part)
        elif isinstance(part, Redefine):
            # This is the schema that is going to be redefined
            _redef = read_schema(part.schemaLocation, add, defs, impo, modul,
                                 ignore, sdir)
            # so find and replace
            # Use the schema to be redefined as starting point
            _replacement = find_and_replace(_redef, part)
            _replace.append((part, _replacement.parts))

    for part in _remove_parts:
        _schema.parts.remove(part)
    _schema.parts.extend(_included_parts)
    if _replace:
        for vad, med in _replace:
            _schema.parts.remove(vad)
            _schema.parts.extend(med)
    return _schema

def main(argv):
    try:
        opts, args = getopt.getopt(argv, "a:d:hi:I:s:",
                                    ["add=", "help", "import=", "defs="])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)

    add = []
    defs = []
    impo = {}
    modul = {}
    ignore = []
    sdir = ["./"]

    for opt, arg in opts:
        if opt in ("-a", "--add"):
            add.append(arg)
        elif opt in ("-d", "--defs"):
            defs.append(arg)
        elif opt in ("-h", "--help"):
            usage()
            sys.exit()
        elif opt in ("-s", "--schemadir"):
            sdir.append(arg)
        elif opt in ("-i", "--import"):
            mod = get_mod(arg, ['.'])
            modul[mod.NAMESPACE] = mod
            impo[mod.NAMESPACE] = [arg, None]
        elif opt in ("-I", "--ignore"):
            ignore.append(arg)
        else:
            assert False, "unhandled option"

    if not args:
        print "No XSD-file specified"
        usage()
        sys.exit(2)

    schema = read_schema(args[0], add, defs, impo, modul, ignore, sdir)
    #print schema.__dict__
    schema.out()

if __name__ == "__main__":    
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = sync_attrmaps
#!/usr/bin/env python

from importlib import import_module
import sys
import os

__author__ = 'roland'


def load(head, tail):
    if head == "":
        if sys.path[0] != ".":
            sys.path.insert(0, ".")
    else:
        sys.path.insert(0, head)

    if tail.endswith(".py"):
        tail = tail[:-3]

    return import_module(tail)


def intcmp(s1, s2):
    try:
        _i1 = int(s1)
        _i2 = int(s2)
    except ValueError:
        _i1 = s1
        _i2 = s2

    if _i1 < _i2:
        return -1
    if _i1 > _i2:
        return 1
    else:
        return 0


class AMap(object):
    def __init__(self, head, tail, indent=4 * " "):
        self.mod = load(head, tail)
        self.variable = {}
        self.vars = []
        self.text = []
        self.indent = indent
        for key, val in self.mod.__dict__.items():
            if key.startswith("__"):
                continue
            elif key == "MAP":
                continue
            else:
                self.variable[key] = val
                self.vars.append(key)
        self.vars.sort()

    def sync(self):
        for key, val in self.mod.MAP["fro"].items():
            try:
                assert self.mod.MAP["to"][val] == key
            except KeyError:  # missing value
                print "# Added %s=%s" % (self.mod.MAP["to"][val], key)
                self.mod.MAP["to"][val] = key
            except AssertionError:
                raise Exception("Mismatch key:%s '%s' != '%s'" % (
                    key, val, self.mod.MAP["to"][val]))

        for val in self.mod.MAP["to"].values():
            if val not in self.mod.MAP["fro"]:
                print "# Missing URN '%s'" % val

    def do_fro(self):
        txt = ["%s'fro': {" % self.indent]
        i2 = self.indent + self.indent
        _fro = self.mod.MAP["fro"]
        for var in self.vars:
            _v = self.variable[var]
            li = [k[len(_v):] for k in _fro.keys() if k.startswith(_v)]
            li.sort(intcmp)
            for item in li:
                txt.append("%s%s+'%s': '%s'," % (i2, var, item,
                                                 _fro[_v + item]))
        txt.append('%s},' % self.indent)
        return txt

    def do_to(self):
        txt = ["%s'to': {" % self.indent]
        i2 = self.indent + self.indent
        _to = self.mod.MAP["to"]
        _keys = _to.keys()
        _keys.sort()
        invmap = dict([(v, k) for k, v in self.variable.items()])

        for key in _keys:
            val = _to[key]
            for _urn, _name in invmap.items():
                if val.startswith(_urn):
                    txt.append("%s'%s': %s+'%s'," % (i2, key, _name,
                                                     val[len(_urn):]))

        txt.append('%s}' % self.indent)
        return txt

    def __str__(self):
        self.sync()
        text = []
        for key in self.vars:
            text.append("%s = '%s'" % (key, self.variable[key]))

        text.extend(["", ""])

        text.append("MAP = {")
        text.append("%s'identifier': '%s'," % (self.indent,
                                               self.mod.MAP["identifier"]))
        text.extend(self.do_fro())
        text.extend(self.do_to())

        text.append("}")
        text.append("")
        return "\n".join(text)


if __name__ == "__main__":
    _name = sys.argv[1]
    if os.path.isfile(_name):
        directory, fname = os.path.split(_name)
        amap = AMap(directory, fname, 4 * " ")
        f = open(_name, "w")
        f.write("%s" % amap)
        f.close()
    elif os.path.isdir(_name):
        for fname in os.listdir(_name):
            if fname == "__init__.py":
                continue
            elif fname.endswith(".pyc"):
                continue
            print 10 * "=" + fname + 10 * "="
            amap = AMap(_name, fname, 4 * " ")
            f = open(fname, "w")
            f.write("%s" % amap)
            f.close()

########NEW FILE########
