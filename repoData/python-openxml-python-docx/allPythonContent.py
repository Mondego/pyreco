__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# python-docx documentation build configuration file, created by
# sphinx-quickstart on Sat Jun 29 17:34:36 2013.
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))

from docx import __version__


# -- General configuration ---------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.viewcode'
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'python-docx'
copyright = u'2013, Steve Canny'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# A string of reStructuredText that will be included at the end of every source
# file that is read. This is the right place to add substitutions that should
# be available in every file.
rst_epilog = """
.. |api-Document| replace:: :class:`docx.api.Document`

.. |_Body| replace:: :class:`_Body`

.. |_Cell| replace:: :class:`_Cell`

.. |_Column| replace:: :class:`_Column`

.. |_Columns| replace:: :class:`_Columns`

.. |Document| replace:: :class:`Document`

.. |docx| replace:: ``python-docx``

.. |Emu| replace:: :class:`.Emu`

.. |False| replace:: ``False``

.. |InlineShape| replace:: :class:`.InlineShape`

.. |InlineShapes| replace:: :class:`.InlineShapes`

.. |int| replace:: :class:`int`

.. |Length| replace:: :class:`.Length`

.. |OpcPackage| replace:: :class:`OpcPackage`

.. |None| replace:: ``None``

.. |NumberingPart| replace:: :class:`NumberingPart`

.. |Paragraph| replace:: :class:`.Paragraph`

.. |Part| replace:: :class:`Part`

.. |_Relationship| replace:: :class:`_Relationship`

.. |Relationships| replace:: :class:`_Relationships`

.. |_Row| replace:: :class:`_Row`

.. |_Rows| replace:: :class:`_Rows`

.. |Run| replace:: :class:`Run`

.. |StylesPart| replace:: :class:`StylesPart`

.. |Table| replace:: :class:`.Table`

.. |Text| replace:: :class:`Text`

.. |True| replace:: ``True``

.. |ValueError| replace:: :class:`ValueError`
"""


# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['.build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'armstrong'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}
html_sidebars = {
    '**': ['localtoc.html', 'relations.html', 'sidebarlinks.html',
           'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'python-docxdoc'


# -- Options for LaTeX output -----------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file,
#  target name,
#  title,
#  author,
#  documentclass [howto/manual]).
latex_documents = [
    ('index', 'python-docx.tex', u'python-docx Documentation',
     u'Steve Canny', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output -----------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'python-docx', u'python-docx Documentation',
     [u'Steve Canny'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ---------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'python-docx', u'python-docx Documentation',
     u'Steve Canny', 'python-docx', 'One line description of project.',
     'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = api
# encoding: utf-8

"""
Directly exposed API functions and classes, :func:`Document` for now.
Provides a syntactically more convenient API for interacting with the
OpcPackage graph.
"""

from __future__ import absolute_import, division, print_function

import os

from docx.enum.text import WD_BREAK
from docx.opc.constants import CONTENT_TYPE as CT, RELATIONSHIP_TYPE as RT
from docx.package import Package
from docx.parts.numbering import NumberingPart
from docx.parts.styles import StylesPart
from docx.shared import lazyproperty


_thisdir = os.path.split(__file__)[0]
_default_docx_path = os.path.join(_thisdir, 'templates', 'default.docx')


class Document(object):
    """
    Return a |Document| instance loaded from *docx*, where *docx* can be
    either a path to a ``.docx`` file (a string) or a file-like object. If
    *docx* is missing or ``None``, the built-in default document "template"
    is loaded.
    """
    def __init__(self, docx=None):
        super(Document, self).__init__()
        document_part, package = self._open(docx)
        self._document_part = document_part
        self._package = package

    def add_heading(self, text='', level=1):
        """
        Return a heading paragraph newly added to the end of the document,
        populated with *text* and having the heading paragraph style
        determined by *level*. If *level* is 0, the style is set to
        ``'Title'``. If *level* is 1 (or not present), ``'Heading1'`` is used.
        Otherwise the style is set to ``'Heading{level}'``. If *level* is
        outside the range 0-9, |ValueError| is raised.
        """
        if not 0 <= level <= 9:
            raise ValueError("level must be in range 0-9, got %d" % level)
        style = 'Title' if level == 0 else 'Heading%d' % level
        return self.add_paragraph(text, style)

    def add_page_break(self):
        """
        Return a paragraph newly added to the end of the document and
        containing only a page break.
        """
        p = self._document_part.add_paragraph()
        r = p.add_run()
        r.add_break(WD_BREAK.PAGE)
        return p

    def add_paragraph(self, text='', style=None):
        """
        Return a paragraph newly added to the end of the document, populated
        with *text* and having paragraph style *style*.
        """
        p = self._document_part.add_paragraph()
        if text:
            r = p.add_run()
            r.add_text(text)
        if style is not None:
            p.style = style
        return p

    def add_picture(self, image_path_or_stream, width=None, height=None):
        """
        Add the image at *image_path_or_stream* in a new paragraph at the end
        of the document. If neither width nor height is specified, the
        picture appears at its native size. If only one is specified, it is
        used to compute a scaling factor that is then applied to the
        unspecified dimension, preserving the aspect ratio of the image. The
        native size of the picture is calculated using the dots-per-inch
        (dpi) value specified in the image file, defaulting to 72 dpi if no
        value is specified, as is often the case.
        """
        picture = self.inline_shapes.add_picture(image_path_or_stream)

        # scale picture dimensions if width and/or height provided
        if width is not None or height is not None:
            native_width, native_height = picture.width, picture.height
            if width is None:
                scaling_factor = float(height) / float(native_height)
                width = int(round(native_width * scaling_factor))
            elif height is None:
                scaling_factor = float(width) / float(native_width)
                height = int(round(native_height * scaling_factor))
            # set picture to scaled dimensions
            picture.width = width
            picture.height = height

        return picture

    def add_table(self, rows, cols, style='LightShading-Accent1'):
        """
        Add a table having row and column counts of *rows* and *cols*
        respectively and table style of *style*. If *style* is |None|, a
        table with no style is produced.
        """
        table = self._document_part.add_table(rows, cols)
        if style:
            table.style = style
        return table

    @property
    def inline_shapes(self):
        """
        Return a reference to the |InlineShapes| instance for this document.
        """
        return self._document_part.inline_shapes

    @lazyproperty
    def numbering_part(self):
        """
        Instance of |NumberingPart| for this document. Creates an empty
        numbering part if one is not present.
        """
        try:
            return self._document_part.part_related_by(RT.NUMBERING)
        except KeyError:
            numbering_part = NumberingPart.new()
            self._document_part.relate_to(numbering_part, RT.NUMBERING)
            return numbering_part

    @property
    def paragraphs(self):
        """
        A list of |Paragraph| instances corresponding to the paragraphs in
        the document, in document order. Note that paragraphs within revision
        marks such as ``<w:ins>`` or ``<w:del>`` do not appear in this list.
        """
        return self._document_part.paragraphs

    def save(self, path_or_stream):
        """
        Save this document to *path_or_stream*, which can be either a path to
        a filesystem location (a string) or a file-like object.
        """
        self._package.save(path_or_stream)

    @lazyproperty
    def styles_part(self):
        """
        Instance of |StylesPart| for this document. Creates an empty styles
        part if one is not present.
        """
        try:
            return self._document_part.part_related_by(RT.STYLES)
        except KeyError:
            styles_part = StylesPart.new()
            self._document_part.relate_to(styles_part, RT.STYLES)
            return styles_part

    @property
    def tables(self):
        """
        A list of |Table| instances corresponding to the tables in the
        document, in document order. Note that tables within revision marks
        such as ``<w:ins>`` or ``<w:del>`` do not appear in this list.
        """
        return self._document_part.tables

    @staticmethod
    def _open(docx):
        """
        Return a (document_part, package) 2-tuple loaded from *docx*, where
        *docx* can be either a path to a ``.docx`` file (a string) or a
        file-like object. If *docx* is ``None``, the built-in default
        document "template" is loaded.
        """
        docx = _default_docx_path if docx is None else docx
        package = Package.open(docx)
        document_part = package.main_document
        if document_part.content_type != CT.WML_DOCUMENT_MAIN:
            tmpl = "file '%s' is not a Word file, content type is '%s'"
            raise ValueError(tmpl % (docx, document_part.content_type))
        return document_part, package

########NEW FILE########
__FILENAME__ = compat
# encoding: utf-8

"""
Provides Python 2/3 compatibility objects
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

import sys

# ===========================================================================
# Python 3 versions
# ===========================================================================

if sys.version_info >= (3, 0):

    from io import BytesIO

    def is_string(obj):
        """
        Return True if *obj* is a string, False otherwise.
        """
        return isinstance(obj, str)

# ===========================================================================
# Python 2 versions
# ===========================================================================

else:

    from StringIO import StringIO as BytesIO  # noqa

    def is_string(obj):
        """
        Return True if *obj* is a string, False otherwise.
        """
        return isinstance(obj, basestring)

########NEW FILE########
__FILENAME__ = shape
# encoding: utf-8

"""
Enumerations related to DrawingML shapes in WordprocessingML files
"""

from __future__ import absolute_import, print_function, unicode_literals


class WD_INLINE_SHAPE_TYPE(object):
    """
    Corresponds to WdInlineShapeType enumeration
    http://msdn.microsoft.com/en-us/library/office/ff192587.aspx
    """
    CHART = 12
    LINKED_PICTURE = 4
    PICTURE = 3
    SMART_ART = 15
    NOT_IMPLEMENTED = -6

WD_INLINE_SHAPE = WD_INLINE_SHAPE_TYPE

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
Enumerations related to text in WordprocessingML files
"""

from __future__ import absolute_import, print_function, unicode_literals


class WD_BREAK_TYPE(object):
    """
    Corresponds to WdBreakType enumeration
    http://msdn.microsoft.com/en-us/library/office/ff195905.aspx
    """
    COLUMN = 8
    LINE = 6
    LINE_CLEAR_LEFT = 9
    LINE_CLEAR_RIGHT = 10
    LINE_CLEAR_ALL = 11  # added for consistency, not in MS version
    PAGE = 7
    SECTION_CONTINUOUS = 3
    SECTION_EVEN_PAGE = 4
    SECTION_NEXT_PAGE = 2
    SECTION_ODD_PAGE = 5
    TEXT_WRAPPING = 11

WD_BREAK = WD_BREAK_TYPE


class WD_UNDERLINE(object):
    """
    Corresponds to WdUnderline enumeration
    http://msdn.microsoft.com/en-us/library/office/ff822388.aspx
    """
    NONE = 0
    SINGLE = 1
    WORDS = 2
    DOUBLE = 3
    DOTTED = 4
    THICK = 6
    DASH = 7
    DOT_DASH = 9
    DOT_DOT_DASH = 10
    WAVY = 11
    DOTTED_HEAVY = 20
    DASH_HEAVY = 23
    DOT_DASH_HEAVY = 25
    DOT_DOT_DASH_HEAVY = 26
    WAVY_HEAVY = 27
    DASH_LONG = 39
    WAVY_DOUBLE = 43
    DASH_LONG_HEAVY = 55

########NEW FILE########
__FILENAME__ = bmp
# encoding: utf-8

from __future__ import absolute_import, division, print_function

from .constants import MIME_TYPE
from .helpers import LITTLE_ENDIAN, StreamReader
from .image import BaseImageHeader


class Bmp(BaseImageHeader):
    """
    Image header parser for BMP images
    """
    @classmethod
    def from_stream(cls, stream):
        """
        Return |Bmp| instance having header properties parsed from the BMP
        image in *stream*.
        """
        stream_rdr = StreamReader(stream, LITTLE_ENDIAN)

        px_width = stream_rdr.read_long(0x12)
        px_height = stream_rdr.read_long(0x16)

        horz_px_per_meter = stream_rdr.read_long(0x26)
        vert_px_per_meter = stream_rdr.read_long(0x2A)

        horz_dpi = cls._dpi(horz_px_per_meter)
        vert_dpi = cls._dpi(vert_px_per_meter)

        return cls(px_width, px_height, horz_dpi, vert_dpi)

    @property
    def content_type(self):
        """
        MIME content type for this image, unconditionally `image/bmp` for
        BMP images.
        """
        return MIME_TYPE.BMP

    @property
    def default_ext(self):
        """
        Default filename extension, always 'bmp' for BMP images.
        """
        return 'bmp'

    @staticmethod
    def _dpi(px_per_meter):
        """
        Return the integer pixels per inch from *px_per_meter*, defaulting to
        96 if *px_per_meter* is zero.
        """
        if px_per_meter == 0:
            return 96
        return int(round(px_per_meter * 0.0254))

########NEW FILE########
__FILENAME__ = constants
# encoding: utf-8

"""
Constants specific the the image sub-package
"""


class JPEG_MARKER_CODE(object):
    """
    JPEG marker codes
    """
    TEM = b'\x01'
    DHT = b'\xC4'
    DAC = b'\xCC'
    JPG = b'\xC8'

    SOF0 = b'\xC0'
    SOF1 = b'\xC1'
    SOF2 = b'\xC2'
    SOF3 = b'\xC3'
    SOF5 = b'\xC5'
    SOF6 = b'\xC6'
    SOF7 = b'\xC7'
    SOF9 = b'\xC9'
    SOFA = b'\xCA'
    SOFB = b'\xCB'
    SOFD = b'\xCD'
    SOFE = b'\xCE'
    SOFF = b'\xCF'

    RST0 = b'\xD0'
    RST1 = b'\xD1'
    RST2 = b'\xD2'
    RST3 = b'\xD3'
    RST4 = b'\xD4'
    RST5 = b'\xD5'
    RST6 = b'\xD6'
    RST7 = b'\xD7'

    SOI = b'\xD8'
    EOI = b'\xD9'
    SOS = b'\xDA'
    DQT = b'\xDB'  # Define Quantization Table(s)
    DNL = b'\xDC'
    DRI = b'\xDD'
    DHP = b'\xDE'
    EXP = b'\xDF'

    APP0 = b'\xE0'
    APP1 = b'\xE1'
    APP2 = b'\xE2'
    APP3 = b'\xE3'
    APP4 = b'\xE4'
    APP5 = b'\xE5'
    APP6 = b'\xE6'
    APP7 = b'\xE7'
    APP8 = b'\xE8'
    APP9 = b'\xE9'
    APPA = b'\xEA'
    APPB = b'\xEB'
    APPC = b'\xEC'
    APPD = b'\xED'
    APPE = b'\xEE'
    APPF = b'\xEF'

    STANDALONE_MARKERS = (
        TEM, SOI, EOI, RST0, RST1, RST2, RST3, RST4, RST5, RST6, RST7
    )

    SOF_MARKER_CODES = (
        SOF0, SOF1, SOF2, SOF3, SOF5, SOF6, SOF7, SOF9, SOFA, SOFB, SOFD,
        SOFE, SOFF
    )

    marker_names = {
        b'\x00': 'UNKNOWN',
        b'\xC0': 'SOF0',
        b'\xC2': 'SOF2',
        b'\xC4': 'DHT',
        b'\xDA': 'SOS',   # start of scan
        b'\xD8': 'SOI',   # start of image
        b'\xD9': 'EOI',   # end of image
        b'\xDB': 'DQT',
        b'\xE0': 'APP0',
        b'\xE1': 'APP1',
        b'\xE2': 'APP2',
        b'\xED': 'APP13',
        b'\xEE': 'APP14',
    }

    @classmethod
    def is_standalone(cls, marker_code):
        return marker_code in cls.STANDALONE_MARKERS


class MIME_TYPE(object):
    """
    Image content types
    """
    BMP = 'image/bmp'
    GIF = 'image/gif'
    JPEG = 'image/jpeg'
    PNG = 'image/png'
    TIFF = 'image/tiff'


class PNG_CHUNK_TYPE(object):
    """
    PNG chunk type names
    """
    IHDR = 'IHDR'
    pHYs = 'pHYs'
    IEND = 'IEND'


class TIFF_FLD_TYPE(object):
    """
    Tag codes for TIFF Image File Directory (IFD) entries.
    """
    BYTE = 1
    ASCII = 2
    SHORT = 3
    LONG = 4
    RATIONAL = 5

    field_type_names = {
        1: 'BYTE', 2: 'ASCII char', 3: 'SHORT', 4: 'LONG',
        5: 'RATIONAL'
    }


TIFF_FLD = TIFF_FLD_TYPE


class TIFF_TAG(object):
    """
    Tag codes for TIFF Image File Directory (IFD) entries.
    """
    IMAGE_WIDTH = 0x0100
    IMAGE_LENGTH = 0x0101
    X_RESOLUTION = 0x011A
    Y_RESOLUTION = 0x011B
    RESOLUTION_UNIT = 0x0128

    tag_names = {
        0x00FE: 'NewSubfileType',
        0x0100: 'ImageWidth',
        0x0101: 'ImageLength',
        0x0102: 'BitsPerSample',
        0x0103: 'Compression',
        0x0106: 'PhotometricInterpretation',
        0x010E: 'ImageDescription',
        0x010F: 'Make',
        0x0110: 'Model',
        0x0111: 'StripOffsets',
        0x0112: 'Orientation',
        0x0115: 'SamplesPerPixel',
        0x0117: 'StripByteCounts',
        0x011A: 'XResolution',
        0x011B: 'YResolution',
        0x011C: 'PlanarConfiguration',
        0x0128: 'ResolutionUnit',
        0x0131: 'Software',
        0x0132: 'DateTime',
        0x0213: 'YCbCrPositioning',
        0x8769: 'ExifTag',
        0x8825: 'GPS IFD',
        0xC4A5: 'PrintImageMatching',
    }

########NEW FILE########
__FILENAME__ = exceptions
# encoding: utf-8

"""
Exceptions specific the the image sub-package
"""


class InvalidImageStreamError(Exception):
    """
    The recognized image stream appears to be corrupted
    """


class UnexpectedEndOfFileError(Exception):
    """
    EOF was unexpectedly encountered while reading an image stream.
    """


class UnrecognizedImageError(Exception):
    """
    The provided image stream could not be recognized.
    """

########NEW FILE########
__FILENAME__ = gif
# encoding: utf-8

from __future__ import absolute_import, division, print_function

from struct import Struct

from .constants import MIME_TYPE
from .image import BaseImageHeader


class Gif(BaseImageHeader):
    """
    Image header parser for GIF images. Note that the GIF format does not
    support resolution (DPI) information. Both horizontal and vertical DPI
    default to 72.
    """
    @classmethod
    def from_stream(cls, stream):
        """
        Return |Gif| instance having header properties parsed from GIF image
        in *stream*.
        """
        px_width, px_height = cls._dimensions_from_stream(stream)
        return cls(px_width, px_height, 72, 72)

    @property
    def content_type(self):
        """
        MIME content type for this image, unconditionally `image/gif` for
        GIF images.
        """
        return MIME_TYPE.GIF

    @property
    def default_ext(self):
        """
        Default filename extension, always 'gif' for GIF images.
        """
        return 'gif'

    @classmethod
    def _dimensions_from_stream(cls, stream):
        stream.seek(6)
        bytes_ = stream.read(4)
        struct = Struct('<HH')
        px_width, px_height = struct.unpack(bytes_)
        return px_width, px_height

########NEW FILE########
__FILENAME__ = helpers
# encoding: utf-8

from __future__ import absolute_import, division, print_function

from struct import Struct

from .exceptions import UnexpectedEndOfFileError


BIG_ENDIAN = '>'
LITTLE_ENDIAN = '<'


class StreamReader(object):
    """
    Wraps a file-like object to provide access to structured data from a
    binary file. Byte-order is configurable. *base_offset* is added to any
    base value provided to calculate actual location for reads.
    """
    def __init__(self, stream, byte_order, base_offset=0):
        super(StreamReader, self).__init__()
        self._stream = stream
        self._byte_order = (
            LITTLE_ENDIAN if byte_order == LITTLE_ENDIAN else BIG_ENDIAN
        )
        self._base_offset = base_offset

    def read(self, count):
        """
        Allow pass-through read() call
        """
        return self._stream.read(count)

    def read_byte(self, base, offset=0):
        """
        Return the int value of the byte at the file position defined by
        self._base_offset + *base* + *offset*. If *base* is None, the byte is
        read from the current position in the stream.
        """
        fmt = 'B'
        return self._read_int(fmt, base, offset)

    def read_long(self, base, offset=0):
        """
        Return the int value of the four bytes at the file position defined by
        self._base_offset + *base* + *offset*. If *base* is None, the long is
        read from the current position in the stream. The endian setting of
        this instance is used to interpret the byte layout of the long.
        """
        fmt = '<L' if self._byte_order is LITTLE_ENDIAN else '>L'
        return self._read_int(fmt, base, offset)

    def read_short(self, base, offset=0):
        """
        Return the int value of the two bytes at the file position determined
        by *base* and *offset*, similarly to ``read_long()`` above.
        """
        fmt = b'<H' if self._byte_order is LITTLE_ENDIAN else b'>H'
        return self._read_int(fmt, base, offset)

    def read_str(self, char_count, base, offset=0):
        """
        Return a string containing the *char_count* bytes at the file
        position determined by self._base_offset + *base* + *offset*.
        """
        def str_struct(char_count):
            format_ = '%ds' % char_count
            return Struct(format_)
        struct = str_struct(char_count)
        chars = self._unpack_item(struct, base, offset)
        unicode_str = chars.decode('UTF-8')
        return unicode_str

    def seek(self, base, offset=0):
        location = self._base_offset + base + offset
        self._stream.seek(location)

    def tell(self):
        """
        Allow pass-through tell() call
        """
        return self._stream.tell()

    def _read_bytes(self, byte_count, base, offset):
        self.seek(base, offset)
        bytes_ = self._stream.read(byte_count)
        if len(bytes_) < byte_count:
            raise UnexpectedEndOfFileError
        return bytes_

    def _read_int(self, fmt, base, offset):
        struct = Struct(fmt)
        return self._unpack_item(struct, base, offset)

    def _unpack_item(self, struct, base, offset):
        bytes_ = self._read_bytes(struct.size, base, offset)
        return struct.unpack(bytes_)[0]

########NEW FILE########
__FILENAME__ = image
# encoding: utf-8

"""
Provides objects that can characterize image streams as to content type and
size, as a required step in including them in a document.
"""

from __future__ import absolute_import, division, print_function

import hashlib
import os

from ..compat import BytesIO, is_string
from ..shared import lazyproperty
from .exceptions import UnrecognizedImageError


class Image(object):
    """
    Graphical image stream such as JPEG, PNG, or GIF with properties and
    methods required by ImagePart.
    """
    def __init__(self, blob, filename, image_header):
        super(Image, self).__init__()
        self._blob = blob
        self._filename = filename
        self._image_header = image_header

    @classmethod
    def from_blob(cls, blob):
        """
        Return a new |Image| subclass instance parsed from the image binary
        contained in *blob*.
        """
        stream = BytesIO(blob)
        return cls._from_stream(stream, blob)

    @classmethod
    def from_file(cls, image_descriptor):
        """
        Return a new |Image| subclass instance loaded from the image file
        identified by *image_descriptor*, a path or file-like object.
        """
        if is_string(image_descriptor):
            path = image_descriptor
            with open(path, 'rb') as f:
                blob = f.read()
                stream = BytesIO(blob)
            filename = os.path.basename(path)
        else:
            stream = image_descriptor
            stream.seek(0)
            blob = stream.read()
            filename = None
        return cls._from_stream(stream, blob, filename)

    @property
    def blob(self):
        """
        The bytes of the image 'file'
        """
        return self._blob

    @property
    def content_type(self):
        """
        MIME content type for this image, e.g. ``'image/jpeg'`` for a JPEG
        image
        """
        return self._image_header.content_type

    @lazyproperty
    def ext(self):
        """
        The file extension for the image. If an actual one is available from
        a load filename it is used. Otherwise a canonical extension is
        assigned based on the content type. Does not contain the leading
        period, e.g. 'jpg', not '.jpg'.
        """
        return os.path.splitext(self._filename)[1][1:]

    @property
    def filename(self):
        """
        Original image file name, if loaded from disk, or a generic filename
        if loaded from an anonymous stream.
        """
        return self._filename

    @property
    def px_width(self):
        """
        The horizontal pixel dimension of the image
        """
        return self._image_header.px_width

    @property
    def px_height(self):
        """
        The vertical pixel dimension of the image
        """
        return self._image_header.px_height

    @property
    def horz_dpi(self):
        """
        Integer dots per inch for the width of this image. Defaults to 72
        when not present in the file, as is often the case.
        """
        return self._image_header.horz_dpi

    @property
    def vert_dpi(self):
        """
        Integer dots per inch for the height of this image. Defaults to 72
        when not present in the file, as is often the case.
        """
        return self._image_header.vert_dpi

    @lazyproperty
    def sha1(self):
        """
        SHA1 hash digest of the image blob
        """
        return hashlib.sha1(self._blob).hexdigest()

    @classmethod
    def _from_stream(cls, stream, blob, filename=None):
        """
        Return an instance of the |Image| subclass corresponding to the
        format of the image in *stream*.
        """
        image_header = _ImageHeaderFactory(stream)
        if filename is None:
            filename = 'image.%s' % image_header.default_ext
        return cls(blob, filename, image_header)


def _ImageHeaderFactory(stream):
    """
    Return a |BaseImageHeader| subclass instance that knows how to parse the
    headers of the image in *stream*.
    """
    from docx.image import SIGNATURES

    def read_32(stream):
        stream.seek(0)
        return stream.read(32)

    header = read_32(stream)
    for cls, offset, signature_bytes in SIGNATURES:
        end = offset + len(signature_bytes)
        found_bytes = header[offset:end]
        if found_bytes == signature_bytes:
            return cls.from_stream(stream)
    raise UnrecognizedImageError


class BaseImageHeader(object):
    """
    Base class for image header subclasses like |Jpeg| and |Tiff|.
    """
    def __init__(self, px_width, px_height, horz_dpi, vert_dpi):
        self._px_width = px_width
        self._px_height = px_height
        self._horz_dpi = horz_dpi
        self._vert_dpi = vert_dpi

    @property
    def content_type(self):
        """
        Abstract property definition, must be implemented by all subclasses.
        """
        msg = (
            'content_type property must be implemented by all subclasses of '
            'BaseImageHeader'
        )
        raise NotImplementedError(msg)

    @property
    def default_ext(self):
        """
        Default filename extension for images of this type. An abstract
        property definition, must be implemented by all subclasses.
        """
        msg = (
            'default_ext property must be implemented by all subclasses of '
            'BaseImageHeader'
        )
        raise NotImplementedError(msg)

    @property
    def px_width(self):
        """
        The horizontal pixel dimension of the image
        """
        return self._px_width

    @property
    def px_height(self):
        """
        The vertical pixel dimension of the image
        """
        return self._px_height

    @property
    def horz_dpi(self):
        """
        Integer dots per inch for the width of this image. Defaults to 72
        when not present in the file, as is often the case.
        """
        return self._horz_dpi

    @property
    def vert_dpi(self):
        """
        Integer dots per inch for the height of this image. Defaults to 72
        when not present in the file, as is often the case.
        """
        return self._vert_dpi

########NEW FILE########
__FILENAME__ = jpeg
# encoding: utf-8

"""
Objects related to parsing headers of JPEG image streams, both JFIF and Exif
sub-formats.
"""

from __future__ import absolute_import, division, print_function

from ..compat import BytesIO
from .constants import JPEG_MARKER_CODE, MIME_TYPE
from .helpers import BIG_ENDIAN, StreamReader
from .image import BaseImageHeader
from .tiff import Tiff


class Jpeg(BaseImageHeader):
    """
    Base class for JFIF and EXIF subclasses.
    """
    @property
    def content_type(self):
        """
        MIME content type for this image, unconditionally `image/jpeg` for
        JPEG images.
        """
        return MIME_TYPE.JPEG

    @property
    def default_ext(self):
        """
        Default filename extension, always 'jpg' for JPG images.
        """
        return 'jpg'


class Exif(Jpeg):
    """
    Image header parser for Exif image format
    """
    @classmethod
    def from_stream(cls, stream):
        """
        Return |Exif| instance having header properties parsed from Exif
        image in *stream*.
        """
        markers = _JfifMarkers.from_stream(stream)
        # print('\n%s' % markers)

        px_width = markers.sof.px_width
        px_height = markers.sof.px_height
        horz_dpi = markers.app1.horz_dpi
        vert_dpi = markers.app1.vert_dpi

        return cls(px_width, px_height, horz_dpi, vert_dpi)


class Jfif(Jpeg):
    """
    Image header parser for JFIF image format
    """
    @classmethod
    def from_stream(cls, stream):
        """
        Return a |Jfif| instance having header properties parsed from image
        in *stream*.
        """
        markers = _JfifMarkers.from_stream(stream)

        px_width = markers.sof.px_width
        px_height = markers.sof.px_height
        horz_dpi = markers.app0.horz_dpi
        vert_dpi = markers.app0.vert_dpi

        return cls(px_width, px_height, horz_dpi, vert_dpi)


class _JfifMarkers(object):
    """
    Sequence of markers in a JPEG file, perhaps truncated at first SOS marker
    for performance reasons.
    """
    def __init__(self, markers):
        super(_JfifMarkers, self).__init__()
        self._markers = list(markers)

    def __str__(self):  # pragma: no cover
        """
        Returns a tabular listing of the markers in this instance, which can
        be handy for debugging and perhaps other uses.
        """
        header = ' offset  seglen  mc  name\n=======  ======  ==  ====='
        tmpl = '%7d  %6d  %02X  %s'
        rows = []
        for marker in self._markers:
            rows.append(tmpl % (
                marker.offset, marker.segment_length,
                ord(marker.marker_code), marker.name
            ))
        lines = [header] + rows
        return '\n'.join(lines)

    @classmethod
    def from_stream(cls, stream):
        """
        Return a |_JfifMarkers| instance containing a |_JfifMarker| subclass
        instance for each marker in *stream*.
        """
        marker_parser = _MarkerParser.from_stream(stream)
        markers = []
        for marker in marker_parser.iter_markers():
            markers.append(marker)
            if marker.marker_code == JPEG_MARKER_CODE.SOS:
                break
        return cls(markers)

    @property
    def app0(self):
        """
        First APP0 marker in image markers.
        """
        for m in self._markers:
            if m.marker_code == JPEG_MARKER_CODE.APP0:
                return m
        raise KeyError('no APP0 marker in image')

    @property
    def app1(self):
        """
        First APP1 marker in image markers.
        """
        for m in self._markers:
            if m.marker_code == JPEG_MARKER_CODE.APP1:
                return m
        raise KeyError('no APP1 marker in image')

    @property
    def sof(self):
        """
        First start of frame (SOFn) marker in this sequence.
        """
        for m in self._markers:
            if m.marker_code in JPEG_MARKER_CODE.SOF_MARKER_CODES:
                return m
        raise KeyError('no start of frame (SOFn) marker in image')


class _MarkerParser(object):
    """
    Service class that knows how to parse a JFIF stream and iterate over its
    markers.
    """
    def __init__(self, stream_reader):
        super(_MarkerParser, self).__init__()
        self._stream = stream_reader

    @classmethod
    def from_stream(cls, stream):
        """
        Return a |_MarkerParser| instance to parse JFIF markers from
        *stream*.
        """
        stream_reader = StreamReader(stream, BIG_ENDIAN)
        return cls(stream_reader)

    def iter_markers(self):
        """
        Generate a (marker_code, segment_offset) 2-tuple for each marker in
        the JPEG *stream*, in the order they occur in the stream.
        """
        marker_finder = _MarkerFinder.from_stream(self._stream)
        start = 0
        marker_code = None
        while marker_code != JPEG_MARKER_CODE.EOI:
            marker_code, segment_offset = marker_finder.next(start)
            marker = _MarkerFactory(
                marker_code, self._stream, segment_offset
            )
            yield marker
            start = segment_offset + marker.segment_length


class _MarkerFinder(object):
    """
    Service class that knows how to find the next JFIF marker in a stream.
    """
    def __init__(self, stream):
        super(_MarkerFinder, self).__init__()
        self._stream = stream

    @classmethod
    def from_stream(cls, stream):
        """
        Return a |_MarkerFinder| instance to find JFIF markers in *stream*.
        """
        return cls(stream)

    def next(self, start):
        """
        Return a (marker_code, segment_offset) 2-tuple identifying and
        locating the first marker in *stream* occuring after offset *start*.
        The returned *segment_offset* points to the position immediately
        following the 2-byte marker code, the start of the marker segment,
        for those markers that have a segment.
        """
        position = start
        while True:
            # skip over any non-\xFF bytes
            position = self._offset_of_next_ff_byte(start=position)
            # skip over any \xFF padding bytes
            position, byte_ = self._next_non_ff_byte(start=position+1)
            # 'FF 00' sequence is not a marker, start over if found
            if byte_ == b'\x00':
                continue
            # this is a marker, gather return values and break out of scan
            marker_code, segment_offset = byte_, position+1
            break
        return marker_code, segment_offset

    def _next_non_ff_byte(self, start):
        """
        Return an offset, byte 2-tuple for the next byte in *stream* that is
        not '\xFF', starting with the byte at offset *start*. If the byte at
        offset *start* is not '\xFF', *start* and the returned *offset* will
        be the same.
        """
        self._stream.seek(start)
        byte_ = self._read_byte()
        while byte_ == b'\xFF':
            byte_ = self._read_byte()
        offset_of_non_ff_byte = self._stream.tell() - 1
        return offset_of_non_ff_byte, byte_

    def _offset_of_next_ff_byte(self, start):
        """
        Return the offset of the next '\xFF' byte in *stream* starting with
        the byte at offset *start*. Returns *start* if the byte at that
        offset is a hex 255; it does not necessarily advance in the stream.
        """
        self._stream.seek(start)
        byte_ = self._read_byte()
        while byte_ != b'\xFF':
            byte_ = self._read_byte()
        offset_of_ff_byte = self._stream.tell() - 1
        return offset_of_ff_byte

    def _read_byte(self):
        """
        Return the next byte read from stream. Raise Exception if stream is
        at end of file.
        """
        byte_ = self._stream.read(1)
        if not byte_:  # pragma: no cover
            raise Exception('unexpected end of file')
        return byte_


def _MarkerFactory(marker_code, stream, offset):
    """
    Return |_Marker| or subclass instance appropriate for marker at *offset*
    in *stream* having *marker_code*.
    """
    if marker_code == JPEG_MARKER_CODE.APP0:
        marker_cls = _App0Marker
    elif marker_code == JPEG_MARKER_CODE.APP1:
        marker_cls = _App1Marker
    elif marker_code in JPEG_MARKER_CODE.SOF_MARKER_CODES:
        marker_cls = _SofMarker
    else:
        marker_cls = _Marker
    return marker_cls.from_stream(stream, marker_code, offset)


class _Marker(object):
    """
    Base class for JFIF marker classes. Represents a marker and its segment
    occuring in a JPEG byte stream.
    """
    def __init__(self, marker_code, offset, segment_length):
        super(_Marker, self).__init__()
        self._marker_code = marker_code
        self._offset = offset
        self._segment_length = segment_length

    @classmethod
    def from_stream(cls, stream, marker_code, offset):
        """
        Return a generic |_Marker| instance for the marker at *offset* in
        *stream* having *marker_code*.
        """
        if JPEG_MARKER_CODE.is_standalone(marker_code):
            segment_length = 0
        else:
            segment_length = stream.read_short(offset)
        return cls(marker_code, offset, segment_length)

    @property
    def marker_code(self):
        """
        The single-byte code that identifies the type of this marker, e.g.
        ``'\xE0'`` for start of image (SOI).
        """
        return self._marker_code

    @property
    def name(self):  # pragma: no cover
        return JPEG_MARKER_CODE.marker_names[self._marker_code]

    @property
    def offset(self):  # pragma: no cover
        return self._offset

    @property
    def segment_length(self):
        """
        The length in bytes of this marker's segment
        """
        return self._segment_length


class _App0Marker(_Marker):
    """
    Represents a JFIF APP0 marker segment.
    """
    def __init__(
            self, marker_code, offset, length, density_units, x_density,
            y_density):
        super(_App0Marker, self).__init__(marker_code, offset, length)
        self._density_units = density_units
        self._x_density = x_density
        self._y_density = y_density

    @property
    def horz_dpi(self):
        """
        Horizontal dots per inch specified in this marker, defaults to 72 if
        not specified.
        """
        return self._dpi(self._x_density)

    @property
    def vert_dpi(self):
        """
        Vertical dots per inch specified in this marker, defaults to 72 if
        not specified.
        """
        return self._dpi(self._y_density)

    def _dpi(self, density):
        """
        Return dots per inch corresponding to *density* value.
        """
        if self._density_units == 1:
            dpi = density
        elif self._density_units == 2:
            dpi = int(round(density * 2.54))
        else:
            dpi = 72
        return dpi

    @classmethod
    def from_stream(cls, stream, marker_code, offset):
        """
        Return an |_App0Marker| instance for the APP0 marker at *offset* in
        *stream*.
        """
        # field               off  type   notes
        # ------------------  ---  -----  -------------------
        # segment length       0   short
        # JFIF identifier      2   5 chr  'JFIF\x00'
        # major JPEG version   7   byte   typically 1
        # minor JPEG version   8   byte   typically 1 or 2
        # density units        9   byte   1=inches, 2=cm
        # horz dots per unit  10   short
        # vert dots per unit  12   short
        # ------------------  ---  -----  -------------------
        segment_length = stream.read_short(offset)
        density_units = stream.read_byte(offset, 9)
        x_density = stream.read_short(offset, 10)
        y_density = stream.read_short(offset, 12)
        return cls(
            marker_code, offset, segment_length, density_units, x_density,
            y_density
        )


class _App1Marker(_Marker):
    """
    Represents a JFIF APP1 (Exif) marker segment.
    """
    def __init__(self, marker_code, offset, length, horz_dpi, vert_dpi):
        super(_App1Marker, self).__init__(marker_code, offset, length)
        self._horz_dpi = horz_dpi
        self._vert_dpi = vert_dpi

    @classmethod
    def from_stream(cls, stream, marker_code, offset):
        """
        Extract the horizontal and vertical dots-per-inch value from the APP1
        header at *offset* in *stream*.
        """
        # field                 off  len  type   notes
        # --------------------  ---  ---  -----  ----------------------------
        # segment length         0    2   short
        # Exif identifier        2    6   6 chr  'Exif\x00\x00'
        # TIFF byte order        8    2   2 chr  'II'=little 'MM'=big endian
        # meaning of universe   10    2   2 chr  '*\x00' or '\x00*' depending
        # IFD0 off fr/II or MM  10   16   long   relative to ...?
        # --------------------  ---  ---  -----  ----------------------------
        segment_length = stream.read_short(offset)
        if cls._is_non_Exif_APP1_segment(stream, offset):
            return cls(marker_code, offset, segment_length, 72, 72)
        tiff = cls._tiff_from_exif_segment(stream, offset, segment_length)
        return cls(
            marker_code, offset, segment_length, tiff.horz_dpi, tiff.vert_dpi
        )

    @property
    def horz_dpi(self):
        """
        Horizontal dots per inch specified in this marker, defaults to 72 if
        not specified.
        """
        return self._horz_dpi

    @property
    def vert_dpi(self):
        """
        Vertical dots per inch specified in this marker, defaults to 72 if
        not specified.
        """
        return self._vert_dpi

    @classmethod
    def _is_non_Exif_APP1_segment(cls, stream, offset):
        """
        Return True if the APP1 segment at *offset* in *stream* is NOT an
        Exif segment, as determined by the ``'Exif\x00\x00'`` signature at
        offset 2 in the segment.
        """
        stream.seek(offset+2)
        exif_signature = stream.read(6)
        return exif_signature != b'Exif\x00\x00'

    @classmethod
    def _tiff_from_exif_segment(cls, stream, offset, segment_length):
        """
        Return a |Tiff| instance parsed from the Exif APP1 segment of
        *segment_length* at *offset* in *stream*.
        """
        # wrap full segment in its own stream and feed to Tiff()
        stream.seek(offset+8)
        segment_bytes = stream.read(segment_length-8)
        substream = BytesIO(segment_bytes)
        return Tiff.from_stream(substream)


class _SofMarker(_Marker):
    """
    Represents a JFIF start of frame (SOFx) marker segment.
    """
    def __init__(
            self, marker_code, offset, segment_length, px_width, px_height):
        super(_SofMarker, self).__init__(marker_code, offset, segment_length)
        self._px_width = px_width
        self._px_height = px_height

    @classmethod
    def from_stream(cls, stream, marker_code, offset):
        """
        Return an |_SofMarker| instance for the SOFn marker at *offset* in
        stream.
        """
        # field                 off  type   notes
        # ------------------  ---  -----  ----------------------------
        # segment length       0   short
        # Data precision       2   byte
        # Vertical lines       3   short  px_height
        # Horizontal lines     5   short  px_width
        # ------------------  ---  -----  ----------------------------
        segment_length = stream.read_short(offset)
        px_height = stream.read_short(offset, 3)
        px_width = stream.read_short(offset, 5)
        return cls(marker_code, offset, segment_length, px_width, px_height)

    @property
    def px_height(self):
        """
        Image height in pixels
        """
        return self._px_height

    @property
    def px_width(self):
        """
        Image width in pixels
        """
        return self._px_width

########NEW FILE########
__FILENAME__ = png
# encoding: utf-8

from __future__ import absolute_import, division, print_function

from .constants import MIME_TYPE, PNG_CHUNK_TYPE
from .exceptions import InvalidImageStreamError
from .helpers import BIG_ENDIAN, StreamReader
from .image import BaseImageHeader


class Png(BaseImageHeader):
    """
    Image header parser for PNG images
    """
    @property
    def content_type(self):
        """
        MIME content type for this image, unconditionally `image/png` for
        PNG images.
        """
        return MIME_TYPE.PNG

    @property
    def default_ext(self):
        """
        Default filename extension, always 'png' for PNG images.
        """
        return 'png'

    @classmethod
    def from_stream(cls, stream):
        """
        Return a |Png| instance having header properties parsed from image in
        *stream*.
        """
        parser = _PngParser.parse(stream)

        px_width = parser.px_width
        px_height = parser.px_height
        horz_dpi = parser.horz_dpi
        vert_dpi = parser.vert_dpi

        return cls(px_width, px_height, horz_dpi, vert_dpi)


class _PngParser(object):
    """
    Parses a PNG image stream to extract the image properties found in its
    chunks.
    """
    def __init__(self, chunks):
        super(_PngParser, self).__init__()
        self._chunks = chunks

    @classmethod
    def parse(cls, stream):
        """
        Return a |_PngParser| instance containing the header properties
        parsed from the PNG image in *stream*.
        """
        chunks = _Chunks.from_stream(stream)
        return cls(chunks)

    @property
    def px_width(self):
        """
        The number of pixels in each row of the image.
        """
        IHDR = self._chunks.IHDR
        return IHDR.px_width

    @property
    def px_height(self):
        """
        The number of stacked rows of pixels in the image.
        """
        IHDR = self._chunks.IHDR
        return IHDR.px_height

    @property
    def horz_dpi(self):
        """
        Integer dots per inch for the width of this image. Defaults to 72
        when not present in the file, as is often the case.
        """
        pHYs = self._chunks.pHYs
        if pHYs is None:
            return 72
        return self._dpi(pHYs.units_specifier, pHYs.horz_px_per_unit)

    @property
    def vert_dpi(self):
        """
        Integer dots per inch for the height of this image. Defaults to 72
        when not present in the file, as is often the case.
        """
        pHYs = self._chunks.pHYs
        if pHYs is None:
            return 72
        return self._dpi(pHYs.units_specifier, pHYs.vert_px_per_unit)

    @staticmethod
    def _dpi(units_specifier, px_per_unit):
        """
        Return dots per inch value calculated from *units_specifier* and
        *px_per_unit*.
        """
        if units_specifier == 1 and px_per_unit:
            return int(round(px_per_unit * 0.0254))
        return 72


class _Chunks(object):
    """
    Collection of the chunks parsed from a PNG image stream
    """
    def __init__(self, chunk_iterable):
        super(_Chunks, self).__init__()
        self._chunks = list(chunk_iterable)

    @classmethod
    def from_stream(cls, stream):
        """
        Return a |_Chunks| instance containing the PNG chunks in *stream*.
        """
        chunk_parser = _ChunkParser.from_stream(stream)
        chunks = [chunk for chunk in chunk_parser.iter_chunks()]
        return cls(chunks)

    @property
    def IHDR(self):
        """
        IHDR chunk in PNG image
        """
        match = lambda chunk: chunk.type_name == PNG_CHUNK_TYPE.IHDR
        IHDR = self._find_first(match)
        if IHDR is None:
            raise InvalidImageStreamError('no IHDR chunk in PNG image')
        return IHDR

    @property
    def pHYs(self):
        """
        pHYs chunk in PNG image, or |None| if not present
        """
        match = lambda chunk: chunk.type_name == PNG_CHUNK_TYPE.pHYs
        return self._find_first(match)

    def _find_first(self, match):
        """
        Return first chunk in stream order returning True for function
        *match*.
        """
        for chunk in self._chunks:
            if match(chunk):
                return chunk
        return None


class _ChunkParser(object):
    """
    Extracts chunks from a PNG image stream
    """
    def __init__(self, stream_rdr):
        super(_ChunkParser, self).__init__()
        self._stream_rdr = stream_rdr

    @classmethod
    def from_stream(cls, stream):
        """
        Return a |_ChunkParser| instance that can extract the chunks from the
        PNG image in *stream*.
        """
        stream_rdr = StreamReader(stream, BIG_ENDIAN)
        return cls(stream_rdr)

    def iter_chunks(self):
        """
        Generate a |_Chunk| subclass instance for each chunk in this parser's
        PNG stream, in the order encountered in the stream.
        """
        for chunk_type, offset in self._iter_chunk_offsets():
            chunk = _ChunkFactory(chunk_type, self._stream_rdr, offset)
            yield chunk

    def _iter_chunk_offsets(self):
        """
        Generate a (chunk_type, chunk_offset) 2-tuple for each of the chunks
        in the PNG image stream. Iteration stops after the IEND chunk is
        returned.
        """
        chunk_offset = 8
        while True:
            chunk_data_len = self._stream_rdr.read_long(chunk_offset)
            chunk_type = self._stream_rdr.read_str(4, chunk_offset, 4)
            data_offset = chunk_offset + 8
            yield chunk_type, data_offset
            if chunk_type == 'IEND':
                break
            # incr offset for chunk len long, chunk type, chunk data, and CRC
            chunk_offset += (4 + 4 + chunk_data_len + 4)


def _ChunkFactory(chunk_type, stream_rdr, offset):
    """
    Return a |_Chunk| subclass instance appropriate to *chunk_type* parsed
    from *stream_rdr* at *offset*.
    """
    chunk_cls_map = {
        PNG_CHUNK_TYPE.IHDR: _IHDRChunk,
        PNG_CHUNK_TYPE.pHYs: _pHYsChunk,
    }
    chunk_cls = chunk_cls_map.get(chunk_type, _Chunk)
    return chunk_cls.from_offset(chunk_type, stream_rdr, offset)


class _Chunk(object):
    """
    Base class for specific chunk types. Also serves as the default chunk
    type.
    """
    def __init__(self, chunk_type):
        super(_Chunk, self).__init__()
        self._chunk_type = chunk_type

    @classmethod
    def from_offset(cls, chunk_type, stream_rdr, offset):
        """
        Return a default _Chunk instance that only knows its chunk type.
        """
        return cls(chunk_type)

    @property
    def type_name(self):
        """
        The chunk type name, e.g. 'IHDR', 'pHYs', etc.
        """
        return self._chunk_type


class _IHDRChunk(_Chunk):
    """
    IHDR chunk, contains the image dimensions
    """
    def __init__(self, chunk_type, px_width, px_height):
        super(_IHDRChunk, self).__init__(chunk_type)
        self._px_width = px_width
        self._px_height = px_height

    @classmethod
    def from_offset(cls, chunk_type, stream_rdr, offset):
        """
        Return an _IHDRChunk instance containing the image dimensions
        extracted from the IHDR chunk in *stream* at *offset*.
        """
        px_width = stream_rdr.read_long(offset)
        px_height = stream_rdr.read_long(offset, 4)
        return cls(chunk_type, px_width, px_height)

    @property
    def px_width(self):
        return self._px_width

    @property
    def px_height(self):
        return self._px_height


class _pHYsChunk(_Chunk):
    """
    pYHs chunk, contains the image dpi information
    """
    def __init__(self, chunk_type, horz_px_per_unit, vert_px_per_unit,
                 units_specifier):
        super(_pHYsChunk, self).__init__(chunk_type)
        self._horz_px_per_unit = horz_px_per_unit
        self._vert_px_per_unit = vert_px_per_unit
        self._units_specifier = units_specifier

    @classmethod
    def from_offset(cls, chunk_type, stream_rdr, offset):
        """
        Return a _pHYsChunk instance containing the image resolution
        extracted from the pHYs chunk in *stream* at *offset*.
        """
        horz_px_per_unit = stream_rdr.read_long(offset)
        vert_px_per_unit = stream_rdr.read_long(offset, 4)
        units_specifier = stream_rdr.read_byte(offset, 8)
        return cls(
            chunk_type, horz_px_per_unit, vert_px_per_unit, units_specifier
        )

    @property
    def horz_px_per_unit(self):
        return self._horz_px_per_unit

    @property
    def vert_px_per_unit(self):
        return self._vert_px_per_unit

    @property
    def units_specifier(self):
        return self._units_specifier

########NEW FILE########
__FILENAME__ = tiff
# encoding: utf-8

from __future__ import absolute_import, division, print_function

from .constants import MIME_TYPE, TIFF_FLD, TIFF_TAG
from .helpers import BIG_ENDIAN, LITTLE_ENDIAN, StreamReader
from .image import BaseImageHeader


class Tiff(BaseImageHeader):
    """
    Image header parser for TIFF images. Handles both big and little endian
    byte ordering.
    """
    @property
    def content_type(self):
        """
        Return the MIME type of this TIFF image, unconditionally the string
        ``image/tiff``.
        """
        return MIME_TYPE.TIFF

    @property
    def default_ext(self):
        """
        Default filename extension, always 'tiff' for TIFF images.
        """
        return 'tiff'

    @classmethod
    def from_stream(cls, stream):
        """
        Return a |Tiff| instance containing the properties of the TIFF image
        in *stream*.
        """
        parser = _TiffParser.parse(stream)

        px_width = parser.px_width
        px_height = parser.px_height
        horz_dpi = parser.horz_dpi
        vert_dpi = parser.vert_dpi

        return cls(px_width, px_height, horz_dpi, vert_dpi)


class _TiffParser(object):
    """
    Parses a TIFF image stream to extract the image properties found in its
    main image file directory (IFD)
    """
    def __init__(self, ifd_entries):
        super(_TiffParser, self).__init__()
        self._ifd_entries = ifd_entries

    @classmethod
    def parse(cls, stream):
        """
        Return an instance of |_TiffParser| containing the properties parsed
        from the TIFF image in *stream*.
        """
        stream_rdr = cls._make_stream_reader(stream)
        ifd0_offset = stream_rdr.read_long(4)
        ifd_entries = _IfdEntries.from_stream(stream_rdr, ifd0_offset)
        return cls(ifd_entries)

    @property
    def horz_dpi(self):
        """
        The horizontal dots per inch value calculated from the XResolution
        and ResolutionUnit tags of the IFD; defaults to 72 if those tags are
        not present.
        """
        return self._dpi(TIFF_TAG.X_RESOLUTION)

    @property
    def vert_dpi(self):
        """
        The vertical dots per inch value calculated from the XResolution and
        ResolutionUnit tags of the IFD; defaults to 72 if those tags are not
        present.
        """
        return self._dpi(TIFF_TAG.Y_RESOLUTION)

    @property
    def px_height(self):
        """
        The number of stacked rows of pixels in the image, |None| if the IFD
        contains no ``ImageLength`` tag, the expected case when the TIFF is
        embeded in an Exif image.
        """
        return self._ifd_entries.get(TIFF_TAG.IMAGE_LENGTH)

    @property
    def px_width(self):
        """
        The number of pixels in each row in the image, |None| if the IFD
        contains no ``ImageWidth`` tag, the expected case when the TIFF is
        embeded in an Exif image.
        """
        return self._ifd_entries.get(TIFF_TAG.IMAGE_WIDTH)

    @classmethod
    def _detect_endian(cls, stream):
        """
        Return either BIG_ENDIAN or LITTLE_ENDIAN depending on the endian
        indicator found in the TIFF *stream* header, either 'MM' or 'II'.
        """
        stream.seek(0)
        endian_str = stream.read(2)
        return BIG_ENDIAN if endian_str == b'MM' else LITTLE_ENDIAN

    def _dpi(self, resolution_tag):
        """
        Return the dpi value calculated for *resolution_tag*, which can be
        either TIFF_TAG.X_RESOLUTION or TIFF_TAG.Y_RESOLUTION. The
        calculation is based on the values of both that tag and the
        TIFF_TAG.RESOLUTION_UNIT tag in this parser's |_IfdEntries| instance.
        """
        if resolution_tag not in self._ifd_entries:
            return 72
        resolution_unit = self._ifd_entries[TIFF_TAG.RESOLUTION_UNIT]
        if resolution_unit == 1:  # aspect ratio only
            return 72
        # resolution_unit == 2 for inches, 3 for centimeters
        units_per_inch = 1 if resolution_unit == 2 else 2.54
        dots_per_unit = self._ifd_entries[resolution_tag]
        return int(round(dots_per_unit * units_per_inch))

    @classmethod
    def _make_stream_reader(cls, stream):
        """
        Return a |StreamReader| instance with wrapping *stream* and having
        "endian-ness" determined by the 'MM' or 'II' indicator in the TIFF
        stream header.
        """
        endian = cls._detect_endian(stream)
        return StreamReader(stream, endian)


class _IfdEntries(object):
    """
    Image File Directory for a TIFF image, having mapping (dict) semantics
    allowing "tag" values to be retrieved by tag code.
    """
    def __init__(self, entries):
        super(_IfdEntries, self).__init__()
        self._entries = entries

    def __contains__(self, key):
        """
        Provides ``in`` operator, e.g. ``tag in ifd_entries``
        """
        return self._entries.__contains__(key)

    def __getitem__(self, key):
        """
        Provides indexed access, e.g. ``tag_value = ifd_entries[tag_code]``
        """
        return self._entries.__getitem__(key)

    @classmethod
    def from_stream(cls, stream, offset):
        """
        Return a new |_IfdEntries| instance parsed from *stream* starting at
        *offset*.
        """
        ifd_parser = _IfdParser(stream, offset)
        entries = dict((e.tag, e.value) for e in ifd_parser.iter_entries())
        return cls(entries)

    def get(self, tag_code, default=None):
        """
        Return value of IFD entry having tag matching *tag_code*, or
        *default* if no matching tag found.
        """
        return self._entries.get(tag_code, default)


class _IfdParser(object):
    """
    Service object that knows how to extract directory entries from an Image
    File Directory (IFD)
    """
    def __init__(self, stream_rdr, offset):
        super(_IfdParser, self).__init__()
        self._stream_rdr = stream_rdr
        self._offset = offset

    def iter_entries(self):
        """
        Generate an |_IfdEntry| instance corresponding to each entry in the
        directory.
        """
        for idx in range(self._entry_count):
            dir_entry_offset = self._offset + 2 + (idx*12)
            ifd_entry = _IfdEntryFactory(self._stream_rdr, dir_entry_offset)
            yield ifd_entry

    @property
    def _entry_count(self):
        """
        The count of directory entries, read from the top of the IFD header
        """
        return self._stream_rdr.read_short(self._offset)


def _IfdEntryFactory(stream_rdr, offset):
    """
    Return an |_IfdEntry| subclass instance containing the value of the
    directory entry at *offset* in *stream_rdr*.
    """
    ifd_entry_classes = {
        TIFF_FLD.ASCII:    _AsciiIfdEntry,
        TIFF_FLD.SHORT:    _ShortIfdEntry,
        TIFF_FLD.LONG:     _LongIfdEntry,
        TIFF_FLD.RATIONAL: _RationalIfdEntry,
    }
    field_type = stream_rdr.read_short(offset, 2)
    if field_type in ifd_entry_classes:
        entry_cls = ifd_entry_classes[field_type]
    else:
        entry_cls = _IfdEntry
    return entry_cls.from_stream(stream_rdr, offset)


class _IfdEntry(object):
    """
    Base class for IFD entry classes. Subclasses are differentiated by value
    type, e.g. ASCII, long int, etc.
    """
    def __init__(self, tag_code, value):
        super(_IfdEntry, self).__init__()
        self._tag_code = tag_code
        self._value = value

    @classmethod
    def from_stream(cls, stream_rdr, offset):
        """
        Return an |_IfdEntry| subclass instance containing the tag and value
        of the tag parsed from *stream_rdr* at *offset*. Note this method is
        common to all subclasses. Override the ``_parse_value()`` method to
        provide distinctive behavior based on field type.
        """
        tag_code = stream_rdr.read_short(offset, 0)
        value_count = stream_rdr.read_long(offset, 4)
        value_offset = stream_rdr.read_long(offset, 8)
        value = cls._parse_value(
            stream_rdr, offset, value_count, value_offset
        )
        return cls(tag_code, value)

    @classmethod
    def _parse_value(cls, stream_rdr, offset, value_count, value_offset):
        """
        Return the value of this field parsed from *stream_rdr* at *offset*.
        Intended to be overridden by subclasses.
        """
        return 'UNIMPLEMENTED FIELD TYPE'  # pragma: no cover

    @property
    def tag(self):
        """
        Short int code that identifies this IFD entry
        """
        return self._tag_code

    @property
    def value(self):
        """
        Value of this tag, its type being dependent on the tag.
        """
        return self._value


class _AsciiIfdEntry(_IfdEntry):
    """
    IFD entry having the form of a NULL-terminated ASCII string
    """
    @classmethod
    def _parse_value(cls, stream_rdr, offset, value_count, value_offset):
        """
        Return the ASCII string parsed from *stream_rdr* at *value_offset*.
        The length of the string, including a terminating '\x00' (NUL)
        character, is in *value_count*.
        """
        return stream_rdr.read_str(value_count-1, value_offset)


class _ShortIfdEntry(_IfdEntry):
    """
    IFD entry expressed as a short (2-byte) integer
    """
    @classmethod
    def _parse_value(cls, stream_rdr, offset, value_count, value_offset):
        """
        Return the short int value contained in the *value_offset* field of
        this entry. Only supports single values at present.
        """
        if value_count == 1:
            return stream_rdr.read_short(offset, 8)
        else:  # pragma: no cover
            return 'Multi-value short integer NOT IMPLEMENTED'


class _LongIfdEntry(_IfdEntry):
    """
    IFD entry expressed as a long (4-byte) integer
    """
    @classmethod
    def _parse_value(cls, stream_rdr, offset, value_count, value_offset):
        """
        Return the long int value contained in the *value_offset* field of
        this entry. Only supports single values at present.
        """
        if value_count == 1:
            return stream_rdr.read_long(offset, 8)
        else:  # pragma: no cover
            return 'Multi-value long integer NOT IMPLEMENTED'


class _RationalIfdEntry(_IfdEntry):
    """
    IFD entry expressed as a numerator, denominator pair
    """
    @classmethod
    def _parse_value(cls, stream_rdr, offset, value_count, value_offset):
        """
        Return the rational (numerator / denominator) value at *value_offset*
        in *stream_rdr* as a floating-point number. Only supports single
        values at present.
        """
        if value_count == 1:
            numerator = stream_rdr.read_long(value_offset)
            denominator = stream_rdr.read_long(value_offset, 4)
            return numerator / denominator
        else:  # pragma: no cover
            return 'Multi-value Rational NOT IMPLEMENTED'

########NEW FILE########
__FILENAME__ = compat
# encoding: utf-8

"""
Provides Python 2/3 compatibility objects
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

import sys

# ===========================================================================
# Python 3 versions
# ===========================================================================

if sys.version_info >= (3, 0):

    def cls_method_fn(cls, method_name):
        """
        Return the function object associated with the method of *cls* having
        *method_name*.
        """
        return getattr(cls, method_name)

    def is_string(obj):
        """
        Return True if *obj* is a string, False otherwise.
        """
        return isinstance(obj, str)

# ===========================================================================
# Python 2 versions
# ===========================================================================

else:

    def cls_method_fn(cls, method_name):
        """
        Return the function object associated with the method of *cls* having
        *method_name*.
        """
        unbound_method = getattr(cls, method_name)
        return unbound_method.__func__

    def is_string(obj):
        """
        Return True if *obj* is a string, False otherwise.
        """
        return isinstance(obj, basestring)

########NEW FILE########
__FILENAME__ = constants
# encoding: utf-8

"""
Constant values related to the Open Packaging Convention, in particular,
content types and relationship types.
"""


class CONTENT_TYPE(object):
    """
    Content type URIs (like MIME-types) that specify a part's format
    """
    BMP = (
        'image/bmp'
    )
    DML_CHART = (
        'application/vnd.openxmlformats-officedocument.drawingml.chart+xml'
    )
    DML_CHARTSHAPES = (
        'application/vnd.openxmlformats-officedocument.drawingml.chartshapes'
        '+xml'
    )
    DML_DIAGRAM_COLORS = (
        'application/vnd.openxmlformats-officedocument.drawingml.diagramColo'
        'rs+xml'
    )
    DML_DIAGRAM_DATA = (
        'application/vnd.openxmlformats-officedocument.drawingml.diagramData'
        '+xml'
    )
    DML_DIAGRAM_LAYOUT = (
        'application/vnd.openxmlformats-officedocument.drawingml.diagramLayo'
        'ut+xml'
    )
    DML_DIAGRAM_STYLE = (
        'application/vnd.openxmlformats-officedocument.drawingml.diagramStyl'
        'e+xml'
    )
    GIF = (
        'image/gif'
    )
    JPEG = (
        'image/jpeg'
    )
    MS_PHOTO = (
        'image/vnd.ms-photo'
    )
    OFC_CUSTOM_PROPERTIES = (
        'application/vnd.openxmlformats-officedocument.custom-properties+xml'
    )
    OFC_CUSTOM_XML_PROPERTIES = (
        'application/vnd.openxmlformats-officedocument.customXmlProperties+x'
        'ml'
    )
    OFC_DRAWING = (
        'application/vnd.openxmlformats-officedocument.drawing+xml'
    )
    OFC_EXTENDED_PROPERTIES = (
        'application/vnd.openxmlformats-officedocument.extended-properties+x'
        'ml'
    )
    OFC_OLE_OBJECT = (
        'application/vnd.openxmlformats-officedocument.oleObject'
    )
    OFC_PACKAGE = (
        'application/vnd.openxmlformats-officedocument.package'
    )
    OFC_THEME = (
        'application/vnd.openxmlformats-officedocument.theme+xml'
    )
    OFC_THEME_OVERRIDE = (
        'application/vnd.openxmlformats-officedocument.themeOverride+xml'
    )
    OFC_VML_DRAWING = (
        'application/vnd.openxmlformats-officedocument.vmlDrawing'
    )
    OPC_CORE_PROPERTIES = (
        'application/vnd.openxmlformats-package.core-properties+xml'
    )
    OPC_DIGITAL_SIGNATURE_CERTIFICATE = (
        'application/vnd.openxmlformats-package.digital-signature-certificat'
        'e'
    )
    OPC_DIGITAL_SIGNATURE_ORIGIN = (
        'application/vnd.openxmlformats-package.digital-signature-origin'
    )
    OPC_DIGITAL_SIGNATURE_XMLSIGNATURE = (
        'application/vnd.openxmlformats-package.digital-signature-xmlsignatu'
        're+xml'
    )
    OPC_RELATIONSHIPS = (
        'application/vnd.openxmlformats-package.relationships+xml'
    )
    PML_COMMENTS = (
        'application/vnd.openxmlformats-officedocument.presentationml.commen'
        'ts+xml'
    )
    PML_COMMENT_AUTHORS = (
        'application/vnd.openxmlformats-officedocument.presentationml.commen'
        'tAuthors+xml'
    )
    PML_HANDOUT_MASTER = (
        'application/vnd.openxmlformats-officedocument.presentationml.handou'
        'tMaster+xml'
    )
    PML_NOTES_MASTER = (
        'application/vnd.openxmlformats-officedocument.presentationml.notesM'
        'aster+xml'
    )
    PML_NOTES_SLIDE = (
        'application/vnd.openxmlformats-officedocument.presentationml.notesS'
        'lide+xml'
    )
    PML_PRESENTATION_MAIN = (
        'application/vnd.openxmlformats-officedocument.presentationml.presen'
        'tation.main+xml'
    )
    PML_PRES_PROPS = (
        'application/vnd.openxmlformats-officedocument.presentationml.presPr'
        'ops+xml'
    )
    PML_PRINTER_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.presentationml.printe'
        'rSettings'
    )
    PML_SLIDE = (
        'application/vnd.openxmlformats-officedocument.presentationml.slide+'
        'xml'
    )
    PML_SLIDESHOW_MAIN = (
        'application/vnd.openxmlformats-officedocument.presentationml.slides'
        'how.main+xml'
    )
    PML_SLIDE_LAYOUT = (
        'application/vnd.openxmlformats-officedocument.presentationml.slideL'
        'ayout+xml'
    )
    PML_SLIDE_MASTER = (
        'application/vnd.openxmlformats-officedocument.presentationml.slideM'
        'aster+xml'
    )
    PML_SLIDE_UPDATE_INFO = (
        'application/vnd.openxmlformats-officedocument.presentationml.slideU'
        'pdateInfo+xml'
    )
    PML_TABLE_STYLES = (
        'application/vnd.openxmlformats-officedocument.presentationml.tableS'
        'tyles+xml'
    )
    PML_TAGS = (
        'application/vnd.openxmlformats-officedocument.presentationml.tags+x'
        'ml'
    )
    PML_TEMPLATE_MAIN = (
        'application/vnd.openxmlformats-officedocument.presentationml.templa'
        'te.main+xml'
    )
    PML_VIEW_PROPS = (
        'application/vnd.openxmlformats-officedocument.presentationml.viewPr'
        'ops+xml'
    )
    PNG = (
        'image/png'
    )
    SML_CALC_CHAIN = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.calcCha'
        'in+xml'
    )
    SML_CHARTSHEET = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.chartsh'
        'eet+xml'
    )
    SML_COMMENTS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.comment'
        's+xml'
    )
    SML_CONNECTIONS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.connect'
        'ions+xml'
    )
    SML_CUSTOM_PROPERTY = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.customP'
        'roperty'
    )
    SML_DIALOGSHEET = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.dialogs'
        'heet+xml'
    )
    SML_EXTERNAL_LINK = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.externa'
        'lLink+xml'
    )
    SML_PIVOT_CACHE_DEFINITION = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCa'
        'cheDefinition+xml'
    )
    SML_PIVOT_CACHE_RECORDS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCa'
        'cheRecords+xml'
    )
    SML_PIVOT_TABLE = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTa'
        'ble+xml'
    )
    SML_PRINTER_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.printer'
        'Settings'
    )
    SML_QUERY_TABLE = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.queryTa'
        'ble+xml'
    )
    SML_REVISION_HEADERS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.revisio'
        'nHeaders+xml'
    )
    SML_REVISION_LOG = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.revisio'
        'nLog+xml'
    )
    SML_SHARED_STRINGS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedS'
        'trings+xml'
    )
    SML_SHEET = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    SML_SHEET_MAIN = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.m'
        'ain+xml'
    )
    SML_SHEET_METADATA = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMe'
        'tadata+xml'
    )
    SML_STYLES = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+'
        'xml'
    )
    SML_TABLE = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.table+x'
        'ml'
    )
    SML_TABLE_SINGLE_CELLS = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.tableSi'
        'ngleCells+xml'
    )
    SML_TEMPLATE_MAIN = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.templat'
        'e.main+xml'
    )
    SML_USER_NAMES = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.userNam'
        'es+xml'
    )
    SML_VOLATILE_DEPENDENCIES = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.volatil'
        'eDependencies+xml'
    )
    SML_WORKSHEET = (
        'application/vnd.openxmlformats-officedocument.spreadsheetml.workshe'
        'et+xml'
    )
    TIFF = (
        'image/tiff'
    )
    WML_COMMENTS = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.comm'
        'ents+xml'
    )
    WML_DOCUMENT_GLOSSARY = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.docu'
        'ment.glossary+xml'
    )
    WML_DOCUMENT_MAIN = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.docu'
        'ment.main+xml'
    )
    WML_ENDNOTES = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.endn'
        'otes+xml'
    )
    WML_FONT_TABLE = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.font'
        'Table+xml'
    )
    WML_FOOTER = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.foot'
        'er+xml'
    )
    WML_FOOTNOTES = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.foot'
        'notes+xml'
    )
    WML_HEADER = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.head'
        'er+xml'
    )
    WML_NUMBERING = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.numb'
        'ering+xml'
    )
    WML_PRINTER_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.prin'
        'terSettings'
    )
    WML_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.sett'
        'ings+xml'
    )
    WML_STYLES = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.styl'
        'es+xml'
    )
    WML_WEB_SETTINGS = (
        'application/vnd.openxmlformats-officedocument.wordprocessingml.webS'
        'ettings+xml'
    )
    XML = (
        'application/xml'
    )
    X_EMF = (
        'image/x-emf'
    )
    X_FONTDATA = (
        'application/x-fontdata'
    )
    X_FONT_TTF = (
        'application/x-font-ttf'
    )
    X_WMF = (
        'image/x-wmf'
    )


class NAMESPACE(object):
    """Constant values for OPC XML namespaces"""
    DML_WORDPROCESSING_DRAWING = (
        'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDraw'
        'ing'
    )
    OFC_RELATIONSHIPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
    )
    OPC_RELATIONSHIPS = (
        'http://schemas.openxmlformats.org/package/2006/relationships'
    )
    OPC_CONTENT_TYPES = (
        'http://schemas.openxmlformats.org/package/2006/content-types'
    )
    WML_MAIN = (
        'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    )


class RELATIONSHIP_TARGET_MODE(object):
    """Open XML relationship target modes"""
    EXTERNAL = 'External'
    INTERNAL = 'Internal'


class RELATIONSHIP_TYPE(object):
    AUDIO = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/audio'
    )
    A_F_CHUNK = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/aFChunk'
    )
    CALC_CHAIN = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/calcChain'
    )
    CERTIFICATE = (
        'http://schemas.openxmlformats.org/package/2006/relationships/digita'
        'l-signature/certificate'
    )
    CHART = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/chart'
    )
    CHARTSHEET = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/chartsheet'
    )
    CHART_USER_SHAPES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/chartUserShapes'
    )
    COMMENTS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/comments'
    )
    COMMENT_AUTHORS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/commentAuthors'
    )
    CONNECTIONS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/connections'
    )
    CONTROL = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/control'
    )
    CORE_PROPERTIES = (
        'http://schemas.openxmlformats.org/package/2006/relationships/metada'
        'ta/core-properties'
    )
    CUSTOM_PROPERTIES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/custom-properties'
    )
    CUSTOM_PROPERTY = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/customProperty'
    )
    CUSTOM_XML = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/customXml'
    )
    CUSTOM_XML_PROPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/customXmlProps'
    )
    DIAGRAM_COLORS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/diagramColors'
    )
    DIAGRAM_DATA = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/diagramData'
    )
    DIAGRAM_LAYOUT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/diagramLayout'
    )
    DIAGRAM_QUICK_STYLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/diagramQuickStyle'
    )
    DIALOGSHEET = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/dialogsheet'
    )
    DRAWING = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/drawing'
    )
    ENDNOTES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/endnotes'
    )
    EXTENDED_PROPERTIES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/extended-properties'
    )
    EXTERNAL_LINK = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/externalLink'
    )
    FONT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/font'
    )
    FONT_TABLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/fontTable'
    )
    FOOTER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/footer'
    )
    FOOTNOTES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/footnotes'
    )
    GLOSSARY_DOCUMENT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/glossaryDocument'
    )
    HANDOUT_MASTER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/handoutMaster'
    )
    HEADER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/header'
    )
    HYPERLINK = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/hyperlink'
    )
    IMAGE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/image'
    )
    NOTES_MASTER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/notesMaster'
    )
    NOTES_SLIDE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/notesSlide'
    )
    NUMBERING = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/numbering'
    )
    OFFICE_DOCUMENT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/officeDocument'
    )
    OLE_OBJECT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/oleObject'
    )
    ORIGIN = (
        'http://schemas.openxmlformats.org/package/2006/relationships/digita'
        'l-signature/origin'
    )
    PACKAGE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/package'
    )
    PIVOT_CACHE_DEFINITION = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/pivotCacheDefinition'
    )
    PIVOT_CACHE_RECORDS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/spreadsheetml/pivotCacheRecords'
    )
    PIVOT_TABLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/pivotTable'
    )
    PRES_PROPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/presProps'
    )
    PRINTER_SETTINGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/printerSettings'
    )
    QUERY_TABLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/queryTable'
    )
    REVISION_HEADERS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/revisionHeaders'
    )
    REVISION_LOG = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/revisionLog'
    )
    SETTINGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/settings'
    )
    SHARED_STRINGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/sharedStrings'
    )
    SHEET_METADATA = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/sheetMetadata'
    )
    SIGNATURE = (
        'http://schemas.openxmlformats.org/package/2006/relationships/digita'
        'l-signature/signature'
    )
    SLIDE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/slide'
    )
    SLIDE_LAYOUT = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/slideLayout'
    )
    SLIDE_MASTER = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/slideMaster'
    )
    SLIDE_UPDATE_INFO = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/slideUpdateInfo'
    )
    STYLES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/styles'
    )
    TABLE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/table'
    )
    TABLE_SINGLE_CELLS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/tableSingleCells'
    )
    TABLE_STYLES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/tableStyles'
    )
    TAGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/tags'
    )
    THEME = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/theme'
    )
    THEME_OVERRIDE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/themeOverride'
    )
    THUMBNAIL = (
        'http://schemas.openxmlformats.org/package/2006/relationships/metada'
        'ta/thumbnail'
    )
    USERNAMES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/usernames'
    )
    VIDEO = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/video'
    )
    VIEW_PROPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/viewProps'
    )
    VML_DRAWING = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/vmlDrawing'
    )
    VOLATILE_DEPENDENCIES = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/volatileDependencies'
    )
    WEB_SETTINGS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/webSettings'
    )
    WORKSHEET_SOURCE = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/worksheetSource'
    )
    XML_MAPS = (
        'http://schemas.openxmlformats.org/officeDocument/2006/relationships'
        '/xmlMaps'
    )

########NEW FILE########
__FILENAME__ = exceptions
# encoding: utf-8

"""
Exceptions specific to python-opc

The base exception class is OpcError.
"""


class OpcError(Exception):
    """
    Base error class for python-opc
    """


class PackageNotFoundError(OpcError):
    """
    Raised when a package cannot be found at the specified path.
    """

########NEW FILE########
__FILENAME__ = oxml
# encoding: utf-8

"""
Temporary stand-in for main oxml module that came across with the
PackageReader transplant. Probably much will get replaced with objects from
the pptx.oxml.core and then this module will either get deleted or only hold
the package related custom element classes.
"""

from __future__ import absolute_import, print_function, unicode_literals

from lxml import etree

from .constants import NAMESPACE as NS, RELATIONSHIP_TARGET_MODE as RTM


# configure XML parser
element_class_lookup = etree.ElementNamespaceClassLookup()
oxml_parser = etree.XMLParser(remove_blank_text=True)
oxml_parser.set_element_class_lookup(element_class_lookup)

nsmap = {
    'ct': NS.OPC_CONTENT_TYPES,
    'pr': NS.OPC_RELATIONSHIPS,
    'r':  NS.OFC_RELATIONSHIPS,
}


# ===========================================================================
# functions
# ===========================================================================

def oxml_fromstring(text):
    """
    ``etree.fromstring()`` replacement that uses oxml parser
    """
    return etree.fromstring(text, oxml_parser)


def qn(tag):
    """
    Stands for "qualified name", a utility function to turn a namespace
    prefixed tag name into a Clark-notation qualified tag name for lxml. For
    example, ``qn('p:cSld')`` returns ``'{http://schemas.../main}cSld'``.
    """
    prefix, tagroot = tag.split(':')
    uri = nsmap[prefix]
    return '{%s}%s' % (uri, tagroot)


def serialize_part_xml(part_elm):
    """
    Serialize *part_elm* etree element to XML suitable for storage as an XML
    part. That is to say, no insignificant whitespace added for readability,
    and an appropriate XML declaration added with UTF-8 encoding specified.
    """
    return etree.tostring(part_elm, encoding='UTF-8', standalone=True)


def serialize_for_reading(element):
    """
    Serialize *element* to human-readable XML suitable for tests. No XML
    declaration.
    """
    return etree.tostring(element, encoding='unicode', pretty_print=True)


# ===========================================================================
# Custom element classes
# ===========================================================================

class OxmlBaseElement(etree.ElementBase):
    """
    Base class for all custom element classes, to add standardized behavior
    to all classes in one place.
    """
    @property
    def xml(self):
        """
        Return XML string for this element, suitable for testing purposes.
        Pretty printed for readability and without an XML declaration at the
        top.
        """
        return serialize_for_reading(self)


class CT_Default(OxmlBaseElement):
    """
    ``<Default>`` element, specifying the default content type to be applied
    to a part with the specified extension.
    """
    @property
    def content_type(self):
        """
        String held in the ``ContentType`` attribute of this ``<Default>``
        element.
        """
        return self.get('ContentType')

    @property
    def extension(self):
        """
        String held in the ``Extension`` attribute of this ``<Default>``
        element.
        """
        return self.get('Extension')

    @staticmethod
    def new(ext, content_type):
        """
        Return a new ``<Default>`` element with attributes set to parameter
        values.
        """
        xml = '<Default xmlns="%s"/>' % nsmap['ct']
        default = oxml_fromstring(xml)
        default.set('Extension', ext)
        default.set('ContentType', content_type)
        return default


class CT_Override(OxmlBaseElement):
    """
    ``<Override>`` element, specifying the content type to be applied for a
    part with the specified partname.
    """
    @property
    def content_type(self):
        """
        String held in the ``ContentType`` attribute of this ``<Override>``
        element.
        """
        return self.get('ContentType')

    @staticmethod
    def new(partname, content_type):
        """
        Return a new ``<Override>`` element with attributes set to parameter
        values.
        """
        xml = '<Override xmlns="%s"/>' % nsmap['ct']
        override = oxml_fromstring(xml)
        override.set('PartName', partname)
        override.set('ContentType', content_type)
        return override

    @property
    def partname(self):
        """
        String held in the ``PartName`` attribute of this ``<Override>``
        element.
        """
        return self.get('PartName')


class CT_Relationship(OxmlBaseElement):
    """
    ``<Relationship>`` element, representing a single relationship from a
    source to a target part.
    """
    @staticmethod
    def new(rId, reltype, target, target_mode=RTM.INTERNAL):
        """
        Return a new ``<Relationship>`` element.
        """
        xml = '<Relationship xmlns="%s"/>' % nsmap['pr']
        relationship = oxml_fromstring(xml)
        relationship.set('Id', rId)
        relationship.set('Type', reltype)
        relationship.set('Target', target)
        if target_mode == RTM.EXTERNAL:
            relationship.set('TargetMode', RTM.EXTERNAL)
        return relationship

    @property
    def rId(self):
        """
        String held in the ``Id`` attribute of this ``<Relationship>``
        element.
        """
        return self.get('Id')

    @property
    def reltype(self):
        """
        String held in the ``Type`` attribute of this ``<Relationship>``
        element.
        """
        return self.get('Type')

    @property
    def target_ref(self):
        """
        String held in the ``Target`` attribute of this ``<Relationship>``
        element.
        """
        return self.get('Target')

    @property
    def target_mode(self):
        """
        String held in the ``TargetMode`` attribute of this
        ``<Relationship>`` element, either ``Internal`` or ``External``.
        Defaults to ``Internal``.
        """
        return self.get('TargetMode', RTM.INTERNAL)


class CT_Relationships(OxmlBaseElement):
    """
    ``<Relationships>`` element, the root element in a .rels file.
    """
    def add_rel(self, rId, reltype, target, is_external=False):
        """
        Add a child ``<Relationship>`` element with attributes set according
        to parameter values.
        """
        target_mode = RTM.EXTERNAL if is_external else RTM.INTERNAL
        relationship = CT_Relationship.new(rId, reltype, target, target_mode)
        self.append(relationship)

    @staticmethod
    def new():
        """
        Return a new ``<Relationships>`` element.
        """
        xml = '<Relationships xmlns="%s"/>' % nsmap['pr']
        relationships = oxml_fromstring(xml)
        return relationships

    @property
    def Relationship_lst(self):
        """
        Return a list containing all the ``<Relationship>`` child elements.
        """
        return self.findall(qn('pr:Relationship'))

    @property
    def xml(self):
        """
        Return XML string for this element, suitable for saving in a .rels
        stream, not pretty printed and with an XML declaration at the top.
        """
        return serialize_part_xml(self)


class CT_Types(OxmlBaseElement):
    """
    ``<Types>`` element, the container element for Default and Override
    elements in [Content_Types].xml.
    """
    def add_default(self, ext, content_type):
        """
        Add a child ``<Default>`` element with attributes set to parameter
        values.
        """
        default = CT_Default.new(ext, content_type)
        self.append(default)

    def add_override(self, partname, content_type):
        """
        Add a child ``<Override>`` element with attributes set to parameter
        values.
        """
        override = CT_Override.new(partname, content_type)
        self.append(override)

    @property
    def defaults(self):
        return self.findall(qn('ct:Default'))

    @staticmethod
    def new():
        """
        Return a new ``<Types>`` element.
        """
        xml = '<Types xmlns="%s"/>' % nsmap['ct']
        types = oxml_fromstring(xml)
        return types

    @property
    def overrides(self):
        return self.findall(qn('ct:Override'))


ct_namespace = element_class_lookup.get_namespace(nsmap['ct'])
ct_namespace['Default'] = CT_Default
ct_namespace['Override'] = CT_Override
ct_namespace['Types'] = CT_Types

pr_namespace = element_class_lookup.get_namespace(nsmap['pr'])
pr_namespace['Relationship'] = CT_Relationship
pr_namespace['Relationships'] = CT_Relationships

########NEW FILE########
__FILENAME__ = package
# encoding: utf-8

"""
The :mod:`pptx.packaging` module coheres around the concerns of reading and
writing presentations to and from a .pptx file.
"""

from __future__ import absolute_import, print_function, unicode_literals

from .compat import cls_method_fn
from .constants import RELATIONSHIP_TYPE as RT
from .oxml import CT_Relationships, nsmap, serialize_part_xml
from .packuri import PACKAGE_URI, PackURI
from .pkgreader import PackageReader
from .pkgwriter import PackageWriter
from .shared import lazyproperty


class OpcPackage(object):
    """
    Main API class for |python-opc|. A new instance is constructed by calling
    the :meth:`open` class method with a path to a package file or file-like
    object containing one.
    """
    def __init__(self):
        super(OpcPackage, self).__init__()

    def after_unmarshal(self):
        """
        Entry point for any post-unmarshaling processing. May be overridden
        by subclasses without forwarding call to super.
        """
        # don't place any code here, just catch call if not overridden by
        # subclass
        pass

    def iter_rels(self):
        """
        Generate exactly one reference to each relationship in the package by
        performing a depth-first traversal of the rels graph.
        """
        def walk_rels(source, visited=None):
            visited = [] if visited is None else visited
            for rel in source.rels.values():
                yield rel
                if rel.is_external:
                    continue
                part = rel.target_part
                if part in visited:
                    continue
                visited.append(part)
                new_source = part
                for rel in walk_rels(new_source, visited):
                    yield rel

        for rel in walk_rels(self):
            yield rel

    def iter_parts(self):
        """
        Generate exactly one reference to each of the parts in the package by
        performing a depth-first traversal of the rels graph.
        """
        def walk_parts(source, visited=list()):
            for rel in source.rels.values():
                if rel.is_external:
                    continue
                part = rel.target_part
                if part in visited:
                    continue
                visited.append(part)
                yield part
                new_source = part
                for part in walk_parts(new_source, visited):
                    yield part

        for part in walk_parts(self):
            yield part

    def load_rel(self, reltype, target, rId, is_external=False):
        """
        Return newly added |_Relationship| instance of *reltype* between this
        part and *target* with key *rId*. Target mode is set to
        ``RTM.EXTERNAL`` if *is_external* is |True|. Intended for use during
        load from a serialized package, where the rId is well known. Other
        methods exist for adding a new relationship to the package during
        processing.
        """
        return self.rels.add_relationship(reltype, target, rId, is_external)

    @property
    def main_document(self):
        """
        Return a reference to the main document part for this package.
        Examples include a document part for a WordprocessingML package, a
        presentation part for a PresentationML package, or a workbook part
        for a SpreadsheetML package.
        """
        return self.part_related_by(RT.OFFICE_DOCUMENT)

    @classmethod
    def open(cls, pkg_file):
        """
        Return an |OpcPackage| instance loaded with the contents of
        *pkg_file*.
        """
        pkg_reader = PackageReader.from_file(pkg_file)
        package = cls()
        Unmarshaller.unmarshal(pkg_reader, package, PartFactory)
        return package

    def part_related_by(self, reltype):
        """
        Return part to which this package has a relationship of *reltype*.
        Raises |KeyError| if no such relationship is found and |ValueError|
        if more than one such relationship is found.
        """
        return self.rels.part_with_reltype(reltype)

    @property
    def parts(self):
        """
        Return a list containing a reference to each of the parts in this
        package.
        """
        return [part for part in self.iter_parts()]

    def relate_to(self, part, reltype):
        """
        Return rId key of relationship to *part*, from the existing
        relationship if there is one, otherwise a newly created one.
        """
        rel = self.rels.get_or_add(reltype, part)
        return rel.rId

    @lazyproperty
    def rels(self):
        """
        Return a reference to the |Relationships| instance holding the
        collection of relationships for this package.
        """
        return Relationships(PACKAGE_URI.baseURI)

    def save(self, pkg_file):
        """
        Save this package to *pkg_file*, where *file* can be either a path to
        a file (a string) or a file-like object.
        """
        # self._notify_before_marshal()
        for part in self.parts:
            part.before_marshal()
        PackageWriter.write(pkg_file, self.rels, self.parts)


class Part(object):
    """
    Base class for package parts. Provides common properties and methods, but
    intended to be subclassed in client code to implement specific part
    behaviors.
    """
    def __init__(
            self, partname, content_type, blob=None, element=None,
            package=None):
        super(Part, self).__init__()
        self._partname = partname
        self._content_type = content_type
        self._blob = blob
        self._element = element
        self._package = package

    # load/save interface to OpcPackage ------------------------------

    def after_unmarshal(self):
        """
        Entry point for post-unmarshaling processing, for example to parse
        the part XML. May be overridden by subclasses without forwarding call
        to super.
        """
        # don't place any code here, just catch call if not overridden by
        # subclass
        pass

    def before_marshal(self):
        """
        Entry point for pre-serialization processing, for example to finalize
        part naming if necessary. May be overridden by subclasses without
        forwarding call to super.
        """
        # don't place any code here, just catch call if not overridden by
        # subclass
        pass

    @property
    def blob(self):
        """
        Contents of this package part as a sequence of bytes. May be text or
        binary. Intended to be overridden by subclasses. Default behavior is
        to return load blob.
        """
        if self._element is not None:
            return serialize_part_xml(self._element)
        return self._blob

    @property
    def content_type(self):
        """
        Content type of this part.
        """
        return self._content_type

    @classmethod
    def load(cls, partname, content_type, blob, package):
        return cls(
            partname, content_type, blob=blob, element=None, package=package
        )

    def load_rel(self, reltype, target, rId, is_external=False):
        """
        Return newly added |_Relationship| instance of *reltype* between this
        part and *target* with key *rId*. Target mode is set to
        ``RTM.EXTERNAL`` if *is_external* is |True|. Intended for use during
        load from a serialized package, where the rId is well known. Other
        methods exist for adding a new relationship to a part when
        manipulating a part.
        """
        return self.rels.add_relationship(reltype, target, rId, is_external)

    @property
    def partname(self):
        """
        |PackURI| instance holding partname of this part, e.g.
        '/ppt/slides/slide1.xml'
        """
        return self._partname

    @partname.setter
    def partname(self, partname):
        if not isinstance(partname, PackURI):
            tmpl = "partname must be instance of PackURI, got '%s'"
            raise TypeError(tmpl % type(partname).__name__)
        self._partname = partname

    # relationship management interface for child objects ------------

    def drop_rel(self, rId):
        """
        Remove the relationship identified by *rId* if its reference count
        is less than 2. Relationships with a reference count of 0 are
        implicit relationships.
        """
        if self._rel_ref_count(rId) < 2:
            del self.rels[rId]

    def part_related_by(self, reltype):
        """
        Return part to which this part has a relationship of *reltype*.
        Raises |KeyError| if no such relationship is found and |ValueError|
        if more than one such relationship is found. Provides ability to
        resolve implicitly related part, such as Slide -> SlideLayout.
        """
        return self.rels.part_with_reltype(reltype)

    def relate_to(self, target, reltype, is_external=False):
        """
        Return rId key of relationship of *reltype* to *target*, from an
        existing relationship if there is one, otherwise a newly created one.
        """
        if is_external:
            return self.rels.get_or_add_ext_rel(reltype, target)
        else:
            rel = self.rels.get_or_add(reltype, target)
            return rel.rId

    @property
    def related_parts(self):
        """
        Dictionary mapping related parts by rId, so child objects can resolve
        explicit relationships present in the part XML, e.g. sldIdLst to a
        specific |Slide| instance.
        """
        return self.rels.related_parts

    @lazyproperty
    def rels(self):
        """
        |Relationships| instance holding the relationships for this part.
        """
        return Relationships(self._partname.baseURI)

    def target_ref(self, rId):
        """
        Return URL contained in target ref of relationship identified by
        *rId*.
        """
        rel = self.rels[rId]
        return rel.target_ref

    def _rel_ref_count(self, rId):
        """
        Return the count of references in this part's XML to the relationship
        identified by *rId*.
        """
        assert self._element is not None
        rIds = self._element.xpath('//@r:id', namespaces=nsmap)
        return len([_rId for _rId in rIds if _rId == rId])

    # ----------------------------------------------------------------

    @property
    def package(self):
        """
        |OpcPackage| instance this part belongs to.
        """
        return self._package


class PartFactory(object):
    """
    Provides a way for client code to specify a subclass of |Part| to be
    constructed by |Unmarshaller| based on its content type and/or a custom
    callable. Setting ``PartFactory.part_class_selector`` to a callable
    object will cause that object to be called with the parameters
    ``content_type, reltype``, once for each part in the package. If the
    callable returns an object, it is used as the class for that part. If it
    returns |None|, part class selection falls back to the content type map
    defined in ``PartFactory.part_type_for``. If no class is returned from
    either of these, the class contained in ``PartFactory.default_part_type``
    is used to construct the part, which is by default ``opc.package.Part``.
    """
    part_class_selector = None
    part_type_for = {}
    default_part_type = Part

    def __new__(cls, partname, content_type, reltype, blob, package):
        PartClass = None
        if cls.part_class_selector is not None:
            part_class_selector = cls_method_fn(cls, 'part_class_selector')
            PartClass = part_class_selector(content_type, reltype)
        if PartClass is None:
            PartClass = cls._part_cls_for(content_type)
        return PartClass.load(partname, content_type, blob, package)

    @classmethod
    def _part_cls_for(cls, content_type):
        """
        Return the custom part class registered for *content_type*, or the
        default part class if no custom class is registered for
        *content_type*.
        """
        if content_type in cls.part_type_for:
            return cls.part_type_for[content_type]
        return cls.default_part_type


class Relationships(dict):
    """
    Collection object for |_Relationship| instances, having list semantics.
    """
    def __init__(self, baseURI):
        super(Relationships, self).__init__()
        self._baseURI = baseURI
        self._target_parts_by_rId = {}

    def add_relationship(self, reltype, target, rId, is_external=False):
        """
        Return a newly added |_Relationship| instance.
        """
        rel = _Relationship(rId, reltype, target, self._baseURI, is_external)
        self[rId] = rel
        if not is_external:
            self._target_parts_by_rId[rId] = target
        return rel

    def get_or_add(self, reltype, target_part):
        """
        Return relationship of *reltype* to *target_part*, newly added if not
        already present in collection.
        """
        rel = self._get_matching(reltype, target_part)
        if rel is None:
            rId = self._next_rId
            rel = self.add_relationship(reltype, target_part, rId)
        return rel

    def get_or_add_ext_rel(self, reltype, target_ref):
        """
        Return rId of external relationship of *reltype* to *target_ref*,
        newly added if not already present in collection.
        """
        rel = self._get_matching(reltype, target_ref, is_external=True)
        if rel is None:
            rId = self._next_rId
            rel = self.add_relationship(
                reltype, target_ref, rId, is_external=True
            )
        return rel.rId

    def part_with_reltype(self, reltype):
        """
        Return target part of rel with matching *reltype*, raising |KeyError|
        if not found and |ValueError| if more than one matching relationship
        is found.
        """
        rel = self._get_rel_of_type(reltype)
        return rel.target_part

    @property
    def related_parts(self):
        """
        dict mapping rIds to target parts for all the internal relationships
        in the collection.
        """
        return self._target_parts_by_rId

    @property
    def xml(self):
        """
        Serialize this relationship collection into XML suitable for storage
        as a .rels file in an OPC package.
        """
        rels_elm = CT_Relationships.new()
        for rel in self.values():
            rels_elm.add_rel(
                rel.rId, rel.reltype, rel.target_ref, rel.is_external
            )
        return rels_elm.xml

    def _get_matching(self, reltype, target, is_external=False):
        """
        Return relationship of matching *reltype*, *target*, and
        *is_external* from collection, or None if not found.
        """
        def matches(rel, reltype, target, is_external):
            if rel.reltype != reltype:
                return False
            if rel.is_external != is_external:
                return False
            rel_target = rel.target_ref if rel.is_external else rel.target_part
            if rel_target != target:
                return False
            return True

        for rel in self.values():
            if matches(rel, reltype, target, is_external):
                return rel
        return None

    def _get_rel_of_type(self, reltype):
        """
        Return single relationship of type *reltype* from the collection.
        Raises |KeyError| if no matching relationship is found. Raises
        |ValueError| if more than one matching relationship is found.
        """
        matching = [rel for rel in self.values() if rel.reltype == reltype]
        if len(matching) == 0:
            tmpl = "no relationship of type '%s' in collection"
            raise KeyError(tmpl % reltype)
        if len(matching) > 1:
            tmpl = "multiple relationships of type '%s' in collection"
            raise ValueError(tmpl % reltype)
        return matching[0]

    @property
    def _next_rId(self):
        """
        Next available rId in collection, starting from 'rId1' and making use
        of any gaps in numbering, e.g. 'rId2' for rIds ['rId1', 'rId3'].
        """
        for n in range(1, len(self)+2):
            rId_candidate = 'rId%d' % n  # like 'rId19'
            if rId_candidate not in self:
                return rId_candidate


class Unmarshaller(object):
    """
    Hosts static methods for unmarshalling a package from a |PackageReader|
    instance.
    """
    @staticmethod
    def unmarshal(pkg_reader, package, part_factory):
        """
        Construct graph of parts and realized relationships based on the
        contents of *pkg_reader*, delegating construction of each part to
        *part_factory*. Package relationships are added to *pkg*.
        """
        parts = Unmarshaller._unmarshal_parts(
            pkg_reader, package, part_factory
        )
        Unmarshaller._unmarshal_relationships(pkg_reader, package, parts)
        for part in parts.values():
            part.after_unmarshal()
        package.after_unmarshal()

    @staticmethod
    def _unmarshal_parts(pkg_reader, package, part_factory):
        """
        Return a dictionary of |Part| instances unmarshalled from
        *pkg_reader*, keyed by partname. Side-effect is that each part in
        *pkg_reader* is constructed using *part_factory*.
        """
        parts = {}
        for partname, content_type, reltype, blob in pkg_reader.iter_sparts():
            parts[partname] = part_factory(
                partname, content_type, reltype, blob, package
            )
        return parts

    @staticmethod
    def _unmarshal_relationships(pkg_reader, package, parts):
        """
        Add a relationship to the source object corresponding to each of the
        relationships in *pkg_reader* with its target_part set to the actual
        target part in *parts*.
        """
        for source_uri, srel in pkg_reader.iter_srels():
            source = package if source_uri == '/' else parts[source_uri]
            target = (srel.target_ref if srel.is_external
                      else parts[srel.target_partname])
            source.load_rel(srel.reltype, target, srel.rId, srel.is_external)


class _Relationship(object):
    """
    Value object for relationship to part.
    """
    def __init__(self, rId, reltype, target, baseURI, external=False):
        super(_Relationship, self).__init__()
        self._rId = rId
        self._reltype = reltype
        self._target = target
        self._baseURI = baseURI
        self._is_external = bool(external)

    @property
    def is_external(self):
        return self._is_external

    @property
    def reltype(self):
        return self._reltype

    @property
    def rId(self):
        return self._rId

    @property
    def target_part(self):
        if self._is_external:
            raise ValueError("target_part property on _Relationship is undef"
                             "ined when target mode is External")
        return self._target

    @property
    def target_ref(self):
        if self._is_external:
            return self._target
        else:
            return self._target.partname.relative_ref(self._baseURI)

########NEW FILE########
__FILENAME__ = packuri
# encoding: utf-8

"""
Provides the PackURI value type along with some useful known pack URI strings
such as PACKAGE_URI.
"""

import posixpath
import re


class PackURI(str):
    """
    Provides access to pack URI components such as the baseURI and the
    filename slice. Behaves as |str| otherwise.
    """
    _filename_re = re.compile('([a-zA-Z]+)([1-9][0-9]*)?')

    def __new__(cls, pack_uri_str):
        if not pack_uri_str[0] == '/':
            tmpl = "PackURI must begin with slash, got '%s'"
            raise ValueError(tmpl % pack_uri_str)
        return str.__new__(cls, pack_uri_str)

    @staticmethod
    def from_rel_ref(baseURI, relative_ref):
        """
        Return a |PackURI| instance containing the absolute pack URI formed by
        translating *relative_ref* onto *baseURI*.
        """
        joined_uri = posixpath.join(baseURI, relative_ref)
        abs_uri = posixpath.abspath(joined_uri)
        return PackURI(abs_uri)

    @property
    def baseURI(self):
        """
        The base URI of this pack URI, the directory portion, roughly
        speaking. E.g. ``'/ppt/slides'`` for ``'/ppt/slides/slide1.xml'``.
        For the package pseudo-partname '/', baseURI is '/'.
        """
        return posixpath.split(self)[0]

    @property
    def ext(self):
        """
        The extension portion of this pack URI, e.g. ``'xml'`` for
        ``'/word/document.xml'``. Note the period is not included.
        """
        # raw_ext is either empty string or starts with period, e.g. '.xml'
        raw_ext = posixpath.splitext(self)[1]
        return raw_ext[1:] if raw_ext.startswith('.') else raw_ext

    @property
    def filename(self):
        """
        The "filename" portion of this pack URI, e.g. ``'slide1.xml'`` for
        ``'/ppt/slides/slide1.xml'``. For the package pseudo-partname '/',
        filename is ''.
        """
        return posixpath.split(self)[1]

    @property
    def idx(self):
        """
        Return partname index as integer for tuple partname or None for
        singleton partname, e.g. ``21`` for ``'/ppt/slides/slide21.xml'`` and
        |None| for ``'/ppt/presentation.xml'``.
        """
        filename = self.filename
        if not filename:
            return None
        name_part = posixpath.splitext(filename)[0]  # filename w/ext removed
        match = self._filename_re.match(name_part)
        if match is None:
            return None
        if match.group(2):
            return int(match.group(2))
        return None

    @property
    def membername(self):
        """
        The pack URI with the leading slash stripped off, the form used as
        the Zip file membername for the package item. Returns '' for the
        package pseudo-partname '/'.
        """
        return self[1:]

    def relative_ref(self, baseURI):
        """
        Return string containing relative reference to package item from
        *baseURI*. E.g. PackURI('/ppt/slideLayouts/slideLayout1.xml') would
        return '../slideLayouts/slideLayout1.xml' for baseURI '/ppt/slides'.
        """
        # workaround for posixpath bug in 2.6, doesn't generate correct
        # relative path when *start* (second) parameter is root ('/')
        if baseURI == '/':
            relpath = self[1:]
        else:
            relpath = posixpath.relpath(self, baseURI)
        return relpath

    @property
    def rels_uri(self):
        """
        The pack URI of the .rels part corresponding to the current pack URI.
        Only produces sensible output if the pack URI is a partname or the
        package pseudo-partname '/'.
        """
        rels_filename = '%s.rels' % self.filename
        rels_uri_str = posixpath.join(self.baseURI, '_rels', rels_filename)
        return PackURI(rels_uri_str)


PACKAGE_URI = PackURI('/')
CONTENT_TYPES_URI = PackURI('/[Content_Types].xml')

########NEW FILE########
__FILENAME__ = phys_pkg
# encoding: utf-8

"""
Provides a general interface to a *physical* OPC package, such as a zip file.
"""

from __future__ import absolute_import

import os

from zipfile import ZipFile, is_zipfile, ZIP_DEFLATED

from .compat import is_string
from .exceptions import PackageNotFoundError
from .packuri import CONTENT_TYPES_URI


class PhysPkgReader(object):
    """
    Factory for physical package reader objects.
    """
    def __new__(cls, pkg_file):
        # if *pkg_file* is a string, treat it as a path
        if is_string(pkg_file):
            if os.path.isdir(pkg_file):
                reader_cls = _DirPkgReader
            elif is_zipfile(pkg_file):
                reader_cls = _ZipPkgReader
            else:
                raise PackageNotFoundError(
                    "Package not found at '%s'" % pkg_file
                )
        else:  # assume it's a stream and pass it to Zip reader to sort out
            reader_cls = _ZipPkgReader

        return super(PhysPkgReader, cls).__new__(reader_cls)


class PhysPkgWriter(object):
    """
    Factory for physical package writer objects.
    """
    def __new__(cls, pkg_file):
        return super(PhysPkgWriter, cls).__new__(_ZipPkgWriter)


class _DirPkgReader(PhysPkgReader):
    """
    Implements |PhysPkgReader| interface for an OPC package extracted into a
    directory.
    """
    def __init__(self, path):
        """
        *path* is the path to a directory containing an expanded package.
        """
        super(_DirPkgReader, self).__init__()
        self._path = os.path.abspath(path)

    def blob_for(self, pack_uri):
        """
        Return contents of file corresponding to *pack_uri* in package
        directory.
        """
        path = os.path.join(self._path, pack_uri.membername)
        with open(path, 'rb') as f:
            blob = f.read()
        return blob

    def close(self):
        """
        Provides interface consistency with |ZipFileSystem|, but does
        nothing, a directory file system doesn't need closing.
        """
        pass

    @property
    def content_types_xml(self):
        """
        Return the `[Content_Types].xml` blob from the package.
        """
        return self.blob_for(CONTENT_TYPES_URI)

    def rels_xml_for(self, source_uri):
        """
        Return rels item XML for source with *source_uri*, or None if the
        item has no rels item.
        """
        try:
            rels_xml = self.blob_for(source_uri.rels_uri)
        except IOError:
            rels_xml = None
        return rels_xml


class _ZipPkgReader(PhysPkgReader):
    """
    Implements |PhysPkgReader| interface for a zip file OPC package.
    """
    def __init__(self, pkg_file):
        super(_ZipPkgReader, self).__init__()
        self._zipf = ZipFile(pkg_file, 'r')

    def blob_for(self, pack_uri):
        """
        Return blob corresponding to *pack_uri*. Raises |ValueError| if no
        matching member is present in zip archive.
        """
        return self._zipf.read(pack_uri.membername)

    def close(self):
        """
        Close the zip archive, releasing any resources it is using.
        """
        self._zipf.close()

    @property
    def content_types_xml(self):
        """
        Return the `[Content_Types].xml` blob from the zip package.
        """
        return self.blob_for(CONTENT_TYPES_URI)

    def rels_xml_for(self, source_uri):
        """
        Return rels item XML for source with *source_uri* or None if no rels
        item is present.
        """
        try:
            rels_xml = self.blob_for(source_uri.rels_uri)
        except KeyError:
            rels_xml = None
        return rels_xml


class _ZipPkgWriter(PhysPkgWriter):
    """
    Implements |PhysPkgWriter| interface for a zip file OPC package.
    """
    def __init__(self, pkg_file):
        super(_ZipPkgWriter, self).__init__()
        self._zipf = ZipFile(pkg_file, 'w', compression=ZIP_DEFLATED)

    def close(self):
        """
        Close the zip archive, flushing any pending physical writes and
        releasing any resources it's using.
        """
        self._zipf.close()

    def write(self, pack_uri, blob):
        """
        Write *blob* to this zip package with the membername corresponding to
        *pack_uri*.
        """
        self._zipf.writestr(pack_uri.membername, blob)

########NEW FILE########
__FILENAME__ = pkgreader
# encoding: utf-8

"""
Provides a low-level, read-only API to a serialized Open Packaging Convention
(OPC) package.
"""

from __future__ import absolute_import

from .constants import RELATIONSHIP_TARGET_MODE as RTM
from .oxml import oxml_fromstring
from .packuri import PACKAGE_URI, PackURI
from .phys_pkg import PhysPkgReader
from .shared import CaseInsensitiveDict


class PackageReader(object):
    """
    Provides access to the contents of a zip-format OPC package via its
    :attr:`serialized_parts` and :attr:`pkg_srels` attributes.
    """
    def __init__(self, content_types, pkg_srels, sparts):
        super(PackageReader, self).__init__()
        self._pkg_srels = pkg_srels
        self._sparts = sparts

    @staticmethod
    def from_file(pkg_file):
        """
        Return a |PackageReader| instance loaded with contents of *pkg_file*.
        """
        phys_reader = PhysPkgReader(pkg_file)
        content_types = _ContentTypeMap.from_xml(phys_reader.content_types_xml)
        pkg_srels = PackageReader._srels_for(phys_reader, PACKAGE_URI)
        sparts = PackageReader._load_serialized_parts(
            phys_reader, pkg_srels, content_types
        )
        phys_reader.close()
        return PackageReader(content_types, pkg_srels, sparts)

    def iter_sparts(self):
        """
        Generate a 4-tuple `(partname, content_type, reltype, blob)` for each
        of the serialized parts in the package.
        """
        for s in self._sparts:
            yield (s.partname, s.content_type, s.reltype, s.blob)

    def iter_srels(self):
        """
        Generate a 2-tuple `(source_uri, srel)` for each of the relationships
        in the package.
        """
        for srel in self._pkg_srels:
            yield (PACKAGE_URI, srel)
        for spart in self._sparts:
            for srel in spart.srels:
                yield (spart.partname, srel)

    @staticmethod
    def _load_serialized_parts(phys_reader, pkg_srels, content_types):
        """
        Return a list of |_SerializedPart| instances corresponding to the
        parts in *phys_reader* accessible by walking the relationship graph
        starting with *pkg_srels*.
        """
        sparts = []
        part_walker = PackageReader._walk_phys_parts(phys_reader, pkg_srels)
        for partname, blob, reltype, srels in part_walker:
            content_type = content_types[partname]
            spart = _SerializedPart(
                partname, content_type, reltype, blob, srels
            )
            sparts.append(spart)
        return tuple(sparts)

    @staticmethod
    def _srels_for(phys_reader, source_uri):
        """
        Return |_SerializedRelationships| instance populated with
        relationships for source identified by *source_uri*.
        """
        rels_xml = phys_reader.rels_xml_for(source_uri)
        return _SerializedRelationships.load_from_xml(
            source_uri.baseURI, rels_xml)

    @staticmethod
    def _walk_phys_parts(phys_reader, srels, visited_partnames=None):
        """
        Generate a 4-tuple `(partname, blob, reltype, srels)` for each of the
        parts in *phys_reader* by walking the relationship graph rooted at
        srels.
        """
        if visited_partnames is None:
            visited_partnames = []
        for srel in srels:
            if srel.is_external:
                continue
            partname = srel.target_partname
            if partname in visited_partnames:
                continue
            visited_partnames.append(partname)
            reltype = srel.reltype
            part_srels = PackageReader._srels_for(phys_reader, partname)
            blob = phys_reader.blob_for(partname)
            yield (partname, blob, reltype, part_srels)
            next_walker = PackageReader._walk_phys_parts(
                phys_reader, part_srels, visited_partnames
            )
            for partname, blob, reltype, srels in next_walker:
                yield (partname, blob, reltype, srels)


class _ContentTypeMap(object):
    """
    Value type providing dictionary semantics for looking up content type by
    part name, e.g. ``content_type = cti['/ppt/presentation.xml']``.
    """
    def __init__(self):
        super(_ContentTypeMap, self).__init__()
        self._overrides = CaseInsensitiveDict()
        self._defaults = CaseInsensitiveDict()

    def __getitem__(self, partname):
        """
        Return content type for part identified by *partname*.
        """
        if not isinstance(partname, PackURI):
            tmpl = "_ContentTypeMap key must be <type 'PackURI'>, got %s"
            raise KeyError(tmpl % type(partname))
        if partname in self._overrides:
            return self._overrides[partname]
        if partname.ext in self._defaults:
            return self._defaults[partname.ext]
        tmpl = "no content type for partname '%s' in [Content_Types].xml"
        raise KeyError(tmpl % partname)

    @staticmethod
    def from_xml(content_types_xml):
        """
        Return a new |_ContentTypeMap| instance populated with the contents
        of *content_types_xml*.
        """
        types_elm = oxml_fromstring(content_types_xml)
        ct_map = _ContentTypeMap()
        for o in types_elm.overrides:
            ct_map._add_override(o.partname, o.content_type)
        for d in types_elm.defaults:
            ct_map._add_default(d.extension, d.content_type)
        return ct_map

    def _add_default(self, extension, content_type):
        """
        Add the default mapping of *extension* to *content_type* to this
        content type mapping.
        """
        self._defaults[extension] = content_type

    def _add_override(self, partname, content_type):
        """
        Add the default mapping of *partname* to *content_type* to this
        content type mapping.
        """
        self._overrides[partname] = content_type


class _SerializedPart(object):
    """
    Value object for an OPC package part. Provides access to the partname,
    content type, blob, and serialized relationships for the part.
    """
    def __init__(self, partname, content_type, reltype, blob, srels):
        super(_SerializedPart, self).__init__()
        self._partname = partname
        self._content_type = content_type
        self._reltype = reltype
        self._blob = blob
        self._srels = srels

    @property
    def partname(self):
        return self._partname

    @property
    def content_type(self):
        return self._content_type

    @property
    def blob(self):
        return self._blob

    @property
    def reltype(self):
        """
        The referring relationship type of this part.
        """
        return self._reltype

    @property
    def srels(self):
        return self._srels


class _SerializedRelationship(object):
    """
    Value object representing a serialized relationship in an OPC package.
    Serialized, in this case, means any target part is referred to via its
    partname rather than a direct link to an in-memory |Part| object.
    """
    def __init__(self, baseURI, rel_elm):
        super(_SerializedRelationship, self).__init__()
        self._baseURI = baseURI
        self._rId = rel_elm.rId
        self._reltype = rel_elm.reltype
        self._target_mode = rel_elm.target_mode
        self._target_ref = rel_elm.target_ref

    @property
    def is_external(self):
        """
        True if target_mode is ``RTM.EXTERNAL``
        """
        return self._target_mode == RTM.EXTERNAL

    @property
    def reltype(self):
        """Relationship type, like ``RT.OFFICE_DOCUMENT``"""
        return self._reltype

    @property
    def rId(self):
        """
        Relationship id, like 'rId9', corresponds to the ``Id`` attribute on
        the ``CT_Relationship`` element.
        """
        return self._rId

    @property
    def target_mode(self):
        """
        String in ``TargetMode`` attribute of ``CT_Relationship`` element,
        one of ``RTM.INTERNAL`` or ``RTM.EXTERNAL``.
        """
        return self._target_mode

    @property
    def target_ref(self):
        """
        String in ``Target`` attribute of ``CT_Relationship`` element, a
        relative part reference for internal target mode or an arbitrary URI,
        e.g. an HTTP URL, for external target mode.
        """
        return self._target_ref

    @property
    def target_partname(self):
        """
        |PackURI| instance containing partname targeted by this relationship.
        Raises ``ValueError`` on reference if target_mode is ``'External'``.
        Use :attr:`target_mode` to check before referencing.
        """
        if self.is_external:
            msg = ('target_partname attribute on Relationship is undefined w'
                   'here TargetMode == "External"')
            raise ValueError(msg)
        # lazy-load _target_partname attribute
        if not hasattr(self, '_target_partname'):
            self._target_partname = PackURI.from_rel_ref(self._baseURI,
                                                         self.target_ref)
        return self._target_partname


class _SerializedRelationships(object):
    """
    Read-only sequence of |_SerializedRelationship| instances corresponding
    to the relationships item XML passed to constructor.
    """
    def __init__(self):
        super(_SerializedRelationships, self).__init__()
        self._srels = []

    def __iter__(self):
        """Support iteration, e.g. 'for x in srels:'"""
        return self._srels.__iter__()

    @staticmethod
    def load_from_xml(baseURI, rels_item_xml):
        """
        Return |_SerializedRelationships| instance loaded with the
        relationships contained in *rels_item_xml*. Returns an empty
        collection if *rels_item_xml* is |None|.
        """
        srels = _SerializedRelationships()
        if rels_item_xml is not None:
            rels_elm = oxml_fromstring(rels_item_xml)
            for rel_elm in rels_elm.Relationship_lst:
                srels._srels.append(_SerializedRelationship(baseURI, rel_elm))
        return srels

########NEW FILE########
__FILENAME__ = pkgwriter
# encoding: utf-8

"""
Provides a low-level, write-only API to a serialized Open Packaging
Convention (OPC) package, essentially an implementation of OpcPackage.save()
"""

from __future__ import absolute_import

from .constants import CONTENT_TYPE as CT
from .oxml import CT_Types, serialize_part_xml
from .packuri import CONTENT_TYPES_URI, PACKAGE_URI
from .phys_pkg import PhysPkgWriter
from .shared import CaseInsensitiveDict
from .spec import default_content_types


class PackageWriter(object):
    """
    Writes a zip-format OPC package to *pkg_file*, where *pkg_file* can be
    either a path to a zip file (a string) or a file-like object. Its single
    API method, :meth:`write`, is static, so this class is not intended to
    be instantiated.
    """
    @staticmethod
    def write(pkg_file, pkg_rels, parts):
        """
        Write a physical package (.pptx file) to *pkg_file* containing
        *pkg_rels* and *parts* and a content types stream based on the
        content types of the parts.
        """
        phys_writer = PhysPkgWriter(pkg_file)
        PackageWriter._write_content_types_stream(phys_writer, parts)
        PackageWriter._write_pkg_rels(phys_writer, pkg_rels)
        PackageWriter._write_parts(phys_writer, parts)
        phys_writer.close()

    @staticmethod
    def _write_content_types_stream(phys_writer, parts):
        """
        Write ``[Content_Types].xml`` part to the physical package with an
        appropriate content type lookup target for each part in *parts*.
        """
        cti = _ContentTypesItem.from_parts(parts)
        phys_writer.write(CONTENT_TYPES_URI, cti.blob)

    @staticmethod
    def _write_parts(phys_writer, parts):
        """
        Write the blob of each part in *parts* to the package, along with a
        rels item for its relationships if and only if it has any.
        """
        for part in parts:
            phys_writer.write(part.partname, part.blob)
            if len(part._rels):
                phys_writer.write(part.partname.rels_uri, part._rels.xml)

    @staticmethod
    def _write_pkg_rels(phys_writer, pkg_rels):
        """
        Write the XML rels item for *pkg_rels* ('/_rels/.rels') to the
        package.
        """
        phys_writer.write(PACKAGE_URI.rels_uri, pkg_rels.xml)


class _ContentTypesItem(object):
    """
    Service class that composes a content types item ([Content_Types].xml)
    based on a list of parts. Not meant to be instantiated directly, its
    single interface method is xml_for(), e.g.
    ``_ContentTypesItem.xml_for(parts)``.
    """
    def __init__(self):
        self._defaults = CaseInsensitiveDict()
        self._overrides = dict()

    @property
    def blob(self):
        """
        Return XML form of this content types item, suitable for storage as
        ``[Content_Types].xml`` in an OPC package.
        """
        return serialize_part_xml(self._element)

    @classmethod
    def from_parts(cls, parts):
        """
        Return content types XML mapping each part in *parts* to the
        appropriate content type and suitable for storage as
        ``[Content_Types].xml`` in an OPC package.
        """
        cti = cls()
        cti._defaults['rels'] = CT.OPC_RELATIONSHIPS
        cti._defaults['xml'] = CT.XML
        for part in parts:
            cti._add_content_type(part.partname, part.content_type)
        return cti

    def _add_content_type(self, partname, content_type):
        """
        Add a content type for the part with *partname* and *content_type*,
        using a default or override as appropriate.
        """
        ext = partname.ext
        if (ext.lower(), content_type) in default_content_types:
            self._defaults[ext] = content_type
        else:
            self._overrides[partname] = content_type

    @property
    def _element(self):
        """
        Return XML form of this content types item, suitable for storage as
        ``[Content_Types].xml`` in an OPC package. Although the sequence of
        elements is not strictly significant, as an aid to testing and
        readability Default elements are sorted by extension and Override
        elements are sorted by partname.
        """
        _types_elm = CT_Types.new()
        for ext in sorted(self._defaults.keys()):
            _types_elm.add_default(ext, self._defaults[ext])
        for partname in sorted(self._overrides.keys()):
            _types_elm.add_override(partname, self._overrides[partname])
        return _types_elm

########NEW FILE########
__FILENAME__ = shared
# encoding: utf-8

"""
Objects shared by opc modules.
"""

from __future__ import absolute_import, print_function, unicode_literals


class CaseInsensitiveDict(dict):
    """
    Mapping type that behaves like dict except that it matches without respect
    to the case of the key. E.g. cid['A'] == cid['a']. Note this is not
    general-purpose, just complete enough to satisfy opc package needs. It
    assumes str keys, and that it is created empty; keys passed in constructor
    are not accounted for
    """
    def __contains__(self, key):
        return super(CaseInsensitiveDict, self).__contains__(key.lower())

    def __getitem__(self, key):
        return super(CaseInsensitiveDict, self).__getitem__(key.lower())

    def __setitem__(self, key, value):
        return super(CaseInsensitiveDict, self).__setitem__(
            key.lower(), value
        )


def lazyproperty(f):
    """
    @lazyprop decorator. Decorated method will be called only on first access
    to calculate a cached property value. After that, the cached value is
    returned.
    """
    cache_attr_name = '_%s' % f.__name__  # like '_foobar' for prop 'foobar'
    docstring = f.__doc__

    def get_prop_value(obj):
        try:
            return getattr(obj, cache_attr_name)
        except AttributeError:
            value = f(obj)
            setattr(obj, cache_attr_name, value)
            return value

    return property(get_prop_value, doc=docstring)

########NEW FILE########
__FILENAME__ = spec
# encoding: utf-8

"""
Provides mappings that embody aspects of the Open XML spec ISO/IEC 29500.
"""

from .constants import CONTENT_TYPE as CT


default_content_types = (
    ('bin',     CT.PML_PRINTER_SETTINGS),
    ('bin',     CT.SML_PRINTER_SETTINGS),
    ('bin',     CT.WML_PRINTER_SETTINGS),
    ('bmp',     CT.BMP),
    ('emf',     CT.X_EMF),
    ('fntdata', CT.X_FONTDATA),
    ('gif',     CT.GIF),
    ('jpe',     CT.JPEG),
    ('jpeg',    CT.JPEG),
    ('jpg',     CT.JPEG),
    ('png',     CT.PNG),
    ('rels',    CT.OPC_RELATIONSHIPS),
    ('tif',     CT.TIFF),
    ('tiff',    CT.TIFF),
    ('wdp',     CT.MS_PHOTO),
    ('wmf',     CT.X_WMF),
    ('xlsx',    CT.SML_SHEET),
    ('xml',     CT.XML),
)

########NEW FILE########
__FILENAME__ = exceptions
# encoding: utf-8

"""
Exceptions for oxml sub-package
"""


class ValidationError(Exception):
    """
    Raised when invalid XML is encountered, such as on attempt to access a
    missing required child element
    """

########NEW FILE########
__FILENAME__ = document
# encoding: utf-8

"""
Custom element classes that correspond to the document part, e.g.
<w:document>.
"""

from docx.oxml.shared import OxmlBaseElement, qn
from docx.oxml.table import CT_Tbl
from docx.oxml.text import CT_P


class CT_Document(OxmlBaseElement):
    """
    ``<w:document>`` element, the root element of a document.xml file.
    """
    @property
    def body(self):
        return self.find(qn('w:body'))


class CT_Body(OxmlBaseElement):
    """
    ``<w:body>``, the container element for the main document story in
    ``document.xml``.
    """
    def add_p(self):
        """
        Return a new <w:p> element that has been added at the end of any
        existing body content.
        """
        p = CT_P.new()
        return self._append_blocklevelelt(p)

    def add_tbl(self):
        """
        Return a new <w:tbl> element that has been added at the end of any
        existing body content.
        """
        tbl = CT_Tbl.new()
        return self._append_blocklevelelt(tbl)

    def clear_content(self):
        """
        Remove all content child elements from this <w:body> element. Leave
        the <w:sectPr> element if it is present.
        """
        if self._sentinel_sectPr is not None:
            content_elms = self[:-1]
        else:
            content_elms = self[:]
        for content_elm in content_elms:
            self.remove(content_elm)

    @property
    def p_lst(self):
        """
        List of <w:p> child elements.
        """
        return self.findall(qn('w:p'))

    @property
    def tbl_lst(self):
        """
        List of <w:tbl> child elements.
        """
        return self.findall(qn('w:tbl'))

    def _append_blocklevelelt(self, block_level_elt):
        """
        Return *block_level_elt* after appending it to end of
        EG_BlockLevelElts sequence.
        """
        sentinel_sectPr = self._sentinel_sectPr
        if sentinel_sectPr is not None:
            sentinel_sectPr.addprevious(block_level_elt)
        else:
            self.append(block_level_elt)
        return block_level_elt

    @property
    def _sentinel_sectPr(self):
        """
        Return ``<w:sectPr>`` element appearing as last child, or None if not
        found. Note that the ``<w:sectPr>`` element can also occur earlier in
        the body; here we're only interested in one occuring as the last
        child.
        """
        if len(self) == 0:
            sentinel_sectPr = None
        elif self[-1].tag != qn('w:sectPr'):
            sentinel_sectPr = None
        else:
            sentinel_sectPr = self[-1]
        return sentinel_sectPr

########NEW FILE########
__FILENAME__ = numbering
# encoding: utf-8

"""
Custom element classes related to the numbering part
"""

from docx.oxml.shared import (
    CT_DecimalNumber, nsmap, OxmlBaseElement, OxmlElement, qn
)


class CT_Num(OxmlBaseElement):
    """
    ``<w:num>`` element, which represents a concrete list definition
    instance, having a required child <w:abstractNumId> that references an
    abstract numbering definition that defines most of the formatting details.
    """
    @property
    def abstractNumId(self):
        return self.find(qn('w:abstractNumId'))

    def add_lvlOverride(self, ilvl):
        """
        Return a newly added CT_NumLvl (<w:lvlOverride>) element having its
        ``ilvl`` attribute set to *ilvl*.
        """
        lvlOverride = CT_NumLvl.new(ilvl)
        self.append(lvlOverride)
        return lvlOverride

    @classmethod
    def new(cls, num_id, abstractNum_id):
        """
        Return a new ``<w:num>`` element having numId of *num_id* and having
        a ``<w:abstractNumId>`` child with val attribute set to
        *abstractNum_id*.
        """
        abstractNumId = CT_DecimalNumber.new(
            'w:abstractNumId', abstractNum_id
        )
        num = OxmlElement('w:num', {qn('w:numId'): str(num_id)})
        num.append(abstractNumId)
        return num

    @property
    def numId(self):
        numId_str = self.get(qn('w:numId'))
        return int(numId_str)


class CT_NumLvl(OxmlBaseElement):
    """
    ``<w:lvlOverride>`` element, which identifies a level in a list
    definition to override with settings it contains.
    """
    def add_startOverride(self, val):
        """
        Return a newly added CT_DecimalNumber element having tagname
        ``w:startOverride`` and ``val`` attribute set to *val*.
        """
        startOverride = CT_DecimalNumber.new('w:startOverride', val)
        self.insert(0, startOverride)
        return startOverride

    @classmethod
    def new(cls, ilvl):
        """
        Return a new ``<w:lvlOverride>`` element having its ``ilvl``
        attribute set to *ilvl*.
        """
        return OxmlElement('w:lvlOverride', {qn('w:ilvl'): str(ilvl)})


class CT_NumPr(OxmlBaseElement):
    """
    A ``<w:numPr>`` element, a container for numbering properties applied to
    a paragraph.
    """
    def get_or_add_ilvl(self):
        """
        Return the ilvl child element, newly added if not present.
        """
        ilvl = self.ilvl
        if ilvl is None:
            ilvl = self._add_ilvl()
        return ilvl

    def get_or_add_numId(self):
        """
        Return the numId child element, newly added if not present.
        """
        numId = self.numId
        if numId is None:
            numId = self._add_numId()
        return numId

    @property
    def ilvl(self):
        return self.find(qn('w:ilvl'))

    @ilvl.setter
    def ilvl(self, val):
        """
        Get or add a <w:ilvl> child and set its ``w:val`` attribute to *val*.
        """
        ilvl = self.get_or_add_ilvl()
        ilvl.val = val

    @classmethod
    def new(cls):
        """
        Return a new ``<w:numPr>`` element
        """
        return OxmlElement('w:numPr')

    @property
    def numId(self):
        return self.find(qn('w:numId'))

    @numId.setter
    def numId(self, val):
        """
        Get or add a <w:numId> child and set its ``w:val`` attribute to *val*.
        """
        numId = self.get_or_add_numId()
        numId.val = val

    def _add_ilvl(self, val=0):
        """
        Return a newly added CT_DecimalNumber element having tagname 'w:ilvl'
        and ``val`` attribute set to *val*.
        """
        ilvl = CT_DecimalNumber.new('w:ilvl', val)
        return self._insert_ilvl(ilvl)

    def _add_numId(self, val=0):
        """
        Return a newly added CT_DecimalNumber element having tagname
        'w:numId' and ``val`` attribute set to *val*.
        """
        numId = CT_DecimalNumber.new('w:numId', val)
        return self._insert_numId(numId)

    def _insert_ilvl(self, ilvl):
        return self.insert_element_before(
            ilvl, 'w:numId', 'w:numberingChange', 'w:ins'
        )

    def _insert_numId(self, numId):
        return self.insert_element_before(
            numId, 'w:numberingChange', 'w:ins'
        )


class CT_Numbering(OxmlBaseElement):
    """
    ``<w:numbering>`` element, the root element of a numbering part, i.e.
    numbering.xml
    """
    def add_num(self, abstractNum_id):
        """
        Return a newly added CT_Num (<w:num>) element that references
        the abstract numbering definition having id *abstractNum_id*.
        """
        next_num_id = self._next_numId
        num = CT_Num.new(next_num_id, abstractNum_id)
        return self._insert_num(num)

    @property
    def num_lst(self):
        """
        List of <w:num> child elements.
        """
        return self.findall(qn('w:num'))

    def num_having_numId(self, numId):
        """
        Return the ``<w:num>`` child element having ``numId`` attribute
        matching *numId*.
        """
        xpath = './w:num[@w:numId="%d"]' % numId
        try:
            return self.xpath(xpath, namespaces=nsmap)[0]
        except IndexError:
            raise KeyError('no <w:num> element with numId %d' % numId)

    def _insert_num(self, num):
        return self.insert_element_before(num, 'w:numIdMacAtCleanup')

    @property
    def _next_numId(self):
        """
        The first ``numId`` unused by a ``<w:num>`` element, starting at
        1 and filling any gaps in numbering between existing ``<w:num>``
        elements.
        """
        numId_strs = self.xpath('./w:num/@w:numId', namespaces=nsmap)
        num_ids = [int(numId_str) for numId_str in numId_strs]
        for num in range(1, len(num_ids)+2):
            if num not in num_ids:
                break
        return num

########NEW FILE########
__FILENAME__ = styles
# encoding: utf-8

"""
Custom element classes related to the styles part
"""

from docx.oxml.shared import nsmap, OxmlBaseElement, qn


class CT_Style(OxmlBaseElement):
    """
    A ``<w:style>`` element, representing a style definition
    """
    @property
    def pPr(self):
        return self.find(qn('w:pPr'))


class CT_Styles(OxmlBaseElement):
    """
    ``<w:styles>`` element, the root element of a styles part, i.e.
    styles.xml
    """
    def style_having_styleId(self, styleId):
        """
        Return the ``<w:style>`` child element having ``styleId`` attribute
        matching *styleId*.
        """
        xpath = './w:style[@w:styleId="%s"]' % styleId
        try:
            return self.xpath(xpath, namespaces=nsmap)[0]
        except IndexError:
            raise KeyError('no <w:style> element with styleId %d' % styleId)

    @property
    def style_lst(self):
        """
        List of <w:style> child elements.
        """
        return self.findall(qn('w:style'))

########NEW FILE########
__FILENAME__ = shape
# encoding: utf-8

"""
Custom element classes for shape-related elements like ``<w:inline>``
"""

from docx.oxml.shared import (
    nsmap, nspfxmap, OxmlBaseElement, OxmlElement, qn
)
from docx.shared import Emu


class CT_Blip(OxmlBaseElement):
    """
    ``<a:blip>`` element, specifies image source and adjustments such as
    alpha and tint.
    """
    @property
    def embed(self):
        return self.get(qn('r:embed'))

    @property
    def link(self):
        return self.get(qn('r:link'))

    @classmethod
    def new(cls, rId):
        blip = OxmlElement('a:blip')
        blip.set(qn('r:embed'), rId)
        return blip


class CT_BlipFillProperties(OxmlBaseElement):
    """
    ``<pic:blipFill>`` element, specifies picture properties
    """
    @property
    def blip(self):
        return self.find(qn('a:blip'))

    @classmethod
    def new(cls, rId):
        blipFill = OxmlElement('pic:blipFill')
        blipFill.append(CT_Blip.new(rId))
        blipFill.append(CT_StretchInfoProperties.new())
        return blipFill


class CT_GraphicalObject(OxmlBaseElement):
    """
    ``<a:graphic>`` element, container for a DrawingML object
    """
    @property
    def graphicData(self):
        return self.find(qn('a:graphicData'))

    @classmethod
    def new(cls, uri, pic):
        graphic = OxmlElement('a:graphic')
        graphic.append(CT_GraphicalObjectData.new(uri, pic))
        return graphic


class CT_GraphicalObjectData(OxmlBaseElement):
    """
    ``<a:graphicData>`` element, container for the XML of a DrawingML object
    """
    @classmethod
    def new(cls, uri, pic):
        graphicData = OxmlElement('a:graphicData')
        graphicData.set('uri', uri)
        graphicData.append(pic)
        return graphicData

    @property
    def pic(self):
        return self.find(qn('pic:pic'))

    @property
    def uri(self):
        return self.get('uri')


class CT_Inline(OxmlBaseElement):
    """
    ``<w:inline>`` element, container for an inline shape.
    """
    @property
    def extent(self):
        return self.find(qn('wp:extent'))

    @property
    def graphic(self):
        return self.find(qn('a:graphic'))

    @classmethod
    def new(cls, cx, cy, shape_id, pic):
        """
        Return a new ``<wp:inline>`` element populated with the values passed
        as parameters.
        """
        name = 'Picture %d' % shape_id
        uri = nsmap['pic']

        inline = OxmlElement('wp:inline', nsmap=nspfxmap('wp', 'r'))
        inline.append(CT_PositiveSize2D.new('wp:extent', cx, cy))
        inline.append(CT_NonVisualDrawingProps.new(
            'wp:docPr', shape_id, name
        ))
        inline.append(CT_GraphicalObject.new(uri, pic))
        return inline


class CT_NonVisualDrawingProps(OxmlBaseElement):
    """
    Used for ``<wp:docPr>`` element, and perhaps others. Specifies the id and
    name of a DrawingML drawing.
    """
    @classmethod
    def new(cls, nsptagname_str, shape_id, name):
        elt = OxmlElement(nsptagname_str)
        elt.set('id', str(shape_id))
        elt.set('name', name)
        return elt


class CT_NonVisualPictureProperties(OxmlBaseElement):
    """
    ``<pic:cNvPicPr>`` element, specifies picture locking and resize
    behaviors.
    """
    @classmethod
    def new(cls):
        return OxmlElement('pic:cNvPicPr')


class CT_Picture(OxmlBaseElement):
    """
    ``<pic:pic>`` element, a DrawingML picture
    """
    @property
    def blipFill(self):
        return self.find(qn('pic:blipFill'))

    @classmethod
    def new(cls, pic_id, filename, rId, cx, cy):
        """
        Return a new ``<pic:pic>`` element populated with the minimal
        contents required to define a viable picture element, based on the
        values passed as parameters.
        """
        pic = OxmlElement('pic:pic', nsmap=nspfxmap('pic', 'r'))
        pic.append(CT_PictureNonVisual.new(pic_id, filename))
        pic.append(CT_BlipFillProperties.new(rId))
        pic.append(CT_ShapeProperties.new(cx, cy))
        return pic


class CT_PictureNonVisual(OxmlBaseElement):
    """
    ``<pic:nvPicPr>`` element, non-visual picture properties
    """
    @classmethod
    def new(cls, pic_id, image_filename):
        nvPicPr = OxmlElement('pic:nvPicPr')
        nvPicPr.append(CT_NonVisualDrawingProps.new(
            'pic:cNvPr', pic_id, image_filename
        ))
        nvPicPr.append(CT_NonVisualPictureProperties.new())
        return nvPicPr


class CT_Point2D(OxmlBaseElement):
    """
    Used for ``<a:off>`` element, and perhaps others. Specifies an x, y
    coordinate (point).
    """
    @classmethod
    def new(cls, nsptagname_str, x, y):
        elm = OxmlElement(nsptagname_str)
        elm.set('x', str(x))
        elm.set('y', str(y))
        return elm


class CT_PositiveSize2D(OxmlBaseElement):
    """
    Used for ``<wp:extent>`` element, and perhaps others later. Specifies the
    size of a DrawingML drawing.
    """
    @property
    def cx(self):
        cx_str = self.get('cx')
        cx = int(cx_str)
        return Emu(cx)

    @cx.setter
    def cx(self, cx):
        cx_str = str(cx)
        self.set('cx', cx_str)

    @property
    def cy(self):
        cy_str = self.get('cy')
        cy = int(cy_str)
        return Emu(cy)

    @cy.setter
    def cy(self, cy):
        cy_str = str(cy)
        self.set('cy', cy_str)

    @classmethod
    def new(cls, nsptagname_str, cx, cy):
        elm = OxmlElement(nsptagname_str)
        elm.set('cx', str(cx))
        elm.set('cy', str(cy))
        return elm


class CT_PresetGeometry2D(OxmlBaseElement):
    """
    ``<a:prstGeom>`` element, specifies an preset autoshape geometry, such
    as ``rect``.
    """
    @classmethod
    def new(cls, prst):
        prstGeom = OxmlElement('a:prstGeom')
        prstGeom.set('prst', prst)
        return prstGeom


class CT_RelativeRect(OxmlBaseElement):
    """
    ``<a:fillRect>`` element, specifying picture should fill containing
    rectangle shape.
    """
    @classmethod
    def new(cls):
        return OxmlElement('a:fillRect')


class CT_ShapeProperties(OxmlBaseElement):
    """
    ``<pic:spPr>`` element, specifies size and shape of picture container.
    """
    @classmethod
    def new(cls, cx, cy):
        spPr = OxmlElement('pic:spPr')
        spPr.append(CT_Transform2D.new(cx, cy))
        spPr.append(CT_PresetGeometry2D.new('rect'))
        return spPr


class CT_StretchInfoProperties(OxmlBaseElement):
    """
    ``<a:stretch>`` element, specifies how picture should fill its containing
    shape.
    """
    @classmethod
    def new(cls):
        stretch = OxmlElement('a:stretch')
        stretch.append(CT_RelativeRect.new())
        return stretch


class CT_Transform2D(OxmlBaseElement):
    """
    ``<a:xfrm>`` element, specifies size and shape of picture container.
    """
    @classmethod
    def new(cls, cx, cy):
        spPr = OxmlElement('a:xfrm')
        spPr.append(CT_Point2D.new('a:off', 0, 0))
        spPr.append(CT_PositiveSize2D.new('a:ext', cx, cy))
        return spPr

########NEW FILE########
__FILENAME__ = shared
# encoding: utf-8

"""
Objects shared by modules in the docx.oxml subpackage.
"""

from lxml import etree

import re

from .exceptions import ValidationError


nsmap = {
    'a':   ('http://schemas.openxmlformats.org/drawingml/2006/main'),
    'c':   ('http://schemas.openxmlformats.org/drawingml/2006/chart'),
    'dgm': ('http://schemas.openxmlformats.org/drawingml/2006/diagram'),
    'pic': ('http://schemas.openxmlformats.org/drawingml/2006/picture'),
    'r':   ('http://schemas.openxmlformats.org/officeDocument/2006/relations'
            'hips'),
    'w':   ('http://schemas.openxmlformats.org/wordprocessingml/2006/main'),
    'wp':  ('http://schemas.openxmlformats.org/drawingml/2006/wordprocessing'
            'Drawing'),
    'xml': ('http://www.w3.org/XML/1998/namespace')
}

# configure XML parser
element_class_lookup = etree.ElementNamespaceClassLookup()
oxml_parser = etree.XMLParser(remove_blank_text=True)
oxml_parser.set_element_class_lookup(element_class_lookup)


# ===========================================================================
# utility functions
# ===========================================================================

class NamespacePrefixedTag(str):
    """
    Value object that knows the semantics of an XML tag having a namespace
    prefix.
    """
    def __new__(cls, nstag, *args):
        return super(NamespacePrefixedTag, cls).__new__(cls, nstag)

    def __init__(self, nstag):
        self._pfx, self._local_part = nstag.split(':')
        self._ns_uri = nsmap[self._pfx]

    @property
    def clark_name(self):
        return '{%s}%s' % (self._ns_uri, self._local_part)

    @property
    def local_part(self):
        """
        Return the local part of the tag as a string. E.g. 'foobar' is
        returned for tag 'f:foobar'.
        """
        return self._local_part

    @property
    def nsmap(self):
        """
        Return a dict having a single member, mapping the namespace prefix of
        this tag to it's namespace name (e.g. {'f': 'http://foo/bar'}). This
        is handy for passing to xpath calls and other uses.
        """
        return {self._pfx: self._ns_uri}

    @property
    def nspfx(self):
        """
        Return the string namespace prefix for the tag, e.g. 'f' is returned
        for tag 'f:foobar'.
        """
        return self._pfx

    @property
    def nsuri(self):
        """
        Return the namespace URI for the tag, e.g. 'http://foo/bar' would be
        returned for tag 'f:foobar' if the 'f' prefix maps to
        'http://foo/bar' in nsmap.
        """
        return self._ns_uri


def nsdecls(*prefixes):
    return ' '.join(['xmlns:%s="%s"' % (pfx, nsmap[pfx]) for pfx in prefixes])


def nspfxmap(*nspfxs):
    """
    Return a dict containing the subset namespace prefix mappings specified by
    *nspfxs*. Any number of namespace prefixes can be supplied, e.g.
    namespaces('a', 'r', 'p').
    """
    return dict((pfx, nsmap[pfx]) for pfx in nspfxs)


def OxmlElement(nsptag_str, attrs=None, nsmap=None):
    """
    Return a 'loose' lxml element having the tag specified by *nsptag_str*.
    *nsptag_str* must contain the standard namespace prefix, e.g. 'a:tbl'.
    The resulting element is an instance of the custom element class for this
    tag name if one is defined. A dictionary of attribute values may be
    provided as *attrs*; they are set if present.
    """
    nsptag = NamespacePrefixedTag(nsptag_str)
    nsmap = nsmap if nsmap is not None else nsptag.nsmap
    return oxml_parser.makeelement(
        nsptag.clark_name, attrib=attrs, nsmap=nsmap
    )


def oxml_fromstring(text):
    """
    ``etree.fromstring()`` replacement that uses oxml parser
    """
    return etree.fromstring(text, oxml_parser)


def qn(tag):
    """
    Stands for "qualified name", a utility function to turn a namespace
    prefixed tag name into a Clark-notation qualified tag name for lxml. For
    example, ``qn('p:cSld')`` returns ``'{http://schemas.../main}cSld'``.
    """
    prefix, tagroot = tag.split(':')
    uri = nsmap[prefix]
    return '{%s}%s' % (uri, tagroot)


def register_custom_element_class(tag, cls):
    """
    Register *cls* to be constructed when the oxml parser encounters an
    element with matching *tag*. *tag* is a string of the form
    ``nspfx:tagroot``, e.g. ``'w:document'``.
    """
    nspfx, tagroot = tag.split(':')
    namespace = element_class_lookup.get_namespace(nsmap[nspfx])
    namespace[tagroot] = cls


def serialize_for_reading(element):
    """
    Serialize *element* to human-readable XML suitable for tests. No XML
    declaration.
    """
    xml = etree.tostring(element, encoding='unicode', pretty_print=True)
    return XmlString(xml)


def _SubElement(parent, tag):
    return etree.SubElement(parent, qn(tag), nsmap=nsmap)


class XmlString(str):
    """
    Provides string comparison override suitable for serialized XML that is
    useful for tests.
    """

    # '    <w:xyz xmlns:a="http://ns/decl/a" attr_name="val">text</w:xyz>'
    # |          |                                          ||           |
    # +----------+------------------------------------------++-----------+
    #  front      attrs                                     | text
    #                                                     close

    _xml_elm_line_patt = re.compile(
        '( *</?[\w:]+)(.*?)(/?>)([^<]*</\w+>)?'
    )

    def __eq__(self, other):
        lines = self.splitlines()
        lines_other = other.splitlines()
        if len(lines) != len(lines_other):
            return False
        for line, line_other in zip(lines, lines_other):
            if not self._eq_elm_strs(line, line_other):
                return False
        return True

    def __ne__(self, other):
        return not self.__eq__(other)

    def _attr_seq(self, attrs):
        """
        Return a sequence of attribute strings parsed from *attrs*. Each
        attribute string is stripped of whitespace on both ends.
        """
        attrs = attrs.strip()
        attr_lst = attrs.split()
        return sorted(attr_lst)

    def _eq_elm_strs(self, line, line_2):
        """
        Return True if the element in *line_2* is XML equivalent to the
        element in *line*.
        """
        front, attrs, close, text = self._parse_line(line)
        front_2, attrs_2, close_2, text_2 = self._parse_line(line_2)
        if front != front_2:
            return False
        if self._attr_seq(attrs) != self._attr_seq(attrs_2):
            return False
        if close != close_2:
            return False
        if text != text_2:
            return False
        return True

    def _parse_line(self, line):
        """
        Return front, attrs, close, text 4-tuple result of parsing XML element
        string *line*.
        """
        match = self._xml_elm_line_patt.match(line)
        front, attrs, close, text = [match.group(n) for n in range(1, 5)]
        return front, attrs, close, text


# ===========================================================================
# shared custom element classes
# ===========================================================================

class OxmlBaseElement(etree.ElementBase):
    """
    Base class for all custom element classes, to add standardized behavior
    to all classes in one place.
    """
    def first_child_found_in(self, *tagnames):
        """
        Return the first child found with tag in *tagnames*, or None if
        not found.
        """
        for tagname in tagnames:
            child = self.find(qn(tagname))
            if child is not None:
                return child
        return None

    def insert_element_before(self, elm, *tagnames):
        successor = self.first_child_found_in(*tagnames)
        if successor is not None:
            successor.addprevious(elm)
        else:
            self.append(elm)
        return elm

    @property
    def xml(self):
        """
        Return XML string for this element, suitable for testing purposes.
        Pretty printed for readability and without an XML declaration at the
        top.
        """
        return serialize_for_reading(self)


class CT_DecimalNumber(OxmlBaseElement):
    """
    Used for ``<w:numId>``, ``<w:ilvl>``, ``<w:abstractNumId>`` and several
    others, containing a text representation of a decimal number (e.g. 42) in
    its ``val`` attribute.
    """
    @classmethod
    def new(cls, nsptagname, val):
        """
        Return a new ``CT_DecimalNumber`` element having tagname *nsptagname*
        and ``val`` attribute set to *val*.
        """
        return OxmlElement(nsptagname, attrs={qn('w:val'): str(val)})

    @property
    def val(self):
        """
        Required attribute containing a decimal integer
        """
        number_str = self.get(qn('w:val'))
        return int(number_str)

    @val.setter
    def val(self, val):
        decimal_number_str = '%d' % val
        self.set(qn('w:val'), decimal_number_str)


class CT_OnOff(OxmlBaseElement):
    """
    Used for ``<w:b>``, ``<w:i>`` elements and others, containing a bool-ish
    string in its ``val`` attribute, xsd:boolean plus 'on' and 'off'.
    """
    @property
    def val(self):
        val = self.get(qn('w:val'))
        if val is None:
            return True
        elif val in ('0', 'false', 'off'):
            return False
        elif val in ('1', 'true', 'on'):
            return True
        raise ValidationError("expected xsd:boolean, got '%s'" % val)

    @val.setter
    def val(self, value):
        val = qn('w:val')
        if bool(value) is True:
            if val in self.attrib:
                del self.attrib[val]
        else:
            self.set(val, '0')


class CT_String(OxmlBaseElement):
    """
    Used for ``<w:pStyle>`` and ``<w:tblStyle>`` elements and others,
    containing a style name in its ``val`` attribute.
    """
    @classmethod
    def new(cls, nsptagname, val):
        """
        Return a new ``CT_String`` element with tagname *nsptagname* and
        ``val`` attribute set to *val*.
        """
        return OxmlElement(nsptagname, attrs={qn('w:val'): val})

    @classmethod
    def new_pStyle(cls, val):
        """
        Return a new ``<w:pStyle>`` element with ``val`` attribute set to
        *val*.
        """
        return OxmlElement('w:pStyle', attrs={qn('w:val'): val})

    @classmethod
    def new_rStyle(cls, val):
        """
        Return a new ``<w:rStyle>`` element with ``val`` attribute set to
        *val*.
        """
        return OxmlElement('w:rStyle', attrs={qn('w:val'): val})

    @property
    def val(self):
        return self.get(qn('w:val'))

    @val.setter
    def val(self, val):
        return self.set(qn('w:val'), val)

########NEW FILE########
__FILENAME__ = table
# encoding: utf-8

"""
Custom element classes for tables
"""

from __future__ import absolute_import, print_function, unicode_literals

from docx.oxml.shared import OxmlBaseElement, OxmlElement, qn

from .exceptions import ValidationError
from .shared import CT_String
from .text import CT_P


class CT_Row(OxmlBaseElement):
    """
    ``<w:tr>`` element
    """
    def add_tc(self):
        """
        Return a new <w:tc> element that has been added at the end of any
        existing tc elements.
        """
        tc = CT_Tc.new()
        return self._append_tc(tc)

    @classmethod
    def new(cls):
        """
        Return a new ``<w:tr>`` element.
        """
        return OxmlElement('w:tr')

    @property
    def tc_lst(self):
        """
        Sequence containing the ``<w:tc>`` child elements in this ``<w:tr>``.
        """
        return self.findall(qn('w:tc'))

    def _append_tc(self, tc):
        """
        Return *tc* after appending it to end of tc sequence.
        """
        self.append(tc)
        return tc


class CT_Tbl(OxmlBaseElement):
    """
    ``<w:tbl>`` element
    """
    def add_tr(self):
        """
        Return a new <w:tr> element that has been added at the end of any
        existing tr elements.
        """
        tr = CT_Row.new()
        return self._append_tr(tr)

    @classmethod
    def new(cls):
        """
        Return a new ``<w:tbl>`` element, containing the required
        ``<w:tblPr>`` and ``<w:tblGrid>`` child elements.
        """
        tbl = OxmlElement('w:tbl')
        tblPr = CT_TblPr.new()
        tbl.append(tblPr)
        tblGrid = CT_TblGrid.new()
        tbl.append(tblGrid)
        return tbl

    @property
    def tblGrid(self):
        tblGrid = self.find(qn('w:tblGrid'))
        if tblGrid is None:
            raise ValidationError('required w:tblGrid child not found')
        return tblGrid

    @property
    def tblPr(self):
        tblPr = self.find(qn('w:tblPr'))
        if tblPr is None:
            raise ValidationError('required w:tblPr child not found')
        return tblPr

    @property
    def tr_lst(self):
        """
        Sequence containing the ``<w:tr>`` child elements in this
        ``<w:tbl>``.
        """
        return self.findall(qn('w:tr'))

    def _append_tr(self, tr):
        """
        Return *tr* after appending it to end of tr sequence.
        """
        self.append(tr)
        return tr


class CT_TblGrid(OxmlBaseElement):
    """
    ``<w:tblGrid>`` element, child of ``<w:tbl>``, holds ``<w:gridCol>``
    elements that define column count, width, etc.
    """
    def add_gridCol(self):
        """
        Return a new <w:gridCol> element that has been added at the end of
        any existing gridCol elements.
        """
        gridCol = CT_TblGridCol.new()
        return self._append_gridCol(gridCol)

    @property
    def gridCol_lst(self):
        """
        Sequence containing the ``<w:gridCol>`` child elements in this
        ``<w:tblGrid>``.
        """
        return self.findall(qn('w:gridCol'))

    @classmethod
    def new(cls):
        """
        Return a new ``<w:tblGrid>`` element.
        """
        return OxmlElement('w:tblGrid')

    def _append_gridCol(self, gridCol):
        """
        Return *gridCol* after appending it to end of gridCol sequence.
        """
        successor = self.first_child_found_in('w:tblGridChange')
        if successor is not None:
            successor.addprevious(gridCol)
        else:
            self.append(gridCol)
        return gridCol

    def first_child_found_in(self, *tagnames):
        """
        Return the first child found with tag in *tagnames*, or None if
        not found.
        """
        for tagname in tagnames:
            child = self.find(qn(tagname))
            if child is not None:
                return child
        return None


class CT_TblGridCol(OxmlBaseElement):
    """
    ``<w:gridCol>`` element, child of ``<w:tblGrid>``, defines a table
    column.
    """
    @classmethod
    def new(cls):
        """
        Return a new ``<w:gridCol>`` element.
        """
        return OxmlElement('w:gridCol')


class CT_TblPr(OxmlBaseElement):
    """
    ``<w:tblPr>`` element, child of ``<w:tbl>``, holds child elements that
    define table properties such as style and borders.
    """
    def add_tblStyle(self, style_name):
        """
        Return a new <w:tblStyle> element newly inserted in sequence among
        the existing child elements, respecting the schema definition.
        """
        tblStyle = CT_String.new('w:tblStyle', style_name)
        return self._insert_tblStyle(tblStyle)

    @classmethod
    def new(cls):
        """
        Return a new ``<w:tblPr>`` element.
        """
        return OxmlElement('w:tblPr')

    @property
    def tblStyle(self):
        """
        Optional <w:tblStyle> child element, or |None| if not present.
        """
        return self.find(qn('w:tblStyle'))

    def _insert_tblStyle(self, tblStyle):
        """
        Return *tblStyle* after inserting it in sequence among the existing
        child elements. Assumes no ``<w:tblStyle>`` element is present.
        """
        assert self.tblStyle is None
        self.insert(0, tblStyle)
        return tblStyle


class CT_Tc(OxmlBaseElement):
    """
    ``<w:tc>`` table cell element
    """
    def add_p(self):
        """
        Return a new <w:p> element that has been added at the end of any
        existing cell content.
        """
        p = CT_P.new()
        self.append(p)
        return p

    def clear_content(self):
        """
        Remove all content child elements, preserving the ``<w:tcPr>``
        element if present.
        """
        new_children = []
        tcPr = self.tcPr
        if tcPr is not None:
            new_children.append(tcPr)
        self[:] = new_children

    @classmethod
    def new(cls):
        """
        Return a new ``<w:tc>`` element, containing an empty paragraph as the
        required EG_BlockLevelElt.
        """
        tc = OxmlElement('w:tc')
        p = CT_P.new()
        tc.append(p)
        return tc

    @property
    def p_lst(self):
        """
        List of <w:p> child elements.
        """
        return self.findall(qn('w:p'))

    @property
    def tcPr(self):
        """
        <w:tcPr> child element or |None| if not present.
        """
        return self.find(qn('w:tcPr'))

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
Custom element classes related to text, such as paragraph (CT_P) and runs
(CT_R).
"""

from docx.enum.text import WD_UNDERLINE
from docx.oxml.parts.numbering import CT_NumPr
from docx.oxml.shared import (
    CT_String, nsdecls, OxmlBaseElement, OxmlElement, oxml_fromstring, qn
)


class CT_Br(OxmlBaseElement):
    """
    ``<w:br>`` element, indicating a line, page, or column break in a run.
    """
    @classmethod
    def new(cls):
        """
        Return a new ``<w:br>`` element.
        """
        return OxmlElement('w:br')

    @property
    def clear(self):
        self.get(qn('w:clear'))

    @clear.setter
    def clear(self, clear_str):
        self.set(qn('w:clear'), clear_str)

    @property
    def type(self):
        return self.get(qn('w:type'))

    @type.setter
    def type(self, type_str):
        self.set(qn('w:type'), type_str)


class CT_P(OxmlBaseElement):
    """
    ``<w:p>`` element, containing the properties and text for a paragraph.
    """
    def add_r(self):
        """
        Return a newly added CT_R (<w:r>) element.
        """
        r = CT_R.new()
        self.append(r)
        return r

    def get_or_add_pPr(self):
        """
        Return the pPr child element, newly added if not present.
        """
        pPr = self.pPr
        if pPr is None:
            pPr = self._add_pPr()
        return pPr

    @staticmethod
    def new():
        """
        Return a new ``<w:p>`` element.
        """
        xml = '<w:p %s/>' % nsdecls('w')
        p = oxml_fromstring(xml)
        return p

    @property
    def pPr(self):
        """
        ``<w:pPr>`` child element or None if not present.
        """
        return self.find(qn('w:pPr'))

    @property
    def r_lst(self):
        """
        Sequence containing a reference to each run element in this paragraph.
        """
        return self.findall(qn('w:r'))

    @property
    def style(self):
        """
        String contained in w:val attribute of <w:pPr><w:pStyle> child, or
        None if that element is not present.
        """
        pPr = self.pPr
        if pPr is None:
            return None
        return pPr.style

    @style.setter
    def style(self, style):
        """
        Set style of this <w:p> element to *style*. If *style* is None,
        remove the style element.
        """
        pPr = self.get_or_add_pPr()
        pPr.style = style

    def _add_pPr(self):
        """
        Return a newly added pPr child element. Assumes one is not present.
        """
        pPr = CT_PPr.new()
        self.insert(0, pPr)
        return pPr


class CT_PPr(OxmlBaseElement):
    """
    ``<w:pPr>`` element, containing the properties for a paragraph.
    """
    def get_or_add_numPr(self):
        """
        Return the numPr child element, newly added if not present.
        """
        numPr = self.numPr
        if numPr is None:
            numPr = self._add_numPr()
        return numPr

    def get_or_add_pStyle(self):
        """
        Return the pStyle child element, newly added if not present.
        """
        pStyle = self.pStyle
        if pStyle is None:
            pStyle = self._add_pStyle()
        return pStyle

    @staticmethod
    def new():
        """
        Return a new ``<w:pPr>`` element.
        """
        xml = '<w:pPr %s/>' % nsdecls('w')
        pPr = oxml_fromstring(xml)
        return pPr

    @property
    def numPr(self):
        """
        ``<w:numPr>`` child element or None if not present.
        """
        return self.find(qn('w:numPr'))

    @property
    def pStyle(self):
        """
        ``<w:pStyle>`` child element or None if not present.
        """
        return self.find(qn('w:pStyle'))

    def remove_pStyle(self):
        pStyle = self.pStyle
        if pStyle is not None:
            self.remove(pStyle)

    @property
    def style(self):
        """
        String contained in <w:pStyle> child, or None if that element is not
        present.
        """
        pStyle = self.pStyle
        if pStyle is None:
            return None
        return pStyle.get(qn('w:val'))

    @style.setter
    def style(self, style):
        """
        Set val attribute of <w:pStyle> child element to *style*, adding a
        new element if necessary. If *style* is |None|, remove the <w:pStyle>
        element if present.
        """
        if style is None:
            self.remove_pStyle()
        elif self.pStyle is None:
            self._add_pStyle(style)
        else:
            self.pStyle.val = style

    def _add_numPr(self):
        numPr = CT_NumPr.new()
        return self._insert_numPr(numPr)

    def _add_pStyle(self, style):
        pStyle = CT_String.new_pStyle(style)
        return self._insert_pStyle(pStyle)

    def _insert_numPr(self, numPr):
        return self.insert_element_before(
            numPr, 'w:suppressLineNumbers', 'w:pBdr', 'w:shd', 'w:tabs',
            'w:suppressAutoHyphens', 'w:kinsoku', 'w:wordWrap',
            'w:overflowPunct', 'w:topLinePunct', 'w:autoSpaceDE',
            'w:autoSpaceDN', 'w:bidi', 'w:adjustRightInd', 'w:snapToGrid',
            'w:spacing', 'w:ind', 'w:contextualSpacing', 'w:mirrorIndents',
            'w:suppressOverlap', 'w:jc', 'w:textDirection',
            'w:textAlignment', 'w:textboxTightWrap', 'w:outlineLvl',
            'w:divId', 'w:cnfStyle', 'w:rPr', 'w:sectPr', 'w:pPrChange'
        )

    def _insert_pStyle(self, pStyle):
        self.insert(0, pStyle)
        return pStyle


class CT_R(OxmlBaseElement):
    """
    ``<w:r>`` element, containing the properties and text for a run.
    """
    def add_br(self):
        """
        Return a newly appended CT_Br (<w:br>) child element.
        """
        br = CT_Br.new()
        self.append(br)
        return br

    def add_drawing(self, inline_or_anchor):
        """
        Return a newly appended ``CT_Drawing`` (``<w:drawing>``) child
        element having *inline_or_anchor* as its child.
        """
        drawing = OxmlElement('w:drawing')
        self.append(drawing)
        drawing.append(inline_or_anchor)
        return drawing

    def add_t(self, text):
        """
        Return a newly added CT_T (<w:t>) element containing *text*.
        """
        t = CT_Text.new(text)
        if len(text.strip()) < len(text):
            t.set(qn('xml:space'), 'preserve')
        self.append(t)
        return t

    def get_or_add_rPr(self):
        """
        Return the rPr child element, newly added if not present.
        """
        rPr = self.rPr
        if rPr is None:
            rPr = self._add_rPr()
        return rPr

    @classmethod
    def new(cls):
        """
        Return a new ``<w:r>`` element.
        """
        return OxmlElement('w:r')

    @property
    def rPr(self):
        """
        ``<w:rPr>`` child element or None if not present.
        """
        return self.find(qn('w:rPr'))

    @property
    def style(self):
        """
        String contained in w:val attribute of <w:rStyle> grandchild, or
        |None| if that element is not present.
        """
        rPr = self.rPr
        if rPr is None:
            return None
        return rPr.style

    @style.setter
    def style(self, style):
        """
        Set the character style of this <w:r> element to *style*. If *style*
        is None, remove the style element.
        """
        rPr = self.get_or_add_rPr()
        rPr.style = style

    @property
    def t_lst(self):
        """
        Sequence of <w:t> elements in this paragraph.
        """
        return self.findall(qn('w:t'))

    @property
    def underline(self):
        """
        String contained in w:val attribute of <w:u> grandchild, or |None| if
        that element is not present.
        """
        rPr = self.rPr
        if rPr is None:
            return None
        return rPr.underline

    @underline.setter
    def underline(self, value):
        rPr = self.get_or_add_rPr()
        rPr.underline = value

    def _add_rPr(self):
        """
        Return a newly added rPr child element. Assumes one is not present.
        """
        rPr = CT_RPr.new()
        self.insert(0, rPr)
        return rPr


class CT_RPr(OxmlBaseElement):
    """
    ``<w:rPr>`` element, containing the properties for a run.
    """
    def add_b(self):
        """
        Return a newly added <w:b/> child element.
        """
        b = OxmlElement('w:b')
        self.insert(0, b)
        return b

    def add_bCs(self):
        """
        Return a newly added <w:bCs/> child element.
        """
        bCs = OxmlElement('w:bCs')
        self.insert(0, bCs)
        return bCs

    def add_caps(self):
        """
        Return a newly added <w:caps/> child element.
        """
        caps = OxmlElement('w:caps')
        self.insert(0, caps)
        return caps

    def add_cs(self):
        """
        Return a newly added <w:cs/> child element.
        """
        cs = OxmlElement('w:cs')
        self.insert(0, cs)
        return cs

    def add_dstrike(self):
        """
        Return a newly added <w:dstrike/> child element.
        """
        dstrike = OxmlElement('w:dstrike')
        self.insert(0, dstrike)
        return dstrike

    def add_emboss(self):
        """
        Return a newly added <w:emboss/> child element.
        """
        emboss = OxmlElement('w:emboss')
        self.insert(0, emboss)
        return emboss

    def add_i(self):
        """
        Return a newly added <w:i/> child element.
        """
        i = OxmlElement('w:i')
        self.insert(0, i)
        return i

    def add_iCs(self):
        """
        Return a newly added <w:iCs/> child element.
        """
        iCs = OxmlElement('w:iCs')
        self.insert(0, iCs)
        return iCs

    def add_imprint(self):
        """
        Return a newly added <w:imprint/> child element.
        """
        imprint = OxmlElement('w:imprint')
        self.insert(0, imprint)
        return imprint

    def add_noProof(self):
        """
        Return a newly added <w:noProof/> child element.
        """
        noProof = OxmlElement('w:noProof')
        self.insert(0, noProof)
        return noProof

    def add_oMath(self):
        """
        Return a newly added <w:oMath/> child element.
        """
        oMath = OxmlElement('w:oMath')
        self.insert(0, oMath)
        return oMath

    def add_outline(self):
        """
        Return a newly added <w:outline/> child element.
        """
        outline = OxmlElement('w:outline')
        self.insert(0, outline)
        return outline

    def add_rtl(self):
        """
        Return a newly added <w:rtl/> child element.
        """
        rtl = OxmlElement('w:rtl')
        self.insert(0, rtl)
        return rtl

    def add_shadow(self):
        """
        Return a newly added <w:shadow/> child element.
        """
        shadow = OxmlElement('w:shadow')
        self.insert(0, shadow)
        return shadow

    def add_smallCaps(self):
        """
        Return a newly added <w:smallCaps/> child element.
        """
        smallCaps = OxmlElement('w:smallCaps')
        self.insert(0, smallCaps)
        return smallCaps

    def add_snapToGrid(self):
        """
        Return a newly added <w:snapToGrid/> child element.
        """
        snapToGrid = OxmlElement('w:snapToGrid')
        self.insert(0, snapToGrid)
        return snapToGrid

    def add_specVanish(self):
        """
        Return a newly added <w:specVanish/> child element.
        """
        specVanish = OxmlElement('w:specVanish')
        self.insert(0, specVanish)
        return specVanish

    def add_strike(self):
        """
        Return a newly added <w:strike/> child element.
        """
        strike = OxmlElement('w:strike')
        self.insert(0, strike)
        return strike

    def add_vanish(self):
        """
        Return a newly added <w:vanish/> child element.
        """
        vanish = OxmlElement('w:vanish')
        self.insert(0, vanish)
        return vanish

    def add_webHidden(self):
        """
        Return a newly added <w:webHidden/> child element.
        """
        webHidden = OxmlElement('w:webHidden')
        self.insert(0, webHidden)
        return webHidden

    @property
    def b(self):
        """
        First ``<w:b>`` child element or None if none are present.
        """
        return self.find(qn('w:b'))

    @property
    def bCs(self):
        """
        First ``<w:bCs>`` child element or None if none are present.
        """
        return self.find(qn('w:bCs'))

    @property
    def caps(self):
        """
        First ``<w:caps>`` child element or None if none are present.
        """
        return self.find(qn('w:caps'))

    @property
    def cs(self):
        """
        First ``<w:cs>`` child element or None if none are present.
        """
        return self.find(qn('w:cs'))

    @property
    def dstrike(self):
        """
        First ``<w:dstrike>`` child element or None if none are present.
        """
        return self.find(qn('w:dstrike'))

    @property
    def emboss(self):
        """
        First ``<w:emboss>`` child element or None if none are present.
        """
        return self.find(qn('w:emboss'))

    @property
    def i(self):
        """
        First ``<w:i>`` child element or None if none are present.
        """
        return self.find(qn('w:i'))

    @property
    def iCs(self):
        """
        First ``<w:iCs>`` child element or None if none are present.
        """
        return self.find(qn('w:iCs'))

    @property
    def imprint(self):
        """
        First ``<w:imprint>`` child element or None if none are present.
        """
        return self.find(qn('w:imprint'))

    @classmethod
    def new(cls):
        """
        Return a new ``<w:rPr>`` element.
        """
        return OxmlElement('w:rPr')

    @property
    def noProof(self):
        """
        First ``<w:noProof>`` child element or None if none are present.
        """
        return self.find(qn('w:noProof'))

    @property
    def oMath(self):
        """
        First ``<w:oMath>`` child element or None if none are present.
        """
        return self.find(qn('w:oMath'))

    @property
    def outline(self):
        """
        First ``<w:outline>`` child element or None if none are present.
        """
        return self.find(qn('w:outline'))

    def remove_b(self):
        b_lst = self.findall(qn('w:b'))
        for b in b_lst:
            self.remove(b)

    def remove_bCs(self):
        bCs_lst = self.findall(qn('w:bCs'))
        for bCs in bCs_lst:
            self.remove(bCs)

    def remove_caps(self):
        caps_lst = self.findall(qn('w:caps'))
        for caps in caps_lst:
            self.remove(caps)

    def remove_cs(self):
        cs_lst = self.findall(qn('w:cs'))
        for cs in cs_lst:
            self.remove(cs)

    def remove_dstrike(self):
        dstrike_lst = self.findall(qn('w:dstrike'))
        for dstrike in dstrike_lst:
            self.remove(dstrike)

    def remove_emboss(self):
        emboss_lst = self.findall(qn('w:emboss'))
        for emboss in emboss_lst:
            self.remove(emboss)

    def remove_i(self):
        i_lst = self.findall(qn('w:i'))
        for i in i_lst:
            self.remove(i)

    def remove_iCs(self):
        iCs_lst = self.findall(qn('w:iCs'))
        for iCs in iCs_lst:
            self.remove(iCs)

    def remove_imprint(self):
        imprint_lst = self.findall(qn('w:imprint'))
        for imprint in imprint_lst:
            self.remove(imprint)

    def remove_noProof(self):
        noProof_lst = self.findall(qn('w:noProof'))
        for noProof in noProof_lst:
            self.remove(noProof)

    def remove_oMath(self):
        oMath_lst = self.findall(qn('w:oMath'))
        for oMath in oMath_lst:
            self.remove(oMath)

    def remove_outline(self):
        outline_lst = self.findall(qn('w:outline'))
        for outline in outline_lst:
            self.remove(outline)

    def remove_rStyle(self):
        rStyle = self.rStyle
        if rStyle is not None:
            self.remove(rStyle)

    def remove_rtl(self):
        rtl_lst = self.findall(qn('w:rtl'))
        for rtl in rtl_lst:
            self.remove(rtl)

    def remove_shadow(self):
        shadow_lst = self.findall(qn('w:shadow'))
        for shadow in shadow_lst:
            self.remove(shadow)

    def remove_smallCaps(self):
        smallCaps_lst = self.findall(qn('w:smallCaps'))
        for smallCaps in smallCaps_lst:
            self.remove(smallCaps)

    def remove_snapToGrid(self):
        snapToGrid_lst = self.findall(qn('w:snapToGrid'))
        for snapToGrid in snapToGrid_lst:
            self.remove(snapToGrid)

    def remove_specVanish(self):
        specVanish_lst = self.findall(qn('w:specVanish'))
        for specVanish in specVanish_lst:
            self.remove(specVanish)

    def remove_strike(self):
        strike_lst = self.findall(qn('w:strike'))
        for strike in strike_lst:
            self.remove(strike)

    def remove_u(self):
        u_lst = self.findall(qn('w:u'))
        for u in u_lst:
            self.remove(u)

    def remove_vanish(self):
        vanish_lst = self.findall(qn('w:vanish'))
        for vanish in vanish_lst:
            self.remove(vanish)

    def remove_webHidden(self):
        webHidden_lst = self.findall(qn('w:webHidden'))
        for webHidden in webHidden_lst:
            self.remove(webHidden)

    @property
    def rStyle(self):
        """
        ``<w:rStyle>`` child element or None if not present.
        """
        return self.find(qn('w:rStyle'))

    @property
    def rtl(self):
        """
        First ``<w:rtl>`` child element or None if none are present.
        """
        return self.find(qn('w:rtl'))

    @property
    def shadow(self):
        """
        First ``<w:shadow>`` child element or None if none are present.
        """
        return self.find(qn('w:shadow'))

    @property
    def smallCaps(self):
        """
        First ``<w:smallCaps>`` child element or None if none are present.
        """
        return self.find(qn('w:smallCaps'))

    @property
    def snapToGrid(self):
        """
        First ``<w:snapToGrid>`` child element or None if none are present.
        """
        return self.find(qn('w:snapToGrid'))

    @property
    def specVanish(self):
        """
        First ``<w:specVanish>`` child element or None if none are present.
        """
        return self.find(qn('w:specVanish'))

    @property
    def strike(self):
        """
        First ``<w:strike>`` child element or None if none are present.
        """
        return self.find(qn('w:strike'))

    @property
    def style(self):
        """
        String contained in <w:rStyle> child, or None if that element is not
        present.
        """
        rStyle = self.rStyle
        if rStyle is None:
            return None
        return rStyle.val

    @style.setter
    def style(self, style):
        """
        Set val attribute of <w:rStyle> child element to *style*, adding a
        new element if necessary. If *style* is |None|, remove the <w:rStyle>
        element if present.
        """
        if style is None:
            self.remove_rStyle()
        elif self.rStyle is None:
            self._add_rStyle(style)
        else:
            self.rStyle.val = style

    @property
    def u(self):
        """
        First ``<w:u>`` child element or |None| if none are present.
        """
        return self.find(qn('w:u'))

    @property
    def underline(self):
        """
        Underline type specified in <w:u> child, or None if that element is
        not present.
        """
        u = self.u
        if u is None:
            return None
        return u.val

    @underline.setter
    def underline(self, value):
        self.remove_u()
        if value is not None:
            u = self._add_u()
            u.val = value

    @property
    def vanish(self):
        """
        First ``<w:vanish>`` child element or None if none are present.
        """
        return self.find(qn('w:vanish'))

    @property
    def webHidden(self):
        """
        First ``<w:webHidden>`` child element or None if none are present.
        """
        return self.find(qn('w:webHidden'))

    def _add_rStyle(self, style):
        rStyle = CT_String.new_rStyle(style)
        self.insert(0, rStyle)
        return rStyle

    def _add_u(self):
        """
        Return a newly added <w:u/> child element.
        """
        u = OxmlElement('w:u')
        self.insert(0, u)
        return u


class CT_Text(OxmlBaseElement):
    """
    ``<w:t>`` element, containing a sequence of characters within a run.
    """
    @classmethod
    def new(cls, text):
        """
        Return a new ``<w:t>`` element.
        """
        t = OxmlElement('w:t')
        t.text = text
        return t


class CT_Underline(OxmlBaseElement):
    """
    ``<w:u>`` element, specifying the underlining style for a run.
    """
    @property
    def val(self):
        """
        The underline type corresponding to the ``w:val`` attribute value.
        """
        underline_type_map = {
            None:              None,
            'none':            False,
            'single':          True,
            'words':           WD_UNDERLINE.WORDS,
            'double':          WD_UNDERLINE.DOUBLE,
            'dotted':          WD_UNDERLINE.DOTTED,
            'thick':           WD_UNDERLINE.THICK,
            'dash':            WD_UNDERLINE.DASH,
            'dotDash':         WD_UNDERLINE.DOT_DASH,
            'dotDotDash':      WD_UNDERLINE.DOT_DOT_DASH,
            'wave':            WD_UNDERLINE.WAVY,
            'dottedHeavy':     WD_UNDERLINE.DOTTED_HEAVY,
            'dashedHeavy':     WD_UNDERLINE.DASH_HEAVY,
            'dashDotHeavy':    WD_UNDERLINE.DOT_DASH_HEAVY,
            'dashDotDotHeavy': WD_UNDERLINE.DOT_DOT_DASH_HEAVY,
            'wavyHeavy':       WD_UNDERLINE.WAVY_HEAVY,
            'dashLong':        WD_UNDERLINE.DASH_LONG,
            'wavyDouble':      WD_UNDERLINE.WAVY_DOUBLE,
            'dashLongHeavy':   WD_UNDERLINE.DASH_LONG_HEAVY,
        }
        val = self.get(qn('w:val'))
        return underline_type_map[val]

    @val.setter
    def val(self, value):
        underline_vals = {
            True:                            'single',
            False:                           'none',
            WD_UNDERLINE.WORDS:              'words',
            WD_UNDERLINE.DOUBLE:             'double',
            WD_UNDERLINE.DOTTED:             'dotted',
            WD_UNDERLINE.THICK:              'thick',
            WD_UNDERLINE.DASH:               'dash',
            WD_UNDERLINE.DOT_DASH:           'dotDash',
            WD_UNDERLINE.DOT_DOT_DASH:       'dotDotDash',
            WD_UNDERLINE.WAVY:               'wave',
            WD_UNDERLINE.DOTTED_HEAVY:       'dottedHeavy',
            WD_UNDERLINE.DASH_HEAVY:         'dashedHeavy',
            WD_UNDERLINE.DOT_DASH_HEAVY:     'dashDotHeavy',
            WD_UNDERLINE.DOT_DOT_DASH_HEAVY: 'dashDotDotHeavy',
            WD_UNDERLINE.WAVY_HEAVY:         'wavyHeavy',
            WD_UNDERLINE.DASH_LONG:          'dashLong',
            WD_UNDERLINE.WAVY_DOUBLE:        'wavyDouble',
            WD_UNDERLINE.DASH_LONG_HEAVY:    'dashLongHeavy',
        }
        val = underline_vals[value]
        self.set(qn('w:val'), val)

########NEW FILE########
__FILENAME__ = package
# encoding: utf-8

"""
WordprocessingML Package class and related objects
"""

from __future__ import absolute_import, print_function, unicode_literals

from docx.image.image import Image
from docx.opc.constants import RELATIONSHIP_TYPE as RT
from docx.opc.package import OpcPackage
from docx.opc.packuri import PackURI
from docx.parts.image import ImagePart
from docx.shared import lazyproperty


class Package(OpcPackage):
    """
    Customizations specific to a WordprocessingML package.
    """
    def after_unmarshal(self):
        """
        Called by loading code after all parts and relationships have been
        loaded, to afford the opportunity for any required post-processing.
        """
        self._gather_image_parts()

    @lazyproperty
    def image_parts(self):
        """
        Collection of all image parts in this package.
        """
        return ImageParts()

    def _gather_image_parts(self):
        """
        Load the image part collection with all the image parts in package.
        """
        for rel in self.iter_rels():
            if rel.is_external:
                continue
            if rel.reltype != RT.IMAGE:
                continue
            if rel.target_part in self.image_parts:
                continue
            self.image_parts.append(rel.target_part)


class ImageParts(object):
    """
    Collection of |ImagePart| instances corresponding to each image part in
    the package.
    """
    def __init__(self):
        super(ImageParts, self).__init__()
        self._image_parts = []

    def __contains__(self, item):
        return self._image_parts.__contains__(item)

    def __iter__(self):
        return self._image_parts.__iter__()

    def __len__(self):
        return self._image_parts.__len__()

    def append(self, item):
        self._image_parts.append(item)

    def get_or_add_image_part(self, image_descriptor):
        """
        Return an |ImagePart| instance containing the image identified by
        *image_descriptor*, newly created if a matching one is not present in
        the collection.
        """
        image = Image.from_file(image_descriptor)
        matching_image_part = self._get_by_sha1(image.sha1)
        if matching_image_part is not None:
            return matching_image_part
        return self._add_image_part(image)

    def _add_image_part(self, image):
        """
        Return an |ImagePart| instance newly created from image and appended
        to the collection.
        """
        partname = self._next_image_partname(image.ext)
        image_part = ImagePart.from_image(image, partname)
        self.append(image_part)
        return image_part

    def _get_by_sha1(self, sha1):
        """
        Return the image part in this collection having a SHA1 hash matching
        *sha1*, or |None| if not found.
        """
        for image_part in self._image_parts:
            if image_part.sha1 == sha1:
                return image_part
        return None

    def _next_image_partname(self, ext):
        """
        The next available image partname, starting from
        ``/word/media/image1.{ext}`` where unused numbers are reused. The
        partname is unique by number, without regard to the extension. *ext*
        does not include the leading period.
        """
        def image_partname(n):
            return PackURI('/word/media/image%d.%s' % (n, ext))
        used_numbers = [image_part.partname.idx for image_part in self]
        for n in range(1, len(self)+1):
            if not n in used_numbers:
                return image_partname(n)
        return image_partname(len(self)+1)

########NEW FILE########
__FILENAME__ = document
# encoding: utf-8

"""
|DocumentPart| and closely related objects
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

from ..opc.constants import RELATIONSHIP_TYPE as RT
from ..opc.oxml import serialize_part_xml
from ..opc.package import Part
from ..oxml.shared import nsmap, oxml_fromstring
from ..shape import InlineShape
from ..shared import lazyproperty, Parented
from ..table import Table
from ..text import Paragraph


class DocumentPart(Part):
    """
    Main document part of a WordprocessingML (WML) package, aka a .docx file.
    """
    def __init__(self, partname, content_type, document_elm, package):
        super(DocumentPart, self).__init__(
            partname, content_type, package=package
        )
        self._element = document_elm

    def add_paragraph(self):
        """
        Return a paragraph newly added to the end of body content.
        """
        return self.body.add_paragraph()

    def add_table(self, rows, cols):
        """
        Return a table having *rows* rows and *cols* columns, newly appended
        to the main document story.
        """
        return self.body.add_table(rows, cols)

    @property
    def blob(self):
        return serialize_part_xml(self._element)

    @lazyproperty
    def body(self):
        """
        The |_Body| instance containing the content for this document.
        """
        return _Body(self._element.body)

    def get_or_add_image_part(self, image_descriptor):
        """
        Return an ``(image_part, rId)`` 2-tuple for the image identified by
        *image_descriptor*. *image_part* is an |Image| instance corresponding
        to the image, newly created if no matching image part is found. *rId*
        is the key for the relationship between this document part and the
        image part, reused if already present, newly created if not.
        """
        image_parts = self._package.image_parts
        image_part = image_parts.get_or_add_image_part(image_descriptor)
        rId = self.relate_to(image_part, RT.IMAGE)
        return (image_part, rId)

    @lazyproperty
    def inline_shapes(self):
        """
        The |InlineShapes| instance containing the inline shapes in the
        document.
        """
        return InlineShapes(self._element.body, self)

    @classmethod
    def load(cls, partname, content_type, blob, package):
        document_elm = oxml_fromstring(blob)
        document_part = cls(partname, content_type, document_elm, package)
        return document_part

    @property
    def next_id(self):
        """
        The next available positive integer id value in this document. Gaps
        in id sequence are filled. The id attribute value is unique in the
        document, without regard to the element type it appears on.
        """
        id_str_lst = self._element.xpath('//@id')
        used_ids = [int(id_str) for id_str in id_str_lst if id_str.isdigit()]
        for n in range(1, len(used_ids)+2):
            if n not in used_ids:
                return n

    @property
    def paragraphs(self):
        """
        A list of |Paragraph| instances corresponding to the paragraphs in
        the document, in document order. Note that paragraphs within revision
        marks such as inserted or deleted do not appear in this list.
        """
        return self.body.paragraphs

    @property
    def part(self):
        """
        Part of the parent protocol, "children" of the document will not know
        the part that contains them so must ask their parent object. That
        chain of delegation ends here for document child objects.
        """
        return self

    @property
    def tables(self):
        """
        A list of |Table| instances corresponding to the tables in the
        document, in document order. Note that tables within revision marks
        such as ``<w:ins>`` or ``<w:del>`` do not appear in this list.
        """
        return self.body.tables


class _Body(object):
    """
    Proxy for ``<w:body>`` element in this document, having primarily a
    container role.
    """
    def __init__(self, body_elm):
        super(_Body, self).__init__()
        self._body = body_elm

    def add_paragraph(self):
        """
        Return a paragraph newly added to the end of body content.
        """
        p = self._body.add_p()
        return Paragraph(p)

    def add_table(self, rows, cols):
        """
        Return a table having *rows* rows and *cols* cols, newly appended to
        the main document story.
        """
        tbl = self._body.add_tbl()
        table = Table(tbl)
        for i in range(cols):
            table.add_column()
        for i in range(rows):
            table.add_row()
        return table

    def clear_content(self):
        """
        Return this |_Body| instance after clearing it of all content.
        Section properties for the main document story, if present, are
        preserved.
        """
        self._body.clear_content()
        return self

    @property
    def paragraphs(self):
        return [Paragraph(p) for p in self._body.p_lst]

    @property
    def tables(self):
        """
        A sequence containing all the tables in the document, in the order
        they appear.
        """
        return [Table(tbl) for tbl in self._body.tbl_lst]


class InlineShapes(Parented):
    """
    Sequence of |InlineShape| instances, supporting len(), iteration, and
    indexed access.
    """
    def __init__(self, body_elm, parent):
        super(InlineShapes, self).__init__(parent)
        self._body = body_elm

    def __getitem__(self, idx):
        """
        Provide indexed access, e.g. 'inline_shapes[idx]'
        """
        try:
            inline = self._inline_lst[idx]
        except IndexError:
            msg = "inline shape index [%d] out of range" % idx
            raise IndexError(msg)
        return InlineShape(inline)

    def __iter__(self):
        return (InlineShape(inline) for inline in self._inline_lst)

    def __len__(self):
        return len(self._inline_lst)

    def add_picture(self, image_descriptor):
        """
        Add the image identified by *image_descriptor* to the document at its
        native size. The picture is placed inline in a new paragraph at the
        end of the document. *image_descriptor* can be a path (a string) or a
        file-like object containing a binary image.
        """
        image_part, rId = self.part.get_or_add_image_part(image_descriptor)
        shape_id = self.part.next_id
        r = self._body.add_p().add_r()
        return InlineShape.new_picture(r, image_part, rId, shape_id)

    @property
    def _inline_lst(self):
        body = self._body
        xpath = './w:p/w:r/w:drawing/wp:inline'
        return body.xpath(xpath, namespaces=nsmap)

########NEW FILE########
__FILENAME__ = image
# encoding: utf-8

"""
The proxy class for an image part, and related objects.
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

import hashlib

from docx.image.image import Image
from docx.opc.package import Part
from docx.shared import Emu, Inches


class ImagePart(Part):
    """
    An image part. Corresponds to the target part of a relationship with type
    RELATIONSHIP_TYPE.IMAGE.
    """
    def __init__(self, partname, content_type, blob, image=None):
        super(ImagePart, self).__init__(partname, content_type, blob)
        self._image = image

    @property
    def default_cx(self):
        """
        Native width of this image, calculated from its width in pixels and
        horizontal dots per inch (dpi).
        """
        px_width = self.image.px_width
        horz_dpi = self.image.horz_dpi
        width_in_inches = px_width / horz_dpi
        return Inches(width_in_inches)

    @property
    def default_cy(self):
        """
        Native height of this image, calculated from its height in pixels and
        vertical dots per inch (dpi).
        """
        px_height = self.image.px_height
        horz_dpi = self.image.horz_dpi
        height_in_emu = 914400 * px_height / horz_dpi
        return Emu(height_in_emu)

    @property
    def filename(self):
        """
        Filename from which this image part was originally created. A generic
        name, e.g. 'image.png', is substituted if no name is available, for
        example when the image was loaded from an unnamed stream. In that
        case a default extension is applied based on the detected MIME type
        of the image.
        """
        if self._image is not None:
            return self._image.filename
        return 'image.%s' % self.partname.ext

    @classmethod
    def from_image(cls, image, partname):
        """
        Return an |ImagePart| instance newly created from *image* and
        assigned *partname*.
        """
        return ImagePart(partname, image.content_type, image.blob, image)

    @property
    def image(self):
        if self._image is None:
            self._image = Image.from_blob(self.blob)
        return self._image

    @classmethod
    def load(cls, partname, content_type, blob, package):
        """
        Called by ``docx.opc.package.PartFactory`` to load an image part from
        a package being opened by ``Document(...)`` call.
        """
        return cls(partname, content_type, blob)

    @property
    def sha1(self):
        """
        SHA1 hash digest of the blob of this image part.
        """
        return hashlib.sha1(self._blob).hexdigest()

########NEW FILE########
__FILENAME__ = numbering
# encoding: utf-8

"""
|NumberingPart| and closely related objects
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

from ..opc.package import Part
from ..oxml.shared import oxml_fromstring
from ..shared import lazyproperty


class NumberingPart(Part):
    """
    Proxy for the numbering.xml part containing numbering definitions for
    a document or glossary.
    """
    def __init__(self, partname, content_type, element, package):
        super(NumberingPart, self).__init__(
            partname, content_type, element=element, package=package
        )

    @classmethod
    def load(cls, partname, content_type, blob, package):
        """
        Provides PartFactory interface for loading a numbering part from
        a WML package.
        """
        numbering_elm = oxml_fromstring(blob)
        numbering_part = cls(partname, content_type, numbering_elm, package)
        return numbering_part

    @classmethod
    def new(cls):
        """
        Return newly created empty numbering part, containing only the root
        ``<w:numbering>`` element.
        """
        raise NotImplementedError

    @lazyproperty
    def numbering_definitions(self):
        """
        The |_NumberingDefinitions| instance containing the numbering
        definitions (<w:num> element proxies) for this numbering part.
        """
        return _NumberingDefinitions(self._element)


class _NumberingDefinitions(object):
    """
    Collection of |_NumberingDefinition| instances corresponding to the
    ``<w:num>`` elements in a numbering part.
    """
    def __init__(self, numbering_elm):
        super(_NumberingDefinitions, self).__init__()
        self._numbering = numbering_elm

    def __len__(self):
        return len(self._numbering.num_lst)

########NEW FILE########
__FILENAME__ = styles
# encoding: utf-8

"""
Provides StylesPart and related objects
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

from ..opc.package import Part
from ..oxml.shared import oxml_fromstring
from ..shared import lazyproperty


class StylesPart(Part):
    """
    Proxy for the styles.xml part containing style definitions for a document
    or glossary.
    """
    def __init__(self, partname, content_type, element, package):
        super(StylesPart, self).__init__(
            partname, content_type, element=element, package=package
        )

    @classmethod
    def load(cls, partname, content_type, blob, package):
        """
        Provides PartFactory interface for loading a styles part from a WML
        package.
        """
        styles_elm = oxml_fromstring(blob)
        styles_part = cls(partname, content_type, styles_elm, package)
        return styles_part

    @classmethod
    def new(cls):
        """
        Return newly created empty styles part, containing only the root
        ``<w:styles>`` element.
        """
        raise NotImplementedError

    @lazyproperty
    def styles(self):
        """
        The |_Styles| instance containing the styles (<w:style> element
        proxies) for this styles part.
        """
        return _Styles(self._element)


class _Styles(object):
    """
    Collection of |_Style| instances corresponding to the ``<w:style>``
    elements in a styles part.
    """
    def __init__(self, styles_elm):
        super(_Styles, self).__init__()
        self._styles_elm = styles_elm

    def __len__(self):
        return len(self._styles_elm.style_lst)

########NEW FILE########
__FILENAME__ = shape
# encoding: utf-8

"""
Objects related to shapes, visual objects that appear on the drawing layer of
a document.
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

from docx.enum.shape import WD_INLINE_SHAPE
from docx.oxml.shape import CT_Inline, CT_Picture
from docx.oxml.shared import nsmap


class InlineShape(object):
    """
    Proxy for an ``<wp:inline>`` element, representing the container for an
    inline graphical object.
    """
    def __init__(self, inline):
        super(InlineShape, self).__init__()
        self._inline = inline

    @property
    def height(self):
        """
        Read/write. The display height of this inline shape as an |Emu|
        instance.
        """
        return self._inline.extent.cy

    @height.setter
    def height(self, cy):
        assert isinstance(cy, int)
        assert 0 < cy
        self._inline.extent.cy = cy

    @classmethod
    def new_picture(cls, r, image_part, rId, shape_id):
        """
        Return a new |InlineShape| instance containing an inline picture
        placement of *image_part* appended to run *r* and uniquely identified
        by *shape_id*.
        """
        cx, cy, filename = (
            image_part.default_cx, image_part.default_cy, image_part.filename
        )
        pic_id = 0
        pic = CT_Picture.new(pic_id, filename, rId, cx, cy)
        inline = CT_Inline.new(cx, cy, shape_id, pic)
        r.add_drawing(inline)
        return cls(inline)

    @property
    def type(self):
        """
        The type of this inline shape as a member of
        ``docx.enum.shape.WD_INLINE_SHAPE``, e.g. ``LINKED_PICTURE``.
        Read-only.
        """
        graphicData = self._inline.graphic.graphicData
        uri = graphicData.uri
        if uri == nsmap['pic']:
            blip = graphicData.pic.blipFill.blip
            if blip.link is not None:
                return WD_INLINE_SHAPE.LINKED_PICTURE
            return WD_INLINE_SHAPE.PICTURE
        if uri == nsmap['c']:
            return WD_INLINE_SHAPE.CHART
        if uri == nsmap['dgm']:
            return WD_INLINE_SHAPE.SMART_ART
        return WD_INLINE_SHAPE.NOT_IMPLEMENTED

    @property
    def width(self):
        """
        Read/write. The display width of this inline shape as an |Emu|
        instance.
        """
        return self._inline.extent.cx

    @width.setter
    def width(self, cx):
        assert isinstance(cx, int)
        assert 0 < cx
        self._inline.extent.cx = cx

########NEW FILE########
__FILENAME__ = shared
# encoding: utf-8

"""
Objects shared by docx modules.
"""

from __future__ import absolute_import, print_function, unicode_literals


class Length(int):
    """
    Base class for length constructor classes Inches, Cm, Mm, Px, and Emu.
    Behaves as an int count of English Metric Units, 914400 to the inch,
    36000 to the cm. Provides convenience unit conversion methods in the form
    of read-only properties. Immutable.
    """
    _EMUS_PER_INCH = 914400
    _EMUS_PER_CM = 360000
    _EMUS_PER_MM = 36000
    _EMUS_PER_PX = 12700

    def __new__(cls, emu):
        return int.__new__(cls, emu)

    @property
    def inches(self):
        """
        The equivalent length expressed in inches (float).
        """
        return self / float(self._EMUS_PER_INCH)

    @property
    def cm(self):
        """
        The equivalent length expressed in centimeters (float).
        """
        return self / float(self._EMUS_PER_CM)

    @property
    def mm(self):
        """
        The equivalent length expressed in millimeters (float).
        """
        return self / float(self._EMUS_PER_MM)

    @property
    def px(self):
        # round can somtimes return values like x.999999 which are truncated
        # to x by int(); adding the 0.1 prevents this
        return int(round(self / float(self._EMUS_PER_PX)) + 0.1)

    @property
    def emu(self):
        """
        The equivalent length expressed in English Metric Units (int).
        """
        return self


class Inches(Length):
    """
    Convenience constructor for length in inches, e.g.
    ``width = Inches(0.5)``.
    """
    def __new__(cls, inches):
        emu = int(inches * Length._EMUS_PER_INCH)
        return Length.__new__(cls, emu)


class Cm(Length):
    """
    Convenience constructor for length in centimeters, e.g.
    ``height = Cm(12)``.
    """
    def __new__(cls, cm):
        emu = int(cm * Length._EMUS_PER_CM)
        return Length.__new__(cls, emu)


class Emu(Length):
    """
    Convenience constructor for length in English Metric Units, e.g.
    ``width = Emu(457200)``.
    """
    def __new__(cls, emu):
        return Length.__new__(cls, int(emu))


class Mm(Length):
    """
    Convenience constructor for length in millimeters, e.g.
    ``width = Mm(240.5)``.
    """
    def __new__(cls, mm):
        emu = int(mm * Length._EMUS_PER_MM)
        return Length.__new__(cls, emu)


class Pt(int):
    """
    Convenience class for setting font sizes in points
    """
    _UNITS_PER_POINT = 100

    def __new__(cls, pts):
        units = int(pts * Pt._UNITS_PER_POINT)
        return int.__new__(cls, units)


class Px(Length):
    """
    Convenience constructor for length in pixels.
    """
    def __new__(cls, px):
        emu = int(px * Length._EMUS_PER_PX)
        return Length.__new__(cls, emu)


def lazyproperty(f):
    """
    @lazyprop decorator. Decorated method will be called only on first access
    to calculate a cached property value. After that, the cached value is
    returned.
    """
    cache_attr_name = '_%s' % f.__name__  # like '_foobar' for prop 'foobar'
    docstring = f.__doc__

    def get_prop_value(obj):
        try:
            return getattr(obj, cache_attr_name)
        except AttributeError:
            value = f(obj)
            setattr(obj, cache_attr_name, value)
            return value

    return property(get_prop_value, doc=docstring)


def write_only_property(f):
    """
    @write_only_property decorator. Creates a property (descriptor attribute)
    that accepts assignment, but not getattr (use in an expression).
    """
    docstring = f.__doc__

    return property(fset=f, doc=docstring)


class Parented(object):
    """
    Provides common services for document elements that occur below a part
    but may occasionally require an ancestor object to provide a service,
    such as add or drop a relationship. Provides ``self._parent`` attribute
    to subclasses.
    """
    def __init__(self, parent):
        super(Parented, self).__init__()
        self._parent = parent

    @property
    def part(self):
        """
        The package part containing this object
        """
        return self._parent.part

########NEW FILE########
__FILENAME__ = table
# encoding: utf-8

"""
The |Table| object and related proxy classes.
"""

from __future__ import absolute_import, print_function, unicode_literals

from .shared import lazyproperty, write_only_property
from .text import Paragraph


class Table(object):
    """
    Proxy class for a WordprocessingML ``<w:tbl>`` element.
    """
    def __init__(self, tbl):
        super(Table, self).__init__()
        self._tbl = tbl

    def add_column(self):
        """
        Return a |_Column| instance, newly added rightmost to the table.
        """
        tblGrid = self._tbl.tblGrid
        gridCol = tblGrid.add_gridCol()
        for tr in self._tbl.tr_lst:
            tr.add_tc()
        return _Column(gridCol, self._tbl)

    def add_row(self):
        """
        Return a |_Row| instance, newly added bottom-most to the table.
        """
        tbl = self._tbl
        tr = tbl.add_tr()
        for gridCol in tbl.tblGrid.gridCol_lst:
            tr.add_tc()
        return _Row(tr)

    def cell(self, row_idx, col_idx):
        """
        Return |_Cell| instance correponding to table cell at *row_idx*,
        *col_idx* intersection, where (0, 0) is the top, left-most cell.
        """
        row = self.rows[row_idx]
        return row.cells[col_idx]

    @lazyproperty
    def columns(self):
        """
        |_Columns| instance containing the sequence of rows in this table.
        """
        return _Columns(self._tbl)

    @lazyproperty
    def rows(self):
        """
        |_Rows| instance containing the sequence of rows in this table.
        """
        return _Rows(self._tbl)

    @property
    def style(self):
        """
        String name of style to be applied to this table, e.g.
        'LightShading-Accent1'. Name is derived by removing spaces from the
        table style name displayed in the Word UI.
        """
        tblStyle = self._tblPr.tblStyle
        if tblStyle is None:
            return None
        return tblStyle.val

    @style.setter
    def style(self, style_name):
        tblStyle = self._tblPr.tblStyle
        if tblStyle is None:
            self._tblPr.add_tblStyle(style_name)
        else:
            tblStyle.val = style_name

    @property
    def _tblPr(self):
        return self._tbl.tblPr


class _Cell(object):
    """
    Table cell
    """
    def __init__(self, tc):
        super(_Cell, self).__init__()
        self._tc = tc

    @property
    def paragraphs(self):
        """
        List of paragraphs in the cell. A table cell is required to contain
        at least one block-level element. By default this is a single
        paragraph.
        """
        return [Paragraph(p) for p in self._tc.p_lst]

    @write_only_property
    def text(self, text):
        """
        Write-only. Set entire contents of cell to the string *text*. Any
        existing content or revisions are replaced.
        """
        tc = self._tc
        tc.clear_content()
        p = tc.add_p()
        r = p.add_r()
        r.add_t(text)


class _Column(object):
    """
    Table column
    """
    def __init__(self, gridCol, tbl):
        super(_Column, self).__init__()
        self._gridCol = gridCol
        self._tbl = tbl

    @lazyproperty
    def cells(self):
        """
        Sequence of |_Cell| instances corresponding to cells in this column.
        Supports ``len()``, iteration and indexed access.
        """
        return _ColumnCells(self._tbl, self._gridCol)


class _ColumnCells(object):
    """
    Sequence of |_Cell| instances corresponding to the cells in a table
    column.
    """
    def __init__(self, tbl, gridCol):
        super(_ColumnCells, self).__init__()
        self._tbl = tbl
        self._gridCol = gridCol

    def __getitem__(self, idx):
        """
        Provide indexed access, (e.g. 'cells[0]')
        """
        try:
            tr = self._tr_lst[idx]
        except IndexError:
            msg = "cell index [%d] is out of range" % idx
            raise IndexError(msg)
        tc = tr.tc_lst[self._col_idx]
        return _Cell(tc)

    def __iter__(self):
        for tr in self._tr_lst:
            tc = tr.tc_lst[self._col_idx]
            yield _Cell(tc)

    def __len__(self):
        return len(self._tr_lst)

    @property
    def _col_idx(self):
        gridCol_lst = self._tbl.tblGrid.gridCol_lst
        return gridCol_lst.index(self._gridCol)

    @property
    def _tr_lst(self):
        return self._tbl.tr_lst


class _Columns(object):
    """
    Sequence of |_Column| instances corresponding to the columns in a table.
    Supports ``len()``, iteration and indexed access.
    """
    def __init__(self, tbl):
        super(_Columns, self).__init__()
        self._tbl = tbl

    def __getitem__(self, idx):
        """
        Provide indexed access, e.g. 'columns[0]'
        """
        try:
            gridCol = self._gridCol_lst[idx]
        except IndexError:
            msg = "column index [%d] is out of range" % idx
            raise IndexError(msg)
        return _Column(gridCol, self._tbl)

    def __iter__(self):
        return (_Column(gridCol, self._tbl) for gridCol in self._gridCol_lst)

    def __len__(self):
        return len(self._gridCol_lst)

    @property
    def _gridCol_lst(self):
        """
        Sequence containing ``<w:gridCol>`` elements for this table, each
        representing a table column.
        """
        tblGrid = self._tbl.tblGrid
        return tblGrid.gridCol_lst


class _Row(object):
    """
    Table row
    """
    def __init__(self, tr):
        super(_Row, self).__init__()
        self._tr = tr

    @lazyproperty
    def cells(self):
        """
        Sequence of |_Cell| instances corresponding to cells in this row.
        Supports ``len()``, iteration and indexed access.
        """
        return _RowCells(self._tr)


class _RowCells(object):
    """
    Sequence of |_Cell| instances corresponding to the cells in a table row.
    """
    def __init__(self, tr):
        super(_RowCells, self).__init__()
        self._tr = tr

    def __getitem__(self, idx):
        """
        Provide indexed access, (e.g. 'cells[0]')
        """
        try:
            tc = self._tr.tc_lst[idx]
        except IndexError:
            msg = "cell index [%d] is out of range" % idx
            raise IndexError(msg)
        return _Cell(tc)

    def __iter__(self):
        return (_Cell(tc) for tc in self._tr.tc_lst)

    def __len__(self):
        return len(self._tr.tc_lst)


class _Rows(object):
    """
    Sequence of |_Row| instances corresponding to the rows in a table.
    Supports ``len()``, iteration and indexed access.
    """
    def __init__(self, tbl):
        super(_Rows, self).__init__()
        self._tbl = tbl

    def __getitem__(self, idx):
        """
        Provide indexed access, (e.g. 'rows[0]')
        """
        try:
            tr = self._tbl.tr_lst[idx]
        except IndexError:
            msg = "row index [%d] out of range" % idx
            raise IndexError(msg)
        return _Row(tr)

    def __iter__(self):
        return (_Row(tr) for tr in self._tbl.tr_lst)

    def __len__(self):
        return len(self._tbl.tr_lst)

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
Text-related proxy types for python-docx, such as Paragraph and Run.
"""

from __future__ import absolute_import, print_function, unicode_literals

from docx.enum.text import WD_BREAK


def boolproperty(f):
    """
    @boolproperty decorator. Decorated method must return the XML element
    name of the boolean property element occuring under rPr. Causes
    a read/write tri-state property to be added to the class having the name
    of the decorated function.
    """
    def _get_prop_value(parent, attr_name):
        return getattr(parent, attr_name)

    def _remove_prop(parent, attr_name):
        remove_method_name = 'remove_%s' % attr_name
        remove_method = getattr(parent, remove_method_name)
        remove_method()

    def _add_prop(parent, attr_name):
        add_method_name = 'add_%s' % attr_name
        add_method = getattr(parent, add_method_name)
        return add_method()

    def getter(obj):
        r, attr_name = obj._r, f(obj)
        if r.rPr is None:
            return None
        prop_value = _get_prop_value(r.rPr, attr_name)
        if prop_value is None:
            return None
        return prop_value.val

    def setter(obj, value):
        r, attr_name = obj._r, f(obj)
        rPr = r.get_or_add_rPr()
        _remove_prop(rPr, attr_name)
        if value is not None:
            elm = _add_prop(rPr, attr_name)
            if bool(value) is False:
                elm.val = False

    return property(getter, setter, doc=f.__doc__)


class Paragraph(object):
    """
    Proxy object wrapping ``<w:p>`` element.
    """
    def __init__(self, p):
        super(Paragraph, self).__init__()
        self._p = p

    def add_run(self, text=None, style=None):
        """
        Append a run to this paragraph containing *text* and having character
        style identified by style ID *style*.
        """
        r = self._p.add_r()
        run = Run(r)
        if text:
            run.add_text(text)
        if style:
            run.style = style
        return run

    @property
    def runs(self):
        """
        Sequence of |Run| instances corresponding to the <w:r> elements in
        this paragraph.
        """
        return [Run(r) for r in self._p.r_lst]

    @property
    def style(self):
        """
        Paragraph style for this paragraph. Read/Write.
        """
        style = self._p.style
        return style if style is not None else 'Normal'

    @style.setter
    def style(self, style):
        self._p.style = None if style == 'Normal' else style

    @property
    def text(self):
        """
        A string formed by concatenating the text of each run in the
        paragraph.
        """
        text = ''
        for run in self.runs:
            text += run.text
        return text


class Run(object):
    """
    Proxy object wrapping ``<w:r>`` element. Several of the properties on Run
    take a tri-state value, |True|, |False|, or |None|. |True| and |False|
    correspond to on and off respectively. |None| indicates the property is
    not specified directly on the run and its effective value is taken from
    the style hierarchy.
    """
    def __init__(self, r):
        super(Run, self).__init__()
        self._r = r

    def add_break(self, break_type=WD_BREAK.LINE):
        """
        Add a break element of *break_type* to this run. *break_type* can
        take the values `WD_BREAK.LINE`, `WD_BREAK.PAGE`, and
        `WD_BREAK.COLUMN` where `WD_BREAK` is imported from `docx.enum.text`.
        *break_type* defaults to `WD_BREAK.LINE`.
        """
        type_, clear = {
            WD_BREAK.LINE:             (None,           None),
            WD_BREAK.PAGE:             ('page',         None),
            WD_BREAK.COLUMN:           ('column',       None),
            WD_BREAK.LINE_CLEAR_LEFT:  ('textWrapping', 'left'),
            WD_BREAK.LINE_CLEAR_RIGHT: ('textWrapping', 'right'),
            WD_BREAK.LINE_CLEAR_ALL:   ('textWrapping', 'all'),
        }[break_type]
        br = self._r.add_br()
        if type_ is not None:
            br.type = type_
        if clear is not None:
            br.clear = clear

    def add_text(self, text):
        """
        Add a text element to this run.
        """
        t = self._r.add_t(text)
        return Text(t)

    @boolproperty
    def all_caps(self):
        """
        Read/write. Causes the text of the run to appear in capital letters.
        """
        return 'caps'

    @boolproperty
    def bold(self):
        """
        Read/write. Causes the text of the run to appear in bold.
        """
        return 'b'

    @boolproperty
    def complex_script(self):
        """
        Read/write tri-state value. When |True|, causes the characters in the
        run to be treated as complex script regardless of their Unicode
        values.
        """
        return 'cs'

    @boolproperty
    def cs_bold(self):
        """
        Read/write tri-state value. When |True|, causes the complex script
        characters in the run to be displayed in bold typeface.
        """
        return 'bCs'

    @boolproperty
    def cs_italic(self):
        """
        Read/write tri-state value. When |True|, causes the complex script
        characters in the run to be displayed in italic typeface.
        """
        return 'iCs'

    @boolproperty
    def double_strike(self):
        """
        Read/write tri-state value. When |True|, causes the text in the run
        to appear with double strikethrough.
        """
        return 'dstrike'

    @boolproperty
    def emboss(self):
        """
        Read/write tri-state value. When |True|, causes the text in the run
        to appear as if raised off the page in relief.
        """
        return 'emboss'

    @boolproperty
    def hidden(self):
        """
        Read/write tri-state value. When |True|, causes the text in the run
        to be hidden from display, unless applications settings force hidden
        text to be shown.
        """
        return 'vanish'

    @boolproperty
    def italic(self):
        """
        Read/write tri-state value. When |True|, causes the text of the run
        to appear in italics.
        """
        return 'i'

    @boolproperty
    def imprint(self):
        """
        Read/write tri-state value. When |True|, causes the text in the run
        to appear as if pressed into the page.
        """
        return 'imprint'

    @boolproperty
    def math(self):
        """
        Read/write tri-state value. When |True|, specifies this run contains
        WML that should be handled as though it was Office Open XML Math.
        """
        return 'oMath'

    @boolproperty
    def no_proof(self):
        """
        Read/write tri-state value. When |True|, specifies that the contents
        of this run should not report any errors when the document is scanned
        for spelling and grammar.
        """
        return 'noProof'

    @boolproperty
    def outline(self):
        """
        Read/write tri-state value. When |True| causes the characters in the
        run to appear as if they have an outline, by drawing a one pixel wide
        border around the inside and outside borders of each character glyph.
        """
        return 'outline'

    @boolproperty
    def rtl(self):
        """
        Read/write tri-state value. When |True| causes the text in the run
        to have right-to-left characteristics.
        """
        return 'rtl'

    @boolproperty
    def shadow(self):
        """
        Read/write tri-state value. When |True| causes the text in the run
        to appear as if each character has a shadow.
        """
        return 'shadow'

    @boolproperty
    def small_caps(self):
        """
        Read/write tri-state value. When |True| causes the lowercase
        characters in the run to appear as capital letters two points smaller
        than the font size specified for the run.
        """
        return 'smallCaps'

    @boolproperty
    def snap_to_grid(self):
        """
        Read/write tri-state value. When |True| causes the run to use the
        document grid characters per line settings defined in the docGrid
        element when laying out the characters in this run.
        """
        return 'snapToGrid'

    @boolproperty
    def spec_vanish(self):
        """
        Read/write tri-state value. When |True|, specifies that the given run
        shall always behave as if it is hidden, even when hidden text is
        being displayed in the current document. The property has a very
        narrow, specialized use related to the table of contents. Consult the
        spec (17.3.2.36) for more details.
        """
        return 'specVanish'

    @boolproperty
    def strike(self):
        """
        Read/write tri-state value. When |True| causes the text in the run
        to appear with a single horizontal line through the center of the
        line.
        """
        return 'strike'

    @property
    def style(self):
        """
        Read/write. The string style ID of the character style applied to
        this run, or |None| if it has no directly-applied character style.
        Setting this property to |None| causes any directly-applied character
        style to be removed such that the run inherits character formatting
        from its containing paragraph.
        """
        return self._r.style

    @style.setter
    def style(self, char_style):
        self._r.style = char_style

    @property
    def text(self):
        """
        A string formed by concatenating all the <w:t> elements present in
        this run.
        """
        text = ''
        for t in self._r.t_lst:
            text += t.text
        return text

    @property
    def underline(self):
        """
        The underline style for this |Run|, one of |None|, |True|, |False|,
        or a value from ``pptx.enum.text.WD_UNDERLINE``. A value of |None|
        indicates the run has no directly-applied underline value and so will
        inherit the underline value of its containing paragraph. Assigning
        |None| to this property removes any directly-applied underline value.
        A value of |False| indicates a directly-applied setting of no
        underline, overriding any inherited value. A value of |True|
        indicates single underline. The values from ``WD_UNDERLINE`` are used
        to specify other outline styles such as double, wavy, and dotted.
        """
        return self._r.underline

    @underline.setter
    def underline(self, value):
        self._r.underline = value

    @boolproperty
    def web_hidden(self):
        """
        Read/write tri-state value. When |True|, specifies that the contents
        of this run shall be hidden when the document is displayed in web
        page view.
        """
        return 'webHidden'


class Text(object):
    """
    Proxy object wrapping ``<w:t>`` element.
    """
    def __init__(self, t_elm):
        super(Text, self).__init__()
        self._t = t_elm

########NEW FILE########
__FILENAME__ = environment
# encoding: utf-8

"""
Used by behave to set testing environment before and after running acceptance
tests.
"""

import os

scratch_dir = os.path.abspath(
    os.path.join(os.path.split(__file__)[0], '_scratch')
)


def before_all(context):
    if not os.path.isdir(scratch_dir):
        os.mkdir(scratch_dir)

########NEW FILE########
__FILENAME__ = api
# encoding: utf-8

"""
Step implementations for basic API features
"""

from behave import then, when

from docx.shared import Inches
from docx.table import Table

from helpers import test_file_path


# when ====================================================

@when('I add a 2 x 2 table specifying only row and column count')
def when_add_2x2_table_specifying_only_row_and_col_count(context):
    document = context.document
    document.add_table(rows=2, cols=2)


@when('I add a 2 x 2 table specifying style \'foobar\'')
def when_add_2x2_table_specifying_style_foobar(context):
    document = context.document
    document.add_table(rows=2, cols=2, style='foobar')


@when('I add a heading specifying level={level_str}')
def when_add_heading_specifying_level(context, level_str):
    level = int(level_str)
    document = context.document
    document.add_heading(level=level)


@when('I add a heading specifying only its text')
def when_add_heading_specifying_only_its_text(context):
    document = context.document
    context.heading_text = 'Spam vs. Eggs'
    document.add_heading(context.heading_text)


@when('I add a page break to the document')
def when_add_page_break_to_document(context):
    document = context.document
    document.add_page_break()


@when('I add a paragraph specifying its style')
def when_add_paragraph_specifying_style(context):
    document = context.document
    context.paragraph_style = 'barfoo'
    document.add_paragraph(style=context.paragraph_style)


@when('I add a paragraph specifying its text')
def when_add_paragraph_specifying_text(context):
    document = context.document
    context.paragraph_text = 'foobar'
    document.add_paragraph(context.paragraph_text)


@when('I add a paragraph without specifying text or style')
def when_add_paragraph_without_specifying_text_or_style(context):
    document = context.document
    document.add_paragraph()


@when('I add a picture specifying 1.75" width and 2.5" height')
def when_add_picture_specifying_width_and_height(context):
    document = context.document
    context.picture = document.add_picture(
        test_file_path('monty-truth.png'),
        width=Inches(1.75), height=Inches(2.5)
    )


@when('I add a picture specifying a height of 1.5 inches')
def when_add_picture_specifying_height(context):
    document = context.document
    context.picture = document.add_picture(
        test_file_path('monty-truth.png'), height=Inches(1.5)
    )


@when('I add a picture specifying a width of 1.5 inches')
def when_add_picture_specifying_width(context):
    document = context.document
    context.picture = document.add_picture(
        test_file_path('monty-truth.png'), width=Inches(1.5)
    )


@when('I add a picture specifying only the image file')
def when_add_picture_specifying_only_image_file(context):
    document = context.document
    context.picture = document.add_picture(test_file_path('monty-truth.png'))


# then =====================================================

@then('the document contains a 2 x 2 table')
def then_document_contains_2x2_table(context):
    document = context.document
    table = document.tables[-1]
    assert isinstance(table, Table)
    assert len(table.rows) == 2
    assert len(table.columns) == 2
    context.table_ = table


@then('the last paragraph contains only a page break')
def then_last_paragraph_contains_only_a_page_break(context):
    document = context.document
    p = document.paragraphs[-1]
    assert len(p.runs) == 1
    assert len(p.runs[0]._r) == 1
    assert p.runs[0]._r[0].type == 'page'


@then('the last paragraph contains the heading text')
def then_last_p_contains_heading_text(context):
    document = context.document
    text = context.heading_text
    p = document.paragraphs[-1]
    assert p.text == text


@then('the last paragraph contains the text I specified')
def then_last_p_contains_specified_text(context):
    document = context.document
    text = context.paragraph_text
    p = document.paragraphs[-1]
    assert p.text == text


@then('the last paragraph has the style I specified')
def then_last_p_has_specified_style(context):
    document = context.document
    style = context.paragraph_style
    p = document.paragraphs[-1]
    assert p.style == style


@then('the last paragraph is the empty paragraph I added')
def then_last_p_is_empty_paragraph_added(context):
    document = context.document
    p = document.paragraphs[-1]
    assert p.text == ''


@then('the picture has its native width and height')
def then_picture_has_native_width_and_height(context):
    picture = context.picture
    assert picture.width == 1905000, 'got %d' % picture.width
    assert picture.height == 2717800, 'got %d' % picture.height


@then('the picture height is 2.14 inches')
def then_picture_height_is_value_2(context):
    picture = context.picture
    assert picture.height == 1956816, 'got %d' % picture.height


@then('the picture height is 2.5 inches')
def then_picture_height_is_value(context):
    picture = context.picture
    assert picture.height == 2286000, 'got %d' % picture.height


@then('the picture width is 1.05 inches')
def then_picture_width_is_value_2(context):
    picture = context.picture
    assert picture.width == 961402, 'got %d' % picture.width


@then('the picture width is 1.75 inches')
def then_picture_width_is_value(context):
    picture = context.picture
    assert picture.width == 1600200, 'got %d' % picture.width


@then('the style of the last paragraph is \'{style}\'')
def then_style_of_last_paragraph_is_style(context, style):
    document = context.document
    p = document.paragraphs[-1]
    assert p.style == style


@then('the table style is \'{style}\'')
def then_table_style_is_style(context, style):
    table = context.table_
    assert table.style == style

########NEW FILE########
__FILENAME__ = block
# encoding: utf-8

"""
Step implementations for block content containers
"""

from behave import given, then, when

from docx import Document
from docx.table import Table

from helpers import test_docx


# given ===================================================

@given('a document containing a table')
def given_a_document_containing_a_table(context):
    docx_path = test_docx('blk-containing-table')
    context.document = Document(docx_path)


@given('a paragraph')
def given_a_paragraph(context):
    context.document = Document()
    context.paragraph = context.document.add_paragraph()


# when ====================================================

@when('I add a paragraph')
def when_add_paragraph(context):
    document = context.document
    context.p = document.add_paragraph()


@when('I add a table')
def when_add_table(context):
    rows, cols = 2, 2
    context.document.add_table(rows, cols)


# then =====================================================

@then('I can access the table')
def then_can_access_table(context):
    table = context.document.tables[-1]
    assert isinstance(table, Table)


@then('the new table appears in the document')
def then_new_table_appears_in_document(context):
    table = context.document.tables[-1]
    assert isinstance(table, Table)

########NEW FILE########
__FILENAME__ = cell
# encoding: utf-8

"""
Step implementations for table cell-related features
"""

from __future__ import absolute_import, print_function, unicode_literals

from behave import given, then, when

from docx import Document


# given ===================================================

@given('a table cell')
def given_a_table_cell(context):
    table = Document().add_table(rows=2, cols=2)
    context.cell = table.cell(0, 0)


# when =====================================================

@when('I assign a string to the cell text attribute')
def when_assign_string_to_cell_text_attribute(context):
    cell = context.cell
    text = 'foobar'
    cell.text = text
    context.expected_text = text


# then =====================================================

@then('the cell contains the string I assigned')
def then_cell_contains_string_assigned(context):
    cell, expected_text = context.cell, context.expected_text
    text = cell.paragraphs[0].runs[0].text
    msg = "expected '%s', got '%s'" % (expected_text, text)
    assert text == expected_text, msg

########NEW FILE########
__FILENAME__ = helpers
# encoding: utf-8

"""
Helper methods and variables for acceptance tests.
"""

import os


def absjoin(*paths):
    return os.path.abspath(os.path.join(*paths))

thisdir = os.path.split(__file__)[0]
scratch_dir = absjoin(thisdir, '../_scratch')

# scratch output docx file -------------
saved_docx_path = absjoin(scratch_dir, 'test_out.docx')

test_text = 'python-docx was here!'


def test_docx(name):
    """
    Return the absolute path to test .docx file with root name *name*.
    """
    return absjoin(thisdir, 'test_files', '%s.docx' % name)


def test_file_path(name):
    """
    Return the absolute path to file with *name* in test_files directory
    """
    return absjoin(thisdir, 'test_files', '%s' % name)

########NEW FILE########
__FILENAME__ = image
# encoding: utf-8

"""
Step implementations for image characterization features
"""

from __future__ import absolute_import, print_function, unicode_literals

from behave import given, then, when

from docx.image.image import Image

from helpers import test_file_path


# given ===================================================

@given('the image file \'{filename}\'')
def given_image_filename(context, filename):
    context.image_path = test_file_path(filename)


# when ====================================================

@when('I construct an image using the image path')
def when_construct_image_using_path(context):
    context.image = Image.from_file(context.image_path)


# then ====================================================

@then('the image has content type \'{mime_type}\'')
def then_image_has_content_type(context, mime_type):
    content_type = context.image.content_type
    assert content_type == mime_type, (
        "expected MIME type '%s', got '%s'" % (mime_type, content_type)
    )


@then('the image has {horz_dpi_str} horizontal dpi')
def then_image_has_horizontal_dpi(context, horz_dpi_str):
    expected_horz_dpi = int(horz_dpi_str)
    horz_dpi = context.image.horz_dpi
    assert horz_dpi == expected_horz_dpi, (
        "expected horizontal dpi %d, got %d" % (expected_horz_dpi, horz_dpi)
    )


@then('the image has {vert_dpi_str} vertical dpi')
def then_image_has_vertical_dpi(context, vert_dpi_str):
    expected_vert_dpi = int(vert_dpi_str)
    vert_dpi = context.image.vert_dpi
    assert vert_dpi == expected_vert_dpi, (
        "expected vertical dpi %d, got %d" % (expected_vert_dpi, vert_dpi)
    )


@then('the image is {px_height_str} pixels high')
def then_image_is_cx_pixels_high(context, px_height_str):
    expected_px_height = int(px_height_str)
    px_height = context.image.px_height
    assert px_height == expected_px_height, (
        "expected pixel height %d, got %d" % (expected_px_height, px_height)
    )


@then('the image is {px_width_str} pixels wide')
def then_image_is_cx_pixels_wide(context, px_width_str):
    expected_px_width = int(px_width_str)
    px_width = context.image.px_width
    assert px_width == expected_px_width, (
        "expected pixel width %d, got %d" % (expected_px_width, px_width)
    )

########NEW FILE########
__FILENAME__ = numbering
# encoding: utf-8

"""
Step implementations for numbering-related features
"""

from behave import given, then, when

from docx import Document

from helpers import test_docx


# given ===================================================

@given('a document having a numbering part')
def given_a_document_having_a_numbering_part(context):
    docx_path = test_docx('num-having-numbering-part')
    context.document = Document(docx_path)


# when ====================================================

@when('I get the numbering part from the document')
def when_get_numbering_part_from_document(context):
    document = context.document
    context.numbering_part = document.numbering_part


# then =====================================================

@then('the numbering part has the expected numbering definitions')
def then_numbering_part_has_expected_numbering_definitions(context):
    numbering_part = context.numbering_part
    assert len(numbering_part.numbering_definitions) == 10

########NEW FILE########
__FILENAME__ = paragraph
# encoding: utf-8

"""
Step implementations for paragraph-related features
"""

from behave import then, when

from docx import Document

from helpers import saved_docx_path, test_text


TEST_STYLE = 'Heading1'


# when ====================================================

@when('I add a run to the paragraph')
def when_add_new_run_to_paragraph(context):
    context.r = context.p.add_run()


@when('I add text to the run')
def when_add_new_text_to_run(context):
    context.r.add_text(test_text)


@when('I set the paragraph style')
def when_I_set_the_paragraph_style(context):
    context.paragraph.add_run().add_text(test_text)
    context.paragraph.style = TEST_STYLE


# then =====================================================

@then('the document contains the text I added')
def then_document_contains_text_I_added(context):
    document = Document(saved_docx_path)
    paragraphs = document.paragraphs
    p = paragraphs[-1]
    r = p.runs[0]
    assert r.text == test_text


@then('the paragraph has the style I set')
def then_the_paragraph_has_the_style_I_set(context):
    paragraph = Document(saved_docx_path).paragraphs[-1]
    assert paragraph.style == TEST_STYLE

########NEW FILE########
__FILENAME__ = shape
# encoding: utf-8

"""
Step implementations for graphical object (shape) related features
"""

from __future__ import absolute_import, print_function, unicode_literals

import hashlib

from behave import given, then, when

from docx import Document
from docx.enum.shape import WD_INLINE_SHAPE
from docx.parts.document import InlineShape, InlineShapes
from docx.shared import Inches

from helpers import test_docx, test_file_path


# given ===================================================

@given('a document containing five inline shapes')
def given_a_document_containing_two_inline_shapes(context):
    docx_path = test_docx('shp-inline-shape-access')
    context.document = Document(docx_path)


@given('an inline shape collection containing five shapes')
def given_inline_shape_collection_containing_two_shapes(context):
    docx_path = test_docx('shp-inline-shape-access')
    document = Document(docx_path)
    context.inline_shapes = document.inline_shapes


@given('an inline shape of known dimensions')
def given_inline_shape_of_known_dimensions(context):
    document = Document(test_docx('shp-inline-shape-access'))
    context.inline_shape = document.inline_shapes[0]


@given('an inline shape known to be {shp_of_type}')
def given_inline_shape_known_to_be_shape_of_type(context, shp_of_type):
    inline_shape_idx = {
        'an embedded picture':  0,
        'a linked picture':     1,
        'a link+embed picture': 2,
        'a smart art diagram':  3,
        'a chart':              4,
    }[shp_of_type]
    docx_path = test_docx('shp-inline-shape-access')
    document = Document(docx_path)
    context.inline_shape = document.inline_shapes[inline_shape_idx]


# when =====================================================

@when('I add an inline picture from a file-like object')
def when_add_inline_picture_from_file_like_object(context):
    document = context.document
    with open(test_file_path('monty-truth.png'), 'rb') as f:
        context.inline_shape = document.inline_shapes.add_picture(f)


@when('I add an inline picture to the document')
def when_add_inline_picture_to_document(context):
    document = context.document
    context.inline_shape = (document.inline_shapes.add_picture(
        test_file_path('monty-truth.png')
    ))


@when('I change the dimensions of the inline shape')
def when_change_dimensions_of_inline_shape(context):
    inline_shape = context.inline_shape
    inline_shape.width = Inches(1)
    inline_shape.height = Inches(0.5)


# then =====================================================

@then('I can access each inline shape by index')
def then_can_access_each_inline_shape_by_index(context):
    inline_shapes = context.inline_shapes
    for idx in range(2):
        inline_shape = inline_shapes[idx]
        assert isinstance(inline_shape, InlineShape)


@then('I can access the inline shape collection of the document')
def then_can_access_inline_shape_collection_of_document(context):
    document = context.document
    inline_shapes = document.inline_shapes
    assert isinstance(inline_shapes, InlineShapes)


@then('I can iterate over the inline shape collection')
def then_can_iterate_over_inline_shape_collection(context):
    inline_shapes = context.inline_shapes
    shape_count = 0
    for inline_shape in inline_shapes:
        shape_count += 1
        assert isinstance(inline_shape, InlineShape)
    expected_count = 5
    assert shape_count == expected_count, (
        'expected %d, got %d' % (expected_count, shape_count)
    )


@then('its inline shape type is {shape_type}')
def then_inline_shape_type_is_shape_type(context, shape_type):
    expected_value = {
        'WD_INLINE_SHAPE.CHART':          WD_INLINE_SHAPE.CHART,
        'WD_INLINE_SHAPE.LINKED_PICTURE': WD_INLINE_SHAPE.LINKED_PICTURE,
        'WD_INLINE_SHAPE.PICTURE':        WD_INLINE_SHAPE.PICTURE,
        'WD_INLINE_SHAPE.SMART_ART':      WD_INLINE_SHAPE.SMART_ART,
    }[shape_type]
    inline_shape = context.inline_shape
    assert inline_shape.type == expected_value


@then('the dimensions of the inline shape match the known values')
def then_dimensions_of_inline_shape_match_known_values(context):
    inline_shape = context.inline_shape
    assert inline_shape.width == 1778000, 'got %s' % inline_shape.width
    assert inline_shape.height == 711200, 'got %s' % inline_shape.height


@then('the dimensions of the inline shape match the new values')
def then_dimensions_of_inline_shape_match_new_values(context):
    inline_shape = context.inline_shape
    assert inline_shape.width == 914400, 'got %s' % inline_shape.width
    assert inline_shape.height == 457200, 'got %s' % inline_shape.height


@then('the document contains the inline picture')
def then_the_document_contains_the_inline_picture(context):
    document = context.document
    picture_shape = document.inline_shapes[0]
    blip = picture_shape._inline.graphic.graphicData.pic.blipFill.blip
    rId = blip.embed
    image_part = document._document_part.related_parts[rId]
    image_sha1 = hashlib.sha1(image_part.blob).hexdigest()
    expected_sha1 = '79769f1e202add2e963158b532e36c2c0f76a70c'
    assert image_sha1 == expected_sha1, (
        "image SHA1 doesn't match, expected %s, got %s" %
        (expected_sha1, image_sha1)
    )


@then('the length of the inline shape collection is 5')
def then_len_of_inline_shape_collection_is_5(context):
    inline_shapes = context.document.inline_shapes
    shape_count = len(inline_shapes)
    assert shape_count == 5, 'got %s' % shape_count

########NEW FILE########
__FILENAME__ = shared
# encoding: utf-8

"""
General-purpose step implementations
"""

import os

from behave import given, when

from docx import Document

from helpers import saved_docx_path


# given ===================================================

@given('a document')
def given_a_document(context):
    context.document = Document()


# when ====================================================

@when('I save the document')
def when_save_document(context):
    if os.path.isfile(saved_docx_path):
        os.remove(saved_docx_path)
    context.document.save(saved_docx_path)

########NEW FILE########
__FILENAME__ = styles
# encoding: utf-8

"""
Step implementations for styles-related features
"""

from behave import given, then, when

from docx import Document

from helpers import test_docx


# given ===================================================

@given('a document having a styles part')
def given_a_document_having_a_styles_part(context):
    docx_path = test_docx('sty-having-styles-part')
    context.document = Document(docx_path)


# when ====================================================

@when('I get the styles part from the document')
def when_get_styles_part_from_document(context):
    document = context.document
    context.styles_part = document.styles_part


# then =====================================================

@then('the styles part has the expected number of style definitions')
def then_styles_part_has_expected_number_of_style_definitions(context):
    styles_part = context.styles_part
    assert len(styles_part.styles) == 4

########NEW FILE########
__FILENAME__ = table
# encoding: utf-8

"""
Step implementations for table-related features
"""

from __future__ import absolute_import, print_function, unicode_literals

from behave import given, then, when

from docx import Document
from docx.table import (
    _Cell, _Column, _ColumnCells, _Columns, _Row, _RowCells, _Rows
)

from helpers import test_docx


# given ===================================================

@given('a 2 x 2 table')
def given_a_2x2_table(context):
    context.table_ = Document().add_table(rows=2, cols=2)


@given('a column cell collection having two cells')
def given_a_column_cell_collection_having_two_cells(context):
    docx_path = test_docx('blk-containing-table')
    document = Document(docx_path)
    context.cells = document.tables[0].columns[0].cells


@given('a column collection having two columns')
def given_a_column_collection_having_two_columns(context):
    docx_path = test_docx('blk-containing-table')
    document = Document(docx_path)
    context.columns = document.tables[0].columns


@given('a row cell collection having two cells')
def given_a_row_cell_collection_having_two_cells(context):
    docx_path = test_docx('blk-containing-table')
    document = Document(docx_path)
    context.cells = document.tables[0].rows[0].cells


@given('a row collection having two rows')
def given_a_row_collection_having_two_rows(context):
    docx_path = test_docx('blk-containing-table')
    document = Document(docx_path)
    context.rows = document.tables[0].rows


@given('a table')
def given_a_table(context):
    context.table_ = Document().add_table(rows=2, cols=2)


@given('a table having an applied style')
def given_a_table_having_an_applied_style(context):
    docx_path = test_docx('tbl-having-applied-style')
    document = Document(docx_path)
    context.table_ = document.tables[0]


@given('a table having two columns')
def given_a_table_having_two_columns(context):
    docx_path = test_docx('blk-containing-table')
    document = Document(docx_path)
    # context.table is used internally by behave, underscore added
    # to distinguish this one
    context.table_ = document.tables[0]


@given('a table having two rows')
def given_a_table_having_two_rows(context):
    docx_path = test_docx('blk-containing-table')
    document = Document(docx_path)
    context.table_ = document.tables[0]


@given('a table column having two cells')
def given_a_table_column_having_two_cells(context):
    docx_path = test_docx('blk-containing-table')
    document = Document(docx_path)
    context.column = document.tables[0].columns[0]


@given('a table row having two cells')
def given_a_table_row_having_two_cells(context):
    docx_path = test_docx('blk-containing-table')
    document = Document(docx_path)
    context.row = document.tables[0].rows[0]


# when =====================================================

@when('I add a column to the table')
def when_add_column_to_table(context):
    table = context.table_
    context.column = table.add_column()


@when('I add a row to the table')
def when_add_row_to_table(context):
    table = context.table_
    context.row = table.add_row()


@when('I apply a style to the table')
def when_apply_style_to_table(context):
    table = context.table_
    table.style = 'LightShading-Accent1'


# then =====================================================

@then('I can access a cell using its row and column indices')
def then_can_access_cell_using_its_row_and_col_indices(context):
    table = context.table_
    for row_idx in range(2):
        for col_idx in range(2):
            cell = table.cell(row_idx, col_idx)
            assert isinstance(cell, _Cell)


@then('I can access a collection column by index')
def then_can_access_collection_column_by_index(context):
    columns = context.columns
    for idx in range(2):
        column = columns[idx]
        assert isinstance(column, _Column)


@then('I can access a collection row by index')
def then_can_access_collection_row_by_index(context):
    rows = context.rows
    for idx in range(2):
        row = rows[idx]
        assert isinstance(row, _Row)


@then('I can access a column cell by index')
def then_can_access_column_cell_by_index(context):
    cells = context.cells
    for idx in range(2):
        cell = cells[idx]
        assert isinstance(cell, _Cell)


@then('I can access a row cell by index')
def then_can_access_row_cell_by_index(context):
    cells = context.cells
    for idx in range(2):
        cell = cells[idx]
        assert isinstance(cell, _Cell)


@then('I can access the cell collection of the column')
def then_can_access_cell_collection_of_column(context):
    column = context.column
    cells = column.cells
    assert isinstance(cells, _ColumnCells)


@then('I can access the cell collection of the row')
def then_can_access_cell_collection_of_row(context):
    row = context.row
    cells = row.cells
    assert isinstance(cells, _RowCells)


@then('I can access the column collection of the table')
def then_can_access_column_collection_of_table(context):
    table = context.table_
    columns = table.columns
    assert isinstance(columns, _Columns)


@then('I can access the row collection of the table')
def then_can_access_row_collection_of_table(context):
    table = context.table_
    rows = table.rows
    assert isinstance(rows, _Rows)


@then('I can get the length of the column cell collection')
def then_can_get_length_of_column_cell_collection(context):
    column = context.column
    cells = column.cells
    assert len(cells) == 2


@then('I can get the length of the row cell collection')
def then_can_get_length_of_row_cell_collection(context):
    row = context.row
    cells = row.cells
    assert len(cells) == 2


@then('I can get the table style name')
def then_can_get_table_style_name(context):
    table = context.table_
    msg = "got '%s'" % table.style
    assert table.style == 'LightShading-Accent1', msg


@then('I can iterate over the column cells')
def then_can_iterate_over_the_column_cells(context):
    cells = context.cells
    actual_count = 0
    for cell in cells:
        actual_count += 1
        assert isinstance(cell, _Cell)
    assert actual_count == 2


@then('I can iterate over the column collection')
def then_can_iterate_over_column_collection(context):
    columns = context.columns
    actual_count = 0
    for column in columns:
        actual_count += 1
        assert isinstance(column, _Column)
    assert actual_count == 2


@then('I can iterate over the row cells')
def then_can_iterate_over_the_row_cells(context):
    cells = context.cells
    actual_count = 0
    for cell in cells:
        actual_count += 1
        assert isinstance(cell, _Cell)
    assert actual_count == 2


@then('I can iterate over the row collection')
def then_can_iterate_over_row_collection(context):
    rows = context.rows
    actual_count = 0
    for row in rows:
        actual_count += 1
        assert isinstance(row, _Row)
    assert actual_count == 2


@then('the length of the column collection is 2')
def then_len_of_column_collection_is_2(context):
    columns = context.table_.columns
    assert len(columns) == 2


@then('the length of the row collection is 2')
def then_len_of_row_collection_is_2(context):
    rows = context.table_.rows
    assert len(rows) == 2


@then('the new column has 2 cells')
def then_new_column_has_2_cells(context):
    assert len(context.column.cells) == 2


@then('the new row has 2 cells')
def then_new_row_has_2_cells(context):
    assert len(context.row.cells) == 2


@then('the table style matches the name I applied')
def then_table_style_matches_name_applied(context):
    table = context.table_
    tmpl = "table.style doesn't match, got '%s'"
    assert table.style == 'LightShading-Accent1', tmpl % table.style


@then('the table has {count} columns')
def then_table_has_count_columns(context, count):
    column_count = int(count)
    columns = context.table_.columns
    assert len(columns) == column_count


@then('the table has {count} rows')
def then_table_has_count_rows(context, count):
    row_count = int(count)
    rows = context.table_.rows
    assert len(rows) == row_count

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
Step implementations for text-related features
"""

from __future__ import absolute_import, print_function, unicode_literals

from behave import given, then, when

from docx import Document
from docx.enum.text import WD_BREAK, WD_UNDERLINE
from docx.oxml.shared import qn

from .helpers import test_docx, test_text


# given ===================================================

@given('a run')
def given_a_run(context):
    p = Document().add_paragraph()
    context.run = p.add_run()


@given('a run having {bool_prop_name} set on')
def given_a_run_having_bool_prop_set_on(context, bool_prop_name):
    run = Document().add_paragraph().add_run()
    setattr(run, bool_prop_name, True)
    context.run = run


@given('a run having {underline_type} underline')
def given_a_run_having_underline_type(context, underline_type):
    run_idx = {
        'inherited': 0, 'no': 1, 'single': 2, 'double': 3
    }[underline_type]
    document = Document(test_docx('run-enumerated-props'))
    context.run = document.paragraphs[0].runs[run_idx]


@given('a run having style {char_style}')
def given_a_run_having_style_char_style(context, char_style):
    run_idx = {
        'None': 0, 'Emphasis': 1, 'Strong': 2
    }[char_style]
    document = Document(test_docx('run-char-style'))
    context.run = document.paragraphs[0].runs[run_idx]


# when ====================================================

@when('I add a column break')
def when_add_column_break(context):
    run = context.run
    run.add_break(WD_BREAK.COLUMN)


@when('I add a line break')
def when_add_line_break(context):
    run = context.run
    run.add_break()


@when('I add a page break')
def when_add_page_break(context):
    run = context.run
    run.add_break(WD_BREAK.PAGE)


@when('I add a run specifying its text')
def when_I_add_a_run_specifying_its_text(context):
    context.run = context.paragraph.add_run(test_text)


@when('I add a run specifying the character style Emphasis')
def when_I_add_a_run_specifying_the_character_style_Emphasis(context):
    context.run = context.paragraph.add_run(test_text, 'Emphasis')


@when('I assign {value_str} to its {bool_prop_name} property')
def when_assign_true_to_bool_run_prop(context, value_str, bool_prop_name):
    value = {'True': True, 'False': False, 'None': None}[value_str]
    run = context.run
    setattr(run, bool_prop_name, value)


@when('I set the character style of the run to {char_style}')
def when_I_set_the_character_style_of_the_run(context, char_style):
    style_value = {
        'None': None, 'Emphasis': 'Emphasis', 'Strong': 'Strong'
    }[char_style]
    context.run.style = style_value


@when('I set the run underline to {underline_value}')
def when_I_set_the_run_underline_to_value(context, underline_value):
    new_value = {
        'True': True, 'False': False, 'None': None,
        'WD_UNDERLINE.SINGLE': WD_UNDERLINE.SINGLE,
        'WD_UNDERLINE.DOUBLE': WD_UNDERLINE.DOUBLE,
    }[underline_value]
    context.run.underline = new_value


# then =====================================================

@then('it is a column break')
def then_type_is_column_break(context):
    attrib = context.last_child.attrib
    assert attrib == {qn('w:type'): 'column'}


@then('it is a line break')
def then_type_is_line_break(context):
    attrib = context.last_child.attrib
    assert attrib == {}


@then('it is a page break')
def then_type_is_page_break(context):
    attrib = context.last_child.attrib
    assert attrib == {qn('w:type'): 'page'}


@then('the last item in the run is a break')
def then_last_item_in_run_is_a_break(context):
    run = context.run
    context.last_child = run._r[-1]
    expected_tag = (
        '{http://schemas.openxmlformats.org/wordprocessingml/2006/main}br'
    )
    assert context.last_child.tag == expected_tag


@then('the run appears in {boolean_prop_name} unconditionally')
def then_run_appears_in_boolean_prop_name(context, boolean_prop_name):
    run = context.run
    assert getattr(run, boolean_prop_name) is True


@then('the run appears with its inherited {boolean_prop_name} setting')
def then_run_inherits_bool_prop_value(context, boolean_prop_name):
    run = context.run
    assert getattr(run, boolean_prop_name) is None


@then('the run appears without {boolean_prop_name} unconditionally')
def then_run_appears_without_bool_prop(context, boolean_prop_name):
    run = context.run
    assert getattr(run, boolean_prop_name) is False


@then('the run contains the text I specified')
def then_the_run_contains_the_text_I_specified(context):
    assert context.run.text == test_text


@then('the run underline property value is {underline_value}')
def then_the_run_underline_property_value_is(context, underline_value):
    expected_value = {
        'None': None, 'False': False, 'True': True,
        'WD_UNDERLINE.DOUBLE': WD_UNDERLINE.DOUBLE
    }[underline_value]
    assert context.run.underline == expected_value


@then('the style of the run is {char_style}')
def then_the_style_of_the_run_is_char_style(context, char_style):
    expected_value = {
        'None': None, 'Emphasis': 'Emphasis', 'Strong': 'Strong'
    }[char_style]
    assert context.run.style == expected_value

########NEW FILE########
__FILENAME__ = test_bmp
# encoding: utf-8

"""
Test suite for docx.image.bmp module
"""

from __future__ import absolute_import, print_function

import pytest

from docx.compat import BytesIO
from docx.image.constants import MIME_TYPE
from docx.image.bmp import Bmp

from ..unitutil import initializer_mock


class DescribeBmp(object):

    def it_can_construct_from_a_bmp_stream(self, from_stream_fixture):
        stream, Bmp__init__, cx, cy, horz_dpi, vert_dpi = from_stream_fixture
        bmp = Bmp.from_stream(stream)
        Bmp__init__.assert_called_once_with(cx, cy, horz_dpi, vert_dpi)
        assert isinstance(bmp, Bmp)

    def it_knows_its_content_type(self):
        bmp = Bmp(None, None, None, None)
        assert bmp.content_type == MIME_TYPE.BMP

    def it_knows_its_default_ext(self):
        bmp = Bmp(None, None, None, None)
        assert bmp.default_ext == 'bmp'

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(self, Bmp__init__):
        cx, cy, horz_dpi, vert_dpi = 26, 43, 200, 96
        bytes_ = (
            b'fillerfillerfiller\x1A\x00\x00\x00\x2B\x00\x00\x00'
            b'fillerfiller\xB8\x1E\x00\x00\x00\x00\x00\x00'
        )
        stream = BytesIO(bytes_)
        return stream, Bmp__init__, cx, cy, horz_dpi, vert_dpi

    @pytest.fixture
    def Bmp__init__(self, request):
        return initializer_mock(request, Bmp)

########NEW FILE########
__FILENAME__ = test_gif
# encoding: utf-8

"""
Test suite for docx.image.gif module
"""

from __future__ import absolute_import, print_function

import pytest

from docx.compat import BytesIO
from docx.image.constants import MIME_TYPE
from docx.image.gif import Gif

from ..unitutil import initializer_mock


class DescribeGif(object):

    def it_can_construct_from_a_gif_stream(self, from_stream_fixture):
        stream, Gif__init__, cx, cy = from_stream_fixture
        gif = Gif.from_stream(stream)
        Gif__init__.assert_called_once_with(cx, cy, 72, 72)
        assert isinstance(gif, Gif)

    def it_knows_its_content_type(self):
        gif = Gif(None, None, None, None)
        assert gif.content_type == MIME_TYPE.GIF

    def it_knows_its_default_ext(self):
        gif = Gif(None, None, None, None)
        assert gif.default_ext == 'gif'

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(self, Gif__init__):
        cx, cy = 42, 24
        bytes_ = b'filler\x2A\x00\x18\x00'
        stream = BytesIO(bytes_)
        return stream, Gif__init__, cx, cy

    @pytest.fixture
    def Gif__init__(self, request):
        return initializer_mock(request, Gif)

########NEW FILE########
__FILENAME__ = test_helpers
# encoding: utf-8

"""
Test suite for docx.image.helpers module
"""

from __future__ import absolute_import, print_function

import pytest

from docx.compat import BytesIO
from docx.image.exceptions import UnexpectedEndOfFileError
from docx.image.helpers import BIG_ENDIAN, LITTLE_ENDIAN, StreamReader


class DescribeStreamReader(object):

    def it_can_read_a_string_of_specified_len_at_offset(
            self, read_str_fixture):
        stream_rdr, expected_string = read_str_fixture
        s = stream_rdr.read_str(6, 2)
        assert s == 'foobar'

    def it_raises_on_unexpected_EOF(self, read_str_fixture):
        stream_rdr = read_str_fixture[0]
        with pytest.raises(UnexpectedEndOfFileError):
            stream_rdr.read_str(9, 2)

    def it_can_read_a_long(self, read_long_fixture):
        stream_rdr, offset, expected_int = read_long_fixture
        l = stream_rdr.read_long(offset)
        assert l == expected_int

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (BIG_ENDIAN,    b'\xBE\x00\x00\x00\x2A\xEF', 1, 42),
        (LITTLE_ENDIAN, b'\xBE\xEF\x2A\x00\x00\x00', 2, 42),
    ])
    def read_long_fixture(self, request):
        byte_order, bytes_, offset, expected_int = request.param
        stream = BytesIO(bytes_)
        stream_rdr = StreamReader(stream, byte_order)
        return stream_rdr, offset, expected_int

    @pytest.fixture
    def read_str_fixture(self):
        stream = BytesIO(b'\x01\x02foobar\x03\x04')
        stream_rdr = StreamReader(stream, BIG_ENDIAN)
        expected_string = 'foobar'
        return stream_rdr, expected_string

########NEW FILE########
__FILENAME__ = test_image
# encoding: utf-8

"""
Test suite for docx.image package
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from docx.compat import BytesIO
from docx.image.bmp import Bmp
from docx.image.exceptions import UnrecognizedImageError
from docx.image.gif import Gif
from docx.image.image import BaseImageHeader, Image, _ImageHeaderFactory
from docx.image.jpeg import Exif, Jfif
from docx.image.png import Png
from docx.image.tiff import Tiff
from docx.opc.constants import CONTENT_TYPE as CT

from ..unitutil import (
    function_mock, class_mock, initializer_mock, instance_mock, method_mock,
    test_file
)


class DescribeImage(object):

    def it_can_construct_from_an_image_blob(self, from_blob_fixture):
        blob_, BytesIO_, _from_stream_, stream_, image_ = from_blob_fixture
        image = Image.from_blob(blob_)
        BytesIO_.assert_called_once_with(blob_)
        _from_stream_.assert_called_once_with(stream_, blob_)
        assert image is image_

    def it_can_construct_from_an_image_path(self, from_path_fixture):
        image_path, _from_stream_, stream_, blob, filename, image_ = (
            from_path_fixture
        )
        image = Image.from_file(image_path)
        _from_stream_.assert_called_once_with(stream_, blob, filename)
        assert image is image_

    def it_can_construct_from_an_image_file_like(self, from_filelike_fixture):
        image_stream, _from_stream_, blob, image_ = from_filelike_fixture
        image = Image.from_file(image_stream)
        _from_stream_.assert_called_once_with(image_stream, blob, None)
        assert image is image_

    def it_can_construct_from_an_image_stream(self, from_stream_fixture):
        # fixture ----------------------
        stream_, blob_, filename_in = from_stream_fixture[:3]
        _ImageHeaderFactory_, image_header_ = from_stream_fixture[3:5]
        Image__init_, filename_out = from_stream_fixture[5:]
        # exercise ---------------------
        image = Image._from_stream(stream_, blob_, filename_in)
        # verify -----------------------
        _ImageHeaderFactory_.assert_called_once_with(stream_)
        Image__init_.assert_called_once_with(
            blob_, filename_out, image_header_
        )
        assert isinstance(image, Image)

    def it_provides_access_to_the_image_blob(self):
        blob = b'foobar'
        image = Image(blob, None, None)
        assert image.blob == blob

    def it_knows_the_image_content_type(self, content_type_fixture):
        image_header_, content_type = content_type_fixture
        image = Image(None, None, image_header_)
        assert image.content_type == content_type

    def it_knows_the_image_dimensions(self, dimensions_fixture):
        image_header_, px_width, px_height = dimensions_fixture
        image = Image(None, None, image_header_)
        assert image.px_width == px_width
        assert image.px_height == px_height

    def it_knows_the_image_filename(self):
        filename = 'foobar.png'
        image = Image(None, filename, None)
        assert image.filename == filename

    def it_knows_the_image_filename_extension(self):
        image = Image(None, 'foobar.png', None)
        assert image.ext == 'png'

    def it_knows_the_horz_and_vert_dpi_of_the_image(self, dpi_fixture):
        image_header_, horz_dpi, vert_dpi = dpi_fixture
        image = Image(None, None, image_header_)
        assert image.horz_dpi == horz_dpi
        assert image.vert_dpi == vert_dpi

    def it_knows_the_sha1_of_its_image(self):
        blob = b'fO0Bar'
        image = Image(blob, None, None)
        assert image.sha1 == '4921e7002ddfba690a937d54bda226a7b8bdeb68'

    def it_correctly_characterizes_known_images(self, known_image_fixture):
        image_path, characteristics = known_image_fixture
        ext, content_type, px_width, px_height, horz_dpi, vert_dpi = (
            characteristics
        )
        with open(test_file(image_path), 'rb') as stream:
            image = Image.from_file(stream)
            assert image.content_type == content_type
            assert image.ext == ext
            assert image.px_width == px_width
            assert image.px_height == px_height
            assert image.horz_dpi == horz_dpi
            assert image.vert_dpi == vert_dpi

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def blob_(self, request):
        return instance_mock(request, bytes)

    @pytest.fixture
    def BytesIO_(self, request, stream_):
        return class_mock(
            request, 'docx.image.image.BytesIO', return_value=stream_
        )

    @pytest.fixture
    def content_type_fixture(self, image_header_):
        content_type = 'image/foobar'
        image_header_.content_type = content_type
        return image_header_, content_type

    @pytest.fixture
    def dimensions_fixture(self, image_header_):
        px_width, px_height = 111, 222
        image_header_.px_width = px_width
        image_header_.px_height = px_height
        return image_header_, px_width, px_height

    @pytest.fixture
    def dpi_fixture(self, image_header_):
        horz_dpi, vert_dpi = 333, 444
        image_header_.horz_dpi = horz_dpi
        image_header_.vert_dpi = vert_dpi
        return image_header_, horz_dpi, vert_dpi

    @pytest.fixture
    def filename_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def from_blob_fixture(
            self, blob_, BytesIO_, _from_stream_, stream_, image_):
        return blob_, BytesIO_, _from_stream_, stream_, image_

    @pytest.fixture
    def from_filelike_fixture(self, _from_stream_, image_):
        image_path = test_file('python-icon.png')
        with open(image_path, 'rb') as f:
            blob = f.read()
        image_stream = BytesIO(blob)
        return image_stream, _from_stream_, blob, image_

    @pytest.fixture
    def from_path_fixture(self, _from_stream_, BytesIO_, stream_, image_):
        filename = 'python-icon.png'
        image_path = test_file(filename)
        with open(image_path, 'rb') as f:
            blob = f.read()
        return image_path, _from_stream_, stream_, blob, filename, image_

    @pytest.fixture(params=['foobar.png', None])
    def from_stream_fixture(
            self, request, stream_, blob_, _ImageHeaderFactory_,
            image_header_, Image__init_):
        filename_in = request.param
        filename_out = 'image.png' if filename_in is None else filename_in
        return (
            stream_, blob_, filename_in, _ImageHeaderFactory_, image_header_,
            Image__init_, filename_out
        )

    @pytest.fixture
    def _from_stream_(self, request, image_):
        return method_mock(
            request, Image, '_from_stream', return_value=image_
        )

    @pytest.fixture
    def image_(self, request):
        return instance_mock(request, Image)

    @pytest.fixture
    def _ImageHeaderFactory_(self, request, image_header_):
        return function_mock(
            request, 'docx.image.image._ImageHeaderFactory',
            return_value=image_header_
        )

    @pytest.fixture
    def image_header_(self, request):
        return instance_mock(request, BaseImageHeader, default_ext='png')

    @pytest.fixture
    def Image__init_(self, request):
        return initializer_mock(request, Image)

    @pytest.fixture(params=[0, 1, 2, 3, 4, 5, 6, 7, 8])
    def known_image_fixture(self, request):
        cases = (
            ('python.bmp',       ('bmp',  CT.BMP,   211,   71,  96,  96)),
            ('sonic.gif',        ('gif',  CT.GIF,   290,  360,  72,  72)),
            ('python-icon.jpeg', ('jpg',  CT.JPEG,  204,  204,  72,  72)),
            ('300-dpi.jpg',      ('jpg',  CT.JPEG, 1504, 1936, 300, 300)),
            ('monty-truth.png',  ('png',  CT.PNG,   150,  214,  72,  72)),
            ('150-dpi.png',      ('png',  CT.PNG,   901, 1350, 150, 150)),
            ('300-dpi.png',      ('png',  CT.PNG,   860,  579, 300, 300)),
            ('72-dpi.tiff',      ('tiff', CT.TIFF,   48,   48,  72,  72)),
            ('300-dpi.TIF',      ('tiff', CT.TIFF, 2464, 3248, 300, 300)),
            # ('CVS_LOGO.WMF',     ('wmf',  CT.X_WMF, 149,   59,  72,  72)),
        )
        image_filename, characteristics = cases[request.param]
        return image_filename, characteristics

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_ImageHeaderFactory(object):

    def it_constructs_the_right_class_for_a_given_image_stream(
            self, call_fixture):
        stream, expected_class = call_fixture
        image_header = _ImageHeaderFactory(stream)
        assert isinstance(image_header, expected_class)

    def it_raises_on_unrecognized_image_stream(self):
        stream = BytesIO(b'foobar 666 not an image stream')
        with pytest.raises(UnrecognizedImageError):
            _ImageHeaderFactory(stream)

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        ('python-icon.png',   Png),
        ('python-icon.jpeg',  Jfif),
        ('exif-420-dpi.jpg',  Exif),
        ('sonic.gif',         Gif),
        ('72-dpi.tiff',       Tiff),
        ('little-endian.tif', Tiff),
        ('python.bmp',        Bmp),
    ])
    def call_fixture(self, request):
        image_filename, expected_class = request.param
        image_path = test_file(image_filename)
        with open(image_path, 'rb') as f:
            blob = f.read()
        image_stream = BytesIO(blob)
        image_stream.seek(666)
        return image_stream, expected_class


class DescribeBaseImageHeader(object):

    def it_defines_content_type_as_an_abstract_property(self):
        base_image_header = BaseImageHeader(None, None, None, None)
        with pytest.raises(NotImplementedError):
            base_image_header.content_type

    def it_defines_default_ext_as_an_abstract_property(self):
        base_image_header = BaseImageHeader(None, None, None, None)
        with pytest.raises(NotImplementedError):
            base_image_header.default_ext

    def it_knows_the_image_dimensions(self):
        px_width, px_height = 42, 24
        image_header = BaseImageHeader(px_width, px_height, None, None)
        assert image_header.px_width == px_width
        assert image_header.px_height == px_height

    def it_knows_the_horz_and_vert_dpi_of_the_image(self):
        horz_dpi, vert_dpi = 42, 24
        image_header = BaseImageHeader(None, None, horz_dpi, vert_dpi)
        assert image_header.horz_dpi == horz_dpi
        assert image_header.vert_dpi == vert_dpi

########NEW FILE########
__FILENAME__ = test_jpeg
# encoding: utf-8

"""
Test suite for docx.image.jpeg module
"""

from __future__ import absolute_import, print_function

import pytest

from mock import call

from docx.compat import BytesIO
from docx.image.constants import JPEG_MARKER_CODE, MIME_TYPE
from docx.image.helpers import BIG_ENDIAN, StreamReader
from docx.image.jpeg import (
    _App0Marker, _App1Marker, Exif, Jfif, _JfifMarkers, Jpeg, _Marker,
    _MarkerFactory, _MarkerFinder, _MarkerParser, _SofMarker
)
from docx.image.tiff import Tiff

from ..unitutil import (
    initializer_mock, class_mock, instance_mock, method_mock
)


class DescribeJpeg(object):

    def it_knows_its_content_type(self):
        jpeg = Jpeg(None, None, None, None)
        assert jpeg.content_type == MIME_TYPE.JPEG

    def it_knows_its_default_ext(self):
        jpeg = Jpeg(None, None, None, None)
        assert jpeg.default_ext == 'jpg'

    class DescribeExif(object):

        def it_can_construct_from_an_exif_stream(self, from_exif_fixture):
            # fixture ----------------------
            stream_, _JfifMarkers_, cx, cy, horz_dpi, vert_dpi = (
                from_exif_fixture
            )
            # exercise ---------------------
            exif = Exif.from_stream(stream_)
            # verify -----------------------
            _JfifMarkers_.from_stream.assert_called_once_with(stream_)
            assert isinstance(exif, Exif)
            assert exif.px_width == cx
            assert exif.px_height == cy
            assert exif.horz_dpi == horz_dpi
            assert exif.vert_dpi == vert_dpi

    class DescribeJfif(object):

        def it_can_construct_from_a_jfif_stream(self, from_jfif_fixture):
            stream_, _JfifMarkers_, cx, cy, horz_dpi, vert_dpi = (
                from_jfif_fixture
            )
            jfif = Jfif.from_stream(stream_)
            _JfifMarkers_.from_stream.assert_called_once_with(stream_)
            assert isinstance(jfif, Jfif)
            assert jfif.px_width == cx
            assert jfif.px_height == cy
            assert jfif.horz_dpi == horz_dpi
            assert jfif.vert_dpi == vert_dpi

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_exif_fixture(self, stream_, _JfifMarkers_, jfif_markers_):
        px_width, px_height = 111, 222
        horz_dpi, vert_dpi = 333, 444
        jfif_markers_.sof.px_width = px_width
        jfif_markers_.sof.px_height = px_height
        jfif_markers_.app1.horz_dpi = horz_dpi
        jfif_markers_.app1.vert_dpi = vert_dpi
        return (
            stream_, _JfifMarkers_, px_width, px_height, horz_dpi, vert_dpi
        )

    @pytest.fixture
    def from_jfif_fixture(self, stream_, _JfifMarkers_, jfif_markers_):
        px_width, px_height = 111, 222
        horz_dpi, vert_dpi = 333, 444
        jfif_markers_.sof.px_width = px_width
        jfif_markers_.sof.px_height = px_height
        jfif_markers_.app0.horz_dpi = horz_dpi
        jfif_markers_.app0.vert_dpi = vert_dpi
        return (
            stream_, _JfifMarkers_, px_width, px_height, horz_dpi, vert_dpi
        )

    @pytest.fixture
    def _JfifMarkers_(self, request, jfif_markers_):
        _JfifMarkers_ = class_mock(request, 'docx.image.jpeg._JfifMarkers')
        _JfifMarkers_.from_stream.return_value = jfif_markers_
        return _JfifMarkers_

    @pytest.fixture
    def jfif_markers_(self, request):
        return instance_mock(request, _JfifMarkers)

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_JfifMarkers(object):

    def it_can_construct_from_a_jfif_stream(self, from_stream_fixture):
        stream_, _MarkerParser_, _JfifMarkers__init_, marker_lst = (
            from_stream_fixture
        )
        jfif_markers = _JfifMarkers.from_stream(stream_)
        _MarkerParser_.from_stream.assert_called_once_with(stream_)
        _JfifMarkers__init_.assert_called_once_with(marker_lst)
        assert isinstance(jfif_markers, _JfifMarkers)

    def it_can_find_the_APP0_marker(self, app0_fixture):
        jfif_markers, app0_ = app0_fixture
        app0 = jfif_markers.app0
        assert app0 is app0_

    def it_can_find_the_APP1_marker(self, app1_fixture):
        jfif_markers, app1_ = app1_fixture
        app1 = jfif_markers.app1
        assert app1 is app1_

    def it_raises_if_it_cant_find_the_APP0_marker(self, no_app0_fixture):
        jfif_markers = no_app0_fixture
        with pytest.raises(KeyError):
            jfif_markers.app0

    def it_raises_if_it_cant_find_the_APP1_marker(self, no_app1_fixture):
        jfif_markers = no_app1_fixture
        with pytest.raises(KeyError):
            jfif_markers.app1

    def it_can_find_the_SOF_marker(self, sof_fixture):
        jfif_markers, sof_ = sof_fixture
        sof = jfif_markers.sof
        assert sof is sof_

    def it_raises_if_it_cant_find_the_SOF_marker(self, no_sof_fixture):
        jfif_markers = no_sof_fixture
        with pytest.raises(KeyError):
            jfif_markers.sof

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def app0_(self, request):
        return instance_mock(
            request, _App0Marker, marker_code=JPEG_MARKER_CODE.APP0
        )

    @pytest.fixture
    def app1_(self, request):
        return instance_mock(
            request, _App1Marker, marker_code=JPEG_MARKER_CODE.APP1
        )

    @pytest.fixture
    def app0_fixture(self, soi_, app0_, eoi_):
        markers = (soi_, app0_, eoi_)
        jfif_markers = _JfifMarkers(markers)
        return jfif_markers, app0_

    @pytest.fixture
    def app1_fixture(self, soi_, app1_, eoi_):
        markers = (soi_, app1_, eoi_)
        jfif_markers = _JfifMarkers(markers)
        return jfif_markers, app1_

    @pytest.fixture
    def eoi_(self, request):
        return instance_mock(
            request, _SofMarker, marker_code=JPEG_MARKER_CODE.EOI
        )

    @pytest.fixture
    def from_stream_fixture(
            self, stream_, _MarkerParser_, _JfifMarkers__init_, soi_, app0_,
            sof_, sos_):
        marker_lst = [soi_, app0_, sof_, sos_]
        return stream_, _MarkerParser_, _JfifMarkers__init_, marker_lst

    @pytest.fixture
    def _JfifMarkers__init_(self, request):
        return initializer_mock(request, _JfifMarkers)

    @pytest.fixture
    def marker_parser_(self, request, markers_all_):
        marker_parser_ = instance_mock(request, _MarkerParser)
        marker_parser_.iter_markers.return_value = markers_all_
        return marker_parser_

    @pytest.fixture
    def _MarkerParser_(self, request, marker_parser_):
        _MarkerParser_ = class_mock(request, 'docx.image.jpeg._MarkerParser')
        _MarkerParser_.from_stream.return_value = marker_parser_
        return _MarkerParser_

    @pytest.fixture
    def markers_all_(self, request, soi_, app0_, sof_, sos_, eoi_):
        return [soi_, app0_, sof_, sos_, eoi_]

    @pytest.fixture
    def no_app0_fixture(self, soi_, eoi_):
        markers = (soi_, eoi_)
        return _JfifMarkers(markers)

    @pytest.fixture
    def no_app1_fixture(self, soi_, eoi_):
        markers = (soi_, eoi_)
        return _JfifMarkers(markers)

    @pytest.fixture
    def no_sof_fixture(self, soi_, eoi_):
        markers = (soi_, eoi_)
        return _JfifMarkers(markers)

    @pytest.fixture
    def sof_(self, request):
        return instance_mock(
            request, _SofMarker, marker_code=JPEG_MARKER_CODE.SOF0
        )

    @pytest.fixture
    def sof_fixture(self, soi_, sof_, eoi_):
        markers = (soi_, sof_, eoi_)
        jfif_markers = _JfifMarkers(markers)
        return jfif_markers, sof_

    @pytest.fixture
    def soi_(self, request):
        return instance_mock(
            request, _Marker, marker_code=JPEG_MARKER_CODE.SOI
        )

    @pytest.fixture
    def sos_(self, request):
        return instance_mock(
            request, _Marker, marker_code=JPEG_MARKER_CODE.SOS
        )

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_Marker(object):

    def it_can_construct_from_a_stream_and_offset(self, from_stream_fixture):
        stream, marker_code, offset, _Marker__init_, length = (
            from_stream_fixture
        )
        marker = _Marker.from_stream(stream, marker_code, offset)
        _Marker__init_.assert_called_once_with(marker_code, offset, length)
        assert isinstance(marker, _Marker)

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (JPEG_MARKER_CODE.SOI,  2,  0),
        (JPEG_MARKER_CODE.APP0, 4, 16),
    ])
    def from_stream_fixture(self, request, _Marker__init_):
        marker_code, offset, length = request.param
        bytes_ = b'\xFF\xD8\xFF\xE0\x00\x10'
        stream_reader = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        return stream_reader, marker_code, offset, _Marker__init_, length

    @pytest.fixture
    def _Marker__init_(self, request):
        return initializer_mock(request, _Marker)


class Describe_App0Marker(object):

    def it_can_construct_from_a_stream_and_offset(self, from_stream_fixture):
        (stream, marker_code, offset, _App0Marker__init_, length,
         density_units, x_density, y_density) = from_stream_fixture
        app0_marker = _App0Marker.from_stream(stream, marker_code, offset)
        _App0Marker__init_.assert_called_once_with(
            marker_code, offset, length, density_units, x_density, y_density
        )
        assert isinstance(app0_marker, _App0Marker)

    def it_knows_the_image_dpi(self, dpi_fixture):
        density_units, x_density, y_density, horz_dpi, vert_dpi = dpi_fixture
        app0 = _App0Marker(
            None, None, None, density_units, x_density, y_density
        )
        assert app0.horz_dpi == horz_dpi
        assert app0.vert_dpi == vert_dpi

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def _App0Marker__init_(self, request):
        return initializer_mock(request, _App0Marker)

    @pytest.fixture(params=[
        (0, 100, 200,  72,  72),
        (1, 100, 200, 100, 200),
        (2, 100, 200, 254, 508),
    ])
    def dpi_fixture(self, request):
        density_units, x_density, y_density, horz_dpi, vert_dpi = (
            request.param
        )
        return density_units, x_density, y_density, horz_dpi, vert_dpi

    @pytest.fixture
    def from_stream_fixture(self, request, _App0Marker__init_):
        bytes_ = b'\x00\x10JFIF\x00\x01\x01\x01\x00\x2A\x00\x18'
        stream_reader = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        marker_code, offset, length = JPEG_MARKER_CODE.APP0, 0, 16
        density_units, x_density, y_density = 1, 42, 24
        return (
            stream_reader, marker_code, offset, _App0Marker__init_, length,
            density_units, x_density, y_density
        )


class Describe_App1Marker(object):

    def it_can_construct_from_a_stream_and_offset(self, from_stream_fixture):
        (stream, marker_code, offset, _App1Marker__init_, length,
         _tiff_from_exif_segment_, horz_dpi, vert_dpi) = from_stream_fixture
        app1_marker = _App1Marker.from_stream(stream, marker_code, offset)
        _tiff_from_exif_segment_.assert_called_once_with(
            stream, offset, length
        )
        _App1Marker__init_.assert_called_once_with(
            marker_code, offset, length, horz_dpi, vert_dpi
        )
        assert isinstance(app1_marker, _App1Marker)

    def it_can_construct_from_non_Exif_APP1_segment(self, non_Exif_fixture):
        stream, marker_code, offset = non_Exif_fixture[:3]
        _App1Marker__init_, length = non_Exif_fixture[3:]
        app1_marker = _App1Marker.from_stream(stream, marker_code, offset)
        _App1Marker__init_.assert_called_once_with(
            marker_code, offset, length, 72, 72
        )
        assert isinstance(app1_marker, _App1Marker)

    def it_gets_a_tiff_from_its_Exif_segment_to_help_construct(
            self, get_tiff_fixture):
        stream, offset, length = get_tiff_fixture[:3]
        BytesIO_, segment_bytes, substream_ = get_tiff_fixture[3:6]
        Tiff_, tiff_ = get_tiff_fixture[6:]
        tiff = _App1Marker._tiff_from_exif_segment(stream, offset, length)
        BytesIO_.assert_called_once_with(segment_bytes)
        Tiff_.from_stream.assert_called_once_with(substream_)
        assert tiff is tiff_

    def it_knows_the_image_dpi(self):
        horz_dpi, vert_dpi = 42, 24
        app1 = _App1Marker(None, None, None, horz_dpi, vert_dpi)
        assert app1.horz_dpi == horz_dpi
        assert app1.vert_dpi == vert_dpi

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def _App1Marker__init_(self, request):
        return initializer_mock(request, _App1Marker)

    @pytest.fixture
    def BytesIO_(self, request, substream_):
        return class_mock(
            request, 'docx.image.jpeg.BytesIO', return_value=substream_
        )

    @pytest.fixture
    def from_stream_fixture(
            self, request, _App1Marker__init_, _tiff_from_exif_segment_):
        bytes_ = b'\x00\x42Exif\x00\x00'
        stream_reader = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        marker_code, offset, length = JPEG_MARKER_CODE.APP1, 0, 66
        horz_dpi, vert_dpi = 42, 24
        return (
            stream_reader, marker_code, offset, _App1Marker__init_, length,
            _tiff_from_exif_segment_, horz_dpi, vert_dpi
        )

    @pytest.fixture
    def get_tiff_fixture(self, request, BytesIO_, substream_, Tiff_, tiff_):
        bytes_ = b'xfillerxMM\x00*\x00\x00\x00\x42'
        stream_reader = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        offset, segment_length, segment_bytes = 0, 16, bytes_[8:]
        return (
            stream_reader, offset, segment_length, BytesIO_, segment_bytes,
            substream_, Tiff_, tiff_
        )

    @pytest.fixture
    def non_Exif_fixture(self, request, _App1Marker__init_):
        bytes_ = b'\x00\x42Foobar'
        stream_reader = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        marker_code, offset, length = JPEG_MARKER_CODE.APP1, 0, 66
        return stream_reader, marker_code, offset, _App1Marker__init_, length

    @pytest.fixture
    def substream_(self, request):
        return instance_mock(request, BytesIO)

    @pytest.fixture
    def Tiff_(self, request, tiff_):
        Tiff_ = class_mock(request, 'docx.image.jpeg.Tiff')
        Tiff_.from_stream.return_value = tiff_
        return Tiff_

    @pytest.fixture
    def tiff_(self, request):
        return instance_mock(request, Tiff, horz_dpi=42, vert_dpi=24)

    @pytest.fixture
    def _tiff_from_exif_segment_(self, request, tiff_):
        return method_mock(
            request, _App1Marker, '_tiff_from_exif_segment',
            return_value=tiff_
        )


class Describe_SofMarker(object):

    def it_can_construct_from_a_stream_and_offset(self, from_stream_fixture):
        (stream, marker_code, offset, _SofMarker__init_, length,
         px_width, px_height) = from_stream_fixture
        sof_marker = _SofMarker.from_stream(stream, marker_code, offset)
        _SofMarker__init_.assert_called_once_with(
            marker_code, offset, length, px_width, px_height
        )
        assert isinstance(sof_marker, _SofMarker)

    def it_knows_the_image_width_and_height(self):
        sof = _SofMarker(None, None, None, 42, 24)
        assert sof.px_width == 42
        assert sof.px_height == 24

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(self, request, _SofMarker__init_):
        bytes_ = b'\x00\x11\x00\x00\x2A\x00\x18'
        stream_reader = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        marker_code, offset, length = JPEG_MARKER_CODE.SOF0, 0, 17
        px_width, px_height = 24, 42
        return (
            stream_reader, marker_code, offset, _SofMarker__init_, length,
            px_width, px_height
        )

    @pytest.fixture
    def _SofMarker__init_(self, request):
        return initializer_mock(request, _SofMarker)


class Describe_MarkerFactory(object):

    def it_constructs_the_appropriate_marker_object(self, call_fixture):
        marker_code, stream_, offset_, marker_cls_ = call_fixture
        marker = _MarkerFactory(marker_code, stream_, offset_)
        marker_cls_.from_stream.assert_called_once_with(
            stream_, marker_code, offset_
        )
        assert marker is marker_cls_.from_stream.return_value

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        JPEG_MARKER_CODE.APP0,
        JPEG_MARKER_CODE.APP1,
        JPEG_MARKER_CODE.SOF0,
        JPEG_MARKER_CODE.SOF7,
        JPEG_MARKER_CODE.SOS,
    ])
    def call_fixture(
            self, request, stream_, offset_, _App0Marker_, _App1Marker_,
            _SofMarker_, _Marker_):
        marker_code = request.param
        if marker_code == JPEG_MARKER_CODE.APP0:
            marker_cls_ = _App0Marker_
        elif marker_code == JPEG_MARKER_CODE.APP1:
            marker_cls_ = _App1Marker_
        elif marker_code in JPEG_MARKER_CODE.SOF_MARKER_CODES:
            marker_cls_ = _SofMarker_
        else:
            marker_cls_ = _Marker_
        return marker_code, stream_, offset_, marker_cls_

    @pytest.fixture
    def _App0Marker_(self, request):
        return class_mock(request, 'docx.image.jpeg._App0Marker')

    @pytest.fixture
    def _App1Marker_(self, request):
        return class_mock(request, 'docx.image.jpeg._App1Marker')

    @pytest.fixture
    def _Marker_(self, request):
        return class_mock(request, 'docx.image.jpeg._Marker')

    @pytest.fixture
    def offset_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def _SofMarker_(self, request):
        return class_mock(request, 'docx.image.jpeg._SofMarker')

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_MarkerFinder(object):

    def it_can_construct_from_a_stream(self, from_stream_fixture):
        stream_, _MarkerFinder__init_ = from_stream_fixture
        marker_finder = _MarkerFinder.from_stream(stream_)
        _MarkerFinder__init_.assert_called_once_with(stream_)
        assert isinstance(marker_finder, _MarkerFinder)

    def it_can_find_the_next_marker_after_a_given_offset(self, next_fixture):
        marker_finder, start, expected_code_and_offset = next_fixture
        marker_code, segment_offset = marker_finder.next(start)
        assert (marker_code, segment_offset) == expected_code_and_offset

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(self, stream_, _MarkerFinder__init_):
        return stream_, _MarkerFinder__init_

    @pytest.fixture
    def _MarkerFinder__init_(self, request):
        return initializer_mock(request, _MarkerFinder)

    @pytest.fixture(params=[
        (0, JPEG_MARKER_CODE.SOI,   2),
        (1, JPEG_MARKER_CODE.APP0,  4),
        (2, JPEG_MARKER_CODE.APP0,  4),
        (3, JPEG_MARKER_CODE.EOI,  12),
        (4, JPEG_MARKER_CODE.EOI,  12),
        (6, JPEG_MARKER_CODE.EOI,  12),
        (8, JPEG_MARKER_CODE.EOI,  12),
    ])
    def next_fixture(self, request):
        start, marker_code, segment_offset = request.param
        bytes_ = b'\xFF\xD8\xFF\xE0\x00\x01\xFF\x00\xFF\xFF\xFF\xD9'
        stream_reader = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        marker_finder = _MarkerFinder(stream_reader)
        expected_code_and_offset = (marker_code, segment_offset)
        return marker_finder, start, expected_code_and_offset

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_MarkerParser(object):

    def it_can_construct_from_a_jfif_stream(self, from_stream_fixture):
        stream_, StreamReader_, _MarkerParser__init_, stream_reader_ = (
            from_stream_fixture
        )
        marker_parser = _MarkerParser.from_stream(stream_)
        StreamReader_.assert_called_once_with(stream_, BIG_ENDIAN)
        _MarkerParser__init_.assert_called_once_with(stream_reader_)
        assert isinstance(marker_parser, _MarkerParser)

    def it_can_iterate_over_the_jfif_markers_in_its_stream(
            self, iter_markers_fixture):
        (marker_parser, stream_, _MarkerFinder_, marker_finder_,
         _MarkerFactory_, marker_codes, offsets,
         marker_lst) = iter_markers_fixture
        markers = [marker for marker in marker_parser.iter_markers()]
        _MarkerFinder_.from_stream.assert_called_once_with(stream_)
        assert marker_finder_.next.call_args_list == [
            call(0), call(2), call(20)
        ]
        assert _MarkerFactory_.call_args_list == [
            call(marker_codes[0], stream_, offsets[0]),
            call(marker_codes[1], stream_, offsets[1]),
            call(marker_codes[2], stream_, offsets[2]),
        ]
        assert markers == marker_lst

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def app0_(self, request):
        return instance_mock(request, _App0Marker, segment_length=16)

    @pytest.fixture
    def eoi_(self, request):
        return instance_mock(request, _Marker, segment_length=0)

    @pytest.fixture
    def from_stream_fixture(
            self, stream_, StreamReader_, _MarkerParser__init_,
            stream_reader_):
        return stream_, StreamReader_, _MarkerParser__init_, stream_reader_

    @pytest.fixture
    def iter_markers_fixture(
            self, stream_reader_, _MarkerFinder_, marker_finder_,
            _MarkerFactory_, soi_, app0_, eoi_):
        marker_parser = _MarkerParser(stream_reader_)
        offsets = [2, 4, 22]
        marker_lst = [soi_, app0_, eoi_]
        marker_finder_.next.side_effect = [
            (JPEG_MARKER_CODE.SOI,  offsets[0]),
            (JPEG_MARKER_CODE.APP0, offsets[1]),
            (JPEG_MARKER_CODE.EOI,  offsets[2]),
        ]
        marker_codes = [
            JPEG_MARKER_CODE.SOI, JPEG_MARKER_CODE.APP0, JPEG_MARKER_CODE.EOI
        ]
        return (
            marker_parser, stream_reader_, _MarkerFinder_, marker_finder_,
            _MarkerFactory_, marker_codes, offsets, marker_lst
        )

    @pytest.fixture
    def _MarkerFactory_(self, request, soi_, app0_, eoi_):
        return class_mock(
            request, 'docx.image.jpeg._MarkerFactory',
            side_effect=[soi_, app0_, eoi_]
        )

    @pytest.fixture
    def _MarkerFinder_(self, request, marker_finder_):
        _MarkerFinder_ = class_mock(request, 'docx.image.jpeg._MarkerFinder')
        _MarkerFinder_.from_stream.return_value = marker_finder_
        return _MarkerFinder_

    @pytest.fixture
    def marker_finder_(self, request):
        return instance_mock(request, _MarkerFinder)

    @pytest.fixture
    def _MarkerParser__init_(self, request):
        return initializer_mock(request, _MarkerParser)

    @pytest.fixture
    def soi_(self, request):
        return instance_mock(request, _Marker, segment_length=0)

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)

    @pytest.fixture
    def StreamReader_(self, request, stream_reader_):
        return class_mock(
            request, 'docx.image.jpeg.StreamReader',
            return_value=stream_reader_
        )

    @pytest.fixture
    def stream_reader_(self, request):
        return instance_mock(request, StreamReader)

########NEW FILE########
__FILENAME__ = test_png
# encoding: utf-8

"""
Test suite for docx.image.png module
"""

from __future__ import absolute_import, print_function

import pytest

from mock import call

from docx.compat import BytesIO
from docx.image.constants import MIME_TYPE, PNG_CHUNK_TYPE
from docx.image.exceptions import InvalidImageStreamError
from docx.image.helpers import BIG_ENDIAN, StreamReader
from docx.image.png import (
    _Chunk, _Chunks, _ChunkFactory, _ChunkParser, _IHDRChunk, _pHYsChunk,
    Png, _PngParser
)

from ..unitutil import (
    function_mock, class_mock, initializer_mock, instance_mock, method_mock
)


class DescribePng(object):

    def it_can_construct_from_a_png_stream(self, from_stream_fixture):
        stream_, _PngParser_, Png__init__, cx, cy, horz_dpi, vert_dpi = (
            from_stream_fixture
        )
        png = Png.from_stream(stream_)
        _PngParser_.parse.assert_called_once_with(stream_)
        Png__init__.assert_called_once_with(cx, cy, horz_dpi, vert_dpi)
        assert isinstance(png, Png)

    def it_knows_its_content_type(self):
        png = Png(None, None, None, None)
        assert png.content_type == MIME_TYPE.PNG

    def it_knows_its_default_ext(self):
        png = Png(None, None, None, None)
        assert png.default_ext == 'png'

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(
            self, stream_, _PngParser_, png_parser_, Png__init__):
        px_width, px_height, horz_dpi, vert_dpi = 42, 24, 36, 63
        png_parser_.px_width = px_width
        png_parser_.px_height = px_height
        png_parser_.horz_dpi = horz_dpi
        png_parser_.vert_dpi = vert_dpi
        return (
            stream_, _PngParser_, Png__init__, px_width, px_height,
            horz_dpi, vert_dpi
        )

    @pytest.fixture
    def Png__init__(self, request):
        return initializer_mock(request, Png)

    @pytest.fixture
    def _PngParser_(self, request, png_parser_):
        _PngParser_ = class_mock(request, 'docx.image.png._PngParser')
        _PngParser_.parse.return_value = png_parser_
        return _PngParser_

    @pytest.fixture
    def png_parser_(self, request):
        return instance_mock(request, _PngParser)

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_PngParser(object):

    def it_can_parse_the_headers_of_a_PNG_stream(self, parse_fixture):
        stream_, _Chunks_, _PngParser__init_, chunks_ = parse_fixture
        png_parser = _PngParser.parse(stream_)
        _Chunks_.from_stream.assert_called_once_with(stream_)
        _PngParser__init_.assert_called_once_with(chunks_)
        assert isinstance(png_parser, _PngParser)

    def it_knows_the_image_width_and_height(self, dimensions_fixture):
        png_parser, px_width, px_height = dimensions_fixture
        assert png_parser.px_width == px_width
        assert png_parser.px_height == px_height

    def it_knows_the_image_dpi(self, dpi_fixture):
        png_parser, horz_dpi, vert_dpi = dpi_fixture
        assert png_parser.horz_dpi == horz_dpi
        assert png_parser.vert_dpi == vert_dpi

    def it_defaults_image_dpi_to_72(self, no_dpi_fixture):
        png_parser = no_dpi_fixture
        assert png_parser.horz_dpi == 72
        assert png_parser.vert_dpi == 72

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def _Chunks_(self, request, chunks_):
        _Chunks_ = class_mock(request, 'docx.image.png._Chunks')
        _Chunks_.from_stream.return_value = chunks_
        return _Chunks_

    @pytest.fixture
    def chunks_(self, request):
        return instance_mock(request, _Chunks)

    @pytest.fixture
    def dimensions_fixture(self, chunks_):
        px_width, px_height = 12, 34
        chunks_.IHDR.px_width = px_width
        chunks_.IHDR.px_height = px_height
        png_parser = _PngParser(chunks_)
        return png_parser, px_width, px_height

    @pytest.fixture
    def dpi_fixture(self, chunks_):
        horz_px_per_unit, vert_px_per_unit, units_specifier = 1654, 945, 1
        horz_dpi, vert_dpi = 42, 24
        chunks_.pHYs.horz_px_per_unit = horz_px_per_unit
        chunks_.pHYs.vert_px_per_unit = vert_px_per_unit
        chunks_.pHYs.units_specifier = units_specifier
        png_parser = _PngParser(chunks_)
        return png_parser, horz_dpi, vert_dpi

    @pytest.fixture(params=[
        (-1, -1), (0, 1000), (None, 1000), (1, 0), (1, None)
    ])
    def no_dpi_fixture(self, request, chunks_):
        """
        Scenarios are: 1) no pHYs chunk in PNG stream, 2) units specifier
        other than 1; 3) px_per_unit is 0; 4) px_per_unit is None
        """
        units_specifier, px_per_unit = request.param
        if units_specifier == -1:
            chunks_.pHYs = None
        else:
            chunks_.pHYs.horz_px_per_unit = px_per_unit
            chunks_.pHYs.vert_px_per_unit = px_per_unit
            chunks_.pHYs.units_specifier = units_specifier
        png_parser = _PngParser(chunks_)
        return png_parser

    @pytest.fixture
    def parse_fixture(self, stream_, _Chunks_, _PngParser__init_, chunks_):
        return stream_, _Chunks_, _PngParser__init_, chunks_

    @pytest.fixture
    def _PngParser__init_(self, request):
        return initializer_mock(request, _PngParser)

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_Chunks(object):

    def it_can_construct_from_a_stream(self, from_stream_fixture):
        stream_, _ChunkParser_, chunk_parser_, _Chunks__init_, chunk_lst = (
            from_stream_fixture
        )
        chunks = _Chunks.from_stream(stream_)
        _ChunkParser_.from_stream.assert_called_once_with(stream_)
        chunk_parser_.iter_chunks.assert_called_once_with()
        _Chunks__init_.assert_called_once_with(chunk_lst)
        assert isinstance(chunks, _Chunks)

    def it_provides_access_to_the_IHDR_chunk(self, IHDR_fixture):
        chunks, IHDR_chunk_ = IHDR_fixture
        assert chunks.IHDR == IHDR_chunk_

    def it_provides_access_to_the_pHYs_chunk(self, pHYs_fixture):
        chunks, expected_chunk = pHYs_fixture
        assert chunks.pHYs == expected_chunk

    def it_raises_if_theres_no_IHDR_chunk(self, no_IHDR_fixture):
        chunks = no_IHDR_fixture
        with pytest.raises(InvalidImageStreamError):
            chunks.IHDR

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(
            self, stream_, _ChunkParser_, chunk_parser_, _Chunks__init_):
        chunk_lst = [1, 2]
        chunk_parser_.iter_chunks.return_value = iter(chunk_lst)
        return (
            stream_, _ChunkParser_, chunk_parser_, _Chunks__init_, chunk_lst
        )

    @pytest.fixture
    def _ChunkParser_(self, request, chunk_parser_):
        _ChunkParser_ = class_mock(request, 'docx.image.png._ChunkParser')
        _ChunkParser_.from_stream.return_value = chunk_parser_
        return _ChunkParser_

    @pytest.fixture
    def chunk_parser_(self, request):
        return instance_mock(request, _ChunkParser)

    @pytest.fixture
    def _Chunks__init_(self, request):
        return initializer_mock(request, _Chunks)

    @pytest.fixture
    def IHDR_fixture(self, IHDR_chunk_, pHYs_chunk_):
        chunks = (IHDR_chunk_, pHYs_chunk_)
        chunks = _Chunks(chunks)
        return chunks, IHDR_chunk_

    @pytest.fixture
    def IHDR_chunk_(self, request):
        return instance_mock(
            request, _IHDRChunk, type_name=PNG_CHUNK_TYPE.IHDR
        )

    @pytest.fixture
    def no_IHDR_fixture(self, pHYs_chunk_):
        chunks = (pHYs_chunk_,)
        chunks = _Chunks(chunks)
        return chunks

    @pytest.fixture
    def pHYs_chunk_(self, request):
        return instance_mock(
            request, _pHYsChunk, type_name=PNG_CHUNK_TYPE.pHYs
        )

    @pytest.fixture(params=[True, False])
    def pHYs_fixture(self, request, IHDR_chunk_, pHYs_chunk_):
        has_pHYs_chunk = request.param
        chunks = [IHDR_chunk_]
        if has_pHYs_chunk:
            chunks.append(pHYs_chunk_)
        expected_chunk = pHYs_chunk_ if has_pHYs_chunk else None
        chunks = _Chunks(chunks)
        return chunks, expected_chunk

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_ChunkParser(object):

    def it_can_construct_from_a_stream(self, from_stream_fixture):
        stream_, StreamReader_, stream_rdr_, _ChunkParser__init_ = (
            from_stream_fixture
        )
        chunk_parser = _ChunkParser.from_stream(stream_)
        StreamReader_.assert_called_once_with(stream_, BIG_ENDIAN)
        _ChunkParser__init_.assert_called_once_with(stream_rdr_)
        assert isinstance(chunk_parser, _ChunkParser)

    def it_can_iterate_over_the_chunks_in_its_png_stream(self, iter_fixture):
        # fixture ----------------------
        chunk_parser, _iter_chunk_offsets_, _ChunkFactory_ = iter_fixture[:3]
        stream_rdr_, offsets, chunk_lst = iter_fixture[3:]
        # exercise ---------------------
        chunks = [chunk for chunk in chunk_parser.iter_chunks()]
        # verify -----------------------
        _iter_chunk_offsets_.assert_called_once_with()
        assert _ChunkFactory_.call_args_list == [
            call(PNG_CHUNK_TYPE.IHDR, stream_rdr_, offsets[0]),
            call(PNG_CHUNK_TYPE.pHYs, stream_rdr_, offsets[1]),
        ]
        assert chunks == chunk_lst

    def it_iterates_over_the_chunk_offsets_to_help_parse(
            self, iter_offsets_fixture):
        chunk_parser, expected_chunk_offsets = iter_offsets_fixture
        chunk_offsets = [co for co in chunk_parser._iter_chunk_offsets()]
        assert chunk_offsets == expected_chunk_offsets

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def chunk_(self, request):
        return instance_mock(request, _Chunk)

    @pytest.fixture
    def chunk_2_(self, request):
        return instance_mock(request, _Chunk)

    @pytest.fixture
    def _ChunkFactory_(self, request, chunk_lst_):
        return function_mock(
            request, 'docx.image.png._ChunkFactory',
            side_effect=chunk_lst_
        )

    @pytest.fixture
    def chunk_lst_(self, chunk_, chunk_2_):
        return [chunk_, chunk_2_]

    @pytest.fixture
    def _ChunkParser__init_(self, request):
        return initializer_mock(request, _ChunkParser)

    @pytest.fixture
    def from_stream_fixture(
            self, stream_, StreamReader_, stream_rdr_, _ChunkParser__init_):
        return stream_, StreamReader_, stream_rdr_, _ChunkParser__init_

    @pytest.fixture
    def _iter_chunk_offsets_(self, request):
        chunk_offsets = (
            (PNG_CHUNK_TYPE.IHDR, 2),
            (PNG_CHUNK_TYPE.pHYs, 4),
        )
        return method_mock(
            request, _ChunkParser, '_iter_chunk_offsets',
            return_value=iter(chunk_offsets)
        )

    @pytest.fixture
    def iter_fixture(
            self, _iter_chunk_offsets_, _ChunkFactory_, stream_rdr_, chunk_,
            chunk_2_):
        chunk_parser = _ChunkParser(stream_rdr_)
        offsets = [2, 4, 6]
        chunk_lst = [chunk_, chunk_2_]
        return (
            chunk_parser, _iter_chunk_offsets_, _ChunkFactory_, stream_rdr_,
            offsets, chunk_lst
        )

    @pytest.fixture
    def iter_offsets_fixture(self):
        bytes_ = b'-filler-\x00\x00\x00\x00IHDRxxxx\x00\x00\x00\x00IEND'
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        chunk_parser = _ChunkParser(stream_rdr)
        expected_chunk_offsets = [
            (PNG_CHUNK_TYPE.IHDR, 16),
            (PNG_CHUNK_TYPE.IEND, 28),
        ]
        return chunk_parser, expected_chunk_offsets

    @pytest.fixture
    def StreamReader_(self, request, stream_rdr_):
        return class_mock(
            request, 'docx.image.png.StreamReader', return_value=stream_rdr_
        )

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)

    @pytest.fixture
    def stream_rdr_(self, request):
        return instance_mock(request, StreamReader)


class Describe_ChunkFactory(object):

    def it_constructs_the_appropriate_Chunk_subclass(self, call_fixture):
        chunk_type, stream_rdr_, offset, chunk_cls_ = call_fixture
        chunk = _ChunkFactory(chunk_type, stream_rdr_, offset)
        chunk_cls_.from_offset.assert_called_once_with(
            chunk_type, stream_rdr_, offset
        )
        assert isinstance(chunk, _Chunk)

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        PNG_CHUNK_TYPE.IHDR,
        PNG_CHUNK_TYPE.pHYs,
        PNG_CHUNK_TYPE.IEND,
    ])
    def call_fixture(
            self, request, _IHDRChunk_, _pHYsChunk_, _Chunk_, stream_rdr_):
        chunk_type = request.param
        chunk_cls_ = {
            PNG_CHUNK_TYPE.IHDR: _IHDRChunk_,
            PNG_CHUNK_TYPE.pHYs: _pHYsChunk_,
            PNG_CHUNK_TYPE.IEND: _Chunk_,
        }[chunk_type]
        offset = 999
        return chunk_type, stream_rdr_, offset, chunk_cls_

    @pytest.fixture
    def _Chunk_(self, request, chunk_):
        _Chunk_ = class_mock(request, 'docx.image.png._Chunk')
        _Chunk_.from_offset.return_value = chunk_
        return _Chunk_

    @pytest.fixture
    def chunk_(self, request):
        return instance_mock(request, _Chunk)

    @pytest.fixture
    def _IHDRChunk_(self, request, ihdr_chunk_):
        _IHDRChunk_ = class_mock(request, 'docx.image.png._IHDRChunk')
        _IHDRChunk_.from_offset.return_value = ihdr_chunk_
        return _IHDRChunk_

    @pytest.fixture
    def ihdr_chunk_(self, request):
        return instance_mock(request, _IHDRChunk)

    @pytest.fixture
    def _pHYsChunk_(self, request, phys_chunk_):
        _pHYsChunk_ = class_mock(request, 'docx.image.png._pHYsChunk')
        _pHYsChunk_.from_offset.return_value = phys_chunk_
        return _pHYsChunk_

    @pytest.fixture
    def phys_chunk_(self, request):
        return instance_mock(request, _pHYsChunk)

    @pytest.fixture
    def stream_rdr_(self, request):
        return instance_mock(request, StreamReader)


class Describe_Chunk(object):

    def it_can_construct_from_a_stream_and_offset(self):
        chunk_type = 'fOOB'
        chunk = _Chunk.from_offset(chunk_type, None, None)
        assert isinstance(chunk, _Chunk)
        assert chunk.type_name == chunk_type


class Describe_IHDRChunk(object):

    def it_can_construct_from_a_stream_and_offset(self, from_offset_fixture):
        stream_rdr, offset, px_width, px_height = from_offset_fixture
        ihdr_chunk = _IHDRChunk.from_offset(None, stream_rdr, offset)
        assert isinstance(ihdr_chunk, _IHDRChunk)
        assert ihdr_chunk.px_width == px_width
        assert ihdr_chunk.px_height == px_height

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_offset_fixture(self):
        bytes_ = b'\x00\x00\x00\x2A\x00\x00\x00\x18'
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        offset, px_width, px_height = 0, 42, 24
        return stream_rdr, offset, px_width, px_height


class Describe_pHYsChunk(object):

    def it_can_construct_from_a_stream_and_offset(self, from_offset_fixture):
        stream_rdr, offset = from_offset_fixture[:2]
        horz_px_per_unit, vert_px_per_unit = from_offset_fixture[2:4]
        units_specifier = from_offset_fixture[4]
        pHYs_chunk = _pHYsChunk.from_offset(None, stream_rdr, offset)
        assert isinstance(pHYs_chunk, _pHYsChunk)
        assert pHYs_chunk.horz_px_per_unit == horz_px_per_unit
        assert pHYs_chunk.vert_px_per_unit == vert_px_per_unit
        assert pHYs_chunk.units_specifier == units_specifier

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_offset_fixture(self):
        bytes_ = b'\x00\x00\x00\x2A\x00\x00\x00\x18\x01'
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        offset, horz_px_per_unit, vert_px_per_unit, units_specifier = (
            0, 42, 24, 1
        )
        return (
            stream_rdr, offset, horz_px_per_unit, vert_px_per_unit,
            units_specifier
        )

########NEW FILE########
__FILENAME__ = test_tiff
# encoding: utf-8

"""
Test suite for docx.image.tiff module
"""

from __future__ import absolute_import, print_function

import pytest

from mock import call

from docx.compat import BytesIO
from docx.image.constants import MIME_TYPE, TIFF_TAG
from docx.image.helpers import BIG_ENDIAN, LITTLE_ENDIAN, StreamReader
from docx.image.tiff import (
    _AsciiIfdEntry, _IfdEntries, _IfdEntry, _IfdEntryFactory, _IfdParser,
    _LongIfdEntry, _RationalIfdEntry, _ShortIfdEntry, Tiff, _TiffParser
)

from ..unitutil import (
    function_mock, class_mock, initializer_mock, instance_mock, loose_mock,
    method_mock
)


class DescribeTiff(object):

    def it_can_construct_from_a_tiff_stream(self, from_stream_fixture):
        (stream_, _TiffParser_, Tiff__init_, px_width, px_height, horz_dpi,
         vert_dpi) = from_stream_fixture
        tiff = Tiff.from_stream(stream_)
        _TiffParser_.parse.assert_called_once_with(stream_)
        Tiff__init_.assert_called_once_with(
            px_width, px_height, horz_dpi, vert_dpi
        )
        assert isinstance(tiff, Tiff)

    def it_knows_its_content_type(self):
        tiff = Tiff(None, None, None, None)
        assert tiff.content_type == MIME_TYPE.TIFF

    def it_knows_its_default_ext(self):
        tiff = Tiff(None, None, None, None)
        assert tiff.default_ext == 'tiff'

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(
            self, stream_, _TiffParser_, tiff_parser_, Tiff__init_):
        px_width, px_height = 111, 222
        horz_dpi, vert_dpi = 333, 444
        tiff_parser_.px_width = px_width
        tiff_parser_.px_height = px_height
        tiff_parser_.horz_dpi = horz_dpi
        tiff_parser_.vert_dpi = vert_dpi
        return (
            stream_, _TiffParser_, Tiff__init_, px_width, px_height,
            horz_dpi, vert_dpi
        )

    @pytest.fixture
    def Tiff__init_(self, request):
        return initializer_mock(request, Tiff)

    @pytest.fixture
    def _TiffParser_(self, request, tiff_parser_):
        _TiffParser_ = class_mock(request, 'docx.image.tiff._TiffParser')
        _TiffParser_.parse.return_value = tiff_parser_
        return _TiffParser_

    @pytest.fixture
    def tiff_parser_(self, request):
        return instance_mock(request, _TiffParser)

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_TiffParser(object):

    def it_can_parse_the_properties_from_a_tiff_stream(
            self, from_stream_fixture):
        (stream_, _make_stream_reader_, _IfdEntries_, ifd0_offset_,
         stream_rdr_, _TiffParser__init_, ifd_entries_) = from_stream_fixture
        tiff_parser = _TiffParser.parse(stream_)
        _make_stream_reader_.assert_called_once_with(stream_)
        _IfdEntries_.from_stream.assert_called_once_with(
            stream_rdr_, ifd0_offset_
        )
        _TiffParser__init_.assert_called_once_with(ifd_entries_)
        assert isinstance(tiff_parser, _TiffParser)

    def it_makes_a_stream_reader_to_help_parse(self, mk_stream_rdr_fixture):
        stream, StreamReader_, endian, stream_rdr_ = mk_stream_rdr_fixture
        stream_rdr = _TiffParser._make_stream_reader(stream)
        StreamReader_.assert_called_once_with(stream, endian)
        assert stream_rdr is stream_rdr_

    def it_knows_image_width_and_height_after_parsing(self):
        px_width, px_height = 42, 24
        entries = {
            TIFF_TAG.IMAGE_WIDTH:  px_width,
            TIFF_TAG.IMAGE_LENGTH: px_height,
        }
        ifd_entries = _IfdEntries(entries)
        tiff_parser = _TiffParser(ifd_entries)
        assert tiff_parser.px_width == px_width
        assert tiff_parser.px_height == px_height

    def it_knows_the_horz_and_vert_dpi_after_parsing(self, dpi_fixture):
        tiff_parser, expected_horz_dpi, expected_vert_dpi = dpi_fixture
        assert tiff_parser.horz_dpi == expected_horz_dpi
        assert tiff_parser.vert_dpi == expected_vert_dpi

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (1,  150,  240,  72,  72),
        (2,   42,   24,  42,  24),
        (3,  100,  200, 254, 508),
        (6, None, None,  72,  72),
    ])
    def dpi_fixture(self, request):
        resolution_unit, x_resolution, y_resolution = request.param[:3]
        expected_horz_dpi, expected_vert_dpi = request.param[3:]

        entries = {TIFF_TAG.RESOLUTION_UNIT: resolution_unit}
        if x_resolution is not None:
            entries[TIFF_TAG.X_RESOLUTION] = x_resolution
        if y_resolution is not None:
            entries[TIFF_TAG.Y_RESOLUTION] = y_resolution

        tiff_parser = _TiffParser(entries)
        return tiff_parser, expected_horz_dpi, expected_vert_dpi

    @pytest.fixture
    def from_stream_fixture(
            self, stream_, _make_stream_reader_, _IfdEntries_, ifd0_offset_,
            stream_rdr_, _TiffParser__init_, ifd_entries_):
        return (
            stream_, _make_stream_reader_, _IfdEntries_, ifd0_offset_,
            stream_rdr_, _TiffParser__init_, ifd_entries_
        )

    @pytest.fixture
    def _IfdEntries_(self, request, ifd_entries_):
        _IfdEntries_ = class_mock(request, 'docx.image.tiff._IfdEntries')
        _IfdEntries_.from_stream.return_value = ifd_entries_
        return _IfdEntries_

    @pytest.fixture
    def ifd_entries_(self, request):
        return instance_mock(request, _IfdEntries)

    @pytest.fixture
    def ifd0_offset_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def _make_stream_reader_(self, request, stream_rdr_):
        return method_mock(
            request, _TiffParser, '_make_stream_reader',
            return_value=stream_rdr_
        )

    @pytest.fixture(params=[
        (b'MM\x00*', BIG_ENDIAN),
        (b'II*\x00', LITTLE_ENDIAN),
    ])
    def mk_stream_rdr_fixture(self, request, StreamReader_, stream_rdr_):
        bytes_, endian = request.param
        stream = BytesIO(bytes_)
        return stream, StreamReader_, endian, stream_rdr_

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)

    @pytest.fixture
    def StreamReader_(self, request, stream_rdr_):
        return class_mock(
            request, 'docx.image.tiff.StreamReader', return_value=stream_rdr_
        )

    @pytest.fixture
    def stream_rdr_(self, request, ifd0_offset_):
        stream_rdr_ = instance_mock(request, StreamReader)
        stream_rdr_.read_long.return_value = ifd0_offset_
        return stream_rdr_

    @pytest.fixture
    def _TiffParser__init_(self, request):
        return initializer_mock(request, _TiffParser)


class Describe_IfdEntries(object):

    def it_can_construct_from_a_stream_and_offset(self, from_stream_fixture):
        stream_, offset_, _IfdParser_, _IfdEntries__init_, entries_ = (
            from_stream_fixture
        )
        ifd_entries = _IfdEntries.from_stream(stream_, offset_)
        _IfdParser_.assert_called_once_with(stream_, offset_)
        _IfdEntries__init_.assert_called_once_with(entries_)
        assert isinstance(ifd_entries, _IfdEntries)

    def it_has_basic_mapping_semantics(self):
        key, value = 1, 'foobar'
        entries = {key: value}
        ifd_entries = _IfdEntries(entries)
        assert key in ifd_entries
        assert ifd_entries[key] == value

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(
            self, stream_, offset_, _IfdParser_, ifd_parser_,
            _IfdEntries__init_, ifd_entry_, ifd_entry_2_):
        ifd_parser_.iter_entries.return_value = [ifd_entry_, ifd_entry_2_]
        entries_ = {1: 42, 2: 24}
        return stream_, offset_, _IfdParser_, _IfdEntries__init_, entries_

    @pytest.fixture
    def ifd_entry_(self, request):
        return instance_mock(request, _IfdEntry, tag=1, value=42)

    @pytest.fixture
    def ifd_entry_2_(self, request):
        return instance_mock(request, _IfdEntry, tag=2, value=24)

    @pytest.fixture
    def _IfdEntries__init_(self, request):
        return initializer_mock(request, _IfdEntries)

    @pytest.fixture
    def _IfdParser_(self, request, ifd_parser_):
        return class_mock(
            request, 'docx.image.tiff._IfdParser', return_value=ifd_parser_
        )

    @pytest.fixture
    def ifd_parser_(self, request):
        return instance_mock(request, _IfdParser)

    @pytest.fixture
    def offset_(self, request):
        return instance_mock(request, int)

    @pytest.fixture
    def stream_(self, request):
        return instance_mock(request, BytesIO)


class Describe_IfdParser(object):

    def it_can_iterate_through_the_directory_entries_in_an_IFD(
            self, iter_fixture):
        (ifd_parser, _IfdEntryFactory_, stream_rdr, offsets,
         expected_entries) = iter_fixture
        entries = [e for e in ifd_parser.iter_entries()]
        assert _IfdEntryFactory_.call_args_list == [
            call(stream_rdr, offsets[0]),
            call(stream_rdr, offsets[1]),
        ]
        assert entries == expected_entries

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def ifd_entry_(self, request):
        return instance_mock(request, _IfdEntry, tag=1, value=42)

    @pytest.fixture
    def ifd_entry_2_(self, request):
        return instance_mock(request, _IfdEntry, tag=2, value=24)

    @pytest.fixture
    def _IfdEntryFactory_(self, request, ifd_entry_, ifd_entry_2_):
        return function_mock(
            request, 'docx.image.tiff._IfdEntryFactory',
            side_effect=[ifd_entry_, ifd_entry_2_]
        )

    @pytest.fixture
    def iter_fixture(self, _IfdEntryFactory_, ifd_entry_, ifd_entry_2_):
        stream_rdr = StreamReader(BytesIO(b'\x00\x02'), BIG_ENDIAN)
        offsets = [2, 14]
        ifd_parser = _IfdParser(stream_rdr, offset=0)
        expected_entries = [ifd_entry_, ifd_entry_2_]
        return (
            ifd_parser, _IfdEntryFactory_, stream_rdr, offsets,
            expected_entries
        )


class Describe_IfdEntryFactory(object):

    def it_constructs_the_right_class_for_a_given_ifd_entry(self, fixture):
        stream_rdr, offset, entry_cls_, ifd_entry_ = fixture
        ifd_entry = _IfdEntryFactory(stream_rdr, offset)
        entry_cls_.from_stream.assert_called_once_with(stream_rdr, offset)
        assert ifd_entry is ifd_entry_

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (b'\x66\x66\x00\x01', 'BYTE'),
        (b'\x66\x66\x00\x02', 'ASCII'),
        (b'\x66\x66\x00\x03', 'SHORT'),
        (b'\x66\x66\x00\x04', 'LONG'),
        (b'\x66\x66\x00\x05', 'RATIONAL'),
        (b'\x66\x66\x00\x06', 'CUSTOM'),
    ])
    def fixture(
            self, request, ifd_entry_, _IfdEntry_, _AsciiIfdEntry_,
            _ShortIfdEntry_, _LongIfdEntry_, _RationalIfdEntry_):
        bytes_, entry_type = request.param
        entry_cls_ = {
            'BYTE':     _IfdEntry_,
            'ASCII':    _AsciiIfdEntry_,
            'SHORT':    _ShortIfdEntry_,
            'LONG':     _LongIfdEntry_,
            'RATIONAL': _RationalIfdEntry_,
            'CUSTOM':   _IfdEntry_,
        }[entry_type]
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        offset = 0
        return stream_rdr, offset, entry_cls_, ifd_entry_

    @pytest.fixture
    def ifd_entry_(self, request):
        return instance_mock(request, _IfdEntry)

    @pytest.fixture
    def _IfdEntry_(self, request, ifd_entry_):
        _IfdEntry_ = class_mock(request, 'docx.image.tiff._IfdEntry')
        _IfdEntry_.from_stream.return_value = ifd_entry_
        return _IfdEntry_

    @pytest.fixture
    def _AsciiIfdEntry_(self, request, ifd_entry_):
        _AsciiIfdEntry_ = class_mock(
            request, 'docx.image.tiff._AsciiIfdEntry')
        _AsciiIfdEntry_.from_stream.return_value = ifd_entry_
        return _AsciiIfdEntry_

    @pytest.fixture
    def _ShortIfdEntry_(self, request, ifd_entry_):
        _ShortIfdEntry_ = class_mock(
            request, 'docx.image.tiff._ShortIfdEntry')
        _ShortIfdEntry_.from_stream.return_value = ifd_entry_
        return _ShortIfdEntry_

    @pytest.fixture
    def _LongIfdEntry_(self, request, ifd_entry_):
        _LongIfdEntry_ = class_mock(
            request, 'docx.image.tiff._LongIfdEntry')
        _LongIfdEntry_.from_stream.return_value = ifd_entry_
        return _LongIfdEntry_

    @pytest.fixture
    def _RationalIfdEntry_(self, request, ifd_entry_):
        _RationalIfdEntry_ = class_mock(
            request, 'docx.image.tiff._RationalIfdEntry')
        _RationalIfdEntry_.from_stream.return_value = ifd_entry_
        return _RationalIfdEntry_

    @pytest.fixture
    def offset_(self, request):
        return instance_mock(request, int)


class Describe_IfdEntry(object):

    def it_can_construct_from_a_stream_and_offset(self, from_stream_fixture):
        (stream_rdr, offset, _parse_value_, value_count, value_offset,
         _IfdEntry__init_, tag_code, value_) = from_stream_fixture
        ifd_entry = _IfdEntry.from_stream(stream_rdr, offset)
        _parse_value_.assert_called_once_with(
            stream_rdr, offset, value_count, value_offset
        )
        _IfdEntry__init_.assert_called_once_with(tag_code, value_)
        assert isinstance(ifd_entry, _IfdEntry)

    def it_provides_read_only_access_to_the_directory_entry(self):
        tag_code, value = 1, 2
        ifd_entry = _IfdEntry(tag_code, value)
        assert (ifd_entry.tag, ifd_entry.value) == (tag_code, value)

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def from_stream_fixture(
            self, _parse_value_, _IfdEntry__init_, value_):
        bytes_ = b'\x00\x01\x66\x66\x00\x00\x00\x02\x00\x00\x00\x03'
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        offset, tag_code, value_count, value_offset = 0, 1, 2, 3
        return (
            stream_rdr, offset, _parse_value_, value_count, value_offset,
            _IfdEntry__init_, tag_code, value_
        )

    @pytest.fixture
    def _IfdEntry__init_(self, request):
        return initializer_mock(request, _IfdEntry)

    @pytest.fixture
    def _parse_value_(self, request, value_):
        return method_mock(
            request, _IfdEntry, '_parse_value', return_value=value_
        )

    @pytest.fixture
    def value_(self, request):
        return loose_mock(request)


class Describe_AsciiIfdEntry(object):

    def it_can_parse_an_ascii_string_IFD_entry(self):
        bytes_ = b'foobar\x00'
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        val = _AsciiIfdEntry._parse_value(stream_rdr, None, 7, 0)
        assert val == 'foobar'


class Describe_ShortIfdEntry(object):

    def it_can_parse_a_short_int_IFD_entry(self):
        bytes_ = b'foobaroo\x00\x2A'
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        val = _ShortIfdEntry._parse_value(stream_rdr, 0, 1, None)
        assert val == 42


class Describe_LongIfdEntry(object):

    def it_can_parse_a_long_int_IFD_entry(self):
        bytes_ = b'foobaroo\x00\x00\x00\x2A'
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        val = _LongIfdEntry._parse_value(stream_rdr, 0, 1, None)
        assert val == 42


class Describe_RationalIfdEntry(object):

    def it_can_parse_a_rational_IFD_entry(self):
        bytes_ = b'\x00\x00\x00\x2A\x00\x00\x00\x54'
        stream_rdr = StreamReader(BytesIO(bytes_), BIG_ENDIAN)
        val = _RationalIfdEntry._parse_value(stream_rdr, None, 1, 0)
        assert val == 0.5

########NEW FILE########
__FILENAME__ = test_oxml
# encoding: utf-8

"""
Test suite for opc.oxml module
"""

from docx.opc.constants import RELATIONSHIP_TARGET_MODE as RTM
from docx.opc.oxml import (
    CT_Default, CT_Override, CT_Relationship, CT_Relationships, CT_Types
)

from ..unitutil import actual_xml
from .unitdata.rels import (
    a_Default, an_Override, a_Relationship, a_Relationships, a_Types
)


class DescribeCT_Default(object):

    def it_provides_read_access_to_xml_values(self):
        default = a_Default().element
        assert default.extension == 'xml'
        assert default.content_type == 'application/xml'

    def it_can_construct_a_new_default_element(self):
        default = CT_Default.new('xml', 'application/xml')
        expected_xml = a_Default().xml
        assert default.xml == expected_xml


class DescribeCT_Override(object):

    def it_provides_read_access_to_xml_values(self):
        override = an_Override().element
        assert override.partname == '/part/name.xml'
        assert override.content_type == 'app/vnd.type'

    def it_can_construct_a_new_override_element(self):
        override = CT_Override.new('/part/name.xml', 'app/vnd.type')
        expected_xml = an_Override().xml
        assert override.xml == expected_xml


class DescribeCT_Relationship(object):

    def it_provides_read_access_to_xml_values(self):
        rel = a_Relationship().element
        assert rel.rId == 'rId9'
        assert rel.reltype == 'ReLtYpE'
        assert rel.target_ref == 'docProps/core.xml'
        assert rel.target_mode == RTM.INTERNAL

    def it_can_construct_from_attribute_values(self):
        cases = (
            ('rId9', 'ReLtYpE', 'foo/bar.xml',      None),
            ('rId9', 'ReLtYpE', 'bar/foo.xml',      RTM.INTERNAL),
            ('rId9', 'ReLtYpE', 'http://some/link', RTM.EXTERNAL),
        )
        for rId, reltype, target, target_mode in cases:
            if target_mode is None:
                rel = CT_Relationship.new(rId, reltype, target)
            else:
                rel = CT_Relationship.new(rId, reltype, target, target_mode)
            builder = a_Relationship().with_target(target)
            if target_mode == RTM.EXTERNAL:
                builder = builder.with_target_mode(RTM.EXTERNAL)
            expected_rel_xml = builder.xml
            assert rel.xml == expected_rel_xml


class DescribeCT_Relationships(object):

    def it_can_construct_a_new_relationships_element(self):
        rels = CT_Relationships.new()
        expected_xml = (
            '<Relationships xmlns="http://schemas.openxmlformats.org/package'
            '/2006/relationships"/>\n'
        )
        assert actual_xml(rels) == expected_xml

    def it_can_build_rels_element_incrementally(self):
        # setup ------------------------
        rels = CT_Relationships.new()
        # exercise ---------------------
        rels.add_rel('rId1', 'http://reltype1', 'docProps/core.xml')
        rels.add_rel('rId2', 'http://linktype', 'http://some/link', True)
        rels.add_rel('rId3', 'http://reltype2', '../slides/slide1.xml')
        # verify -----------------------
        expected_rels_xml = a_Relationships().xml
        assert actual_xml(rels) == expected_rels_xml

    def it_can_generate_rels_file_xml(self):
        expected_xml = (
            '<?xml version=\'1.0\' encoding=\'UTF-8\' standalone=\'yes\'?>\n'
            '<Relationships xmlns="http://schemas.openxmlformats.org/package'
            '/2006/relationships"/>'.encode('utf-8')
        )
        assert CT_Relationships.new().xml == expected_xml


class DescribeCT_Types(object):

    def it_provides_access_to_default_child_elements(self):
        types = a_Types().element
        assert len(types.defaults) == 2
        for default in types.defaults:
            assert isinstance(default, CT_Default)

    def it_provides_access_to_override_child_elements(self):
        types = a_Types().element
        assert len(types.overrides) == 3
        for override in types.overrides:
            assert isinstance(override, CT_Override)

    def it_should_have_empty_list_on_no_matching_elements(self):
        types = a_Types().empty().element
        assert types.defaults == []
        assert types.overrides == []

    def it_can_construct_a_new_types_element(self):
        types = CT_Types.new()
        expected_xml = a_Types().empty().xml
        assert types.xml == expected_xml

    def it_can_build_types_element_incrementally(self):
        types = CT_Types.new()
        types.add_default('xml', 'application/xml')
        types.add_default('jpeg', 'image/jpeg')
        types.add_override('/docProps/core.xml', 'app/vnd.type1')
        types.add_override('/ppt/presentation.xml', 'app/vnd.type2')
        types.add_override('/docProps/thumbnail.jpeg', 'image/jpeg')
        expected_types_xml = a_Types().xml
        assert types.xml == expected_types_xml

########NEW FILE########
__FILENAME__ = test_package
# encoding: utf-8

"""
Test suite for docx.opc.package module
"""

from __future__ import absolute_import

import pytest

from mock import call, Mock, patch, PropertyMock

from docx.opc.oxml import CT_Relationships
from docx.opc.packuri import PACKAGE_URI, PackURI
from docx.opc.package import (
    OpcPackage, Part, PartFactory, _Relationship, Relationships,
    Unmarshaller
)
from docx.opc.pkgreader import PackageReader

from ..unitutil import (
    cls_attr_mock, class_mock, function_mock, instance_mock, loose_mock,
    method_mock
)


class DescribeOpcPackage(object):

    def it_can_open_a_pkg_file(self, PackageReader_, PartFactory_,
                               Unmarshaller_):
        # mockery ----------------------
        pkg_file = Mock(name='pkg_file')
        pkg_reader = PackageReader_.from_file.return_value
        # exercise ---------------------
        pkg = OpcPackage.open(pkg_file)
        # verify -----------------------
        PackageReader_.from_file.assert_called_once_with(pkg_file)
        Unmarshaller_.unmarshal.assert_called_once_with(pkg_reader, pkg,
                                                        PartFactory_)
        assert isinstance(pkg, OpcPackage)

    def it_initializes_its_rels_collection_on_first_reference(
            self, Relationships_):
        pkg = OpcPackage()
        rels = pkg.rels
        Relationships_.assert_called_once_with(PACKAGE_URI.baseURI)
        assert rels == Relationships_.return_value

    def it_can_add_a_relationship_to_a_part(self, pkg_with_rels_, rel_attrs_):
        reltype, target, rId = rel_attrs_
        pkg = pkg_with_rels_
        # exercise ---------------------
        pkg.load_rel(reltype, target, rId)
        # verify -----------------------
        pkg._rels.add_relationship.assert_called_once_with(
            reltype, target, rId, False
        )

    def it_can_establish_a_relationship_to_another_part(
            self, relate_to_part_fixture_):
        pkg, part_, reltype, rId = relate_to_part_fixture_
        _rId = pkg.relate_to(part_, reltype)
        pkg.rels.get_or_add.assert_called_once_with(reltype, part_)
        assert _rId == rId

    def it_can_provide_a_list_of_the_parts_it_contains(self):
        # mockery ----------------------
        parts = [Mock(name='part1'), Mock(name='part2')]
        pkg = OpcPackage()
        # verify -----------------------
        with patch.object(OpcPackage, 'iter_parts', return_value=parts):
            assert pkg.parts == [parts[0], parts[1]]

    def it_can_iterate_over_parts_by_walking_rels_graph(self):
        # +----------+       +--------+
        # | pkg_rels |-----> | part_1 |
        # +----------+       +--------+
        #      |               |    ^
        #      v               v    |
        #   external         +--------+
        #                    | part_2 |
        #                    +--------+
        part1, part2 = (Mock(name='part1'), Mock(name='part2'))
        part1.rels = {
            1: Mock(name='rel1', is_external=False, target_part=part2)
        }
        part2.rels = {
            1: Mock(name='rel2', is_external=False, target_part=part1)
        }
        pkg = OpcPackage()
        pkg._rels = {
            1: Mock(name='rel3', is_external=False, target_part=part1),
            2: Mock(name='rel4', is_external=True),
        }
        # verify -----------------------
        assert part1 in pkg.iter_parts()
        assert part2 in pkg.iter_parts()
        assert len([p for p in pkg.iter_parts()]) == 2

    def it_can_find_a_part_related_by_reltype(self, related_part_fixture_):
        pkg, reltype, related_part_ = related_part_fixture_
        related_part = pkg.part_related_by(reltype)
        pkg.rels.part_with_reltype.assert_called_once_with(reltype)
        assert related_part is related_part_

    def it_can_save_to_a_pkg_file(
            self, pkg_file_, PackageWriter_, parts, parts_):
        pkg = OpcPackage()
        pkg.save(pkg_file_)
        for part in parts_:
            part.before_marshal.assert_called_once_with()
        PackageWriter_.write.assert_called_once_with(
            pkg_file_, pkg._rels, parts_
        )

    # fixtures ---------------------------------------------

    @pytest.fixture
    def PackageReader_(self, request):
        return class_mock(request, 'docx.opc.package.PackageReader')

    @pytest.fixture
    def PackageWriter_(self, request):
        return class_mock(request, 'docx.opc.package.PackageWriter')

    @pytest.fixture
    def PartFactory_(self, request):
        return class_mock(request, 'docx.opc.package.PartFactory')

    @pytest.fixture
    def parts(self, request, parts_):
        """
        Return a mock patching property OpcPackage.parts, reversing the
        patch after each use.
        """
        _patch = patch.object(
            OpcPackage, 'parts', new_callable=PropertyMock,
            return_value=parts_
        )
        request.addfinalizer(_patch.stop)
        return _patch.start()

    @pytest.fixture
    def parts_(self, request):
        part_ = instance_mock(request, Part, name='part_')
        part_2_ = instance_mock(request, Part, name='part_2_')
        return [part_, part_2_]

    @pytest.fixture
    def pkg(self, request):
        return OpcPackage()

    @pytest.fixture
    def pkg_file_(self, request):
        return loose_mock(request)

    @pytest.fixture
    def pkg_with_rels_(self, request, rels_):
        pkg = OpcPackage()
        pkg._rels = rels_
        return pkg

    @pytest.fixture
    def Relationships_(self, request):
        return class_mock(request, 'docx.opc.package.Relationships')

    @pytest.fixture
    def rel_attrs_(self, request):
        reltype = 'http://rel/type'
        target_ = instance_mock(request, Part, name='target_')
        rId = 'rId99'
        return reltype, target_, rId

    @pytest.fixture
    def relate_to_part_fixture_(self, request, pkg, rels_, reltype):
        rId = 'rId99'
        rel_ = instance_mock(request, _Relationship, name='rel_', rId=rId)
        rels_.get_or_add.return_value = rel_
        pkg._rels = rels_
        part_ = instance_mock(request, Part, name='part_')
        return pkg, part_, reltype, rId

    @pytest.fixture
    def related_part_fixture_(self, request, rels_, reltype):
        related_part_ = instance_mock(request, Part, name='related_part_')
        rels_.part_with_reltype.return_value = related_part_
        pkg = OpcPackage()
        pkg._rels = rels_
        return pkg, reltype, related_part_

    @pytest.fixture
    def rels_(self, request):
        return instance_mock(request, Relationships)

    @pytest.fixture
    def reltype(self, request):
        return 'http://rel/type'

    @pytest.fixture
    def Unmarshaller_(self, request):
        return class_mock(request, 'docx.opc.package.Unmarshaller')


class DescribePartLoadSaveInterface(object):

    def it_remembers_its_construction_state(self):
        partname, content_type, blob, element, package = (
            Mock(name='partname'), Mock(name='content_type'),
            Mock(name='blob'), None, Mock(name='package')
        )
        part = Part(partname, content_type, blob, element, package)
        assert part.partname == partname
        assert part.content_type == content_type
        assert part.blob == blob
        assert part.package == package

    def it_can_be_notified_after_unmarshalling_is_complete(self, part):
        part.after_unmarshal()

    def it_can_be_notified_before_marshalling_is_started(self, part):
        part.before_marshal()

    def it_allows_its_partname_to_be_changed(self, part):
        new_partname = PackURI('/ppt/presentation.xml')
        part.partname = new_partname
        assert part.partname == new_partname

    def it_can_load_a_relationship_during_package_open(
            self, part_with_rels_, rel_attrs_):
        # fixture ----------------------
        part, rels_ = part_with_rels_
        reltype, target, rId = rel_attrs_
        # exercise ---------------------
        part.load_rel(reltype, target, rId)
        # verify -----------------------
        rels_.add_relationship.assert_called_once_with(
            reltype, target, rId, False
        )

    # fixtures ---------------------------------------------

    @pytest.fixture
    def part(self):
        partname = PackURI('/foo/bar.xml')
        part = Part(partname, None, None)
        return part

    @pytest.fixture
    def part_with_rels_(self, request, part, rels_):
        part._rels = rels_
        return part, rels_

    @pytest.fixture
    def rel_attrs_(self, request):
        reltype = 'http://rel/type'
        target_ = instance_mock(request, Part, name='target_')
        rId = 'rId99'
        return reltype, target_, rId

    @pytest.fixture
    def rels_(self, request):
        return instance_mock(request, Relationships)


class DescribePartRelsProxyInterface(object):

    def it_has_a_rels_collection_initialized_on_first_reference(
            self, Relationships_):
        partname = PackURI('/foo/bar.xml')
        part = Part(partname, None, None)
        assert part.rels is Relationships_.return_value
        Relationships_.assert_called_once_with(partname.baseURI)

    def it_can_establish_a_relationship_to_another_part(
            self, relate_to_part_fixture_):
        # fixture ----------------------
        part, related_part_, reltype, rId = relate_to_part_fixture_
        # exercise ---------------------
        _rId = part.relate_to(related_part_, reltype)
        # verify -----------------------
        part.rels.get_or_add.assert_called_once_with(reltype, related_part_)
        assert _rId == rId

    def it_can_establish_an_external_relationship(
            self, relate_to_url_fixture_):
        part, url, reltype, rId = relate_to_url_fixture_
        _rId = part.relate_to(url, reltype, is_external=True)
        part.rels.get_or_add_ext_rel.assert_called_once_with(reltype, url)
        assert _rId == rId

    # def it_can_drop_a_relationship(self, part_with_rels_to_drop_):
    #     part, rId, rId_2, rId_3 = part_with_rels_to_drop_
    #     part.drop_rel(rId)    # this one has ref count of 2, don't drop
    #     part.drop_rel(rId_2)  # this one has ref count of 1, drop
    #     part.drop_rel(rId_3)  # this one has ref count of 0, drop
    #     assert part.rels.__delitem__.call_args_list == [
    #         call(rId_2), call(rId_3)
    #     ]

    def it_can_find_a_part_related_by_reltype(self, related_part_fixture_):
        part, reltype, related_part_ = related_part_fixture_
        related_part = part.part_related_by(reltype)
        part.rels.part_with_reltype.assert_called_once_with(reltype)
        assert related_part is related_part_

    def it_can_find_the_target_ref_of_an_external_relationship(
            self, target_ref_fixture_):
        part, rId, url = target_ref_fixture_
        _url = part.target_ref(rId)
        assert _url == url

    # fixtures ---------------------------------------------

    @pytest.fixture
    def part(self):
        partname = PackURI('/foo/bar.xml')
        part = Part(partname, None, None)
        return part

    # @pytest.fixture
    # def part_with_rels_to_drop_(self, request, part, rels_):
    #     rId, rId_2, rId3 = 'rId1', 'rId2', 'rId3'
    #     _element = (
    #         an_rPr().with_nsdecls('a', 'r')
    #                 .with_child(an_hlinkClick().with_rId(rId))
    #                 .with_child(an_hlinkClick().with_rId(rId))
    #                 .with_child(an_hlinkClick().with_rId(rId_2))
    #                 .element
    #     )
    #     part._element = _element
    #     part._rels = rels_
    #     return part, rId, rId_2, rId3

    @pytest.fixture
    def Relationships_(self, request):
        return class_mock(request, 'docx.opc.package.Relationships')

    @pytest.fixture
    def relate_to_part_fixture_(self, request, part, reltype):
        rId = 'rId99'
        related_part_ = instance_mock(request, Part, name='related_part_')
        rels_ = instance_mock(request, Relationships, name='rels_')
        rel_ = instance_mock(request, _Relationship, name='rel_', rId=rId)
        rels_.get_or_add.return_value = rel_
        part._rels = rels_
        return part, related_part_, reltype, rId

    @pytest.fixture
    def relate_to_url_fixture_(self, request, part, reltype):
        rId = 'rId21'
        url = 'https://github.com/scanny/python-docx'
        rels_ = instance_mock(request, Relationships, name='rels_')
        rels_.get_or_add_ext_rel.return_value = rId
        part._rels = rels_
        return part, url, reltype, rId

    @pytest.fixture
    def related_part_fixture_(self, request, part, reltype):
        related_part_ = instance_mock(request, Part, name='related_part_')
        rels_ = instance_mock(request, Relationships, name='rels_')
        rels_.part_with_reltype.return_value = related_part_
        part._rels = rels_
        return part, reltype, related_part_

    @pytest.fixture
    def reltype(self):
        return 'http:/rel/type'

    @pytest.fixture
    def rels_(self, request):
        return instance_mock(request, Relationships)

    @pytest.fixture
    def target_ref_fixture_(self, request, part):
        rId = 'rId246'
        url = 'https://github.com/scanny/python-docx'
        rels = Relationships(None)
        rels.add_relationship(None, url, rId, is_external=True)
        part._rels = rels
        return part, rId, url


class DescribePartFactory(object):

    def it_constructs_part_from_selector_if_defined(
            self, cls_selector_fixture):
        # fixture ----------------------
        (cls_selector_fn_, part_load_params, CustomPartClass_,
         part_of_custom_type_) = cls_selector_fixture
        partname, content_type, reltype, blob, package = part_load_params
        # exercise ---------------------
        PartFactory.part_class_selector = cls_selector_fn_
        part = PartFactory(partname, content_type, reltype, blob, package)
        # verify -----------------------
        cls_selector_fn_.assert_called_once_with(content_type, reltype)
        CustomPartClass_.load.assert_called_once_with(
            partname, content_type, blob, package
        )
        assert part is part_of_custom_type_

    def it_constructs_custom_part_type_for_registered_content_types(
            self, part_args_, CustomPartClass_, part_of_custom_type_):
        # fixture ----------------------
        partname, content_type, reltype, package, blob = part_args_
        # exercise ---------------------
        PartFactory.part_type_for[content_type] = CustomPartClass_
        part = PartFactory(partname, content_type, reltype, blob, package)
        # verify -----------------------
        CustomPartClass_.load.assert_called_once_with(
            partname, content_type, blob, package
        )
        assert part is part_of_custom_type_

    def it_constructs_part_using_default_class_when_no_custom_registered(
            self, part_args_2_, DefaultPartClass_, part_of_default_type_):
        partname, content_type, reltype, blob, package = part_args_2_
        part = PartFactory(partname, content_type, reltype, blob, package)
        DefaultPartClass_.load.assert_called_once_with(
            partname, content_type, blob, package
        )
        assert part is part_of_default_type_

    # fixtures ---------------------------------------------

    @pytest.fixture
    def blob_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def blob_2_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def cls_method_fn_(self, request, cls_selector_fn_):
        return function_mock(
            request, 'docx.opc.package.cls_method_fn',
            return_value=cls_selector_fn_
        )

    @pytest.fixture
    def cls_selector_fixture(
            self, request, cls_selector_fn_, cls_method_fn_, part_load_params,
            CustomPartClass_, part_of_custom_type_):
        def reset_part_class_selector():
            PartFactory.part_class_selector = original_part_class_selector
        original_part_class_selector = PartFactory.part_class_selector
        request.addfinalizer(reset_part_class_selector)
        return (
            cls_selector_fn_, part_load_params, CustomPartClass_,
            part_of_custom_type_
        )

    @pytest.fixture
    def cls_selector_fn_(self, request, CustomPartClass_):
        cls_selector_fn_ = loose_mock(request)
        # Python 3 version
        cls_selector_fn_.return_value = CustomPartClass_
        # Python 2 version
        cls_selector_fn_.__func__ = loose_mock(
            request, name='__func__', return_value=cls_selector_fn_
        )
        return cls_selector_fn_

    @pytest.fixture
    def content_type_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def content_type_2_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def CustomPartClass_(self, request, part_of_custom_type_):
        CustomPartClass_ = Mock(name='CustomPartClass', spec=Part)
        CustomPartClass_.load.return_value = part_of_custom_type_
        return CustomPartClass_

    @pytest.fixture
    def DefaultPartClass_(self, request, part_of_default_type_):
        DefaultPartClass_ = cls_attr_mock(
            request, PartFactory, 'default_part_type'
        )
        DefaultPartClass_.load.return_value = part_of_default_type_
        return DefaultPartClass_

    @pytest.fixture
    def package_(self, request):
        return instance_mock(request, OpcPackage)

    @pytest.fixture
    def package_2_(self, request):
        return instance_mock(request, OpcPackage)

    @pytest.fixture
    def part_load_params(
            self, partname_, content_type_, reltype_, blob_, package_):
        return partname_, content_type_, reltype_, blob_, package_

    @pytest.fixture
    def part_of_custom_type_(self, request):
        return instance_mock(request, Part)

    @pytest.fixture
    def part_of_default_type_(self, request):
        return instance_mock(request, Part)

    @pytest.fixture
    def partname_(self, request):
        return instance_mock(request, PackURI)

    @pytest.fixture
    def partname_2_(self, request):
        return instance_mock(request, PackURI)

    @pytest.fixture
    def part_args_(
            self, request, partname_, content_type_, reltype_, package_,
            blob_):
        return partname_, content_type_, reltype_, blob_, package_

    @pytest.fixture
    def part_args_2_(
            self, request, partname_2_, content_type_2_, reltype_2_,
            package_2_, blob_2_):
        return partname_2_, content_type_2_, reltype_2_, blob_2_, package_2_

    @pytest.fixture
    def reltype_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def reltype_2_(self, request):
        return instance_mock(request, str)


class Describe_Relationship(object):

    def it_remembers_construction_values(self):
        # test data --------------------
        rId = 'rId9'
        reltype = 'reltype'
        target = Mock(name='target_part')
        external = False
        # exercise ---------------------
        rel = _Relationship(rId, reltype, target, None, external)
        # verify -----------------------
        assert rel.rId == rId
        assert rel.reltype == reltype
        assert rel.target_part == target
        assert rel.is_external == external

    def it_should_raise_on_target_part_access_on_external_rel(self):
        rel = _Relationship(None, None, None, None, external=True)
        with pytest.raises(ValueError):
            rel.target_part

    def it_should_have_target_ref_for_external_rel(self):
        rel = _Relationship(None, None, 'target', None, external=True)
        assert rel.target_ref == 'target'

    def it_should_have_relative_ref_for_internal_rel(self):
        """
        Internal relationships (TargetMode == 'Internal' in the XML) should
        have a relative ref, e.g. '../slideLayouts/slideLayout1.xml', for
        the target_ref attribute.
        """
        part = Mock(name='part', partname=PackURI('/ppt/media/image1.png'))
        baseURI = '/ppt/slides'
        rel = _Relationship(None, None, part, baseURI)  # external=False
        assert rel.target_ref == '../media/image1.png'


class DescribeRelationships(object):

    def it_has_a_len(self):
        rels = Relationships(None)
        assert len(rels) == 0

    def it_has_dict_style_lookup_of_rel_by_rId(self):
        rel = Mock(name='rel', rId='foobar')
        rels = Relationships(None)
        rels['foobar'] = rel
        assert rels['foobar'] == rel

    def it_should_raise_on_failed_lookup_by_rId(self):
        rels = Relationships(None)
        with pytest.raises(KeyError):
            rels['barfoo']

    def it_can_add_a_relationship(self, _Relationship_):
        baseURI, rId, reltype, target, external = (
            'baseURI', 'rId9', 'reltype', 'target', False
        )
        rels = Relationships(baseURI)
        rel = rels.add_relationship(reltype, target, rId, external)
        _Relationship_.assert_called_once_with(
            rId, reltype, target, baseURI, external
        )
        assert rels[rId] == rel
        assert rel == _Relationship_.return_value

    def it_can_add_an_external_relationship(self, add_ext_rel_fixture_):
        rels, reltype, url = add_ext_rel_fixture_
        rId = rels.get_or_add_ext_rel(reltype, url)
        rel = rels[rId]
        assert rel.is_external
        assert rel.target_ref == url
        assert rel.reltype == reltype

    def it_should_return_an_existing_one_if_it_matches(
            self, add_matching_ext_rel_fixture_):
        rels, reltype, url, rId = add_matching_ext_rel_fixture_
        _rId = rels.get_or_add_ext_rel(reltype, url)
        assert _rId == rId
        assert len(rels) == 1

    def it_can_compose_rels_xml(self, rels, rels_elm):
        # exercise ---------------------
        rels.xml
        # verify -----------------------
        rels_elm.assert_has_calls(
            [
                call.add_rel(
                    'rId1', 'http://rt-hyperlink', 'http://some/link', True
                ),
                call.add_rel(
                    'rId2', 'http://rt-image', '../media/image1.png', False
                ),
                call.xml()
            ],
            any_order=True
        )

    # fixtures ---------------------------------------------

    @pytest.fixture
    def add_ext_rel_fixture_(self, reltype, url):
        rels = Relationships(None)
        return rels, reltype, url

    @pytest.fixture
    def add_matching_ext_rel_fixture_(self, request, reltype, url):
        rId = 'rId369'
        rels = Relationships(None)
        rels.add_relationship(reltype, url, rId, is_external=True)
        return rels, reltype, url, rId

    @pytest.fixture
    def _Relationship_(self, request):
        return class_mock(request, 'docx.opc.package._Relationship')

    @pytest.fixture
    def rels(self):
        """
        Populated Relationships instance that will exercise the rels.xml
        property.
        """
        rels = Relationships('/baseURI')
        rels.add_relationship(
            reltype='http://rt-hyperlink', target='http://some/link',
            rId='rId1', is_external=True
        )
        part = Mock(name='part')
        part.partname.relative_ref.return_value = '../media/image1.png'
        rels.add_relationship(reltype='http://rt-image', target=part,
                              rId='rId2')
        return rels

    @pytest.fixture
    def rels_elm(self, request):
        """
        Return a rels_elm mock that will be returned from
        CT_Relationships.new()
        """
        # create rels_elm mock with a .xml property
        rels_elm = Mock(name='rels_elm')
        xml = PropertyMock(name='xml')
        type(rels_elm).xml = xml
        rels_elm.attach_mock(xml, 'xml')
        rels_elm.reset_mock()  # to clear attach_mock call
        # patch CT_Relationships to return that rels_elm
        patch_ = patch.object(CT_Relationships, 'new', return_value=rels_elm)
        patch_.start()
        request.addfinalizer(patch_.stop)
        return rels_elm

    @pytest.fixture
    def reltype(self):
        return 'http://rel/type'

    @pytest.fixture
    def url(self):
        return 'https://github.com/scanny/python-docx'


class DescribeUnmarshaller(object):

    def it_can_unmarshal_from_a_pkg_reader(
            self, pkg_reader_, pkg_, part_factory_, _unmarshal_parts,
            _unmarshal_relationships, parts_dict_):
        # exercise ---------------------
        Unmarshaller.unmarshal(pkg_reader_, pkg_, part_factory_)
        # verify -----------------------
        _unmarshal_parts.assert_called_once_with(
            pkg_reader_, pkg_, part_factory_
        )
        _unmarshal_relationships.assert_called_once_with(
            pkg_reader_, pkg_, parts_dict_
        )
        for part in parts_dict_.values():
            part.after_unmarshal.assert_called_once_with()
        pkg_.after_unmarshal.assert_called_once_with()

    def it_can_unmarshal_parts(
            self, pkg_reader_, pkg_, part_factory_, parts_dict_, partnames_,
            content_types_, reltypes_, blobs_):
        # fixture ----------------------
        partname_, partname_2_ = partnames_
        content_type_, content_type_2_ = content_types_
        reltype_, reltype_2_ = reltypes_
        blob_, blob_2_ = blobs_
        # exercise ---------------------
        parts = Unmarshaller._unmarshal_parts(
            pkg_reader_, pkg_, part_factory_
        )
        # verify -----------------------
        assert (
            part_factory_.call_args_list == [
                call(partname_, content_type_, reltype_, blob_, pkg_),
                call(partname_2_, content_type_2_, reltype_2_, blob_2_, pkg_)
            ]
        )
        assert parts == parts_dict_

    def it_can_unmarshal_relationships(self):
        # test data --------------------
        reltype = 'http://reltype'
        # mockery ----------------------
        pkg_reader = Mock(name='pkg_reader')
        pkg_reader.iter_srels.return_value = (
            ('/',         Mock(name='srel1', rId='rId1', reltype=reltype,
             target_partname='partname1', is_external=False)),
            ('/',         Mock(name='srel2', rId='rId2', reltype=reltype,
             target_ref='target_ref_1',   is_external=True)),
            ('partname1', Mock(name='srel3', rId='rId3', reltype=reltype,
             target_partname='partname2', is_external=False)),
            ('partname2', Mock(name='srel4', rId='rId4', reltype=reltype,
             target_ref='target_ref_2',   is_external=True)),
        )
        pkg = Mock(name='pkg')
        parts = {}
        for num in range(1, 3):
            name = 'part%d' % num
            part = Mock(name=name)
            parts['partname%d' % num] = part
            pkg.attach_mock(part, name)
        # exercise ---------------------
        Unmarshaller._unmarshal_relationships(pkg_reader, pkg, parts)
        # verify -----------------------
        expected_pkg_calls = [
            call.load_rel(reltype, parts['partname1'], 'rId1', False),
            call.load_rel(reltype, 'target_ref_1', 'rId2', True),
            call.part1.load_rel(reltype, parts['partname2'], 'rId3', False),
            call.part2.load_rel(reltype, 'target_ref_2', 'rId4', True),
        ]
        assert pkg.mock_calls == expected_pkg_calls

    # fixtures ---------------------------------------------

    @pytest.fixture
    def blobs_(self, request):
        blob_ = loose_mock(request, spec=str, name='blob_')
        blob_2_ = loose_mock(request, spec=str, name='blob_2_')
        return blob_, blob_2_

    @pytest.fixture
    def content_types_(self, request):
        content_type_ = loose_mock(request, spec=str, name='content_type_')
        content_type_2_ = loose_mock(request, spec=str, name='content_type_2_')
        return content_type_, content_type_2_

    @pytest.fixture
    def part_factory_(self, request, parts_):
        part_factory_ = loose_mock(request, spec=Part)
        part_factory_.side_effect = parts_
        return part_factory_

    @pytest.fixture
    def partnames_(self, request):
        partname_ = loose_mock(request, spec=str, name='partname_')
        partname_2_ = loose_mock(request, spec=str, name='partname_2_')
        return partname_, partname_2_

    @pytest.fixture
    def parts_(self, request):
        part_ = instance_mock(request, Part, name='part_')
        part_2_ = instance_mock(request, Part, name='part_2')
        return part_, part_2_

    @pytest.fixture
    def parts_dict_(self, request, partnames_, parts_):
        partname_, partname_2_ = partnames_
        part_, part_2_ = parts_
        return {partname_: part_, partname_2_: part_2_}

    @pytest.fixture
    def pkg_(self, request):
        return instance_mock(request, OpcPackage)

    @pytest.fixture
    def pkg_reader_(
            self, request, partnames_, content_types_, reltypes_, blobs_):
        partname_, partname_2_ = partnames_
        content_type_, content_type_2_ = content_types_
        reltype_, reltype_2_ = reltypes_
        blob_, blob_2_ = blobs_
        iter_spart_items = (
            (partname_, content_type_, reltype_, blob_),
            (partname_2_, content_type_2_, reltype_2_, blob_2_),
        )
        pkg_reader_ = instance_mock(request, PackageReader)
        pkg_reader_.iter_sparts.return_value = iter_spart_items
        return pkg_reader_

    @pytest.fixture
    def reltypes_(self, request):
        reltype_ = instance_mock(request, str, name='reltype_')
        reltype_2_ = instance_mock(request, str, name='reltype_2')
        return reltype_, reltype_2_

    @pytest.fixture
    def _unmarshal_parts(self, request, parts_dict_):
        return method_mock(
            request, Unmarshaller, '_unmarshal_parts',
            return_value=parts_dict_
        )

    @pytest.fixture
    def _unmarshal_relationships(self, request):
        return method_mock(request, Unmarshaller, '_unmarshal_relationships')


# from ..oxml.unitdata.text import an_hlinkClick, an_rPr
# from ..unitutil import (
#     absjoin, class_mock, cls_attr_mock, instance_mock, loose_mock,
#     method_mock, test_file_dir
# )
# test_docx_path = absjoin(test_file_dir, 'test.docx')
# dir_pkg_path = absjoin(test_file_dir, 'expanded_docx')
# zip_pkg_path = test_docx_path

# def test_it_finds_default_case_insensitive(self, cti):
#     """_ContentTypesItem[partname] finds default case insensitive"""
#     # setup ------------------------
#     partname = '/ppt/media/image1.JPG'
#     content_type = 'image/jpeg'
#     cti._defaults = {'jpg': content_type}
#     # exercise ---------------------
#     val = cti[partname]
#     # verify -----------------------
#     assert val == content_type

# def test_it_finds_override_case_insensitive(self, cti):
#     """_ContentTypesItem[partname] finds override case insensitive"""
#     # setup ------------------------
#     partname = '/foo/bar.xml'
#     case_mangled_partname = '/FoO/bAr.XML'
#     content_type = 'application/vnd.content_type'
#     cti._overrides = {
#         partname: content_type
#     }
#     # exercise ---------------------
#     val = cti[case_mangled_partname]
#     # verify -----------------------
#     assert val == content_type

# def test_save_accepts_stream(self, tmp_docx_path):
#     pkg = Package().open(dir_pkg_path)
#     stream = StringIO()
#     # exercise --------------------
#     pkg.save(stream)
#     # verify ----------------------
#     # can't use is_zipfile() directly on stream in Python 2.6
#     stream.seek(0)
#     with open(tmp_docx_path, 'wb') as f:
#         f.write(stream.read())
#     msg = "Package.save(stream) did not create zipfile"
#     assert is_zipfile(tmp_docx_path), msg


# @pytest.fixture
# def tmp_docx_path(tmpdir):
#     return str(tmpdir.join('test_python-docx.docx'))

########NEW FILE########
__FILENAME__ = test_packuri
# encoding: utf-8

"""
Test suite for the docx.opc.packuri module
"""

import pytest

from docx.opc.packuri import PackURI


class DescribePackURI(object):

    def cases(self, expected_values):
        """
        Return list of tuples zipped from uri_str cases and
        *expected_values*. Raise if lengths don't match.
        """
        uri_str_cases = [
            '/',
            '/ppt/presentation.xml',
            '/ppt/slides/slide1.xml',
        ]
        if len(expected_values) != len(uri_str_cases):
            msg = "len(expected_values) differs from len(uri_str_cases)"
            raise AssertionError(msg)
        pack_uris = [PackURI(uri_str) for uri_str in uri_str_cases]
        return zip(pack_uris, expected_values)

    def it_can_construct_from_relative_ref(self):
        baseURI = '/ppt/slides'
        relative_ref = '../slideLayouts/slideLayout1.xml'
        pack_uri = PackURI.from_rel_ref(baseURI, relative_ref)
        assert pack_uri == '/ppt/slideLayouts/slideLayout1.xml'

    def it_should_raise_on_construct_with_bad_pack_uri_str(self):
        with pytest.raises(ValueError):
            PackURI('foobar')

    def it_can_calculate_baseURI(self):
        expected_values = ('/', '/ppt', '/ppt/slides')
        for pack_uri, expected_baseURI in self.cases(expected_values):
            assert pack_uri.baseURI == expected_baseURI

    def it_can_calculate_extension(self):
        expected_values = ('', 'xml', 'xml')
        for pack_uri, expected_ext in self.cases(expected_values):
            assert pack_uri.ext == expected_ext

    def it_can_calculate_filename(self):
        expected_values = ('', 'presentation.xml', 'slide1.xml')
        for pack_uri, expected_filename in self.cases(expected_values):
            assert pack_uri.filename == expected_filename

    def it_knows_the_filename_index(self):
        expected_values = (None, None, 1)
        for pack_uri, expected_idx in self.cases(expected_values):
            assert pack_uri.idx == expected_idx

    def it_can_calculate_membername(self):
        expected_values = (
            '',
            'ppt/presentation.xml',
            'ppt/slides/slide1.xml',
        )
        for pack_uri, expected_membername in self.cases(expected_values):
            assert pack_uri.membername == expected_membername

    def it_can_calculate_relative_ref_value(self):
        cases = (
            ('/', '/ppt/presentation.xml', 'ppt/presentation.xml'),
            ('/ppt', '/ppt/slideMasters/slideMaster1.xml',
             'slideMasters/slideMaster1.xml'),
            ('/ppt/slides', '/ppt/slideLayouts/slideLayout1.xml',
             '../slideLayouts/slideLayout1.xml'),
        )
        for baseURI, uri_str, expected_relative_ref in cases:
            pack_uri = PackURI(uri_str)
            assert pack_uri.relative_ref(baseURI) == expected_relative_ref

    def it_can_calculate_rels_uri(self):
        expected_values = (
            '/_rels/.rels',
            '/ppt/_rels/presentation.xml.rels',
            '/ppt/slides/_rels/slide1.xml.rels',
        )
        for pack_uri, expected_rels_uri in self.cases(expected_values):
            assert pack_uri.rels_uri == expected_rels_uri

########NEW FILE########
__FILENAME__ = test_phys_pkg
# encoding: utf-8

"""
Test suite for docx.opc.phys_pkg module
"""

from __future__ import absolute_import

try:
    from io import BytesIO  # Python 3
except ImportError:
    from StringIO import StringIO as BytesIO

import hashlib
import pytest

from mock import Mock
from zipfile import ZIP_DEFLATED, ZipFile

from docx.opc.exceptions import PackageNotFoundError
from docx.opc.packuri import PACKAGE_URI, PackURI
from docx.opc.phys_pkg import (
    _DirPkgReader, PhysPkgReader, PhysPkgWriter, _ZipPkgReader, _ZipPkgWriter
)

from ..unitutil import absjoin, class_mock, loose_mock, test_file_dir


test_docx_path = absjoin(test_file_dir, 'test.docx')
dir_pkg_path = absjoin(test_file_dir, 'expanded_docx')
zip_pkg_path = test_docx_path


class DescribeDirPkgReader(object):

    def it_is_used_by_PhysPkgReader_when_pkg_is_a_dir(self):
        phys_reader = PhysPkgReader(dir_pkg_path)
        assert isinstance(phys_reader, _DirPkgReader)

    def it_doesnt_mind_being_closed_even_though_it_doesnt_need_it(
            self, dir_reader):
        dir_reader.close()

    def it_can_retrieve_the_blob_for_a_pack_uri(self, dir_reader):
        pack_uri = PackURI('/word/document.xml')
        blob = dir_reader.blob_for(pack_uri)
        sha1 = hashlib.sha1(blob).hexdigest()
        assert sha1 == '0e62d87ea74ea2b8088fd11ee97b42da9b4c77b0'

    def it_can_get_the_content_types_xml(self, dir_reader):
        sha1 = hashlib.sha1(dir_reader.content_types_xml).hexdigest()
        assert sha1 == '89aadbb12882dd3d7340cd47382dc2c73d75dd81'

    def it_can_retrieve_the_rels_xml_for_a_source_uri(self, dir_reader):
        rels_xml = dir_reader.rels_xml_for(PACKAGE_URI)
        sha1 = hashlib.sha1(rels_xml).hexdigest()
        assert sha1 == 'ebacdddb3e7843fdd54c2f00bc831551b26ac823'

    def it_returns_none_when_part_has_no_rels_xml(self, dir_reader):
        partname = PackURI('/ppt/viewProps.xml')
        rels_xml = dir_reader.rels_xml_for(partname)
        assert rels_xml is None

    # fixtures ---------------------------------------------

    @pytest.fixture
    def pkg_file_(self, request):
        return loose_mock(request)

    @pytest.fixture(scope='class')
    def dir_reader(self):
        return _DirPkgReader(dir_pkg_path)


class DescribePhysPkgReader(object):

    def it_raises_when_pkg_path_is_not_a_package(self):
        with pytest.raises(PackageNotFoundError):
            PhysPkgReader('foobar')


class DescribeZipPkgReader(object):

    def it_is_used_by_PhysPkgReader_when_pkg_is_a_zip(self):
        phys_reader = PhysPkgReader(zip_pkg_path)
        assert isinstance(phys_reader, _ZipPkgReader)

    def it_is_used_by_PhysPkgReader_when_pkg_is_a_stream(self):
        with open(zip_pkg_path, 'rb') as stream:
            phys_reader = PhysPkgReader(stream)
        assert isinstance(phys_reader, _ZipPkgReader)

    def it_opens_pkg_file_zip_on_construction(self, ZipFile_, pkg_file_):
        _ZipPkgReader(pkg_file_)
        ZipFile_.assert_called_once_with(pkg_file_, 'r')

    def it_can_be_closed(self, ZipFile_):
        # mockery ----------------------
        zipf = ZipFile_.return_value
        zip_pkg_reader = _ZipPkgReader(None)
        # exercise ---------------------
        zip_pkg_reader.close()
        # verify -----------------------
        zipf.close.assert_called_once_with()

    def it_can_retrieve_the_blob_for_a_pack_uri(self, phys_reader):
        pack_uri = PackURI('/word/document.xml')
        blob = phys_reader.blob_for(pack_uri)
        sha1 = hashlib.sha1(blob).hexdigest()
        assert sha1 == 'b9b4a98bcac7c5a162825b60c3db7df11e02ac5f'

    def it_has_the_content_types_xml(self, phys_reader):
        sha1 = hashlib.sha1(phys_reader.content_types_xml).hexdigest()
        assert sha1 == 'cd687f67fd6b5f526eedac77cf1deb21968d7245'

    def it_can_retrieve_rels_xml_for_source_uri(self, phys_reader):
        rels_xml = phys_reader.rels_xml_for(PACKAGE_URI)
        sha1 = hashlib.sha1(rels_xml).hexdigest()
        assert sha1 == '90965123ed2c79af07a6963e7cfb50a6e2638565'

    def it_returns_none_when_part_has_no_rels_xml(self, phys_reader):
        partname = PackURI('/ppt/viewProps.xml')
        rels_xml = phys_reader.rels_xml_for(partname)
        assert rels_xml is None

    # fixtures ---------------------------------------------

    @pytest.fixture(scope='class')
    def phys_reader(self, request):
        phys_reader = _ZipPkgReader(zip_pkg_path)
        request.addfinalizer(phys_reader.close)
        return phys_reader

    @pytest.fixture
    def pkg_file_(self, request):
        return loose_mock(request)


class DescribeZipPkgWriter(object):

    def it_is_used_by_PhysPkgWriter_unconditionally(self, tmp_docx_path):
        phys_writer = PhysPkgWriter(tmp_docx_path)
        assert isinstance(phys_writer, _ZipPkgWriter)

    def it_opens_pkg_file_zip_on_construction(self, ZipFile_):
        pkg_file = Mock(name='pkg_file')
        _ZipPkgWriter(pkg_file)
        ZipFile_.assert_called_once_with(
            pkg_file, 'w', compression=ZIP_DEFLATED
        )

    def it_can_be_closed(self, ZipFile_):
        # mockery ----------------------
        zipf = ZipFile_.return_value
        zip_pkg_writer = _ZipPkgWriter(None)
        # exercise ---------------------
        zip_pkg_writer.close()
        # verify -----------------------
        zipf.close.assert_called_once_with()

    def it_can_write_a_blob(self, pkg_file):
        # setup ------------------------
        pack_uri = PackURI('/part/name.xml')
        blob = '<BlobbityFooBlob/>'.encode('utf-8')
        # exercise ---------------------
        pkg_writer = PhysPkgWriter(pkg_file)
        pkg_writer.write(pack_uri, blob)
        pkg_writer.close()
        # verify -----------------------
        written_blob_sha1 = hashlib.sha1(blob).hexdigest()
        zipf = ZipFile(pkg_file, 'r')
        retrieved_blob = zipf.read(pack_uri.membername)
        zipf.close()
        retrieved_blob_sha1 = hashlib.sha1(retrieved_blob).hexdigest()
        assert retrieved_blob_sha1 == written_blob_sha1

    # fixtures ---------------------------------------------

    @pytest.fixture
    def pkg_file(self, request):
        pkg_file = BytesIO()
        request.addfinalizer(pkg_file.close)
        return pkg_file


# fixtures -------------------------------------------------

@pytest.fixture
def tmp_docx_path(tmpdir):
    return str(tmpdir.join('test_python-docx.docx'))


@pytest.fixture
def ZipFile_(request):
    return class_mock(request, 'docx.opc.phys_pkg.ZipFile')

########NEW FILE########
__FILENAME__ = test_pkgreader
# encoding: utf-8

"""
Test suite for opc.pkgreader module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from mock import call, Mock, patch

from docx.opc.constants import (
    CONTENT_TYPE as CT, RELATIONSHIP_TARGET_MODE as RTM
)
from docx.opc.packuri import PackURI
from docx.opc.phys_pkg import _ZipPkgReader
from docx.opc.pkgreader import (
    _ContentTypeMap, PackageReader, _SerializedPart, _SerializedRelationship,
    _SerializedRelationships
)

from .unitdata.types import a_Default, a_Types, an_Override
from ..unitutil import (
    initializer_mock, class_mock, function_mock, instance_mock, loose_mock,
    method_mock
)


class DescribePackageReader(object):

    def it_can_construct_from_pkg_file(
            self, init, PhysPkgReader_, from_xml, _srels_for,
            _load_serialized_parts):
        # mockery ----------------------
        phys_reader = PhysPkgReader_.return_value
        content_types = from_xml.return_value
        pkg_srels = _srels_for.return_value
        sparts = _load_serialized_parts.return_value
        pkg_file = Mock(name='pkg_file')
        # exercise ---------------------
        pkg_reader = PackageReader.from_file(pkg_file)
        # verify -----------------------
        PhysPkgReader_.assert_called_once_with(pkg_file)
        from_xml.assert_called_once_with(phys_reader.content_types_xml)
        _srels_for.assert_called_once_with(phys_reader, '/')
        _load_serialized_parts.assert_called_once_with(phys_reader, pkg_srels,
                                                       content_types)
        phys_reader.close.assert_called_once_with()
        init.assert_called_once_with(content_types, pkg_srels, sparts)
        assert isinstance(pkg_reader, PackageReader)

    def it_can_iterate_over_the_serialized_parts(self, iter_sparts_fixture):
        pkg_reader, expected_iter_spart_items = iter_sparts_fixture
        iter_spart_items = list(pkg_reader.iter_sparts())
        assert iter_spart_items == expected_iter_spart_items

    def it_can_iterate_over_all_the_srels(self):
        # mockery ----------------------
        pkg_srels = ['srel1', 'srel2']
        sparts = [
            Mock(name='spart1', partname='pn1', srels=['srel3', 'srel4']),
            Mock(name='spart2', partname='pn2', srels=['srel5', 'srel6']),
        ]
        pkg_reader = PackageReader(None, pkg_srels, sparts)
        # exercise ---------------------
        generated_tuples = [t for t in pkg_reader.iter_srels()]
        # verify -----------------------
        expected_tuples = [
            ('/',   'srel1'),
            ('/',   'srel2'),
            ('pn1', 'srel3'),
            ('pn1', 'srel4'),
            ('pn2', 'srel5'),
            ('pn2', 'srel6'),
        ]
        assert generated_tuples == expected_tuples

    def it_can_load_serialized_parts(self, _SerializedPart_, _walk_phys_parts):
        # test data --------------------
        test_data = (
            ('/part/name1.xml', 'app/vnd.type_1', 'reltype1', '<Part_1/>',
             'srels_1'),
            ('/part/name2.xml', 'app/vnd.type_2', 'reltype2', '<Part_2/>',
             'srels_2'),
        )
        iter_vals = [(t[0], t[2], t[3], t[4]) for t in test_data]
        content_types = dict((t[0], t[1]) for t in test_data)
        # mockery ----------------------
        phys_reader = Mock(name='phys_reader')
        pkg_srels = Mock(name='pkg_srels')
        _walk_phys_parts.return_value = iter_vals
        _SerializedPart_.side_effect = expected_sparts = (
            Mock(name='spart_1'), Mock(name='spart_2')
        )
        # exercise ---------------------
        retval = PackageReader._load_serialized_parts(
            phys_reader, pkg_srels, content_types
        )
        # verify -----------------------
        expected_calls = [
            call('/part/name1.xml', 'app/vnd.type_1', '<Part_1/>',
                 'reltype1', 'srels_1'),
            call('/part/name2.xml', 'app/vnd.type_2', '<Part_2/>',
                 'reltype2', 'srels_2'),
        ]
        assert _SerializedPart_.call_args_list == expected_calls
        assert retval == expected_sparts

    def it_can_walk_phys_pkg_parts(self, _srels_for):
        # test data --------------------
        # +----------+       +--------+
        # | pkg_rels |-----> | part_1 |
        # +----------+       +--------+
        #      |               |    ^
        #      v               v    |
        #   external         +--------+     +--------+
        #                    | part_2 |---> | part_3 |
        #                    +--------+     +--------+
        partname_1, partname_2, partname_3 = (
            '/part/name1.xml', '/part/name2.xml', '/part/name3.xml'
        )
        part_1_blob, part_2_blob, part_3_blob = (
            '<Part_1/>', '<Part_2/>', '<Part_3/>'
        )
        reltype1, reltype2, reltype3 = ('reltype1', 'reltype2', 'reltype3')
        srels = [
            Mock(name='rId1', is_external=True),
            Mock(name='rId2', is_external=False, reltype=reltype1,
                 target_partname=partname_1),
            Mock(name='rId3', is_external=False, reltype=reltype2,
                 target_partname=partname_2),
            Mock(name='rId4', is_external=False, reltype=reltype1,
                 target_partname=partname_1),
            Mock(name='rId5', is_external=False, reltype=reltype3,
                 target_partname=partname_3),
        ]
        pkg_srels = srels[:2]
        part_1_srels = srels[2:3]
        part_2_srels = srels[3:5]
        part_3_srels = []
        # mockery ----------------------
        phys_reader = Mock(name='phys_reader')
        _srels_for.side_effect = [part_1_srels, part_2_srels, part_3_srels]
        phys_reader.blob_for.side_effect = [
            part_1_blob, part_2_blob, part_3_blob
        ]
        # exercise ---------------------
        generated_tuples = list(
            PackageReader._walk_phys_parts(phys_reader, pkg_srels)
        )
        # verify -----------------------
        expected_tuples = [
            (partname_1, part_1_blob, reltype1, part_1_srels),
            (partname_2, part_2_blob, reltype2, part_2_srels),
            (partname_3, part_3_blob, reltype3, part_3_srels),
        ]
        assert generated_tuples == expected_tuples

    def it_can_retrieve_srels_for_a_source_uri(
            self, _SerializedRelationships_):
        # mockery ----------------------
        phys_reader = Mock(name='phys_reader')
        source_uri = Mock(name='source_uri')
        rels_xml = phys_reader.rels_xml_for.return_value
        load_from_xml = _SerializedRelationships_.load_from_xml
        srels = load_from_xml.return_value
        # exercise ---------------------
        retval = PackageReader._srels_for(phys_reader, source_uri)
        # verify -----------------------
        phys_reader.rels_xml_for.assert_called_once_with(source_uri)
        load_from_xml.assert_called_once_with(source_uri.baseURI, rels_xml)
        assert retval == srels

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def blobs_(self, request):
        blob_ = loose_mock(request, spec=str, name='blob_')
        blob_2_ = loose_mock(request, spec=str, name='blob_2_')
        return blob_, blob_2_

    @pytest.fixture
    def content_types_(self, request):
        content_type_ = loose_mock(request, spec=str, name='content_type_')
        content_type_2_ = loose_mock(request, spec=str, name='content_type_2_')
        return content_type_, content_type_2_

    @pytest.fixture
    def from_xml(self, request):
        return method_mock(request, _ContentTypeMap, 'from_xml')

    @pytest.fixture
    def init(self, request):
        return initializer_mock(request, PackageReader)

    @pytest.fixture
    def iter_sparts_fixture(
            self, sparts_, partnames_, content_types_, reltypes_, blobs_):
        pkg_reader = PackageReader(None, None, sparts_)
        expected_iter_spart_items = [
            (partnames_[0], content_types_[0], reltypes_[0], blobs_[0]),
            (partnames_[1], content_types_[1], reltypes_[1], blobs_[1]),
        ]
        return pkg_reader, expected_iter_spart_items

    @pytest.fixture
    def _load_serialized_parts(self, request):
        return method_mock(request, PackageReader, '_load_serialized_parts')

    @pytest.fixture
    def partnames_(self, request):
        partname_ = loose_mock(request, spec=str, name='partname_')
        partname_2_ = loose_mock(request, spec=str, name='partname_2_')
        return partname_, partname_2_

    @pytest.fixture
    def PhysPkgReader_(self, request):
        _patch = patch(
            'docx.opc.pkgreader.PhysPkgReader', spec_set=_ZipPkgReader
        )
        request.addfinalizer(_patch.stop)
        return _patch.start()

    @pytest.fixture
    def reltypes_(self, request):
        reltype_ = instance_mock(request, str, name='reltype_')
        reltype_2_ = instance_mock(request, str, name='reltype_2')
        return reltype_, reltype_2_

    @pytest.fixture
    def _SerializedPart_(self, request):
        return class_mock(request, 'docx.opc.pkgreader._SerializedPart')

    @pytest.fixture
    def _SerializedRelationships_(self, request):
        return class_mock(
            request, 'docx.opc.pkgreader._SerializedRelationships'
        )

    @pytest.fixture
    def sparts_(
            self, request, partnames_, content_types_, reltypes_, blobs_):
        sparts_ = []
        for idx in range(2):
            name = 'spart_%s' % (('%d_' % (idx+1)) if idx else '')
            spart_ = instance_mock(
                request, _SerializedPart, name=name,
                partname=partnames_[idx], content_type=content_types_[idx],
                reltype=reltypes_[idx], blob=blobs_[idx]
            )
            sparts_.append(spart_)
        return sparts_

    @pytest.fixture
    def _srels_for(self, request):
        return method_mock(request, PackageReader, '_srels_for')

    @pytest.fixture
    def _walk_phys_parts(self, request):
        return method_mock(request, PackageReader, '_walk_phys_parts')


class Describe_ContentTypeMap(object):

    def it_can_construct_from_ct_item_xml(self, from_xml_fixture):
        content_types_xml, expected_defaults, expected_overrides = (
            from_xml_fixture
        )
        ct_map = _ContentTypeMap.from_xml(content_types_xml)
        assert ct_map._defaults == expected_defaults
        assert ct_map._overrides == expected_overrides

    def it_matches_an_override_on_case_insensitive_partname(
            self, match_override_fixture):
        ct_map, partname, content_type = match_override_fixture
        assert ct_map[partname] == content_type

    def it_falls_back_to_case_insensitive_extension_default_match(
            self, match_default_fixture):
        ct_map, partname, content_type = match_default_fixture
        assert ct_map[partname] == content_type

    def it_should_raise_on_partname_not_found(self):
        ct_map = _ContentTypeMap()
        with pytest.raises(KeyError):
            ct_map[PackURI('/!blat/rhumba.1x&')]

    def it_should_raise_on_key_not_instance_of_PackURI(self):
        ct_map = _ContentTypeMap()
        ct_map._overrides = {PackURI('/part/name1.xml'): 'app/vnd.type1'}
        with pytest.raises(KeyError):
            ct_map['/part/name1.xml']

    # fixtures ---------------------------------------------

    @pytest.fixture
    def from_xml_fixture(self):
        entries = (
            ('Default', 'xml', CT.XML),
            ('Default', 'PNG', CT.PNG),
            ('Override', '/ppt/presentation.xml', CT.PML_PRESENTATION_MAIN),
        )
        content_types_xml = self._xml_from(entries)
        expected_defaults = {}
        expected_overrides = {}
        for entry in entries:
            if entry[0] == 'Default':
                ext = entry[1].lower()
                content_type = entry[2]
                expected_defaults[ext] = content_type
            elif entry[0] == 'Override':
                partname, content_type = entry[1:]
                expected_overrides[partname] = content_type
        return content_types_xml, expected_defaults, expected_overrides

    @pytest.fixture(params=[
        ('/foo/bar.xml', 'xml', 'application/xml'),
        ('/foo/bar.PNG', 'png', 'image/png'),
        ('/foo/bar.jpg', 'JPG', 'image/jpeg'),
    ])
    def match_default_fixture(self, request):
        partname_str, ext, content_type = request.param
        partname = PackURI(partname_str)
        ct_map = _ContentTypeMap()
        ct_map._add_override(PackURI('/bar/foo.xyz'), 'application/xyz')
        ct_map._add_default(ext, content_type)
        return ct_map, partname, content_type

    @pytest.fixture(params=[
        ('/foo/bar.xml', '/foo/bar.xml'),
        ('/foo/bar.xml', '/FOO/Bar.XML'),
        ('/FoO/bAr.XmL', '/foo/bar.xml'),
    ])
    def match_override_fixture(self, request):
        partname_str, should_match_partname_str = request.param
        partname = PackURI(partname_str)
        should_match_partname = PackURI(should_match_partname_str)
        content_type = 'appl/vnd-foobar'
        ct_map = _ContentTypeMap()
        ct_map._add_override(partname, content_type)
        return ct_map, should_match_partname, content_type

    def _xml_from(self, entries):
        """
        Return XML for a [Content_Types].xml based on items in *entries*.
        """
        types_bldr = a_Types().with_nsdecls()
        for entry in entries:
            if entry[0] == 'Default':
                ext, content_type = entry[1:]
                default_bldr = a_Default()
                default_bldr.with_Extension(ext)
                default_bldr.with_ContentType(content_type)
                types_bldr.with_child(default_bldr)
            elif entry[0] == 'Override':
                partname, content_type = entry[1:]
                override_bldr = an_Override()
                override_bldr.with_PartName(partname)
                override_bldr.with_ContentType(content_type)
                types_bldr.with_child(override_bldr)
        return types_bldr.xml()


class Describe_SerializedPart(object):

    def it_remembers_construction_values(self):
        # test data --------------------
        partname = '/part/name.xml'
        content_type = 'app/vnd.type'
        reltype = 'http://rel/type'
        blob = '<Part/>'
        srels = 'srels proxy'
        # exercise ---------------------
        spart = _SerializedPart(partname, content_type, reltype, blob, srels)
        # verify -----------------------
        assert spart.partname == partname
        assert spart.content_type == content_type
        assert spart.reltype == reltype
        assert spart.blob == blob
        assert spart.srels == srels


class Describe_SerializedRelationship(object):

    def it_remembers_construction_values(self):
        # test data --------------------
        rel_elm = Mock(
            name='rel_elm', rId='rId9', reltype='ReLtYpE',
            target_ref='docProps/core.xml', target_mode=RTM.INTERNAL
        )
        # exercise ---------------------
        srel = _SerializedRelationship('/', rel_elm)
        # verify -----------------------
        assert srel.rId == 'rId9'
        assert srel.reltype == 'ReLtYpE'
        assert srel.target_ref == 'docProps/core.xml'
        assert srel.target_mode == RTM.INTERNAL

    def it_knows_when_it_is_external(self):
        cases = (RTM.INTERNAL, RTM.EXTERNAL, 'FOOBAR')
        expected_values = (False, True, False)
        for target_mode, expected_value in zip(cases, expected_values):
            rel_elm = Mock(name='rel_elm', rId=None, reltype=None,
                           target_ref=None, target_mode=target_mode)
            srel = _SerializedRelationship(None, rel_elm)
            assert srel.is_external is expected_value

    def it_can_calculate_its_target_partname(self):
        # test data --------------------
        cases = (
            ('/', 'docProps/core.xml', '/docProps/core.xml'),
            ('/ppt', 'viewProps.xml', '/ppt/viewProps.xml'),
            ('/ppt/slides', '../slideLayouts/slideLayout1.xml',
             '/ppt/slideLayouts/slideLayout1.xml'),
        )
        for baseURI, target_ref, expected_partname in cases:
            # setup --------------------
            rel_elm = Mock(name='rel_elm', rId=None, reltype=None,
                           target_ref=target_ref, target_mode=RTM.INTERNAL)
            # exercise -----------------
            srel = _SerializedRelationship(baseURI, rel_elm)
            # verify -------------------
            assert srel.target_partname == expected_partname

    def it_raises_on_target_partname_when_external(self):
        rel_elm = Mock(
            name='rel_elm', rId='rId9', reltype='ReLtYpE',
            target_ref='docProps/core.xml', target_mode=RTM.EXTERNAL
        )
        srel = _SerializedRelationship('/', rel_elm)
        with pytest.raises(ValueError):
            srel.target_partname


class Describe_SerializedRelationships(object):

    def it_can_load_from_xml(
            self, oxml_fromstring_, _SerializedRelationship_):
        # mockery ----------------------
        baseURI, rels_item_xml, rel_elm_1, rel_elm_2 = (
            Mock(name='baseURI'), Mock(name='rels_item_xml'),
            Mock(name='rel_elm_1'), Mock(name='rel_elm_2'),
        )
        rels_elm = Mock(
            name='rels_elm', Relationship_lst=[rel_elm_1, rel_elm_2]
        )
        oxml_fromstring_.return_value = rels_elm
        # exercise ---------------------
        srels = _SerializedRelationships.load_from_xml(
            baseURI, rels_item_xml)
        # verify -----------------------
        expected_calls = [
            call(baseURI, rel_elm_1),
            call(baseURI, rel_elm_2),
        ]
        oxml_fromstring_.assert_called_once_with(rels_item_xml)
        assert _SerializedRelationship_.call_args_list == expected_calls
        assert isinstance(srels, _SerializedRelationships)

    def it_should_be_iterable(self):
        srels = _SerializedRelationships()
        try:
            for x in srels:
                pass
        except TypeError:
            msg = "_SerializedRelationships object is not iterable"
            pytest.fail(msg)

    # fixtures ---------------------------------------------

    @pytest.fixture
    def oxml_fromstring_(self, request):
        return function_mock(request, 'docx.opc.pkgreader.oxml_fromstring')

    @pytest.fixture
    def _SerializedRelationship_(self, request):
        return class_mock(
            request, 'docx.opc.pkgreader._SerializedRelationship'
        )

########NEW FILE########
__FILENAME__ = test_pkgwriter
# encoding: utf-8

"""
Test suite for opc.pkgwriter module
"""

import pytest

from mock import call, MagicMock, Mock, patch

from docx.opc.constants import CONTENT_TYPE as CT
from docx.opc.package import Part
from docx.opc.packuri import PackURI
from docx.opc.phys_pkg import _ZipPkgWriter
from docx.opc.pkgwriter import _ContentTypesItem, PackageWriter

from .unitdata.types import a_Default, a_Types, an_Override
from ..unitutil import class_mock, instance_mock, method_mock


class DescribePackageWriter(object):

    def it_can_write_a_package(self, PhysPkgWriter_, _write_methods):
        # mockery ----------------------
        pkg_file = Mock(name='pkg_file')
        pkg_rels = Mock(name='pkg_rels')
        parts = Mock(name='parts')
        phys_writer = PhysPkgWriter_.return_value
        # exercise ---------------------
        PackageWriter.write(pkg_file, pkg_rels, parts)
        # verify -----------------------
        expected_calls = [
            call._write_content_types_stream(phys_writer, parts),
            call._write_pkg_rels(phys_writer, pkg_rels),
            call._write_parts(phys_writer, parts),
        ]
        PhysPkgWriter_.assert_called_once_with(pkg_file)
        assert _write_methods.mock_calls == expected_calls
        phys_writer.close.assert_called_once_with()

    def it_can_write_a_content_types_stream(self, write_cti_fixture):
        _ContentTypesItem_, parts_, phys_pkg_writer_, blob_ = (
            write_cti_fixture
        )
        PackageWriter._write_content_types_stream(phys_pkg_writer_, parts_)
        _ContentTypesItem_.from_parts.assert_called_once_with(parts_)
        phys_pkg_writer_.write.assert_called_once_with(
            '/[Content_Types].xml', blob_
        )

    def it_can_write_a_pkg_rels_item(self):
        # mockery ----------------------
        phys_writer = Mock(name='phys_writer')
        pkg_rels = Mock(name='pkg_rels')
        # exercise ---------------------
        PackageWriter._write_pkg_rels(phys_writer, pkg_rels)
        # verify -----------------------
        phys_writer.write.assert_called_once_with('/_rels/.rels',
                                                  pkg_rels.xml)

    def it_can_write_a_list_of_parts(self):
        # mockery ----------------------
        phys_writer = Mock(name='phys_writer')
        rels = MagicMock(name='rels')
        rels.__len__.return_value = 1
        part1 = Mock(name='part1', _rels=rels)
        part2 = Mock(name='part2', _rels=[])
        # exercise ---------------------
        PackageWriter._write_parts(phys_writer, [part1, part2])
        # verify -----------------------
        expected_calls = [
            call(part1.partname, part1.blob),
            call(part1.partname.rels_uri, part1._rels.xml),
            call(part2.partname, part2.blob),
        ]
        assert phys_writer.write.mock_calls == expected_calls

    # fixtures ---------------------------------------------

    @pytest.fixture
    def blob_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def cti_(self, request, blob_):
        return instance_mock(request, _ContentTypesItem, blob=blob_)

    @pytest.fixture
    def _ContentTypesItem_(self, request, cti_):
        _ContentTypesItem_ = class_mock(
            request, 'docx.opc.pkgwriter._ContentTypesItem'
        )
        _ContentTypesItem_.from_parts.return_value = cti_
        return _ContentTypesItem_

    @pytest.fixture
    def parts_(self, request):
        return instance_mock(request, list)

    @pytest.fixture
    def PhysPkgWriter_(self, request):
        _patch = patch('docx.opc.pkgwriter.PhysPkgWriter')
        request.addfinalizer(_patch.stop)
        return _patch.start()

    @pytest.fixture
    def phys_pkg_writer_(self, request):
        return instance_mock(request, _ZipPkgWriter)

    @pytest.fixture
    def write_cti_fixture(
            self, _ContentTypesItem_, parts_, phys_pkg_writer_, blob_):
        return _ContentTypesItem_, parts_, phys_pkg_writer_, blob_

    @pytest.fixture
    def _write_methods(self, request):
        """Mock that patches all the _write_* methods of PackageWriter"""
        root_mock = Mock(name='PackageWriter')
        patch1 = patch.object(PackageWriter, '_write_content_types_stream')
        patch2 = patch.object(PackageWriter, '_write_pkg_rels')
        patch3 = patch.object(PackageWriter, '_write_parts')
        root_mock.attach_mock(patch1.start(), '_write_content_types_stream')
        root_mock.attach_mock(patch2.start(), '_write_pkg_rels')
        root_mock.attach_mock(patch3.start(), '_write_parts')

        def fin():
            patch1.stop()
            patch2.stop()
            patch3.stop()

        request.addfinalizer(fin)
        return root_mock

    @pytest.fixture
    def xml_for_(self, request):
        return method_mock(request, _ContentTypesItem, 'xml_for')


class Describe_ContentTypesItem(object):

    def it_can_compose_content_types_element(self, xml_for_fixture):
        cti, expected_xml = xml_for_fixture
        types_elm = cti._element
        assert types_elm.xml == expected_xml

    # fixtures ---------------------------------------------

    def _mock_part(self, request, name, partname_str, content_type):
        partname = PackURI(partname_str)
        return instance_mock(
            request, Part, name=name, partname=partname,
            content_type=content_type
        )

    @pytest.fixture(params=[
        ('Default',  '/ppt/MEDIA/image.PNG',   CT.PNG),
        ('Default',  '/ppt/media/image.xml',   CT.XML),
        ('Default',  '/ppt/media/image.rels',  CT.OPC_RELATIONSHIPS),
        ('Default',  '/ppt/media/image.jpeg',  CT.JPEG),
        ('Override', '/docProps/core.xml',     'app/vnd.core'),
        ('Override', '/ppt/slides/slide1.xml', 'app/vnd.ct_sld'),
        ('Override', '/zebra/foo.bar',         'app/vnd.foobar'),
    ])
    def xml_for_fixture(self, request):
        elm_type, partname_str, content_type = request.param
        part_ = self._mock_part(request, 'part_', partname_str, content_type)
        cti = _ContentTypesItem.from_parts([part_])
        # expected_xml -----------------
        types_bldr = a_Types().with_nsdecls()
        ext = partname_str.split('.')[-1].lower()
        if elm_type == 'Default' and ext not in ('rels', 'xml'):
            default_bldr = a_Default()
            default_bldr.with_Extension(ext)
            default_bldr.with_ContentType(content_type)
            types_bldr.with_child(default_bldr)

        types_bldr.with_child(
            a_Default().with_Extension('rels')
                       .with_ContentType(CT.OPC_RELATIONSHIPS)
        )
        types_bldr.with_child(
            a_Default().with_Extension('xml').with_ContentType(CT.XML)
        )

        if elm_type == 'Override':
            override_bldr = an_Override()
            override_bldr.with_PartName(partname_str)
            override_bldr.with_ContentType(content_type)
            types_bldr.with_child(override_bldr)

        expected_xml = types_bldr.xml()
        return cti, expected_xml

########NEW FILE########
__FILENAME__ = test_rels
# encoding: utf-8

"""
Test suite for docx.opc relationships
"""

from __future__ import absolute_import

import pytest

from mock import call, Mock, patch, PropertyMock

from docx.opc.constants import RELATIONSHIP_TYPE as RT
from docx.opc.oxml import CT_Relationships
from docx.opc.package import Part, _Relationship, Relationships
from docx.opc.packuri import PackURI

from ..unitutil import class_mock, instance_mock, loose_mock


class Describe_Relationship(object):

    def it_remembers_construction_values(self):
        # test data --------------------
        rId = 'rId9'
        reltype = 'reltype'
        target = Mock(name='target_part')
        external = False
        # exercise ---------------------
        rel = _Relationship(rId, reltype, target, None, external)
        # verify -----------------------
        assert rel.rId == rId
        assert rel.reltype == reltype
        assert rel.target_part == target
        assert rel.is_external == external

    def it_should_raise_on_target_part_access_on_external_rel(self):
        rel = _Relationship(None, None, None, None, external=True)
        with pytest.raises(ValueError):
            rel.target_part

    def it_should_have_target_ref_for_external_rel(self):
        rel = _Relationship(None, None, 'target', None, external=True)
        assert rel.target_ref == 'target'

    def it_should_have_relative_ref_for_internal_rel(self):
        """
        Internal relationships (TargetMode == 'Internal' in the XML) should
        have a relative ref, e.g. '../slideLayouts/slideLayout1.xml', for
        the target_ref attribute.
        """
        part = Mock(name='part', partname=PackURI('/ppt/media/image1.png'))
        baseURI = '/ppt/slides'
        rel = _Relationship(None, None, part, baseURI)  # external=False
        assert rel.target_ref == '../media/image1.png'


class DescribeRelationships(object):

    def it_also_has_dict_style_get_rel_by_rId(self, rels_with_known_rel):
        rels, rId, known_rel = rels_with_known_rel
        assert rels[rId] == known_rel

    def it_should_raise_on_failed_lookup_by_rId(self, rels):
        with pytest.raises(KeyError):
            rels['rId666']

    def it_has_a_len(self, rels):
        assert len(rels) == 0

    def it_can_add_a_relationship(self, _Relationship_):
        baseURI, rId, reltype, target, is_external = (
            'baseURI', 'rId9', 'reltype', 'target', False
        )
        rels = Relationships(baseURI)
        rel = rels.add_relationship(reltype, target, rId, is_external)
        _Relationship_.assert_called_once_with(
            rId, reltype, target, baseURI, is_external
        )
        assert rels[rId] == rel
        assert rel == _Relationship_.return_value

    def it_can_add_a_relationship_if_not_found(
            self, rels_with_matching_rel_, rels_with_missing_rel_):

        rels, reltype, part, matching_rel = rels_with_matching_rel_
        assert rels.get_or_add(reltype, part) == matching_rel

        rels, reltype, part, new_rel = rels_with_missing_rel_
        assert rels.get_or_add(reltype, part) == new_rel

    def it_knows_the_next_available_rId(self, rels_with_rId_gap):
        rels, expected_next_rId = rels_with_rId_gap
        next_rId = rels._next_rId
        assert next_rId == expected_next_rId

    def it_can_find_a_related_part_by_reltype(
            self, rels_with_target_known_by_reltype):
        rels, reltype, known_target_part = rels_with_target_known_by_reltype
        part = rels.part_with_reltype(reltype)
        assert part is known_target_part

    def it_can_find_a_related_part_by_rId(self, rels_with_known_target_part):
        rels, rId, known_target_part = rels_with_known_target_part
        part = rels.related_parts[rId]
        assert part is known_target_part

    def it_raises_KeyError_on_part_with_rId_not_found(self, rels):
        with pytest.raises(KeyError):
            rels.related_parts['rId666']

    def it_can_compose_rels_xml(self, rels_with_known_rels, rels_elm):
        rels_with_known_rels.xml
        rels_elm.assert_has_calls(
            [
                call.add_rel(
                    'rId1', 'http://rt-hyperlink', 'http://some/link', True
                ),
                call.add_rel(
                    'rId2', 'http://rt-image', '../media/image1.png', False
                ),
                call.xml()
            ],
            any_order=True
        )

    # def it_raises_on_add_rel_with_duplicate_rId(self, rels, rel):
    #     with pytest.raises(ValueError):
    #         rels.add_rel(rel)

    # fixtures ---------------------------------------------

    @pytest.fixture
    def _Relationship_(self, request):
        return class_mock(request, 'docx.opc.package._Relationship')

    @pytest.fixture
    def rel(self, _rId, _reltype, _target_part, _baseURI):
        return _Relationship(_rId, _reltype, _target_part, _baseURI)

    @pytest.fixture
    def rels(self, _baseURI):
        return Relationships(_baseURI)

    @pytest.fixture
    def rels_elm(self, request):
        """
        Return a rels_elm mock that will be returned from
        CT_Relationships.new()
        """
        # create rels_elm mock with a .xml property
        rels_elm = Mock(name='rels_elm')
        xml = PropertyMock(name='xml')
        type(rels_elm).xml = xml
        rels_elm.attach_mock(xml, 'xml')
        rels_elm.reset_mock()  # to clear attach_mock call
        # patch CT_Relationships to return that rels_elm
        patch_ = patch.object(CT_Relationships, 'new', return_value=rels_elm)
        patch_.start()
        request.addfinalizer(patch_.stop)
        return rels_elm

    @pytest.fixture
    def rels_with_known_rel(self, rels, _rId, rel):
        rels[_rId] = rel
        return rels, _rId, rel

    @pytest.fixture
    def rels_with_known_rels(self):
        """
        Populated Relationships instance that will exercise the rels.xml
        property.
        """
        rels = Relationships('/baseURI')
        rels.add_relationship(
            reltype='http://rt-hyperlink', target='http://some/link',
            rId='rId1', is_external=True
        )
        part = Mock(name='part')
        part.partname.relative_ref.return_value = '../media/image1.png'
        rels.add_relationship(reltype='http://rt-image', target=part,
                              rId='rId2')
        return rels

    @pytest.fixture
    def rels_with_known_target_part(self, rels, _rel_with_known_target_part):
        rel, rId, target_part = _rel_with_known_target_part
        rels.add_relationship(None, target_part, rId)
        return rels, rId, target_part

    @pytest.fixture
    def rels_with_matching_rel_(self, request, rels):
        matching_reltype_ = instance_mock(
            request, str, name='matching_reltype_'
        )
        matching_part_ = instance_mock(
            request, Part, name='matching_part_'
        )
        matching_rel_ = instance_mock(
            request, _Relationship, name='matching_rel_',
            reltype=matching_reltype_, target_part=matching_part_,
            is_external=False
        )
        rels[1] = matching_rel_
        return rels, matching_reltype_, matching_part_, matching_rel_

    @pytest.fixture
    def rels_with_missing_rel_(self, request, rels, _Relationship_):
        missing_reltype_ = instance_mock(
            request, str, name='missing_reltype_'
        )
        missing_part_ = instance_mock(
            request, Part, name='missing_part_'
        )
        new_rel_ = instance_mock(
            request, _Relationship, name='new_rel_',
            reltype=missing_reltype_, target_part=missing_part_,
            is_external=False
        )
        _Relationship_.return_value = new_rel_
        return rels, missing_reltype_, missing_part_, new_rel_

    @pytest.fixture
    def rels_with_rId_gap(self, request, rels):
        rel_with_rId1 = instance_mock(
            request, _Relationship, name='rel_with_rId1', rId='rId1'
        )
        rel_with_rId3 = instance_mock(
            request, _Relationship, name='rel_with_rId3', rId='rId3'
        )
        rels['rId1'] = rel_with_rId1
        rels['rId3'] = rel_with_rId3
        return rels, 'rId2'

    @pytest.fixture
    def rels_with_target_known_by_reltype(
            self, rels, _rel_with_target_known_by_reltype):
        rel, reltype, target_part = _rel_with_target_known_by_reltype
        rels[1] = rel
        return rels, reltype, target_part

    @pytest.fixture
    def _baseURI(self):
        return '/baseURI'

    @pytest.fixture
    def _rel_with_known_target_part(
            self, _rId, _reltype, _target_part, _baseURI):
        rel = _Relationship(_rId, _reltype, _target_part, _baseURI)
        return rel, _rId, _target_part

    @pytest.fixture
    def _rel_with_target_known_by_reltype(
            self, _rId, _reltype, _target_part, _baseURI):
        rel = _Relationship(_rId, _reltype, _target_part, _baseURI)
        return rel, _reltype, _target_part

    @pytest.fixture
    def _reltype(self):
        return RT.SLIDE

    @pytest.fixture
    def _rId(self):
        return 'rId6'

    @pytest.fixture
    def _target_part(self, request):
        return loose_mock(request)

########NEW FILE########
__FILENAME__ = rels
# encoding: utf-8

"""
Test data for relationship-related unit tests.
"""

from __future__ import absolute_import

from docx.opc.constants import RELATIONSHIP_TYPE as RT
from docx.opc.package import Relationships

from docx.opc.constants import NAMESPACE as NS
from docx.opc.oxml import oxml_fromstring


class BaseBuilder(object):
    """
    Provides common behavior for all data builders.
    """
    @property
    def element(self):
        """Return element based on XML generated by builder"""
        return oxml_fromstring(self.xml)

    def with_indent(self, indent):
        """Add integer *indent* spaces at beginning of element XML"""
        self._indent = indent
        return self


class RelationshipsBuilder(object):
    """Builder class for test Relationships"""
    partname_tmpls = {
        RT.SLIDE_MASTER: '/ppt/slideMasters/slideMaster%d.xml',
        RT.SLIDE:        '/ppt/slides/slide%d.xml',
    }

    def __init__(self):
        self.relationships = []
        self.next_rel_num = 1
        self.next_partnums = {}

    def _next_partnum(self, reltype):
        if reltype not in self.next_partnums:
            self.next_partnums[reltype] = 1
        partnum = self.next_partnums[reltype]
        self.next_partnums[reltype] = partnum + 1
        return partnum

    @property
    def next_rId(self):
        rId = 'rId%d' % self.next_rel_num
        self.next_rel_num += 1
        return rId

    def _next_tuple_partname(self, reltype):
        partname_tmpl = self.partname_tmpls[reltype]
        partnum = self._next_partnum(reltype)
        return partname_tmpl % partnum

    def build(self):
        rels = Relationships()
        for rel in self.relationships:
            rels.add_rel(rel)
        return rels


class CT_DefaultBuilder(BaseBuilder):
    """
    Test data builder for CT_Default (Default) XML element that appears in
    `[Content_Types].xml`.
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._content_type = 'application/xml'
        self._extension = 'xml'
        self._indent = 0
        self._namespace = ' xmlns="%s"' % NS.OPC_CONTENT_TYPES

    def with_content_type(self, content_type):
        """Set ContentType attribute to *content_type*"""
        self._content_type = content_type
        return self

    def with_extension(self, extension):
        """Set Extension attribute to *extension*"""
        self._extension = extension
        return self

    def without_namespace(self):
        """Don't include an 'xmlns=' attribute"""
        self._namespace = ''
        return self

    @property
    def xml(self):
        """Return Default element"""
        tmpl = '%s<Default%s Extension="%s" ContentType="%s"/>\n'
        indent = ' ' * self._indent
        return tmpl % (indent, self._namespace, self._extension,
                       self._content_type)


class CT_OverrideBuilder(BaseBuilder):
    """
    Test data builder for CT_Override (Override) XML element that appears in
    `[Content_Types].xml`.
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._content_type = 'app/vnd.type'
        self._indent = 0
        self._namespace = ' xmlns="%s"' % NS.OPC_CONTENT_TYPES
        self._partname = '/part/name.xml'

    def with_content_type(self, content_type):
        """Set ContentType attribute to *content_type*"""
        self._content_type = content_type
        return self

    def with_partname(self, partname):
        """Set PartName attribute to *partname*"""
        self._partname = partname
        return self

    def without_namespace(self):
        """Don't include an 'xmlns=' attribute"""
        self._namespace = ''
        return self

    @property
    def xml(self):
        """Return Override element"""
        tmpl = '%s<Override%s PartName="%s" ContentType="%s"/>\n'
        indent = ' ' * self._indent
        return tmpl % (indent, self._namespace, self._partname,
                       self._content_type)


class CT_RelationshipBuilder(BaseBuilder):
    """
    Test data builder for CT_Relationship (Relationship) XML element that
    appears in .rels files
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._rId = 'rId9'
        self._reltype = 'ReLtYpE'
        self._target = 'docProps/core.xml'
        self._target_mode = None
        self._indent = 0
        self._namespace = ' xmlns="%s"' % NS.OPC_RELATIONSHIPS

    def with_rId(self, rId):
        """Set Id attribute to *rId*"""
        self._rId = rId
        return self

    def with_reltype(self, reltype):
        """Set Type attribute to *reltype*"""
        self._reltype = reltype
        return self

    def with_target(self, target):
        """Set XXX attribute to *target*"""
        self._target = target
        return self

    def with_target_mode(self, target_mode):
        """Set TargetMode attribute to *target_mode*"""
        self._target_mode = None if target_mode == 'Internal' else target_mode
        return self

    def without_namespace(self):
        """Don't include an 'xmlns=' attribute"""
        self._namespace = ''
        return self

    @property
    def target_mode(self):
        if self._target_mode is None:
            return ''
        return ' TargetMode="%s"' % self._target_mode

    @property
    def xml(self):
        """Return Relationship element"""
        tmpl = '%s<Relationship%s Id="%s" Type="%s" Target="%s"%s/>\n'
        indent = ' ' * self._indent
        return tmpl % (indent, self._namespace, self._rId, self._reltype,
                       self._target, self.target_mode)


class CT_RelationshipsBuilder(BaseBuilder):
    """
    Test data builder for CT_Relationships (Relationships) XML element, the
    root element in .rels files.
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._rels = (
            ('rId1', 'http://reltype1', 'docProps/core.xml',    'Internal'),
            ('rId2', 'http://linktype', 'http://some/link',     'External'),
            ('rId3', 'http://reltype2', '../slides/slide1.xml', 'Internal'),
        )

    @property
    def xml(self):
        """
        Return XML string based on settings accumulated via method calls.
        """
        xml = '<Relationships xmlns="%s">\n' % NS.OPC_RELATIONSHIPS
        for rId, reltype, target, target_mode in self._rels:
            xml += (a_Relationship().with_rId(rId)
                                    .with_reltype(reltype)
                                    .with_target(target)
                                    .with_target_mode(target_mode)
                                    .with_indent(2)
                                    .without_namespace()
                                    .xml)
        xml += '</Relationships>\n'
        return xml


class CT_TypesBuilder(BaseBuilder):
    """
    Test data builder for CT_Types (<Types>) XML element, the root element in
    [Content_Types].xml files
    """
    def __init__(self):
        """Establish instance variables with default values"""
        self._defaults = (
            ('xml', 'application/xml'),
            ('jpeg', 'image/jpeg'),
        )
        self._empty = False
        self._overrides = (
            ('/docProps/core.xml', 'app/vnd.type1'),
            ('/ppt/presentation.xml', 'app/vnd.type2'),
            ('/docProps/thumbnail.jpeg', 'image/jpeg'),
        )

    def empty(self):
        self._empty = True
        return self

    @property
    def xml(self):
        """
        Return XML string based on settings accumulated via method calls
        """
        if self._empty:
            return '<Types xmlns="%s"/>\n' % NS.OPC_CONTENT_TYPES

        xml = '<Types xmlns="%s">\n' % NS.OPC_CONTENT_TYPES
        for extension, content_type in self._defaults:
            xml += (a_Default().with_extension(extension)
                               .with_content_type(content_type)
                               .with_indent(2)
                               .without_namespace()
                               .xml)
        for partname, content_type in self._overrides:
            xml += (an_Override().with_partname(partname)
                                 .with_content_type(content_type)
                                 .with_indent(2)
                                 .without_namespace()
                                 .xml)
        xml += '</Types>\n'
        return xml


def a_Default():
    return CT_DefaultBuilder()


def a_Relationship():
    return CT_RelationshipBuilder()


def a_Relationships():
    return CT_RelationshipsBuilder()


def a_Types():
    return CT_TypesBuilder()


def an_Override():
    return CT_OverrideBuilder()

########NEW FILE########
__FILENAME__ = types
# encoding: utf-8

"""
XML test data builders for [Content_Types].xml elements
"""

from __future__ import absolute_import, print_function, unicode_literals

from docx.opc.oxml import nsmap

from ...unitdata import BaseBuilder


class CT_DefaultBuilder(BaseBuilder):
    __tag__ = 'Default'
    __nspfxs__ = ('ct',)
    __attrs__ = ('Extension', 'ContentType')


class CT_OverrideBuilder(BaseBuilder):
    __tag__ = 'Override'
    __nspfxs__ = ('ct',)
    __attrs__ = ('PartName', 'ContentType')


class CT_TypesBuilder(BaseBuilder):
    __tag__ = 'Types'
    __nspfxs__ = ('ct',)
    __attrs__ = ()

    def with_nsdecls(self, *nspfxs):
        self._nsdecls = ' xmlns="%s"' % nsmap['ct']
        return self


def a_Default():
    return CT_DefaultBuilder()


def a_Types():
    return CT_TypesBuilder()


def an_Override():
    return CT_OverrideBuilder()

########NEW FILE########
__FILENAME__ = test_document
# encoding: utf-8

"""
Test suite for the docx.oxml.parts module.
"""

from docx.oxml.parts.document import CT_Body
from docx.oxml.text import CT_P

from .unitdata.document import a_body, a_document
from ..unitdata.text import a_p, a_sectPr


class DescribeCT_Body(object):

    def it_can_add_a_p_to_itself(self):
        """
        Return a newly created |CT_P| element that has been added after any
        existing content.
        """
        cases = (
            (a_body().with_nsdecls(),
             a_body().with_nsdecls().with_child(a_p())),
            (a_body().with_nsdecls().with_child(a_sectPr()),
             a_body().with_nsdecls().with_child(a_p()).with_child(a_sectPr())),
        )
        for before_body_bldr, after_body_bldr in cases:
            body = before_body_bldr.element
            # exercise -----------------
            p = body.add_p()
            # verify -------------------
            assert body.xml == after_body_bldr.xml()
            assert isinstance(p, CT_P)

    def it_can_clear_all_the_content_it_holds(self):
        """
        Remove all content child elements from this <w:body> element.
        """
        cases = (
            (a_body().with_nsdecls(),
             a_body().with_nsdecls()),
            (a_body().with_nsdecls().with_child(a_p()),
             a_body().with_nsdecls()),
            (a_body().with_nsdecls().with_child(a_sectPr()),
             a_body().with_nsdecls().with_child(a_sectPr())),
            (a_body().with_nsdecls().with_child(a_p()).with_child(a_sectPr()),
             a_body().with_nsdecls().with_child(a_sectPr())),
        )
        for before_body_bldr, after_body_bldr in cases:
            body = before_body_bldr.element
            # exercise -----------------
            body.clear_content()
            # verify -------------------
            assert body.xml == after_body_bldr.xml()


class DescribeCT_Document(object):

    def it_holds_a_body_element(self):
        document = a_document().with_nsdecls().with_child(a_body()).element
        assert isinstance(document.body, CT_Body)

########NEW FILE########
__FILENAME__ = document
# encoding: utf-8

"""
Test data builders for parts XML.
"""

from ....unitdata import BaseBuilder


class CT_BodyBuilder(BaseBuilder):
    __tag__ = 'w:body'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_DocumentBuilder(BaseBuilder):
    __tag__ = 'w:document'
    __nspfxs__ = ('w',)
    __attrs__ = ()


def a_body():
    return CT_BodyBuilder()


def a_document():
    return CT_DocumentBuilder()

########NEW FILE########
__FILENAME__ = test_shared
# encoding: utf-8

"""
Test suite for docx.oxml.shared
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

import pytest

from docx.oxml.shared import XmlString


class DescribeXmlString(object):

    def it_knows_if_two_xml_lines_are_equivalent(self, xml_line_case):
        line, other, differs = xml_line_case
        xml = XmlString(line)
        assert xml == other
        assert xml != differs

    # fixtures ---------------------------------------------

    @pytest.fixture(params=[
        'simple_elm', 'nsp_tagname', 'indent', 'attrs', 'nsdecl_order',
        'closing_elm',
    ])
    def xml_line_case(self, request):
        cases = {
            'simple_elm': (
                '<name/>',
                '<name/>',
                '<name>',
            ),
            'nsp_tagname': (
                '<xyz:name/>',
                '<xyz:name/>',
                '<abc:name/>',
            ),
            'indent': (
                '  <xyz:name/>',
                '  <xyz:name/>',
                '<xyz:name/>',
            ),
            'attrs': (
                '  <abc:Name foo="bar" bar="foo">',
                '  <abc:Name bar="foo" foo="bar">',
                '  <abc:Name far="boo" foo="bar">',
            ),
            'nsdecl_order': (
                '    <name xmlns:a="http://ns/1" xmlns:b="http://ns/2"/>',
                '    <name xmlns:b="http://ns/2" xmlns:a="http://ns/1"/>',
                '    <name xmlns:b="http://ns/2" xmlns:a="http://ns/1">',
            ),
            'closing_elm': (
                '</xyz:name>',
                '</xyz:name>',
                '<xyz:name>',
            ),
        }
        line, other, differs = cases[request.param]
        return line, other, differs

########NEW FILE########
__FILENAME__ = test_text
# encoding: utf-8

"""
Test suite for the docx.oxml.text module.
"""

from docx.oxml.text import CT_P, CT_PPr, CT_R, CT_Text

from .unitdata.text import a_p, a_pPr, a_pStyle, a_t, an_r


class DescribeCT_P(object):

    def it_can_construct_a_new_p_element(self):
        p = CT_P.new()
        expected_xml = a_p().with_nsdecls().xml()
        assert p.xml == expected_xml

    def it_has_a_sequence_of_the_runs_it_contains(self):
        p = a_p().with_nsdecls().with_child(an_r()).with_child(an_r()).element
        assert len(p.r_lst) == 2
        for r in p.r_lst:
            assert isinstance(r, CT_R)

    def it_can_add_an_r_to_itself(self):
        p = a_p().with_nsdecls().element
        # exercise -----------------
        r = p.add_r()
        # verify -------------------
        assert p.xml == a_p().with_nsdecls().with_child(an_r()).xml()
        assert isinstance(r, CT_R)

    def it_knows_its_paragraph_style(self):
        pPr_bldr = a_pPr().with_child(a_pStyle().with_val('foobar'))
        cases = (
            (a_p(), None),
            (a_p().with_child(pPr_bldr), 'foobar'),
        )
        for builder, expected_value in cases:
            p = builder.with_nsdecls().element
            assert p.style == expected_value

    def it_can_set_its_paragraph_style(self):
        pPr = a_pPr().with_child(a_pStyle().with_val('foobar'))
        pPr2 = a_pPr().with_child(a_pStyle().with_val('barfoo'))
        cases = (
            (1, a_p(), None, a_p().with_child(a_pPr())),
            (2, a_p(), 'foobar', a_p().with_child(pPr)),
            (3, a_p().with_child(pPr), None, a_p().with_child(a_pPr())),
            (4, a_p().with_child(pPr), 'barfoo', a_p().with_child(pPr2)),
        )
        for case_nmbr, before_bldr, new_style, after_bldr in cases:
            p = before_bldr.with_nsdecls().element
            p.style = new_style
            expected_xml = after_bldr.with_nsdecls().xml()
            assert p.xml == expected_xml


class DescribeCT_PPr(object):

    def it_can_construct_a_new_pPr_element(self):
        pPr = CT_PPr.new()
        expected_xml = a_pPr().with_nsdecls().xml()
        assert pPr.xml == expected_xml

    def it_knows_the_paragraph_style(self):
        cases = (
            (a_pPr(), None),
            (a_pPr().with_child(a_pStyle().with_val('foobar')), 'foobar'),
        )
        for builder, expected_value in cases:
            pPr = builder.with_nsdecls().element
            assert pPr.style == expected_value

    def it_can_set_the_paragraph_style(self):
        cases = (
            (1, a_pPr(), None, a_pPr()),
            (2, a_pPr(), 'foobar',
             a_pPr().with_child(a_pStyle().with_val('foobar'))),
            (3, a_pPr().with_child(a_pStyle().with_val('foobar')), None,
             a_pPr()),
            (4, a_pPr().with_child(a_pStyle().with_val('foobar')), 'barfoo',
             a_pPr().with_child(a_pStyle().with_val('barfoo'))),
        )
        for case_nmbr, before_bldr, new_style, after_bldr in cases:
            pPr = before_bldr.with_nsdecls().element
            pPr.style = new_style
            expected_xml = after_bldr.with_nsdecls().xml()
            assert pPr.xml == expected_xml


class DescribeCT_R(object):

    def it_can_construct_a_new_r_element(self):
        r = CT_R.new()
        assert r.xml == an_r().with_nsdecls().xml()

    def it_can_add_a_t_to_itself(self):
        text = 'foobar'
        r = an_r().with_nsdecls().element
        # exercise -----------------
        t = r.add_t(text)
        # verify -------------------
        assert (
            r.xml ==
            an_r().with_nsdecls().with_child(a_t().with_text(text)).xml()
        )
        assert isinstance(t, CT_Text)

    def it_has_a_sequence_of_the_t_elms_it_contains(self):
        cases = (
            (an_r().with_nsdecls(), 0),
            (an_r().with_nsdecls().with_child(
                a_t().with_text('foo')), 1),
            (an_r().with_nsdecls().with_child(
                a_t().with_text('foo')).with_child(
                a_t().with_text('bar')), 2),
        )
        for r_bldr, expected_len in cases:
            r = r_bldr.element
            assert len(r.t_lst) == expected_len
            for t in r.t_lst:
                assert isinstance(t, CT_Text)


class DescribeCT_Text(object):

    def it_can_construct_a_new_t_element(self):
        text = 'foobar'
        t = CT_Text.new(text)
        assert t.xml == a_t().with_nsdecls().with_text(text).xml()

########NEW FILE########
__FILENAME__ = dml
# encoding: utf-8

"""
Test data builders for DrawingML XML elements
"""

from ...unitdata import BaseBuilder


class CT_BlipBuilder(BaseBuilder):
    __tag__ = 'a:blip'
    __nspfxs__ = ('a',)
    __attrs__ = ('r:embed', 'r:link', 'cstate')


class CT_BlipFillPropertiesBuilder(BaseBuilder):
    __tag__ = 'pic:blipFill'
    __nspfxs__ = ('pic',)
    __attrs__ = ()


class CT_DrawingBuilder(BaseBuilder):
    __tag__ = 'w:drawing'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_GraphicalObjectBuilder(BaseBuilder):
    __tag__ = 'a:graphic'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_GraphicalObjectDataBuilder(BaseBuilder):
    __tag__ = 'a:graphicData'
    __nspfxs__ = ('a',)
    __attrs__ = ('uri',)


class CT_InlineBuilder(BaseBuilder):
    __tag__ = 'wp:inline'
    __nspfxs__ = ('wp',)
    __attrs__ = ('distT', 'distB', 'distL', 'distR')


class CT_NonVisualDrawingPropsBuilder(BaseBuilder):
    __nspfxs__ = ('wp',)
    __attrs__ = ('id', 'name', 'descr', 'hidden', 'title')

    def __init__(self, tag):
        self.__tag__ = tag
        super(CT_NonVisualDrawingPropsBuilder, self).__init__()


class CT_NonVisualPicturePropertiesBuilder(BaseBuilder):
    __tag__ = 'pic:cNvPicPr'
    __nspfxs__ = ('pic',)
    __attrs__ = ('preferRelativeResize')


class CT_PictureBuilder(BaseBuilder):
    __tag__ = 'pic:pic'
    __nspfxs__ = ('pic',)
    __attrs__ = ()


class CT_PictureNonVisualBuilder(BaseBuilder):
    __tag__ = 'pic:nvPicPr'
    __nspfxs__ = ('pic',)
    __attrs__ = ()


class CT_Point2DBuilder(BaseBuilder):
    __tag__ = 'a:off'
    __nspfxs__ = ('a',)
    __attrs__ = ('x', 'y')


class CT_PositiveSize2DBuilder(BaseBuilder):
    __nspfxs__ = ()
    __attrs__ = ('cx', 'cy')

    def __init__(self, tag):
        self.__tag__ = tag
        super(CT_PositiveSize2DBuilder, self).__init__()


class CT_PresetGeometry2DBuilder(BaseBuilder):
    __tag__ = 'a:prstGeom'
    __nspfxs__ = ('a',)
    __attrs__ = ('prst',)


class CT_RelativeRectBuilder(BaseBuilder):
    __tag__ = 'a:fillRect'
    __nspfxs__ = ('a',)
    __attrs__ = ('l', 't', 'r', 'b')


class CT_ShapePropertiesBuilder(BaseBuilder):
    __tag__ = 'pic:spPr'
    __nspfxs__ = ('pic', 'a')
    __attrs__ = ('bwMode',)


class CT_StretchInfoPropertiesBuilder(BaseBuilder):
    __tag__ = 'a:stretch'
    __nspfxs__ = ('a',)
    __attrs__ = ()


class CT_Transform2DBuilder(BaseBuilder):
    __tag__ = 'a:xfrm'
    __nspfxs__ = ('a',)
    __attrs__ = ('rot', 'flipH', 'flipV')


def a_blip():
    return CT_BlipBuilder()


def a_blipFill():
    return CT_BlipFillPropertiesBuilder()


def a_cNvPicPr():
    return CT_NonVisualPicturePropertiesBuilder()


def a_cNvPr():
    return CT_NonVisualDrawingPropsBuilder('pic:cNvPr')


def a_docPr():
    return CT_NonVisualDrawingPropsBuilder('wp:docPr')


def a_drawing():
    return CT_DrawingBuilder()


def a_fillRect():
    return CT_RelativeRectBuilder()


def a_graphic():
    return CT_GraphicalObjectBuilder()


def a_graphicData():
    return CT_GraphicalObjectDataBuilder()


def a_pic():
    return CT_PictureBuilder()


def a_prstGeom():
    return CT_PresetGeometry2DBuilder()


def a_stretch():
    return CT_StretchInfoPropertiesBuilder()


def an_ext():
    return CT_PositiveSize2DBuilder('a:ext')


def an_extent():
    return CT_PositiveSize2DBuilder('wp:extent')


def an_inline():
    return CT_InlineBuilder()


def an_nvPicPr():
    return CT_PictureNonVisualBuilder()


def an_off():
    return CT_Point2DBuilder()


def an_spPr():
    return CT_ShapePropertiesBuilder()


def an_xfrm():
    return CT_Transform2DBuilder()

########NEW FILE########
__FILENAME__ = numbering
# encoding: utf-8

"""
Test data builders for numbering part XML elements
"""

from ...unitdata import BaseBuilder


class CT_NumBuilder(BaseBuilder):
    __tag__ = 'w:num'
    __nspfxs__ = ('w',)
    __attrs__ = ('w:numId')


class CT_NumberingBuilder(BaseBuilder):
    __tag__ = 'w:numbering'
    __nspfxs__ = ('w',)
    __attrs__ = ()


def a_num():
    return CT_NumBuilder()


def a_numbering():
    return CT_NumberingBuilder()

########NEW FILE########
__FILENAME__ = shared
# encoding: utf-8

"""
Test data builders shared by more than one other module
"""

from ...unitdata import BaseBuilder


class CT_OnOffBuilder(BaseBuilder):
    __nspfxs__ = ('w',)
    __attrs__ = ('w:val')

    def __init__(self, tag):
        self.__tag__ = tag
        super(CT_OnOffBuilder, self).__init__()

    def with_val(self, value):
        self._set_xmlattr('w:val', str(value))
        return self


class CT_StringBuilder(BaseBuilder):
    __nspfxs__ = ('w',)
    __attrs__ = ()

    def __init__(self, tag):
        self.__tag__ = tag
        super(CT_StringBuilder, self).__init__()

    def with_val(self, value):
        self._set_xmlattr('w:val', str(value))
        return self

########NEW FILE########
__FILENAME__ = styles
# encoding: utf-8

"""
Test data builders for styles part XML elements
"""

from ...unitdata import BaseBuilder


class CT_StyleBuilder(BaseBuilder):
    __tag__ = 'w:style'
    __nspfxs__ = ('w',)
    __attrs__ = ('w:type', 'w:styleId', 'w:default', 'w:customStyle')


class CT_StylesBuilder(BaseBuilder):
    __tag__ = 'w:styles'
    __nspfxs__ = ('w',)
    __attrs__ = ()


def a_style():
    return CT_StyleBuilder()


def a_styles():
    return CT_StylesBuilder()

########NEW FILE########
__FILENAME__ = table
# encoding: utf-8

"""
Test data builders for text XML elements
"""

from ...unitdata import BaseBuilder
from .shared import CT_StringBuilder


class CT_RowBuilder(BaseBuilder):
    __tag__ = 'w:tr'
    __nspfxs__ = ('w',)
    __attrs__ = ('w:w',)


class CT_TblBuilder(BaseBuilder):
    __tag__ = 'w:tbl'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_TblGridBuilder(BaseBuilder):
    __tag__ = 'w:tblGrid'
    __nspfxs__ = ('w',)
    __attrs__ = ('w:w',)


class CT_TblGridColBuilder(BaseBuilder):
    __tag__ = 'w:gridCol'
    __nspfxs__ = ('w',)
    __attrs__ = ('w:w',)


class CT_TblPrBuilder(BaseBuilder):
    __tag__ = 'w:tblPr'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_TcBuilder(BaseBuilder):
    __tag__ = 'w:tc'
    __nspfxs__ = ('w',)
    __attrs__ = ('w:id',)


class CT_TcPrBuilder(BaseBuilder):
    __tag__ = 'w:tcPr'
    __nspfxs__ = ('w',)
    __attrs__ = ()


def a_gridCol():
    return CT_TblGridColBuilder()


def a_tbl():
    return CT_TblBuilder()


def a_tblGrid():
    return CT_TblGridBuilder()


def a_tblPr():
    return CT_TblPrBuilder()


def a_tblStyle():
    return CT_StringBuilder('w:tblStyle')


def a_tc():
    return CT_TcBuilder()


def a_tcPr():
    return CT_TcPrBuilder()


def a_tr():
    return CT_RowBuilder()

########NEW FILE########
__FILENAME__ = text
# encoding: utf-8

"""
Test data builders for text XML elements
"""

from ...unitdata import BaseBuilder
from .shared import CT_OnOffBuilder, CT_StringBuilder


class CT_BrBuilder(BaseBuilder):
    __tag__ = 'w:br'
    __nspfxs__ = ('w',)
    __attrs__ = ('w:type', 'w:clear')


class CT_PBuilder(BaseBuilder):
    __tag__ = 'w:p'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_PPrBuilder(BaseBuilder):
    __tag__ = 'w:pPr'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_RBuilder(BaseBuilder):
    __tag__ = 'w:r'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_RPrBuilder(BaseBuilder):
    __tag__ = 'w:rPr'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_SectPrBuilder(BaseBuilder):
    __tag__ = 'w:sectPr'
    __nspfxs__ = ('w',)
    __attrs__ = ()


class CT_TextBuilder(BaseBuilder):
    __tag__ = 'w:t'
    __nspfxs__ = ('w',)
    __attrs__ = ()

    def with_space(self, value):
        self._set_xmlattr('xml:space', str(value))
        return self


class CT_Underline(BaseBuilder):
    __tag__ = 'w:u'
    __nspfxs__ = ('w',)
    __attrs__ = (
        'w:val', 'w:color', 'w:themeColor', 'w:themeTint', 'w:themeShade'
    )


def a_b():
    return CT_OnOffBuilder('w:b')


def a_bCs():
    return CT_OnOffBuilder('w:bCs')


def a_br():
    return CT_BrBuilder()


def a_caps():
    return CT_OnOffBuilder('w:caps')


def a_cs():
    return CT_OnOffBuilder('w:cs')


def a_dstrike():
    return CT_OnOffBuilder('w:dstrike')


def a_noProof():
    return CT_OnOffBuilder('w:noProof')


def a_shadow():
    return CT_OnOffBuilder('w:shadow')


def a_smallCaps():
    return CT_OnOffBuilder('w:smallCaps')


def a_snapToGrid():
    return CT_OnOffBuilder('w:snapToGrid')


def a_specVanish():
    return CT_OnOffBuilder('w:specVanish')


def a_strike():
    return CT_OnOffBuilder('w:strike')


def a_vanish():
    return CT_OnOffBuilder('w:vanish')


def a_webHidden():
    return CT_OnOffBuilder('w:webHidden')


def a_p():
    return CT_PBuilder()


def a_pPr():
    return CT_PPrBuilder()


def a_pStyle():
    return CT_StringBuilder('w:pStyle')


def a_sectPr():
    return CT_SectPrBuilder()


def a_t():
    return CT_TextBuilder()


def a_u():
    return CT_Underline()


def an_emboss():
    return CT_OnOffBuilder('w:emboss')


def an_i():
    return CT_OnOffBuilder('w:i')


def an_iCs():
    return CT_OnOffBuilder('w:iCs')


def an_imprint():
    return CT_OnOffBuilder('w:imprint')


def an_oMath():
    return CT_OnOffBuilder('w:oMath')


def an_outline():
    return CT_OnOffBuilder('w:outline')


def an_r():
    return CT_RBuilder()


def an_rPr():
    return CT_RPrBuilder()


def an_rStyle():
    return CT_StringBuilder('w:rStyle')


def an_rtl():
    return CT_OnOffBuilder('w:rtl')

########NEW FILE########
__FILENAME__ = test_document
# encoding: utf-8

"""
Test suite for the docx.parts.document module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from mock import Mock

from docx.opc.constants import CONTENT_TYPE as CT, RELATIONSHIP_TYPE as RT
from docx.opc.package import PartFactory
from docx.opc.packuri import PackURI
from docx.oxml.parts.document import CT_Body, CT_Document
from docx.oxml.text import CT_R
from docx.package import ImageParts, Package
from docx.parts.document import _Body, DocumentPart, InlineShapes
from docx.parts.image import ImagePart
from docx.shape import InlineShape
from docx.table import Table
from docx.text import Paragraph

from ..oxml.unitdata.dml import a_drawing, an_inline
from ..oxml.parts.unitdata.document import a_body, a_document
from ..oxml.unitdata.table import (
    a_gridCol, a_tbl, a_tblGrid, a_tblPr, a_tc, a_tr
)
from ..oxml.unitdata.text import a_p, a_sectPr, an_r
from ..unitutil import (
    function_mock, class_mock, initializer_mock, instance_mock, loose_mock,
    method_mock, property_mock
)


class DescribeDocumentPart(object):

    def it_is_used_by_PartFactory_to_construct_main_document_part(
            self, part_load_fixture):
        # fixture ----------------------
        document_part_load_, partname_, blob_, package_, document_part_ = (
            part_load_fixture
        )
        content_type = CT.WML_DOCUMENT_MAIN
        reltype = RT.OFFICE_DOCUMENT
        # exercise ---------------------
        part = PartFactory(partname_, content_type, reltype, blob_, package_)
        # verify -----------------------
        document_part_load_.assert_called_once_with(
            partname_, content_type, blob_, package_
        )
        assert part is document_part_

    def it_can_be_constructed_by_opc_part_factory(
            self, oxml_fromstring_, init):
        # mockery ----------------------
        partname, content_type, blob, document_elm, package = (
            Mock(name='partname'), Mock(name='content_type'),
            Mock(name='blob'), Mock(name='document_elm'),
            Mock(name='package')
        )
        oxml_fromstring_.return_value = document_elm
        # exercise ---------------------
        doc = DocumentPart.load(partname, content_type, blob, package)
        # verify -----------------------
        oxml_fromstring_.assert_called_once_with(blob)
        init.assert_called_once_with(
            partname, content_type, document_elm, package
        )
        assert isinstance(doc, DocumentPart)

    def it_can_add_a_paragraph(self, add_paragraph_fixture):
        document_part, body_, p_ = add_paragraph_fixture
        p = document_part.add_paragraph()
        body_.add_paragraph.assert_called_once_with()
        assert p is p_

    def it_can_add_a_table(self, add_table_fixture):
        document_part, rows, cols, body_, table_ = add_table_fixture
        table = document_part.add_table(rows, cols)
        body_.add_table.assert_called_once_with(rows, cols)
        assert table is table_

    def it_can_add_an_image_part_to_the_document(
            self, get_or_add_image_fixture):
        (document, image_descriptor_, image_parts_, relate_to_, image_part_,
         rId_) = get_or_add_image_fixture
        image_part, rId = document.get_or_add_image_part(image_descriptor_)
        image_parts_.get_or_add_image_part.assert_called_once_with(
            image_descriptor_
        )
        relate_to_.assert_called_once_with(image_part_, RT.IMAGE)
        assert image_part is image_part_
        assert rId == rId_

    def it_has_a_body(self, document_body_fixture):
        document, _Body_, body_elm = document_body_fixture
        _body = document.body
        _Body_.assert_called_once_with(body_elm)
        assert _body is _Body_.return_value

    def it_can_serialize_to_xml(self, document_blob_fixture):
        document_part, document_elm, serialize_part_xml_ = (
            document_blob_fixture
        )
        blob = document_part.blob
        serialize_part_xml_.assert_called_once_with(document_elm)
        assert blob is serialize_part_xml_.return_value

    def it_provides_access_to_the_document_paragraphs(
            self, paragraphs_fixture):
        document_part, paragraphs_ = paragraphs_fixture
        paragraphs = document_part.paragraphs
        assert paragraphs is paragraphs_

    def it_provides_access_to_the_document_tables(self, tables_fixture):
        document_part, tables_ = tables_fixture
        tables = document_part.tables
        assert tables is tables_

    def it_provides_access_to_the_inline_shapes_in_the_document(
            self, inline_shapes_fixture):
        document, InlineShapes_, body_elm = inline_shapes_fixture
        inline_shapes = document.inline_shapes
        InlineShapes_.assert_called_once_with(body_elm, document)
        assert inline_shapes is InlineShapes_.return_value

    def it_knows_it_is_the_part_its_child_objects_belong_to(self, document):
        assert document.part is document

    def it_knows_the_next_available_xml_id(self, next_id_fixture):
        document, expected_id = next_id_fixture
        assert document.next_id == expected_id

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def add_paragraph_fixture(self, document_part_body_, body_, p_):
        document_part = DocumentPart(None, None, None, None)
        return document_part, body_, p_

    @pytest.fixture
    def add_table_fixture(self, document_part_body_, body_, table_):
        document_part = DocumentPart(None, None, None, None)
        rows, cols = 2, 4
        return document_part, rows, cols, body_, table_

    @pytest.fixture
    def _Body_(self, request):
        return class_mock(request, 'docx.parts.document._Body')

    @pytest.fixture
    def body_(self, request, p_, table_):
        body_ = instance_mock(request, _Body)
        body_.add_paragraph.return_value = p_
        body_.add_table.return_value = table_
        return body_

    @pytest.fixture
    def blob_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def content_type_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def document(self):
        return DocumentPart(None, None, None, None)

    @pytest.fixture
    def document_blob_fixture(self, request, serialize_part_xml_):
        document_elm = instance_mock(request, CT_Document)
        document_part = DocumentPart(None, None, document_elm, None)
        return document_part, document_elm, serialize_part_xml_

    @pytest.fixture
    def document_body_fixture(self, request, _Body_):
        document_elm = (
            a_document().with_nsdecls().with_child(
                a_body())
        ).element
        body_elm = document_elm[0]
        document = DocumentPart(None, None, document_elm, None)
        return document, _Body_, body_elm

    @pytest.fixture
    def document_part_(self, request):
        return instance_mock(request, DocumentPart)

    @pytest.fixture
    def document_part_body_(self, request, body_):
        return property_mock(
            request, DocumentPart, 'body', return_value=body_
        )

    @pytest.fixture
    def document_part_load_(self, request):
        return method_mock(request, DocumentPart, 'load')

    @pytest.fixture
    def get_or_add_image_fixture(
            self, request, package_, image_descriptor_, image_parts_,
            relate_to_, image_part_, rId_):
        package_.image_parts = image_parts_
        document = DocumentPart(None, None, None, package_)
        return (
            document, image_descriptor_, image_parts_, relate_to_,
            image_part_, rId_
        )

    @pytest.fixture
    def image_descriptor_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def image_part_(self, request):
        return instance_mock(request, ImagePart)

    @pytest.fixture
    def image_parts_(self, request, image_part_):
        image_parts_ = instance_mock(request, ImageParts)
        image_parts_.get_or_add_image_part.return_value = image_part_
        return image_parts_

    @pytest.fixture
    def init(self, request):
        return initializer_mock(request, DocumentPart)

    @pytest.fixture
    def InlineShapes_(self, request):
        return class_mock(request, 'docx.parts.document.InlineShapes')

    @pytest.fixture
    def inline_shapes_fixture(self, request, InlineShapes_):
        document_elm = (
            a_document().with_nsdecls().with_child(
                a_body())
        ).element
        body_elm = document_elm[0]
        document = DocumentPart(None, None, document_elm, None)
        return document, InlineShapes_, body_elm

    @pytest.fixture(params=[
        ((), 1), ((1,), 2), ((2,), 1), ((1, 2, 3), 4), ((1, 2, 4), 3),
        ((0, 0), 1), ((0, 0, 1, 3), 2), (('foo', 1, 2), 3), ((1, 'bar'), 2)
    ])
    def next_id_fixture(self, request):
        existing_ids, expected_id = request.param
        document_elm = a_document().with_nsdecls().element
        for n in existing_ids:
            p = a_p().with_nsdecls().element
            p.set('id', str(n))
            document_elm.append(p)
        document = DocumentPart(None, None, document_elm, None)
        return document, expected_id

    @pytest.fixture
    def oxml_fromstring_(self, request):
        return function_mock(request, 'docx.parts.document.oxml_fromstring')

    @pytest.fixture
    def p_(self, request):
        return instance_mock(request, Paragraph)

    @pytest.fixture
    def package_(self, request):
        return instance_mock(request, Package)

    @pytest.fixture
    def paragraphs_(self, request):
        return instance_mock(request, list)

    @pytest.fixture
    def paragraphs_fixture(self, document_part_body_, body_, paragraphs_):
        document_part = DocumentPart(None, None, None, None)
        body_.paragraphs = paragraphs_
        return document_part, paragraphs_

    @pytest.fixture
    def part_load_fixture(
            self, document_part_load_, partname_, blob_, package_,
            document_part_):
        document_part_load_.return_value = document_part_
        return (
            document_part_load_, partname_, blob_, package_, document_part_
        )

    @pytest.fixture
    def partname_(self, request):
        return instance_mock(request, PackURI)

    @pytest.fixture
    def relate_to_(self, request, rId_):
        relate_to_ = method_mock(request, DocumentPart, 'relate_to')
        relate_to_.return_value = rId_
        return relate_to_

    @pytest.fixture
    def rId_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def serialize_part_xml_(self, request):
        return function_mock(
            request, 'docx.parts.document.serialize_part_xml'
        )

    @pytest.fixture
    def table_(self, request):
        return instance_mock(request, Table)

    @pytest.fixture
    def tables_(self, request):
        return instance_mock(request, list)

    @pytest.fixture
    def tables_fixture(self, document_part_body_, body_, tables_):
        document_part = DocumentPart(None, None, None, None)
        body_.tables = tables_
        return document_part, tables_


class Describe_Body(object):

    def it_can_add_a_paragraph(self, add_paragraph_fixture):
        body, expected_xml = add_paragraph_fixture
        p = body.add_paragraph()
        assert body._body.xml == expected_xml
        assert isinstance(p, Paragraph)

    def it_can_add_a_table(self, add_table_fixture):
        body, expected_xml = add_table_fixture
        table = body.add_table(rows=1, cols=1)
        assert body._body.xml == expected_xml
        assert isinstance(table, Table)

    def it_can_clear_itself_of_all_content_it_holds(
            self, clear_content_fixture):
        body, expected_xml = clear_content_fixture
        _body = body.clear_content()
        assert body._body.xml == expected_xml
        assert _body is body

    def it_provides_access_to_the_paragraphs_it_contains(
            self, body_with_paragraphs):
        body = body_with_paragraphs
        paragraphs = body.paragraphs
        assert len(paragraphs) == 2
        for p in paragraphs:
            assert isinstance(p, Paragraph)

    def it_provides_access_to_the_tables_it_contains(
            self, body_with_tables):
        body = body_with_tables
        tables = body.tables
        assert len(tables) == 2
        for table in tables:
            assert isinstance(table, Table)

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (0, False), (1, False), (0, True), (1, True)
    ])
    def add_paragraph_fixture(self, request):
        p_count, has_sectPr = request.param
        # body element -----------------
        body_bldr = self._body_bldr(p_count=p_count, sectPr=has_sectPr)
        body_elm = body_bldr.element
        body = _Body(body_elm)
        # expected XML -----------------
        p_count += 1
        body_bldr = self._body_bldr(p_count=p_count, sectPr=has_sectPr)
        expected_xml = body_bldr.xml()
        return body, expected_xml

    @pytest.fixture(params=[(0, False), (0, True), (1, False), (1, True)])
    def add_table_fixture(self, request):
        p_count, has_sectPr = request.param
        body_bldr = self._body_bldr(p_count=p_count, sectPr=has_sectPr)
        body = _Body(body_bldr.element)

        tbl_bldr = self._tbl_bldr()
        body_bldr = self._body_bldr(
            p_count=p_count, tbl_bldr=tbl_bldr, sectPr=has_sectPr
        )
        expected_xml = body_bldr.xml()

        return body, expected_xml

    @pytest.fixture
    def body_with_paragraphs(self):
        body_elm = (
            a_body().with_nsdecls()
                    .with_child(a_p())
                    .with_child(a_p())
                    .element
        )
        return _Body(body_elm)

    @pytest.fixture
    def body_with_tables(self):
        body_elm = (
            a_body().with_nsdecls()
                    .with_child(a_tbl())
                    .with_child(a_tbl())
                    .element
        )
        return _Body(body_elm)

    @pytest.fixture(params=[False, True])
    def clear_content_fixture(self, request):
        has_sectPr = request.param
        # body element -----------------
        body_bldr = a_body().with_nsdecls()
        body_bldr.with_child(a_p())
        if has_sectPr:
            body_bldr.with_child(a_sectPr())
        body_elm = body_bldr.element
        body = _Body(body_elm)
        # expected XML -----------------
        body_bldr = a_body().with_nsdecls()
        if has_sectPr:
            body_bldr.with_child(a_sectPr())
        expected_xml = body_bldr.xml()
        return body, expected_xml

    def _body_bldr(self, p_count=0, tbl_bldr=None, sectPr=False):
        body_bldr = a_body().with_nsdecls()
        for i in range(p_count):
            body_bldr.with_child(a_p())
        if tbl_bldr is not None:
            body_bldr.with_child(tbl_bldr)
        if sectPr:
            body_bldr.with_child(a_sectPr())
        return body_bldr

    def _tbl_bldr(self, rows=1, cols=1):
        tblPr_bldr = a_tblPr()

        tblGrid_bldr = a_tblGrid()
        for i in range(cols):
            tblGrid_bldr.with_child(a_gridCol())

        tbl_bldr = a_tbl()
        tbl_bldr.with_child(tblPr_bldr)
        tbl_bldr.with_child(tblGrid_bldr)
        for i in range(rows):
            tr_bldr = self._tr_bldr(cols)
            tbl_bldr.with_child(tr_bldr)

        return tbl_bldr

    def _tc_bldr(self):
        return a_tc().with_child(a_p())

    def _tr_bldr(self, cols):
        tr_bldr = a_tr()
        for i in range(cols):
            tc_bldr = self._tc_bldr()
            tr_bldr.with_child(tc_bldr)
        return tr_bldr


class DescribeInlineShapes(object):

    def it_knows_how_many_inline_shapes_it_contains(
            self, inline_shapes_fixture):
        inline_shapes, inline_shape_count = inline_shapes_fixture
        assert len(inline_shapes) == inline_shape_count

    def it_can_iterate_over_its_InlineShape_instances(
            self, inline_shapes_fixture):
        inline_shapes, inline_shape_count = inline_shapes_fixture
        actual_count = 0
        for inline_shape in inline_shapes:
            assert isinstance(inline_shape, InlineShape)
            actual_count += 1
        assert actual_count == inline_shape_count

    def it_provides_indexed_access_to_inline_shapes(
            self, inline_shapes_fixture):
        inline_shapes, inline_shape_count = inline_shapes_fixture
        for idx in range(-inline_shape_count, inline_shape_count):
            inline_shape = inline_shapes[idx]
            assert isinstance(inline_shape, InlineShape)

    def it_raises_on_indexed_access_out_of_range(
            self, inline_shapes_fixture):
        inline_shapes, inline_shape_count = inline_shapes_fixture
        with pytest.raises(IndexError):
            too_low = -1 - inline_shape_count
            inline_shapes[too_low]
        with pytest.raises(IndexError):
            too_high = inline_shape_count
            inline_shapes[too_high]

    def it_can_add_an_inline_picture_to_the_document(
            self, add_picture_fixture):
        # fixture ----------------------
        (inline_shapes, image_descriptor_, document_, InlineShape_,
         r_, image_part_, rId_, shape_id_, new_picture_shape_
         ) = add_picture_fixture
        # exercise ---------------------
        picture_shape = inline_shapes.add_picture(image_descriptor_)
        # verify -----------------------
        document_.get_or_add_image_part.assert_called_once_with(
            image_descriptor_
        )
        InlineShape_.new_picture.assert_called_once_with(
            r_, image_part_, rId_, shape_id_
        )
        assert picture_shape is new_picture_shape_

    def it_knows_the_part_it_belongs_to(self, inline_shapes_with_parent_):
        inline_shapes, parent_ = inline_shapes_with_parent_
        part = inline_shapes.part
        assert part is parent_.part

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def add_picture_fixture(
            self, request, body_, document_, image_descriptor_, InlineShape_,
            r_, image_part_, rId_, shape_id_, new_picture_shape_):
        inline_shapes = InlineShapes(body_, None)
        property_mock(request, InlineShapes, 'part', return_value=document_)
        return (
            inline_shapes, image_descriptor_, document_, InlineShape_, r_,
            image_part_, rId_, shape_id_, new_picture_shape_
        )

    @pytest.fixture
    def body_(self, request, r_):
        body_ = instance_mock(request, CT_Body)
        body_.add_p.return_value.add_r.return_value = r_
        return body_

    @pytest.fixture
    def document_(self, request, rId_, image_part_, shape_id_):
        document_ = instance_mock(request, DocumentPart, name='document_')
        document_.get_or_add_image_part.return_value = image_part_, rId_
        document_.next_id = shape_id_
        return document_

    @pytest.fixture
    def image_part_(self, request):
        return instance_mock(request, ImagePart)

    @pytest.fixture
    def image_descriptor_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def InlineShape_(self, request, new_picture_shape_):
        InlineShape_ = class_mock(request, 'docx.parts.document.InlineShape')
        InlineShape_.new_picture.return_value = new_picture_shape_
        return InlineShape_

    @pytest.fixture
    def inline_shapes_fixture(self):
        inline_shape_count = 2
        body = (
            a_body().with_nsdecls('w', 'wp').with_child(
                a_p().with_child(
                    an_r().with_child(
                        a_drawing().with_child(
                            an_inline()))).with_child(
                    an_r().with_child(
                        a_drawing().with_child(
                            an_inline())
                    )
                )
            )
        ).element
        inline_shapes = InlineShapes(body, None)
        return inline_shapes, inline_shape_count

    @pytest.fixture
    def inline_shapes_with_parent_(self, request):
        parent_ = loose_mock(request, name='parent_')
        inline_shapes = InlineShapes(None, parent_)
        return inline_shapes, parent_

    @pytest.fixture
    def new_picture_shape_(self, request):
        return instance_mock(request, InlineShape)

    @pytest.fixture
    def r_(self, request):
        return instance_mock(request, CT_R)

    @pytest.fixture
    def rId_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def shape_id_(self, request):
        return instance_mock(request, int)

########NEW FILE########
__FILENAME__ = test_image
# encoding: utf-8

"""
Test suite for docx.parts.image module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from docx.image.image import Image
from docx.opc.constants import CONTENT_TYPE as CT, RELATIONSHIP_TYPE as RT
from docx.opc.package import PartFactory
from docx.opc.packuri import PackURI
from docx.package import Package
from docx.parts.image import ImagePart

from ..unitutil import (
    initializer_mock, instance_mock, method_mock, test_file
)


class DescribeImagePart(object):

    def it_is_used_by_PartFactory_to_construct_image_part(self, load_fixture):
        # fixture ----------------------
        image_part_load_, partname_, blob_, package_, image_part_ = (
            load_fixture
        )
        content_type = CT.JPEG
        reltype = RT.IMAGE
        # exercise ---------------------
        part = PartFactory(partname_, content_type, reltype, blob_, package_)
        # verify -----------------------
        image_part_load_.assert_called_once_with(
            partname_, content_type, blob_, package_
        )
        assert part is image_part_

    def it_can_construct_from_an_Image_instance(self, from_image_fixture):
        image_, partname_, ImagePart__init__ = from_image_fixture
        image_part = ImagePart.from_image(image_, partname_)
        ImagePart__init__.assert_called_once_with(
            partname_, image_.content_type, image_.blob, image_
        )
        assert isinstance(image_part, ImagePart)

    def it_knows_its_default_dimensions_in_EMU(self, dimensions_fixture):
        image_part, cx, cy = dimensions_fixture
        assert image_part.default_cx == cx
        assert image_part.default_cy == cy

    def it_knows_its_filename(self, filename_fixture):
        image_part, expected_filename = filename_fixture
        assert image_part.filename == expected_filename

    def it_knows_the_sha1_of_its_image(self):
        blob = b'fO0Bar'
        image_part = ImagePart(None, None, blob)
        assert image_part.sha1 == '4921e7002ddfba690a937d54bda226a7b8bdeb68'

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def blob_(self, request):
        return instance_mock(request, str)

    @pytest.fixture(params=['loaded', 'new'])
    def dimensions_fixture(self, request):
        image_file_path = test_file('monty-truth.png')
        image = Image.from_file(image_file_path)
        expected_cx, expected_cy = 1905000, 2717800

        # case 1: image part is loaded by PartFactory w/no Image inst
        if request.param == 'loaded':
            partname = PackURI('/word/media/image1.png')
            content_type = CT.PNG
            image_part = ImagePart.load(
                partname, content_type, image.blob, None
            )
        # case 2: image part is newly created from image file
        elif request.param == 'new':
            image_part = ImagePart.from_image(image, None)

        return image_part, expected_cx, expected_cy

    @pytest.fixture(params=['loaded', 'new'])
    def filename_fixture(self, request, image_):
        partname = PackURI('/word/media/image666.png')
        if request.param == 'loaded':
            image_part = ImagePart(partname, None, None, None)
            expected_filename = 'image.png'
        elif request.param == 'new':
            image_.filename = 'foobar.PXG'
            image_part = ImagePart(partname, None, None, image_)
            expected_filename = image_.filename
        return image_part, expected_filename

    @pytest.fixture
    def from_image_fixture(self, image_, partname_, ImagePart__init__):
        return image_, partname_, ImagePart__init__

    @pytest.fixture
    def image_(self, request):
        return instance_mock(request, Image)

    @pytest.fixture
    def ImagePart__init__(self, request):
        return initializer_mock(request, ImagePart)

    @pytest.fixture
    def image_part_(self, request):
        return instance_mock(request, ImagePart)

    @pytest.fixture
    def image_part_load_(self, request, image_part_):
        return method_mock(
            request, ImagePart, 'load', return_value=image_part_
        )

    @pytest.fixture
    def load_fixture(
            self, image_part_load_, partname_, blob_, package_, image_part_):
        return image_part_load_, partname_, blob_, package_, image_part_

    @pytest.fixture
    def package_(self, request):
        return instance_mock(request, Package)

    @pytest.fixture
    def partname_(self, request):
        return instance_mock(request, PackURI)

########NEW FILE########
__FILENAME__ = test_numbering
# encoding: utf-8

"""
Test suite for the docx.parts.numbering module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from docx.opc.constants import CONTENT_TYPE as CT, RELATIONSHIP_TYPE as RT
from docx.opc.package import PartFactory
from docx.opc.packuri import PackURI
from docx.oxml.parts.numbering import CT_Numbering
from docx.package import Package
from docx.parts.numbering import NumberingPart, _NumberingDefinitions

from ..oxml.unitdata.numbering import a_num, a_numbering
from ..unitutil import (
    function_mock, class_mock, initializer_mock, instance_mock, method_mock
)


class DescribeNumberingPart(object):

    def it_is_used_by_PartFactory_to_construct_numbering_part(
            self, load_fixture):
        # fixture ----------------------
        numbering_part_load_, partname_, blob_, package_, numbering_part_ = (
            load_fixture
        )
        content_type, reltype = CT.WML_NUMBERING, RT.NUMBERING
        # exercise ---------------------
        part = PartFactory(partname_, content_type, reltype, blob_, package_)
        # verify -----------------------
        numbering_part_load_.assert_called_once_with(
            partname_, content_type, blob_, package_
        )
        assert part is numbering_part_

    def it_can_be_constructed_by_opc_part_factory(self, construct_fixture):
        (partname_, content_type_, blob_, package_, oxml_fromstring_,
         init__, numbering_elm_) = construct_fixture
        # exercise ---------------------
        numbering_part = NumberingPart.load(
            partname_, content_type_, blob_, package_
        )
        # verify -----------------------
        oxml_fromstring_.assert_called_once_with(blob_)
        init__.assert_called_once_with(
            partname_, content_type_, numbering_elm_, package_
        )
        assert isinstance(numbering_part, NumberingPart)

    def it_provides_access_to_the_numbering_definitions(
            self, num_defs_fixture):
        (numbering_part, _NumberingDefinitions_, numbering_elm_,
         numbering_definitions_) = num_defs_fixture
        numbering_definitions = numbering_part.numbering_definitions
        _NumberingDefinitions_.assert_called_once_with(numbering_elm_)
        assert numbering_definitions is numbering_definitions_

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def blob_(self, request):
        return instance_mock(request, bytes)

    @pytest.fixture
    def construct_fixture(
            self, partname_, content_type_, blob_, package_,
            oxml_fromstring_, init__, numbering_elm_):
        return (
            partname_, content_type_, blob_, package_, oxml_fromstring_,
            init__, numbering_elm_
        )

    @pytest.fixture
    def content_type_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def init__(self, request):
        return initializer_mock(request, NumberingPart)

    @pytest.fixture
    def load_fixture(
            self, numbering_part_load_, partname_, blob_, package_,
            numbering_part_):
        numbering_part_load_.return_value = numbering_part_
        return (
            numbering_part_load_, partname_, blob_, package_, numbering_part_
        )

    @pytest.fixture
    def _NumberingDefinitions_(self, request, numbering_definitions_):
        return class_mock(
            request, 'docx.parts.numbering._NumberingDefinitions',
            return_value=numbering_definitions_
        )

    @pytest.fixture
    def num_defs_fixture(
            self, _NumberingDefinitions_, numbering_elm_,
            numbering_definitions_):
        numbering_part = NumberingPart(None, None, numbering_elm_, None)
        return (
            numbering_part, _NumberingDefinitions_, numbering_elm_,
            numbering_definitions_
        )

    @pytest.fixture
    def numbering_definitions_(self, request):
        return instance_mock(request, _NumberingDefinitions)

    @pytest.fixture
    def numbering_elm_(self, request):
        return instance_mock(request, CT_Numbering)

    @pytest.fixture
    def numbering_part_(self, request):
        return instance_mock(request, NumberingPart)

    @pytest.fixture
    def numbering_part_load_(self, request):
        return method_mock(request, NumberingPart, 'load')

    @pytest.fixture
    def oxml_fromstring_(self, request, numbering_elm_):
        return function_mock(
            request, 'docx.parts.numbering.oxml_fromstring',
            return_value=numbering_elm_
        )

    @pytest.fixture
    def package_(self, request):
        return instance_mock(request, Package)

    @pytest.fixture
    def partname_(self, request):
        return instance_mock(request, PackURI)


class Describe_NumberingDefinitions(object):

    def it_knows_how_many_numbering_definitions_it_contains(
            self, len_fixture):
        numbering_definitions, numbering_definition_count = len_fixture
        assert len(numbering_definitions) == numbering_definition_count

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[0, 1, 2, 3])
    def len_fixture(self, request):
        numbering_definition_count = request.param
        numbering_bldr = a_numbering().with_nsdecls()
        for idx in range(numbering_definition_count):
            numbering_bldr.with_child(a_num())
        numbering_elm = numbering_bldr.element
        numbering_definitions = _NumberingDefinitions(numbering_elm)
        return numbering_definitions, numbering_definition_count

########NEW FILE########
__FILENAME__ = test_styles
# encoding: utf-8

"""
Test suite for the docx.parts.styles module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from docx.opc.constants import CONTENT_TYPE as CT, RELATIONSHIP_TYPE as RT
from docx.opc.package import PartFactory
from docx.opc.packuri import PackURI
from docx.oxml.parts.styles import CT_Styles
from docx.package import Package
from docx.parts.styles import StylesPart, _Styles

from ..oxml.unitdata.styles import a_style, a_styles
from ..unitutil import (
    function_mock, class_mock, initializer_mock, instance_mock, method_mock
)


class DescribeStylesPart(object):

    def it_is_used_by_PartFactory_to_construct_styles_part(
            self, load_fixture):
        # fixture ----------------------
        styles_part_load_, partname_, blob_, package_, styles_part_ = (
            load_fixture
        )
        content_type, reltype = CT.WML_STYLES, RT.STYLES
        # exercise ---------------------
        part = PartFactory(partname_, content_type, reltype, blob_, package_)
        # verify -----------------------
        styles_part_load_.assert_called_once_with(
            partname_, content_type, blob_, package_
        )
        assert part is styles_part_

    def it_can_be_constructed_by_opc_part_factory(self, construct_fixture):
        (partname_, content_type_, blob_, package_, oxml_fromstring_,
         init__, styles_elm_) = construct_fixture
        # exercise ---------------------
        styles_part = StylesPart.load(
            partname_, content_type_, blob_, package_
        )
        # verify -----------------------
        oxml_fromstring_.assert_called_once_with(blob_)
        init__.assert_called_once_with(
            partname_, content_type_, styles_elm_, package_
        )
        assert isinstance(styles_part, StylesPart)

    def it_provides_access_to_the_styles(self, styles_fixture):
        styles_part, _Styles_, styles_elm_, styles_ = styles_fixture
        styles = styles_part.styles
        _Styles_.assert_called_once_with(styles_elm_)
        assert styles is styles_

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def blob_(self, request):
        return instance_mock(request, bytes)

    @pytest.fixture
    def construct_fixture(
            self, partname_, content_type_, blob_, package_,
            oxml_fromstring_, init__, styles_elm_):
        return (
            partname_, content_type_, blob_, package_, oxml_fromstring_,
            init__, styles_elm_
        )

    @pytest.fixture
    def content_type_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def init__(self, request):
        return initializer_mock(request, StylesPart)

    @pytest.fixture
    def load_fixture(
            self, styles_part_load_, partname_, blob_, package_,
            styles_part_):
        styles_part_load_.return_value = styles_part_
        return (
            styles_part_load_, partname_, blob_, package_, styles_part_
        )

    @pytest.fixture
    def oxml_fromstring_(self, request, styles_elm_):
        return function_mock(
            request, 'docx.parts.styles.oxml_fromstring',
            return_value=styles_elm_
        )

    @pytest.fixture
    def package_(self, request):
        return instance_mock(request, Package)

    @pytest.fixture
    def partname_(self, request):
        return instance_mock(request, PackURI)

    @pytest.fixture
    def _Styles_(self, request, styles_):
        return class_mock(
            request, 'docx.parts.styles._Styles', return_value=styles_
        )

    @pytest.fixture
    def styles_(self, request):
        return instance_mock(request, _Styles)

    @pytest.fixture
    def styles_elm_(self, request):
        return instance_mock(request, CT_Styles)

    @pytest.fixture
    def styles_fixture(self, _Styles_, styles_elm_, styles_):
        styles_part = StylesPart(None, None, styles_elm_, None)
        return styles_part, _Styles_, styles_elm_, styles_

    @pytest.fixture
    def styles_part_(self, request):
        return instance_mock(request, StylesPart)

    @pytest.fixture
    def styles_part_load_(self, request):
        return method_mock(request, StylesPart, 'load')


class Describe_Styles(object):

    def it_knows_how_many_styles_it_contains(self, len_fixture):
        styles, style_count = len_fixture
        assert len(styles) == style_count

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[0, 1, 2, 3])
    def len_fixture(self, request):
        style_count = request.param
        styles_bldr = a_styles().with_nsdecls()
        for idx in range(style_count):
            styles_bldr.with_child(a_style())
        styles_elm = styles_bldr.element
        styles = _Styles(styles_elm)
        return styles, style_count

########NEW FILE########
__FILENAME__ = test_api
# encoding: utf-8

"""
Test suite for the docx.api module
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

import pytest

from docx.api import Document
from docx.enum.text import WD_BREAK
from docx.opc.constants import CONTENT_TYPE as CT, RELATIONSHIP_TYPE as RT
from docx.package import Package
from docx.parts.document import DocumentPart, InlineShapes
from docx.parts.numbering import NumberingPart
from docx.parts.styles import StylesPart
from docx.table import Table
from docx.text import Paragraph, Run

from .unitutil import (
    instance_mock, class_mock, method_mock, property_mock, var_mock
)


class DescribeDocument(object):

    def it_opens_a_docx_on_construction(self, init_fixture):
        docx_, open_ = init_fixture
        document = Document(docx_)
        open_.assert_called_once_with(docx_)
        assert isinstance(document, Document)

    def it_can_open_a_docx_file(self, open_fixture):
        docx_, Package_, package_, document_part_ = open_fixture
        document_part, package = Document._open(docx_)
        Package_.open.assert_called_once_with(docx_)
        assert document_part is document_part
        assert package is package_

    def it_opens_default_template_if_no_file_provided(
            self, Package_, default_docx_):
        Document._open(None)
        Package_.open.assert_called_once_with(default_docx_)

    def it_should_raise_if_not_a_Word_file(self, Package_, package_, docx_):
        package_.main_document.content_type = 'foobar'
        with pytest.raises(ValueError):
            Document._open(docx_)

    def it_can_add_a_heading(self, add_heading_fixture):
        document, add_paragraph_, p_, text, level, style = add_heading_fixture
        p = document.add_heading(text, level)
        add_paragraph_.assert_called_once_with(text, style)
        assert p is p_

    def it_should_raise_on_heading_level_out_of_range(self, document):
        with pytest.raises(ValueError):
            document.add_heading(level=-1)
        with pytest.raises(ValueError):
            document.add_heading(level=10)

    def it_can_add_an_empty_paragraph(self, add_empty_paragraph_fixture):
        document, document_part_, p_ = add_empty_paragraph_fixture
        p = document.add_paragraph()
        document_part_.add_paragraph.assert_called_once_with()
        assert p is p_

    def it_can_add_a_paragraph_of_text(self, add_text_paragraph_fixture):
        document, text, p_, r_ = add_text_paragraph_fixture
        p = document.add_paragraph(text)
        p.add_run.assert_called_once_with()
        r_.add_text.assert_called_once_with(text)

    def it_can_add_a_styled_paragraph(self, add_styled_paragraph_fixture):
        document, style, p_ = add_styled_paragraph_fixture
        p = document.add_paragraph(style=style)
        assert p.style == style

    def it_can_add_a_page_break(self, add_page_break_fixture):
        document, document_part_, p_, r_ = add_page_break_fixture
        p = document.add_page_break()
        document_part_.add_paragraph.assert_called_once_with()
        p_.add_run.assert_called_once_with()
        r_.add_break.assert_called_once_with(WD_BREAK.PAGE)
        assert p is p_

    def it_can_add_a_picture(self, add_picture_fixture):
        (document, image_path, width, height, inline_shapes_, expected_width,
         expected_height, picture_) = add_picture_fixture
        picture = document.add_picture(image_path, width, height)
        inline_shapes_.add_picture.assert_called_once_with(image_path)
        assert picture.width == expected_width
        assert picture.height == expected_height
        assert picture is picture_

    def it_can_add_a_table(self, add_table_fixture):
        document, rows, cols, style, document_part_, expected_style, table_ = (
            add_table_fixture
        )
        table = document.add_table(rows, cols, style)
        document_part_.add_table.assert_called_once_with(rows, cols)
        assert table.style == expected_style
        assert table == table_

    def it_provides_access_to_the_document_inline_shapes(self, document):
        body = document.inline_shapes
        assert body is document._document_part.inline_shapes

    def it_provides_access_to_the_document_paragraphs(
            self, paragraphs_fixture):
        document, paragraphs_ = paragraphs_fixture
        paragraphs = document.paragraphs
        assert paragraphs is paragraphs_

    def it_provides_access_to_the_document_tables(self, tables_fixture):
        document, tables_ = tables_fixture
        tables = document.tables
        assert tables is tables_

    def it_can_save_the_package(self, save_fixture):
        document, package_, file_ = save_fixture
        document.save(file_)
        package_.save.assert_called_once_with(file_)

    def it_provides_access_to_the_numbering_part(self, num_part_get_fixture):
        document, document_part_, numbering_part_ = num_part_get_fixture
        numbering_part = document.numbering_part
        document_part_.part_related_by.assert_called_once_with(RT.NUMBERING)
        assert numbering_part is numbering_part_

    def it_creates_numbering_part_on_first_access_if_not_present(
            self, num_part_create_fixture):
        document, NumberingPart_, document_part_, numbering_part_ = (
            num_part_create_fixture
        )
        numbering_part = document.numbering_part
        NumberingPart_.new.assert_called_once_with()
        document_part_.relate_to.assert_called_once_with(
            numbering_part_, RT.NUMBERING
        )
        assert numbering_part is numbering_part_

    def it_provides_access_to_the_styles_part(self, styles_part_get_fixture):
        document, document_part_, styles_part_ = styles_part_get_fixture
        styles_part = document.styles_part
        document_part_.part_related_by.assert_called_once_with(RT.STYLES)
        assert styles_part is styles_part_

    def it_creates_styles_part_on_first_access_if_not_present(
            self, styles_part_create_fixture):
        document, StylesPart_, document_part_, styles_part_ = (
            styles_part_create_fixture
        )
        styles_part = document.styles_part
        StylesPart_.new.assert_called_once_with()
        document_part_.relate_to.assert_called_once_with(
            styles_part_, RT.STYLES
        )
        assert styles_part is styles_part_

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[0, 1, 2, 5, 9])
    def add_heading_fixture(self, request, document, add_paragraph_, p_):
        level = request.param
        text = 'Spam vs. Bacon'
        style = 'Title' if level == 0 else 'Heading%d' % level
        return document, add_paragraph_, p_, text, level, style

    @pytest.fixture
    def add_empty_paragraph_fixture(self, document, document_part_, p_):
        return document, document_part_, p_

    @pytest.fixture
    def add_page_break_fixture(self, document, document_part_, p_, r_):
        return document, document_part_, p_, r_

    @pytest.fixture
    def add_paragraph_(self, request, p_):
        return method_mock(
            request, Document, 'add_paragraph', return_value=p_
        )

    @pytest.fixture(params=[
        (None, None,  200,  100),
        (1000, 500,  1000,  500),
        (2000, None, 2000, 1000),
        (None, 2000, 4000, 2000),
    ])
    def add_picture_fixture(
            self, request, Document_inline_shapes_, inline_shapes_):
        width, height, expected_width, expected_height = request.param
        document = Document()
        image_path_ = instance_mock(request, str, name='image_path_')
        picture_ = inline_shapes_.add_picture.return_value
        picture_.width, picture_.height = 200, 100
        return (
            document, image_path_, width, height, inline_shapes_,
            expected_width, expected_height, picture_
        )

    @pytest.fixture
    def add_styled_paragraph_fixture(self, document, p_):
        style = 'foobaresque'
        return document, style, p_

    @pytest.fixture(params=[None, 'LightShading-Accent1', 'foobar'])
    def add_table_fixture(self, request, document, document_part_, table_):
        rows, cols = 4, 2
        style = expected_style = request.param
        return (
            document, rows, cols, style, document_part_, expected_style,
            table_
        )

    @pytest.fixture
    def add_text_paragraph_fixture(self, document, p_, r_):
        text = 'foobar\rbarfoo'
        return document, text, p_, r_

    @pytest.fixture
    def default_docx_(self, request):
        return var_mock(request, 'docx.api._default_docx_path')

    @pytest.fixture
    def Document_inline_shapes_(self, request, inline_shapes_):
        return property_mock(
            request, Document, 'inline_shapes', return_value=inline_shapes_
        )

    @pytest.fixture
    def document(self, open_):
        return Document()

    @pytest.fixture
    def document_part_(self, request, p_, paragraphs_, table_, tables_):
        document_part_ = instance_mock(
            request, DocumentPart, content_type=CT.WML_DOCUMENT_MAIN
        )
        document_part_.add_paragraph.return_value = p_
        document_part_.add_table.return_value = table_
        document_part_.paragraphs = paragraphs_
        document_part_.tables = tables_
        return document_part_

    @pytest.fixture
    def docx_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def init_fixture(self, docx_, open_):
        return docx_, open_

    @pytest.fixture
    def inline_shapes_(self, request):
        return instance_mock(request, InlineShapes)

    @pytest.fixture
    def num_part_create_fixture(
            self, document, NumberingPart_, document_part_, numbering_part_):
        document_part_.part_related_by.side_effect = KeyError
        return document, NumberingPart_, document_part_, numbering_part_

    @pytest.fixture
    def num_part_get_fixture(self, document, document_part_, numbering_part_):
        document_part_.part_related_by.return_value = numbering_part_
        return document, document_part_, numbering_part_

    @pytest.fixture
    def NumberingPart_(self, request, numbering_part_):
        NumberingPart_ = class_mock(request, 'docx.api.NumberingPart')
        NumberingPart_.new.return_value = numbering_part_
        return NumberingPart_

    @pytest.fixture
    def numbering_part_(self, request):
        return instance_mock(request, NumberingPart)

    @pytest.fixture
    def open_(self, request, document_part_, package_):
        return method_mock(
            request, Document, '_open',
            return_value=(document_part_, package_)
        )

    @pytest.fixture
    def open_fixture(self, docx_, Package_, package_, document_part_):
        return docx_, Package_, package_, document_part_

    @pytest.fixture
    def p_(self, request, r_):
        p_ = instance_mock(request, Paragraph)
        p_.add_run.return_value = r_
        return p_

    @pytest.fixture
    def Package_(self, request, package_):
        Package_ = class_mock(request, 'docx.api.Package')
        Package_.open.return_value = package_
        return Package_

    @pytest.fixture
    def package_(self, request, document_part_):
        package_ = instance_mock(request, Package)
        package_.main_document = document_part_
        return package_

    @pytest.fixture
    def paragraphs_(self, request):
        return instance_mock(request, list)

    @pytest.fixture
    def paragraphs_fixture(self, document, paragraphs_):
        return document, paragraphs_

    @pytest.fixture
    def r_(self, request):
        return instance_mock(request, Run)

    @pytest.fixture
    def save_fixture(self, request, open_, package_):
        file_ = instance_mock(request, str)
        document = Document()
        return document, package_, file_

    @pytest.fixture
    def StylesPart_(self, request, styles_part_):
        StylesPart_ = class_mock(request, 'docx.api.StylesPart')
        StylesPart_.new.return_value = styles_part_
        return StylesPart_

    @pytest.fixture
    def styles_part_(self, request):
        return instance_mock(request, StylesPart)

    @pytest.fixture
    def styles_part_create_fixture(
            self, document, StylesPart_, document_part_, styles_part_):
        document_part_.part_related_by.side_effect = KeyError
        return document, StylesPart_, document_part_, styles_part_

    @pytest.fixture
    def styles_part_get_fixture(self, document, document_part_, styles_part_):
        document_part_.part_related_by.return_value = styles_part_
        return document, document_part_, styles_part_

    @pytest.fixture
    def table_(self, request):
        return instance_mock(request, Table, style=None)

    @pytest.fixture
    def tables_(self, request):
        return instance_mock(request, list)

    @pytest.fixture
    def tables_fixture(self, document, tables_):
        return document, tables_

########NEW FILE########
__FILENAME__ = test_package
# encoding: utf-8

"""
Test suite for docx.package module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from docx.image.image import Image
from docx.opc.packuri import PackURI
from docx.package import ImageParts, Package
from docx.parts.image import ImagePart

from .unitutil import (
    docx_path, class_mock, instance_mock, method_mock
)


class DescribePackage(object):

    def it_gathers_package_image_parts_after_unmarshalling(self):
        package = Package.open(docx_path('having-images'))
        image_parts = package.image_parts
        assert len(image_parts) == 3
        for image_part in image_parts:
            assert isinstance(image_part, ImagePart)


class DescribeImageParts(object):

    def it_can_get_a_matching_image_part(self, get_image_part_fixture):
        image_parts, image_descriptor, image_part_ = get_image_part_fixture
        image_part = image_parts.get_or_add_image_part(image_descriptor)
        assert image_part is image_part_

    def it_can_add_a_new_image_part(self, add_image_part_fixture):
        image_parts, image_descriptor, image_, image_part_ = (
            add_image_part_fixture
        )
        image_part = image_parts.get_or_add_image_part(image_descriptor)
        image_parts._add_image_part.assert_called_once_with(image_)
        assert image_part is image_part_

    def it_knows_the_next_available_image_partname(
            self, next_partname_fixture):
        image_parts, ext, expected_partname = next_partname_fixture
        assert image_parts._next_image_partname(ext) == expected_partname

    def it_can_really_add_a_new_image_part(
            self, really_add_image_part_fixture):
        image_parts, image_, ImagePart_, partname_, image_part_ = (
            really_add_image_part_fixture
        )
        image_part = image_parts._add_image_part(image_)
        ImagePart_.from_image.assert_called_once_with(image_, partname_)
        assert image_part in image_parts
        assert image_part is image_part_

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def _add_image_part_(self, request, new_image_part_):
        return method_mock(
            request, ImageParts, '_add_image_part',
            return_value=new_image_part_
        )

    @pytest.fixture
    def add_image_part_fixture(
            self, Image_, _add_image_part_, image_descriptor_, image_,
            new_image_part_,):
        image_parts = ImageParts()
        return image_parts, image_descriptor_, image_, new_image_part_

    @pytest.fixture
    def get_image_part_fixture(self, Image_, image_part_, image_descriptor_):
        image_parts = ImageParts()
        image_parts.append(image_part_)
        return image_parts, image_descriptor_, image_part_

    @pytest.fixture
    def Image_(self, request, image_):
        Image_ = class_mock(request, 'docx.package.Image')
        Image_.from_file.return_value = image_
        return Image_

    @pytest.fixture
    def image_(self, request, sha1):
        image_ = instance_mock(request, Image)
        image_.sha1 = sha1
        return image_

    @pytest.fixture
    def image_descriptor_(self, request):
        return instance_mock(request, str)

    @pytest.fixture
    def ImagePart_(self, request, image_part_):
        ImagePart_ = class_mock(request, 'docx.package.ImagePart')
        ImagePart_.from_image.return_value = image_part_
        return ImagePart_

    @pytest.fixture
    def image_part_(self, request, sha1):
        image_part_ = instance_mock(request, ImagePart)
        image_part_.sha1 = sha1
        return image_part_

    def _image_part_with_partname_(self, request, n):
        partname = self._image_partname(n)
        return instance_mock(request, ImagePart, partname=partname)

    def _image_partname(self, n):
        return PackURI('/word/media/image%d.png' % n)

    @pytest.fixture
    def new_image_part_(self, request):
        return instance_mock(request, ImagePart)

    @pytest.fixture
    def _next_image_partname_(self, request):
        return method_mock(request, ImageParts, '_next_image_partname')

    @pytest.fixture(params=[((2, 3), 1), ((1, 3), 2), ((1, 2), 3)])
    def next_partname_fixture(self, request):
        existing_partname_numbers, expected_partname_number = request.param
        image_parts = ImageParts()
        for n in existing_partname_numbers:
            image_part_ = self._image_part_with_partname_(request, n)
            image_parts.append(image_part_)
        ext = 'png'
        expected_image_partname = self._image_partname(
            expected_partname_number
        )
        return image_parts, ext, expected_image_partname

    @pytest.fixture
    def partname_(self, request):
        return instance_mock(request, PackURI)

    @pytest.fixture
    def really_add_image_part_fixture(
            self, _next_image_partname_, partname_, image_, ImagePart_,
            image_part_):
        image_parts = ImageParts()
        _next_image_partname_.return_value = partname_
        return image_parts, image_, ImagePart_, partname_, image_part_

    @pytest.fixture
    def sha1(self):
        return 'F008AH'

########NEW FILE########
__FILENAME__ = test_shape
# encoding: utf-8

"""
Test suite for the docx.shape module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from docx.enum.shape import WD_INLINE_SHAPE
from docx.oxml.shared import nsmap
from docx.parts.image import ImagePart
from docx.shape import InlineShape
from docx.shared import Length

from .oxml.unitdata.dml import (
    a_blip, a_blipFill, a_cNvPr, a_cNvPicPr, a_docPr, a_fillRect, a_graphic,
    a_graphicData, a_pic, a_prstGeom, a_stretch, an_ext, an_extent,
    an_inline, an_nvPicPr, an_off, an_spPr, an_xfrm
)
from .oxml.unitdata.text import an_r
from .unitutil import instance_mock


class DescribeInlineShape(object):

    def it_knows_what_type_of_shape_it_is(self, shape_type_fixture):
        inline_shape, inline_shape_type = shape_type_fixture
        assert inline_shape.type == inline_shape_type

    def it_can_contruct_a_new_inline_picture_shape(
            self, new_picture_fixture):
        inline_shape, r, image_part_, rId, shape_id, expected_inline_xml = (
            new_picture_fixture
        )
        picture = inline_shape.new_picture(r, image_part_, rId, shape_id)
        assert picture._inline.xml == expected_inline_xml
        assert r[0][0] is picture._inline

    def it_knows_its_display_dimensions(self, dimensions_get_fixture):
        inline_shape, cx, cy = dimensions_get_fixture
        width = inline_shape.width
        height = inline_shape.height
        assert isinstance(width, Length)
        assert width == cx
        assert isinstance(height, Length)
        assert height == cy

    def it_can_change_its_display_dimensions(self, dimensions_set_fixture):
        inline_shape, cx, cy, expected_xml = dimensions_set_fixture
        inline_shape.width = cx
        inline_shape.height = cy
        assert inline_shape._inline.xml == expected_xml

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def dimensions_get_fixture(self):
        cx, cy = 333, 666
        inline = self._inline_bldr_with_dimensions(cx, cy).element
        inline_shape = InlineShape(inline)
        return inline_shape, cx, cy

    @pytest.fixture
    def dimensions_set_fixture(self):
        # inline_shape -----------------
        cx, cy = 333, 666
        inline = self._inline_bldr_with_dimensions(cx, cy).element
        inline_shape = InlineShape(inline)
        # expected_xml -----------------
        cx, cy = cx + 111, cy + 222
        expected_xml = self._inline_bldr_with_dimensions(cx, cy).xml()
        return inline_shape, cx, cy, expected_xml

    @pytest.fixture
    def image_params(self):
        filename = 'foobar.garf'
        rId = 'rId42'
        cx, cy = 914422, 223344
        return filename, rId, cx, cy

    @pytest.fixture
    def image_part_(self, request, image_params):
        filename, rId, cx, cy = image_params
        image_part_ = instance_mock(request, ImagePart)
        image_part_.default_cx = cx
        image_part_.default_cy = cy
        image_part_.filename = filename
        return image_part_

    @pytest.fixture
    def new_picture_fixture(self, request, image_part_, image_params):
        filename, rId, cx, cy = image_params
        inline_shape = InlineShape(None)
        r = an_r().with_nsdecls().element
        shape_id = 7
        name = 'Picture %d' % shape_id
        uri = nsmap['pic']
        expected_inline = (
            an_inline().with_nsdecls('r', 'wp', 'w').with_child(
                an_extent().with_cx(cx).with_cy(cy)).with_child(
                a_docPr().with_id(shape_id).with_name(name)).with_child(
                a_graphic().with_nsdecls().with_child(
                    a_graphicData().with_uri(uri).with_child(
                        self._pic_bldr(filename, rId, cx, cy))))
        ).element
        expected_inline_xml = expected_inline.xml
        return (
            inline_shape, r, image_part_, rId, shape_id, expected_inline_xml
        )

    @pytest.fixture(params=[
        'embed pic', 'link pic', 'link+embed pic', 'chart', 'smart art',
        'not implemented'
    ])
    def shape_type_fixture(self, request):
        if request.param == 'embed pic':
            inline = self._inline_with_picture(embed=True)
            shape_type = WD_INLINE_SHAPE.PICTURE

        elif request.param == 'link pic':
            inline = self._inline_with_picture(link=True)
            shape_type = WD_INLINE_SHAPE.LINKED_PICTURE

        elif request.param == 'link+embed pic':
            inline = self._inline_with_picture(embed=True, link=True)
            shape_type = WD_INLINE_SHAPE.LINKED_PICTURE

        elif request.param == 'chart':
            inline = self._inline_with_uri(nsmap['c'])
            shape_type = WD_INLINE_SHAPE.CHART

        elif request.param == 'smart art':
            inline = self._inline_with_uri(nsmap['dgm'])
            shape_type = WD_INLINE_SHAPE.SMART_ART

        elif request.param == 'not implemented':
            inline = self._inline_with_uri('foobar')
            shape_type = WD_INLINE_SHAPE.NOT_IMPLEMENTED

        return InlineShape(inline), shape_type

    def _inline_bldr_with_dimensions(self, cx, cy):
        return (
            an_inline().with_nsdecls().with_child(
                an_extent().with_cx(cx).with_cy(cy))
        )

    def _inline_with_picture(self, embed=False, link=False):
        picture_ns = nsmap['pic']

        blip_bldr = a_blip()
        if embed:
            blip_bldr.with_embed('rId1')
        if link:
            blip_bldr.with_link('rId2')

        inline = (
            an_inline().with_nsdecls('wp', 'r').with_child(
                a_graphic().with_nsdecls().with_child(
                    a_graphicData().with_uri(picture_ns).with_child(
                        a_pic().with_nsdecls().with_child(
                            a_blipFill().with_child(
                                blip_bldr)))))
        ).element
        return inline

    def _inline_with_uri(self, uri):
        inline = (
            an_inline().with_nsdecls('wp').with_child(
                a_graphic().with_nsdecls().with_child(
                    a_graphicData().with_uri(uri)))
        ).element
        return inline

    def _pic_bldr(self, name, rId, cx, cy):
        return (
            a_pic().with_nsdecls().with_child(
                an_nvPicPr().with_child(
                    a_cNvPr().with_id(0).with_name(name)).with_child(
                    a_cNvPicPr())).with_child(
                a_blipFill().with_child(
                    a_blip().with_embed(rId)).with_child(
                    a_stretch().with_child(
                        a_fillRect()))).with_child(
                an_spPr().with_child(
                    an_xfrm().with_child(
                        an_off().with_x(0).with_y(0)).with_child(
                        an_ext().with_cx(cx).with_cy(cy))).with_child(
                    a_prstGeom().with_prst('rect')))
        )

########NEW FILE########
__FILENAME__ = test_table
# encoding: utf-8

"""
Test suite for the docx.table module
"""

from __future__ import absolute_import, print_function, unicode_literals

import pytest

from docx.table import (
    _Cell, _Column, _ColumnCells, _Columns, _Row, _RowCells, _Rows, Table
)
from docx.text import Paragraph

from .oxml.unitdata.table import (
    a_gridCol, a_tbl, a_tblGrid, a_tblPr, a_tblStyle, a_tc, a_tcPr, a_tr
)
from .oxml.unitdata.text import a_p, a_t, an_r


class DescribeTable(object):

    def it_provides_access_to_the_table_rows(self, table):
        rows = table.rows
        assert isinstance(rows, _Rows)

    def it_provides_access_to_the_table_columns(self, table):
        columns = table.columns
        assert isinstance(columns, _Columns)

    def it_provides_access_to_a_cell_by_row_and_col_indices(self, table):
        for row_idx in range(2):
            for col_idx in range(2):
                cell = table.cell(row_idx, col_idx)
                assert isinstance(cell, _Cell)
                tr = table._tbl.tr_lst[row_idx]
                tc = tr.tc_lst[col_idx]
                assert tc is cell._tc

    def it_can_add_a_row(self, add_row_fixture):
        table, expected_xml = add_row_fixture
        row = table.add_row()
        assert table._tbl.xml == expected_xml
        assert isinstance(row, _Row)
        assert row._tr is table._tbl.tr_lst[1]

    def it_can_add_a_column(self, add_column_fixture):
        table, expected_xml = add_column_fixture
        column = table.add_column()
        assert table._tbl.xml == expected_xml
        assert isinstance(column, _Column)
        assert column._gridCol is table._tbl.tblGrid.gridCol_lst[1]

    def it_knows_its_table_style(self, table_style_fixture):
        table, style = table_style_fixture
        assert table.style == style

    def it_can_apply_a_table_style_by_name(self, table_style_set_fixture):
        table, style_name, expected_xml = table_style_set_fixture
        table.style = style_name
        assert table._tbl.xml == expected_xml

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def add_column_fixture(self):
        tbl = _tbl_bldr(2, 1).element
        table = Table(tbl)
        expected_xml = _tbl_bldr(2, 2).xml()
        return table, expected_xml

    @pytest.fixture
    def add_row_fixture(self):
        tbl = _tbl_bldr(rows=1, cols=2).element
        table = Table(tbl)
        expected_xml = _tbl_bldr(rows=2, cols=2).xml()
        return table, expected_xml

    @pytest.fixture
    def table(self):
        tbl = _tbl_bldr(rows=2, cols=2).element
        table = Table(tbl)
        return table

    @pytest.fixture
    def table_style_fixture(self):
        style = 'foobar'
        tbl = (
            a_tbl().with_nsdecls().with_child(
                a_tblPr().with_child(
                    a_tblStyle().with_val(style)))
        ).element
        table = Table(tbl)
        return table, style

    @pytest.fixture
    def table_style_set_fixture(self):
        # table ------------------------
        tbl = a_tbl().with_nsdecls().with_child(a_tblPr()).element
        table = Table(tbl)
        # style_name -------------------
        style_name = 'foobar'
        # expected_xml -----------------
        expected_xml = (
            a_tbl().with_nsdecls().with_child(
                a_tblPr().with_child(
                    a_tblStyle().with_val(style_name)))
        ).xml()
        return table, style_name, expected_xml


class Describe_Cell(object):

    def it_provides_access_to_the_paragraphs_it_contains(
            self, cell_with_paragraphs):
        cell = cell_with_paragraphs
        paragraphs = cell.paragraphs
        assert len(paragraphs) == 2
        for p in paragraphs:
            assert isinstance(p, Paragraph)

    def it_can_replace_its_content_with_a_string_of_text(
            self, cell_text_fixture):
        cell, text, expected_xml = cell_text_fixture
        cell.text = text
        assert cell._tc.xml == expected_xml

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def cell_text_fixture(self):
        # cell -------------------------
        tc = (
            a_tc().with_nsdecls().with_child(
                a_tcPr()).with_child(
                a_p()).with_child(
                a_tbl()).with_child(
                a_p())
        ).element
        cell = _Cell(tc)
        # text -------------------------
        text = 'foobar'
        # expected_xml -----------------
        expected_xml = (
            a_tc().with_nsdecls().with_child(
                a_tcPr()).with_child(
                a_p().with_child(
                    an_r().with_child(
                        a_t().with_text(text))))
        ).xml()
        return cell, text, expected_xml

    @pytest.fixture
    def cell_with_paragraphs(self):
        tc = (
            a_tc().with_nsdecls()
                  .with_child(a_p())
                  .with_child(a_p())
                  .element
        )
        return _Cell(tc)


class Describe_Column(object):

    def it_provides_access_to_the_column_cells(self, column):
        cells = column.cells
        assert isinstance(cells, _ColumnCells)

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def column(self):
        return _Column(None, None)


class Describe_ColumnCells(object):

    def it_knows_how_many_cells_it_contains(self, cells_fixture):
        cells, cell_count = cells_fixture
        assert len(cells) == cell_count

    def it_can_iterate_over_its__Cell_instances(self, cells_fixture):
        cells, cell_count = cells_fixture
        actual_count = 0
        for cell in cells:
            assert isinstance(cell, _Cell)
            actual_count += 1
        assert actual_count == cell_count

    def it_provides_indexed_access_to_cells(self, cells_fixture):
        cells, cell_count = cells_fixture
        for idx in range(-cell_count, cell_count):
            cell = cells[idx]
            assert isinstance(cell, _Cell)

    def it_raises_on_indexed_access_out_of_range(self, cells_fixture):
        cells, cell_count = cells_fixture
        too_low = -1 - cell_count
        too_high = cell_count
        with pytest.raises(IndexError):
            cells[too_low]
        with pytest.raises(IndexError):
            cells[too_high]

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def cells_fixture(self):
        cell_count = 2
        tbl = _tbl_bldr(rows=cell_count, cols=1).element
        gridCol = tbl.tblGrid.gridCol_lst[0]
        cells = _ColumnCells(tbl, gridCol)
        return cells, cell_count


class Describe_Columns(object):

    def it_knows_how_many_columns_it_contains(self, columns_fixture):
        columns, column_count = columns_fixture
        assert len(columns) == column_count

    def it_can_interate_over_its__Column_instances(self, columns_fixture):
        columns, column_count = columns_fixture
        actual_count = 0
        for column in columns:
            assert isinstance(column, _Column)
            actual_count += 1
        assert actual_count == column_count

    def it_provides_indexed_access_to_columns(self, columns_fixture):
        columns, column_count = columns_fixture
        for idx in range(-column_count, column_count):
            column = columns[idx]
            assert isinstance(column, _Column)

    def it_raises_on_indexed_access_out_of_range(self, columns_fixture):
        columns, column_count = columns_fixture
        too_low = -1 - column_count
        too_high = column_count
        with pytest.raises(IndexError):
            columns[too_low]
        with pytest.raises(IndexError):
            columns[too_high]

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def columns_fixture(self):
        column_count = 2
        tbl = _tbl_bldr(rows=2, cols=column_count).element
        columns = _Columns(tbl)
        return columns, column_count


class Describe_Row(object):

    def it_provides_access_to_the_row_cells(self, cells_access_fixture):
        row = cells_access_fixture
        cells = row.cells
        assert isinstance(cells, _RowCells)

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def cells_access_fixture(self):
        tr = a_tr().with_nsdecls().element
        row = _Row(tr)
        return row


class Describe_RowCells(object):

    def it_knows_how_many_cells_it_contains(self, cell_count_fixture):
        cells, cell_count = cell_count_fixture
        assert len(cells) == cell_count

    def it_can_iterate_over_its__Cell_instances(self, cell_count_fixture):
        cells, cell_count = cell_count_fixture
        actual_count = 0
        for cell in cells:
            assert isinstance(cell, _Cell)
            actual_count += 1
        assert actual_count == cell_count

    def it_provides_indexed_access_to_cells(self, cell_count_fixture):
        cells, cell_count = cell_count_fixture
        for idx in range(-cell_count, cell_count):
            cell = cells[idx]
            assert isinstance(cell, _Cell)

    def it_raises_on_indexed_access_out_of_range(self, cell_count_fixture):
        cells, cell_count = cell_count_fixture
        too_low = -1 - cell_count
        too_high = cell_count
        with pytest.raises(IndexError):
            cells[too_low]
        with pytest.raises(IndexError):
            cells[too_high]

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def cell_count_fixture(self):
        cell_count = 2
        tr_bldr = a_tr().with_nsdecls()
        for idx in range(cell_count):
            tr_bldr.with_child(a_tc())
        tr = tr_bldr.element
        cells = _RowCells(tr)
        return cells, cell_count


class Describe_Rows(object):

    def it_knows_how_many_rows_it_contains(self, rows_fixture):
        rows, row_count = rows_fixture
        assert len(rows) == row_count

    def it_can_iterate_over_its__Row_instances(self, rows_fixture):
        rows, row_count = rows_fixture
        actual_count = 0
        for row in rows:
            assert isinstance(row, _Row)
            actual_count += 1
        assert actual_count == row_count

    def it_provides_indexed_access_to_rows(self, rows_fixture):
        rows, row_count = rows_fixture
        for idx in range(-row_count, row_count):
            row = rows[idx]
            assert isinstance(row, _Row)

    def it_raises_on_indexed_access_out_of_range(self, rows_fixture):
        rows, row_count = rows_fixture
        with pytest.raises(IndexError):
            too_low = -1 - row_count
            rows[too_low]
        with pytest.raises(IndexError):
            too_high = row_count
            rows[too_high]

    # fixtures -------------------------------------------------------

    @pytest.fixture
    def rows_fixture(self):
        row_count = 2
        tbl = _tbl_bldr(rows=row_count, cols=2).element
        rows = _Rows(tbl)
        return rows, row_count


# fixtures -----------------------------------------------------------

def _tbl_bldr(rows, cols):
    tblGrid_bldr = a_tblGrid()
    for i in range(cols):
        tblGrid_bldr.with_child(a_gridCol())
    tbl_bldr = a_tbl().with_nsdecls().with_child(tblGrid_bldr)
    for i in range(rows):
        tr_bldr = _tr_bldr(cols)
        tbl_bldr.with_child(tr_bldr)
    return tbl_bldr


def _tc_bldr():
    return a_tc().with_child(a_p())


def _tr_bldr(cols):
    tr_bldr = a_tr()
    for i in range(cols):
        tc_bldr = _tc_bldr()
        tr_bldr.with_child(tc_bldr)
    return tr_bldr

########NEW FILE########
__FILENAME__ = test_text
# encoding: utf-8

"""
Test suite for the docx.text module
"""

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

from docx.enum.text import WD_BREAK, WD_UNDERLINE
from docx.oxml.text import CT_P, CT_R
from docx.text import Paragraph, Run

import pytest

from mock import call, Mock

from .oxml.unitdata.text import (
    a_b, a_bCs, a_br, a_caps, a_cs, a_dstrike, a_p, a_shadow, a_smallCaps,
    a_snapToGrid, a_specVanish, a_strike, a_t, a_u, a_vanish, a_webHidden,
    an_emboss, an_i, an_iCs, an_imprint, an_oMath, a_noProof, an_outline,
    an_r, an_rPr, an_rStyle, an_rtl
)
from .unitutil import class_mock, instance_mock


class DescribeParagraph(object):

    def it_has_a_sequence_of_the_runs_it_contains(self, runs_fixture):
        paragraph, Run_, r_, r_2_, run_, run_2_ = runs_fixture
        runs = paragraph.runs
        assert Run_.mock_calls == [call(r_), call(r_2_)]
        assert runs == [run_, run_2_]

    def it_can_add_a_run_to_itself(self, add_run_fixture):
        paragraph, text, style, expected_xml = add_run_fixture
        run = paragraph.add_run(text, style)
        assert paragraph._p.xml == expected_xml
        assert isinstance(run, Run)
        assert run._r is paragraph._p.r_lst[0]

    def it_knows_its_paragraph_style(self):
        cases = (
            (Mock(name='p_elm', style='foobar'), 'foobar'),
            (Mock(name='p_elm', style=None),     'Normal'),
        )
        for p_elm, expected_style in cases:
            p = Paragraph(p_elm)
            assert p.style == expected_style

    def it_can_set_its_paragraph_style(self):
        cases = (
            ('foobar', 'foobar'),
            ('Normal', None),
        )
        for style, expected_setting in cases:
            p_elm = Mock(name='p_elm')
            p = Paragraph(p_elm)
            p.style = style
            assert p_elm.style == expected_setting

    def it_knows_the_text_it_contains(self, text_prop_fixture):
        p, expected_text = text_prop_fixture
        assert p.text == expected_text

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        (None, None), (None, 'Strong'), ('foobar', None), ('foobar', 'Strong')
    ])
    def add_run_fixture(self, request, paragraph):
        text, style = request.param
        r_bldr = an_r()
        if style:
            r_bldr.with_child(
                an_rPr().with_child(an_rStyle().with_val(style))
            )
        if text:
            r_bldr.with_child(a_t().with_text(text))
        expected_xml = a_p().with_nsdecls().with_child(r_bldr).xml()
        return paragraph, text, style, expected_xml

    # fixture components ---------------------------------------------

    @pytest.fixture
    def p_(self, request, r_, r_2_):
        return instance_mock(request, CT_P, r_lst=(r_, r_2_))

    @pytest.fixture
    def paragraph(self):
        p = a_p().with_nsdecls().element
        return Paragraph(p)

    @pytest.fixture
    def Run_(self, request, runs_):
        run_, run_2_ = runs_
        return class_mock(
            request, 'docx.text.Run', side_effect=[run_, run_2_]
        )

    @pytest.fixture
    def r_(self, request):
        return instance_mock(request, CT_R)

    @pytest.fixture
    def r_2_(self, request):
        return instance_mock(request, CT_R)

    @pytest.fixture
    def runs_(self, request):
        run_ = instance_mock(request, Run, name='run_')
        run_2_ = instance_mock(request, Run, name='run_2_')
        return run_, run_2_

    @pytest.fixture
    def runs_fixture(self, p_, Run_, r_, r_2_, runs_):
        paragraph = Paragraph(p_)
        run_, run_2_ = runs_
        return paragraph, Run_, r_, r_2_, run_, run_2_

    @pytest.fixture
    def text_prop_fixture(self):
        p = (
            a_p().with_nsdecls().with_child(
                an_r().with_child(
                    a_t().with_text('foo'))).with_child(
                an_r().with_child(
                    a_t().with_text(' de bar')))
        ).element
        paragraph = Paragraph(p)
        return paragraph, 'foo de bar'


class DescribeRun(object):

    def it_knows_its_bool_prop_states(self, bool_prop_get_fixture):
        run, prop_name, expected_state = bool_prop_get_fixture
        assert getattr(run, prop_name) == expected_state

    def it_can_change_its_bool_prop_settings(self, bool_prop_set_fixture):
        run, prop_name, value, expected_xml = bool_prop_set_fixture
        setattr(run, prop_name, value)
        assert run._r.xml == expected_xml

    def it_knows_its_character_style(self, style_get_fixture):
        run, expected_style = style_get_fixture
        assert run.style == expected_style

    def it_can_change_its_character_style(self, style_set_fixture):
        run, style, expected_xml = style_set_fixture
        run.style = style
        assert run._r.xml == expected_xml

    def it_knows_its_underline_type(self, underline_get_fixture):
        run, expected_value = underline_get_fixture
        assert run.underline == expected_value

    def it_can_change_its_underline_type(self, underline_set_fixture):
        run, underline, expected_xml = underline_set_fixture
        run.underline = underline
        assert run._r.xml == expected_xml

    def it_can_add_text(self, add_text_fixture):
        run, text_str, expected_xml, Text_ = add_text_fixture
        _text = run.add_text(text_str)
        assert run._r.xml == expected_xml
        assert _text is Text_.return_value

    def it_can_add_a_break(self, add_break_fixture):
        run, break_type, expected_xml = add_break_fixture
        run.add_break(break_type)
        assert run._r.xml == expected_xml

    def it_knows_the_text_it_contains(self, text_prop_fixture):
        run, expected_text = text_prop_fixture
        assert run.text == expected_text

    # fixtures -------------------------------------------------------

    @pytest.fixture(params=[
        'line', 'page', 'column', 'clr_lt', 'clr_rt', 'clr_all'
    ])
    def add_break_fixture(self, request, run):
        type_, clear, break_type = {
            'line':    (None,           None,    WD_BREAK.LINE),
            'page':    ('page',         None,    WD_BREAK.PAGE),
            'column':  ('column',       None,    WD_BREAK.COLUMN),
            'clr_lt':  ('textWrapping', 'left',  WD_BREAK.LINE_CLEAR_LEFT),
            'clr_rt':  ('textWrapping', 'right', WD_BREAK.LINE_CLEAR_RIGHT),
            'clr_all': ('textWrapping', 'all',   WD_BREAK.LINE_CLEAR_ALL),
        }[request.param]
        # expected_xml -----------------
        br_bldr = a_br()
        if type_ is not None:
            br_bldr.with_type(type_)
        if clear is not None:
            br_bldr.with_clear(clear)
        expected_xml = an_r().with_nsdecls().with_child(br_bldr).xml()
        return run, break_type, expected_xml

    @pytest.fixture(params=['foobar', ' foo bar', 'bar foo '])
    def add_text_fixture(self, request, run, Text_):
        text_str = request.param
        t_bldr = a_t().with_text(text_str)
        if text_str.startswith(' ') or text_str.endswith(' '):
            t_bldr.with_space('preserve')
        expected_xml = an_r().with_nsdecls().with_child(t_bldr).xml()
        return run, text_str, expected_xml, Text_

    @pytest.fixture(params=[
        ('all_caps', True), ('all_caps', False), ('all_caps', None),
        ('bold', True), ('bold', False), ('bold', None),
        ('italic', True), ('italic', False), ('italic', None),
        ('complex_script', True), ('complex_script', False),
        ('complex_script', None),
        ('cs_bold', True), ('cs_bold', False), ('cs_bold', None),
        ('cs_italic', True), ('cs_italic', False), ('cs_italic', None),
        ('double_strike', True), ('double_strike', False),
        ('double_strike', None),
        ('emboss', True), ('emboss', False), ('emboss', None),
        ('hidden', True), ('hidden', False), ('hidden', None),
        ('italic', True), ('italic', False), ('italic', None),
        ('imprint', True), ('imprint', False), ('imprint', None),
        ('math', True), ('math', False), ('math', None),
        ('no_proof', True), ('no_proof', False), ('no_proof', None),
        ('outline', True), ('outline', False), ('outline', None),
        ('rtl', True), ('rtl', False), ('rtl', None),
        ('shadow', True), ('shadow', False), ('shadow', None),
        ('small_caps', True), ('small_caps', False), ('small_caps', None),
        ('snap_to_grid', True), ('snap_to_grid', False),
        ('snap_to_grid', None),
        ('spec_vanish', True), ('spec_vanish', False), ('spec_vanish', None),
        ('strike', True), ('strike', False), ('strike', None),
        ('web_hidden', True), ('web_hidden', False), ('web_hidden', None),
    ])
    def bool_prop_get_fixture(self, request):
        bool_prop_name, expected_state = request.param
        bool_prop_bldr = {
            'all_caps':       a_caps,
            'bold':           a_b,
            'complex_script': a_cs,
            'cs_bold':        a_bCs,
            'cs_italic':      an_iCs,
            'double_strike':  a_dstrike,
            'emboss':         an_emboss,
            'hidden':         a_vanish,
            'italic':         an_i,
            'imprint':        an_imprint,
            'math':           an_oMath,
            'no_proof':       a_noProof,
            'outline':        an_outline,
            'rtl':            an_rtl,
            'shadow':         a_shadow,
            'small_caps':     a_smallCaps,
            'snap_to_grid':   a_snapToGrid,
            'spec_vanish':    a_specVanish,
            'strike':         a_strike,
            'web_hidden':     a_webHidden,
        }[bool_prop_name]
        r_bldr = an_r().with_nsdecls()
        if expected_state is not None:
            child_bldr = bool_prop_bldr()
            if expected_state is False:
                child_bldr.with_val('off')
            rPr_bldr = an_rPr().with_child(child_bldr)
            r_bldr.with_child(rPr_bldr)
        r = r_bldr.element
        run = Run(r)
        return run, bool_prop_name, expected_state

    @pytest.fixture(params=[
        ('all_caps', True), ('all_caps', False), ('all_caps', None),
        ('bold', True), ('bold', False), ('bold', None),
        ('italic', True), ('italic', False), ('italic', None),
        ('complex_script', True), ('complex_script', False),
        ('complex_script', None),
        ('cs_bold', True), ('cs_bold', False), ('cs_bold', None),
        ('cs_italic', True), ('cs_italic', False), ('cs_italic', None),
        ('double_strike', True), ('double_strike', False),
        ('double_strike', None),
        ('emboss', True), ('emboss', False), ('emboss', None),
        ('hidden', True), ('hidden', False), ('hidden', None),
        ('italic', True), ('italic', False), ('italic', None),
        ('imprint', True), ('imprint', False), ('imprint', None),
        ('math', True), ('math', False), ('math', None),
        ('no_proof', True), ('no_proof', False), ('no_proof', None),
        ('outline', True), ('outline', False), ('outline', None),
        ('rtl', True), ('rtl', False), ('rtl', None),
        ('shadow', True), ('shadow', False), ('shadow', None),
        ('small_caps', True), ('small_caps', False), ('small_caps', None),
        ('snap_to_grid', True), ('snap_to_grid', False),
        ('snap_to_grid', None),
        ('spec_vanish', True), ('spec_vanish', False), ('spec_vanish', None),
        ('strike', True), ('strike', False), ('strike', None),
        ('web_hidden', True), ('web_hidden', False), ('web_hidden', None),
    ])
    def bool_prop_set_fixture(self, request):
        bool_prop_name, value = request.param
        bool_prop_bldr = {
            'all_caps':       a_caps,
            'bold':           a_b,
            'complex_script': a_cs,
            'cs_bold':        a_bCs,
            'cs_italic':      an_iCs,
            'double_strike':  a_dstrike,
            'emboss':         an_emboss,
            'hidden':         a_vanish,
            'italic':         an_i,
            'imprint':        an_imprint,
            'math':           an_oMath,
            'no_proof':       a_noProof,
            'outline':        an_outline,
            'rtl':            an_rtl,
            'shadow':         a_shadow,
            'small_caps':     a_smallCaps,
            'snap_to_grid':   a_snapToGrid,
            'spec_vanish':    a_specVanish,
            'strike':         a_strike,
            'web_hidden':     a_webHidden,
        }[bool_prop_name]
        # run --------------------------
        r = an_r().with_nsdecls().element
        run = Run(r)
        # expected_xml -----------------
        rPr_bldr = an_rPr()
        if value is not None:
            child_bldr = bool_prop_bldr()
            if value is False:
                child_bldr.with_val(0)
            rPr_bldr.with_child(child_bldr)
        expected_xml = an_r().with_nsdecls().with_child(rPr_bldr).xml()
        return run, bool_prop_name, value, expected_xml

    @pytest.fixture(params=['Foobar', None])
    def style_get_fixture(self, request):
        style = request.param
        r = self.r_bldr_with_style(style).element
        run = Run(r)
        return run, style

    @pytest.fixture(params=[
        (None, None),
        (None, 'Foobar'),
        ('Foobar', None),
        ('Foobar', 'Foobar'),
        ('Foobar', 'Barfoo'),
    ])
    def style_set_fixture(self, request):
        before_style, after_style = request.param
        r = self.r_bldr_with_style(before_style).element
        run = Run(r)
        expected_xml = self.r_bldr_with_style(after_style).xml()
        return run, after_style, expected_xml

    @pytest.fixture
    def text_prop_fixture(self, Text_):
        r = (
            an_r().with_nsdecls().with_child(
                a_t().with_text('foo')).with_child(
                a_t().with_text('bar'))
        ).element
        run = Run(r)
        return run, 'foobar'

    @pytest.fixture(params=[
        (None,     None),
        ('single', True),
        ('none',   False),
        ('double', WD_UNDERLINE.DOUBLE),
    ])
    def underline_get_fixture(self, request):
        underline_type, expected_prop_value = request.param
        r = self.r_bldr_with_underline(underline_type).element
        run = Run(r)
        return run, expected_prop_value

    @pytest.fixture(params=[
        (None,     True,                'single'),
        (None,     False,               'none'),
        (None,     None,                None),
        (None,     WD_UNDERLINE.SINGLE, 'single'),
        (None,     WD_UNDERLINE.WAVY,   'wave'),
        ('single', True,                'single'),
        ('single', False,               'none'),
        ('single', None,                None),
        ('single', WD_UNDERLINE.SINGLE, 'single'),
        ('single', WD_UNDERLINE.DOTTED, 'dotted'),
    ])
    def underline_set_fixture(self, request):
        before_val, underline, expected_val = request.param
        r = self.r_bldr_with_underline(before_val).element
        run = Run(r)
        expected_xml = self.r_bldr_with_underline(expected_val).xml()
        return run, underline, expected_xml

    # fixture components ---------------------------------------------

    @pytest.fixture
    def run(self):
        r = an_r().with_nsdecls().element
        return Run(r)

    def r_bldr_with_style(self, style):
        rPr_bldr = an_rPr()
        if style is not None:
            rPr_bldr.with_child(an_rStyle().with_val(style))
        r_bldr = an_r().with_nsdecls().with_child(rPr_bldr)
        return r_bldr

    def r_bldr_with_underline(self, underline_type):
        rPr_bldr = an_rPr()
        if underline_type is not None:
            rPr_bldr.with_child(a_u().with_val(underline_type))
        r_bldr = an_r().with_nsdecls().with_child(rPr_bldr)
        return r_bldr

    @pytest.fixture
    def Text_(self, request):
        return class_mock(request, 'docx.text.Text')

########NEW FILE########
__FILENAME__ = unitdata
# encoding: utf-8

"""
Shared code for unit test data builders
"""

from __future__ import absolute_import, print_function, unicode_literals

from docx.oxml.shared import nsdecls, oxml_fromstring


class BaseBuilder(object):
    """
    Provides common behavior for all data builders.
    """
    def __init__(self):
        self._empty = False
        self._nsdecls = ''
        self._text = ''
        self._xmlattrs = []
        self._xmlattr_method_map = {}
        for attr_name in self.__attrs__:
            base_name = (
                attr_name.split(':')[1] if ':' in attr_name else attr_name
            )
            method_name = 'with_%s' % base_name
            self._xmlattr_method_map[method_name] = attr_name
        self._child_bldrs = []

    def __getattr__(self, name):
        """
        Intercept attribute access to generalize "with_{xmlattr_name}()"
        methods.
        """
        if name in self._xmlattr_method_map:
            def with_xmlattr(value):
                xmlattr_name = self._xmlattr_method_map[name]
                self._set_xmlattr(xmlattr_name, value)
                return self
            return with_xmlattr
        else:
            tmpl = "'%s' object has no attribute '%s'"
            raise AttributeError(tmpl % (self.__class__.__name__, name))

    def clear(self):
        """
        Reset this builder back to initial state so it can be reused within
        a single test.
        """
        BaseBuilder.__init__(self)
        return self

    @property
    def element(self):
        """
        Element parsed from XML generated by builder in current state
        """
        elm = oxml_fromstring(self.xml())
        return elm

    def with_child(self, child_bldr):
        """
        Cause new child element specified by *child_bldr* to be appended to
        the children of this element.
        """
        self._child_bldrs.append(child_bldr)
        return self

    def with_text(self, text):
        """
        Cause *text* to be placed between the start and end tags of this
        element. Not robust enough for mixed elements, intended only for
        elements having no child elements.
        """
        self._text = text
        return self

    def with_nsdecls(self, *nspfxs):
        """
        Cause the element to contain namespace declarations. By default, the
        namespace prefixes defined in the Builder class are used. These can
        be overridden by providing exlicit prefixes, e.g.
        ``with_nsdecls('a', 'r')``.
        """
        if not nspfxs:
            nspfxs = self.__nspfxs__
        self._nsdecls = ' %s' % nsdecls(*nspfxs)
        return self

    def xml(self, indent=0):
        """
        Return element XML based on attribute settings
        """
        indent_str = ' ' * indent
        if self._is_empty:
            xml = '%s%s\n' % (indent_str, self._empty_element_tag)
        else:
            xml = '%s\n' % self._non_empty_element_xml(indent)
        return xml

    def xml_bytes(self, indent=0):
        return self.xml(indent=indent).encode('utf-8')

    @property
    def _empty_element_tag(self):
        return '<%s%s%s/>' % (self.__tag__, self._nsdecls, self._xmlattrs_str)

    @property
    def _end_tag(self):
        return '</%s>' % self.__tag__

    @property
    def _is_empty(self):
        return len(self._child_bldrs) == 0 and len(self._text) == 0

    def _non_empty_element_xml(self, indent):
        indent_str = ' ' * indent
        if self._text:
            xml = ('%s%s%s%s' %
                   (indent_str, self._start_tag, self._text, self._end_tag))
        else:
            xml = '%s%s\n' % (indent_str, self._start_tag)
            for child_bldr in self._child_bldrs:
                xml += child_bldr.xml(indent+2)
            xml += '%s%s' % (indent_str, self._end_tag)
        return xml

    def _set_xmlattr(self, xmlattr_name, value):
        xmlattr_str = ' %s="%s"' % (xmlattr_name, str(value))
        self._xmlattrs.append(xmlattr_str)

    @property
    def _start_tag(self):
        return '<%s%s%s>' % (self.__tag__, self._nsdecls, self._xmlattrs_str)

    @property
    def _xmlattrs_str(self):
        """
        Return all element attributes as a string, like ' foo="bar" x="1"'.
        """
        return ''.join(self._xmlattrs)

########NEW FILE########
__FILENAME__ = unitutil
# encoding: utf-8

"""
Utility functions for unit testing
"""

import os

from mock import create_autospec, Mock, patch, PropertyMock

from docx.oxml.shared import serialize_for_reading


_thisdir = os.path.split(__file__)[0]
test_file_dir = os.path.abspath(os.path.join(_thisdir, 'test_files'))


def abspath(relpath):
    thisdir = os.path.split(__file__)[0]
    return os.path.abspath(os.path.join(thisdir, relpath))


def actual_xml(elm):
    return serialize_for_reading(elm)


def absjoin(*paths):
    return os.path.abspath(os.path.join(*paths))


def docx_path(name):
    """
    Return the absolute path to test .docx file with root name *name*.
    """
    return absjoin(_thisdir, 'test_files', '%s.docx' % name)


def test_file(name):
    """
    Return the absolute path to test file having *name*.
    """
    return absjoin(_thisdir, 'test_files', name)


# ===========================================================================
# pytest mocking helpers
# ===========================================================================


def class_mock(request, q_class_name, autospec=True, **kwargs):
    """
    Return a mock patching the class with qualified name *q_class_name*.
    The mock is autospec'ed based on the patched class unless the optional
    argument *autospec* is set to False. Any other keyword arguments are
    passed through to Mock(). Patch is reversed after calling test returns.
    """
    _patch = patch(q_class_name, autospec=autospec, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def cls_attr_mock(request, cls, attr_name, name=None, **kwargs):
    """
    Return a mock for attribute *attr_name* on *cls* where the patch is
    reversed after pytest uses it.
    """
    name = request.fixturename if name is None else name
    _patch = patch.object(cls, attr_name, name=name, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def function_mock(request, q_function_name, **kwargs):
    """
    Return a mock patching the function with qualified name
    *q_function_name*. Patch is reversed after calling test returns.
    """
    _patch = patch(q_function_name, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def initializer_mock(request, cls):
    """
    Return a mock for the __init__ method on *cls* where the patch is
    reversed after pytest uses it.
    """
    _patch = patch.object(cls, '__init__', return_value=None)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def instance_mock(request, cls, name=None, spec_set=True, **kwargs):
    """
    Return a mock for an instance of *cls* that draws its spec from the class
    and does not allow new attributes to be set on the instance. If *name* is
    missing or |None|, the name of the returned |Mock| instance is set to
    *request.fixturename*. Additional keyword arguments are passed through to
    the Mock() call that creates the mock.
    """
    name = name if name is not None else request.fixturename
    return create_autospec(
        cls, _name=name, spec_set=spec_set, instance=True, **kwargs
    )


def loose_mock(request, name=None, **kwargs):
    """
    Return a "loose" mock, meaning it has no spec to constrain calls on it.
    Additional keyword arguments are passed through to Mock(). If called
    without a name, it is assigned the name of the fixture.
    """
    if name is None:
        name = request.fixturename
    return Mock(name=name, **kwargs)


def method_mock(request, cls, method_name, **kwargs):
    """
    Return a mock for method *method_name* on *cls* where the patch is
    reversed after pytest uses it.
    """
    _patch = patch.object(cls, method_name, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def property_mock(request, cls, prop_name, **kwargs):
    """
    Return a mock for property *prop_name* on class *cls* where the patch is
    reversed after pytest uses it.
    """
    _patch = patch.object(cls, prop_name, new_callable=PropertyMock, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()


def var_mock(request, q_var_name, **kwargs):
    """
    Return a mock patching the variable with qualified name *q_var_name*.
    Patch is reversed after calling test returns.
    """
    _patch = patch(q_var_name, **kwargs)
    request.addfinalizer(_patch.stop)
    return _patch.start()

########NEW FILE########
