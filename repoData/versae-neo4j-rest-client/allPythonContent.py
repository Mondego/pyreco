__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# neo4j-rest-client documentation build configuration file, created by
# sphinx-quickstart on Mon Feb 27 11:54:51 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'neo4j-rest-client'
copyright = u'2014, Javier de la Rosa'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '2.0.0'
# The full version, including alpha/beta/rc tags.
release = '2.0.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'neo4j-rest-clientdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'neo4j-rest-client.tex', u'neo4j-rest-client Documentation',
   u'Javier de la Rosa', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'neo4j-rest-client', u'neo4j-rest-client Documentation',
     [u'Javier de la Rosa'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'neo4j-rest-client', u'neo4j-rest-client Documentation',
   u'Javier de la Rosa', 'neo4j-rest-client',
   'Object-oriented Python library to interact with Neo4j standalone REST server.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = client
# -*- coding: utf-8 -*-
from datetime import date, datetime, time
try:
    import cPickle as pickle
except:
    import pickle
import weakref
import warnings
from lucenequerybuilder import Q

from neo4jrestclient import options
from neo4jrestclient.constants import (
    BREADTH_FIRST, DEPTH_FIRST,
    STOP_AT_END_OF_GRAPH,
    NODE_GLOBAL, NODE_PATH, NODE_RECENT,
    RELATIONSHIP_GLOBAL, RELATIONSHIP_PATH,
    RELATIONSHIP_RECENT, NONE, INDEX, ITERABLE,
    NODE, RELATIONSHIP, PATH, POSITION, FULLPATH, RAW,
    INDEX_FULLTEXT, TX_GET, TX_PUT, TX_POST, TX_DELETE,
    INDEX_RELATIONSHIP, INDEX_NODE,
    RELATIONSHIPS_ALL, RELATIONSHIPS_IN, RELATIONSHIPS_OUT,
    RETURN_ALL_NODES, RETURN_ALL_BUT_START_NODE
)
from neo4jrestclient.iterable import Iterable
from neo4jrestclient.labels import NodeLabelsProxy, LabelsProxy
from neo4jrestclient.query import (
    QuerySequence, FilterSequence, QueryTransaction, CypherException
)
from neo4jrestclient.request import Request
from neo4jrestclient.exceptions import (NotFoundError, StatusException,
                                        TransactionException)
from neo4jrestclient.traversals import TraversalDescription, GraphTraversal
from neo4jrestclient.utils import (PY2, text_type, smart_quote, string_types,
                                   unquote, get_auth_from_uri)

__all__ = ["GraphDatabase", "Incoming", "Outgoing", "Undirected",
           "StopAtDepth", "NotFoundError", "StatusException", "Q"]


class StopAtDepth(object):
    """
    Only traverse to a certain depth.
    """

    def __init__(self, depth):
        self.depth = depth

    def __get__(self):
        return self.depth


class GraphDatabase(object):
    """
    Main class for connection to Ne4j standalone REST server.
    """

    def __init__(self, url, username=None, password=None, cert_file=None,
                 key_file=None):
        username_uri, password_uri, xxx = get_auth_from_uri(url)
        username = username or username_uri
        password = password or password_uri
        self._auth = {
            "username": username,
            "password": password,
            "cert_file": cert_file,
            "key_file": key_file,
        }
        self._transactions = {}
        self.url = None
        if url.endswith("/"):
            self.url = url
        else:
            self.url = "%s/" % url
        response = Request(**self._auth).get(self.url)
        if response.status_code == 200:
            response_json = response.json()
        else:
            raise NotFoundError(response.status_code, "Unable get root")
        if "data" in response_json and "management" in response_json:
            response = Request(**self._auth).get(response_json["data"])
            if response.status_code == 200:
                response_json = response.json()
            else:
                raise NotFoundError(response.status_code, "Unable get root")
        if response_json:
            self._relationship_index = response_json['relationship_index']
            self._node = response_json['node']
            self._labels = response_json.get('labels',
                                             "{}labels".format(self.url))
            self._labels_list = None
            self._node_index = response_json['node_index']
            self._reference_node = response_json.get('reference_node', None)
            self._extensions_info = response_json['extensions_info']
            self._extensions = response_json['extensions']
            self._cypher = response_json.get('cypher', None)
            self._transaction = response_json.get('transaction', None)
            self.VERSION = response_json.get('neo4j_version', None)
            if self.VERSION:
                self._auth.update({'version': self.VERSION})
            self._extensions_cache = None
            self.nodes = NodesProxy(self._node, self._reference_node,
                                    self._node_index,
                                    auth=self._auth, cypher=self._cypher)
            # Backward compatibility. The current style is more pythonic
            self.node = self.nodes
            # HACK: Neo4j doesn't provide the URLs to access to relationships
            url_parts = self._node.rpartition("node")
            self._relationship = "%s%s%s" % (url_parts[0], RELATIONSHIP,
                                             url_parts[2])
            self.relationships = RelationshipsProxy(self._relationship,
                                                    self._relationship_index,
                                                    auth=self._auth,
                                                    cypher=self._cypher)
            self.Traversal = GraphTraversal
            try:
                self._batch = response_json["batch"]
            except KeyError:
                self._batch = "%sbatch" % self.url

    def __eq__(self, obj):
        return (
            self._relationship_index == obj._relationship_index
            and self._relationship == obj._relationship
            and self._node == obj._node
            and self._labels == obj._labels
            and self._labels_list == obj._labels_list
            and self._node_index == obj._node_index
            and self._reference_node == obj._reference_node
            and self._extensions_info == obj._extensions_info
            and self._extensions == obj._extensions
            and self._cypher == obj._cypher
            and self._transaction == obj._transaction
            and self._batch == obj._batch
        )

    def _get_extensions(self):
        if not self._extensions_cache:
            self._extensions_cache = ExtensionsProxy(self._extensions,
                                                     auth=self._auth,
                                                     cypher=self._cypher)
        return self._extensions_cache
    extensions = property(_get_extensions)

    def _get_reference_node(self):
        warnings.warn("Deprecated, the reference node is not needed anymore",
                      DeprecationWarning)
        if self._reference_node:
            return Node(self._reference_node)
        else:
            return None
    reference_node = property(_get_reference_node)

    def flush(self, return_globals=True):
        if options.TX_NAME in globals():
            del globals()[options.TX_NAME]
        self._transactions = {}
        if return_globals:
            return globals()

    def traverse(self, start_node, *args, **kwargs):
        return start_node.traverse(*args, **kwargs)

    def traversal(self):
        return TraversalDescription(auth=self._auth, cypher=self._cypher)

    def transaction(self, using_globals=True, commit=True, update=True,
                    transaction_id=None, context=None, for_query=False,
                    rollback=True, execute=False):
        if transaction_id not in self._transactions:
            transaction_id = len(self._transactions.keys())
        if for_query:
            types = {
                "node": Node,
                "relationship": Relationship,
                "path": Path,
                "position": Position,
            }
            tx = QueryTransaction(self, transaction_id, rollback=rollback,
                                  commit=commit, update=update, types=types,
                                  execute=execute)
        else:
            tx = Transaction(self, transaction_id, context or {},
                             commit=commit, update=update)
        self._transactions[transaction_id] = tx
        if using_globals:
            globals()[options.TX_NAME] = self._transactions[transaction_id]
        return self._transactions[transaction_id]

    def query(self, q, params=None, returns=RAW, tx=None):
        if self._cypher or self._transaction:
            types = {
                "node": Node,
                "relationship": Relationship,
                "path": Path,
                "position": Position,
            }
            tx = Transaction.get_transaction(tx)
            # The non transactional Cypher endpoint will be removed eventually,
            # So we create always a transaction per query for Neo4j 2.0+
            if (tx is None
                    and self.VERSION and self.VERSION.split(".")[0] >= "2"):
                tx = self.transaction(for_query=True, execute=True)
            return QuerySequence(self._cypher, self._auth, q=q, params=params,
                                 types=types, returns=returns, tx=tx)
        else:
            raise CypherException

    def _get_labels(self):
        if not self._labels_list and self.VERSION.split(".")[0] >= "2":
            self._labels_list = LabelsProxy(self._labels,
                                            auth=self._auth,
                                            cypher=self._cypher,
                                            node=Node)
        return self._labels_list
    labels = property(_get_labels)


class TransactionOperationProxy(dict, object):
    """
    TransactionOperationProxy class. A proxy to convert transaction operations
    into final instances of Node or Relationship.
    """

    def __init__(self, obj=None, job=None, typ=None, **kwargs):
        self._proxy = None
        if obj is not None:
            self._object_ref = weakref.ref(obj)
        else:
            self._object_ref = None
        self._job_id = job
        if "body" not in kwargs:
            if typ == NODE:
                kwargs.update({"body": {}})
            else:  # RELATIONSHIP and INDEX
                kwargs.update({"body": {"data": {}}})
        elif typ == RELATIONSHIP and "data" not in kwargs["body"]:
            kwargs["body"].update({"data": {}})
        self._extras = {"type": typ}
        super(TransactionOperationProxy, self).__init__(kwargs)

    def __call__(self):
        return dict(self)

    def __getattribute__(self, attr, *args, **kwargs):
        _proxy = object.__getattribute__(self, "_proxy")
        _type = object.__getattribute__(self, "_extras")["type"]
        if _proxy is not None:
            return getattr(_proxy, attr)
        elif _type and attr in ("relationships", "start", "end", "type", "id"):
            if (_type == NODE and attr == "relationships"
                    or _type == RELATIONSHIP
                    and attr in ("start", "end", "type")):
                return object.__getattribute__(self, "_get_%s" % attr)()
            else:
                return object.__getattribute__(self, attr)
        elif _type == NODE:
            try:
                return object.__getattribute__(self, attr)
            except AttributeError:
                warnings.warn("Deprecated, in favor of pythonic style to "
                              "declare relationships: "
                              "n2.relationships.create(rel_name, n2). "
                              "This is needed in order to handle pickling in "
                              "nodes.",
                              DeprecationWarning)

                def _create_relationship(*args, **kwargs):
                    _attr = "_create_relationship"
                    _func = object.__getattribute__(self, _attr)
                    _relationship = _func(attr)
                    return _relationship(*args, **kwargs)

                return _create_relationship
        else:
            return object.__getattribute__(self, attr)

    def __setattribute__(self, attr, val):
        _proxy = object.__getattribute__(self, "_proxy")
        if _proxy is not None:
            setattr(_proxy, attr, val)
        else:
            object.__setattr__(self, attr, val)

    def set(self, key, value):
        self.__setitem__(key, value)

    def get(self, key):
        self.__getitem__(key)

    def _get_properties(self):
        return dict(self)

    def _set_properties(self, props={}):
        # _type = object.__getattribute__(self, "_extras")["type"]
        if type == RELATIONSHIP:
            _body = dict.__getitem__(self, "body")
            _data = dict.__getitem__(_body, "data")
            _data.update(props)
        else:
            _body = dict.__getitem__(self, "body")
            _body.update(props)

    def _del_properties(self):
        # _type = object.__getattribute__(self, "_extras")["type"]
        if type == RELATIONSHIP:
            _body = dict.__getitem__(self, "body")
            dict.__setitem__(_body, "data", {})
        else:
            dict.__setitem__(self, "body", {})

    properties = property(_get_properties, _set_properties, _del_properties)

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        attr = "__unicode__"
        try:
            return getattr(object.__getattribute__(self, "_proxy"), attr)()
        except AttributeError:
            pass
        return object.__repr__(self)

    def __getitem__(self, key):
        _type = object.__getattribute__(self, "_extras")["type"]
        _proxy = object.__getattribute__(self, "_proxy")
        if _proxy is not None:
            if isinstance(key, slice):
                eltos = _proxy._list[key]
                if _proxy._attribute:
                    return [_proxy._class(elto[_proxy._attribute],
                                          update_dict=elto) for elto in eltos]
                else:
                    return [_proxy._class(elto) for elto in eltos]
            else:
                return _proxy.__getitem__(key)
        else:
            if _type == RELATIONSHIP:
                _body = dict.__getitem__(self, "body")
                return dict.__getitem__(_body, key)
            elif _type == ITERABLE:
                _body = dict.__getitem__(self, "body")
                dict.__setitem__(self, "key", key)
                return self
            else:
                _body = dict.__getitem__(self, "body")
                return dict.__getitem__(_body, key)

    def __setitem__(self, key, val):
        _type = object.__getattribute__(self, "_extras")["type"]
        _proxy = object.__getattribute__(self, "_proxy")
        if _proxy is not None:
            return _proxy.__setitem__(key, val)
        else:
            if _type == RELATIONSHIP:
                _body = dict.__getitem__(self, "body")
                _data = dict.__getitem__(_body, "data")
                return dict.__setitem__(_data, key, val)
            else:
                _body = dict.__getitem__(self, "body")
                return dict.__setitem__(_body, key, val)

    def get_object(self):
        if self._object_ref:
            return self._object_ref()
        else:
            return None

    def get_job_id(self):
        return self._job_id

    def change(self, cls, url, data=None, auth=None):
        _auth = auth or {}
        _type = object.__getattribute__(self, "_extras")["type"]
        if _type in (INDEX_NODE, INDEX_RELATIONSHIP):
            # TODO: Improve the way we get the name of the index,
            #       maybe including the name in the results
            name = data["location"].split(data["from"])[1][1:-1]
            if NODE in data["from"]:
                self._proxy = cls(index_for=NODE, name=name, auth=_auth,
                                  **data["body"])
            else:
                self._proxy = cls(index_for=RELATIONSHIP,
                                  name=name, auth=_auth,
                                  **data["body"])
        elif _type == ITERABLE:
            if not data["body"] or len(data["body"]) == 0:
                self._proxy = list()
            else:
                self_keys = self().keys()
                # Check if it is an element from the iterable
                if "key" in self_keys and "of" in self_keys:
                    _key = dict.__getitem__(self, "key")
                    _of = dict.__getitem__(self, "of")
                    _body = data["body"][_key]
                    if _of == NODE:
                        cls = Node
                    else:  # Relationship
                        cls = Relationship
                    self._proxy = cls(_body["self"],
                                      update_dict=_body, auth=_auth)
                else:
                    first_element = data["body"][0]
                    if "self" in first_element:
                        if NODE in first_element["self"]:
                            self._proxy = cls(Node, data["body"], "self",
                                              auth=_auth)
                        elif RELATIONSHIP in first_element["self"]:
                            self._proxy = cls(Relationship, data["body"],
                                              "self", auth=_auth)
                    else:
                        self._proxy = cls(Path, data["body"], auth=_auth)
        else:
            if "self" in data["body"] and data["body"]["self"] != url:
                self._proxy = cls(data["body"]["self"],
                                  update_dict=data["body"], auth=_auth)
            elif data["body"] == data["returns"]:
                # Basic types likes strings or integers
                self._proxy = cls(data["body"])
            else:
                self._proxy = cls(url, update_dict=data["body"], auth=_auth)

    # Common functions
    def _get_id(self):
        _body = dict.__getitem__(self, "body")
        return "{%s}" % _body["id"]

    # Node functions
    def _get_relationships(self):
        """
        HACK: Return a 3-methods class: incoming, outgoing and all.
        """
        return Relationships(self)

    def _create_relationship(self, relationship_name, *args, **kwargs):
        _job_id = object.__getattribute__(self, "_job_id")

        def relationship(to, *args, **kwargs):
            tx = Transaction.get_transaction(kwargs.get("tx", None))
            object.__getattribute__(self, "_extras")["to"] = to
            create_relationship_url = "{%s}/relationships" % _job_id
            # Check if target node doesn't exist yet
            if (isinstance(to, TransactionOperationProxy)
                    and not isinstance(to, Node)):
                to_url = "{%s}" % to()["id"]
            else:
                to_url = to.url
            data = {
                "to": to_url,
                "type": relationship_name,
            }
            if "tx" in kwargs and isinstance(kwargs["tx"], Transaction):
                x = kwargs.pop("tx", None)
                del x  # Makes pyflakes happy
            if kwargs:
                data.update({"data": kwargs})
            object.__getattribute__(self, "_extras")["tx"] = tx
            return tx.append(TX_POST, create_relationship_url,
                             data=data, obj=self, returns=RELATIONSHIP)
        return relationship

    # Relationships functions
    def _get_start(self):
        _proxy = object.__getattribute__(self, "_proxy")
        node_from_string = dict.__getitem__(_proxy, "to")
        node_from_index = int(node_from_string.split("/")[0][1:-1])
        tx = object.__getattribute__(self, "_extras")["tx"]
        node_from = tx.operations[node_from_index]
        return node_from

    def _get_end(self):
        node_to = object.__getattribute__(self, "_extras")["to"]
        return node_to

    def _get_type(self):
        _body = dict.__getitem__(self, "body")
        _data = dict.__getitem__(_body, "data")
        return dict.__getitem__(_data, "type")

    # Index functions
    def add(self, key, value, item, tx=None):
        _body = dict.__getitem__(self, "body")
        _name = dict.__getitem__(_body, "name")
        _type = object.__getattribute__(self, "_extras")["type"]
        if _type == INDEX_NODE:
            index_for = NODE
        else:
            index_for = RELATIONSHIP

        if isinstance(value, (list, tuple)):
            tx = tx or value[1]
            value = value[0]
        if isinstance(item, Transaction):
            tx = tx or item
            item = item.get_value()
        tx = Transaction.get_transaction(tx)
        # Neo4j hardly crush if you try to index a relationship in a
        # node index and viceversa.
        is_node_index = (index_for == NODE
                         and isinstance(item, Node))
        is_relationship_index = (index_for == RELATIONSHIP
                                 and isinstance(item, Relationship))
        if not (is_node_index or is_relationship_index
                or TransactionOperationProxy):
            raise TypeError("%s is a %s and the index is for %ss"
                            % (item, index_for.capitalize(), index_for))
        if isinstance(item, Base):
            url_ref = item.url
        elif isinstance(item, TransactionOperationProxy):
            url_ref = "{%s}" % item()["id"]
        else:
            url_ref = item
        data = {"key": key,
                "value": value,  # smart_quote is not needed anymore
                "uri": url_ref}
        if tx:
            request_url = "index/%s/%s" % (index_for, _name)
            op = tx.append(TX_POST, request_url, data=data,
                           obj=self, returns=index_for)
            return op


class Transaction(object):
    """
    Transaction class.
    """

    def __init__(self, cls, transaction_id, context, commit=True, update=True):
        self._class = cls
        self.url = self._class._batch
        self.id = transaction_id
        self.context = context
        self.auto_commit = commit
        self.auto_update = update
        self.operations = []
        self.references = []
        self._value = None
        self._attribute = None

    def __call__(self, value):
        """
        Call method in order to allow expresions like

            with gdb.transaction(using_globals=False) as tx:
                n[key] = tx(value)
        """
        self._value = value
        return self

    def get_value(self):
        return self._value

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if self.auto_commit:
            return self.commit(type, value, traceback)
        return True

    def _results_list_to_dict(self, results):
        result_dict = {}
        for result in results:
            result_id = result.pop("id")
            if "body" in result and "self" in result["body"]:
                if NODE in result["body"]["self"]:
                    result["returns"] = Node
                elif RELATIONSHIP in result["body"]["self"]:
                    result["returns"] = Relationship
            elif "body" in result and isinstance(result["body"],
                                                 (tuple, list)):
                result["returns"] = Iterable
            elif "from" in result and INDEX in result["from"]:
                result["returns"] = Index
            elif "body" in result:
                result["returns"] = result["body"]
            else:
                result["returns"] = None
            if "returns" in result:
                result_dict[result_id] = result
        return result_dict

    def _batch(self):
        request = Request(**self._class._auth)
        response = request.post(self.url, data=self.operations)
        if response.status_code == 200:
            results_list = response.json()
            results_dict = self._results_list_to_dict(results_list)
            return results_dict
        else:
            raise TransactionException(response.status_code)

    def commit(self, *args, **kwargs):
        auth = self._class._auth
        self._class.flush()
        results = self._batch()
        # Objects to update
        if self.auto_update:
            for operation in self.operations:
                on_object = operation.get_object()
                if hasattr(on_object, "update"):
                    on_object.update(extensions=False,
                                     delete_on_not_found=True)
        # Objects to return
        for referenced_object in self.references:
                ref_object = referenced_object()
                result = results[ref_object()["id"]]
                if "returns" in result:
                    if "location" in result:
                        cls = result["returns"]
                        url = result["location"]
                    elif "body" in result:
                        cls = result["returns"]
                        if "self" in result["body"]:
                            url = result["body"]["self"]
                        elif isinstance(result["body"], (tuple, list)):
                            url = None
                            ref_object.change(cls, url, data=result, auth=auth)
                        elif result["body"] == result["returns"]:
                            url = None
                            ref_object.change(cls.__class__, cls, data=result,
                                              auth=auth)
                    if cls and url:
                        ref_object.change(cls, url, data=result, auth=auth)
        self.references = []
        self.operations = []
        # Destroy the object after commit
        self = None
        if "type" in kwargs and isinstance(kwargs["type"], Exception):
            raise kwargs["type"]
        else:
            return True

    def append(self, method, url, data=None, obj=None, returns=None, of=None):
        job_id = len(self.operations)
        if url.startswith("{"):
            url_to = url
        elif not url.startswith("/"):
            url_to = "/%s" % url.replace(self._class.url, "")
        else:
            url_to = url
        params = {
            "method": method,
            "to": url_to,
            "id": job_id,
            "of": of,
        }
        if data:
            params.update({"body": data})
        # Reunify PUT methods in just one
        transaction_operation = None
        if method == TX_PUT:
            # TODO: Improve the performance of this search
            for i, operation in enumerate(self.operations):
                if (operation()["method"] == params["method"] == TX_PUT
                        and operation()["to"] == params["to"]):
                    if "body" in operation():
                        self.operations[i]()["body"].update(params["body"])
                    else:
                        self.operations[i]()["body"] = params["body"]
                    transaction_operation = operation
                    break
        if not transaction_operation:
            transaction_operation = TransactionOperationProxy(obj=obj,
                                                              job=job_id,
                                                              typ=returns,
                                                              **params)
            self.operations.append(transaction_operation)
            if method in (TX_POST, TX_GET):
                self.references.append(weakref.ref(transaction_operation))
        return transaction_operation

    @staticmethod
    def get_transaction(tx=None):
        if not tx and options.TX_NAME in globals():
            return globals()[options.TX_NAME]
        elif isinstance(tx, (Transaction, QueryTransaction)):
            return tx
        elif (isinstance(tx, (list, tuple)) and len(tx) > 1
              and isinstance(tx[-1], (Transaction, QueryTransaction))):
            return tx[-1]
        else:
            return None


class Base(object):
    """
    Base class.
    """

    def __init__(self, url, create=False, data={}, update_dict={}, auth=None,
                 cypher=None):
        self._dic = {}
        self._auth = auth or {}
        self._cypher = cypher
        self.url = None
        self._labels = None
        # Allow update an object using only a new data dict of properties
        self._update_dict = update_dict
        if url.endswith("/"):
            url = url[:-1]
        if create:
            response = Request(**self._auth).post(url, data=data)
            if response.status_code == 201:
                self._dic.update(data.copy())
                self._update_dict_data()
                self.url = response.headers.get(
                    "location",
                    response.headers.get("content-location")
                )
            else:
                raise NotFoundError(response.status_code, "Invalid data sent")
        if not self.url:
            self.url = url
        self.update()

    def _update_dict_data(self):
        if "data" in self._dic:
            self._dic["data"] = dict((Base._safe_string(k),
                                      Base._safe_string(v))
                                     for k, v in self._dic["data"].items())

    @staticmethod
    def _safe_string(s):
        if options.SMART_DATES:
            if isinstance(s, (datetime, date, time)):
                return s
            else:
                try:
                    dt = datetime.strptime(s, options.DATETIME_FORMAT)
                except ValueError:
                    for date_type in ["date", "time"]:
                        try:
                            option = "%s_FORMAT" % date_type.upper()
                            format = getattr(options, option)
                            t = getattr(datetime.strptime(s, format),
                                        date_type)()
                        except ValueError:
                            pass
                        else:
                            return t
                else:
                    return dt
        if isinstance(s, text_type):
            return s
        if isinstance(s, string_types):
            if PY2:
                return text_type(s.decode("utf-8"))
            else:
                return text_type(s)
        else:
            # We avoid convert non-string values
            return s

    def update(self, extensions=True, delete_on_not_found=False):
        if self._update_dict:
            update_dict = self._update_dict
            status = 200
        else:
            response = Request(**self._auth).get(self.url)
            update_dict = response.json().copy()
            status = response.status_code
        if status == 200:
            self._dic.update(update_dict)
            if extensions:
                self._extensions = self._dic.get('extensions', {})
                if self._extensions:
                    self.extensions = ExtensionsProxy(self._extensions,
                                                      auth=self._auth)
            self._update_dict = {}
        elif delete_on_not_found and status == 404:
            self.url = None
            self._dic = {}
            self = None
            del self
        else:
            raise NotFoundError(response.status_code, "Unable get object")

    def delete(self, key=None, tx=None):
        if key:
            return self.__delitem__(key, tx=tx)
        tx = Transaction.get_transaction(tx)
        if tx:
            return tx.append(TX_DELETE, self.url, obj=self)
        response = Request(**self._auth).delete(self.url)
        if response.status_code == 204:
            self.url = None
            self._dic = None
            self = None
            del self
        elif response.status_code == 404:
            raise NotFoundError(response.status_code,
                                "Node or property not found")
        else:
            raise StatusException(response.status_code,
                                  "Node could not be deleted (still has "
                                  "relationships?)")

    def __getitem__(self, key, tx=None):
        property_url = self._dic["property"].replace("{key}", smart_quote(key))
        tx = Transaction.get_transaction(tx)
        if tx:
            if isinstance(tx, QueryTransaction):
                return self._dic["data"][key]
            else:
                return tx.append(TX_GET, property_url, obj=self)
        response = Request(**self._auth).get(property_url)
        if response.status_code == 200:
            self._dic["data"][key] = response.json()
        else:
            if options.SMART_ERRORS:
                raise KeyError()
            else:
                raise NotFoundError(response.status_code,
                                    "Node or propery not found")
        if options.SMART_DATES:
            return Base._safe_string(self._dic["data"][key])
        else:
            return self._dic["data"][key]

    def get(self, key, *args, **kwargs):
        tx = kwargs.get("tx", None)
        try:
            return self.__getitem__(key, tx=tx)
        except (KeyError, NotFoundError, StatusException):
            if args:
                return args[0]
            elif "default" in kwargs:
                return kwargs["default"]
            elif options.SMART_ERRORS:
                raise KeyError(key)
            else:
                raise NotFoundError()

    def __contains__(self, obj):
        return obj in self._dic["data"]

    def __setitem__(self, key, value, tx=None):
        if value is None:
            self._dic["data"].update({key: value})
        else:
            if isinstance(key, (list, tuple)):
                tx = tx or key[1]
                key = key[0]
            if isinstance(value, Transaction):
                tx = tx or value
                value = value.get_value()
            property_url = self._dic["property"].replace("{key}",
                                                         smart_quote(key))
            tx = Transaction.get_transaction(tx)
            if tx:
                transaction_url = self._dic["property"].replace("{key}", "")
                return tx.append(TX_PUT, transaction_url, {key: value},
                                 obj=self)
            response = Request(**self._auth).put(property_url, data=value)
            if response.status_code == 204:
                if options.SMART_DATES:
                    self._dic["data"].update({key: Base._safe_string(value)})
                else:
                    self._dic["data"].update({key: value})
            elif response.status_code == 404:
                raise NotFoundError(response.status_code,
                                    "Node or property not found")
            else:
                msg = "Invalid data sent"
                try:
                    msg += ": " + response.json().get('message')
                except (ValueError, AttributeError, KeyError):
                    pass
                raise StatusException(response.status_code, msg)

    def set(self, key, value, tx=None):
        tx = Transaction.get_transaction(tx)
        if tx:
            return self.__setitem__(key, value, tx=tx)
        self.__setitem__(key, value)

    def __delitem__(self, key, tx=None):
        property_url = self._dic["property"].replace("{key}", smart_quote(key))
        tx = Transaction.get_transaction(tx)
        if tx:
            return tx.append(TX_DELETE, property_url, obj=self)
        response = Request(**self._auth).delete(property_url)
        if response.status_code == 204:
            del self._dic["data"][key]
        elif response.status_code == 404:
            if options.SMART_ERRORS:
                raise KeyError()
            else:
                raise NotFoundError(response.status_code,
                                    "Node or property not found")
        else:
            raise StatusException(response.status_code,
                                  "Node or property not found")

    def __len__(self):
        # This functions allows to eval nodes in "if" statements
        if "data" and self._dic:
            return len(self._dic["data"])
        else:
            return 0

    def __iter__(self):
        return self._dic["data"].__iter__()

    def __lt__(self, other):
        return (self.url < other.url)

    def __eq__(self, obj):
        if not self.url and not self._dic:
            return (obj is None)
        else:
            return (hasattr(obj, "url")
                    and self.url == obj.url
                    and hasattr(obj, "__class__")
                    and self.__class__ == obj.__class__)

    def __ne__(self, obj):
        if not self.url and not self._dic:
            return not (obj is None)
        else:
            return not (hasattr(obj, "url")
                        and self.url == obj.url
                        and hasattr(obj, "__class__")
                        and self.__class__ == obj.__class__)

    def __nonzero__(self):
        return bool(self._dic)

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        if not self.url and not self._dic:
            return None
        else:
            return u"<Neo4j %s: %s>" % (self.__class__.__name__, self.url)

    def _get_properties(self):
        if options.SMART_DATES:
            self._update_dict_data()
        return self._dic["data"]

    def _set_properties(self, props={}):
        if not props:
            return None
        properties_url = self._dic["properties"]
        response = Request(**self._auth).put(properties_url, data=props)
        if response.status_code == 204:
            self._dic["data"] = props.copy()
            self._update_dict_data()
            return props
        elif response.status_code == 400:
            msg = "Invalid data sent"
            try:
                msg += ": " + response.json().get('message')
            except (ValueError, AttributeError, KeyError):
                pass
            raise StatusException(response.status_code, msg)
        else:
            raise NotFoundError(response.status_code, "Properties not found")

    def _del_properties(self):
        properties_url = self._dic["properties"]
        response = Request(**self._auth).delete(properties_url)
        if response.status_code == 204:
            self._dic["data"] = {}
        else:
            raise NotFoundError(response.status_code, "Properties not found")
    # TODO: Create an own Property class to handle transactions
    properties = property(_get_properties, _set_properties, _del_properties)


class NodesProxy(dict):
    """
    Class proxy for node in order to allow get a node by id and
    create new nodes through calling.
    """

    def __init__(self, node, reference_node=None, node_index=None, auth=None,
                 cypher=None):
        self._node = node
        self._reference_node = reference_node
        self._node_index = node_index
        self._auth = auth or {}
        self._cypher = cypher

    def __call__(self, **kwargs):
        tx = Transaction.get_transaction(kwargs.get("tx", None))
        reference = kwargs.pop("reference", False)
        if reference and self._reference_node:
            return self.__getitem__(self._reference_node, tx=tx)
        else:
            return self.create(**kwargs)

    def __getitem__(self, key, tx=None):
        tx = Transaction.get_transaction(tx)
        if tx:
            if isinstance(key, string_types) and key.startswith(self._node):
                return tx.append(TX_GET, key, obj=self)
            else:
                return tx.append(TX_GET, "%s/%s/" % (self._node, key),
                                 obj=self)
        else:
            if isinstance(key, string_types) and key.startswith(self._node):
                return Node(key, auth=self._auth, cypher=self._cypher)
            else:
                return Node("%s/%s/" % (self._node, key), auth=self._auth,
                            cypher=self._cypher)

    def get(self, key, *args, **kwargs):
        tx = Transaction.get_transaction(kwargs.get("tx", None))
        try:
            return self.__getitem__(key, tx=tx)
        except (KeyError, NotFoundError, StatusException):
            if args:
                return args[0]
            elif "default" in kwargs:
                return kwargs["default"]
            else:
                raise NotFoundError()

    def create(self, **kwargs):
        tx = Transaction.get_transaction(kwargs.get("tx", None))
        if tx:
            if "tx" in kwargs and isinstance(kwargs["tx"], Transaction):
                x = kwargs.pop("tx", None)
                del x  # Makes pyflakes happy
            op = tx.append(TX_POST, self._node, data=kwargs, obj=self,
                           returns=NODE)
            return op
        else:
            return Node(self._node, create=True, data=kwargs, auth=self._auth,
                        cypher=self._cypher)

    def delete(self, key, tx=None):
        tx = Transaction.get_transaction(tx)
        if tx:
            return self.__getitem__(key, tx=tx)
        else:
            node = self.__getitem__(key)
            del node

    def filter(self, lookups=[], start=None):
        return elements_filter(self, lookups=lookups, start=start,
                               returns=Node)

    def all(self):
        return self.filter()

    def _indexes(self):
        if self._node_index:
            return IndexesProxy(self._node_index, NODE, auth=self._auth,
                                cypher=self._cypher)
    indexes = property(_indexes)


class Node(Base):
    """
    Node class.
    """

    def __getattr__(self, *args, **kwargs):
        """
        HACK: Allow to set node relationship
        """
        warnings.warn("Deprecated, in favor of pythonic style to declare "
                      "relationships: n2.relationships.create(rel_name, n2). "
                      "This is needed in order to handle pickling in nodes.",
                      DeprecationWarning)
        return self._create_relationship(*args, **kwargs)

    def _create_relationship(self, relationship_name, *args, **kwargs):
        def relationship(to, *args, **kwargs):
            tx = Transaction.get_transaction(kwargs.get("tx", None))
            create_relationship_url = self._dic["create_relationship"]
            # Check if target node doesn't exist yet
            if (isinstance(to, TransactionOperationProxy)
                    and not isinstance(to, Node)):
                to_url = "{%s}" % to()["id"]
            else:
                to_url = to.url
            data = {
                "to": to_url,
                "type": relationship_name,
            }
            if "tx" in kwargs and isinstance(kwargs["tx"], Transaction):
                x = kwargs.pop("tx", None)
                del x  # Makes pyflakes happy
            if kwargs:
                data.update({"data": kwargs})
            if tx:
                return tx.append(TX_POST, create_relationship_url,
                                 data=data, obj=self, returns=RELATIONSHIP)
            request = Request(**self._auth)
            response = request.post(create_relationship_url, data=data)
            if response.status_code == 201:
                update_dict = response.json()
                return Relationship(response.headers.get("location",
                                    response.headers.get("content-location")),
                                    auth=self._auth,
                                    update_dict=update_dict)
            elif response.status_code == 404:
                raise NotFoundError(
                    response.status_code,
                    "Node specified by the URI not of \"to\" node not found")
            else:
                msg = "Invalid data sent"
                try:
                    msg += ": " + response.json().get('message')
                except (ValueError, AttributeError, KeyError):
                    pass
                raise StatusException(response.status_code, msg)
        return relationship

    # Special methods for handle pickling manually
    def __getnewargs__(self):
        return tuple()

    def __getstate__(self):
        data = {}
        for key, value in self.__dict__.items():
            try:
                encoded = pickle.dumps(value)
            except pickle.PicklingError:
                encoded = pickle.dumps(pickle.Unpickable())
            data[key] = encoded
        return data

    def __setstate__(self, state):
        for key, value in state.items():
            self.__dict__[key] = pickle.loads(value)

    def _get_relationships(self):
        """
        HACK: Return a 3-methods class: incoming, outgoing and all.
        """
        return Relationships(self, auth=self._auth)
    relationships = property(_get_relationships)

    def _get_id(self):
        return int(self.url.split("/")[-1])
    id = property(_get_id)

    def __hash__(self):
        return hash(self.id)

    def items(self):
        try:
            return self._dic["data"].viewitems()
        except AttributeError:
            return self._dic["data"].items()

    def traverse(self, types=None, order=None, stop=None, returnable=None,
                 uniqueness=None, is_stop_node=None, is_returnable=None,
                 paginated=False, page_size=None, time_out=None,
                 returns=None):
        data = {}
        if order in (BREADTH_FIRST, DEPTH_FIRST):
            data.update({"order": order})
        if isinstance(stop, (int, float)):
            data.update({"max_depth": stop})
        elif stop == STOP_AT_END_OF_GRAPH:
            data.update({'prune_evaluator': {
                'language': 'javascript',
                'body': 'false',
            }})
        if returnable in (RETURN_ALL_NODES, RETURN_ALL_BUT_START_NODE):
            data.update({"return_filter": {
                "language": "builtin",
                "name": returnable,
            }})
        elif returnable:
            data.update({"return_filter": {
                "language": "javascript",
                "body": returnable,
            }})
        if uniqueness in (NODE_GLOBAL, NODE_PATH, NODE_RECENT, NODE,
                          RELATIONSHIP_GLOBAL, RELATIONSHIP_PATH,
                          RELATIONSHIP_RECENT, NONE):
            data.update({"uniqueness": uniqueness})
        if types:
            if not isinstance(types, (list, tuple)):
                types = [types]
            relationships = []
            for relationship in types:
                if relationship.direction == "both":
                    relationships.append({"type": relationship.type})
                else:
                    relationships.append({"type": relationship.type,
                                          "direction": relationship.direction})
            if relationships:
                data.update({"relationships": relationships})
        if returns not in (NODE, RELATIONSHIP, PATH, POSITION):
            returns = NODE
        if ((paginated or page_size or time_out)
                and "paged_traverse" in self._dic):
            traverse_params = []
            if page_size:
                traverse_params.append("pageSize=%s" % page_size)
            if time_out is not None:
                traverse_params.append("leaseTime=%d" % time_out)
            traverse_url = self._dic["paged_traverse"].replace("{returnType}",
                                                               returns)
            traverse_url = traverse_url.replace("{?pageSize,leaseTime}", "")
            if traverse_params:
                traverse_url = "%s?%s" % (traverse_url,
                                          "&".join(traverse_params))
            return PaginatedTraversal(traverse_url, returns, data=data,
                                      auth=self._auth, cypher=self._cypher)
        else:
            traverse_url = self._dic["traverse"].replace("{returnType}",
                                                         returns)
            response = Request(**self._auth).post(traverse_url, data=data)
            if response.status_code == 200:
                results_list = response.json()
                if returns == NODE:
                    return Iterable(Node, results_list, "self",
                                    auth=self._auth, cypher=self._cypher)
                elif returns == RELATIONSHIP:
                    return Iterable(Relationship, results_list, "self",
                                    auth=self._auth)
                elif returns == PATH:
                    return Iterable(Path, results_list, auth=self._auth)
                elif returns == POSITION:
                    return Iterable(Position, results_list, auth=self._auth)
            elif response.status_code == 404:
                raise NotFoundError(
                    response.status_code,
                    "Node or relationship not found"
                )
            else:
                msg = "Invalid data sent"
                try:
                    msg += ": " + response.json().get('message')
                except (ValueError, AttributeError, KeyError):
                    pass
                raise StatusException(response.status_code, msg)

    def _set_labels(self, labels):
        if not isinstance(labels, (tuple, list)):
            labels = [labels]
        self._labels = NodeLabelsProxy(self._dic['labels'], labels=labels,
                                       auth=self._auth, node=Node,
                                       cypher=self._cypher)

    def _get_labels(self):
        if not self._labels:
            self._labels = NodeLabelsProxy(self._dic['labels'],
                                           auth=self._auth, node=Node,
                                           cypher=self._cypher)
        return self._labels

    labels = property(_get_labels, _set_labels)


class PaginatedTraversal(object):
    """
    Class for paged traversals.
    """

    def __init__(self, url, returns, data=None, auth=None, cypher=None):
        self._auth = auth or {}
        self._cypher = cypher
        self.url = url
        self.returns = returns
        self.data = data
        self._results = []
        response = Request(**self._auth).post(self.url, data=self.data)
        if response.status_code == 201:
            self._results = response.json()
            self._next_url = response.headers.get(
                "location",
                response.headers.get("content-location")
            )
        else:
            self._next_url = None

    def __iter__(self):
        return self

    def __next__(self):
        if self._results:
            self._item = False
            if self.returns == NODE:
                results = Iterable(Node, self._results, "self",
                                   auth=self._auth, cypher=self._cypher)
            elif self.returns == RELATIONSHIP:
                results = Iterable(Relationship, self._results, "self",
                                   auth=self._auth)
            elif self.returns == PATH:
                results = Iterable(Path, self._results,
                                   auth=self._auth)
            elif self.returns == POSITION:
                results = Iterable(Position, self._results,
                                   auth=self._auth)
            self._results = []
            if self._next_url:
                response = Request(**self._auth).get(self._next_url)
                if response.status_code == 200:
                    self._results = response.json()
                    content_location = response.headers.get("content-location")
                    self._next_url = response.headers.get("location",
                                                          content_location)
                else:
                    self._next_url = None
            return results
        else:
            raise StopIteration

    def next(self):
        return self.__next__()


class IndexesProxy(dict):
    """
    Class proxy for indexes (nodes and relationships).
    """

    def __init__(self, index_url, index_for=NODE, auth=None, cypher=None):
        self._auth = auth or {}
        self._cypher = cypher
        self.url = index_url
        self._index_for = index_for
        self._dict = self._get_dict()

    def __getitem__(self, attr):
        return self._dict[attr]

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        return text_type(self._dict)

    def _get_dict(self):
        indexes_dict = {}
        response = Request(**self._auth).get(self.url)
        if response.status_code == 200:
            indexes_dict = response.json()
            for index_name, index_properties in indexes_dict.items():
                index_props = {}
                for key, val in index_properties.items():
                    index_props[str(key)] = val
                indexes_dict[index_name] = Index(self._index_for, index_name,
                                                 auth=self._auth,
                                                 cypher=self._cypher,
                                                 **index_props)
            return indexes_dict
        elif response.status_code == 404:
            raise NotFoundError(response.status_code, "Indexes not found")
        elif response.status_code == 204:
            return indexes_dict
        else:
            raise StatusException(response.status_code,
                                  "Error requesting indexes with GET %s"
                                  % self.url)

    def create(self, name, **config):
        tx = Transaction.get_transaction(config.pop("tx", None))
        if not config:
            config = {
                'type': INDEX_FULLTEXT,
                'provider': "lucene",
            }
        data = {
            'name': name,
            'config': config,
        }
        if tx:
            url = "/%s/%s" % (INDEX, self._index_for)
            if self._index_for == NODE:
                op = tx.append(TX_POST, url, data=data, obj=self,
                               returns=INDEX_NODE)
            else:
                op = tx.append(TX_POST, url, data=data, obj=self,
                               returns=INDEX_RELATIONSHIP)
            return op
        else:
            if name not in self._dict:
                response = Request(**self._auth).post(self.url, data=data)
                if response.status_code == 201:
                    loaded_dict = response.json()
                    result_dict = {}
                    for key, val in loaded_dict.items():
                        result_dict[str(key)] = val
                    self._dict[name] = Index(self._index_for, name,
                                             auth=self._auth,
                                             cypher=self._cypher,
                                             **result_dict)
                else:
                    msg = "Invalid data sent"
                    try:
                        msg += ": " + response.json().get('message')
                    except (ValueError, AttributeError, KeyError):
                        pass
                    raise StatusException(response.status_code, msg)
            return self._dict[name]

    def get(self, attr, *args, **kwargs):
        if attr in self._dict.keys():
            return self.__getitem__(attr)
        else:
            if args:
                return args[0]
            elif "default" in kwargs:
                return kwargs["default"]
            else:
                if options.SMART_ERRORS:
                    raise KeyError()
                else:
                    raise NotFoundError()

    def items(self):
        return self._dict.items()

    def values(self):
        return self._dict.values()

    def keys(self):
        return self._dict.keys()


class IndexKey(object):
    """
    Intermediate object so that lookups can be done like:
    index[key][value]

    Lookups are formated as http://.../{index_name}/{key}/{value}, so this
    is the object that gets returned by index[key]. The REST request will
    be sent when the value is specified.
    """

    def __init__(self, index_for, url, name, auth=None, cypher=None,
                 key=None, tx=None):
        self._auth = auth or {}
        self._cypher = cypher
        self._key = key
        self._index_for = index_for
        if url[-1] == '/':
            url = url[:-1]
        self.url = url
        self.name = name
        self.tx = tx

    def __getitem__(self, value):
        tx = None
        if isinstance(value, Transaction):
            tx = self.tx or value
            value = value.get_value()
        tx = Transaction.get_transaction(tx)
        url = "%s/%s" % (self.url, smart_quote(value))
        return Index._get_results(url, self._index_for, auth=self._auth,
                                  cypher=self._cypher, tx=tx)

    def __setitem__(self, value, item):
        tx = self.tx
        if isinstance(value, (list, tuple)):
            tx = tx or value[1]
            value = value[0]
        if isinstance(item, Transaction):
            tx = tx or item
            item = item.get_value()
        tx = Transaction.get_transaction(tx)
        # Neo4j hardly crush if you try to index a relationship in a
        # node index and viceversa.
        is_node_index = (self._index_for == NODE
                         and isinstance(item, Node))
        is_relationship_index = (self._index_for == RELATIONSHIP
                                 and isinstance(item, Relationship))
        if not (is_node_index or is_relationship_index
                or TransactionOperationProxy):
            raise TypeError("%s is a %s and the index is for %ss"
                            % (item, self._index_for.capitalize(),
                               self._index_for))
        if isinstance(item, Base):
            url_ref = item.url
        elif isinstance(item, TransactionOperationProxy):
            url_ref = "{%s}" % item()["id"]
        else:
            url_ref = item
        request_url_and_key = self.url.rsplit('/', 1)  # assumes a key
        if PY2:
            # It's URL encoded and we need Unicode
            key = unquote(text_type(request_url_and_key[1]).encode("utf8"))
        else:
            key = unquote(text_type(request_url_and_key[1]))
        data = {"key": key,
                "value": value,  # smart_quote is not needed anymore
                "uri": url_ref}
        if tx:
            request_url = "index/%s/%s" % (self._index_for, self.name)
            op = tx.append(TX_POST, request_url, data=data,
                           obj=self, returns=self._index_for)
            return op
        else:
            request = Request(**self._auth)
            response = request.post(request_url_and_key[0], data=data)
            if response.status_code == 201:
                # Returns object that was indexed
                entity = response.json()
                if self._index_for == NODE:
                    return Node(entity['self'], data=entity['data'],
                                auth=self._auth, update_dict=entity,
                                cypher=self._cypher)
                else:
                    return Relationship(entity['self'],
                                        data=entity['data'],
                                        auth=self._auth)
            else:
                raise StatusException(response.status_code,
                                      "Error requesting index with POST "
                                      "%s, data %s"
                                      % (request_url_and_key[0], url_ref))

    def query(self, value, tx=None):
        url = "%s?query=%s" % (self.url, smart_quote(value))
        return Index._get_results(url, self._index_for, auth=self._auth,
                                  cypher=self._cypher, tx=tx)

    def filter(self, lookups=[], value=None):
        return Index._filter(self, lookups, self._key, value)

    def all(self):
        return self.filter()


class Index(object):
    """
    key/value indexed lookups. Create an index object with GraphDatabase.index.
    The returned object supports dict style lookups, eg index[key][value].
    """

    @staticmethod
    def _get_results(url, node_or_rel, auth={}, cypher=None, tx=None):
        tx = Transaction.get_transaction(tx)
        if tx:
            return tx.append(TX_GET, url, obj=None, returns=ITERABLE,
                             of=node_or_rel)
        else:
            response = Request(**auth).get(url)
            if response.status_code == 200:
                data_list = response.json()
                if node_or_rel == NODE:
                    return Iterable(Node, data_list, "self", auth=auth,
                                    cypher=cypher)
                else:
                    return Iterable(Relationship, data_list, "self", auth=auth)
            elif response.status_code == 404:
                raise NotFoundError(response.status_code,
                                    "Node or relationship not found")
            else:
                raise StatusException(response.status_code,
                                      "Error requesting index with GET %s"
                                      % url)

    def __init__(self, index_for, name, auth=None, cypher=None, **kwargs):
        self._auth = auth or {}
        self._cypher = cypher
        self._index_for = index_for
        self.name = name
        self.template = kwargs.get("template")
        self.provider = kwargs.get("provider")
        self.type = kwargs.get("type")
        url = self.template.replace("{key}/{value}", "")
        if url[-1] == '/':
            url = url[:-1]
        self.url = url

    def __getitem__(self, key):
        if isinstance(key, (list, tuple)):
            tx = key[1]
            key = key[0]
        else:
            tx = None
        tx = Transaction.get_transaction(tx)
        return self.get(key, tx=tx)

    def __eq__(self, obj):
        if not self.url:
            return (obj is None)
        else:
            return (hasattr(obj, "url")
                    and self.url == obj.url
                    and hasattr(obj, "__class__")
                    and self.__class__ == obj.__class__)

    def __ne__(self, obj):
        if not self.url:
            return not (obj is None)
        else:
            return not (hasattr(obj, "url")
                        and self.url == obj.url
                        and hasattr(obj, "__class__")
                        and self.__class__ == obj.__class__)

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        return u"<Neo4j %s: %s>" % (self.__class__.__name__, self.url)

    def add(self, key, value, item, tx=None):
        self.get(key, tx=tx)[value] = item

    def get(self, key, value=None, tx=None):
        if isinstance(key, (list, tuple)):
            tx = tx or key[1]
            key = key[0]
        tx = Transaction.get_transaction(tx)
        index_key = IndexKey(self._index_for,
                             "%s/%s" % (self.url, smart_quote(key)),
                             name=self.name, auth=self._auth,
                             cypher=self._cypher, key=key, tx=tx)
        if value:
            return index_key[smart_quote(value)]
        else:
            return index_key

    def get_or_create(self, key, value, item=None, properties=None,
                      node_from=None, relationship_name=None, node_to=None,
                      tx=None):
        return self._uniqueness("get_or_create", key=key, value=value,
                                item=item, properties=properties,
                                node_from=node_from,
                                relationship_name=relationship_name,
                                node_to=node_to, tx=tx)

    def create_or_fail(self, key, value, item=None, properties=None,
                       node_from=None, relationship_name=None, node_to=None,
                       tx=None):
        return self._uniqueness("create_or_fail", key=key, value=value,
                                item=item, properties=properties,
                                node_from=node_from,
                                relationship_name=relationship_name,
                                node_to=node_to, tx=tx)

    def _uniqueness(self, uniqueness, key, value, item=None, properties=None,
                    node_from=None, relationship_name=None, node_to=None,
                    tx=None):
        url = "%s?uniqueness=%s" % (self.url, uniqueness)
        if item:
            properties = item.properties()
        elif not properties:
            properties = {}
        if self._index_for == NODE:
            data = {
                "key": key,
                "value": value,
                "properties": properties,
            }
        else:
            data = {
                "key": key,
                "value": value,
            }
            if properties:
                data.update({"properties": properties})
            if item:
                data.update({
                    "start": item.start,
                    "end": item.end,
                    "type": item.type,
                })
            else:
                data.update({
                    "start": node_from,
                    "end": node_to,
                    "type": relationship_name,
                })
        tx = Transaction.get_transaction(tx)
        if tx:
            op = tx.append(TX_POST, url, data=data, obj=self,
                           returns=self._index_for)
            return op
        else:
            index_for = self._index_for.capitalize()
            request = Request(**self._auth)
            response = request.post(url, data=data)
            if response.status_code in [200, 201]:
                # Returns object that was indexed
                entity = response.json()
                if self._index_for == NODE:
                    return Node(entity['self'], data=entity['data'],
                                auth=self._auth, update_dict=entity,
                                cypher=self._cypher)
                else:
                    return Relationship(entity['self'],
                                        data=entity['data'],
                                        auth=self._auth)
            elif response.status_code == 409:  # Create or fail, failing
                if options.SMART_ERRORS:
                    raise ValueError("duplicated item in index '%s'"
                                     % index_for)
                else:
                    raise StatusException(response.status_code,
                                          "Duplicated item")
            else:
                if options.SMART_ERRORS:
                    raise KeyError(index_for)
                else:
                    raise StatusException(response.status_code,
                                          "Duplicated item")

    def delete(self, key=None, value=None, item=None, tx=None):
        if not key and not value and not item:
            url = self.template.replace("/{key}/{value}", "")
        else:
            if not isinstance(item, Base):
                raise TypeError("%s has no url attribute" % item)
            if key and value:
                key = smart_quote(key)
                value = smart_quote(value)
                url = self.template.replace("{key}", key).replace("{value}",
                                                                  value)
                url = "%s/%s" % (url, item.id)
                request_url = "index/%s/%s/%s/%s/%s" \
                              % (self._index_for, self.name, key, value,
                                 item.id)
            elif key and not value:
                key = smart_quote(key)
                url = "%s/%s" % (self.template.replace("{key}/{value}", key),
                                 item.id)
                request_url = "index/%s/%s/%s/%s" \
                              % (self._index_for, self.name, key, item.id)
            elif not key and not value:
                url = self.template.replace("{key}/{value}", str(item.id))
                request_url = "index/%s/%s/%s" % (self._index_for, self.name,
                                                  item.id)
            else:
                raise TypeError("delete() takes at least 1 argument, the "
                                "%s to remove" % self._index_for)
        tx = Transaction.get_transaction(tx)
        if tx:
            return tx.append(TX_DELETE, request_url, obj=self)
        else:
            response = Request(**self._auth).delete(url)
            if response.status_code == 404:
                if options.SMART_ERRORS:
                    raise KeyError(self._index_for.capitalize())
                else:
                    index_for = self._index_for.capitalize()
                    raise NotFoundError(response.status_code,
                                        "%s not found" % index_for)
            elif response.status_code != 204:
                raise StatusException(response.status_code)

    def query(self, *args):
        """
        Query a fulltext index by key and query or just a plain Lucene query,

        i1 = gdb.nodes.indexes.get('people',type='fulltext', provider='lucene')
        i1.query('name','do*')
        i1.query('name:do*')

        In this example, the last two line are equivalent.
        """
        if not args or len(args) > 2:
            raise TypeError('query() takes 2 or 3 arguments (a query or a key '
                            'and a query) (%d given)' % (len(args) + 1))
        elif len(args) == 1:
            query, = args
            return self.get('text').query(text_type(query))
        else:
            key, query = args
            index_key = self.get(key)
            if isinstance(query, string_types):
                return index_key.query(query)
            else:
                if query.fielded:
                    raise ValueError('Queries with an included key should '
                                     'not include a field.')
                return index_key.query(text_type(query))

    def filter(self, lookups=[], key=None, value=None):
        return Index._filter(self, lookups, key, value)

    def all(self):
        return self.filter()

    @staticmethod
    def _filter(cls, lookups=[], key=None, value=None):
        if cls._cypher:
            if cls._index_for == NODE:
                start = u"node:"
                returns = Node
            elif cls._index_for == RELATIONSHIP:
                start = u"relationship:"
                returns = Relationship
            else:
                raise CypherException("Index not valid")
            index_name = Base._safe_string(cls.name)
            start = u"%s`%s`" % (start, index_name.replace("`", "\\`"))
            if key:
                key = Base._safe_string(key)
                if value:
                    value = Base._safe_string(value)
                    start = u"%s(\"%s:%s\")" % (start, key, value)
                else:
                    start = u"%s(\"%s:*\")" % (start, key)
            elif value:
                raise CypherException("Index key not valid")
            else:
                start = u"%s(\"*:*\")" % start
            if not isinstance(lookups, (list, tuple)):
                lookups = [lookups]
            types = {
                "node": Node,
                "relationship": Relationship,
                "path": Path,
                "position": Position,
            }
            return FilterSequence(cls._cypher, cls._auth, start=start,
                                  types=types, lookups=lookups,
                                  returns=returns)
        else:
            raise CypherException


class RelationshipsProxy(dict):
    """
    Class proxy for relationships in order to allow get a relationship by id
    and create new relationships through calling.
    """

    def __init__(self, relationship, relationship_index, auth=None,
                 cypher=None):
        self._auth = auth or {}
        self._cypher = cypher
        self._relationship = relationship
        self._relationship_index = relationship_index

    def __getitem__(self, key, tx=None):
        tx = Transaction.get_transaction(tx)
        if tx:
            return tx.append(TX_GET, "%s/%s" % (self._relationship, key),
                             obj=self)
        else:
            return Relationship("%s/%s" % (self._relationship, key),
                                auth=self._auth)

    def get(self, key, *args, **kwargs):
        tx = Transaction.get_transaction(kwargs.get("tx", None))
        try:
            return self.__getitem__(key, tx=tx)
        except (KeyError, NotFoundError, StatusException):
            if args:
                return args[0]
            elif "default" in kwargs:
                return kwargs["default"]
            else:
                raise NotFoundError()

    def create(self, node_from, relationship_name, node_to, **kwargs):
        return getattr(node_from, relationship_name)(node_to, **kwargs)

    def delete(self, key, tx=None):
        tx = Transaction.get_transaction(tx)
        if tx:
            return self.__getitem__(key, tx=tx)
        else:
            relationship = self.__getitem__(key)
            del relationship

    def filter(self, lookups=[], start=None):
        return elements_filter(self, lookups=lookups, start=start,
                               returns=Relationship)

    def all(self):
        return self.filter()

    def _indexes(self):
        if self._relationship_index:
            return IndexesProxy(self._relationship_index, RELATIONSHIP,
                                auth=self._auth, cypher=self._cypher)
    indexes = property(_indexes)


class Relationships(object):
    """
    Relationships class for a node.
    """

    def __init__(self, node, auth=None):
        self._auth = auth or {}
        self._node = node
        self._pattern = "{-list|&|types}"
        self._dict = {}
        self._len = 0

    def __getattr__(self, relationship_type):
        # auth = object.__getattribute__(self, "_auth")

        def get_relationships(types=None, *args, **kwargs):
            tx = Transaction.get_transaction(kwargs.get("tx", None))
            if relationship_type in ["all", "incoming", "outgoing"]:
                if types and isinstance(types, (tuple, list)):
                    key = "%s_typed_relationships" % relationship_type
                    url_string = self._node._dic[key]
                    url = url_string.replace(self._pattern, "&".join(types))
                else:
                    key = "%s_relationships" % relationship_type
                    url = self._node._dic[key]
                if tx:
                    return tx.append(TX_GET, url, obj=self)
                response = Request(**self._auth).get(url)
                if response.status_code == 200:
                    relationship_list = response.json()
                    relationships = Iterable(Relationship, relationship_list,
                                             "self", auth=self._auth)
                    # relationships = [Relationship(r["self"])
                    #                  for r in relationship_list]
                    self._dict[relationship_type] = relationships
                    return self._dict[relationship_type]
                elif response.status_code == 404:
                    if options.SMART_ERRORS:
                        return []
                    else:
                        raise NotFoundError(response.status_code,
                                            "Node or relationship not found")
                else:
                    if options.SMART_ERRORS:
                        raise KeyError("Node not found")
                    else:
                        raise StatusException(response.status_code,
                                              "Node not found")
            raise NameError("name %s is not defined" % relationship_type)

        return get_relationships

    def __len__(self, tx=None):
        tx = Transaction.get_transaction(tx)
        if tx:
            # We have to avoid a infinite recursion loop
            # return len(self.__getattr__("all")(tx=tx))
            pass
        elif "all" in self._dict:
            self._len = len(self._dict["all"])
        else:
            self._len = len(self.__getattr__("all")())
        return self._len

    def count(self, tx=None):
        return self.__len__(tx=tx)

    def __getitem__(self, index, tx=None):
        tx = Transaction.get_transaction(tx)
        return self.__getattr__("all")(tx=tx)[index]

    def create(self, relationship_name, to, **kwargs):
        # TODO: Improve the unicode checking
        try:
            return self._node._create_relationship(relationship_name)(to,
                                                                      **kwargs)
        except (KeyError, UnicodeEncodeError, UnicodeError):
            safe_name = smart_quote(relationship_name)
            return getattr(self._node, safe_name)(to, **kwargs)

    def get(self, index, tx=None):
        tx = Transaction.get_transaction(tx)
        return self.__getattr__(index, tx=tx)


class Relationship(Base):
    """
    Relationship class.
    """

    def _get_start(self):
        return Node(self._dic['start'], auth=self._auth, cypher=self._cypher)
    start = property(_get_start)

    def _get_end(self):
        return Node(self._dic['end'], auth=self._auth, cypher=self._cypher)
    end = property(_get_end)

    def _get_type(self):
        if PY2:
            return self._dic['type'].encode("utf8")
        else:
            return self._dic['type']
    type = property(_get_type)

    def _get_id(self):
        return int(self.url.split("/")[-1])
    id = property(_get_id)


class Path(object):
    """
    Path class for return type PATH in traversals.
    """

    def __init__(self, dic, auth=None, cypher=None):
        self._auth = auth or {}
        self._cypher = cypher
        self._dic = dic
        self._length = int(dic["length"])
        self._nodes = []
        self._relationships = []
        self._iterable = []
        self._start = Node(self._dic["start"], auth=self._auth,
                           cypher=self._cypher)
        self._end = Node(self._dic["end"], auth=self._auth,
                         cypher=self._cypher)
        for i in range(0, len(dic["relationships"])):
            node = Node(dic["nodes"][i], auth=self._auth, cypher=self._cypher)
            self._nodes.append(node)
            relationship = Relationship(dic["relationships"][i],
                                        auth=self._auth)
            self._relationships.append(relationship)
            self._iterable.append(node)
            self._iterable.append(relationship)
        node = Node(dic["nodes"][-1], auth=self._auth, cypher=self._cypher)
        self._nodes.append(node)
        self._iterable.append(node)

    def __len__(self):
        return self._length

    def __iter__(self):
        return iter(self._iterable)

    def _get_start(self):
        return self._start
    start = property(_get_start)

    def _get_end(self):
        return self._end
    end = property(_get_end)

    def _get_weight(self):
        return self._dic.get("weight", None)
    weight = property(_get_weight)

    def _get_nodes(self):
        return self._nodes
    nodes = property(_get_nodes)

    def _get_relationships(self):
        return self._relationships
    relationships = property(_get_relationships)

    def _get_last_relationship(self):
        return self._relationships[-1]
    last_relationship = property(_get_last_relationship)


class Position(object):
    """
    Position class for return type POSITION in traversals.
    """

    def __init__(self, dic, auth=None, cypher=None, **kwargs):
        self._auth = auth or {}
        self._cypher = cypher
        self._node = Node(dic["node"], auth=self._auth, cypher=self._cypher)
        self._depth = int(dic["depth"])
        relationship = Relationship(dic.get("last relationship",
                                    dic.get("last_relationship", None)),
                                    auth=self._auth)
        self._last_relationship = relationship
        self._path = Path(dic["path"], auth=self._auth, cypher=self._cypher)

    def _get_node(self):
        return self._node
    node = property(_get_node)

    def _get_depth(self):
        return self._depth
    depth = property(_get_depth)

    def _get_last_relationship(self):
        return self._last_relationship
    last_relationship = property(_get_last_relationship)

    def _get_path(self):
        return self._path
    path = property(_get_path)


class BaseInAndOut(object):
    """
    Base class for Incoming, Outgoing and Undirected relationships types.
    """

    def __init__(self, direction):
        self.direction = direction

    def get(self, attr):
        return self.__getattr__(attr)

    def __getattr__(self, attr):
        if self.direction == "both":
            warnings.warn("Deprecated, use \"All\" ('both') instead.",
                          DeprecationWarning)
        # Using an anonymous class
        direction = self.direction
        return type("", (object, ), {
            'direction': property(lambda self: direction),
            'type': property(lambda self: attr),
        })()

All = BaseInAndOut(direction=RELATIONSHIPS_ALL)
Incoming = BaseInAndOut(direction=RELATIONSHIPS_IN)
Outgoing = BaseInAndOut(direction=RELATIONSHIPS_OUT)
Undirected = BaseInAndOut(direction="both")  # Deprecated, use "All" instead


class Direction(object):
    ANY = All
    INCOMING = Incoming
    OUTGOING = Outgoing


class ExtensionModule(dict):
    def __init__(self, klass_name, auth):
        self.klass_name = klass_name
        self.auth = auth
        self.cache = {}

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        return u"<Neo4j %s: %s>" % (self.__class__.__name__,
                                    text_type(self.klass_name.keys()))

    def __getitem__(self, attr):
        return self.__getattr__(attr)

    def get(self, attr):
        return self.__getattr__(attr)

    def __getattr__(self, attr):
        if attr in self.cache:
            return self.cache[attr]
        else:
            self.cache[attr] = Extension(self.klass_name[attr], auth=self.auth)
            return self.cache[attr]


class ExtensionsProxy(dict):
    """
    Class proxy for extensions in order to allow get an extension by module
    and class name and executing with the right params through calling.
    """

    def __init__(self, extensions, auth=None, cypher=None):
        self._extensions = extensions
        self._dict = {}
        self._auth = auth or {}
        self._cypher = cypher

    def __getitem__(self, attr):
        return self.__getattr__(attr)

    def __getattr__(self, attr):
        if attr in self._dict:
            return self._dict[attr]
        self._dict[attr] = ExtensionModule(self._extensions[attr], self._auth)
        return self._dict[attr]

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        if not self._dict:
            self._dict = self._get_dict()
        return text_type(self._dict)

    def _get_dict(self):
        return dict([(key, self.__getattr__(key))
                     for key in self._extensions.keys()])

    def get(self, attr, *args, **kwargs):
        if attr in self._dict.keys():
            return self.__getattr__(attr)
        else:
            if args:
                return args[0]
            elif "default" in kwargs:
                return kwargs["default"]
            else:
                raise NotFoundError()

    def items(self):
        if not self._dict:
            self._dict = self._get_dict()
        return self._dict.items()

    def values(self):
        if not self._dict:
            self._dict = self._get_dict()
        return self._dict.values()

    def keys(self):
        if not self._dict:
            self._dict = self._get_dict()
        return self._dict.keys()

    # Special methods for handle pickling manually
    def __getnewargs__(self):
        return tuple()

    def __getstate__(self):
        data = {}
        for key, value in self.__dict__.items():
            try:
                encoded = pickle.dumps(value)
            except pickle.PicklingError:
                encoded = pickle.dumps(pickle.Unpickable())
            data[key] = encoded
        return data

    def __setstate__(self, state):
        for key, value in state.items():
            self.__dict__[key] = pickle.loads(value)


class Extension(object):
    """
    Extension class.
    """

    def __init__(self, url, auth=None, cypher=None):
        self._auth = auth or {}
        self._cypher = cypher
        self._dic = {}
        if url.endswith("/"):
            url = url[:-1]
        self.url = url
        response = Request(**self._auth).get(self.url)
        if response.status_code == 200:
            self._dic.update(response.json().copy())
            self.description = self._dic['description']
            self.name = self._dic['name']
            self.extends = self._dic['extends']
            self.parameters = self._dic['parameters']
        else:
            raise NotFoundError(response.status_code, "Unable get extension")

    def __call__(self, *args, **kwargs):
        # The returns param is a temporary solution while
        # a proper way to get the data type of returned values by
        # the extensions is implemented in Neo4j
        returns = kwargs.pop("returns", None)
        parameters = self._parse_parameters(args, kwargs)
        response = Request(**self._auth).post(self.url, data=parameters)
        if response.status_code == 200:
            result = response.json()
            # Another option is to inspect the results
            if not returns:
                if isinstance(result, (tuple, list)) and len(result) > 0:
                    returns = result[0].get("self", None)
                elif isinstance(result, dict) and "self" in result:
                    returns = result.get("self", None)
            if returns and RAW in returns:
                return result
            if isinstance(result, (tuple, list)) and returns:
                if NODE in returns:
                    return Iterable(Node, result, "self", auth=self._auth,
                                    cypher=self._cypher)
                elif RELATIONSHIP in returns:
                    return Iterable(Relationship, result, "self",
                                    auth=self._auth)
                elif PATH in returns or FULLPATH in returns:
                    return Iterable(Path, result, auth=self._auth)
                elif POSITION in returns:
                    return Iterable(Position, result, auth=self._auth)
            elif isinstance(result, dict) and returns:
                if NODE in returns:
                    return Node(result["self"], data=result, auth=self._auth,
                                cypher=self._cypher)
                elif RELATIONSHIP in returns:
                    return Relationship(result["self"], data=result,
                                        auth=self._auth, cypher=self._cypher)
                elif PATH in returns:
                    return Path(result, auth=self._auth, cypher=self._cypher)
                elif POSITION in returns:
                    return Position(result, auth=self._auth,
                                    cypher=self._cypher)
            elif result:
                return result
            else:
                return []
        elif response.status_code == 404:
            raise NotFoundError(response.status_code, "Extension not found")
        else:
            msg = "Invalid data sent"
            try:
                msg += ": " + response.json()['message']
            except (ValueError, AttributeError, KeyError, TypeError):
                pass
            raise StatusException(response.status_code, msg)

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        return u"<Neo4j %s: %s>" % (self.__class__.__name__, self.url)

    def _parse_parameters(self, args, kwargs):
        if not args and not kwargs:
            return kwargs
        params_len = len(self.parameters)
        args_len = len(args)
        kwargs_len = len(kwargs)
        if args_len + kwargs_len > params_len:
            raise TypeError("%s() take at most %s arguments (%s given)"
                            % (self.name, params_len, args_len + kwargs_len))
        required = [np for np in self.parameters if np["optional"] is False]
        required_len = len(required)
        if args_len + kwargs_len < required_len:
            raise TypeError("%s() take at least %s arguments (%s given)"
                            % (self.name, required_len, args_len + kwargs_len))
        params_kwargs = {}
        if args:
            for i, arg in enumerate(args):
                key = required[i]["name"]
                params_kwargs[key] = args[i]
        if kwargs:
            for param, value in kwargs.items():
                has_param = (len([np for np in self.parameters
                                  if np["name"] == param]) != 0)
                if param not in params_kwargs and has_param:
                    params_kwargs[param] = value
        return self._parse_types(params_kwargs)

    def _parse_types(self, kwargs):
        params_kwargs = {}
        for param, value in kwargs.items():
            if isinstance(value, Base):
                params_kwargs[param] = value.url
            else:
                params_kwargs[param] = value
        return params_kwargs


def elements_filter(cls, lookups=[], start=None, returns=None):
    if isinstance(start, (Index, IndexKey)):
        return start.filter(lookups=lookups)
    elif cls._cypher:
        if start:
            starts = []
            if not isinstance(start, (list, tuple)):
                start = [start]
            for start_element in start:
                try:
                    starts.append(text_type(start_element.id))
                except AttributeError:
                    starts.append(text_type(start_element))
        else:
            starts = u"*"
        if returns is Node:
            start = u"node(%s)" % u", ".join(starts)
        elif returns is Relationship:
            start = u"rel(%s)" % u", ".join(starts)
        else:
            raise CypherException
        if not isinstance(lookups, (list, tuple)):
            lookups = [lookups]
        types = {
            "node": Node,
            "relationship": Relationship,
            "path": Path,
            "position": Position,
        }
        return FilterSequence(cls._cypher, cls._auth, start=start,
                              types=types, lookups=lookups, returns=returns)
    else:
        raise CypherException

########NEW FILE########
__FILENAME__ = constants
# -*- coding: utf-8 -*-
__author__ = "Javier de la Rosa"
__license__ = "GPL 3"
__version__ = "2.0.3"
__email__ = "versae@gmail.com"
__url__ = "https://github.com/versae/neo4j-rest-client"
__description__ = """Object-oriented Python library to interact with """ \
                  """Neo4j standalone REST server"""
__status__ = "Stable"
# Order
BREADTH_FIRST = "breadth_first"
DEPTH_FIRST = "depth_first"
# Relationships
RELATIONSHIPS_ALL = "all"
RELATIONSHIPS_IN = "in"
RELATIONSHIPS_OUT = "out"
# Return
RETURN_ALL_NODES = "all"
RETURN_ALL_BUT_START_NODE = "all_but_start_node"
# Stop
STOP_AT_DEPTH_ONE = 1
STOP_AT_END_OF_GRAPH = "none"
# Uniqueness
NONE = "none"
NODE_GLOBAL = "node_global"
NODE_PATH = "node_path"
NODE_RECENT = "node recent"  # Deprecated
RELATIONSHIP_GLOBAL = "relationship_global"
RELATIONSHIP_PATH = "relationship_path"
RELATIONSHIP_RECENT = "relationship recent"  # Deprecated
# Returns
NODE = "node"
RELATIONSHIP = "relationship"
PATH = "path"
FULLPATH = "fullpath"
POSITION = "position"
RAW = "raw"
ITERABLE = "iterable"
# Indexes
INDEX = "index"
INDEX_NODE = "index_node"
INDEX_RELATIONSHIP = "index_relationship"
INDEX_EXACT = "exact"
INDEX_FULLTEXT = "fulltext"
# Cypher ordering
ASC = "asc"
DESC = "desc"
# Transactions
TX_GET = "GET"
TX_PUT = "PUT"
TX_POST = "POST"
TX_DELETE = "DELETE"

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-


class StatusException(IOError):
    """
    Create an Error Response.
    """

    def __init__(self, value, result=None):
        self.value = value
        self.responses = {
            100: ('Continue',
                  'Request received, please continue'),
            101: ('Switching Protocols',
                  'Switching to new protocol; obey Upgrade header'),
            200: ('OK',
                  'Request fulfilled, document follows'),
            201: ('Created',
                  'Document created, URL follows'),
            202: ('Accepted',
                  'Request accepted, processing continues off-line'),
            203: ('Non-Authoritative Information',
                  'Request fulfilled from cache'),
            204: ('No Content',
                  'Request fulfilled, nothing follows'),
            205: ('Reset Content',
                  'Clear input form for further input.'),
            206: ('Partial Content',
                  'Partial content follows.'),
            300: ('Multiple Choices',
                  'Object has several resources -- see URI list'),
            301: ('Moved Permanently',
                  'Object moved permanently -- see URI list'),
            302: ('Found',
                  'Object moved temporarily -- see URI list'),
            303: ('See Other',
                  'Object moved -- see Method and URL list'),
            304: ('Not Modified',
                  'Document has not changed since given time'),
            305: ('Use Proxy',
                  'You must use proxy specified in Location to access this '
                  'resource.'),
            307: ('Temporary Redirect',
                  'Object moved temporarily -- see URI list'),
            400: ('Bad Request',
                  'Bad request syntax or unsupported method'),
            401: ('Unauthorized',
                  'No permission -- see authorization schemes'),
            402: ('Payment Required',
                  'No payment -- see charging schemes'),
            403: ('Forbidden',
                  'Request forbidden -- authorization will not help'),
            404: ('Not Found',
                  'Nothing matches the given URI'),
            405: ('Method Not Allowed',
                  'Specified method is invalid for this server.'),
            406: ('Not Acceptable',
                  'URI not available in preferred format.'),
            407: ('Proxy Authentication Required',
                  'You must authenticate with '
                  'this proxy before proceeding.'),
            408: ('Request Timeout',
                  'Request timed out; try again later.'),
            409: ('Conflict',
                  'Request conflict.'),
            410: ('Gone',
                  'URI no longer exists and has been permanently removed.'),
            411: ('Length Required',
                  'Client must specify Content-Length.'),
            412: ('Precondition Failed',
                  'Precondition in headers is false.'),
            413: ('Request Entity Too Large',
                  'Entity is too large.'),
            414: ('Request-URI Too Long',
                  'URI is too long.'),
            415: ('Unsupported Media Type',
                  'Entity body in unsupported format.'),
            416: ('Requested Range Not Satisfiable',
                  'Cannot satisfy request range.'),
            417: ('Expectation Failed',
                  'Expect condition could not be satisfied.'),
            418: ('I\'m a teapot',
                  'Is the server running?'),
            500: ('Internal Server Error',
                  'Server got itself in trouble'),
            501: ('Not Implemented',
                  'Server does not support this operation'),
            502: ('Bad Gateway',
                  'Invalid responses from another server/proxy.'),
            503: ('Service Unavailable',
                  'The server cannot process the request due to a high load'),
            504: ('Gateway Timeout',
                  'The gateway server did not receive a timely response'),
            505: ('HTTP Version Not Supported',
                  'Cannot fulfill request.'),
        }
        if result:
            self.result = "\n%s" % result
        else:
            self.result = None  # pedantic, but needed for __str__()

    def __str__(self):
        return u"Code [%s]: %s. %s.%s" % (self.value,
                                          self.responses[self.value][0],
                                          self.responses[self.value][1],
                                          self.result)

    def __unicode__(self):
        return self.__str__()


class TransactionException(StatusException):

    def __init__(self, value=None, message=None):
        if message is None:
            message = "Element not found"
        super(TransactionException, self).__init__(value, message)


class NotFoundError(StatusException):

    def __init__(self, value=None, result=None):
        if not value:
            value = 404
        if not result:
            result = "Node, relationship or property not found"
        super(NotFoundError, self).__init__(value, result)

########NEW FILE########
__FILENAME__ = iterable
# -*- coding: utf-8 -*-


class Iterable(list):
    """
    Class to iterate among returned objects.
    """

    def __init__(self, cls, lst, attr=None, auth=None, cypher=None):
        self._auth = auth or {}
        self._cypher = cypher
        self._list = lst
        self._index = len(lst)
        self._class = cls
        self._attribute = attr
        super(Iterable, self).__init__(lst)

    def __getslice__(self, *args, **kwargs):
        eltos = super(Iterable, self).__getslice__(*args, **kwargs)
        if self._attribute:
            return [self._class(elto[self._attribute], update_dict=elto,
                                auth=self._auth, cypher=self._cypher)
                    for elto in eltos]
        else:
            return [self._class(elto, auth=self._auth, cypher=self._cypher)
                    for elto in eltos]

    def __getitem__(self, index):
        elto = super(Iterable, self).__getitem__(index)
        if self._attribute:
            return self._class(elto[self._attribute], update_dict=elto,
                               auth=self._auth, cypher=self._cypher)
        else:
            return self._class(elto, auth=self._auth, cypher=self._cypher)

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        return u"<Neo4j %s: %s>" % (self.__class__.__name__,
                                    self._class.__name__)

    def __contains__(self, value):
        # TODO: Find a better way to check if value is instance of Base
        #       avoiding a circular loop of imports
        # if isinstance(value, Base) and hasattr(value, "url"):
        if (hasattr(value, "url") and hasattr(value, "id")
                and hasattr(value, "_dic")):
            if self._attribute:
                return value.url in [elto[self._attribute]
                                     for elto in self._list]
            else:
                return value.url in self._list
        return False

    def __iter__(self):
        return self

    @property
    def single(self):
        try:
            return self[0]
        except KeyError:
            return None

    def __next__(self):
        if self._index == 0:
            raise StopIteration
        self._index = self._index - 1
        return self.__getitem__(self._index)

    def next(self):
        return self.__next__()

########NEW FILE########
__FILENAME__ = labels
# -*- coding: utf-8 -*-
import json

from neo4jrestclient import options
from neo4jrestclient.iterable import Iterable
from neo4jrestclient.request import Request
from neo4jrestclient.exceptions import StatusException
from neo4jrestclient.query import FilterSequence
from neo4jrestclient.utils import smart_quote, text_type


class Label(object):

    def __init__(self, url, label, auth=None, cypher=None, node=None):
        self._url = url
        self._label = label
        self._auth = auth
        self._cypher = cypher
        self._node_cls = node
        # Check URLs like http://localhost:7474/db/data/node/27530/labels
        url_split = self._url.rsplit("/", 3)
        if url_split[1] == 'node':
            self._url = u"{}/labels".format(url_split[0])

    def __eq__(self, obj):
        try:
            return obj._label == self._label
        except AttributeError:
            return text_type(obj) == self._label

    def __hash__(self):
        return self._label.__hash__()

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        return u"<Neo4j {}: {}>".format(self.__class__.__name__,
                                        self._label.__repr__())

    def add(self, *nodes):
        for node in nodes:
            node.labels.add(self._label)

    def get(self, **kwargs):
        data = u""
        if kwargs:
            data = []
            for k, v in kwargs.items():
                data.append("{}={}".format(smart_quote(k),
                                           smart_quote(json.dumps(v))))
            data = u"?{}".format(u"&".join(data))
        url = self._url.replace(
            u"labels",
            u"label/{}/nodes{}".format(smart_quote(self._label), data))
        response = Request(**self._auth).get(url)
        if response.status_code == 200:
            results_list = response.json()
            if not results_list:
                return []
            elif isinstance(results_list, (tuple, list)):
                return Iterable(self._node_cls, results_list, "self",
                                auth=self._auth)
        else:
            msg = "Unable to read label(s)"
            try:
                msg += ": " + response.json().get('message')
            except (ValueError, AttributeError, KeyError):
                pass
            raise StatusException(response.status_code, msg)

    def all(self):
        return self.get()

    def single(self):
        return self.filter()[0]

    def filter(self, *lookups):
        if not isinstance(lookups, (list, tuple)):
            lookups = [lookups]
        match = u"(n:`{}`)".format(self._label.replace("`", "\\`"))
        returns = self._node_cls
        types = {
            "node": self._node_cls,
        }
        return FilterSequence(self._cypher, self._auth, start=None,
                              matches=[match], types=types, lookups=lookups,
                              returns=returns)


class BaseLabelsProxy(object):
    """
    Base class proxy for labels.
    """

    def __init__(self, url, labels=None, auth=None, cypher=None, node=None):
        self._url = url
        self._labels = labels
        self._auth = auth or {}
        self._cypher = cypher
        self._node_cls = node
        if self._labels:
            labels = set()
            for label in self._labels:
                if isinstance(label, Label):
                    labels.add(label)
                else:
                    labels.add(Label(self._url, label, auth=self._auth,
                                     cypher=self._cypher, node=self._node_cls))
            self._labels = labels
        if not self._labels:
            self._labels = self._update_labels()

    def _update_labels(self):
        response = Request(**self._auth).get(self._url)
        if response.status_code == 200:
            results_list = response.json()
            return set([Label(self._url, label, auth=self._auth,
                              cypher=self._cypher, node=self._node_cls)
                        for label in results_list])
        else:
            msg = "Unable to get labels"
            try:
                msg += ": " + response.json().get('message')
            except (ValueError, AttributeError, KeyError):
                pass
            raise StatusException(response.status_code, msg)

    def get(self, key, **kwargs):
        if not isinstance(key, Label):
            key = Label(self._url, key, auth=self._auth, cypher=self._cypher,
                        node=self._node_cls)
        if key in self._labels:
            return key
        elif "default" in kwargs:
            return kwargs["default"]
        else:
            raise KeyError(key._label)

    def __getitem__(self, key):
        return self.get(key)

    def __len__(self):
        return len(self._labels)

    def __iter__(self):
        return iter(self._labels)

    def __repr__(self):
        return self.__unicode__()

    def __str__(self):
        return self.__unicode__()

    def __unicode__(self):
        return text_type(self._labels)

    def __contains__(self, key):
        return key in self._labels

    def __eq__(self, obj):
        try:
            return obj._labels == self._labels
        except AttributeError:
            return set(obj) == self._labels

    def __or__(self, obj):
        try:
            return obj._labels | self._labels
        except AttributeError:
            return set(obj) | self._labels


class LabelsProxy(BaseLabelsProxy):
    """
    Class proxy for labels the GraphDatabase object.
    """

    def create(self, label):
        return Label(self._url, label, auth=self._auth, cypher=self._cypher,
                     node=self._node_cls)


class NodeLabelsProxy(BaseLabelsProxy):
    """
    Class proxy for node labels.
    """

    def add(self, labels):
        single = False
        if not isinstance(labels, (tuple, list)):
            labels = [labels]
            single = True
        response = Request(**self._auth).post(self._url, data=labels)
        added = set()
        if response.status_code == 204:
            for label in labels:
                _label = label
                if not isinstance(_label, Label):
                    _label = Label(self._url, label, auth=self._auth,
                                   cypher=self._cypher, node=self._node_cls)
                if _label not in self._labels:
                    self._labels.add(_label)
                    added.add(_label)
        else:
            msg = "Unable to add label"
            try:
                msg += ": " + response.json().get('message')
            except (ValueError, AttributeError, KeyError):
                pass
            raise StatusException(response.status_code, msg)
        if single:
            return added.pop()
        else:
            return added

    def remove(self, label):
        self._discard(label, return_label=False, raise_error=True)

    def discard(self, label):
        self._discard(label, return_label=False, raise_error=False)

    def pop(self, label=None):
        return self._discard(label, return_label=True, raise_error=True)

    def clear(self):
        for label in self._labels:
            self._discard(label, return_label=False, raise_error=False)

    def _discard(self, label=None, return_label=False, raise_error=False):
        if not label:
            label = self._labels.pop()
        url = "{}/{}".format(self._url, smart_quote(label))
        response = Request(**self._auth).delete(url)
        if response.status_code == 204:
            _label = label
            if not isinstance(_label, Label):
                _label = Label(self._url, label)
            if _label in self._labels:
                self._labels.remove(_label)
            if return_label:
                return _label
        elif raise_error:
            if options.SMART_ERRORS:
                raise KeyError("'{}' not found".format(_label))
            else:
                msg = "Unable to remove label"
                try:
                    msg += ": " + response.json().get('message')
                except (ValueError, AttributeError, KeyError):
                    pass
                raise StatusException(response.status_code, msg)

########NEW FILE########
__FILENAME__ = options
# -*- coding: utf-8 -*-
# Request
CACHE = False
CACHE_STORE = '.cache'
DEBUG = False
# Smart errors
SMART_ERRORS = False
# Smart dates
SMART_DATES = False
DATE_FORMAT = "%Y-%m-%d"
TIME_FORMAT = "%H:%M:%S.%f"
DATETIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%f"
# Transactions
TX_NAME = "_tx"
# Verify SSL
VERIFY_SSL = False

########NEW FILE########
__FILENAME__ = query
# -*- coding: utf-8 -*-
# Inspired by: https://github.com/CulturePlex/Sylva
#                     /tree/master/sylva/engines/gdb/lookups
import json
import uuid
from collections import Sequence
import warnings

from neo4jrestclient.constants import RAW
from neo4jrestclient.request import Request
from neo4jrestclient.exceptions import StatusException, TransactionException
from neo4jrestclient.utils import text_type, string_types, in_ipnb


class BaseQ(object):
    # Based on: https://github.com/scholrly/lucene-querybuilder
    #                  /blob/master/lucenequerybuilder/query.py
    """
    Q is a query builder for the Neo4j Cypher language backend

    It allows to build filters like
    Q("Artwork title", istartswith="copy", nullable=False)
    Q(property="Artwork title", lookup="istartswith", match="copy")
    """

    matchs = ("exact", "iexact",
              "contains", "icontains",
              "startswith", "istartswith",
              "endswith", "iendswith",
              "regex", "iregex",
              "gt", "gte", "lt", "lte",
              "in", "inrange", "isnull",
              "eq", "equals", "neq", "notequals")

    def __init__(self, property=None, lookup=None, match=None,
                 nullable=None, var=u"n", **kwargs):
        self._and = None
        self._or = None
        self._not = None
        self.property = property
        self.lookup = lookup
        self.match = match
        self.nullable = nullable
        self.var = var
        if property and (not self.lookup or self.match is None):
            for m in self.matchs:
                if m in kwargs:
                    self.lookup = m
                    self.match = kwargs[m]
                    break
            else:
                all_matchs = ", ".join(self.matchs)
                raise ValueError("Q objects must have at least a lookup method"
                                 " (%s) and a match case".format(all_matchs))

    def is_valid(self):
        return ((self.property and self.lookup and self.match is not None) or
                (self._and or self._or or self._not))

    def _make_and(q1, q2):
        q = q1.__class__()
        q._and = (q1, q2)
        return q

    def _make_not(q1):
        q = q1.__class__()
        q._not = q1
        return q

    def _make_or(q1, q2):
        q = q1.__class__()
        q._or = (q1, q2)
        return q

    def __and__(self, other):
        return BaseQ._make_and(self, other)

    def __or__(self, other):
        return BaseQ._make_or(self, other)

    def __invert__(self):
        return BaseQ._make_not(self)

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __hash__(self):
        return hash((self.property, self.lookup, self.match,
                     self.nullable))

    def get_query_objects(self, var=None, prefix=None, params=None,
                          version=None):
        """
        :return query, params: Query string and a dictionary for lookups
        """
        raise NotImplementedError("Method has to be implemented")

    def __repr__(self):
        return self.__str__()

    def __str__(self):
        return self.__unicode__().encode('utf-8')

    def __unicode__(self):
        query, params = self.get_query_objects()
        return query.format(**params)


class Q(BaseQ):

    def _escape(self, s):
        return s

    def _get_lookup_and_match(self):
        if self.lookup == "exact":
            lookup = u"="
            match = u"{0}".format(self.match)
        elif self.lookup == "iexact":
            lookup = u"=~"
            match = u"(?i){0}".format(self.match)
        elif self.lookup == "contains":
            lookup = u"=~"
            match = u".*{0}.*".format(self.match)
        elif self.lookup == "icontains":
            lookup = u"=~"
            match = u"(?i).*{0}.*".format(self.match)
        elif self.lookup == "startswith":
            lookup = u"=~"
            match = u"{0}.*".format(self.match)
        elif self.lookup == "istartswith":
            lookup = u"=~"
            match = u"(?i){0}.*".format(self.match)
        elif self.lookup == "endswith":
            lookup = u"=~"
            match = u".*{0}".format(self.match)
        elif self.lookup == "iendswith":
            lookup = u"=~"
            match = u"(?i).*{0}".format(self.match)
        elif self.lookup == "regex":
            lookup = u"=~"
            match = u"{0}".format(self.match)
        elif self.lookup == "iregex":
            lookup = u"=~"
            match = u"(?i){0}".format(self.match)
        elif self.lookup == "gt":
            lookup = u">"
            match = self.match
        elif self.lookup == "gte":
            lookup = u">="
            match = self.match
        elif self.lookup == "lt":
            lookup = u"<"
            match = self.match
        elif self.lookup == "lte":
            lookup = u"<="
            match = self.match
        elif self.lookup in ["in", "inrange"]:
            lookup = u"IN"
            matchs = []
            for list_item in self.match:
                if isinstance(list_item, string_types):
                    item = self._escape(list_item)
                else:
                    item = list_item
                matchs.append(item)
            match = matchs
        elif self.lookup == "isnull":
            if self.match:
                lookup = u"is"
            else:
                lookup = u"is not"
            match = u"NULL"
        elif self.lookup in ["eq", "equals"]:
            lookup = u"="
            if isinstance(self.match, string_types):
                match = u"'{0}'".format(self._escape(self.match))
            else:
                match = self.match
        elif self.lookup in ["neq", "notequals"]:
            lookup = u"<>"
            if isinstance(self.match, string_types):
                match = u"'{0}'".format(self._escape(self.match))
            else:
                match = self.match
        else:
            lookup = self.lookup
            match = u""
        return lookup, match

    def get_query_objects(self, var=None, prefix=None, params=None,
                          version=None):
        if var:
            self.var = var
        if not params:
            params = {}
        if not prefix:
            prefix = u""
        else:
            params.update(params)
        if self._and is not None:
            left_and = self._and[0].get_query_objects(params=params,
                                                      version=version)
            params.update(left_and[1])
            right_and = self._and[1].get_query_objects(params=params,
                                                       version=version)
            params.update(right_and[1])
            if self._and[0].is_valid() and self._and[1].is_valid():
                query = u"( {0} AND {1} )".format(left_and[0], right_and[0])
            elif self._and[0].is_valid() and not self._and[1].is_valid():
                query = u" {0} ".format(left_and[0])
            elif not self._and[0].is_valid() and self._and[1].is_valid():
                query = u" {0} ".format(right_and[0])
            else:
                query = u" "
        elif self._not is not None:
            op_not = self._not.get_query_objects(params=params,
                                                 version=version)
            params.update(op_not[1])
            query = u"NOT ( {0} )".format(op_not[0])
        elif self._or is not None:
            left_or = self._or[0].get_query_objects(params=params,
                                                    version=version)
            params.update(left_or[1])
            right_or = self._or[1].get_query_objects(params=params,
                                                     version=version)
            params.update(right_or[1])
            if self._or[0].is_valid() and self._or[1].is_valid():
                query = u"( {0} OR {1} )".format(left_or[0], right_or[0])
            elif self._or[0].is_valid() and not self._or[1].is_valid():
                query = u" {0} ".format(left_or[0])
            elif not self._or[0].is_valid() and self._or[1].is_valid():
                query = u" {0} ".format(right_or[0])
            else:
                query = u" "
        else:
            query = u""
            lookup, match = self._get_lookup_and_match()
        if self.property is not None and self.var is not None:
            key = u"{0}p{1}".format(prefix, len(params))
            prop = text_type(self.property).replace(u"`", u"\\`")
            NEO4J_V2 = version and version.split(".")[0] >= "2"
            if not NEO4J_V2 and self.nullable is None:
                # Backwards compatibility for Neo5j versions prior 2.0
                self.nullable = True
            if self.lookup == 'isnull':
                query_format = ("{0}.`{1}` {2} NULL")
                query = query_format.format(self.var, prop, lookup)
            elif NEO4J_V2 and self.nullable is not None:
                warnings.warn("Deprecated, Neo4j +2.0.0 does not support "
                              "the use of 'nullable' ('!' and '?' operators).",
                              DeprecationWarning)
                if self.nullable is True:
                    try:
                        query_format = (u"(has({0}.`{1}`) and {2}.`{3}` "
                                        u"{4} {{{5}}})")
                        query = query_format.format(self.var, prop,
                                                    self.var, prop,
                                                    lookup, key)
                    except AttributeError:
                        query = (u"( has(%s.`%s`) and %s.`%s` %s {%s} )"
                                 % (self.var, prop, self.var, prop, lookup,
                                    key))
                elif self.nullable is False:
                    try:
                        query_format = (u"(not(has({0}.`{1}`)) or {2}.`{3}` "
                                        u"{4} {{{5}}})")
                        query = query_format.format(self.var, prop,
                                                    self.var, prop,
                                                    lookup, key)
                    except AttributeError:
                        query = (u"( not(has(%s.`%s`)) or %s.`%s` %s {%s} )"
                                 % (self.var, prop, self.var, prop, lookup,
                                    key))
            else:
                if NEO4J_V2:
                    nullable = u""
                elif self.nullable is True:
                    nullable = u"!"
                elif self.nullable is False:
                    nullable = u"?"
                else:
                    nullable = u""
                try:
                    query_format = u"{0}.`{1}`{2} {3} {{{4}}}"
                    query = query_format.format(self.var, prop, nullable,
                                                lookup, key)
                except AttributeError:
                    query = u"%s.`%s`%s %s {%s}" % (self.var, prop,
                                                    nullable, lookup, key)
            params[key] = match
        return query, params


class CypherException(Exception):
    pass


class QuerySequence(Sequence):

    def __init__(self, cypher, auth, q, params=None, types=None, returns=None,
                 lazy=False, tx=None):
        self.q = q
        self.params = params
        self.columns = None
        self._skip = None
        self._limit = None
        self._order_by = None
        self._returns = returns
        self._return_single_rows = False
        self._auth = auth
        self._cypher = cypher
        # This way we avoid a circular reference, by passing objects like Node
        self._types = types or {}
        self._elements = None
        # Store rows and graphs information
        self._elements_row = None
        self._elements_graph = None
        if tx:
            tx.append(q=self.q, params=self.params, returns=self._returns,
                      obj=self)
            tx.execute()
        elif not lazy:
            self._get_elements()

    def _get_elements(self):
        if self._elements is None:
            response = self.get_response()
            try:
                self._elements = QuerySequence.cast(
                    self, elements=response["data"], returns=self._returns
                )
                self.columns = response.get("columns", None)
            except:
                self._elements = response
        return self._elements
    elements = property(_get_elements)

    def __getitem__(self, key):
        return self.elements[key]

    def __contains__(self, item):
        return item in self.elements

    def __iter__(self):
        return (e for e in self.elements)

    def __len__(self):
        return len(self.elements)

    def __reversed__(self):
        return reversed(self.elements)

    def _repr_html_(self):
        return self.to_html()

    def to_html(self, title=None, width=None, height=None):
        html = self._plot_graph(
            self._elements_graph,
            title=title,
            width=width,
            height=height,
        )
        return html

    def _transform_graph_to_d3(self, graph):
        nodes = {}
        links = []
        links_ids = set()
        properties = set()
        for node_dict in graph:
            for node in node_dict.get('nodes', []):
                node_id = node.get('id', len(nodes))
                if node_id not in nodes:
                    node_properties = node.get('properties', {})
                    nodes.update({
                        node_id: {
                            'fill': 'white',
                            'id': node_id,
                            'label': node_id,
                            'properties': node_properties
                        }
                    })
                    properties.update(node_properties.keys())
            for relationship in node_dict.get('relationships', []):
                link_id = relationship.get('id', len(links_ids))
                if (link_id not in links_ids
                        and 'startNode' in relationship
                        and 'endNode' in relationship):
                    rel_properties = relationship.get('properties', {})
                    links.append({
                        'id': link_id,
                        'source': relationship.get('startNode'),
                        'stroke': 'black',
                        'target': relationship.get('endNode'),
                        'label': relationship.get('type'),
                        'properties': rel_properties,
                    })
                    links_ids.add(link_id)
                    # properties.add(*rel_properties.keys())
        d3_graph = {
            'directed': True,
            'graph': [],
            'multigraph': True,
            'links': links,
            'nodes': nodes,
            'properties': list(properties)
        }
        return d3_graph

    def _plot_graph(self, graph, title=None, width=None, height=None):
        """
        Return a HTML representation for a particular QuerySequence.
        Mainly for IPython Notebook.
        """
        if not self._elements_row and not self._elements_graph:
            raise ValueError('Unable to display the graph or the table')
        title = title or self.q
        width = width or json.dumps(None)
        height = height or 300
        d3_uuid = text_type(uuid.uuid1())
        d3_graph = self._transform_graph_to_d3(graph)
        d3_id = "d3_id_" + d3_uuid
        d3_title = title
        d3_container_id = d3_id + "_d3c"
        style = """
        #{d3_id} path.link {{
            fill: none;
            stroke-width: 1.5px;
        }}
        #{d3_id} .node {{
            /*fill: #ccc;*/
            stroke: #333;
            stroke-width: 1.5px;
        }}
        #{d3_id} text {{
            font: 10px sans-serif;
            pointer-events: none;
        }}
        #{d3_id} text.shadow {{
            stroke: #fff;
            stroke-width: 3px;
            stroke-opacity: .8;
        }}
        #{d3_id} .node.sticky {{
            /* stroke-width: 2px; */
        }}
        """.format(d3_id=d3_id)
        js = """
        var links = graph.links;
        var nodes = graph.nodes;

        // Compute the distinct nodes from the links.
        links.forEach(function(link) {
            link.source = (nodes[link.source] ||
                           (nodes[link.source] = {name: link.source}));
            link.target = (nodes[link.target] ||
                           (nodes[link.target] = {name: link.target}));
        });

        var w = width || $(container).width(), h = height;

        var force = d3.layout.force()
            .nodes(d3.values(nodes))
            .links(links)
            .size([w, h])
            .linkDistance(60)
            .charge(-300)
            .on("tick", tick)
            .start();

        var svg = d3.select(container).append("svg:svg")
            .attr("width", w)
            .attr("height", h);

        // Per-type markers, as they don't inherit styles.
        svg.append("svg:defs").selectAll("marker")
            .data(["arrow"])
            .enter().append("svg:marker")
            .attr("id", String)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 15)
            .attr("refY", -1.5)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("svg:path")
            .attr("d", "M0,-5L10,0L0,5");

        var path = svg.append("svg:g").selectAll("path")
            .data(force.links())
            .enter().append("svg:path")
            .attr("class", function(d) { return "link " + d.stroke; })
            .attr("stroke", function(d) { return d.stroke; })
            .attr("marker-end", function(d) { return "url(#arrow)"; });

        var circle = svg.append("svg:g").selectAll("circle")
            .data(force.nodes())
            .enter().append("svg:circle")
            .attr("fill", function(d) { return d.fill; })
            .attr("r", 6)
            .attr("class", "node")
            .call(force.drag)
            .on("mousedown", function(d) {
                d.fixed = true;
                d3.select(this).classed("sticky", true);
            });

        var text = svg.append("svg:g").selectAll("g")
            .data(force.nodes())
            .enter().append("svg:g");

        // A copy of the text with a thick white stroke for legibility.
        text.append("svg:text")
            .attr("x", 8)
            .attr("y", ".31em")
            .attr("class", "shadow")
            .text(function(d) { return d.label; });

        text.append("svg:text")
            .attr("x", 8)
            .attr("y", ".31em")
            .attr("class", "front")
            .text(function(d) { return d.label; });

        // Use elliptical arc path segments to doubly-encode directionality.
        function tick() {
            path.attr("d", function(d) {
                var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
                return ("M" + d.source.x + "," + d.source.y + "A"
                        + dr + "," + dr + " 0 0,1 " + d.target.x + ","
                        + d.target.y);
            });

            circle.attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });

            text.attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });
        }

        // Display options
        var display = $(container + "_display");
        graph.properties.forEach(function (property) {
            var option = $("<OPTION/>");
            option.text(property);
            option.attr("value", property);
            display.append(option);
        });
        display.on("change", function () {
            var selected = $(this).find(":selected").val(),
                displayFunc;
            if (selected.length !== 0) {
                displayFunc = function(d) {
                    return d.properties[selected];
                }
            } else {
                displayFunc = function(d) {
                    return d.label;
                }
            }
            text.select("text.front").text(displayFunc);
            text.select("text.shadow").text(displayFunc);
        });
        """
        return ("""
        <style type="text/css">
        {style}
        </style>

        <div class="accordion">
            <div class="accordion-group">
                <div class="accordion-heading">
                    <a class="accordion-toggle collapsed"
                       data-toggle="collapse" data-parent=""
                       href="#{d3_id}">
                        {d3_title}
                    </a>
                </div>
                <div id="{d3_id}" class="accordion-body in collapse">
                    <div class="accordion-inner">
                        <div id="{d3_container_id}">
                            <select id="{d3_container_id}_display">
                                <option value="">ID</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            var neo4jrestclient = window.neo4jrestclient || {{}};
            neo4jrestclient['{d3_uuid}'] = {{}};
            neo4jrestclient['{d3_uuid}'].graph = {d3_graph};
            neo4jrestclient['{d3_uuid}'].container_id = "{d3_container_id}";
            neo4jrestclient['{d3_uuid}'].container = "#{d3_container_id}";
            neo4jrestclient['{d3_uuid}'].render = function () {{
                (function (graph, container, width, height) {{
                    {js}
                }})(
                    neo4jrestclient['{d3_uuid}'].graph,
                    neo4jrestclient['{d3_uuid}'].container,
                    {width},
                    {height}
                );
            }}
            if (!window.d3) {{
                $.getScript(
                    "//d3js.org/d3.v2.js?2.9.1",
                    neo4jrestclient['{d3_uuid}'].render
                );
            }} else {{
                neo4jrestclient['{d3_uuid}'].render();
            }}
        </script>
        """.format(
            style=style,
            js=js,
            d3_graph=json.dumps(d3_graph),
            d3_id=d3_id,
            d3_uuid=d3_uuid,
            d3_title=d3_title,
            d3_container_id=d3_container_id,
            width=width,
            height=height,
        ))

    def get_response(self):
        # Preparing slicing and ordering
        q = self.q
        params = self.params
        version = self._auth.get('version', None)
        NEO4J_V2 = version and version.split(".")[0] >= "2"
        if self._order_by:
            orders = []
            for o, order in enumerate(self._order_by):
                order_key = "_order_by_%s" % o
                if order_key not in params:
                    if NEO4J_V2:
                        orders.append(u"n.`{%s}` %s"
                                      % (order_key, order[1]))
                    else:
                        nullable = ""
                        if len(order) == 3:
                            if order[2] is True:
                                nullable = "!"
                            elif order[2] is False:
                                nullable = "?"
                        orders.append(u"n.`{%s}`%s %s" % (order_key, nullable,
                                                          order[1]))
                    params[order_key] = order[0]
            if orders:
                q = u"%s order by %s" % (q, ", ".join(orders))
        # Lazy slicing
        if isinstance(self._skip, int) and "_skip" not in params:
            q = u"%s skip {_skip} " % q
            params["_skip"] = self._skip
        if isinstance(self._limit, int) and "_limit" not in params:
            q = u"%s limit {_limit} " % q
            params["_limit"] = self._limit
        # Making the real resquest
        data = {
            "query": q,
            "params": params,
        }
        response = Request(**self._auth).post(self._cypher, data=data)
        if response.status_code == 200:
            response_json = response.json()
            return response_json
        elif response.status_code == 400:
            err_msg = u"Cypher query exception"
            try:
                err_msg = "%s: %s" % (err_msg, response.json()["message"])
            except:
                err_msg = "%s: %s" % (err_msg, response.text)
            raise CypherException(err_msg)
        else:
            raise StatusException(response.status_code, "Invalid data sent")

    @staticmethod
    def cast(cls, elements, returns=None, types=None, auth=None, cypher=None):
        if types is None:
            types = cls._types
        if auth is None:
            auth = cls._auth
        if cypher is None:
            cypher = cls._cypher
        neutral = lambda x: x
        # For IPython Notebook
        cls._elements_row = []
        cls._elements_graph = []
        if not returns or returns is RAW:
            if len(elements) > 0:
                results = []
                for element in elements:
                    # For IPython Notebook
                    if "row" in element:
                        cls._elements_row.append(element["row"])
                    if "graph" in element:
                        cls._elements_graph.append(element["graph"])
                    # For transactional Cypher endpoint
                    results.append(element.get("rest", None))
                return results
            else:
                return elements
        else:
            results = []
            if not isinstance(returns, (tuple, list)):
                returns = [returns]
            else:
                returns = list(returns)
            for row in elements:
                # For IPython Notebook
                if "row" in row:
                    cls._elements_row.append(row["row"])
                if "graph" in row:
                    cls._elements_graph.append(row["graph"])
                # For transactional Cypher endpoint
                if "rest" in row:
                    row = row["rest"]
                # We need both list to have the same lenght
                len_row = len(row)
                len_returns = len(returns)
                if len_row > len_returns:
                    returns += [neutral] * (len_row - len_returns)
                returns = returns[:len_row]
                # And now, apply i-th function to the i-th column in each row
                casted_row = []
                types_keys = types.keys()
                for i, element in enumerate(row):
                    # if "rest" in element:
                    #     element = element["rest"]
                    func = returns[i]
                    # We also allow the use of constants like NODE, etc
                    if isinstance(func, string_types):
                        func_lower = func.lower()
                        if func_lower in types_keys:
                            func = types[func_lower]
                    if func in (types.get("node", ""),
                                types.get("relationship", "")):
                        obj = func(element["self"], update_dict=element,
                                   auth=auth, cypher=cypher)
                        casted_row.append(obj)
                    elif func in (types.get("path", ""),
                                  types.get("position", "")):
                        obj = func(element, auth=auth, cypher=cypher)
                        casted_row.append(obj)
                    elif func in (None, True, False):
                        sub_func = lambda x: x is func
                        casted_row.append(sub_func(element))
                    else:
                        casted_row.append(func(element))
                if cls is not None and cls._return_single_rows:
                    results.append(*casted_row)
                else:
                    results.append(casted_row)
            return results


class QueryTransaction(object):
    """
    Transaction class for tge Cypher endpoint.
    """

    def __init__(self, cls, transaction_id, types, commit=True, update=True,
                 rollback=True, execute=False):
        self._class = cls
        self.url_begin = self._class._transaction
        self.url_tx = None
        self.url_commit = None
        self.id = transaction_id
        self.finished = False
        self._types = types
        self.auto_commit = commit
        self.auto_update = update
        self.auto_rollback = rollback
        self.auto_execute = execute
        self.statements = []
        self.references = []
        self.executed = []
        self.expires = None

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if not self.finished:
            if self.auto_commit:
                self.commit()
            if isinstance(value, TransactionException) and self.auto_rollback:
                self.rollback()
        return True

    def _manage_errors(self, errors):
        message = u""
        if errors:
            for error in errors:
                message = u"{}\n{}:\n{}\n".format(
                    message, error["code"], error["message"]
                )
            raise TransactionException(200, message)

    def _begin(self):
        response = self._request(self.url_begin)
        content = response.json()
        self._manage_errors(content["errors"])
        self.url_tx = response.headers.get("location")
        self.url_commit = content["commit"]
        self.expires = content["transaction"]["expires"]

    def _request(self, url, statements=None):
        if statements is None:
            statements = []
        request = Request(**self._class._auth)
        data = {
            "statements": statements
        }
        response = request.post(url, data=data)
        if response.status_code in [200, 201]:
            return response
        else:
            raise TransactionException(response.status_code)

    def _execute(self, url, results=True):
        response = self._request(url, statements=self.statements)
        content = response.json()
        self._manage_errors(content["errors"])
        _results = self._update(content["results"])
        self.executed = self.references
        self.statements = []
        self.references = []
        if results:
            return _results

    def _update(self, result_list):
        if self.auto_update:
            results = []
            for i, result in enumerate(result_list):
                reference = self.references[i]
                obj = reference["obj"]
                returns = reference["returns"]
                statement = reference["statement"]
                if obj is None:
                    obj = QuerySequence(
                        q=statement['statement'],
                        params=statement['parameters'], returns=returns,
                        types=self._types, auth=self._class._auth,
                        cypher=self._class._cypher, lazy=True
                    )
                obj._elements = QuerySequence.cast(
                    obj, elements=result["data"], returns=returns
                )
                obj.columns = result.get("columns", None)
                results.append(obj)
            return results
        else:
            return result_list

    def append(self, q, params=None, returns=None, obj=None):
        result_data_contents = ["REST"]
        if in_ipnb():
            result_data_contents += ["row", "graph"]
        statement = {
            "statement": q,
            "parameters": params,
            "resultDataContents": result_data_contents,
        }
        self.statements.append(statement)
        self.references.append({
            "statement": statement,
            "returns": returns,
            "obj": obj,
        })

    def reset(self):
        if not self.url_tx:
            self._begin()
        response = self._request(self.url_tx)
        content = response.json()
        self._manage_errors(content["errors"])
        self.expires = content["transaction"]["expires"]
        return self.expires

    def execute(self):
        if self.auto_execute:
            self.url_commit = None
            return self.commit()
        if not self.url_tx:
            self._begin()
        results = self._execute(self.url_tx, results=True)
        self.finished = False
        return results

    def commit(self):
        if self.url_commit:
            url = self.url_commit
        else:
            url = u"{}/commit".format(self.url_begin)
        results = self._execute(url, results=True)
        self.finished = True
        return results

    def rollback(self):
        if self.url_tx:
            request = Request(**self._class._auth)
            response = request.delete(self.url_tx)
            if response.status_code in [200, 201]:
                self._manage_errors(response.json()["errors"])
                self.finished = True
                for reference in self.executed:
                    obj = reference["obj"]
                    if obj is not None:
                        obj._elements = []
                        obj.columns = None
                self.executed = []
            else:
                raise TransactionException(response.status_code)


class FilterSequence(QuerySequence):

    def __init__(self, cypher, auth, start=None, matches=None, lookups=[],
                 order_by=None, types=None, returns=None):
        self.version = auth.get('version', None)
        start = start or u"node(*)"
        q = u"start n=%s " % start
        if matches:
            if not isinstance(matches, (list, tuple)):
                matches = [matches]
            match = u", ".join(matches)
            q = u"{} match {}".format(q, match)
        where = None
        params = {}
        if lookups:
            wheres = Q()
            for lookup in lookups:
                if isinstance(lookup, Q):
                    wheres &= lookup
                elif isinstance(lookup, dict):
                    wheres &= Q(**lookup)
            where, params = wheres.get_query_objects(var="n",
                                                     version=self.version)
        if where:
            q = u"{} where {} return n ".format(q, where)
        else:
            q = u"{} return n ".format(q)
        super(FilterSequence, self).__init__(cypher=cypher, auth=auth, q=q,
                                             params=params, types=types,
                                             returns=returns, lazy=True)
        self._return_single_rows = True

    def __getitem__(self, key):
        if isinstance(key, slice):
            self._skip = key.start
            self._limit = key.stop
        return super(FilterSequence, self).__getitem__(key)

    def order_by(self, property=None, type=None, nullable=True, *args):
        if property is None and isinstance(args, (list, tuple)):
            self._order_by = args
        else:
            self._order_by = [(property, type, nullable)]
        return self

########NEW FILE########
__FILENAME__ = request
# -*- coding: utf-8 -*-
import datetime
import decimal
import re
import requests
import json
import time

from neo4jrestclient import options
from neo4jrestclient.constants import __version__
from neo4jrestclient.exceptions import StatusException
from neo4jrestclient.utils import string_types, get_auth_from_uri

if options.DEBUG:
    import httplib
    import logging
    httplib.HTTPConnection.debuglevel = 1
    logging.basicConfig()
    logging.getLogger().setLevel(logging.DEBUG)
    requests_log = logging.getLogger("requests.packages.urllib3")
    requests_log.setLevel(logging.DEBUG)
    requests_log.propagate = True
session = requests.Session()

if options.CACHE:
    try:
        from cachecontrol import CacheControl
        from cachecontrol.cache import DictCache
        from cachecontrol.caches import FileCache
    except ImportError as e:
        raise ImportError("CacheControl and lockfile need to be installed "
                          "in order to use CACHE and CACHE_STORE options "
                          "in neo4jrestclient. \n"
                          "Please, run $ pip install CacheControl lockfile")
    if isinstance(options.CACHE_STORE, string_types):
        cache = FileCache(options.CACHE_STORE)
    elif isinstance(options.CACHE_STORE, dict):
        cache = DictCache(options.CACHE_STORE)
    else:
        cache = options.CACHE_STORE
    session = CacheControl(session, cache=cache)


class Request(object):
    """
    Create an HTTP request object for HTTP
    verbs GET, POST, PUT and DELETE.
    """

    def __init__(self, username=None, password=None, key_file=None,
                 cert_file=None, **kwargs):
        self.username = username
        self.password = password
        self.key_file = key_file
        self.cert_file = cert_file
        self._illegal_s = re.compile(r"((^|[^%])(%%)*%s)")

    def get(self, url, headers=None):
        """
        Perform an HTTP GET request for a given URL.
        Returns the response object.
        """
        return self._request('GET', url, headers=headers)

    def post(self, url, data, headers=None):
        """
        Perform an HTTP POST request for a given url.
        Returns the response object.
        """
        return self._request('POST', url, data, headers=headers)

    def put(self, url, data, headers=None):
        """
        Perform an HTTP PUT request for a given url.
        Returns the response object.
        """
        return self._request('PUT', url, data, headers=headers)

    def delete(self, url, headers=None):
        """
        Perform an HTTP DELETE request for a given url.
        Returns the response object.
        """
        return self._request('DELETE', url, headers=headers)

    # Proleptic Gregorian dates and strftime before 1900  Python recipes
    # ActiveState Code: http://bit.ly/9t0JKb via @addthis

    def _findall(self, text, substr):
        # Also finds overlaps
        sites = []
        i = 0
        while 1:
            j = text.find(substr, i)
            if j == -1:
                break
            sites.append(j)
            i = j + 1
        return sites

    # Every 28 years the calendar repeats, except through century leap
    # years where it's 6 years.  But only if you're using the Gregorian
    # calendar.  ;)

    def _strftime(self, dt, fmt):
        if self._illegal_s.search(fmt):
            raise TypeError("This strftime implementation does not handle %s")
        if dt.year > 1900:
            return dt.strftime(fmt)
        year = dt.year
        # For every non-leap year century, advance by
        # 6 years to get into the 28-year repeat cycle
        delta = 2000 - year
        off = 6 * (delta // 100 + delta // 400)
        year = year + off
        # Move to around the year 2000
        year = year + ((2000 - year) // 28) * 28
        timetuple = dt.timetuple()
        s1 = time.strftime(fmt, (year,) + timetuple[1:])
        sites1 = self._findall(s1, str(year))
        s2 = time.strftime(fmt, (year + 28,) + timetuple[1:])
        sites2 = self._findall(s2, str(year + 28))
        sites = []
        for site in sites1:
            if site in sites2:
                sites.append(site)
        s = s1
        syear = "%4d" % (dt.year, )
        for site in sites:
            s = s[:site] + syear + s[site + 4:]
        return s

    def _json_encode(self, data, ensure_ascii=False):

        def _any(data):
            ret = None
            if isinstance(data, (list, tuple)):
                ret = _list(data)
            elif isinstance(data, dict):
                ret = _dict(data)
            elif isinstance(data, decimal.Decimal):
                ret = str(data)
            elif isinstance(data, datetime.datetime):
                ret = self._strftime(data, options.DATETIME_FORMAT)
            elif isinstance(data, datetime.date):
                ret = self._strftime(data, options.DATE_FORMAT)
            elif isinstance(data, datetime.time):
                ret = data.strftime(options.TIME_FORMAT)
            else:
                ret = data
            return ret

        def _list(data):
            ret = []
            for v in data:
                ret.append(_any(v))
            return ret

        def _dict(data):
            ret = {}
            for k, v in data.items():
                # Neo4j doesn't allow 'null' properties
                if v is not None:
                    ret[k] = _any(v)
            return ret
        ret = _any(data)
        return json.dumps(ret, ensure_ascii=ensure_ascii)

    def _request(self, method, url, data={}, headers={}):
        username_uri, password_uri, root_uri = get_auth_from_uri(url)
        username = username_uri or self.username
        password = password_uri or self.password
        cert = None
        if self.cert_file:
            if self.key_file:
                cert = (self.cert_file, self.key_file)
            else:
                cert = self.cert_file
        headers = headers or {}
        headers['Accept'] = 'application/json; charset=UTF-8'
        headers['Accept-Encoding'] = '*'
        headers['Accept-Charset'] = 'UTF-8,ISO-8859-1;q=0.7,*;q=0.7'
        headers['Connection'] = 'keep-alive'
        if not options.CACHE:
            headers['Cache-Control'] = 'no-cache'
        headers['User-Agent'] = 'neo4jrestclient/%s ' % __version__
        auth = None
        if username and password:
            auth = (username, password)
        if method in ("POST", "PUT"):
            headers['Content-Type'] = 'application/json'
        data = self._json_encode(data, ensure_ascii=True)
        verify = options.VERIFY_SSL
        try:
            method = method.lower()
            response = getattr(session, method)(root_uri, headers=headers,
                                                data=data, cert=cert,
                                                auth=auth, verify=verify)
            if response.status_code == 401:
                raise StatusException(401, "Authorization Required")
            return response
        except AttributeError:
            raise Exception("Unknown error. Is the server running?")

########NEW FILE########
__FILENAME__ = test_cache
# -*- coding: utf-8 -*-
try:
    from imp import reload
except ImportError:
    reload
import unittest
import os

from neo4jrestclient import client
from neo4jrestclient import options
from neo4jrestclient import request


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        from neo4jrestclient import options as clientCacheDebug
        clientCacheDebug.DEBUG = False
        clientCacheDebug.CACHE = False
        if self.gdb:
            self.gdb.flush()


class FakeCache(object):
    def __init__(self, called):
        self.called = called
        self.dict = {}

    def get(self, key):
        self.called['get'] = True
        return self.dict.get(key, None)

    def set(self, key, value):
        self.called['set'] = True
        self.dict[key] = value

    def delete(self, key):
        if key in self.dict:
            del self.dict[key]


class XtraCacheTestCase(unittest.TestCase):

    def setUp(self):
        self.cache_called = {}
        self.cache = options.CACHE
        self.cache_store = options.CACHE
        options.CACHE = True
        options.CACHE_STORE = FakeCache(self.cache_called)
        # reload modules now cache set
        reload(request)
        reload(client)
        self.gdb = client.GraphDatabase(NEO4J_URL)

    def test_custom_cache_used(self):
        n = self.gdb.nodes.create()
        response = request.session.get(n.url)
        self.assertTrue(hasattr(response, "from_cache"))

    def tearDown(self):
        # leave everything as we found it
        options.CACHE = self.cache
        options.CACHE_STORE = self.cache_store
        reload(request)
        reload(client)
        client

########NEW FILE########
__FILENAME__ = test_exceptions
# -*- coding: utf-8 -*-
import unittest

from neo4jrestclient.exceptions import (
    StatusException, NotFoundError, TransactionException
)


class ExceptionsTestCase(unittest.TestCase):

    def test_status_exception_params(self):
        StatusException(402, "Message")

    def test_not_found_error(self):
        NotFoundError()

    def test_not_found_error_params(self):
        NotFoundError("Message")

    def test_transaction_exception(self):
        TransactionException()

    def test_transaction_params(self):
        TransactionException(200, "Message")

########NEW FILE########
__FILENAME__ = test_extensions
# -*- coding: utf-8 -*-
import unittest
import os

from neo4jrestclient import constants
from neo4jrestclient import client


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class ExtensionsTestCase(GraphDatabaseTesCase):

    def test_get_graph_extensions(self):
        fail = False
        try:
            self.gdb.extensions
        except:
            fail = True
        self.assertTrue(not fail)

    def test_get_node_extensions(self):
        fail = False
        n1 = self.gdb.nodes.create()
        try:
            n1.extensions
        except:
            fail = True
        self.assertTrue(not fail)

    @unittest.skipIf(NEO4J_VERSION not in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_gremlin_extension_reference_node(self):
        # Assuming the GremlinPlugin installed
        ext = self.gdb.extensions.GremlinPlugin
        n = self.gdb.nodes.create()
        gremlin_n = ext.execute_script(script='g.v(%s)' % n.id)
        self.assertEqual(gremlin_n, n)

    @unittest.skipIf(NEO4J_VERSION not in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_gremlin_extension_reference_node_returns(self):
        # Assuming the GremlinPlugin installed
        ext = self.gdb.extensions.GremlinPlugin
        n = self.gdb.nodes.create()
        gremlin_n = ext.execute_script(script='g.v(%s)' % n.id,
                                       returns=constants.NODE)
        self.assertEqual(gremlin_n, n)

    @unittest.skipIf(NEO4J_VERSION not in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_gremlin_extension_relationships(self):
        # Assuming the GremlinPlugin installed
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        n3 = self.gdb.nodes.create()
        n1.relationships.create("related", n2)
        n1.relationships.create("related", n3)
        gremlin = self.gdb.extensions.GremlinPlugin.execute_script
        rels = gremlin(script='g.v(%s).outE' % n1.id)
        self.assertEqual(len(rels), 2)
        for rel in rels:
            self.assertTrue(isinstance(rel, client.Relationship))

    @unittest.skipIf(NEO4J_VERSION not in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_gremlin_extension_relationships_returns(self):
        # Assuming the GremlinPlugin installed
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        n3 = self.gdb.nodes.create()
        n1.relationships.create("related", n2)
        n1.relationships.create("related", n3)
        gremlin = self.gdb.extensions.GremlinPlugin.execute_script
        from neo4jrestclient import options as clientDebug
        clientDebug.DEBUG = True
        rels = gremlin(script='g.v(%s).outE' % n1.id,
                       returns=constants.RELATIONSHIP)
        self.assertEqual(len(rels), 2)
        for rel in rels:
            self.assertTrue(isinstance(rel, client.Relationship))
        clientDebug.DEBUG = False

    @unittest.skipIf(NEO4J_VERSION not in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_gremlin_extension_reference_raw_returns(self):
        # Assuming the GremlinPlugin installed
        ext = self.gdb.extensions.GremlinPlugin
        n = self.gdb.nodes.create(name="Test")
        gremlin_n = ext.execute_script(script='g.v(%s)' % n.id,
                                       returns=constants.RAW)
        self.assertEqual(gremlin_n["data"], n.properties)
        self.assertTrue(isinstance(gremlin_n, dict))

    @unittest.skipIf(NEO4J_VERSION not in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_gremlin_results_raw(self):
        # Assuming the GremlinPlugin installed
        ext = self.gdb.extensions.GremlinPlugin
        n = ext.execute_script(script='results = [1,2]', returns=constants.RAW)
        self.assertTrue(isinstance(n, list))
        self.assertEqual(n, [1, 2])

########NEW FILE########
__FILENAME__ = test_filters
# -*- coding: utf-8 -*-
from datetime import datetime
from random import randint
import unittest
import os

from neo4jrestclient import constants
from neo4jrestclient import client
from neo4jrestclient import query
from neo4jrestclient.utils import text_type


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class FilterTestCase(GraphDatabaseTesCase):

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_nodes(self):
        Q = query.Q
        for i in range(5):
            self.gdb.nodes.create(name="William %s" % i)
        lookup = Q("name", istartswith="william")
        williams = self.gdb.nodes.filter(lookup)
        self.assertTrue(len(williams) >= 5)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_nodes_complex_lookups(self):
        Q = query.Q
        for i in range(5):
            self.gdb.nodes.create(name="James", surname="Smith %s" % i)
        lookups = (
            Q("name", exact="James") &
            (Q("surname", startswith="Smith") &
             ~Q("surname", endswith="1"))
        )
        williams = self.gdb.nodes.filter(lookups)
        self.assertTrue(len(williams) >= 4)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_nodes_slicing(self):
        Q = query.Q
        for i in range(5):
            self.gdb.nodes.create(name="William %s" % i)
        lookup = Q("name", istartswith="william")
        williams = self.gdb.nodes.filter(lookup)[:4]
        self.assertTrue(len(williams) == 4)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_nodes_ordering(self):
        Q = query.Q
        for i in range(5):
            self.gdb.nodes.create(name="William", code=i)
        lookup = Q("code", gte=2)
        williams = self.gdb.nodes.filter(lookup).order_by("code",
                                                          constants.DESC)
        self.assertTrue(williams[-1]["code"] > williams[0]["code"])

    @unittest.skipIf(NEO4J_VERSION not in ["1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_nodes_nullable(self):
        Q = query.Q
        for i in range(5):
            self.gdb.nodes.create(name="William %s" % i)
        lookup = Q("name", istartswith="william", nullable=False)
        williams = self.gdb.nodes.filter(lookup)[:10]
        self.assertTrue(len(williams) > 5)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_nodes_start(self):
        Q = query.Q
        nodes = []
        for i in range(5):
            nodes.append(self.gdb.nodes.create(name="William %s" % i))
        lookup = Q("name", istartswith="william")
        williams = self.gdb.nodes.filter(lookup, start=nodes)
        self.assertTrue(len(williams) == 5)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_nodes_start_index(self):
        Q = query.Q
        t = text_type(datetime.now().strftime('%s%f'))
        index_name = "filter_nodes_start_index_%s" % t
        index = self.gdb.nodes.indexes.create(name=index_name)
        for i in range(5):
            n = self.gdb.nodes.create(name="William %s" % i)
            index["name"]["William"] = n
        lookup = Q("name", istartswith="william")
        williams = self.gdb.nodes.filter(lookup, start=index)
        self.assertTrue(len(williams) == 5)
        williams = self.gdb.nodes.filter(lookup, start=index["name"])
        self.assertTrue(len(williams) == 5)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_index_for_nodes(self):
        Q = query.Q
        n1 = self.gdb.nodes.create(name="Lemmy", band="Motrhead")
        index = self.gdb.nodes.indexes.create(name="music")
        index["band"]["Motrhead"] = n1
        lookup = Q("name", icontains='Lemmy')
        self.assertTrue(n1 in index.filter(lookup))
        self.assertTrue(n1 in index.filter(lookup, key="band"))
        self.assertTrue(n1 in index.filter(lookup, key="band",
                                           value="Motrhead"))
        self.assertTrue(n1 in index["band"].filter(lookup))
        self.assertTrue(n1 in index["band"].filter(lookup, value="Motrhead"))

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_index_for_relationships(self):
        Q = query.Q
        n1 = self.gdb.nodes.create(name="Jhn Doe", place="Texa")
        n2 = self.gdb.nodes.create(name="Mchael Doe", place="Tjuana")
        r1 = self.gdb.relationships.create(n1, "Hate", n2, since=1995)
        index = self.gdb.relationships.indexes.create(name="brthers")
        index["feelig"]["hte"] = r1
        lookup = Q("since", lte=2000)
        self.assertTrue(r1 in index.filter(lookup))
        self.assertTrue(r1 in index.filter(lookup, key="feelig"))
        self.assertTrue(r1 in index.filter(lookup, key="feelig",
                                           value="hte"))
        self.assertTrue(r1 in index["feelig"].filter(lookup))
        self.assertTrue(r1 in index["feelig"].filter(lookup, value="hte"))

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_relationships_start(self):
        Q = query.Q
        rels = []
        for i in range(5):
            n1 = self.gdb.nodes.create(name="William %s" % i)
            n2 = self.gdb.nodes.create(name="Rose %s" % i)
            r = n1.loves(n2, since=(1990 + i))
            rels.append(r)
        lookup = Q("since", lte=2000)
        old_loves = self.gdb.relationships.filter(lookup, start=rels)
        self.assertTrue(len(old_loves) >= 5)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_relationships_start_index(self):
        Q = query.Q
        t = text_type(datetime.now().strftime('%s%f'))
        index_name = "filter_relationships_start_index_%s" % t
        index = self.gdb.relationships.indexes.create(name=index_name)
        for i in range(5):
            n1 = self.gdb.nodes.create(name="William %s" % i)
            n2 = self.gdb.nodes.create(name="Rose %s" % i)
            r = n1.loves(n2, since=(1990 + i))
            index["since"][1990] = r
        lookup = Q("since", lte=2000)
        old_loves = self.gdb.relationships.filter(lookup, start=index)
        self.assertTrue(len(old_loves) == 5)
        old_loves = self.gdb.relationships.filter(lookup, start=index["since"])
        self.assertTrue(len(old_loves) == 5)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_filter_inrange(self):
        Q = query.Q
        t1 = randint(1, 10 ** 10)
        t2 = t1 + 1
        for i in range(5):
            self.gdb.nodes.create(number=t1)
            self.gdb.nodes.create(number=t2)
        lookup = Q("number", inrange=[t1, t2])
        nodes = self.gdb.nodes.filter(lookup)
        self.assertTrue(len(nodes) == 10)

########NEW FILE########
__FILENAME__ = test_graphdatabase
# -*- coding: utf-8 -*-
import unittest
import os

from neo4jrestclient import client


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


@unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2"],
                 "Not supported by Neo4j {}".format(NEO4J_VERSION))
class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def test_connection_https(self):
        url = NEO4J_URL.replace("http://", "https://")
        url = url.replace(":7474", ":7473")
        client.GraphDatabase(url)

    def test_connection_host(self):
        url = NEO4J_URL.replace("/db/data/", "")
        client.GraphDatabase(url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()

########NEW FILE########
__FILENAME__ = test_indices
# -*- coding: utf-8 -*-
from datetime import datetime
import unittest
import os

from neo4jrestclient import client
from neo4jrestclient.exceptions import NotFoundError, StatusException
from neo4jrestclient.utils import PY2


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class IndicesTestCase(GraphDatabaseTesCase):

    def test_create_index_for_nodes(self):
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        index = self.gdb.nodes.indexes.create(name="doe")
        index["surnames"]["d"] = n1
        self.assertTrue(n1 in index["surnames"]["d"])

    def test_create_index_for_nodes_and_dots(self):
        # From https://github.com/versae/neo4j-rest-client/issues/43
        n1 = self.gdb.nodes.create(name="John.Doe", place="Texas.s")
        index = self.gdb.nodes.indexes.create(name="dots")
        index["surnames.s"]["d.d"] = n1
        self.assertTrue(n1 in index["surnames.s"]["d.d"])

    def test_create_index_for_nodes_unicode(self):
        n1 = self.gdb.nodes.create(name="Lemmy", band="Motrhead")
        index = self.gdb.nodes.indexes.create(name="doe")
        index["bands"]["Motrhead"] = n1
        self.assertTrue(n1 in index["bands"]["Motrhead"])

    def test_create_index_for_nodes_and_boolean(self):
        n1 = self.gdb.nodes.create(name="John", is_real=True, is_fake=False)
        index = self.gdb.nodes.indexes.create(name="boolean")
        index["is_real"][True] = n1
        index["is_fake"][False] = n1
        self.assertTrue(n1 in index["is_real"][True])
        self.assertTrue(n1 in index["is_fake"][False])

    def test_create_index_for_nodes_and_number(self):
        n1 = self.gdb.nodes.create(name="John", age=30, mean=2.7)
        index = self.gdb.nodes.indexes.create(name="number")
        index["age"][30] = n1
        index["mean"][2.7] = n1
        self.assertTrue(n1 in index["age"][30])
        self.assertTrue(n1 in index["mean"][2.7])

    def test_create_index_for_nodes_and_unicode(self):
        index = self.gdb.nodes.indexes.create(name="unicode")
        n1 = self.gdb.nodes.create(name="First")
        key = u"Profesin"
        value = u"nformtic"
        n1.set(key, value)
        index[key][value] = n1
        self.assertTrue(n1 in index[key][value])
        n2 = self.gdb.nodes.create(name="Second")
        key = u"Ttulo/Nombre"
        value = u"Necronomicn"
        n2.set(key, value)
        index[key][value] = n2
        self.assertTrue(n2 in index[key][value])

    def test_create_index_for_nodes_url_safe(self):
        n1 = self.gdb.nodes.create(name="Brian", place="AC/DC")
        index = self.gdb.nodes.indexes.create(name="doe")
        index["bands"]["AC/DC"] = n1
        self.assertTrue(n1 in index["bands"]["AC/DC"])

    def test_delete_index_for_nodes(self):
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        index = self.gdb.nodes.indexes.create(name="doe")
        index["surnames"]["d"] = n1
        index.delete()
        self.assertRaises(NotFoundError,
                          index["surnames"].__getitem__, "d")

    def test_create_index_for_relationships(self):
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        n2 = self.gdb.nodes.create(name="Michael Doe", place="Tijuana")
        r1 = self.gdb.relationships.create(n1, "Hates", n2)
        index = self.gdb.relationships.indexes.create(name="brothers")
        index["feeling"]["hate"] = r1
        self.assertTrue(r1 in index["feeling"]["hate"])

    def test_delete_node_from_index(self):
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        index = self.gdb.nodes.indexes.create(name="doe")
        index["surnames"]["d"] = n1
        index.delete("surnames", "d", n1)
        self.assertTrue(n1 not in index["surnames"]["d"])

    def test_delete_node_from_index_with_no_value(self):
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        index = self.gdb.nodes.indexes.create(name="doe")
        index["surnames"]["d"] = n1
        index.delete("surnames", None, n1)
        self.assertTrue(n1 not in index["surnames"]["d"])

    def test_delete_node_from_index_with_no_value_nor_key(self):
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        index = self.gdb.nodes.indexes.create(name="doe")
        index["surnames"]["d"] = n1
        index.delete(None, None, n1)
        self.assertTrue(n1 not in index["surnames"]["d"])

    def test_delete_relationship_from_index(self):
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        n2 = self.gdb.nodes.create(name="Michael Doe", place="Tijuana")
        r1 = self.gdb.relationships.create(n1, "Hates", n2)
        index = self.gdb.relationships.indexes.create(name="brothers")
        index["feeling"]["hate"] = r1
        index.delete("feeling", "hate", r1)
        self.assertTrue(r1 not in index["feeling"]["hate"])

    def test_delete_index_for_relationships(self):
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        n2 = self.gdb.nodes.create(name="Michael Doe", place="Tijuana")
        r1 = self.gdb.relationships.create(n1, "Hates", n2)
        index = self.gdb.relationships.indexes.create(name="brothers")
        index["feeling"]["hate"] = r1
        index.delete()
        self.assertRaises(NotFoundError,
                          index["feeling"].__getitem__, "hate")

    @unittest.skipIf(not PY2,
                     "Lucene Query Builder is not Python3 compliant yet")
    def test_query_index(self):
        Q = client.Q
        n1 = self.gdb.nodes.create(name="John Doe", place="Texas")
        n2 = self.gdb.nodes.create(name="Michael Donald", place="Tijuana")
        index = self.gdb.nodes.indexes.create(name="do", type="fulltext")
        index["surnames"]["doe"] = n1
        index["surnames"]["donald"] = n2
        index['place']['Texas'] = n1
        index['place']['Tijuana'] = n2
        results = index.query("surnames", "do*")
        self.assertTrue(n1 in results and n2 in results)
        results = index.query("surnames:do*")
        self.assertTrue(n1 in results and n2 in results)
        results = index.query('surnames', Q('do*', wildcard=True))
        self.assertTrue(n1 in results and n2 in results)
        results = index.query(Q('surnames', 'do*', wildcard=True))
        self.assertTrue(n1 in results and n2 in results)
        results = index.query(Q('surnames', 'do*', wildcard=True)
                              & Q('place', 'Tijuana'))
        self.assertTrue(n1 not in results and n2 in results)
        results = index.query(-Q('surnames', 'donald') | +Q('place', 'Texas'))
        self.assertTrue(n2 not in results and n1 in results)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_index_get_or_create_created(self):
        index = self.gdb.nodes.indexes.create(name="doe")
        properties = {
            "name": "Lemmy",
            "band": "Motrhead",
        }
        n1 = index.get_or_create(key="bands", value="Motrhead",
                                 properties=properties)
        self.assertTrue(n1 in index["bands"]["Motrhead"])

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_index_get_or_create_existing(self):
        index = self.gdb.nodes.indexes.create(name="doe")
        now = datetime.now().strftime('%s%f')
        properties = {
            "name": "Lemmy",
            "band": "Motrhead",
            "now": now,
        }
        n1 = self.gdb.nodes.create(**properties)
        index["now"][now] = n1
        n2 = index.get_or_create(key="now", value=now,
                                 properties=properties)
        self.assertEqual(n1, n2)
        self.assertTrue(n1 in index["now"][now])
        self.assertTrue(n2 in index["now"][now])

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_index_create_or_fail_created(self):
        index = self.gdb.nodes.indexes.create(name="doe")
        properties = {
            "name": "Lemmy",
            "band": "Motrhead",
        }
        n1 = index.create_or_fail(key="bands", value="Motrhead",
                                  properties=properties)
        self.assertTrue(n1 in index["bands"]["Motrhead"])

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_index_create_or_fail_existing(self):
        index = self.gdb.nodes.indexes.create(name="doe")
        now = datetime.now().strftime('%s%f')
        properties = {
            "name": "Lemmy",
            "band": "Motrhead",
            "now": now,
        }
        n1 = self.gdb.nodes.create(**properties)
        index["now"][now] = n1
        self.assertRaises((Exception, ValueError, StatusException),
                          index.create_or_fail,
                          key="now", value=now, properties=properties)

########NEW FILE########
__FILENAME__ = test_ipython
# -*- coding: utf-8 -*-
import unittest
import os

from neo4jrestclient import client
from neo4jrestclient import query

NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        # A bit of monkey patching to emulate that we are inside IPython
        self.in_ipnb = query.in_ipnb
        query.in_ipnb = lambda: True
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()
        query.in_ipnb = self.in_ipnb


class IPythonTestCase(GraphDatabaseTesCase):

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_ipython_query_raw(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        n1.knows(n2, since=1982)
        q = """start n=node(*) return n limit 2"""
        result = self.gdb.query(q=q)
        self.assertTrue(len(result._elements_graph) == 2)
        self.assertTrue(len(result._elements_row) == 2)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_ipython_query_returns(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        n1.knows(n2, since=1982)
        q = """start n=node(*) return n limit 2"""
        result = self.gdb.query(q=q, returns=client.Node)
        self.assertTrue(len(result._elements_graph) == 2)
        self.assertTrue(len(result._elements_row) == 2)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_ipython_query_returns_html(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        n1.knows(n2, since=1982)
        q = """start n=node(*) return n limit 2"""
        result = self.gdb.query(q=q, returns=client.Node)
        self.assertTrue("div" in result._repr_html_())

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_ipython_query_to_html(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        n1.knows(n2, since=1982)
        q = """start n=node(*) return n limit 2"""
        result = self.gdb.query(q=q, returns=client.Node)
        self.assertTrue("title" in result.to_html(title="title"))

########NEW FILE########
__FILENAME__ = test_labels
# -*- coding: utf-8 -*-
from datetime import datetime
import unittest
import os

from neo4jrestclient import client
from neo4jrestclient.query import Q
from neo4jrestclient.exceptions import StatusException


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


@unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                 "Not supported by Neo4j {}".format(NEO4J_VERSION))
class LabelsTestCase(GraphDatabaseTesCase):

    def test_label_append(self):
        n = self.gdb.nodes.create()
        label = "label"
        n.labels.add(label)
        self.assertIn(label, n.labels)

    def test_label_append_safe(self):
        n = self.gdb.nodes.create()
        label = u"label "
        n.labels.add(label)
        self.assertIn(label, n.labels)

    def test_labels_append(self):
        n = self.gdb.nodes.create()
        labels = ["label1", "label2"]
        n.labels.add(labels)
        for label in labels:
            self.assertIn(label, n.labels)

    def test_labels_append_safe(self):
        n = self.gdb.nodes.create()
        labels = [u"", u""]
        n.labels.add(labels)
        for label in labels:
            self.assertIn(label, n.labels)

    def test_label_append_invalud(self):
        n = self.gdb.nodes.create()
        label = ""
        self.assertRaises(StatusException, n.labels.add, label)

    def test_labels_replace(self):
        n = self.gdb.nodes.create()
        labels1 = ["label1", "label2"]
        n.labels.add(labels1)
        labels2 = ["bel1", "bel2"]
        n.labels = labels2
        labels = n.labels
        for label in labels1:
            self.assertNotIn(label, labels)
        for label in labels2:
            self.assertIn(label, labels)

    def test_labels_replace_safe(self):
        n = self.gdb.nodes.create()
        labels1 = [u"", u""]
        n.labels.add(labels1)
        labels2 = [u"", u"/~"]
        n.labels = labels2
        labels = n.labels
        for label in labels1:
            self.assertNotIn(label, labels)
        for label in labels2:
            self.assertIn(label, labels)

    def test_labels_remove(self):
        n = self.gdb.nodes.create()
        labels = ["label1", "label2"]
        n.labels.add(labels)
        n.labels.remove("label1")
        self.assertIn("label2", n.labels)
        self.assertNotIn("label1", n.labels)

    def test_labels_remove_safe(self):
        n = self.gdb.nodes.create()
        labels = [u"", u""]
        n.labels.add(labels)
        n.labels.remove(u"")
        self.assertIn(u"", n.labels)
        self.assertNotIn(u"", n.labels)

    def test_labels_list(self):
        n = self.gdb.nodes.create()
        labels = ["label1", "label2"]
        n.labels.add(labels)
        self.assertEqual(labels, n.labels)

    def test_labels_list_safe(self):
        n = self.gdb.nodes.create()
        labels = [u"lbel1", u"lbel2"]
        n.labels.add(labels)
        self.assertEqual(labels, n.labels)

    def test_list_nodes_with_a_label(self):
        nodes = []
        label = u"lbel_{}".format(datetime.now())
        for i in range(10):
            n = self.gdb.nodes.create()
            n.labels.add(label)
            nodes.append(n)
        labeled_nodes = self.gdb.labels[label].all()
        for node in nodes:
            self.assertIn(node, labeled_nodes)
        self.assertEqual(len(nodes), len(labeled_nodes))

    def test_get_nodes_with_a_label(self):
        nodes = []
        label = u"lbel_{}".format(datetime.now())
        for i in range(10):
            n = self.gdb.nodes.create()
            n.labels.add(label)
            nodes.append(n)
        labeled_nodes = self.gdb.labels.get(label).all()
        for node in nodes:
            self.assertIn(node, labeled_nodes)
        self.assertEqual(len(nodes), len(labeled_nodes))

    def test_get_nodes_with_a_label_and_property(self):
        nodes = []
        label = u"lbel_{}".format(datetime.now())
        value = u"propert_{}".format(datetime.now())
        for i in range(10):
            if i % 2 == 0:
                n = self.gdb.nodes.create(property=value)
                n.labels.add(label)
                nodes.append(n)
            else:
                n = self.gdb.nodes.create()
        labeled_nodes = self.gdb.labels[label].get(property=value)
        for node in nodes:
            self.assertIn(node, labeled_nodes)
        self.assertEqual(len(nodes), len(labeled_nodes))

    def test_labels(self):
        n1 = self.gdb.nodes.create()
        n1.labels.add(["label1", "label2"])
        n2 = self.gdb.nodes.create()
        n2.labels.add("label3")
        for label in n1.labels | n2.labels:
            self.assertIn(label, self.gdb.labels)
        self.assertTrue(len(n1.labels) + len(n2.labels) <=
                        len(self.gdb.labels))

    def test_labels_all(self):
        n = self.gdb.nodes.create()
        labels = n.labels.add(["label1", "label2"])
        for label in labels:
            self.assertIn(label, self.gdb.labels)
            self.assertIn(n, label.all())

    def test_filter(self):
        n = self.gdb.nodes.create(key="value")
        label = n.labels.add("label")
        q = Q("key", "icontains", "VALUE")
        self.assertIn(n, label.filter(q))

    def test_filter_safe(self):
        n1 = self.gdb.nodes.create(key=u"vlu/")
        n1.labels.add(u"lbel")
        n2 = self.gdb.nodes.create(key=u"val")
        n2.labels.add(u"lbel")
        q = Q("key", "icontains", u"LU")
        label = self.gdb.labels.get(u"lbel")
        self.assertIn(n1, label.filter(q))
        self.assertNotIn(n2, label.filter(q))

    def test_label_create(self):
        label = self.gdb.labels.create("label")
        n1 = self.gdb.nodes.create(key=u"vlu/")
        n2 = self.gdb.nodes.create(key=u"val")
        label.add(n1, n2)
        self.assertIn("label", n1.labels)
        self.assertIn("label", n2.labels)

########NEW FILE########
__FILENAME__ = test_nodes
# -*- coding: utf-8 -*-
from datetime import datetime
import unittest
import os

from neo4jrestclient import client
from neo4jrestclient.exceptions import NotFoundError, StatusException

NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class NodesTestCase(GraphDatabaseTesCase):

    def test_connection_cache(self):
        from neo4jrestclient import options as clientCache
        clientCache.CACHE = True
        gdb = client.GraphDatabase(self.url)
        clientCache.CACHE = False
        self.assertEqual(gdb.url, self.url)

    def test_connection_debug(self):
        from neo4jrestclient import options as clientDebug
        clientDebug.DEBUG = True
        gdb = client.GraphDatabase(self.url)
        clientDebug.DEBUG = False
        self.assertEqual(gdb.url, self.url)

    def test_connection_cache_debug(self):
        from neo4jrestclient import options as clientCacheDebug
        clientCacheDebug.CACHE = True
        clientCacheDebug.DEBUG = True
        gdb = client.GraphDatabase(self.url)
        clientCacheDebug.CACHE = False
        clientCacheDebug.DEBUG = False
        self.assertEqual(gdb.url, self.url)

    def test_create_node(self):
        n = self.gdb.nodes.create()
        self.assertEqual(n.properties, {})

    def test_create_node_properties(self):
        n = self.gdb.nodes.create(name="John Doe", profession="Hacker")
        self.assertEqual(n.properties, {"name": "John Doe",
                                        "profession": "Hacker"})

    def test_create_node_empty(self):
        n = self.gdb.node()
        self.assertEqual(n.properties, {})

    def test_create_node_properties_dictionary(self):
        n = self.gdb.node(name="John Doe", profession="Hacker")
        self.assertEqual(n.properties, {"name": "John Doe",
                                        "profession": "Hacker"})

    def test_create_node_dictionary(self):
        n = self.gdb.node(name="John Doe", profession="Hacker")
        self.assertEqual(n["name"], "John Doe")

    def test_create_node_get(self):
        n = self.gdb.node(name="John Doe", profession="Hacker")
        self.assertEqual(n.get("name"), "John Doe")

    def test_create_node_get_default(self):
        n = self.gdb.node(name="John Doe", profession="Hacker")
        self.assertEqual(n.get("surname", "Doe"), "Doe")

    def test_create_node_date(self):
        from neo4jrestclient import options as clientSmartDates
        clientSmartDates.SMART_DATES = True
        dt = datetime.utcnow()
        d = dt.date()
        t = dt.time()
        n = self.gdb.nodes.create(name="John Doe", datetime=dt, date=d, time=t)
        self.assertEqual(n.properties, {"name": "John Doe",
                                        "datetime": dt,
                                        "date": d,
                                        "time": t})
        self.assertEqual(n["datetime"], dt)
        self.assertEqual(n["date"], d)
        self.assertEqual(n["time"], t)
        self.assertEqual(n.get("datetime"), dt)
        self.assertEqual(n.get("date"), d)
        self.assertEqual(n.get("time"), t)
        clientSmartDates.SMART_DATES = False

    def test_get_node(self):
        n1 = self.gdb.nodes.create(name="John Doe", profession="Hacker")
        n2 = self.gdb.nodes.get(n1.id)
        self.assertEqual(n1, n2)

    def test_get_node_url(self):
        n1 = self.gdb.nodes.create(name="John Doe", profession="Hacker")
        n2 = self.gdb.nodes.get(n1.url)
        self.assertEqual(n1, n2)

    def test_get_node_dicionary(self):
        n1 = self.gdb.node(name="John Doe", profession="Hacker")
        n2 = self.gdb.node[n1.id]
        self.assertEqual(n1, n2)

    def test_get_node_dicionary_with_false(self):
        n1 = self.gdb.node(name="John Doe", enable=False)
        n2 = self.gdb.node[n1.id]
        self.assertEqual(n1.properties, n2.properties)

    def test_get_node_url_dicionary(self):
        n1 = self.gdb.node(name="John Doe", profession="Hacker")
        n2 = self.gdb.node[n1.url]
        self.assertEqual(n1, n2)

    def test_set_node_property_dictionary(self):
        n1 = self.gdb.node(name="John Doe", profession="Hacker")
        n1["name"] = "Jimmy Doe"
        n2 = self.gdb.node[n1.id]
        self.assertEqual(n1["name"], n2["name"])

    def test_set_node_property(self):
        n1 = self.gdb.node(name="John Doe", profession="Hacker")
        n1.set("name", "Jimmy Doe")
        n2 = self.gdb.nodes.get(n1.id)
        self.assertEqual(n1.get("name"), n2.get("name"))

    def test_set_node_property_date(self):
        from neo4jrestclient import options as clientSmartDates
        clientSmartDates.SMART_DATES = True
        dt = datetime.utcnow()
        n1 = self.gdb.node(name="John Doe", profession="Hacker")
        n1.set("birthdate", dt)
        n2 = self.gdb.nodes.get(n1.id)
        self.assertEqual(n1.get("birthdate"), dt)
        self.assertEqual(n2.get("birthdate"), dt)
        clientSmartDates.SMART_DATES = False

    def test_set_node_properties(self):
        n1 = self.gdb.node(name="John Doe", profession="Hacker")
        n1.properties = {"name": "Jimmy Doe"}
        n2 = self.gdb.node[n1.id]
        self.assertEqual(n1.properties, n2.properties)

    def test_set_node_properties_numbers_set(self):
        n1 = self.gdb.node()
        properties = {"name": "Jimmy Doe", "age": 30, "active": False}
        n1.properties = properties
        self.assertEqual(n1.properties, properties)

    def test_set_node_property_safe(self):
        n1 = self.gdb.node(language="Espaol antigillo")
        n1.set("Idioma de los subttulos", "Espaol antigillo")
        self.assertEqual(n1.get("Idioma de los subttulos"),
                         n1.get("language"))

    def test_set_node_properties_safe(self):
        n1 = self.gdb.node()
        n1.properties = {"Idioma de los subttulos": "Espaol antigillo"}
        n1_properties = n1.properties
        n2 = self.gdb.node[n1.id]
        n2_properties = n2.properties
        self.assertEqual(n1_properties, n2_properties)

    def test_delete_node_property_dictionary(self):
        n1 = self.gdb.node(name="John Doe", profession="Hacker")
        del n1["name"]
        self.assertEqual(n1.get("name", None), None)

    def test_delete_node_property(self):
        n1 = self.gdb.nodes.create(name="John Doe", profession="Hacker")
        n1.delete("name")
        self.assertEqual(n1.get("name", None), None)

    def test_delete_node_properties(self):
        n1 = self.gdb.node(name="John Doe", profession="Hacker")
        del n1.properties
        self.assertEqual(n1.properties, {})

    def test_delete_node(self):
        n1 = self.gdb.nodes.create(name="John Doe", profession="Hacker")
        identifier = n1.id
        n1.delete()
        try:
            self.gdb.nodes.get(identifier)
            self.fail()
        except (NotFoundError, StatusException):
            pass

    def test_node_hash(self):
        n1 = self.gdb.node()
        n2 = self.gdb.node[n1.id]
        self.assertEqual(len(set([n1, n2])), 1)
        self.assertEqual(hash(n1), hash(n2))

########NEW FILE########
__FILENAME__ = test_pickle
# -*- coding: utf-8 -*-
try:
    import cPickle as pickle
except:
    import pickle
import unittest
import os

from neo4jrestclient import client


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class PickleTestCase(GraphDatabaseTesCase):

    def test_gdb(self):
        gdb = self.gdb
        p = pickle.dumps(gdb)
        self.assertEqual(gdb, pickle.loads(p))

    def test_node_pickle(self):
        n = self.gdb.nodes.create()
        p = pickle.dumps(n)
        self.assertEqual(n, pickle.loads(p))

    def test_relationship_pickle(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        r = n1.relationships.create("related", n2)
        p = pickle.dumps(r)
        self.assertEqual(r, pickle.loads(p))

########NEW FILE########
__FILENAME__ = test_query
# -*- coding: utf-8 -*-
from datetime import datetime
import unittest
import os

from neo4jrestclient import client
from neo4jrestclient.exceptions import TransactionException
from neo4jrestclient.utils import text_type


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class QueryTestCase(GraphDatabaseTesCase):

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_raw(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        n1.knows(n2, since=1982)
        q = """start n=node(*) return n"""
        result = self.gdb.query(q=q)
        self.assertTrue(result is not None)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_raw_returns(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        n1.knows(n2, since=1982)
        q = """start n=node(*) return n limit 2"""
        results = self.gdb.query(q=q, returns=[client.Node])
        row1, row2 = results
        m1, m2 = row1[0], row2[0]
        self.assertTrue(isinstance(m1, client.Node))
        self.assertTrue(isinstance(m2, client.Node))

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_raw_returns_tuple(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        rel_type = u"rel%s" % text_type(datetime.now().strftime('%s%f'))
        r = n1.relationships.create(rel_type, n2, since=1982)
        q = """start n=node(*) match n-[r:%s]-() """ \
            """return n, n.name, r, r.since""" % rel_type
        results = self.gdb.query(q, returns=(client.Node, text_type,
                                             client.Relationship))
        for node, name, rel, date in results:
            self.assertTrue(node in (n1, n2))
            self.assertTrue(name in (u"John", u"William"))
            self.assertEqual(rel, r)
            self.assertEqual(date, 1982)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_params_returns_tuple(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        rel_type = u"rel%s" % text_type(datetime.now().strftime('%s%f'))
        r = n1.relationships.create(rel_type, n2, since=1982)
        q = """start n=node(*) match n-[r:`{rel}`]-() """ \
            """return n, n.name, r, r.since"""
        params = {
            "rel": rel_type,
        }
        results = self.gdb.query(q, params=params,
                                 returns=(client.Node, text_type,
                                          client.Relationship))
        for node, name, rel, date in results:
            self.assertTrue(node in (n1, n2))
            self.assertTrue(name in (u"John", u"William"))
            self.assertEqual(rel, r)
            self.assertEqual(date, 1982)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_raw_no_return(self):
        property_name = u"rel%s" % text_type(datetime.now().strftime('%s%f'))
        self.gdb.nodes.create(name="John")
        # This sets a property which we will check later
        q = ("""start n=node(*) WHERE HAS(n.name) AND n.name='John' """
             """SET n.`v{}`=True;""".format(property_name))
        # Notice there is NO return value
        self.gdb.query(q=q)
        # Here, we find all nodes that have this property set
        q = ("""start n=node(*) """
             """WHERE HAS(n.`v{}`) return n;""".format(property_name))
        result = self.gdb.query(q=q)
        self.assertTrue(result is not None)
        # Assuming the properties are set according for the first cypher
        # query, this should always be True
        self.assertTrue(len(result) > 0)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_transaction_reset(self):
        tx = self.gdb.transaction(for_query=True)
        self.assertFalse(tx.finished)
        expires = tx.expires
        tx.reset()
        self.assertNotEqual(expires, tx.expires)
        tx.commit()
        self.assertTrue(tx.finished)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_transaction(self):
        tx = self.gdb.transaction(for_query=True)
        self.assertFalse(tx.finished)
        tx.append("CREATE (a) RETURN a")
        results = tx.commit()
        self.assertEqual(len(results), 1)
        for result in results:
            self.assertEqual(len(result), 1)
            self.assertEqual(result.columns, ["a"])
            for row in result:
                self.assertEqual(row[0]['data'], {})
        self.assertTrue(tx.finished)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_transaction_object(self):
        tx = self.gdb.transaction(for_query=True)
        tx.append("MERGE (a:Person {name:'Alice'})")
        tx.append("MERGE (b:Person {name:'Bob'})")
        tx.append("MATCH (lft { name: 'Alice' }),(rgt) "
                  "WHERE rgt.name IN ['Bob', 'Carl'] "
                  "CREATE (lft)-[r:KNOWS]->(rgt) "
                  "RETURN r",
                  returns=client.Relationship)
        results = tx.execute()
        self.assertTrue(len(results) == 3)
        self.assertTrue(isinstance(results[-1][0][0], client.Relationship))
        self.assertEqual(results[-1][0][0].type, u"KNOWS")
        # send another three statements and commit the transaction
        tx.append("MERGE (c:Person {name:'Carol'})")
        tx.append("MERGE (d:Person {name:'Dave'})")
        results = tx.commit()
        self.assertTrue(len(results) == 2)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_transaction_returns_tuple(self):
        n1 = self.gdb.nodes.create(name="John")
        n2 = self.gdb.nodes.create(name="William")
        rel_type = u"rel%s" % text_type(datetime.now().strftime('%s%f'))
        r = n1.relationships.create(rel_type, n2, since=1982)
        q = """start n=node(*) match n-[r:`{rel}`]-() """ \
            """return n, n.name, r, r.since"""
        params = {
            "rel": rel_type,
        }
        with self.gdb.transaction(for_query=True) as tx:
            results = self.gdb.query(q, params=params,
                                     returns=(client.Node, text_type,
                                              client.Relationship))
        self.assertTrue(tx.finished)
        for node, name, rel, date in results:
            self.assertTrue(node in (n1, n2))
            self.assertTrue(name in (u"John", u"William"))
            self.assertEqual(rel, r)
            self.assertEqual(date, 1982)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_transaction_rollback(self):
        with self.gdb.transaction(for_query=True) as tx:
            self.gdb.query("MERGE (a:Person {name:'Alice'})")
            self.gdb.query("MERGE (b:Person {name:'Bob'})")
            results = self.gdb.query(
                "MATCH (lft { name: 'Alice' }),(rgt) "
                "WHERE rgt.name IN ['Bob', 'Carl'] "
                "CREATE (lft)-[r:KNOWS]->(rgt) "
                "RETURN r",
                returns=client.Relationship
            )
            self.assertTrue(len(results) == 1)
            rel = results[0][0]
            self.assertTrue(isinstance(rel, client.Relationship))
            self.assertEqual(rel.type, u"KNOWS")
            tx.rollback()
        self.assertTrue(len(results) == 0)
        self.assertIsNone(self.gdb.relationships.get(rel.id))

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_transaction_fails(self):
        try:
            with self.gdb.transaction(for_query=True):
                self.gdb.query("strt n=node(*) return n")
        except Exception as e:
            self.assertTrue(isinstance(e, TransactionException))

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_transaction_rollback_after_execute(self):
        tx = self.gdb.transaction(for_query=True)
        tx.append("CREATE (a) RETURN a", returns=client.Node)
        results = tx.execute()
        self.assertTrue(len(results) == 1)
        tx.rollback()
        self.assertTrue(tx.finished)

    @unittest.skipIf(NEO4J_VERSION in ["1.6.3", "1.7.2", "1.8.3", "1.9.7"],
                     "Not supported by Neo4j {}".format(NEO4J_VERSION))
    def test_query_transaction_items_get_populated_after_execute(self):
        tx = self.gdb.transaction(for_query=True)
        tx.append('CREATE (me:User {name: "Me"}) RETURN me;',
                  returns=client.Node)
        results = tx.execute()
        node = results[0][0][0]
        self.assertTrue(node.properties != {})
        self.assertEqual(node["name"], "Me")
        tx.commit()

########NEW FILE########
__FILENAME__ = test_relationships
# -*- coding: utf-8 -*-
import unittest
import os

from neo4jrestclient import client
from neo4jrestclient.exceptions import NotFoundError


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class RelationshipsTestCase(GraphDatabaseTesCase):

    def test_create_relationship(self):
        n1 = self.gdb.node()
        n2 = self.gdb.node()
        rel = n1.Knows(n2)
        self.assertEqual(rel.properties, {})

    def test_create_relationship_functional(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        rel = n1.relationships.create("Knows", n2)
        self.assertEqual(rel.properties, {})

    def test_create_relationship_functional_safe(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        r1 = n1.relationships.create("recommends apa motrhead", n2)
        self.assertEqual(r1.properties, {})
        self.assertEqual(r1.type, "recommends apa motrhead")
        r2 = self.gdb.relationships.get(r1.id)
        self.assertEqual(r1.type, r2.type)

    def test_create_relationship_properties(self):
        n1 = self.gdb.node()
        n2 = self.gdb.node()
        rel = n1.Knows(n2, since=1970)
        self.assertEqual(rel.properties, {"since": 1970})

    def test_set_relationships_properties_numbers_set(self):
        n1 = self.gdb.node()
        n2 = self.gdb.node()
        rel = n1.Knows(n2)
        properties = {"name": "Jimmy Doe", "age": 30, "active": False}
        rel.properties = properties
        self.assertEqual(rel.properties, properties)

    def test_create_relationship_functional_properties(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        rel = n1.relationships.create("Knows", n2, since=1970)
        self.assertEqual(rel.properties, {"since": 1970})

    def test_set_relationship_property_safe(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        rel = n1.relationships.create("Knows", n2,
                                      language="Espaol antigillo")
        rel.set("Idioma de los subttulos", "Espaol antigillo")
        self.assertEqual(rel.get("Idioma de los subttulos"),
                         rel.get("language"))

    def test_set_relationship_properties_safe(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        r1 = n1.relationships.create("Knows", n2)
        r1.properties = {"Idioma de los subttulos": "Espaol antigillo"}
        r1_properties = r1.properties
        r2 = self.gdb.relationships.get(r1.id)
        r2_properties = r2.properties
        self.assertEqual(r1_properties, r2_properties)

    def test_delete_relationship(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        rel = n1.relationships.create("Knows", n2, since=1970)
        rel.delete()
        self.assertEqual(len(n1.relationships.outgoing("Knows")), 0)

    def test_get_relationship(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        rel = n1.relationships.create("Knows", n2, since=1970)
        self.assertTrue(isinstance(rel, client.Relationship))

    def test_delete_relationship_not_found(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        rel = n1.relationships.create("Knows", n2, since=1970)
        rel_id = rel.id
        rel.delete()
        self.assertRaises(NotFoundError, self.gdb.relationships.get,
                          rel_id)

########NEW FILE########
__FILENAME__ = test_transactions
# -*- coding: utf-8 -*-
from datetime import datetime
import unittest
import os

from neo4jrestclient import client
from neo4jrestclient import constants


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class TransactionsTestCase(GraphDatabaseTesCase):

    def test_transaction_delete(self):
        n = self.gdb.nodes.create()
        n["age"] = 25
        with self.gdb.transaction():
            n.delete("age")
        self.assertTrue(isinstance(n, client.Node))
        self.assertTrue("age" not in n.properties)

    def test_transaction_delete_node(self):
        n = self.gdb.nodes.create()
        with self.gdb.transaction():
            n.delete()
        self.assertFalse(n)
        self.assertEqual(n, None)

    def test_transaction_delete_relationship(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        r = n1.relationships.create("relation", n2)
        with self.gdb.transaction():
            r.delete()
        self.assertFalse(r)
        self.assertEqual(r, None)

    def test_transaction_properties(self):
        n = self.gdb.nodes.create()
        n["age"] = 25
        n["place"] = "Houston"
        with self.gdb.transaction():
            n.delete("age")
        self.assertTrue(isinstance(n, client.Node))
        self.assertTrue("age" not in n.properties)
        self.assertTrue("place" in n.properties)

    def test_transaction_properties_update(self):
        n = self.gdb.nodes.create()
        n["age"] = 25
        with self.gdb.transaction(update=False):
            n.delete("age")
        self.assertTrue(isinstance(n, client.Node))
        self.assertTrue("age" in n.properties)

    def test_transaction_create(self):
        with self.gdb.transaction():
            n = self.gdb.nodes.create(age=25)
        self.assertTrue(isinstance(n, client.Node))
        self.assertTrue(n.get("age", True))

    def test_transaction_create_and_set(self):
        with self.gdb.transaction():
            n = self.gdb.nodes.create(age=25)
            n.set("surname", u"AC/DC")
            n["name"] = u"Motrhead"
            self.assertEqual(n.properties, {
                "age": 25,
                "name": u"Motrhead",
                "surname": u"AC/DC",
            })
        self.assertTrue(isinstance(n, client.Node))
        self.assertEqual(n.get("age"), 25)
        self.assertEqual(n.get("name"), u"Motrhead")
        self.assertEqual(n.properties, {
            "age": 25,
            "name": u"Motrhead",
            "surname": u"AC/DC",
        })

    def test_transaction_get(self):
        n = self.gdb.nodes.create()
        n1 = self.gdb.nodes.get(n.id)
        with self.gdb.transaction():
            n2 = self.gdb.nodes.get(n.id)
        self.assertTrue(isinstance(n1, client.Node))
        self.assertTrue(isinstance(n2, client.Node))
        self.assertEqual(n1, n2)

    def test_transaction_property(self):
        n = self.gdb.nodes.create()
        with self.gdb.transaction():
            n["age"] = 25
        self.assertTrue(isinstance(n, client.Node))
        self.assertTrue("age" in n.properties)

    def test_transaction_relationship(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        with self.gdb.transaction():
            r = n1.relationships.create("Knows", n2, since=1970)
        self.assertTrue(isinstance(r, client.Relationship))
        self.assertTrue(r is not None)

    def test_transaction_commit(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        initial_rels = len(n1.relationships)
        rels_number = 10
        with self.gdb.transaction(commit=False) as tx:
            for i in range(1, 1 + rels_number):
                n1.relationships.create("relation_%s" % i, n2)
        pre_commit_rels = len(n1.relationships)
        self.assertEqual(initial_rels, pre_commit_rels)
        tx.commit()
        post_commit_rels = len(n1.relationships)
        self.assertEqual(initial_rels + rels_number, post_commit_rels)

    def test_transaction_globals(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        initial_rels = len(n1.relationships)
        rels_number = 10
        with self.gdb.transaction(using_globals=False) as tx:
            for i in range(1, 1 + rels_number):
                n1.relationships.create("relation_%s" % i, n2, tx=tx)
        self.assertEqual(initial_rels + rels_number, len(n1.relationships))

    def test_transaction_update(self):
        n = self.gdb.nodes.create()
        n["age"] = 25
        with self.gdb.transaction(update=False):
            n.delete("age")
        self.assertTrue(isinstance(n, client.Node))
        self.assertTrue("age" in n.properties)
        n.update()
        self.assertTrue("age" not in n.properties)

    def test_transaction_set(self):
        n = self.gdb.nodes.create()
        n["age"] = 25
        n["name"] = "John"
        n["place"] = "Houston"
        with self.gdb.transaction(commit=False, using_globals=False) as tx:
            n["name"] = tx("Jonathan")
            n["age", tx] = 30
            n.set("place", "Toronto", tx=tx)
        self.assertEqual(n["age"], 25)
        self.assertEqual(n["name"], "John")
        self.assertEqual(n["place"], "Houston")
        tx.commit()
        self.assertEqual(n["age"], 30)
        self.assertEqual(n["name"], "Jonathan")
        self.assertEqual(n["place"], "Toronto")

    def test_transaction_multiple(self):
        n = self.gdb.nodes.create()
        n["age"] = 25
        n["name"] = "John"
        n["place"] = "Houston"
        with self.gdb.transaction(commit=False, using_globals=False) as t1:
            with self.gdb.transaction(commit=False, using_globals=False) as t2:
                n.delete("age", tx=t1)
                n["name"] = t2("Jonathan")
                n["place", t2] = "Toronto"
        self.assertTrue("age" in n.properties)
        t1.commit()
        self.assertTrue("age" not in n.properties)
        self.assertEqual(n["name"], "John")
        self.assertEqual(n["place"], "Houston")
        t2.commit()
        self.assertEqual(n["name"], "Jonathan")
        self.assertEqual(n["place"], "Toronto")

    def test_transaction_list(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        initial_rels = len(n1.relationships)
        relations = []
        rels_number = 10
        with self.gdb.transaction(commit=False) as tx:
            for i in range(1, 1 + rels_number):
                relation = n1.relationships.create("relation_%s" % i, n2)
                relations.append(relation)
        tx.commit()
        self.assertEqual(initial_rels + rels_number, len(n1.relationships))
        self.assertTrue(all([isinstance(r, client.Relationship)]
                            for r in relations))

    def test_transaction_dict(self):
        nodes = {}
        nodes_number = 10
        with self.gdb.transaction():
            for i in range(1, 1 + nodes_number):
                nodes[i] = self.gdb.nodes.create(position=i)
        for position, node in nodes.items():
            self.assertTrue(isinstance(node, client.Node))
            self.assertEqual(position, node["position"])

    def test_transaction_conections(self):
        from neo4jrestclient import options as clientDebug
        clientDebug.DEBUG = True
        id_list = []
        for i in range(5):
            n = self.gdb.nodes.create(number=i)
            id_list.append(n.id)
        nodes = []
        with self.gdb.transaction(commit=False) as tx:
            for i in id_list:
                nodes.append(self.gdb.node[i])
        tx.commit()
        clientDebug.DEBUG = False

    def test_transaction_create_relationship_functional(self):
        with self.gdb.transaction():
            n1 = self.gdb.node()
            n2 = self.gdb.node()
            rel = n1.relationships.create("Knows", n2)
            rel["when"] = "January"
        self.assertEqual(rel.properties, {"when": "January"})

    def test_transaction_create_relationship_functional_mixed1(self):
        n1 = self.gdb.node()
        with self.gdb.transaction():
            n2 = self.gdb.node()
            rel = n1.relationships.create("Knows", n2)
            rel["when"] = "January"
        self.assertEqual(rel.properties, {"when": "January"})

    def test_transaction_create_relationship_functional_mixed2(self):
        n2 = self.gdb.node()
        with self.gdb.transaction():
            n1 = self.gdb.node()
            rel = n1.relationships.create("Knows", n2)
            rel["when"] = "January"
        self.assertEqual(rel.properties, {"when": "January"})

    def test_transaction_create_relationship_functional2(self):
        with self.gdb.transaction():
            n1 = self.gdb.node()
            n2 = self.gdb.node()
            rel = n1.relationships.create("Knows", n2)
            rel["when"] = "January"
            self.assertEqual(rel.start, n1)
            self.assertEqual(rel.end, n2)
        self.assertEqual(rel.properties, {"when": "January"})
        self.assertTrue(isinstance(n1, client.Node))
        self.assertTrue(isinstance(n2, client.Node))

    def test_transaction_create_relationship(self):
        with self.gdb.transaction():
            n1 = self.gdb.node()
            n2 = self.gdb.node()
            rel = n1.Knows(n2)
            rel["when"] = "January"
        self.assertEqual(rel.properties, {"when": "January"})

    # The next tests for transaction were taken from @mhluongo fork
    # https://github.com/mhluongo/neo4j-rest-client
    #        /blob/master/neo4jrestclient/tests.py
    def test_transaction_index_creation(self):
        """
        Tests whether indexes are properly created during a transaction.
        Asserts the creation also behaves transactionally (ie, not until
        commit).
        """
        with self.gdb.transaction():
            i1 = self.gdb.nodes.indexes.create('index_from_tx')
            transactionality_test = i1()
        self.assertTrue(isinstance(transactionality_test, dict))
        self.assertTrue(i1 is not None)
        self.assertTrue(isinstance(i1, client.Index))
        i2 = self.gdb.nodes.indexes.get('index_from_tx')
        self.assertTrue(i1 == i2)

    def test_transaction_add_node_to_index(self):
        """
        Tests whether a node can be added to an index within a transaction.
        Does not assert transactionality.
        """
        n1 = self.gdb.nodes.create()
        index = self.gdb.nodes.indexes.create('index_nodes')
        with self.gdb.transaction():
            index.add('test1', 'test1', n1)
            index['test2']['test2'] = n1
        self.assertTrue(index['test1']['test1'][-1] == n1)
        self.assertTrue(index['test2']['test2'][-1] == n1)

    def test_transaction_index_add_rel_to_index(self):
        """
        Tests whether a relationship can be added to an index within a
        transaction.
        Does not assert transactionality.
        """
        #test nodes
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        r = n1.relationships.create('Knows', n2)
        index = self.gdb.relationships.indexes.create('index_rel')
        with self.gdb.transaction():
            index.add('test1', 'test1', r)
            index['test2']['test2'] = r
        self.assertTrue(index['test1']['test1'][-1] == r)
        self.assertTrue(index['test2']['test2'][-1] == r)

    def test_transaction_index_query(self):
        """
        Tests whether the transaction methods work with index queries.
        Note- this test does not prove query transactionality.
        """
        n1 = self.gdb.nodes.create()
        index = self.gdb.nodes.indexes.create('index2')
        index.add('test2', 'test2', n1)
        # Test getting nodes from index during transaction
        tx = self.gdb.transaction()
        index_hits = index['test2']['test2']
        tx.commit()
        self.assertTrue(n1 == index_hits[-1])

    def test_transaction_remove_node_from_index(self):
        index = self.gdb.nodes.indexes.create('index3')
        n = self.gdb.nodes.create()
        index.add('test3', 'test3', n)
        tx = self.gdb.transaction(using_globals=False)
        index.delete('test3', 'test3', n, tx=tx)
        # Assert transactional
        self.assertTrue(n in index['test3']['test3'])
        tx.commit()
        self.assertTrue(n not in index['test3']['test3'])

    def test_transaction_query_index_for_new_node(self):
        #test nodes created in transaction

        index_name = 'index4%s' % datetime.now().strftime('%s%f')
        index = self.gdb.nodes.indexes.create(index_name)
        tx = self.gdb.transaction(using_globals=False)
        n4 = self.gdb.nodes.create(tx=tx)
        index.add('test3', 'test3', n4, tx=tx)
        # Assert transactional
        transactional = True
        try:
            index['test3']['test3'][0]
            transactional = False
        except:
            pass
        tx.commit()
        self.assertTrue(transactional)
        self.assertTrue(index['test3']['test3'][-1] == n4)

    def test_transaction_add_to_new_index(self):
        """
        Tests whether a node can be added to an index that was created earlier
        in the transaction.
        Does not assert transactionality.
        """
        n1 = self.gdb.nodes.create()
        tx = self.gdb.transaction()
        index = self.gdb.nodes.indexes.create('index5')
        index.add('test1', 'test1', n1)
        tx.commit()
        self.assertTrue(isinstance(index, client.Index))
        self.assertTrue(index['test1']['test1'][-1] == n1)

    def test_transaction_new_node_properties(self):
        """
        Tests setting properties on a node created within the same tx.
        Doesn't show transactionality.
        """
        def has_props(node):
            return n['name'] == 'test' and n['age'] == 0

        tx = self.gdb.transaction()
        n = self.gdb.node()
        n['name'] = 'test'
        n['age'] = 0
        tx_props_kept = has_props(n)
        tx.commit()
        self.assertTrue(tx_props_kept)
        self.assertTrue(has_props(n))

    def test_transaction_properties_class(self):
        def has_props(node):
            return node['test1'] == 'test1' and node['test2'] == 'test2'

        def set_props(node):
            node['test1'] = 'test1'
            node['test2'] = 'test2'

        n1 = self.gdb.node()
        tx = self.gdb.transaction()
        set_props(n1)
        has_props_before_commit = has_props(n1)
        tx.commit()
        self.assertFalse(has_props_before_commit)
        self.assertTrue(has_props(n1))
        tx = self.gdb.transaction()
        n2 = self.gdb.node()
        set_props(n2)
        has_props_before_commit = has_props(n1)
        tx.commit()
        self.assertFalse(has_props_before_commit)
        self.assertTrue(has_props(n2))

    def test_transaction_traversal(self):
        nodes = [self.gdb.nodes.create() for i in range(10)]
        # Chain them into a linked list
        last = None
        for n in nodes:
            if last is not None:
                last.relationships.create("Knows", n)
            last = n

        with self.gdb.transaction():
            tx_n = self.gdb.node()
            last.relationships.create('Knows', tx_n)
            types = [
                client.All.Knows,
            ]
            stop = constants.STOP_AT_END_OF_GRAPH
            traversal = nodes[0].traverse(types=types, stop=stop)

        # a non-transactional traversal will be 1 node short
        self.assertEqual(len(traversal), len(nodes) - 1)

    def test_transaction_create_1000_nodes_relationship(self):
        TAG_DICT = {}
        EDGE_DICT = {}
        operations = 0
        with self.gdb.transaction() as tx:
            for i in range(1, 1000):
                operations = len(tx.operations)
                id1 = i
                id2 = i + 1
                TAG_DICT[id1] = self.gdb.node.create(tag="tag1")
                TAG_DICT[id2] = self.gdb.node.create(tag="tag2")
                RUN = self.gdb.node.create(name="RUN")
                if not (id1, id2) in EDGE_DICT:
                    edge = self.gdb.node(name='EDGE_%04d_%04d' % (id1, id2),
                                         type='edge', tag1=id1, tag2=id2)
                    tag1 = TAG_DICT[id1]
                    tag2 = TAG_DICT[id2]
                    edge.relationships.create("EDGE_TAG", tag1)
                    edge.relationships.create("EDGE_TAG", tag2)
                    RUN.relationships.create("RUN_EDGE", edge)
                    EDGE_DICT[(id1, id2)] = edge
                else:
                    edge = EDGE_DICT[(id1, id2)]
        self.assertTrue(operations >= i)

    def test_transaction_access_node(self):
        frame = self.gdb.node.create()
        with self.gdb.transaction():
            edge = self.gdb.node(name='EDGE')
        rel = frame.FRAME_EDGE(edge)
        self.assertTrue(isinstance(rel, client.Relationship))

    # Test from http://stackoverflow.com/questions/11407546/
    def test_transaction_index_access_create_relationship(self):
        s = self.gdb.node.create(id=1)
        d = self.gdb.node.create(id=2)
        nidx = self.gdb.nodes.indexes.create('nodelist')
        nidx.add('nid', 1, s)
        nidx.add('nid', 2, d)
        nodelist = [(1, 2)]
        with self.gdb.transaction():
            for s_id, d_id in nodelist:
                sn = nidx['nid'][s_id][-1]
                dn = nidx['nid'][d_id][-1]
#                rel = sn.Follows(dn)
#        self.assertTrue(isinstance(rel, client.Relationship))
        self.assertEqual(s, sn)
        self.assertEqual(d, dn)

    # Test from https://github.com/versae/neo4j-rest-client/issues/69
    def test_transaction_split(self):

        with self.gdb.transaction():
            a = self.gdb.nodes.create(name='a')
            b = self.gdb.nodes.create(name='b')

        with self.gdb.transaction():
            a.relationships.create("Test", b)
            c = self.gdb.nodes.create(name='c')
            b.relationships.create("Test", c)
            c.relationships.create("Test", a)

        a = self.gdb.nodes[a.id]
        b = self.gdb.nodes[b.id]
        c = self.gdb.nodes[c.id]

        rel_ab = a.relationships.outgoing()[0]
        assert(rel_ab.start == a and rel_ab.end == b)

        rel_bc = b.relationships.outgoing()[0]
        assert(rel_bc.start == b and rel_bc.end == c)

        rel_ca = c.relationships.outgoing()[0]
        assert(rel_ca.start == c and rel_ca.end == a)

########NEW FILE########
__FILENAME__ = test_traversals
# -*- coding: utf-8 -*-
import unittest
import os

from neo4jrestclient import constants
from neo4jrestclient import client


NEO4J_URL = os.environ.get('NEO4J_URL', "http://localhost:7474/db/data/")
NEO4J_VERSION = os.environ.get('NEO4J_VERSION', None)


class GraphDatabaseTesCase(unittest.TestCase):

    def setUp(self):
        self.url = NEO4J_URL
        self.gdb = client.GraphDatabase(self.url)

    def tearDown(self):
        if self.gdb:
            self.gdb.flush()


class TraversalsTestCase(GraphDatabaseTesCase):

    def test_create_traversal(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        n1.relationships.create("Knows", n2, since=1970)
        types = [
            client.All.Knows,
        ]
        traversal = n1.traverse(types=types)
        self.assertTrue(len(traversal) > 0)

    def test_path_traversal(self):
        """
        Tests the use of Path as returnable type.
        """
        nodes = [self.gdb.nodes.create() for i in range(10)]
        # Chain them into a linked list
        last = None
        for n in nodes:
            if last is not None:
                last.relationships.create("Knows", n)
            last = n
        # Toss in a different relationship type to ensure the
        # STOP_AT_END_OF_GRAPH didn't break traversing by type
        nodes[-1].relationships.create("Test", self.gdb.nodes.create())
        types = [
            client.All.Knows,
        ]
        stop = constants.STOP_AT_END_OF_GRAPH
        traversal = nodes[0].traverse(types=types, stop=stop,
                                      returns=constants.PATH)
        paths = [path for path in traversal]
        self.assertTrue(len(traversal) > 0)
        self.assertTrue(all([isinstance(path, client.Path) for path in paths]))
        start_node = paths[0].start
        relationship = paths[0].relationships[0]
        self.assertTrue(isinstance(start_node, client.Node))
        self.assertTrue(isinstance(relationship, client.Relationship))

    def test_path_traversal_getitem(self):
        # Test from @shahin: https://gist.github.com/1418704
        n1 = self.gdb.node()
        n2 = self.gdb.node()
        rel = self.gdb.relationships.create(n1, 'knows', n2)

        # Define path traverser
        class PathTraverser(self.gdb.Traversal):
            stop = constants.STOP_AT_END_OF_GRAPH
            returns = constants.PATH
        try:
            paths = [traversal for traversal in PathTraverser(n1)]
            self.assertEqual(len(paths[0]), 1)
        except:
            raise
        finally:
            # Clean up on fail
            self.gdb.relationships.delete(rel.id)
            self.gdb.node.delete(n2.id)
            self.gdb.node.delete(n1.id)

    def test_graph_wide_traversal(self):
        """
        Tests the use of constants.STOP_AT_END_OF_GRAPH as a stop depth.
        """
        nodes = [self.gdb.nodes.create() for i in range(10)]
        # Chain them into a linked list
        last = None
        for n in nodes:
            if last is not None:
                last.relationships.create("Knows", n)
            last = n
        # Toss in a different relationship type to ensure the
        # STOP_AT_END_OF_GRAPH didn't break traversing by type
        nodes[-1].relationships.create("Test", self.gdb.nodes.create())
        types = [
            client.All.Knows,
        ]
        stop = constants.STOP_AT_END_OF_GRAPH
        traversal = nodes[0].traverse(types=types, stop=stop)
        self.assertEqual(len(traversal), len(nodes) - 1)
        # Test an untyple traversal
        traversal = nodes[0].traverse(stop=stop)
        self.assertEqual(len(traversal), len(nodes))

    def test_traversal_return_filter(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        n3 = self.gdb.nodes.create(name='test name')
        n1.KNOWS(n2)
        n2.KNOWS(n3)
        #all traversal
        traversal = n1.traverse(stop=3,
                                returnable=constants.RETURN_ALL_NODES)
        self.assertEqual(len(traversal), 3)
        #all but start traversal
        traversal = n1.traverse(stop=3,
                                returnable=constants.RETURN_ALL_BUT_START_NODE)
        self.assertEqual(len(traversal), 2)
        #custom javascript return filter
        return_filter_body = 'position.endNode().hasProperty("name")&&'\
                             'position.endNode().getProperty("name")=="'\
                             'test name";'
        traversal = n1.traverse(stop=3, returnable=return_filter_body)
        self.assertEqual(len(traversal), 1)

    def test_create_traversal_class(self):
        n1 = self.gdb.nodes.create()
        n2 = self.gdb.nodes.create()
        n1.relationships.create("Knows", n2, since=1970)

        class TraversalClass(self.gdb.Traversal):

            types = [
                client.All.Knows,
            ]

        results = []
        for result in TraversalClass(n1):
            results.append(result)
        self.assertTrue(len(results) > 0)

    def test_paginated_traversal(self):
        """
        Tests the use of paginated traversals.
        """
        nodes = [self.gdb.nodes.create() for i in range(10)]
        # Chain them into a linked list
        last = None
        for n in nodes:
            if last is not None:
                last.relationships.create("Knows", n)
            last = n
        # Toss in a different relationship type to ensure the
        # STOP_AT_END_OF_GRAPH didn't break traversing by type
        nodes[-1].relationships.create("Test", self.gdb.nodes.create())
        types = [
            client.All.Knows,
        ]
        stop = constants.STOP_AT_END_OF_GRAPH
        pages = nodes[0].traverse(types=types, stop=stop, page_size=5)
        traversal_length = 0
        pages_count = 0
        for traversal in pages:
            traversal_length += len(traversal)
            pages_count += 1
        self.assertEqual(traversal_length, len(nodes) - 1)
        self.assertEqual(pages_count, 2)
        # And make the same test only passing "paginated" argument
        pages = nodes[0].traverse(types=types, stop=stop, paginated=True)
        traversal_length = 0
        for traversal in pages:
            traversal_length += len(traversal)
        self.assertEqual(traversal_length, len(nodes) - 1)
        # Set a ridiculous time_out for getting no results
        pages = nodes[0].traverse(stop=stop, time_out=0.000001)
        traversal_length = len([n for n in [t for t in pages]])
        self.assertEqual(traversal_length, 0)

    # Taken from the official tests by Neo4j python-embedded
    # https://github.com/neo4j/python-embedded
    #        /blob/master/src/test/python/traversal.py
    def create_data(self):
        with self.gdb.transaction():
            self.source = self.gdb.node(message='hello')
            target = self.gdb.node(message='world')
            relationship = self.source.related_to(target, message="graphy")
            secondrel = target.likes(self.source, message="buh")
            relationship
            secondrel

    def test_traverse_string_types(self):
        self.create_data()
        db = self.gdb
        start_node = self.source
        # START SNIPPET: basicTraversal
        traverser = db.traversal()\
            .relationships('related_to')\
            .traverse(start_node)
        # The graph is traversed as
        # you loop through the result.
        for node in traverser.nodes:
            pass
        # END SNIPPET: basicTraversal
        self.assertEqual(len(list(traverser.nodes)), 1)
        # START SNIPPET: directedTraversal
        from neo4jrestclient.traversals import RelationshipDirection
        OUTGOING = RelationshipDirection.OUTGOING
        INCOMING = RelationshipDirection.INCOMING
        #ANY = RelationshipDirection.ANY
        traverser = db.traversal()\
            .relationships('related_to', OUTGOING)\
            .traverse(start_node)
        # END SNIPPET: directedTraversal
        self.assertEqual(len(list(traverser.nodes)), 1)
        traverser = db.traversal()\
            .relationships('related_to', INCOMING)\
            .relationships('likes')\
            .traverse(start_node)
        # END SNIPPET: multiRelationshipTraversal
        self.assertEqual(len(list(traverser.nodes)), 1)
        # START SNIPPET: traversalResults
        traverser = db.traversal()\
            .relationships('related_to')\
            .traverse(start_node)
        # Get each possible path
        for path in traverser:
            pass
        # Get each node
        for node in traverser.nodes:
            pass
        # Get each relationship
        for relationship in traverser.relationships:
            pass
        # END SNIPPET: traversalResults

    def test_traverse_programmatic_types(self):
        from neo4jrestclient.client import Direction
        self.create_data()
        t = self.gdb.traversal()\
            .depthFirst()\
            .relationships(Direction.ANY.related_to)\
            .traverse(self.source)
        res = list(t.nodes)
        self.assertEqual(len(res), 1)

    def test_uniqueness(self):
        self.create_data()
        db = self.gdb
        start_node = self.source
        # START SNIPPET: uniqueness
        from neo4jrestclient.traversals import Uniqueness
        traverser = db.traversal()\
            .uniqueness(Uniqueness.NODE_PATH)\
            .traverse(start_node)
        # END SNIPPET: uniqueness
        res = list(traverser.nodes)
        self.assertEqual(len(res), 2)

    def test_ordering(self):
        self.create_data()
        db = self.gdb
        start_node = self.source
        # START SNIPPET: ordering
        # Depth first traversal, this
        # is the default.
        traverser = db.traversal()\
            .depthFirst()\
            .traverse(self.source)
        # Breadth first traversal
        traverser = db.traversal()\
            .breadthFirst()\
            .traverse(start_node)
        # END SNIPPET: ordering
        res = list(traverser.nodes)
        self.assertEqual(len(res), 1)

    def test_paths(self):
        self.create_data()
        t = self.gdb.traversal()\
            .traverse(self.source)
        for path in t:
            # START SNIPPET: accessPathStartAndEndNode
            start_node = path.start
            end_node = path.end
            # END SNIPPET: accessPathStartAndEndNode
            self.assertNotEqual(start_node, None)
            self.assertNotEqual(end_node, None)
            # START SNIPPET: accessPathLastRelationship
            #last_relationship = path.last_relationship
            # END SNIPPET: accessPathLastRelationship
            # START SNIPPET: loopThroughPath
            for item in path:
                # Item is either a Relationship,
                # or a Node
                pass
            for nodes in path.nodes:
                # All nodes in a path
                pass
            for nodes in path.relationships:
                # All relationships in a path
                pass
            # END SNIPPET: loopThroughPath
            break

########NEW FILE########
__FILENAME__ = traversals
# -*- coding: utf-8 -*-
# From https://gist.github.com/1865786 by @aventurella
# http://docs.neo4j.org/chunked/snapshot/rest-api-traverse.html
#       #rest-api-traversal-returning-nodes-below-a-certain-depth
from neo4jrestclient import constants
from neo4jrestclient.iterable import Iterable
from neo4jrestclient.request import Request
from neo4jrestclient.exceptions import NotFoundError, StatusException
from neo4jrestclient.utils import string_types


class GraphTraversal(object):
    types = None
    order = None
    stop = None
    returnable = None
    uniqueness = None
    paginated = None
    page_size = None
    time_out = None
    returns = None
    is_returnable = None
    isReturnable = None
    is_stop_node = None
    isStopNode = None

    def __init__(self, start_node=None):
        self.start_node = start_node
        is_returnable = self.is_returnable or self.isReturnable
        is_stop_node = self.is_stop_node or self.isStopNode
        results = self.start_node.traverse(types=self.types,
                                           order=self.order,
                                           stop=self.stop,
                                           returnable=self.returnable,
                                           uniqueness=self.uniqueness,
                                           is_stop_node=is_stop_node,
                                           is_returnable=is_returnable,
                                           paginated=self.paginated,
                                           page_size=self.page_size,
                                           time_out=self.time_out,
                                           returns=self.returns)
        self._items = results
        self._index = len(results)

    def __iter__(self):
        return self

    def __next__(self):
        if self._index == 0:
            raise StopIteration
        self._index = self._index - 1
        return self._items[self._index]

    def next(self):
        return self.__next__()


class Order(object):
    BREADTH_FIRST = constants.BREADTH_FIRST
    DEPTH_FIRST = constants.DEPTH_FIRST


class Uniqueness(object):
    NODE_GLOBAL = constants.NODE_GLOBAL
    NONE = constants.NONE
    RELATIONSHIP_GLOBAL = constants.RELATIONSHIP_GLOBAL
    NODE_PATH = constants.NODE_PATH
    RELATIONSHIP_PATH = constants.RELATIONSHIP_PATH


class RelationshipDirection(object):
    ANY = constants.RELATIONSHIPS_ALL
    ALL = constants.RELATIONSHIPS_ALL
    INCOMING = constants.RELATIONSHIPS_IN
    OUTGOING = constants.RELATIONSHIPS_OUT


class Filters(object):
    """Filters answer the question (return true/false)
    Evaluation.INCLUDE_AND_CONTINUE
    Evaluation.EXCLUDE_AND_CONTINUE
    """
    ALL = {"language": "builtin", "name": constants.RETURN_ALL_NODES}
    ALL_BUT_START_NODE = {
        "language": "builtin",
        "name": constants.RETURN_ALL_BUT_START_NODE,
    }


class PruneEvaluators(object):
    """PruneEvaluators answer the question (return true/false)
    Evaluation.INCLUDE_AND_PRUNE
    Evaluation.EXCLUDE_AND_PRUNE
    """
    pass


class Traverser(object):
    NODE = constants.NODE
    RELATIONSHIP = constants.RELATIONSHIP
    PATH = constants.PATH
    FULLPATH = constants.FULLPATH

    def __init__(self, start_node, data, auth=None, cypher=None):
        self._auth = auth or {}
        self._cypher = cypher
        self._data = data
        self._endpoint = start_node._dic["traverse"]
        self._cache = {}

    def request(self, return_type):
        try:
            return self._cache[return_type]
        except KeyError:
            url = self._endpoint.replace("{returnType}", return_type)
            response = Request(**self._auth).post(url, data=self._data)
            if response.status_code == 200:
                results_list = response.json()
                self._cache[return_type] = results_list
                return results_list
            elif response.status_code == 404:
                raise NotFoundError(response.status_code,
                                    "Node or relationship not found")
            raise StatusException(response.status_code, "Invalid data sent")

    @property
    def nodes(self):
        from neo4jrestclient.client import Node
        results = self.request(Traverser.NODE)
        return Iterable(Node, results, "self", cypher=self._cypher)

    @property
    def relationships(self):
        from neo4jrestclient.client import Relationship
        results = self.request(Traverser.RELATIONSHIP)
        return Iterable(Relationship, results, "self")

    @property
    def fullpaths(self):
        raise NotImplementedError()

    def __iter__(self):
        from neo4jrestclient.client import Path
        results = self.request(Traverser.PATH)
        return Iterable(Path, results, auth=self._auth)


class TraversalDescription(object):
    """https://github.com/neo4j/community/blob/master/kernel/src/main
              /java/org/neo4j/graphdb/traversal/TraversalDescription.java"""

    def __init__(self, auth=None, cypher=None):
        self._auth = auth or {}
        self._cypher = cypher
        self._data = {}
        self.uniqueness(Uniqueness.NODE_GLOBAL)
        # self.max_depth(1)

    def uniqueness(self, value):
        self._data["uniqueness"] = value
        return self

    def filter(self, value):
        try:
            value["language"]
            self._data["return_filter"] = value
        except KeyError:
            self._data["return_filter"] = {
                "language": "javascript",
                "body": value,
            }
        return self

    def prune(self, value, language="javascript"):
        try:
            value["language"]
            self._data["prune_evaluator"] = value
        except KeyError:
            self._data["prune_evaluator"] = {"language": language,
                                             "body": value}

    def order(self, value):
        self._data["order"] = value
        return self

    def depthFirst(self, value=None):
        self.order(Order.DEPTH_FIRST)
        return self

    def breadthFirst(self, value=None):
        self.order(Order.BREADTH_FIRST)
        return self

    def relationships(self, name, direction=RelationshipDirection.ALL):
        self._data["relationships"] = []
        if (not isinstance(name, string_types) and hasattr(name, "type")
                and hasattr(name, "direction")):
            direction = name.direction
            name = name.type
        self.relationships_append(name, direction)
        self.relationships = self.relationships_append
        return self

    def relationships_append(self, name, direction=RelationshipDirection.ALL):
        if (not isinstance(name, string_types) and hasattr(name, "type")
                and hasattr(name, "direction")):
            direction = name.direction
            name = name.type
        self._data["relationships"].append({
            "direction": direction,
            "type": name,
        })
        return self

    def max_depth(self, value):
        self._data["max_depth"] = value

    def traverse(self, start_node):
        try:
            self._data['prune_evaluator']
            del self._data["max_depth"]
        except KeyError:
            pass
        return Traverser(start_node, self._data, auth=self._auth,
                         cypher=self._cypher)


class Traversal(object):

    def __init__(self, start_node):
        self._description = Traversal.description()
        self._start_node = start_node

    @property
    def description(self):
        return self._description

    def __iter__(self):
        return self._description.traverse(self._start_node)

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
import json
import sys
PYTHON_VERSION = sys.version_info
PY2 = sys.version_info[0] == 2

if PY2:
    import urllib
    from urlparse import urlparse
    quote = urllib.quote
    unquote = urllib.unquote
    text_type = unicode
    string_types = (str, unicode)
    unichr = unichr

    def smart_quote(val):
        if isinstance(val, (bool, int, long)):
            return quote(json.dumps(val), safe="")
        elif isinstance(val, float):
            return unicode(val)
        else:
            try:
                safe_key = quote(val, safe="")
            except (KeyError, UnicodeEncodeError, UnicodeError):
                safe_key = quote(val.encode("utf8"), safe="")
            return safe_key

else:
    from urllib.parse import quote, unquote, urlparse
    quote = quote
    unquote = unquote
    text_type = str
    string_types = (str,)
    unichr = chr

    def smart_quote(val):
        if isinstance(val, (bool, int, float)):
            return quote(json.dumps(val), safe="")
        else:
            try:
                safe_key = quote(val, safe="")
            except (KeyError, UnicodeEncodeError, UnicodeError):
                safe_key = quote(val.encode("utf8"), safe="")
            return safe_key


def in_ipnb():
    """
    check if we're inside an IPython Notebook
    https://github.com/pydata/pandas/blob/master/pandas/core/common.py#L2508
    """
    try:
        ip = get_ipython()
        front_end = (
            ip.config.get('KernelApp', {}).get('parent_appname', "") or
            ip.config.get('IPKernelApp', {}).get('parent_appname', "")
        )
        if 'notebook' in front_end.lower():
            return True
    except:
        return False
    return False


def get_auth_from_uri(uri):
    splits = urlparse(uri)
    if splits.port:
        port = u":%s" % splits.port
    else:
        port = u""
    if splits.query and splits.fragment:
        root_uri = "%s://%s%s%s?%s#%s" % (splits.scheme, splits.hostname,
                                          port, splits.path,
                                          splits.query, splits.fragment)
    elif splits.query:
        root_uri = "%s://%s%s%s?%s" % (splits.scheme, splits.hostname,
                                       port, splits.path,
                                       splits.query)
    elif splits.fragment:
        root_uri = "%s://%s%s%s#%s" % (splits.scheme, splits.hostname,
                                       port, splits.path,
                                       splits.fragment)
    else:
        root_uri = "%s://%s%s%s" % (splits.scheme, splits.hostname,
                                    port, splits.path)
    return splits.username, splits.password, root_uri

########NEW FILE########
