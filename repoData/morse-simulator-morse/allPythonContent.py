__FILENAME__ = io_export_morse_scene
#--- ### Header
bl_info = {
    "name": "MORSE export scene as Python API (.py)",
    "author": "Gilberto Echeverria",
    "version": (1, 0, 0),
    "blender": (2, 5, 9),
    "api": 36147,
    "location": "File>Import-Export",
    "category": "MORSE",
    #"category": "Import-Export",
    "description": "Save a MORSE scene as a Python description",
    "warning": "",
    "wiki_url": "",
    "tracker_url": "https://softs.laas.fr/bugzilla/"
}

import os
import bpy
import json
import re
from morse.builder.data import *

"""
Morse API to save scene files

To test this module you can open this file inside a Text panel in Blender,
then run the script.
This will generate a python file in the same directory where Blender was first executed.
"""

morse_types = {
    "robots": "Robot",
    "sensors": "Sensor",
    "actuators": "Actuator",
    "middleware": "Middleware",
    "modifiers": "Modifier",
}

def save_translation(obj, obj_name):
    # Set its position
    position_string = ''
    text_buffer = ''
    component_position = obj.location
    if component_position[0] != 0:
        position_string += 'x=%.4f' % component_position[0]
    if component_position[1] != 0:
        if position_string != '':
            position_string += ', '
        position_string += 'y=%.4f' % component_position[1]
    if component_position[2] != 0:
        if position_string != '':
            position_string += ', '
        position_string += 'z=%.4f' % component_position[2]
    # Register a translation only if necessary
    if position_string != '':
        text_buffer += "%s.translate(%s)\n" % (obj_name, position_string)

    return (text_buffer)


def save_rotation(obj, obj_name):
    # Set its rotation
    rotation_string = ''
    text_buffer = ''
    component_rotation = obj.rotation_euler
    if component_rotation[0] != 0:
        rotation_string += 'x=%.4f' % component_rotation[0]
    if component_rotation[1] != 0:
        if rotation_string != '':
            rotation_string += ', '
        rotation_string += 'y=%.4f' % component_rotation[1]
    if component_rotation[2] != 0:
        if rotation_string != '':
            rotation_string += ', '
        rotation_string += 'z=%.4f' % component_rotation[2]
    # Register a translation only if necessary
    if rotation_string != '':
        text_buffer += "%s.rotate(%s)\n" % (obj_name, rotation_string)

    return (text_buffer)


def save_properties(obj, obj_name):
    text_buffer = ''
    # Store the properties of the component
    for key,prop in obj.game.properties.items():
        if key not in ['Robot_Tag', 'Component_Tag', 'Middleware_Tag', 'Modifier_Tag', 'Class', 'Path']:
            if prop.value != '':
                if prop.type == 'STRING':
                    text_buffer += "%s.properties(%s = '%s')\n" % (obj_name, key, prop.value)
                elif prop.type == 'FLOAT' or prop.type == 'TIMER':
                    text_buffer += "%s.properties(%s = %.4f)\n" % (obj_name, key, prop.value)
                else:
                    text_buffer += "%s.properties(%s = %s)\n" % (obj_name, key, prop.value)

    return (text_buffer)


def scan_scene (file_out):
    """ Read all the MORSE components from a Blender file

    Create lists of robots and components to save them as a text file
    """
    file_out.write("from morse.builder import *\n\n")

    robot_text = ''
    component_text = ''

    for obj in bpy.data.objects:
        try:
            component_path = obj.game.properties['Path'].value
        # Exit if the object is not a MORSE component
        except KeyError as detail:
            continue

        # Ignore middleware and modifier empties.
        # These will be added dinamically by the builder
        if 'middleware' in component_path or 'modifiers' in component_path:
            continue

        # Read what type of component this is,
        #  from the source of its python file
        path_elements = component_path.split('/')
        component_type = path_elements[-2]
        component_name = path_elements[-1]

        builder_type = morse_types[component_type]

        # Swap dots for underscores in object names
        obj_name = re.sub('\.', '_', obj.name)
        # Create the object instance
        if component_type == 'robots':
            robot_text += "%s = %s('%s')\n" % (obj_name, builder_type, component_name)
            robot_text += save_translation(obj, obj_name)
            robot_text += save_rotation(obj, obj_name)
            robot_text += save_properties(obj, obj_name)
            robot_text += "\n"

        # Assign component to the parent
        if component_type == 'sensors' or component_type == 'actuators':
            component_text += "%s = %s('%s')\n" % (obj_name, builder_type, component_name)
            component_text += save_translation(obj, obj_name)
            component_text += save_rotation(obj, obj_name)
            parent_name = re.sub('\.', '_', obj.parent.name)
            component_text += "%s.append(%s)\n" % (parent_name, obj_name)
            component_text += save_properties(obj, obj_name)
            component_text += "\n"

    # Write the buffers to the text file
    file_out.write("# Robots\n")
    file_out.write(robot_text)
    file_out.write("# Components\n")
    file_out.write(component_text)


def scan_config(file_out):
    """ Parse the contents of 'component_config.py'
    
    Produce a configuration file that 'morsebuilder' can use to
    configure the robot/middleware bindings in a scene. 
    """
    import component_config
    file_out.write("# Scene configuration\n")
    for key,value in component_config.component_datastream.items():
        component = re.sub('\.', '_', key)
        # If the 'value' variable contains only strings, use that string
        #  as the name of the middleware.
        # This is done for backwards compatibility with the previous
        #  syntax that allowed only one middleware per component
        if isinstance (value[0], str):
            mw = value[0]
            mw = mw.lower()
            file_out.write("%s.add_stream('%s', %s)\n" % (component, mw, value))
        # If using the new syntax that allows more than one middleware
        #  per component
        else:
            for item in value:
                mw = item[0]
                mw = mw.lower()
                file_out.write("%s.add_stream('%s', %s)\n" % (component, mw, item))

    try:
        component_config.component_service
        file_out.write("\n")
        for key,value in component_config.component_service.items():
            component = re.sub('\.', '_', key)
            mw = re.search('(\w+)_request_manager', value[0])
            file_out.write("%s.configure_service('%s')\n" % (component, mw.group(1)))
    except AttributeError as detail:
        print ("\tNo services configured")

    try:
        component_config.component_modifier
        file_out.write("\n")
        for key,value in component_config.component_modifier.items():
            component = re.sub('\.', '_', key)
            mod = value[0]
            file_out.write("%s.configure_modifier(%s)\n" % (component, mod))
    except AttributeError as detail:
        print ("\tNo modifiers configured")

def get_environment():
    try:
        ssh = bpy.data.objects['Scene_Script_Holder']
        environment_file = ssh.game.properties['environment_file'].value
    except KeyError as detail:
        environment_file = 'indoors-1/indoor-1'
        print ("No environment file specified in 'Scene_Script_Holder'\nUsing '%s' as default" % environment_file)

    return environment_file


def save_scene():
    print ("\nRunning from %s" % bpy.data.filepath)
    filename = bpy.path.display_name_from_filepath(bpy.data.filepath) + ".py"
    file_out = open(filename, "w")
    print ("Saving scene robot configuration to file '%s'" % filename)
    scan_scene(file_out)
    scan_config(file_out)
    env_name = get_environment()
    file_out.write("\nenv = Environment('%s')" % env_name)
    file_out.write("\nenv.create()")
    file_out.close()
    print ("Configuration saved")


#--- ### Operator
class MorseExporter(bpy.types.Operator):
    ''' Convert a MORSE scene configuration to a python script '''
    bl_idname = "export_scene.morse"
    bl_label = "Save MORSE scene"
    bl_description = "Convert a MORSE scene configuration to a python script"

    #--- Blender interface methods
    # Check that this is a MORSE scene
    @classmethod
    def poll(self, context):
        return ('Scene_Script_Holder' in bpy.data.objects)

    def execute(self, context):
        save_scene()
        return {'FINISHED'}


def menu_draw(self, context):
    self.layout.operator_context = 'INVOKE_REGION_WIN'
    self.layout.operator(MorseExporter.bl_idname, "Save MORSE scene (.py)")

#--- ### Register
def register():
    bpy.utils.register_module(__name__)
    bpy.types.INFO_MT_file_export.prepend(menu_draw)
def unregister():
    bpy.types.INFO_MT_file_export.remove(menu_draw)
    bpy.utils.unregister_module(__name__)

#--- ### Main code
if __name__ == '__main__':
    register()
    #save_scene()

########NEW FILE########
__FILENAME__ = io_import_morse_path
#--- ### Header
bl_info = {
    "name": "MORSE import robot path (.pth)",
    "author": "Gilberto Echeverria",
    "version": (1, 0, 0),
    "blender": (2, 6, 0),
    "api": 41092,
    "location": "File>Import-Export",
    "category": "MORSE",
    #"category": "Import-Export",
    "description": "Load a 2D path stored as a set of X, Y, yaw",
    "warning": "",
    "wiki_url": "",
    "tracker_url": "https://softs.laas.fr/bugzilla/"
}

import bpy


class MorseLoadTextPath(bpy.types.Operator):
    """ Load the path followed by a robot in MORSE
    The input is a text file with three floats per line: X, Y, yaw"
    """
    bl_idname = "import_mesh.morse_path"
    bl_label = "Import robot path (.pth)"
    bl_description = "Load the path followed by a robot in MORSE"

    segment_counter = 1
    mat = None
    origin_object = None

    filepath  = bpy.props.StringProperty(subtype='FILE_PATH')
    use_origin = bpy.props.BoolProperty(name="Snap to selected object", description="Snap the path to the currently selected object (location and rotation)", default=True)
    path_color = bpy.props.FloatVectorProperty(subtype='COLOR', default=(0.7, 0.1, 0.0), description="Path color")

    @classmethod
    def poll(self, context):
        return (context.mode == 'OBJECT')

    def execute(self, context):
        """ Processes a click on the "submit" button in the filebrowser window '"""
        self.init_material()
        print("Input path file is: '%s'" % self.filepath)
        self.read_morse_path(self.filepath)
        return {'FINISHED'}

    def invoke(self, context, event):
        """ Processes the call to the path importer from the menu.
        Opens a filebrowser window
        """
        wm = context.window_manager
        wm.fileselect_add(self)

        # Place the path at the currently selected object.
        # If there are more than one selected, use the active one
        if self.use_origin and bpy.context.selected_objects != []:
            self.origin_object = bpy.context.active_object
            print ("Using the object '%s' as the origin of the path" % self.origin_object)
            
        return {'RUNNING_MODAL'}

    def draw(self, context):
        """ Define the menu to be shown when loading a path file """
        layout = self.layout

        layout.prop(self, "use_origin")
        box = layout.box()
        box.label(text="Path color:")
        box.prop(self, "path_color")


    def new_segment(self, location, orientation):
        """ Add a new segment to draw a path

        :param location: 3D coordinates of the waypoint
        :param orientation: Euler array for the orientation of the segment
        """
        # Give a name to the new segment
        new_name = "Segment%d" % self.segment_counter
        self.segment_counter += 1

        # Define the coordinates of the vertices.
        #  Each vertex is defined by 3 consecutive floats.
        coords=[(-0.5, -0.1, -0.1), (-0.5, 0.1, -0.1), (-0.5, 0.1 ,0.1), \
        (-0.5, -0.1, 0.1), (0.5, 0.0, 0.0)]

        # Define the faces by index numbers.
        #  Each faces is defined by 3 or 4 consecutive integers.
        faces=[ (2,1,0,3), (0,1,4), (1,2,4), (2,3,4), (3,0,4)]

        # Create the mesh
        mesh = bpy.data.meshes.new(new_name+"Mesh")
        # Add the new material
        mesh.materials.append(self.mat)
        # Create an object with that mesh
        obj = bpy.data.objects.new(new_name, mesh)
        # Set physics simulation to no collision
        obj.game.physics_type = 'NO_COLLISION'
        # Position and orient the object using the parameters provided
        obj.location = location
        obj.rotation_euler = orientation
        # Link object to scene
        bpy.context.scene.objects.link(obj)

        # Fill the mesh with verts, edges, faces
        # edges or faces should be [], or you ask for problems
        mesh.from_pydata(coords,[],faces)
        # Update mesh with new data
        mesh.update(calc_edges=True)


    def init_material(self):
        """ Create a new material for the segments """
        self.mat = bpy.data.materials.new("PathMat")
        self.mat.diffuse_color = self.path_color
        # Disable the shadows on the path object
        self.mat.use_shadows = False
        self.mat.use_cast_buffer_shadows = False


    def read_morse_path(self, filename):
        """ Get the position and orientation of a robot trajectory

        Read the data from a file in the .pth format (3 floats for X, Y, yaw)
        :param filename: name of the path file
        """
        # Open the file
        fp = open(filename, "r")
        for line in fp:
            # Extract the position of the robot
            coords = line.split()
            try:
                segment_position = [float(coords[0]), float(coords[1]), 0.0]
                segment_orientation = [0.0, 0.0, float(coords[2])]
            except ValueError as detail:
                print ("Invalid token in file '%s': %s" % (filename, detail))
                print ("Aborting import")
                return

            self.new_segment(segment_position, segment_orientation)

        # A trick to make the selection and join correctly
        # First select one of the segments. This will be the Active Object
        active_segment = bpy.data.objects["Segment1"]
        active_segment.select = True
        bpy.context.scene.objects.active = active_segment
        # Then select all the rest. This does not change the Active Object
        bpy.ops.object.select_pattern(pattern="Segment*")
        # Join. The active Object must be selected
        bpy.ops.object.join()

        # Change the name of the object
        obj = bpy.context.active_object
        obj.name = "Path"

        # Locate the path if there is a selected object
        if self.origin_object is not None:
            obj.location = self.origin_object.location
            obj.rotation_euler = self.origin_object.rotation_euler


def menu_draw(self, context):
    self.layout.operator_context = 'INVOKE_REGION_WIN'
    self.layout.operator(MorseLoadTextPath.bl_idname, "Load MORSE path (.pth)")


#--- ### Register
def register():
    bpy.utils.register_module(__name__)
    bpy.types.INFO_MT_file_import.prepend(menu_draw)
def unregister():
    bpy.types.INFO_MT_file_import.remove(menu_draw)
    bpy.utils.unregister_module(__name__)

#--- ### Main code
if __name__ == '__main__':
    register()

########NEW FILE########
__FILENAME__ = io_import_morse_text
#--- ### Header
bl_info = {
    "name": "MORSE import robot path from text log",
    "author": "Gilberto Echeverria",
    "version": (1, 0, 0),
    "blender": (2, 6, 0),
    "api": 41092,
    "location": "File>Import-Export",
    "category": "MORSE",
    #"category": "Import-Export",
    "description": "Load a path followed by a robot in MORSE, stored by the text log middleware",
    "warning": "",
    "wiki_url": "",
    "tracker_url": "https://softs.laas.fr/bugzilla/"
}

import bpy
import re
import os


class MorseLoadTextCoords(bpy.types.Operator):
    """ Load the path followed by a robot in MORSE
    The input is a text log file generated by the MORSE text middleware
    """
    bl_idname = "import_mesh.morse_text_coords"
    bl_label = "Import MORSE path from text log"
    bl_description = "Load the path followed by a robot in MORSE"

    segment_counter = 1
    mat = None

    filepath  = bpy.props.StringProperty(subtype='FILE_PATH')
    path_color = bpy.props.FloatVectorProperty(subtype='COLOR', default=(0.7, 0.1, 0.0), description="Path color")
    skip_frames = bpy.props.IntProperty(default=10, description="Number of frames to skip between marks")

    @classmethod
    def poll(self, context):
        return (context.mode == 'OBJECT')

    def execute(self, context):
        """ Processes a click on the "submit" button in the filebrowser window '"""
        self.init_material()
        print("Input path file is: '%s'" % self.filepath)
        self.read_morse_log(self.filepath)
        return {'FINISHED'}

    def invoke(self, context, event):
        """ Processes the call to the path importer from the menu.
        Opens a filebrowser window
        """
        wm = context.window_manager
        wm.fileselect_add(self)
        return {'RUNNING_MODAL'}

    def draw(self, context):
        """ Define the menu to be shown when loading a path file """
        layout = self.layout

        layout.label(text="Number of frames to skip:")
        layout.prop(self, "skip_frames")

        box = layout.box()
        box.label(text="Path color:")
        box.prop(self, "path_color")


    def new_segment(self, location, orientation):
        """ Add a new segment to draw a path

        :param location: 3D coordinates of the waypoint
        :param orientation: Euler array for the orientation of the segment
        """
        # Give a name to the new segment
        new_name = "Segment%d" % self.segment_counter
        self.segment_counter += 1

        # Define the coordinates of the vertices.
        #  Each vertex is defined by 3 consecutive floats.
        coords=[(-0.5, -0.1, -0.1), (-0.5, 0.1, -0.1), (-0.5, 0.1 ,0.1), \
        (-0.5, -0.1, 0.1), (0.5, 0.0, 0.0)]

        # Define the faces by index numbers.
        #  Each faces is defined by 3 or 4 consecutive integers.
        faces=[ (2,1,0,3), (0,1,4), (1,2,4), (2,3,4), (3,0,4)]

        # Create the mesh
        mesh = bpy.data.meshes.new(new_name+"Mesh")
        # Add the new material
        mesh.materials.append(self.mat)
        # Create an object with that mesh
        obj = bpy.data.objects.new(new_name, mesh)
        # Set physics simulation to no collision
        obj.game.physics_type = 'NO_COLLISION'
        # Position and orient the object using the parameters provided
        obj.location = location
        obj.rotation_euler = orientation
        # Link object to scene
        bpy.context.scene.objects.link(obj)

        # Fill the mesh with verts, edges, faces
        # edges or faces should be [], or you ask for problems
        mesh.from_pydata(coords,[],faces)
        # Update mesh with new data
        mesh.update(calc_edges=True)


    def init_material(self):
        """ Create a new material for the segments """
        self.mat = bpy.data.materials.new("SegmentMat")
        self.mat.diffuse_color = self.path_color
        # Disable the shadows on the path object
        self.mat.use_shadows = False
        self.mat.use_cast_buffer_shadows = False


    def read_morse_log(self, filename):
        """ Get the position and orientation of a robot trajectory

        Read the data from a file generated by the 'text' middleware in MORSE
        :param filename: name of the log file
        """
        # Skip up to this number of data points
        #self.skip_frames = 60
        skip_counter = 0

        # Open the file
        fp = open(filename, "r")
        print ("Parsing file '%s'" % filename)
        for line in fp:
            if line.startswith("==>"):
                if skip_counter == 0:
                    result = re.search("\[(.*)\].*\[(.*)\]", line)
                    # Extract the position of the robot
                    coords = result.group(1).split()
                    segment_position = [float(coords[0]), float(coords[1]), float(coords[2])]
                    # Extract the orientation of the robot
                    angles = result.group(2).split()
                    # Make sure to use the correct indices.
                    # Input data is in yaw, pitch, roll order
                    #  which translates to z, y, x
                    segment_orientation = [float(angles[2]), float(angles[1]), float(angles[0])]

                    self.new_segment(segment_position, segment_orientation)

                # Update the skip_counter
                skip_counter = (skip_counter + 1) % self.skip_frames

        # A trick to make the selection and join correctly
        # First select one of the segments. This will be the Active Object
        active_segment = bpy.data.objects["Segment1"]
        active_segment.select = True
        bpy.context.scene.objects.active = active_segment
        # Then select all the rest. This does not change the Active Object
        bpy.ops.object.select_pattern(pattern="Segment*")
        # Join. The active Object must be selected
        bpy.ops.object.join()

        # Change the name of the object
        obj = bpy.context.active_object
        obj.name = "Path"



def menu_draw(self, context):
    self.layout.operator_context = 'INVOKE_REGION_WIN'
    self.layout.operator(MorseLoadTextCoords.bl_idname, "Load MORSE path from log (.txt)")


#--- ### Register
def register():
    bpy.utils.register_module(__name__)
    bpy.types.INFO_MT_file_import.prepend(menu_draw)
def unregister():
    bpy.types.INFO_MT_file_import.remove(menu_draw)
    bpy.utils.unregister_module(__name__)

#--- ### Main code
if __name__ == '__main__':
    register()

########NEW FILE########
__FILENAME__ = morse_object_utils
bl_info = {
    "name": "Morse Utils",
    "description": "Utils for Environment Creation for MORSE",
    "author": "Sebastian Schmidt",
    "version": (0,5,0),
    "blender": (2, 61, 0),
    "api": 39307,
    "location": "Logic",
    "warning": '',
    "wiki_url": "",
    "tracker_url": "",
    "category": "Morse"}


import bpy
from bpy.props import *


def update(self, context):
    objects = []
    for index, obj in enumerate(bpy.context.scene.objects):
        objects.append((str(index), obj.name, str(index)))
    return objects
     
class MorseSwitchDialog(bpy.types.Operator):
    '''
    Make Switches usable for the Human
    '''
    bl_idname = "object.morse_switch_dialog"
    bl_label = "Morse Switch"


    objs = {}
    inv_objs = {}
    
    try:
        bpy.app.handlers.scene_update_post
        handler_available = True
        master = EnumProperty(name = "Switch",items = update)
    except AttributeError:
        handler_available = False
        master = StringProperty(name = "Switch")
    on = BoolProperty(name = "On")

    def update_dict(self, context):
        objs = {}
        inv_objs = {}
        for index, obj in enumerate(bpy.context.scene.objects):
            objs[str(index)] = obj.name
            inv_objs[obj.name] = str(index)
        self.objs = objs
        self.inv_objs = inv_objs
        
    
    def assignProp(self, context, name, value):
        prop = context.object.game.properties[name]
        prop.value = value

    def execute(self, context):
        obj = context.active_object

        obj.game.use_actor = True

        if not 'Switch' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Switch'
            prop.type = 'STRING'

        self.assignProp(context, 'Switch', self.objs[self.master] if self.handler_available else self.master)

        
        try:
            master = context.scene.objects[obj.game.properties['Switch'].value]
            context.scene.objects.active = master
            if not 'On' in master.game.properties:
                bpy.ops.object.game_property_new()
                prop = context.object.game.properties[-1]
                prop.name = 'On'
                prop.type = 'BOOL'

            self.assignProp(context, 'On', self.on)
        except KeyError:
            self.report({'INFO'}, "No object with this name - switch will not function in simulation")

        return{'FINISHED'}
            
    def invoke(self, context, event):
        self.update_dict(context)
        obj = context.object

        if 'Switch' in obj.game.properties:
            if self.handler_available:
                self.master = self.inv_objs[obj.game.properties['Switch'].value]
            else:
                self.master = obj.game.properties['Switch'].value

        return context.window_manager.invoke_props_dialog(self)
    
class MorseObjectDialog(bpy.types.Operator):
    '''
    Operator class that assigns a "Object" and a "Description" Property,
    makes it a Rigid Body with Collision Bounds and Mass
    '''
    bl_idname = "object.morse_object_dialog"
    bl_label = "Morse Object"

    object = BoolProperty(name = "Object")
    graspable = BoolProperty(name = "Graspable")
    label = StringProperty(name = "Label")
    description = StringProperty(name="Description")
    typeProp = StringProperty(name = "Type")
    mass = FloatProperty(name = "Mass")
    bounds = EnumProperty(name="Collision Bounds",
        items = [('one', 'Box', 'Box'), 
                 ('two', 'Sphere', 'Sphere'),
                 ('three', 'Capsule', 'Capsule'), 
                 ('four', 'Cylinder', 'Cylinder'),
                 ('five', 'Cone', 'Cone'),
                 ('six', 'Convex Hull', 'Convex Hull'),
                 ('seven', 'Triangle Mesh', 'Triangle Mesh')])
    
    items = {'one':'BOX', 'two':'SPHERE', 'three':'CAPSULE', 'four':'CYLINDER',
             'five':'CONE', 'six':'CONVEX_HULL', 'seven':'TRIANGLE_MESH'}
    inv_items = {'BOX': 'one', 'CYLINDER': 'four', 'TRIANGLE_MESH': 'seven',
                 'SPHERE': 'two', 'CAPSULE': 'three', 'CONE': 'five',
                 'CONVEX_HULL': 'six'}

    
    def assignProp(self, context, name, value):
        prop = context.object.game.properties[name]
        prop.value = value
    
    def execute(self, context):
        obj = bpy.context.active_object
        
        # add game properties if needed
        if not 'Object' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Object'
            prop.type = 'BOOL'
        
        if not 'Description' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Description'
            prop.type = 'STRING'

        if not 'Label' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Label'
            prop.type = 'STRING'

        if not 'Type' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Type'
            prop.type = 'STRING'

        if not 'Graspable' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Graspable'
            prop.type = 'BOOL'
    
        self.assignProp(context, 'Object', self.object)
        self.assignProp(context, 'Description', self.description)
        self.assignProp(context, 'Label', self.label)
        self.assignProp(context, 'Type', self.typeProp)
        self.assignProp(context, 'Graspable', self.graspable)
        
        if not 'Collision' in obj.game.sensors:
            bpy.ops.logic.sensor_add(type = 'NEAR')
            sens = context.object.game.sensors[-1]
            sens.name = 'Collision'
            sens.distance = 0.05
            sens.reset_distance = 0.075

            bpy.ops.logic.controller_add()
            contr = context.object.game.controllers[-1]

            contr.link(sensor = sens)

        
        # make the object a rigid body
        obj.game.physics_type = 'RIGID_BODY'
        obj.game.use_collision_bounds = True
        obj.game.collision_bounds_type = self.items[self.bounds]
        obj.game.mass = self.mass
        
        return {'FINISHED'}
 
    def invoke(self, context, event):
        obj = context.object
        # check not to overwrite anything already set
        if 'Object' in obj.game.properties:
            self.object = obj.game.properties['Object'].value
        else:
            self.object = True
        if 'Label' in obj.game.properties:
            self.label = obj.game.properties['Label'].value
        else:
            self.label = context.object.name
        if 'Description' in obj.game.properties:
            self.description = obj.game.properties['Description'].value
        else:
            self.description = context.object.name
        if 'Graspable' in obj.game.properties:
            self.graspable = obj.game.properties['Graspable'].value
        else:
            self.graspable = True
        if 'Type' in obj.game.properties:
            self.typeProp = obj.game.properties['Type'].value
        else:
            self.typeProp = "Object"


        
        self.mass = obj.game.mass
        self.bounds = self.inv_items[obj.game.collision_bounds_type]
        return context.window_manager.invoke_props_dialog(self)

 
class MorseDrawerDialog(bpy.types.Operator):
    '''
    Operator class that assigns a "Drawer", a "Description" and a "Open"
    Property, and the logic needed for Animation
    '''
    bl_idname = "object.morse_drawer_dialog"
    bl_label = "Morse Drawer"
 
    drawer = StringProperty(name = "Drawer")
    description = StringProperty(name="Description")
    end_frame = IntProperty(name = "End Frame")
    open = BoolProperty(name = "Open")

    if bpy.app.version >= (2, 60, 0):
        direction = EnumProperty(name = "Generate Action",
                             items = [('one', 'No', 'one'),
                                      ('two', 'X+', 'two'),
                                      ('three', 'X-', 'three'),
                                      ('four', 'Y+', 'four'),
                                      ('five', 'Y-', 'five')])

        vec = {'two':(1.0, 0.0, 0.0), 'three':(-1.0, 0.0, 0.0), 'four':(0.0, 1.0, 0.0), 'five':(0.0, -1.0, 0.0)}
    else:
        direction = 'one'
        # means no action generation
    
    def generate_action(self, endframe, direction):
        # create an action
        action = bpy.data.actions.new(name = bpy.context.object.name + 'Open')
        bpy.context.object.animation_data_create()
        bpy.context.object.animation_data.action = action
        
        # set starting keyframe
        bpy.ops.anim.change_frame(frame = 0)
        bpy.ops.anim.keyframe_insert(type = 'Location')
        
        # set endframe 
        bpy.ops.anim.change_frame(frame = endframe)
        dim = bpy.context.object.dimensions
        translate_tuple = tuple(0.8 * dim[i] * direction[i] for i in range(0,3))    
        bpy.ops.transform.translate(value = translate_tuple)
        bpy.ops.anim.keyframe_insert(type = 'Location')
        
        
        bpy.ops.anim.change_frame(frame = 0)
        
        return action
        
    def assignProp(self, context, name, value):
        prop = context.object.game.properties[name]
        prop.value = value
    
    def execute(self, context):
        obj = bpy.context.active_object
        
        # add game properties if needed
        if not 'Drawer' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Drawer'
            prop.type = 'STRING'
        
        if not 'Open' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Open'
            prop.type = 'BOOL'
        
        if not 'Description' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Description'
            prop.type = 'STRING'
            
        self.assignProp(context, 'Drawer', self.drawer)
        self.assignProp(context, 'Open', self.open)
        self.assignProp(context, 'Description', self.description)
        
        # make the drawer an actor
        obj.game.use_actor = True

        # generate action
        if self.direction != 'one':
            action = self.generate_action(self.end_frame,self.vec[self.direction])
        else:
            action = None
        
        # set the logic to open and close the drawer if needed
        if 'Open' not in context.object.game.sensors:
            bpy.ops.logic.sensor_add(type = 'PROPERTY')
            sens = context.object.game.sensors[-1]
            sens.name = 'Open'
            sens.property = 'Open'
            sens.value = 'True'
        
            bpy.ops.logic.controller_add()
            contr = context.object.game.controllers[-1]
        
            contr.link(sensor=sens)
        
            if bpy.app.version < (2, 60, 0):
                bpy.ops.logic.actuator_add(type = 'FCURVE')
            else:
                bpy.ops.logic.actuator_add(type = 'ACTION')
            act = context.object.game.actuators[-1]
            act.name = 'Open'
            if action:
                act.action = action
        
            contr.link(actuator=act)
        
        
        if 'Close' not in context.object.game.sensors:
            bpy.ops.logic.sensor_add(type = 'PROPERTY')
            sens = context.object.game.sensors[-1]
            sens.name = 'Close'
            sens.property = 'Open'
            sens.value = 'False'
        
            bpy.ops.logic.controller_add()
            contr = context.object.game.controllers[-1]
        
            contr.link(sensor=sens)
            
            if bpy.app.version < (2, 60, 0):
                bpy.ops.logic.actuator_add(type = 'FCURVE')
            else:
                bpy.ops.logic.actuator_add(type = 'ACTION')
            act = context.object.game.actuators[-1]
            act.name = 'Close'
            if action:
                act.action = action
        
            contr.link(actuator=act)
        
        context.object.game.actuators['Open'].frame_end = self.end_frame
        context.object.game.actuators['Close'].frame_start = self.end_frame
        
        return {'FINISHED'}
 
    def invoke(self, context, event):
        obj = context.object
        # check not to overwrite anything already set
        if 'Drawer' in obj.game.properties:
            self.drawer = obj.game.properties['Drawer'].value
        else:
            self.drawer = context.object.name
        if 'Description' in obj.game.properties:
            self.description = obj.game.properties['Description'].value
        else:
            self.description = context.object.name
        if 'Open' in obj.game.properties:
            self.open = obj.game.properties['Open'].value
        else:
            self.open = False
        if 'Open' in obj.game.actuators:
            self.end_frame = obj.game.actuators['Open'].frame_end
        else:
            self.end_frame = 40
        return context.window_manager.invoke_props_dialog(self)


class MorseDoorDialog(bpy.types.Operator):
    '''
    Operator class that assigns a "Door", a "Description" and a "Open" Property
    In Future the may be animated as well, a logic setup is already in this
    script, but commented.
    '''
    bl_idname = "object.morse_door_dialog"
    bl_label = "Morse Door"
 
    door = StringProperty(name = "Door")
    description = StringProperty(name="Description")
    # uncomment next line if using the IPO Setup
    # end_frame = IntProperty(name = "End Frame")
    open = BoolProperty(name = "Open")
    
    def assignProp(self, context, name, value):
        prop = context.object.game.properties[name]
        prop.value = value
    
    def execute(self, context):
        obj = bpy.context.active_object
        
        # add game properties if needed
        if not 'Door' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Door'
            prop.type = 'STRING'
        
        if not 'Open' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Open'
            prop.type = 'BOOL'
        
        if not 'Description' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Description'
            prop.type = 'STRING'
        
        self.assignProp(context, 'Door', self.door)
        self.assignProp(context, 'Open', self.open)
        self.assignProp(context, 'Description', self.description)
        
        # make the door an actor
        obj.game.use_actor = True

        # uncomment this part as well for the IPO Setup
        '''
        # set the logic to open and close the door if needed
        if 'Open' not in context.object.game.sensors:
            bpy.ops.logic.sensor_add(type = 'PROPERTY')
            sens = context.object.game.sensors[-1]
            sens.name = 'Open'
            sens.property = 'Open'
            sens.value = 'True'
        
            bpy.ops.logic.controller_add()
            contr = context.object.game.controllers[-1]
        
            contr.link(sensor=sens)
        
            if bpy.app.version < (2, 60, 0):
                bpy.ops.logic.actuator_add(type = 'FCURVE')
            else:
                bpy.ops.logic.actuator_add(type = 'ACTION')
            act = context.object.game.actuators[-1]
            act.name = 'Open'
        
            contr.link(actuator=act)
        
        
        if 'Close' not in context.object.game.sensors:
            bpy.ops.logic.sensor_add(type = 'PROPERTY')
            sens = context.object.game.sensors[-1]
            sens.name = 'Close'
            sens.property = 'Open'
            sens.value = 'False'
        
            bpy.ops.logic.controller_add()
            contr = context.object.game.controllers[-1]
        
            contr.link(sensor=sens)
        
            if bpy.app.version < (2, 60, 0):
                bpy.ops.logic.actuator_add(type = 'FCURVE')
            else:
                bpy.ops.logic.actuator_add(type = 'ACTION')
            act = context.object.game.actuators[-1]
            act.name = 'Close'
        
            contr.link(actuator=act)
        
        context.object.game.actuators['Open'].frame_end = self.end_frame
        context.object.game.actuators['Close'].frame_start = self.end_frame
        '''
        return {'FINISHED'}
 
    def invoke(self, context, event):
        obj = context.object
        # check not to overwrite anything already set
        if 'Door' in obj.game.properties:
            self.door = obj.game.properties['Door'].value
        else:
            self.door = 'right'
        if 'Description' in obj.game.properties:
            self.description = obj.game.properties['Description'].value
        else:
            self.description = context.object.name
        if 'Open' in obj.game.properties:
            self.open = obj.game.properties['Open'].value
        else:
            self.open = False
        # uncomment this as well for the IPO Setup
        '''
        if 'Open' in obj.game.actuators:
            self.end_frame = obj.game.actuators['Open'].frame_end
        else:
            self.end_frame = 40
        '''
        return context.window_manager.invoke_props_dialog(self)

class MorseLightDialog(bpy.types.Operator):
    '''
    Set up a light that can be switched on and off
    '''
    bl_idname = "object.morse_light_dialog"
    bl_label = "Morse Light"

    On = BoolProperty(name = "On")
    energy = FloatProperty(name = "Energy")

    def assignProp(self, context, name, value):
        prop = context.object.game.properties[name]
        prop.value = value

    def execute(self, context):
        obj = bpy.context.active_object
        
        # add game properties if needed
        if not 'On' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'On'
            prop.type = 'BOOL'

        self.assignProp(context, 'On', self.On)
        
        if not 'Energy' in obj.game.properties:
            bpy.ops.object.game_property_new()
            prop = context.object.game.properties[-1]
            prop.name = 'Energy'
            prop.type = 'FLOAT'

        self.assignProp(context, 'Energy', self.energy)

        # add logic setup
        if not 'PropertyChange' in context.object.game.sensors:
            bpy.ops.logic.sensor_add(type = 'PROPERTY')
            sens = context.object.game.sensors[-1]
            sens.name = 'PropertyChange'
            sens.property = 'On'
            sens.evaluation_type = 'PROPCHANGED'

            bpy.ops.logic.controller_add(type = 'PYTHON')
            contr = context.object.game.controllers[-1]
            contr.mode = 'MODULE'
            contr.module = "lights.change_light_energy"

            contr.link(sensor = sens)

        return {'FINISHED'}
    
    def invoke(self, context, event):
        obj = context.object

        if obj.type != 'LAMP':
            print("Sorry, no lamp selected")
            self.report({'INFO'}, "Sorry, no lamp selected")
            return {'CANCELLED'}
        
        if 'On' in obj.game.properties:
            self.On = obj.game.properties['On'].value
        self.energy = obj.data.energy

        return context.window_manager.invoke_props_dialog(self)
        



# Panel in tools region
class MorsePanel(bpy.types.Panel):
    '''
    Adds a Panel in the Logic Editor UI
    '''
    bl_label = "Morse Utils"
    bl_space_type = "LOGIC_EDITOR"
    bl_region_type = "UI"
 
    def draw(self, context):
        layout = self.layout
        layout.operator("object.morse_object_dialog")
        layout.operator("object.morse_drawer_dialog")
        layout.operator("object.morse_door_dialog")
        layout.operator("object.morse_switch_dialog")

        col = layout.column()
        col.label(text = "Presets for electric devices")
        layout.operator("object.morse_light_dialog", icon = 'LAMP_SPOT')
 

def register():
    bpy.utils.register_class(MorseObjectDialog)
    bpy.utils.register_class(MorseDoorDialog)
    bpy.utils.register_class(MorseDrawerDialog)
    bpy.utils.register_class(MorseSwitchDialog)
    bpy.utils.register_class(MorseLightDialog)
    bpy.utils.register_class(MorsePanel)
    try:
        bpy.app.handlers.scene_update_post.append(update)
    except AttributeError:
        pass
def unregister():
    bpy.utils.unregister_class(MorseObjectDialog)
    bpy.utils.unregister_class(MorseDoorDialog)
    bpy.utils.unregister_class(MorseDrawerDialog)
    bpy.utils.unregister_class(MorseSwitchDialog)
    bpy.utils.unregister_class(MorseLightDialog)
    bpy.utils.unregister_class(MorsePanel)
    try:
        bpy.app.handlers.scene_update_post.remove(update)
    except AttributeError:
        pass
    

########NEW FILE########
__FILENAME__ = future
try:
    from concurrent.futures import ThreadPoolExecutor, Future
except ImportError:
    import sys
    sys.stderr.write("[error] install python-concurrent.futures\n")
    sys.exit(1)

class MorseFuture():
    def __init__(self, future, morse, rqst_id):
        self.done = future.done
        self.running = future.running
        self.result = future.result
        self.exception = future.exception
        self.add_done_callback = future.add_done_callback

        self.rqst_id = rqst_id
        self._morse = morse

    def cancel(self):
        self._morse.cancel(self.rqst_id)

    def __lt__(self, other):
        """ Overrides the comparision operator (used by ==, !=, <, >) to
        first wait for the result of the future.
        """
        return self.result().__lt__(other)

    def __le__(self, other):
        return self.result().__le__(other)

    def __eq__(self, other):
        return self.result().__eq__(other)

    def __ne__(self, other):
        return self.result().__ne__(other)

    def __gt__(self, other):
        return self.result().__gt__(other)

    def __ge__(self, other):
        return self.result().__ge__(other)

    def __repr__(self):
        """ Overrides the representation function to 
        first wait for the result of the future.
        """
        return self.result().__repr__()

class MorseExecutor(ThreadPoolExecutor):

    def __init__(self, max_workers, morse):
        ThreadPoolExecutor.__init__(self, max_workers)
        self._morse = morse

        self.futures = []


    def submit(self, fn, *args, **kwargs):

        rqst_id = args[0]["id"]
        f = ThreadPoolExecutor.submit(self, fn, *args, **kwargs)

        mf = MorseFuture(f, self._morse, rqst_id)
        self.futures.append(mf)
        return mf


    def cancel_all(self):
        for f in self.futures:
            if not f.done():
                f.cancel()

########NEW FILE########
__FILENAME__ = pymorse
#!/usr/bin/env python3
"""A Python interface to control `MORSE <http://morse.openrobots.org>`_,
*the robotics simulator*.

The ``pymorse`` library exposes MORSE services and data stream with a
friendly Python API.

It uses underneath the MORSE socket API.

Usage
=====

Creating a connection to the simulator
--------------------------------------

- Import the ``pymorse`` module
- Create a context with the ``with`` statement:

.. code-block:: python

    import pymorse

    with pymorse.Morse() as simu:
        # ...
        pass


The context manager will take care of properly closing the connection to the
simulator.  You can also directly create an instance of the
:py:class:`pymorse.Morse` class, passing the host and/or port of the
simulator (defaults to localhost:4000). In this case, you must call
:py:meth:`pymorse.Morse.close` before leaving.

- Once created, the context generates proxies for every robots in the scene,
  and every sensors and actuators for each robot.

First example
-------------

Let consider MORSE has been started with the following simulation script:

.. code-block:: python

    from morse.builder import *

    # Add a robot with a position sensor and a motion controller
    r2d2 = ATRV()

    pose = Pose()
    pose.add_interface('socket')
    r2d2.append(pose)

    motion = Waypoint()
    motion.add_interface('socket')
    r2d2.append(motion)


    # Environment
    env = Environment('land-1/trees')

The following Python program sends a destination to the robot, and prints in
background its pose:

.. code-block:: python

    import pymorse

    def print_pos(pose):
        print("I'm currently at %s" % pose)

    with pymorse.Morse() as simu:

        # subscribes to updates from the Pose sensor by passing a callback
        simu.r2d2.pose.subscribe(print_pos)

        # sends a destination
        simu.r2d2.motion.publish({'x' : 10.0, 'y': 5.0, 'z': 0.0,
                                  'tolerance' : 0.5,
                                  'speed' : 1.0})

        # Leave a couple of millisec to the simulator to start the action
        simu.sleep(0.1)

        # waits until we reach the target
        while simu.r2d2.motion.get_status() != "Arrived":
            simu.sleep(0.5)

        print("Here we are!")

.. note::

    Note that here we use ``pymorse.Morse.sleep()`` instead of standard
    ``time.sleep``, the former allowing to consider the simulation time
    while the second use 'system' time.


Data stream manipulation
------------------------

Every component (sensor or actuator) exposes a datastream interface,
either read-only (for sensors) or write-only (for actuators)

They are accessible by their names, as defined in the simulation
script (cf example above).

Streams are Python :py:class:`pymorse.Stream` objects. It offers several
methods to read data:

- :py:meth:`pymorse.Stream.get`: blocks until new data are
  available and returns them.
- :py:meth:`pymorse.Stream.last`: returns the last/the n last (if
  an integer argument is passed) records received, or none/less, if
  none/less have been received.
- :py:meth:`pymorse.Stream.subscribe` (and
  :py:meth:`pymorse.Stream.unsubscribe`): this method is called
  with a callback that is triggered everytime incoming data is received.

These methods are demonstrated in the example below:

.. code-block:: python

    import pymorse

    def printer(data):
        print("Incoming data! " + str(data))

    with pymorse.Morse("localhost", 4000) as simu:

        try:
            # Get the 'Pose' sensor datastream
            pose = simu.r2d2.pose

            # Blocks until something is available
            print(pose.get())

            # Asynchronous read: the following line do not block.
            pose.subscribe(printer)

            # Read for 10 sec
            simu.sleep(10)

        except pymorse.MorseServerError as mse:
            print('Oups! An error occured!')
            print(mse)

Writing on actuator's datastreams is achieved with the
:py:meth:`pymorse.Stream.publish` method, as illustrated in the first example
above.

The data format is always formatted as a JSON dictionary (which means that,
currently, binary data like images are not supported). The documentation page
of each component specify the exact content of the dictionary.

Services
--------

Some components export RPC services. Please refer to the components'
documentation for details.

These services can be accessed from `pymorse`, and mostly look like regular
methods:

.. code-block:: python

    import pymorse

    with pymorse.Morse() as simu:

        # Invokes the get_status service from the 'Waypoints' actuator
        print(simu.r2d2.motion.get_status())

However, these call are **asynchronous**: a call to
`simu.r2d2.motion.get_status()` does not block, and returns instead a
`future`. See the `concurrent.futures API
<http://docs.python.org/dev/library/concurrent.futures.html>`_ to learn more
about `futures`.

Non-blocking call are useful for long lasting services, like in the example
below:

.. code-block:: python

    import pymorse

    def done(evt):
        print("We have reached our destination!")

    with pymorse.Morse() as simu:

        # Start the motion. It may take several seconds before finishing
        # The line below is however non-blocking
        goto_action = simu.r2d2.motion.goto(2.5, 0, 0)

        # Register a callback to know when the action is done
        goto_action.add_done_callback(done)

        print("Am I currently moving? %s" % goto_action.running())

        while goto_action.running():
            simu.sleep(0.5)

Use the `cancel` method on the `future` returned by the RPC call to
abort the service.

To actually wait for a result, call the `result` method on the future:

.. code-block:: python

    import pymorse

    with pymorse.Morse() as simu:

        status = simu.r2d2.motion.get_status().result()

        if status == "Arrived":
            print("Here we are")

However, for certain common cases (printing or comparing the return value), the
`result()` method is automatically called. Thus, the previous code sample can
be rewritten:

.. code-block:: python

    import pymorse

    with pymorse.Morse() as simu:

        if simu.r2d2.motion.get_status() == "Arrived":
            print("Here we are")


Simulator control
-----------------

Several services are available to control the overall behaviour of the
simulator.

The whole list of such services is here: `Supervision services
<http://www.openrobots.org/morse/doc/latest/user/supervision_services.html>`_.

For instance, you can stop the simulator (MORSE will quit) with
:py:meth:`pymorse.quit`, and reset it with :py:meth:`pymorse.Morse.reset`.

These methods are demonstrated in the example below:

.. code-block:: python

    import pymorse

    with pymorse.Morse("localhost", 4000) as simu:

        try:
            print(simu.robots)
            simu.quit()

        except pymorse.MorseServerError as mse:
            print('Oups! An error occured!')
            print(mse)

Logging
=======

This library use the standard Python logging mechanism.  You can
retrieve pymorse log messages through the "pymorse" logger.

The complete example below shows how to retrieve the logger and how to
configure it to print debug messages on the console.

.. code-block:: python

    import logging
    import pymorse

    logger = logging.getLogger("pymorse")

    console = logging.StreamHandler()
    console.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)-15s %(name)s: %(levelname)s - %(message)s')
    console.setFormatter(formatter)

    logger.addHandler(console)

    with pymorse.Morse("localhost", 4000) as simu:

        try:
            print(simu.robots)

            simu.quit()

        except pymorse.MorseServerError as mse:
            print('Oups! An error occured!')
            print(mse)
"""
import json
import logging
import asyncore
import threading

from .future import MorseExecutor
from .stream import Stream, StreamJSON

logger = logging.getLogger("pymorse")
logger.setLevel(logging.WARNING)
# logger.addHandler( logging.NullHandler() )

TIMEOUT=8
BUFFER_SIZE=8192
SUCCESS='SUCCESS'
FAILURE='FAILED'
PREEMPTED='PREEMPTED'

class MorseServiceError(Exception):
    """ Morse Service Exception thrown when unknown error """

class MorseServiceFailed(Exception):
    """ Morse Service Exception thrown when failed error """

class MorseServicePreempted(Exception):
    """ Morse Service Exception thrown when preempted error """


class Component():
    def __init__(self, morse, name, fqn, stream = None, port = None, services = []):
        self._morse = morse
        self.name = name
        self.fqn = fqn # fully qualified name

        if port:
            self.stream = StreamJSON(morse.host, port)

            if stream == 'IN':
                self.publish = self.stream.publish
            elif stream == 'OUT':
                self.get = self.stream.get
                self.last = self.stream.last
                self.subscribe = self.stream.subscribe
                self.unsubscribe = self.stream.unsubscribe

        for service in services:
            logger.debug("Adding service %s to component %s" % (service, self.name))
            self._add_service(service)

    def _add_service(self, method):
        def innermethod(*args):
            logger.debug("Sending asynchronous request %s with args %s." % (method, args))
            req = self._morse._rpc_request(self.fqn, method, *args)
            future = self._morse.executor.submit(self._morse._rpc_process, req)
            #TODO: find a way to throw an execption in the main thread
            # if the RPC request fails at invokation for stupid reasons
            # like wrong # of params
            return future

        innermethod.__doc__ = "This method is a proxy for the MORSE %s service." % method
        innermethod.__name__ = str(method)
        setattr(self, innermethod.__name__, innermethod)

    def close(self):
        if self.stream:
            self.stream.close()

class Robot(dict, Component):
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

    def __init__(self, morse, name, fqn, services = []):
        Component.__init__(self, morse, name, fqn, None, None, services)

def normalize_name(name):
    """Normalize Blender names to get valid Python identifiers"""
    normalized = name
    for illegal in ".-~":
        normalized = normalized.replace(illegal, "_")
    return normalized

def parse_response(raw):
    result = None
    try:
        msg_id, status, result = raw.split(' ', 2)
        try:
            result = json.loads(result)
        except TypeError:
            logger.error("Could not deserialize MORSE answer! Got: <%s>" % result)
    except ValueError:
        # No return value
        if ' ' in raw:
            msg_id, status = raw.split(' ')
        else:
            logger.error("Could not receive a valid response from MORSE: <%s>" % raw)
            msg_id = '???'
            status = FAILURE

    logger.debug("Got answer: %s, %s"%(status, result))
    return {
        "id": msg_id,
        "status": status,
        "result": result,
    }

def rpc_get_result(response):
    result = response['result']
    status = response['status']

    if status == SUCCESS:
        return result
    elif status == FAILURE:
        if result and "wrong # of parameters" in result:
            raise TypeError(result)
        raise MorseServiceFailed(result)
    elif status == PREEMPTED:
        raise MorseServicePreempted(result)
    else:
        raise MorseServiceError(result)

class ResponseCallback:
    _conditions = []
    def __init__(self, req_id):
        self.request_id = req_id
        self.response = None
        self.condition = threading.Condition()
        ResponseCallback._conditions.append(self.condition)

    def callback(self, res_bytes):
        response = parse_response(res_bytes)
        if response['id'] == self.request_id:
            self.response = response
            with self.condition:
                ResponseCallback._conditions.remove(self.condition)
                self.condition.notify_all()

    def cancel_all():
        for condition in ResponseCallback._conditions:
            with condition:
                condition.notify_all()
        del ResponseCallback._conditions[:] # clear list


class Morse(object):
    _asyncore_thread = None
    def __init__(self, host = "localhost", port = 4000):
        """ Creates an instance of the MORSE simulator proxy.

        This is the main object you need to instanciate to communicate with the simulator.

        :param host: the simulator host (default: localhost)
        :param port: the port of the simulator socket interface (default: 4000)
        """
        self.host = host
        self.simulator_service = Stream(host, port)
        self.simulator_service_id = 0
        if not Morse._asyncore_thread:
            Morse._asyncore_thread = threading.Thread( target = asyncore.loop, kwargs = {'timeout': 0.01} )
            Morse._asyncore_thread.start()
            logger.debug("Morse thread started")
        else:
            logger.debug("Morse thread was already started")
        self.executor = MorseExecutor(max_workers = 10, morse = self)
        self.initialize_api()

    def is_up(self):
        return self.simulator_service.is_up()

    def initialize_api(self):
        """ This method asks MORSE for the scene structure, and
        dynamically creates corresponding objects in 'self'.
        """
        details = self.rpc_t(15, 'simulation', 'details') # RPC with timeout
        if not details:
            raise ValueError("simulation details not available")
        logger.debug(details)
        self.robots = []
        for robot_detail in details["robots"]:
            name = normalize_name(robot_detail["name"])
            self.robots.append(name)
            robot = Robot(self, robot_detail['name'], robot_detail['name'],
                          services = robot_detail.get('services', []))
            setattr(self, name, robot)

            components = robot_detail["components"]
            # important to sort the list of components to ensure parents are
            # created before children
            for component in sorted(components.keys()):
                self._add_component(robot, component, components[component])

    def _add_component(self, robot, fqn, details):
        stream = details.get('stream', None)
        port = None
        if stream:
            try:
                port = self.get_stream_port(fqn)
            except MorseServiceFailed:
                logger.warn('Component <%s> has a non-socket stream: datastream via pymorse not supported', fqn)
                stream = None

        services = details.get('services', [])

        name = fqn.split('.')[1:] # the first token is always the robot name. Remove it

        if not name:
            logger.error("Component <%s> of robot <%s> has an invalid name! " \
                         "Please report this bug on morse-users@laas.fr" % (fqn, robot.name))
            return

        logger.debug("Component %s" % str((name[-1], fqn, stream, port, services)) )
        cmpt = Component(self, name[-1], fqn, stream, port, services)

        if len(name) == 1: # this component belongs to the robot directly.
            robot[name[0]] = cmpt
        else:
            subcmpt = robot[name[0]]
            for sub in name[1:-1]:
                subcmpt = getattr(subcmpt, sub)

            if hasattr(subcmpt, name[-1]): # pathologic cmpt name!
                raise RuntimeError("Sub-component name <%s> conflicts with"
                        "<%s.%s> member. To use pymorse with this scenario,"
                        "please change the name of the sub-component." %
                        (name[-1], subcmpt.name, name[-1]))
            setattr(subcmpt, name[-1], cmpt)

    def rpc_t(self, timeout, component, service, *args):
        req = self._rpc_request(component, service, *args)
        return self._rpc_process(req, timeout)

    def rpc(self, component, service, *args):
        """ Calls a service from the simulator.

        The call will block until a response from the simulator is received.

        :param component: the component that expose the service (like a robot name)
        :param service: the name of the service
        :param args...: (variadic) each service parameter, as a separate argument
        """
        req = self._rpc_request(component, service, *args)
        return self._rpc_process(req)

    def _rpc_request(self, component, service, *args):
        req = {
            'id': '%i'%self.simulator_service_id,
            'component': component,
            'service': service,
            'args': json.dumps(args),
        }
        self.simulator_service_id += 1
        return req

    def _rpc_process(self, req, timeout=None):
        raw = "{id} {component} {service} {args}".format(**req)
        logger.debug(raw)
        response_callback = ResponseCallback(req['id'])
        self.simulator_service.subscribe(response_callback.callback)
        try:
            with response_callback.condition:
                self.simulator_service.publish(raw)
                # if self.is_up() and response_callback.condition.wait(timeout):
                # XXX Python 3.2.2 is_up() returns False when connecting...
                if response_callback.condition.wait(timeout):
                    return rpc_get_result(response_callback.response)
        finally:
            self.simulator_service.unsubscribe(response_callback.callback)

        if not self.is_up():
            raise RuntimeError("simulation service is down")

        raise RuntimeError("timeout exceeded while waiting for response")

    def cancel(self, service_id):
        """ Send a cancelation request for an existing (running) service.

        If the service is not running or does not exist, the request is
        ignored.
        """
        self.simulator_service.publish("%i cancel"%int(service_id))

    def close(self, cancel_async_services = False):
        if cancel_async_services:
            logger.info('Cancelling all running asynchronous requests...')
            ResponseCallback.cancel_all()
            self.executor.cancel_all()
        else:
            logger.info('Waiting for all asynchronous requests to complete...')
        self.executor.shutdown(wait = True)
        self.simulator_service.close()
        # Close all other asyncore sockets (StreanJSON)
        asyncore.close_all()
        Morse._asyncore_thread.join(TIMEOUT)
        Morse._asyncore_thread = None # in case we want to re-create
        logger.info('Done. Bye bye!')

    def spin(self):
        Morse._asyncore_thread.join()


    #####################################################################
    ###### Predefined methods to interact with the simulator

    def quit(self):
        self.rpc("simulation", "quit")
        self.close()

    def reset(self):
       return self.rpc("simulation", "reset_objects")

    def streams(self):
       return self.rpc("simulation", "list_streams")

    def get_stream_port(self, stream):
       return self.rpc("simulation", "get_stream_port", stream)

    def activate(self, cmpnt):
        return self.rpc("simulation", "activate", cmpnt)

    def deactivate(self, cmpnt):
        return self.rpc("simulation", "deactivate", cmpnt)

    def sleep(self, time):
        """ Wait for time second.

        Time may be a float. Contrary to ``time.sleep``, this method
        consider the simulated time.
        """
        return self.rpc("time", "sleep", time)

    def time(self):
        """ Return the simulated time, in seconds, since Epoch

        The precision of the value depends on the underlying python
        precision of time, and the frequency of simulator
        """
        return self.rpc("time", "now")

    #### with statement ####
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if not exc_type:
            self.close()
        else:
            self.close(True)
            return False # re-raise exception

########NEW FILE########
__FILENAME__ = stream
"""
import asyncore
import threading
from stream import Stream
s = Stream('python.org', 80)
threading.Thread( target = asyncore.loop, kwargs = {'timeout': .1} ).start()
s.is_up()
s.publish("GET /\r\n")
s.get(.5) or s.last()
"""
import json
import socket
import logging
import asynchat
import threading
# Double-ended queue, thread-safe append/pop.
from collections import deque

logger = logging.getLogger("pymorse")
logger.setLevel(logging.WARNING)
# logger.addHandler( logging.NullHandler() )

MSG_SEPARATOR=b"\n"

class StreamB(asynchat.async_chat):
    """ Asynchrone I/O stream handler (raw bytes)

    To start the handler, just run :meth asyncore.loop: in a new thread::

    threading.Thread( target = asyncore.loop, kwargs = {'timeout': .1} ).start()

    where timeout is used with select.select / select.poll.poll.
    """

    use_encoding = 0 # Python2 compat.

    def __init__(self, host='localhost', port='1234', maxlen=100, sock=None):
        self.error = False
        if not sock:
            sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
            sock.connect( (host, port) )
        self._in_buffer  = b""
        self._in_queue   = deque([], maxlen)
        self._callbacks  = []
        self._cv_new_msg = threading.Condition()
        # init asynchat after connect and setting all locals avoids EBADF
        # and others undesirable effects of the asyncore.loop thread.
        asynchat.async_chat.__init__(self, sock=sock)
        self.set_terminator(MSG_SEPARATOR)

    def is_up(self):
        """
        self.connecting has been introduced lately in several branches
        of python (see issue #10340 of Python). In particular, it is not
        present in the python 3.2.3 interpreter delivered in Ubuntu 12.04.
        On this platform, just test of self.connected. There is still
        possibly a little race  but it mitigate the issue.
        """
        if hasattr(self, 'connecting'):
            return self.connecting or self.connected
        else:
            return self.connected

    def subscribe(self, callback):
        self._callbacks.append(callback)

    def unsubscribe(self, callback):
        self._callbacks.remove(callback)

    def handle_error(self):
        self.error = True
        self.handle_close()

    #### IN ####
    def collect_incoming_data(self, data):
        """Buffer the data"""
        self._in_buffer += data

    def found_terminator(self):
        self.handle_msg(self._in_buffer)
        self._in_buffer = b""

    def handle_msg(self, msg):
        """ append new raw :param msg: in the input queue

        and call subscribed callback methods if any
        """
        with self._cv_new_msg:
            self._in_queue.append(msg)
            self._cv_new_msg.notify_all()
        # handle callback(s)
        decoded_msg = None
        for callback in self._callbacks:
            if not decoded_msg:
                decoded_msg = self.decode( msg )
            callback( decoded_msg )

    def _msg_available(self):
        return bool(self._in_queue)

    def _get_last_msg(self):
        return self.decode( self._in_queue[-1] )

    # TODO implement last n msg decode and msg_queue with hash(msg) -> decoded msg
    def last(self, n=1):
        """ get the last message recieved

        :returns: decoded message or None if no message available
        """
        with self._cv_new_msg:
            if self._msg_available():
                return self._get_last_msg()
        logger.debug("last: no message in queue")
        return None

    def get(self, timeout=None):
        """ wait :param timeout: for a new messge

        When the timeout argument is present and not None, it should be a
        floating point number specifying a timeout for the operation in seconds
        (or fractions thereof).

        :returns: decoded message or None in case of timeout
        """
        with self._cv_new_msg:
            if self._cv_new_msg.wait(timeout):
                return self._get_last_msg()
        logger.debug("get: timed out")
        return None

    #### OUT ####
    def publish(self, msg):
        """ encode :param msg: and append the resulting bytes to the output queue """
        self.push(self.encode( msg ))

    #### patch code from asynchat, ``del deque[0]`` is not safe #####
    def initiate_send(self):
        while self.producer_fifo and self.connected:
            first = self.producer_fifo.popleft()
            # handle empty string/buffer or None entry
            if not first:
                if first is None:
                    self.handle_close()
                    return

            # handle classic producer behavior
            obs = self.ac_out_buffer_size
            try:
                data = first[:obs]
            except TypeError:
                data = first.more()
                if data:
                    self.producer_fifo.extendleft([first, data])
                continue

            if isinstance(data, str) and self.use_encoding:
                data = bytes(data, self.encoding)

            # send the data
            try:
                num_sent = self.send(data)
            except socket.error:
                self.handle_error()
                return

            if num_sent:
                if num_sent < len(data) or obs < len(first):
                    self.producer_fifo.appendleft(first[num_sent:])
            # we tried to send some actual data
            return

    #### CODEC ####
    def decode(self, msg_bytes):
        """ returns message as is (raw bytes) """
        return msg_bytes

    def encode(self, msg_bytes):
        """ returns message as is (raw bytes) plus the MSG_SEPARATOR """
        return msg_bytes + MSG_SEPARATOR


class Stream(StreamB):
    """ String Stream """
    def __init__(self, host='localhost', port='1234', maxlen=100, sock=None):
        StreamB.__init__(self, host, port, maxlen, sock)

    #### CODEC ####
    def decode(self, msg_bytes):
        """ decode bytes to string """
        return msg_bytes.decode()

    def encode(self, msg_str):
        """ encode string to bytes """
        return StreamB.encode(self, msg_str.encode())


class StreamJSON(Stream):
    """ JSON Stream """
    def __init__(self, host='localhost', port='1234', maxlen=100, sock=None):
        Stream.__init__(self, host, port, maxlen, sock)

    def decode(self, msg_bytes):
        """ decode bytes to json object """
        return json.loads(Stream.decode(self, msg_bytes))

    def encode(self, msg_obj):
        """ encode object to json string and then bytes """
        return Stream.encode(self, json.dumps(msg_obj))

########NEW FILE########
__FILENAME__ = pymorse_internals_testing
import unittest
import threading
import time
import socket
import select
import json
import asyncore

import logging; logger = logging.getLogger("pymorse")
from pymorse import StreamJSON, TIMEOUT

class SocketWriter(threading.Thread):
    def __init__(self, port = 61000, freq = 10):
        threading.Thread.__init__(self)
        
        self.freq = freq
        self._client_sockets = []
        
        self._running = True
        
        self._server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._server.bind((str(socket.INADDR_ANY), port))
        self._server.listen(1)
        
        self.start()
        
        self.i = 0
    
    def run(self):
        
        print("Starting the server at %dHz." % self.freq)
        
        while self._running:
            sockets = self._client_sockets + [self._server]
            try:
                inputready, outputready, exceptready = select.select(sockets, sockets, [], 0)
            except select.error:
               pass
            except socket.error:
               pass

            if self._server in inputready:
                print("Got a connection to the socket writer")
                sock, addr = self._server.accept()
                self._client_sockets.append(sock)

            if outputready != []:
                message = (self.get_data() + '\n').encode()
                for o in outputready:
                    try:
                        #print("Writing " + message + " to the socket")
                        o.send(message)
                    except socket.error:
                        self.close_socket(o)
        
        if self._client_sockets:
            print("Closing client sockets...")
            for s in self._client_sockets:
                s.close()

        if self._server:
            print("Shutting down connections to server...")
            self._server.shutdown(socket.SHUT_RDWR)
            print("Closing socket server...")
            self._server.close()
    
    def close_socket(self, sock):
        self._client_sockets.remove(sock)
        try:
            sock.close()
        except socket.error as error_info:
            logger.warning("Socket error catched while closing: " + str(error_info))

    def close(self):
        print("Closing the socket server")
        self._running = False
        self.join()
        print("Done")
        
    def get_data(self):
        
        data = json.dumps([self.i])
        self.i += 1
        time.sleep(1/float(self.freq))
        return data
    
    def reset(self):
        self.i = 0

class TestPyMorseStreamSlow(unittest.TestCase):

    def setUp(self):
        print("Starting test...")
        self.freq = 10
        self._server = SocketWriter(freq = self.freq) # First tests: producer at 10 Hz

        self.host = "localhost"
        self.stream = StreamJSON(self.host, 61000)
        self._asyncore_thread = threading.Thread( target = asyncore.loop, kwargs = {'timeout': 0.01} )
        self._asyncore_thread.start()
        
    def test_get(self):

        self.assertEqual(self.stream.get(), [0])
        self.assertEqual(self.stream.get(), [1])
        
    def test_last_timed(self):

        d = 1/float(self.freq)
        self.assertIsNone(self.stream.last())
        time.sleep(d + d * 0.5)
        self.assertEqual(self.stream.last(), [0])
        time.sleep(d)
        self.assertEqual(self.stream.last(), [1])
        time.sleep(d)
        time.sleep(d)
        self.assertEqual(self.stream.last(), [3])

    def test_subscribe(self):

        d = 1/float(self.freq)
        self.ok = False
        self.i = 0

        self.stream.subscribe(self.on_data)

        time.sleep(d + d * 0.5)
        self.assertTrue(self.ok)

        self.ok = False
        time.sleep(d)
        self.assertTrue(self.ok)

    def test_unsubscribe(self):

        d = 1/float(self.freq)
        self.ok = False
        self.i = 0

        self.stream.subscribe(self.on_data)
        time.sleep(d + d * 0.5)
        self.assertTrue(self.ok)

        self.ok = False

        self.stream.unsubscribe(self.on_data)
        time.sleep(d)
        self.assertFalse(self.ok)

    def on_data(self, record):
        
        self.ok = True
        self.assertEqual(record, [self.i])
        self.i += 1
        
    def tearDown(self):
        self._server.close()
        asyncore.close_all()
        self._asyncore_thread.join(TIMEOUT)
        self._asyncore_thread = None # in case we want to re-create

if __name__ == '__main__':
    
    import logging
    
    console = logging.StreamHandler()
    console.setLevel(4)

    # set a format which is simpler for console use
    formatter = logging.Formatter('%(asctime)-15s %(name)s: %(levelname)s - %(message)s')
    # tell the handler to use this format
    console.setFormatter(formatter)
    # add the handler to the root logger
    logger.setLevel(logging.DEBUG)
    logger.addHandler(console)

    unittest.main()

########NEW FILE########
__FILENAME__ = pymorse_testing
"""
We test here the various features of the pymorse bindings:
- automatic creation of robot/components existing in the simulation
- datastream read/write,
- service invokation
"""

from morse.testing.testing import MorseTestCase
import logging;logger = logging.getLogger("morsetesting.general")

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
import time
from pymorse import Morse, MorseServicePreempted
from concurrent.futures._base import TimeoutError
class PymorseTest(MorseTestCase):

    def setUpEnv(self):
        
        ##### Robot1
        # Names come from the variable name

        robot1 = ATRV()
        robot1.translate(0.0,1.0,0.0)

        battery = Battery()
        battery.add_stream('socket')
        robot1.append(battery)

        motion = Waypoint()
        motion.add_stream('socket')
        motion.configure_service('socket')
        robot1.append(motion)

        ##### Robot2
        # Here, we set explicitely the names via the 'name' property
        robot2 = ATRV("Robi")

        pose = Pose("MyPose")
        pose.add_stream('socket')
        robot2.append(pose)

        # Environment
        env = Environment('empty', fastmode = True)
        env.configure_service('socket')

    def _test_base(self):
        with Morse() as simu:
            self.assertIn("robots", dir(simu))
            self.assertEquals(set(simu.robots), {'robot1', 'Robi'})

            self.assertIn('Robi', dir(simu))
            self.assertIn('robot1', dir(simu))

            self.assertIn('MyPose', simu.Robi)

            self.assertIn('battery', simu.robot1)
            self.assertIn('motion', simu.robot1)

            with self.assertRaises(KeyError):
                simu.Robi.ghost_compt

            with self.assertRaises(KeyError):
                simu.Robi.ghost_compt.get()

            self.assertIsNotNone(simu.Robi.MyPose)
            self.assertIsNotNone(simu.robot1.battery)
            self.assertIsNotNone(simu.robot1.motion)

    def _test_streams(self):

        with Morse() as morse:

            s = morse.robot1.battery

            # Try to read it
            self.assertIsNotNone(s.get())

            s.last()
            s.get()

            motion = morse.robot1.motion

            # Try to write on a stream
            motion.publish({'x' : 10.0, 'y': 5.0, 'z': 0.0, 
                            'tolerance' : 0.5, 
                            'speed' : 1.0})

            time.sleep(1.0)

    def test_services(self):

        with Morse() as morse:

            motion = morse.robot1.motion

            # Should not raise any exception
            req = motion.goto(1.0, 1.0, 0.0, 0.5, 1.0)

            self.assertFalse(req.done())

            res = req.result(2)

            self.assertTrue(req.done())

            self.assertIsNotNone(res) # finished successfully

            # Inexistant service
            with self.assertRaises(AttributeError):
                motion.toto()

            # One missing argument
            fut = motion.goto(5.0, 1.0)
            self.assertEqual(type(fut.exception(1)), TypeError)

            # Too many arguments
            fut = motion.goto(10.0, 5.0, 0.0, 0.5, 1.0, 0.0)
            self.assertEqual(type(fut.exception(1)), TypeError)

            # Wrong type
            # TODO in MORSE: type checking not yet done!
            #with self.assertRaises(ValueError):
            #    motion.goto(10.0, True, 0.0, 0.5, 1.0)


            ## Testing service cancellation
            logger.info("Starting new movement")
            act = motion.goto(1.0, 2.0, 0.0, 0.1, 0.1)
            self.assertTrue(act.running())
            self.assertFalse(act.done())
            logger.info("Ok")

            logger.info("Cancelling it...")
            act.cancel()
            self.assertEqual(type(act.exception(2)), MorseServicePreempted) # action cancelled
            self.assertFalse(act.running())
            self.assertTrue(act.done())
            logger.info("Ok")


            logger.info("Testing double cancellation")
            act.cancel() # should not trigger anything
            logger.info("Ok")

            ## Testing preemption
            logger.info("Starting new movement")
            act1 = motion.goto(2.0, 1.0, 0.0, 0.1, 0.1)
            self.assertTrue(act1.running())
            self.assertFalse(act1.done())
            logger.info("Ok")

            logger.info("Preempting movement with another one")
            act2 = motion.goto(0.0, 1.0, 0.0, 0.1, 0.1)
            self.assertEqual(type(act1.exception(2)), MorseServicePreempted) # action preempted
            self.assertFalse(act1.running())
            self.assertTrue(act1.done())
            self.assertTrue(act2.running())
            logger.info("Ok")

            act2.cancel()

########################## Run these tests ##########################
if __name__ == "__main__":
    import unittest
    from morse.testing.testing import MorseTestRunner
    suite = unittest.TestLoader().loadTestsFromTestCase(PymorseTest)
    sys.exit(not MorseTestRunner().run(suite).wasSuccessful())


########NEW FILE########
__FILENAME__ = examples
from sphinx.directives import CodeBlock

def nop():
    pass

class Example(CodeBlock):
    required_arguments = 0
    def __init__(self, *args, **kwargs):
        CodeBlock.__init__(self, *args, **kwargs)
        self.arguments = ["python"]


def setup(app):
    """Install the plugin.
    
    :param app: Sphinx application context.
    """
    app.add_role('noautoexample', nop )
    app.add_directive('example', Example)
    return

########NEW FILE########
__FILENAME__ = gallery
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import glob
from docutils import nodes
from docutils.parsers.rst import directives
from sphinx.util.compat import Directive

IMAGE_PATH="_images/"
HTML_PATH="user/"
RST_PATH="morse/" + HTML_PATH

def css(d):
    return "; ".join(sorted("%s: %s" % kv for kv in d.items()))

class gallery(nodes.General, nodes.Element): pass
class widegallery(nodes.General, nodes.Element): pass

def visit_widegallery_node(self, node):
    visit_gallery_node(self, node, wide = True)

def visit_gallery_node(self, node, wide = False):

    MEDIA_PATH=os.path.join(node.document.settings.env.config.html_theme_path[0], "media")

    if wide:
        images_per_row = 2
        width = "400px"
    else:
        images_per_row = 4
        width = "200px"

    style = {
        "position": "relative",
    }
    self.body.append(self.starttag(node, "table", style=css(style)))
    img_path = os.path.join(MEDIA_PATH, node["directory"])
    images =  os.listdir(img_path)
    images = [img for img in images if os.path.isfile(os.path.join(img_path, img))]
    for i in range(len(images))[::images_per_row]:
        self.body.append("<tr>\n")
        for j in range(images_per_row):
            if i + j < len(images):
                obj = images[i + j][:-4] #remove extension
                self.body.append("\t<td style='text-align:center'><a href='" + HTML_PATH + node["directory"] + "/" + obj + ".html'><img style='width: " + width + ";' src='" + IMAGE_PATH + images[i+j] + "' /><br/><pre>" + obj + "</pre></a></td>\n")
        self.body.append("</tr>\n")
    self.body.append("</table>\n")

def depart_gallery_node(self, node):
    pass

class Gallery(Directive):
    has_content = True
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = False

    def run(self):
        return [gallery(directory=self.arguments[0])]

class WideGallery(Directive):
    has_content = True
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = False

    def run(self):
        return [widegallery(directory=self.arguments[0])]

def setup(app):
    app.add_node(widegallery, html=(visit_widegallery_node, depart_gallery_node))
    app.add_directive("widegallery", WideGallery)
    
    app.add_node(gallery, html=(visit_gallery_node, depart_gallery_node))
    app.add_directive("gallery", Gallery)

########NEW FILE########
__FILENAME__ = tag
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from docutils import nodes


def tag_role(role, rawtext, text, lineno, inliner,
                       options={}, content=[]):

    categories = {'pymorse': ('middleware', 'pymorse'),
                  'ros': ('middleware', 'user/middlewares/ros'),
                  'pocolibs': ('middleware', 'user/middlewares/pocolibs'),
                  'yarp_json': ('middleware', 'user/middlewares/yarp'),
                  'text': ('middleware', 'user/middlewares/text'),
                  'socket': ('middleware', 'user/middlewares/socket'),
                  'yarp': ('middleware', 'user/middlewares/yarp'),
                  'moos': ('middleware', 'user/middlewares/moos'),
                  'builder': ('api', 'user/builder'),
                  'datastream': ('access', None),
                  'service': ('access', 'dev/services')}
    if text not in categories:
        msg = inliner.reporter.error(
            'Unknown category for tag "%s". Check exts/tag.py '
            'for available categories' % text, line=lineno)
        prb = inliner.problematic(rawtext, rawtext, msg)
        return [prb], [msg]
    
    # deseperately tried to generate a relative path to the doc root
    # but it's a failure.
    # inliner.document.settings.env may be a good starting point
    
    #url = categories[text][1]
    #node = None
    #if url:
    #    import pdb;pdb.set_trace()
    #    node = nodes.reference(rawtext, text, refuri = url + ".html")
    #else:
    #    node = nodes.literal(rawtext, text)

    node = nodes.literal(rawtext, text)
    node['classes'].append("tag")
    node['classes'].append("tag-" + categories[text][0])

    return [node], []


def setup(app):
    """Install the plugin.
    
    :param app: Sphinx application context.
    """
    app.add_role('tag', tag_role)
    return

########NEW FILE########
__FILENAME__ = vimeo
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import division

import re
from docutils import nodes
from docutils.parsers.rst import directives
from sphinx.util.compat import Directive

CONTROL_HEIGHT = 30

def get_size(d, key):
    if key not in d:
        return None
    m = re.match("(\d+)(|%|px)$", d[key])
    if not m:
        raise ValueError("invalid size %r" % d[key])
    return int(m.group(1)), m.group(2) or "px"

def css(d):
    return "; ".join(sorted("%s: %s" % kv for kv in d.items()))

class vimeo(nodes.General, nodes.Element): pass

def visit_vimeo_node(self, node):
    aspect = node["aspect"]
    width = node["width"]
    height = node["height"]

    if aspect is None:
        aspect = 16, 9

    if (height is None) and (width is not None) and (width[1] == "%"):
        style = {
            "padding-top": "%dpx" % CONTROL_HEIGHT,
            "padding-bottom": "%f%%" % (width[0] * aspect[1] / aspect[0]),
            "width": "%d%s" % width,
            "position": "relative",
        }
        self.body.append(self.starttag(node, "div", style=css(style)))
        style = {
            "position": "absolute",
            "top": "0",
            "left": "0",
            "width": "100%",
            "height": "100%",
            "border": "0",
        }
        attrs = {
            "src": "http://player.vimeo.com/video/%s?title=0&amp;byline=0&amp;portrait=0" % node["id"],
            "style": css(style),
        }
        self.body.append(self.starttag(node, "iframe", **attrs))
        self.body.append("</iframe></div>")
    else:
        if width is None:
            if height is None:
                width = 560, "px"
            else:
                width = height[0] * aspect[0] / aspect[1], "px"
        if height is None:
            height = width[0] * aspect[1] / aspect[0], "px"
        style = {
            "width": "%d%s" % width,
            "height": "%d%s" % (height[0] + CONTROL_HEIGHT, height[1]),
            "border": "0",
        }
        attrs = {
            "src": "http://player.vimeo.com/video/%s?title=0&amp;byline=0&amp;portrait=0" % node["id"],
            "style": css(style),
        }
        self.body.append(self.starttag(node, "iframe", **attrs))
        self.body.append("</iframe>")

def depart_vimeo_node(self, node):
    pass

class Vimeo(Directive):
    has_content = True
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = False
    option_spec = {
        "width": directives.unchanged,
        "height": directives.unchanged,
        "aspect": directives.unchanged,
    }

    def run(self):
        if "aspect" in self.options:
            aspect = self.options.get("aspect")
            m = re.match("(\d+):(\d+)", aspect)
            if m is None:
                raise ValueError("invalid aspect ratio %r" % aspect)
            aspect = tuple(int(x) for x in m.groups())
        else:
            aspect = None
        width = get_size(self.options, "width")
        height = get_size(self.options, "height")
        return [vimeo(id=self.arguments[0], aspect=aspect, width=width, height=height)]

def setup(app):
    app.add_node(vimeo, html=(visit_vimeo_node, depart_vimeo_node))
    app.add_directive("vimeo", Vimeo)

########NEW FILE########
__FILENAME__ = yarp_pa10_client
import sys, os
import json
import re
import yarp


# Global variables for the names of the input and output ports
local_in_port_name = ""
local_out_port_name = ""

# Global variables for the ors names of the ports
ors_in_port_name = ""
ors_out_port_name = ""

# Global variables for the yarp ports
local_in_port = 0
local_out_port = 0



def read_trajectory():
	""" Read a list of waypoints from a file.
		Format the data as a list of dictionaries,
		in the same format as the java objects from ROSACE."""
	filename = "qarm.traj"
	file = open(filename, "r")
	arm_movement = []

	for line in file:
		# Get the individual elements, splitting by whitespace
		rotation = line.split()

		arm_movement.append (rotation)

	return arm_movement


def command_robot():
	waiting = True

	# Get the contents of the trajectory config file
	arm_movement = read_trajectory()
	i = 0

	"""
	arm_movement = [	[1, 0, 0, 0, 0, 0],
						[0, 1, 0, 0, 0, 0],
						[0, 0, 1, 0, 0, 0],
						[0, 0, 0, 1, 0, 0],
						[0, 0, 0, 0, 1, 0],
						[0, 0, 0, 0, 0, 1],
						[0, 0, 0, 0, 0, 0],
					]
	"""

	print ("SEQUENCE READ: {0}".format(arm_movement))
	while waiting:
		#raw_coords = input("Input new coordinates: ")
		#print ("The coordinates read are: {0}, of type ({1})".format(raw_coords, type(raw_coords)))

		command = raw_input("Enter command: [ (s)tep / e(x)it ] ")

		if command == "move" or command == "m":
			command = {"command":"move"}
			send_command(command)

		elif command == "step" or command == "s":
			movement = arm_movement[i]
			print ("SENDING MOVEMENT: {0}".format(movement))
			i = i + 1
			send_movement(movement)

		elif command == "exit" or command == "x":
			print ("Exiting the function")
			sys.exit()

def send_movement(movement):
	""" Send the rotation array to the arm """
	bottle = local_out_port.prepare()
	bottle.clear()
	for item in movement:
		#bottle.addDouble(item)
		bottle.addDouble(eval(item))
	local_out_port.write(False)


def send_command(command):
	""" Send a message through the yarp output port."""
	bottle = local_out_port.prepare()
	bottle.clear()
	bottle.addString(command)
	local_out_port.write(False)


def port_setup(robot_name):
	""" Open the input and output ports."""
	global local_in_port
	global local_out_port

	global local_in_port_name
	global local_out_port_name

	global ors_in_port_name
	global ors_out_port_name

	# Define the names for all the ports
	port_prefix = "/ors/robots/" + robot_name + "/"
	local_port_prefix = "/pa10_client/" + robot_name + "/"

	ors_in_port_name = port_prefix + "OBPA-10/in"
	ors_out_port_name = port_prefix + "out"

	local_in_port_name = local_port_prefix + "in/"
	local_out_port_name = local_port_prefix + "out/"

	# Start the yarp network connection
	yarp.Network.init()

	# Open the client ports
	local_in_port = yarp.BufferedPortBottle()
	local_in_port.open(local_in_port_name)
	local_out_port = yarp.BufferedPortBottle()
	local_out_port.open(local_out_port_name)

	# Connect the client ports to the simulator ports
	yarp.Network.connect (local_out_port_name, ors_in_port_name)
	yarp.Network.connect (ors_out_port_name, local_in_port_name)



def usage(program_name):
	print ("Usage: {0} [robot_name]\n", program_name)


def main():
	print ("********* PA-10 arm client *********")

	robot_name = "OBJido"

	argc = len(sys.argv)

	if argc == 2:
		robot_name = sys.argv[1]
	elif argc > 2:
		usage(sys.argv[0])
		sys.exit()

	port_setup(robot_name)

	print (" * Writing commands to " + ors_in_port_name)
	print (" * Listening status on " + ors_out_port_name)

	print (" * Enter command:")

	command_robot()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = cat_script
""" Simple script for the CAT AND MOUSE game tutorial

This will command the CAT, using two semantic cameras, to follow
after the MOUSE robot """

from pymorse import Morse

def is_mouse_visible(semantic_camera_stream):
    """ Read data from the semantic camera, and determine if a specific
    object is within the field of view of the robot """
    data = semantic_camera_stream.get()
    visible_objects = data['visible_objects']
    for visible_object in visible_objects:
        if visible_object['name'] == "MOUSE":
            return True
    return False

def main():
    """ Use the semantic cameras to locate the target and follow it """
    with Morse() as morse:
        semanticL = morse.cat.semanticL
        semanticR = morse.cat.semanticR
        motion = morse.cat.motion

        while True:
            mouse_seen_left = is_mouse_visible(semanticL)
            mouse_seen_right = is_mouse_visible(semanticR)
            if mouse_seen_left and mouse_seen_right:
                v_w = {"v": 2, "w": 0}
            elif mouse_seen_left:
                v_w = {"v": 1.5, "w": 1}
            elif mouse_seen_right:
                v_w = {"v": 1.5, "w": -1}
            else:
                v_w = {"v": 0, "w": -1}
            motion.publish(v_w)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = ghost_estimation_script
import pymorse
import numpy as np
from scipy.linalg import solve_continuous_are

'''
If you are confident in the measures, increase
the confidence so that measure_confidence >> 1.
Otherwise, make it << 1. 
'''
measure_confidence = 1

Aext = np.mat('[0 1 0 0; 0 0 0 0; 0 0 0 1; 0 0 0 0]')
Cext = np.mat('[1 0 0 0; 0 0 1 0]')
n = Aext.shape[0]
ny = Cext.shape[0]
G = np.identity(n);
Q = measure_confidence * np.identity(n);
R = np.identity(ny);

P = solve_continuous_are(Aext.T, Cext.T, Q, R)

L = P * Cext.T * R;
  
dt = .1

A = np.identity(n) + dt * (Aext - L * Cext)
B = L * dt
C = Cext

xest_k = np.mat('[0; 0; 0; 0]')

with pymorse.Morse() as morse:

    while True:
        
        pose = morse.robot.pose.get()
        z = np.mat([[pose['x']], [pose['y']]])
        
        x_ = C * xest_k
        
        pose['x'] = float(x_[0][0])
        pose['y'] = float(x_[1][0])
        morse.ghost.teleport.publish(pose)

        xest_k = A * xest_k + B * z
        
        morse.sleep(dt)

########NEW FILE########
__FILENAME__ = ghost_noise_script
import pymorse

with pymorse.Morse() as morse:
    while True:
        pose = morse.robot.pose.get()
        morse.ghost.teleport.publish(pose)
        morse.sleep(.1)

########NEW FILE########
__FILENAME__ = Rosace_Client
import sys, os
import json
import re
import yarp
from collections import OrderedDict



# Global variables for the names of the input and output ports
local_in_port_name = ""
local_out_port_name = ""

local_GPS_port_name = ""
local_Status_port_name = ""
local_Dest_port_name = ""
local_Heal_port_name = ""

local_Proximity_in_port_name = ""
local_Proximity_out_port_name = ""


# Global variables for the ors names of the ports
ors_in_port_name = ""
ors_out_port_name = ""

ors_GPS_port_name = ""
ors_Status_port_name = ""
ors_Dest_port_name = ""
ors_Heal_port_name = ""

ors_Proximity_in_port_name = ""
ors_Proximity_in_port_name = ""

# Global variables for the yarp ports
local_in_port = 0
local_out_port = 0

local_GPS_port = 0
local_Status_port = 0
local_Dest_port = 0
local_Heal_port = 0




def read_waypoints():
    """ Read a list of waypoints from a file.
        Format the data as a list of dictionaries,
        in the same format as the java objects from ROSACE."""
    filename = "rosace-waypoints.txt"
    file = open(filename, "r")
    wp_list = []

    for line in file:
        # Get the individual elements, splitting by whitespace
        data_list = line.split()
        print (data_list)
        coordinate = OrderedDict( [ ('x', data_list[0]), ('y', data_list[1]), ('z', data_list[2]) ] )
        waypoint = OrderedDict( [ ('point', coordinate), ('radius', data_list[3]) ] )

        #waypoint = OrderedDict( [ ('x', data_list[0]), ('y', data_list[1]), ('z', data_list[2]), ('speed', data_list[3]) ] )

        wp_list.append (waypoint)

    return wp_list


def command_robot():
    waiting = True
    wp_list = read_waypoints ()

    while waiting:
        """
        yarp_data = local_in_port.read(False)
        if yarp_data is not None:
            # Read a string from the bottle
            json_data = yarp_data.toString()
            data = decode_message(json_data)
            print ("Current robot status:")
            for key, value in data.items():
                print ("\t{0}:\t{1}".format(key, value))
        """

        #raw_coords = raw_input("Input new coordinates: ")
        #print ("The coordinates read are: {0}, of type ({1})".format(raw_coords, type(raw_coords)))

        command = input("Enter command: [ (g)ps / (n)eighbours / s(t)atus / (w)aypoint / (h)eal / e(x)it ] ")
        #command = input("Enter command: [ (m)ove / (s)top / s(t)atus / (w)aypoint / (n)eighbours / (h)eal / e(x)it ] ")

        if command == "move" or command == "m":
            command = {"command":"move"}
            send_command(command)

        elif command == "stop" or command == "s":
            command = {"command":"stop"}
            send_command(command)

        elif command == "waypoint" or command == "w":
            wp = wp_list.pop(0)
            message = json.dumps (wp)
            print ("Next waypoint: {0}".format(message))

            # Send the json string through a yarp port
            bottle = local_Dest_port.prepare()
            bottle.clear()
            bottle.addString(message)
            local_Dest_port.write()

        elif command == "heal" or command == "h":
            command = {'heal': 1}
            message = json.dumps (command)
            # Send the json string through a yarp port
            bottle = local_Heal_port.prepare()
            bottle.clear()
            bottle.addString(message)
            local_Heal_port.write()

        elif command == "neighbours" or command == "n" or \
                command == "radius" or command == "r":

            # Separate commands for the radio sensor
            #if command == "neighbours" or command == "n":
                #command = {"request": "Neighbours"}
            #elif command == "radius" or command == "r":
                #command = {"range": "10"}
            #message = json.dumps (command)

            # Send the json string through a yarp port
            #bottle = local_Proximity_out_port.prepare()
            #bottle.clear()
            #bottle.addString(message)
            #local_Proximity_out_port.write()

            # Read the response
            yarp_data = local_Proximity_in_port.read(False)
            if yarp_data is not None:
                # Read a string from the bottle
                json_data = yarp_data.toString()
                data = decode_message(json_data)
                print ("Current robot neighbours:")
                for key, value in data.items():
                    print ("\t{0}:\t{1}".format(key, value))

        elif command == "gps" or command == "g":
            # Read the response
            yarp_data = local_GPS_port.read(False)
            if yarp_data is not None:
                # Read a string from the bottle
                json_data = yarp_data.toString()
                data = decode_message(json_data)
                print ("Current robot location:")
                for key, value in data.items():
                    print ("\t{0}:\t{1}".format(key, value))

        elif command == "status" or command == "t":
            # Read the response
            yarp_data = local_Status_port.read(False)
            if yarp_data is not None:
                # Read a string from the bottle
                json_data = yarp_data.toString()
                data = decode_message(json_data)
                print ("Current robot status:")
                for key, value in data.items():
                    print ("\t{0}:\t{1}".format(key, value))

        elif command == "exit" or command == "x":
            print ("Exiting the function")
            sys.exit()


def send_command(command):
    """ Send a message through the yarp output port."""
    message = json.dumps (command)
    bottle = local_out_port.prepare()
    bottle.clear()
    bottle.addString(message)
    local_out_port.write(False)


def decode_message(json_data):
    """ Decode a data structure using JSON.
        The data is initially a string.
        Returns a Python object,
        either an int, double, string, list or dictionary."""
    # Remove the quotations at the start and end of the string
    json_data = re.sub(r'"(.*)"', r'\1', json_data)
    # Unescape all other quotation marks
    json_data = re.sub(r'\\(.)', r'\1', json_data)
    clean_data = json.loads(json_data)

    return clean_data


def port_setup(robot_name):
    """ Open the input and output ports."""
    global local_in_port
    global local_out_port
    global local_GPS_port
    global local_Status_port
    global local_Dest_port
    global local_Heal_port

    global local_in_port_name
    global local_out_port_name
    global local_GPS_port_name
    global local_Status_port_name
    global local_Dest_port_name
    global local_Heal_port_name

    global local_Proximity_in_port
    global local_Proximity_out_port

    global ors_in_port_name
    global ors_out_port_name
    global ors_GPS_port_name
    global ors_Status_port_name
    global ors_Dest_port_name
    global ors_Heal_port_name
    global ors_Proximity_in_port_name
    global ors_Proximity_out_port_name

    # Define the names for all the ports
    port_prefix = "/ors/robots/" + robot_name + "/"
    local_port_prefix = "/atrv_client/" + robot_name + "/"

    #ors_in_port_name = port_prefix + "in"
    #ors_out_port_name = port_prefix + "out"

    ors_Dest_port_name = port_prefix + "Motion_Controller/in"
    ors_Heal_port_name = port_prefix + "Healer_Beam/in"
    ors_GPS_port_name = port_prefix + "GPS/out"
    ors_Status_port_name = port_prefix + "Status_Sensor/out"

    ors_Proximity_out_port_name = port_prefix + "Proximity_Sensor/out"
    #ors_Proximity_in_port_name = port_prefix + "Proximity_Sensor/in"

    #local_in_port_name = local_port_prefix + "in/"
    #local_out_port_name = local_port_prefix + "out/"

    local_GPS_port_name = local_port_prefix + "GPS/in/"
    local_Status_port_name = local_port_prefix + "Status_Sensor/in/"
    local_Dest_port_name = local_port_prefix + "Motion_Controller/out/"
    local_Heal_port_name = local_port_prefix + "Healer_Beam/out/"

    local_Proximity_in_port_name = local_port_prefix + "Proximity_Sensor/in"
    #local_Proximity_out_port_name = local_port_prefix + "Proximity_Sensor/out"

    # Start the yarp network connection
    yarp.Network.init()

    # Open the client ports
    #local_in_port = yarp.BufferedPortBottle()
    #local_in_port.open(local_in_port_name)
    #local_out_port = yarp.BufferedPortBottle()
    #local_out_port.open(local_out_port_name)

    local_GPS_port = yarp.BufferedPortBottle()
    local_GPS_port.open(local_GPS_port_name)

    local_Status_port = yarp.BufferedPortBottle()
    local_Status_port.open(local_Status_port_name)

    local_Dest_port = yarp.BufferedPortBottle()
    local_Dest_port.open(local_Dest_port_name)

    local_Heal_port = yarp.BufferedPortBottle()
    local_Heal_port.open(local_Heal_port_name)

    #local_Proximity_out_port = yarp.BufferedPortBottle()
    #local_Proximity_out_port.open(local_Proximity_out_port_name)
    local_Proximity_in_port = yarp.BufferedPortBottle()
    local_Proximity_in_port.open(local_Proximity_in_port_name)

    # Connect the client ports to the simulator ports
    #yarp.Network.connect (local_out_port_name, ors_in_port_name)
    #yarp.Network.connect (ors_out_port_name, local_in_port_name)

    yarp.Network.connect (ors_GPS_port_name, local_GPS_port_name)
    yarp.Network.connect (ors_Status_port_name, local_Status_port_name)
    yarp.Network.connect (local_Dest_port_name, ors_Dest_port_name)
    yarp.Network.connect (local_Heal_port_name, ors_Heal_port_name)

    #yarp.Network.connect (local_Proximity_out_port_name, ors_Proximity_in_port_name)
    yarp.Network.connect (ors_Proximity_out_port_name, local_Proximity_in_port_name)




def usage(program_name):
    print ("Usage: {0} [robot_name]\n", program_name)


def main():
    print ("********* ATRV client *********")

    robot_name = "ATRV"

    argc = len(sys.argv)

    if argc == 2:
        robot_name = sys.argv[1]
    elif argc > 3:
        usage(sys.argv[0])
        sys.exit()


    port_setup(robot_name)

    print (" * Writing commands to " + ors_in_port_name)
    print (" * Listening status on " + ors_out_port_name)

    print (" * Writing heal command to " + ors_Heal_port_name)
    print (" * Writing destination to " + ors_Dest_port_name)
    print (" * Listening to GPS on " + ors_GPS_port_name)
    print (" * Listening to robot status on " + ors_Status_port_name)

    print (" * Writing commands to " + ors_Proximity_in_port_name)
    print (" * Listening status on " + ors_Proximity_out_port_name)

    print (" * Enter command:")

    command_robot()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = ros_tutorial
#!/usr/bin/env python

import rospy
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Twist

cmd = rospy.Publisher("/atrv/motion", Twist)
motion = Twist()
def callback(msg):
    position = msg.pose.position
    if position.x < 1:
        motion.linear.x = +0.5
    if position.x > 2:
        motion.linear.x = -0.5
    cmd.publish(motion)

rospy.init_node("rostuto1")
rospy.Subscriber("/atrv/pose", PoseStamped, callback)
rospy.spin() # this will block untill you hit Ctrl+C


########NEW FILE########
__FILENAME__ = socket_v_omega_client
import sys
import socket
import collections
import json


HOST = "localhost"
server_motion_port = 60000
server_pose_port = 60001
connected = False


def _print_data(data):
    """ Choose how to print, depending on the type """
    for item in data:
        # Recursively call this function if item is a list
        if isinstance(item, list):
            _print_data(item)
        elif isinstance(item, str):
            print ("\t%s" % item)
        elif isinstance(item, collections.OrderedDict):
            print ("\t%s" % item)
        elif isinstance(item, float):
            print ("\t%.4f" % item)


def _connect_port(port):
    """ Establish the connection with the given MORSE port"""
    local_socket = None

    for res in socket.getaddrinfo(HOST, port, socket.AF_UNSPEC, socket.SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        try:
            local_socket = socket.socket(af, socktype, proto)
        except socket.error as msg:
            local_socket = None
            continue
        try:
            local_socket.connect(sa)
        except socket.error as msg:
            local_socket.close()
            local_socket = None
            continue
        break

    return local_socket



def _usage(program_name):
    print ("Usage: {0} [server_motion_port_number] [server_pose_port_number]\n", program_name)


def main():
    global server_motion_port
    global server_pose_port
    global connected

    # Read the arguments
    argc = len(sys.argv)
    if argc == 2:
        server_motion_port = int(sys.argv[1])
    if argc == 3:
        server_motion_port = int(sys.argv[1])
        server_pose_port = int(sys.argv[2])
    elif argc > 4:
        _usage(sys.argv[0])
        sys.exit()

    pose_socket = _connect_port(server_pose_port)
    motion_socket = _connect_port(server_motion_port)

    if pose_socket and motion_socket:
        connected = True
    else:
        print ("Error connecting ports. Exiting!")
        sys.exit(-1)

    while True:
        #--------- ASK FOR OPTIONS ----------------#
        print ("Select an option:")
        print ("a) Enter speed")
        print ("b) Read coordinates")
        print ("q) Quit client program")
        op = input("Enter option: ")

        if op == 'a':
            # Ask for the new speeds
            v = input("Enter V speed: ")
            w = input("Enter W speed: ")

            # Build the required data structure, a dictionary
            v_w = {"v": float(v), "w": float(w)}
            print ("Sending the command: {0}".format(v_w))

            # Send the data
            data_out = (json.dumps((v_w)) + '\n').encode()
            print ("SENDING: %s through port %d" % (data_out, server_motion_port))
            sent = motion_socket.send(data_out)

            print ("Just sent %d bytes to server" % sent)

        elif op == 'b':
            data_in = pose_socket.recv(1024)
            try:
                # Split the long string received and keep
                #  only the last complete item
                data_string = str(data_in)
                data_string = data_string.split('\\n')[-2]
                print ("RECEIVED: %s" % data_string)
                #received_data = json.loads(data_in.decode('utf-8'))
                #_print_data(received_data)
            except EOFError as detail:
                print ("\tNo data available for the moment")
            except TypeError as detail:
                print ("\tData is empty?? '%s'" % detail)

        elif op == 'q':
            break

        else:
            print ("Unknown option. Try again.")


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = socket_waypoint_client
import sys
import socket
import collections
if sys.version_info >= (3,0,0):
    import pickle
else:
    import cPickle as pickle


server_ip = "localhost"
server_port = 60000
connected = False

def read_data(client_socket):
    """ Read the input socket until no more data is available """
    finished = False
    data_in = ''

    if connected:
        # Receiving
        while not finished:
            try:
                data_in, SRIP = client_socket.recvfrom(1024)
                #print ("READ: {0}".format(data_in))
            except socket.error as detail:
                finished = True
                #print ("Socket error: %s" % detail)
                continue

        return data_in


def print_data(data):
    """ Choose how to print, depending on the type """
    for item in data:
        # Recursively call this function if item is a list
        if isinstance(item, list):
            print_data(item)
        elif isinstance(item, str):
            print ("\t%s" % item)
        elif isinstance(item, float):
            print ("\t%.4f" % item)
        elif isinstance(item, collections.OrderedDict):
            print ("\t%s" % item)
        else:
            print ("Read data of type: %s" % type(item))



def usage(program_name):
    print ("Usage: {0} [server_port_number]\n", program_name)


def main():
    global server_port
    global connected

    px = 0
    py = 0
    pz = 0
    tolerance = 0.5
    speed = 1

    # Read the arguments
    argc = len(sys.argv)
    if argc == 2:
        server_port = int(sys.argv[1])
    elif argc > 3:
        usage(sys.argv[0])
        sys.exit()

    socket_client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    host = (server_ip, server_port)
    socket_client.setblocking(0)


    while True:
        #--------- ASK FOR OPTIONS ----------------#
        print ("Select an option:")
        print ("a) Enter destination")
        print ("b) Enter speed")
        print ("c) Read coordinates")
        print ("q) Quit client program")
        if sys.version_info >= (3,0,0):
            op = input("Enter option: ")
        else:
            op = raw_input("Enter option: ")

        if op == 'a':
            if sys.version_info >= (3,0,0):
                px = input("Enter X coordinate: ")
                py = input("Enter Y coordinate: ")
                pz = input("Enter Z coordinate: ")
            else:
                px = raw_input("Enter X coordinate: ")
                py = raw_input("Enter Y coordinate: ")
                pz = raw_input("Enter Z coordinate: ")
            waypoint = [float(px), float(py), float(pz), float(tolerance), float(speed)]
            print ("Sending the command: {0}".format(waypoint))

            # Send data
            Data = pickle.dumps((waypoint))
            sent = socket_client.sendto(Data,host)

            print ("Just sent %d bytes to server" % sent)
            # Set the flag that a connection has been established
            connected = True

        elif op == 'b':
            if sys.version_info >= (3,0,0):
                speed = input("Enter speed: ")
            else:
                speed = raw_input("Enter speed: ")
            waypoint = [float(px), float(py), float(pz), float(tolerance), float(speed)]
            print ("Sending the command: {0}".format(waypoint))

            # Send data
            Data = pickle.dumps((waypoint))
            sent = socket_client.sendto(Data,host)

            print ("Just sent %d bytes to server" % sent)

        elif op == 'c':
            # Read data
            data_in = read_data(socket_client)
            try:
                pickled_data = pickle.loads(data_in)
                print_data(pickled_data)
            except EOFError as detail:
                print ("\tNo data available for the moment")
            except TypeError as detail:
                print ("\tData is empty?? '%s'" % detail)

        elif op == 'q':
            break

        else:
            print ("Unknown option. Try again.")



if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = hybrid-client
import os, random
from time import sleep

import hla
import hla.rti as rti
import hla.omt as fom

#Defines the 'MorseVector' type that will be transfered on the HLA federation.
MorseVector = fom.HLAfixedArray("MorseVector", fom.HLAfloat32LE, 3)

class MorseHLAClient():
    def __init__(self, robot_name, host="localhost", port=60400):
        self.fom = "morse.fed"
        self.federation = "MORSE"
        self.robot = None
        # Setup environment
        if os.getenv("CERTI_HTTP_PROXY") == None:
            os.environ["CERTI_HTTP_PROXY"] = ""
        os.environ["CERTI_HOST"] = str(host)
        os.environ["CERTI_TCP_PORT"] = str(port)
        # Create Ambassador
        try:
            self.rtia = rti.RTIAmbassador()
            print("Creating MORSE Federation...")
            try:
                self.rtia.createFederationExecution(self.federation, self.fom)
            except rti.FederationExecutionAlreadyExists:
                print("%s federation already exists", self.federation)
            except rti.CouldNotOpenFED:
                print("FED file not found! " + \
                      "Please check that the '.fed' file is in the CERTI " + \
                      "search path of RTIg.")
                return None
            except rti.ErrorReadingFED:
                print("Error when reading FED file! " + \
                      "Please check the '.fed' file syntax.")
                return None
            print("Joining MORSE Federation...")
            try:
                self.morse_ambassador = rti.FederateAmbassador()
                self.rtia.joinFederationExecution("client-hla", self.federation, self.morse_ambassador)
            except rti.FederateAlreadyExecutionMember:
                print("A Federate with name %s has already registered."+\
                      " Change the name of your federate or " + \
                      "check your federation architecture.", self.node_name)
                return None
            except rti.CouldNotOpenFED:
                print("FED file not found! Please check that the " + \
                      "'.fed' file is in the CERTI search path.")
                return None
            except rti.ErrorReadingFED:
                print("Error when reading FED file! "+ \
                      "Please check the '.fed' file syntax.")
                return None
            # Get class/attribute handlers
            try:
                self.robot_t = self.rtia.getObjectClassHandle("Robot")
                self.position_t = self.rtia.getAttributeHandle("position", self.robot_t)
                self.orientation_t = self.rtia.getAttributeHandle("orientation", self.robot_t)
            except rti.NameNotFound:
                print("'Robot' (or attributes) not declared in FOM." + \
                      "Your '.fed' file may not be up-to-date.")
                return None
            # Declare a robot
            self.rtia.publishObjectClass(self.robot_t, [self.position_t, self.orientation_t])
            self.robot = self.rtia.registerObjectInstance(self.robot_t, robot_name)
            print("Pose of robot %s will be published on the %s federation.", robot_name, self.federation)
            print("MorseAmbassador initialized")
        except Exception as error:
            print("Error when connecting to the RTIg: %s." + \
                  "Please check your HLA network configuration.", error)
            return None
            
    def __del__(self):
        print("Resigning from the HLA federation")
        self.rtia.deleteObjectInstance(self.robot, self.rtia.getObjectInstanceName(self.robot))
        self.rtia.resignFederationExecution(hla.rti.ResignAction.DeleteObjectsAndReleaseAttributes)
            
    def send(self, x, y):
        hla_att = {self.position_t: MorseVector.pack([x, y, 0]),
                   self.orientation_t: MorseVector.pack([0, 0, 0])
                   }
        print("Sending ATRV position ", x, ", ", y)
        self.rtia.updateAttributeValues(self.robot, hla_att, "update")
        self.rtia.tick()

# main
if __name__ == "__main__":
    m = MorseHLAClient("ATRV")
    if m is not None:
        for k in range(10):
            x = random.randint(0, 7)
            y = random.randint(-5, 0)
            m.send(x, y)
            sleep(1)

########NEW FILE########
__FILENAME__ = Cat_waypoints_pymorse_socket_script
""" Simple script for the FLYING CAT AND MOUSE game tutorial

This will command the flying cat, using the pose sensor of the mouse, to follow
after the latter."""

import math
from pymorse import Morse
# Use sockets through pymorse interface


""" The minimal distance to maintain between the mouse and the cat. """
minDist = 5.0

""" The height for the flying cat. """
# NB: this is the absolute height not the one relative to the ground...
# TODO: use sensors (laser?) to take into account the ground and the obstacle
height= 3.5 


def where_is(agentPose_stream):
    """ Read data from the [mouse|cat] pose sensor, and determine the position of the agent """
    pose = agentPose_stream.get()

    return pose


def frighten_mouse():
    """ Use the mouse pose sensor to locate and "chase" it """

    with Morse() as morse:
        catPose = morse.cat.catPose
        mousePose = morse.mouse.mousePose
        motion = morse.cat.waypoint

        while True:
            catPosition = where_is(catPose)
            mousePosition = where_is(mousePose)

            if mousePosition and catPosition:
                # go behind the mouse
                waypoint = {    "x": mousePosition['x'] - minDist*math.cos(mousePosition['yaw']), \
                                "y": mousePosition['y'] - minDist*math.sin(mousePosition['yaw']), \
                                "z": height, \
                                "yaw": catPosition['yaw'], \
                                "tolerance": 0.5 \
                            }

                # look at the mouse
                if mousePosition['x']==catPosition['x']:
                     waypoint['yaw']= math.sign(mousePosition['y']-catPosition['y']) * math.pi
                else:
                    waypoint['yaw']= math.atan2(mousePosition['y']-catPosition['y'],mousePosition['x']-catPosition['x'])
                
                # send the command through the socket
                motion.publish(waypoint)


def main():
    """ Main behaviour """
    frighten_mouse()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = Scene_Client
import sys, os
import json
import re
import yarp

try:
   scriptRoot = os.path.join(os.environ['ORS_ROOT'],'scripts')
except KeyError:
   scriptRoot = '.'

try:
   libRoot = os.path.join(os.environ['ORS_ROOT'],'lib')
except KeyError:
   libRoot = '.'

sys.path.append(scriptRoot)
sys.path.append(libRoot)

from middleware.independent.IndependentBlender import *

# Global variables for the names of the input and output ports
ors_in_port_name = "/ors/admin/in"
#ors_out_port_name = "/ors/robots/OBATRV/Gyroscope"
ors_out_port_name = "/ors/admin/out"

local_in_port_name = "/scene/admin/in"
local_out_port_name = "/scene/admin/out"

orsConnector = MiddlewareConnector()

local_in_port = 0
local_out_port = 0


def get_robot_data():
	bottle = local_out_port.prepare()
	bottle.clear()
	bottle.addString("list_robots")
	local_out_port.write(False)

	waiting = True

	print ("Sent the request")

	while waiting:
		robot_data = local_in_port.read(False)
		if robot_data is not None:

			"""
			# Reading an integer from the bottle
			gyro = robot_data.get(0).asInt()
			print ("Decripted data: '{0}'".format(gyro))
			"""

			# Reading a string from the bottle
			json_data = robot_data.toString()
			print ("Encripted data: '{0}'".format(json_data))
			# Remove the quotations at the start and end of the string
			json_data = re.sub(r'"(.*)"', r'\1', json_data)
			# Unescape all other quotation marks
			json_data = re.sub(r'\\(.)', r'\1', json_data)
			print ("Unescaped data: '{0}'".format(json_data))
			robot_list = json.loads(json_data)
			print ("Decripted data: '{0}'".format(robot_list))


			for item in robot_list:
				name, components = item
				print ("\tRobot: {0}".format(name))
				for comp in components:
					print ("\t\t{0}".format(comp))

			waiting = False


def port_setup():
	global local_in_port
	global local_out_port

	yarp.Network.init()

	local_in_port = yarp.BufferedPortBottle()
	local_in_port.open(local_in_port_name)
	local_out_port = yarp.BufferedPortBottle()
	local_out_port.open(local_out_port_name)

	yarp.Network.connect (local_out_port_name, ors_in_port_name)
	yarp.Network.connect (ors_out_port_name, local_in_port_name)


port_setup()
get_robot_data()

########NEW FILE########
__FILENAME__ = action-1
from morse.builder import *

# Land robot
atrv = ATRV()
atrv.translate(z=0.1000)

platine = PTU()
platine.translate(x=0.2000, z=0.9000)
atrv.append(platine)

stereo = StereoUnit()
stereo.translate(z=0.0400)
platine.append(stereo)

CameraL = VideoCamera()
CameraL.translate(x=0.1000, y=0.2000, z=0.0700)
stereo.append(CameraL)
CameraL.properties(capturing = True)
CameraL.properties(cam_width = 320)
CameraL.properties(cam_height = 240)
CameraL.properties(cam_focal = 25.0000)

CameraR = VideoCamera()
CameraR.translate(x=0.1000, y=-0.2000, z=0.0700)
stereo.append(CameraR)
CameraR.properties(capturing = True)
CameraR.properties(cam_width = 320)
CameraR.properties(cam_height = 240)
CameraR.properties(cam_focal = 25.0000)

gps = GPS()
gps.translate(x=-0.2000, z=0.9000)
atrv.append(gps)

gyroscope = Gyroscope()
gyroscope.translate(z=0.9000)
atrv.append(gyroscope)
gyroscope.properties(reference_frame = 'pomGPSFramePos')
gyroscope.properties(confidence = 0.1000)

motion = MotionVW()
atrv.append(motion)

# Helicopter robot
rmax = RMax()
rmax.translate(x=5.0, y=0.0, z=9.0)

gps01 = GPS()
rmax.append(gps01)

camera02 = VideoCamera()
camera02.translate(x=1.4000)
camera02.rotate(x=-1.5708)
rmax.append(camera02)
camera02.properties(capturing = True)
camera02.properties(cam_width = 512)
camera02.properties(cam_height = 512)
camera02.properties(cam_focal = 35.0000)

gyroscope01 = Gyroscope()
gyroscope01.translate(x=0.8000, z=1.1000)
rmax.append(gyroscope01)

motion01 = Destination()
rmax.append(motion01)


# Scene configuration
gps01.add_stream('yarp')
camera02.add_stream('yarp')
motion01.add_stream('yarp')
gyroscope01.add_stream('yarp')

platine.add_stream('yarp')

motion.add_stream('pocolibs')
stereo.add_stream('pocolibs')
gyroscope.add_stream('pocolibs')

gps01.configure_modifier('NED')
motion01.configure_modifier('NED')
gyroscope01.configure_modifier('NED')

#env = Environment('land-1/buildings_2')
env = Environment('land-1/trees')
env.set_camera_rotation([1.0470, 0, 0.7854])

########NEW FILE########
__FILENAME__ = quadrotor_dynamic_example
from morse.builder import *
import math

waypoint_controller = True

# must be called before creating component
bpymorse.set_speed(fps = 120, logic_step_max = 5, physics_step_max = 5)

# Simple quadrotor with rigid body physics
quadrotor = Quadrotor()
quadrotor.translate(x= -1.2483, y=1.7043, z=1.8106)
quadrotor.name = 'mav'

if waypoint_controller:
    motion = RotorcraftWaypoint()
    motion.name = 'waypoint'
    motion.add_stream('ros')
else:
    # simple controller taking RC-like roll/pitch/yaw/thrust input
    motion = RotorcraftAttitude()
    motion.name = 'attitude'
    motion.add_stream('ros', 'morse.middleware.ros.read_asctec_ctrl_input.CtrlInputReader')

quadrotor.append(motion)

imu = IMU()
imu.name = 'imu'
# IMU with z-axis down (NED)
imu.rotate(x=math.pi)
imu.add_stream('ros')
quadrotor.append(imu)

env = Environment('indoors-1/indoor-1')
env.show_framerate(True)
#env.show_physics(True)

env.create()

########NEW FILE########
__FILENAME__ = rosace-1
from morse.builder import *

atrv00 = ATRV()

atrv01 = ATRV()
atrv01.translate(y=-5.0000)

gps00 = GPS()
gps00.translate(x=-0.2000, z=0.9000)
atrv00.append(gps00)

gps01 = GPS()
gps01.translate(x=-0.2000, z=0.9000)
atrv01.append(gps01)

gyroscope00 = Gyroscope()
gyroscope00.translate(z=0.9000)
atrv00.append(gyroscope00)

gyroscope01 = Gyroscope()
gyroscope01.translate(z=0.9000)
atrv01.append(gyroscope01)

waipont00 = Waypoint()
atrv00.append(waipont00)
waipont00.properties(Speed = 10.0000)

waipont01 = Waypoint()
atrv01.append(waipont01)
waipont01.properties(Speed = 10.0000)

proximity00 = Proximity()
proximity00.translate(y=0.2000, z=1.0000)
atrv00.append(proximity00)
proximity00.properties(Range = 30.0000)

proximity01 = Proximity()
proximity01.translate(y=0.2000, z=1.0000)
atrv01.append(proximity01)
proximity01.properties(Range = 30.0000)

rosace00 = SearchAndRescue()
rosace00.translate(x=0.3000, z=0.9000)
atrv00.append(rosace00)
rosace00.properties(Heal_range = 2.0000)
rosace00.properties(Abilities = '1,2')

rosace01 = SearchAndRescue()
rosace01.translate(x=0.3000, z=0.9000)
atrv01.append(rosace01)
rosace01.properties(Heal_range = 2.0000)
rosace01.properties(Abilities = '1,2')

thermometer00 = Thermometer()
thermometer00.translate(y=-0.2000, z=0.9000)
atrv00.append(thermometer00)

thermometer01 = Thermometer()
thermometer01.translate(y=-0.2000, z=0.9000)
atrv01.append(thermometer01)


gps00.add_stream('yarp', 'post_json_message', 'morse/middleware/yarp/json_mod')
waipont00.add_stream('yarp', 'read_json_waypoint', 'morse/middleware/yarp/json_mod')
rosace00.add_stream('yarp', 'post_json_message', 'morse/middleware/yarp/json_mod')
proximity00.add_stream('yarp', 'post_json_message', 'morse/middleware/yarp/json_mod')

gps01.add_stream('yarp', 'post_json_message', 'morse/middleware/yarp/json_mod')
waipont01.add_stream('yarp', 'read_json_waypoint', 'morse/middleware/yarp/json_mod')
rosace01.add_stream('yarp', 'post_json_message', 'morse/middleware/yarp/json_mod')
proximity01.add_stream('yarp', 'post_json_message', 'morse/middleware/yarp/json_mod')

waipont00.add_service('yarp_json')
rosace00.add_service('yarp_json')

waipont01.add_service('yarp_json')
rosace01.add_service('yarp_json')

# Victims
victim1 = Victim()
victim1.translate(x=4.0)
victim1.properties(Requirements = "1,2,3")

victim2 = Victim()
victim2.translate(x=8.0, y=5.0)
victim2.properties(Requirements = "1")

env = Environment('land-1/rosace_1')
env.set_camera_location([9, -9, 9])

########NEW FILE########
__FILENAME__ = ros_depth
from morse.builder import *

# Append ATRV robot to the scene
atrv = ATRV()

# Append an actuator
motion = MotionVW()
motion.translate(z=0.3)
atrv.append(motion)
motion.add_stream('ros')

# Append an Odometry sensor
odometry = Odometry()
odometry.translate(z=0.73)
atrv.append(odometry)
odometry.add_stream('ros')

# Append a camera
camera = DepthCamera()
camera.translate(x = 0.3, z = 0.76)
camera.properties(cam_width = 640, cam_height = 480)
camera.frequency(15)
atrv.append(camera)
camera.add_stream('ros')

env = Environment('indoors-1/indoor-1')
env.set_camera_rotation([1.0470, 0, 0.7854])
env.show_framerate()
camera.profile()
odometry.profile()

########NEW FILE########
__FILENAME__ = ros_example_multi
from morse.builder import *

# http://www.openrobots.org/morse/doc/latest/user/tutorial.html

def import_atrv(mw):
    # Append ATRV robot to the scene
    atrv = ATRV()

    # Append an actuator
    motion = MotionVW()
    motion.translate(z=0.3)
    atrv.append(motion)

    # Append a Gyroscope sensor
    gyroscope = Gyroscope()
    gyroscope.translate(z=0.83)
    atrv.append(gyroscope)

    # Configuring the middlewares
    gyroscope.add_stream(mw)
    motion.add_stream(mw)
    return atrv

atrv1 = import_atrv('ros')
atrv1.translate(x=-6)

atrv2 = import_atrv('ros')
atrv2.translate(x=-4)

atrv3 = import_atrv('ros')
atrv3.translate(x=-2)

env = Environment('indoors-1/indoor-1')
env.set_camera_rotation([1.0470, 0, 0.7854])

del env

# rostopic pub -1 /atrv1/motion geometry_msgs/Twist "{linear: {x: .1}, angular: {z: .1}}"
# rostopic pub -1 /atrv2/motion geometry_msgs/Twist "{linear: {x: .1}, angular: {z: .1}}"
# rostopic pub -1 /atrv3/motion geometry_msgs/Twist "{linear: {x: .1}, angular: {z: .1}}"

########NEW FILE########
__FILENAME__ = test-1
from morse.builder import *

# Append ATRV robot to the scene
atrv = ATRV()

# Append an actuator
motion = MotionVW()
motion.translate(z=0.3)
atrv.append(motion)

# Append an odometry sensor
odometry = Odometry()
odometry.translate(x=-0.1, z=0.83)
atrv.append(odometry)

# Append a proximity sensor
proximity = Proximity()
proximity.translate(x=-0.2, z=0.83)
atrv.append(proximity)

# Append a Pose sensor (GPS + Gyroscope)
pose = Pose()
pose.translate(x=0.2,z=0.83)
atrv.append(pose)

# Append a sick laser
sick = Sick()
sick.translate(x=0.18,z=0.94)
atrv.append(sick)
sick.properties(resolution = 1)
sick.properties(laser_range = 5.0)

# Append a camera
cam = VideoCamera()
cam.translate(x=0.3,z=1.1)
atrv.append(cam)
cam.properties(cam_width = 128, cam_height = 128)

# Configure the middlewares
motion.add_stream('yarp')
odometry.add_stream('yarp')
proximity.add_stream('yarp')
pose.add_stream('yarp')
sick.add_stream('yarp')
cam.add_stream('yarp')

# Configure the middlewares
motion.add_stream('socket')
pose.add_stream('socket')

env = Environment('laas/grande_salle')
env.set_camera_rotation([1.0470, 0, 0.7854])

########NEW FILE########
__FILENAME__ = cat_mouse_game
from morse.builder import *

#
# "cat" robot
#
cat = ATRV()
cat.translate(x=-6.0, z=0.2)

motion = MotionVW()
cat.append(motion)

semanticL = SemanticCamera()
semanticL.translate(x=0.2, y=0.3, z=0.9)
cat.append(semanticL)

semanticR = SemanticCamera()
semanticR.translate(x=0.2, y=-0.3, z=0.9)
cat.append(semanticR)

motion.add_stream('socket')
semanticL.add_stream('socket')
semanticR.add_stream('socket')

#
# "mouse" robot
#
mouse = ATRV()
mouse.properties(Object = True, Graspable = False, Label = "MOUSE")
mouse.translate(x=1.0, z=0.2)

keyboard = Keyboard()
keyboard.properties(Speed=3.0)
mouse.append(keyboard)

#
# Environment
#
env = Environment('land-1/trees')
env.set_camera_location([10.0, -10.0, 10.0])
env.set_camera_rotation([1.0470, 0, 0.7854])
env.select_display_camera(semanticL)

########NEW FILE########
__FILENAME__ = collision
""" MORSE Collision example """
from morse.builder import *

dala = ATRV()
dala.properties(obstacle=1)

robot = ATRV()

keyboard = Keyboard()
keyboard.properties(Speed=3)
robot.append(keyboard)

collision = Collision()
collision.properties(collision_property="obstacle")
collision.add_stream('socket')
collision.translate(x = 0.7, z = 0.2)
robot.append(collision)
robot.translate(x = -2.0)

env = Environment('outdoors')

########NEW FILE########
__FILENAME__ = flying_outdoor_cat_mouse_game
from morse.builder import *

from math import pi

""" Cat (Quadrotor) """
cat = Quadrotor()
cat.translate(x=-7.0, z=1.0)
cat.rotate(z=pi/3)

# Waypoint controller (x,y,z, yaw and tolerance (default is 0.2))
waypoint = RotorcraftWaypoint()
cat.append(waypoint)
waypoint.add_stream('socket')

semanticC = SemanticCamera()
semanticC.translate(x=0.3, z=-0.05)
semanticC.rotate(x=+0.2)
cat.append(semanticC)
semanticC.properties(Vertical_Flip=False)

catPose = Pose()
cat.append(catPose)
catPose.add_stream('socket')


""" mouse (atrv)"""
mouse = ATRV()
mouse.translate (x=-4.0,y=6.5, z=0.1)
mouse.rotate(z=0.70*pi)

keyb = Keyboard()
keyb.properties(Speed=2.0)
mouse.append(keyb)

mousePose = Pose()
mouse.append(mousePose)
mousePose.add_stream('socket')


""" The playground """
env = Environment('outdoors')
env.set_camera_location([10.0, -10.0, 10.0])
env.set_camera_rotation([1.0470, 0, 0.7854])
env.select_display_camera(semanticC)

########NEW FILE########
__FILENAME__ = interactive_human_tutorial
from morse.builder import *
from math import pi

human = Human()
human.translate(x = 31.0, y = -12.0, z = 0.0)
human.rotate(x = 0.0, y = 0.0, z = pi)

# passive Objects
plate = PassiveObject('props/kitchen_objects', 'Plate')
plate.setgraspable()
plate.translate(x=-2.9, y=1.89, z=0.92)

fork = PassiveObject('props/kitchen_objects', 'Fork')
fork.setgraspable()
fork.translate(x=-2.9, y=1.69, z=0.91)
fork.rotate(z=pi/2)

knife = PassiveObject('props/kitchen_objects', 'Knife')
knife.setgraspable()
knife.translate(x=-2.9, y=2.09, z=0.91)
knife.rotate(z=pi/2)

bottle = PassiveObject('props/misc_objects', 'Bottle')
bottle.setgraspable()
bottle.translate(x=-3.5, y=1.7, z=1.24)

cup1 = PassiveObject('props/kitchen_objects', 'Cup_Ocher')
cup1.setgraspable()
cup1.translate(x=3.3, y=-5.6, z=1.07)
cup1.rotate(z=0.1)

cup2 = PassiveObject('props/kitchen_objects', 'Cup_Blue')
cup2.setgraspable()
cup2.translate(x=3.4, y=-5.35, z=1.07)
cup2.rotate(z=pi/2)

cup3 = PassiveObject('props/kitchen_objects', 'Cup_Gray')
cup3.setgraspable()
cup3.translate(x=3.5, y=-5.6, z=1.07)

book1 = PassiveObject('props/misc_objects', 'Book_Wine_fat')
book1.setgraspable()
book1.translate(x=0.37, y=5.53, z=0.145)

book2 = PassiveObject('props/misc_objects', 'Book_Blue_fat')
book2.setgraspable()
book2.translate(x=0.46, y=5.55, z=0.165)

book3 = PassiveObject('props/misc_objects', 'Book_Wine_thin')
book3.setgraspable()
book3.translate(x=0.53, y=5.53, z=0.136)
book3.rotate(y=-0.28)

book4 = PassiveObject('props/misc_objects', 'Book_Blue_fat')
book4.setgraspable()
book4.translate(x=0.685, y=5.5, z=0.162)

book5 = PassiveObject('props/misc_objects', 'Book_Wine_thin')
book5.setgraspable()
book5.translate(x=0.34, y=5.53, z=0.5265)

book6 = PassiveObject('props/misc_objects', 'Book_Brown_medium')
book6.setgraspable()
book6.translate(x=0.7, y=5.53, z=0.476)
book6.rotate(y=pi/2)

book6 = PassiveObject('props/misc_objects', 'Book_Brown_thin')
book6.setgraspable()
book6.translate(x=0.87, y=5.5, z=0.49)
book6.rotate(y=-1.29)

book7 = PassiveObject('props/misc_objects', 'Book_Blue_medium')
book7.setgraspable()
book7.translate(x=3.25, y=2.99, z=0.934)
book7.rotate(x=1.879, y=pi/2)

env = Environment('human_tut/tutorial_scene')

########NEW FILE########
__FILENAME__ = joystick
""" MORSE Joystick example """
from morse.builder import *

robot = ATRV()

joystick = Joystick()
joystick.properties(Speed=3)
robot.append(joystick)

env = Environment('outdoors')

########NEW FILE########
__FILENAME__ = kinect
""" MORSE Kinect example
"""
from morse.builder import *

robot = ATRV()

keyboard = Keyboard()
keyboard.properties(Speed=3)
robot.append(keyboard)

odometry = Odometry()
odometry.add_stream('ros')
robot.append(odometry)

kinect = Kinect()
kinect.add_stream('ros', frame_id='kinect')
robot.append(kinect)

env = Environment('outdoors')


########NEW FILE########
__FILENAME__ = dala_simple
from morse.builder import *

def equipped_robot(mw='yarp'):
    # Append ATRV robot to the scene
    atrv = ATRV()

    # Append an actuator
    motion = MotionVW()
    atrv.append(motion)

    # Append a Pose sensor (GPS + Gyroscope)
    pose = Pose()
    pose.translate(x=0.2,z=0.83)
    atrv.append(pose)

    # Append a sick laser
    sick = Sick()
    sick.translate(x=0.18,z=0.94)
    atrv.append(sick)
    sick.properties(resolution = 1)
    sick.properties(laser_range = 5.0)

    # Append a camera
    cam = VideoCamera()
    cam.translate(x=0.3,z=1.1)
    atrv.append(cam)
    cam.properties(cam_width = 128, cam_height = 128)

    # Configure the middlewares
    motion.add_stream(mw)
    pose.add_stream(mw)
    sick.add_stream(mw)
    cam.add_stream(mw)

    return (atrv)

########NEW FILE########
__FILENAME__ = tutorial-hla-hybrid
# Add the path of this file to PYTHONPATH
import os, sys, inspect
# cmd_folder = os.path.dirname(os.path.abspath(__file__)) # DO NOT USE __file__ !!!
# __file__ fails if script is called in different ways on Windows
# __file__ fails if someone does os.chdir() before
# sys.argv[0] also fails because it doesn't not always contains the path
cmd_folder = os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0])
if cmd_folder not in sys.path:
        sys.path.insert(0, cmd_folder)


from morse.builder import *

atrv = ATRV()

env = Environment('laas/grande_salle')
env.show_framerate(True)
env.show_physics(False)

env.configure_multinode(protocol="hla", server_address="127.0.0.1", server_port=60400, 
    distribution={
        "atrv": [atrv.name],
    })

env.set_camera_rotation([1.3300, 0, 0.7854])
env.set_camera_location([10.0, -10.0, 3.0])

env.create()

########NEW FILE########
__FILENAME__ = tutorial-hla
# Add the path of this file to PYTHONPATH
import os, sys, inspect
# cmd_folder = os.path.dirname(os.path.abspath(__file__)) # DO NOT USE __file__ !!!
# __file__ fails if script is called in different ways on Windows
# __file__ fails if someone does os.chdir() before
# sys.argv[0] also fails because it doesn't not always contains the path
cmd_folder = os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0])
if cmd_folder not in sys.path:
        sys.path.insert(0, cmd_folder)


from morse.builder import *

from dala_simple import equipped_robot

dala1 = equipped_robot(mw='yarp')
dala2 = equipped_robot(mw='yarp')
dala2.translate(5, -3, 0)

env = Environment('laas/grande_salle')
env.show_framerate(True)
env.show_physics(False)

env.configure_multinode(protocol="hla", server_address="127.0.0.1", server_port=60400, 
    distribution={
        "nodeA": [dala1.name],
        "nodeB": [dala2.name],
    })

env.set_camera_rotation([1.3300, 0, 0.7854])
env.set_camera_location([10.0, -10.0, 3.0])

env.create()

########NEW FILE########
__FILENAME__ = tutorial-socket
# Add the path of this file to PYTHONPATH
import os, sys, inspect
# cmd_folder = os.path.dirname(os.path.abspath(__file__)) # DO NOT USE __file__ !!!
# __file__ fails if script is called in different ways on Windows
# __file__ fails if someone does os.chdir() before
# sys.argv[0] also fails because it doesn't not always contains the path
cmd_folder = os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0])
if cmd_folder not in sys.path:
        sys.path.insert(0, cmd_folder)


from morse.builder import *

from dala_simple import equipped_robot

dala1 = equipped_robot('socket')
dala2 = equipped_robot('socket')
dala2.translate(5, -3, 0)

env = Environment('laas/grande_salle')
env.show_framerate(True)
env.show_physics(False)

env.configure_multinode(protocol="socket", distribution={
    "nodeA": [dala1.name],
    "nodeB": [dala2.name],
    })
#env.configure_multinode(protocol="socket",
#    server_address="140.93.0.93", server_port="65000", distribution=dict())

env.set_camera_rotation([1.3300, 0, 0.7854])
env.set_camera_location([10.0, -10.0, 3.0])

env.create()

########NEW FILE########
__FILENAME__ = multinode
""" MORSE Multinode tutorial (socket, localhost)

Run as:

    multinode_server
    morse run -g 800x600 --name node1 multinode.py
    morse run -g 800x600 --name node2 multinode.py
    morse run -g 800x600 --name node3 multinode.py
    # ...
"""
from morse.builder import *

robots = {}

for idx in range(11):
    idx_robot = 'node%i' % idx
    robots[idx_robot] = ATRV('dala%i' % idx)
    kb = Keyboard('keyb')
    robots[idx_robot].append(kb)
    robots[idx_robot].translate(idx, -idx, 0)
    kb.properties(Speed=3)

env = Environment('outdoors')#, fastmode=True)
env.show_framerate(True)

env.configure_multinode(
        protocol = "socket",
        server_address = "localhost",
        server_port = "65000",
        distribution = {idx: robots[idx].name for idx in robots.keys()}
    )

env.create()
#env.set_log_level('morse.multinode.socket', 'debug')

########NEW FILE########
__FILENAME__ = noise_ghost_tutorial
from morse.builder import *

robot = ATRV()
pose = Pose()
robot.append(pose)
pose.add_stream('socket')
keyboard = Keyboard()
robot.append(keyboard)
pose.alter('Noise', pos_std=.5, rot_std=0, _2D='True')

ghost = ATRV()
ghost.make_ghost()
teleport = Teleport()
ghost.append(teleport)
ghost.add_default_interface('socket')

env = Environment("land-1/trees")
env.create()
########NEW FILE########
__FILENAME__ = scenario
from morse.builder import *

# Append PR2 robot to the scene
james = BasePR2()
james.translate(x=2.5, y=3.2, z=0.0)

# Sensors and Actuators for navigation stack
#pr2_posture = PR2Posture()
#james.append(pr2_posture)
#pr2_posture.add_stream('ros')

motion_controller = MotionXYW()
james.append(motion_controller)
motion_controller.add_stream('ros')

odometry = Odometry()
james.append(odometry)
odometry.add_stream('ros')

sick = Sick()
sick.translate(x=0.275, z=0.252)
james.append(sick)
sick.properties(Visible_arc=False)
sick.properties(laser_range=30.0000)
sick.properties(resolution=1.0000)
sick.properties(scan_window=180.0000)
sick.add_stream('ros')

# Keyboard control
keyboard = Keyboard()
keyboard.name = 'keyboard_control'
james.append(keyboard)

# Set scenario
env = Environment('tum_kitchen/tum_kitchen')
env.set_camera_rotation([1.0470, 0, 0.7854])

########NEW FILE########
__FILENAME__ = sound
""" MORSE Sound example

You can control this actuator using any middleware, here using pymorse:

    from pymorse import Morse
    sim = Morse()
    sim.robot.sound.publish({"mode":"stop"})
    sim.robot.sound.publish({"mode":"play"})
    sim.robot.sound.publish({"mode":"pause"})
    sim.close()
"""
from morse.builder import *

robot = ATRV()

keyboard = Keyboard()
keyboard.properties(Speed=3)
robot.append(keyboard)

sound = Sound()
# TODO edit the path to an existing file on your system
sound.open("/path/to/file.mp3")
sound.add_stream('socket')
robot.append(sound)

env = Environment('outdoors')


########NEW FILE########
__FILENAME__ = tutorial-1-moos-lidar
from morse.builder import *

# Land robot
atrv = ATRV()

gyroscope = Gyroscope()
gyroscope.translate(z = 0.75)
atrv.append(gyroscope)

pose = Pose()
pose.translate(z = 0.75)
atrv.append(pose)

gps = GPS()
gps.translate(z = 0.75)
atrv.append(gps)

imu = IMU()
imu.translate(z = 0.75)
atrv.append(imu)

sick = Sick()
sick.translate(x = 0.50, z = 0.75)
atrv.append(sick)

motion = MotionVW()
atrv.append(motion)

# Add datastream for our robot's components
gyroscope.add_stream("morse.middleware.moos_datastream.MOOS", "morse.middleware.moos.gyroscope.GyroscopeNotifier")
motion.add_stream("morse.middleware.moos_datastream.MOOS", "morse.middleware.moos.motion.MotionReader")
pose.add_stream("morse.middleware.moos_datastream.MOOS", "morse.middleware.moos.pose.PoseNotifier")
gps.add_stream("morse.middleware.moos_datastream.MOOS", "morse.middleware.moos.gps.GPSNotifier")
imu.add_stream("morse.middleware.moos_datastream.MOOS", "morse.middleware.moos.imu.IMUNotifier")
sick.add_stream("morse.middleware.moos_datastream.MOOS", "morse.middleware.moos.sick.LIDARNotifier")

env = Environment('indoors-1/indoor-1')

########NEW FILE########
__FILENAME__ = tutorial-1-moos
from morse.builder import *

# Land robot
atrv = ATRV()

gyroscope = Gyroscope()
gyroscope.translate(z = 0.75)
atrv.append(gyroscope)

motion = MotionVW()
atrv.append(motion)

# Add datastream for our robot's components
gyroscope.add_stream('moos')
motion.add_stream('moos')

env = Environment('indoors-1/indoor-1')

########NEW FILE########
__FILENAME__ = tutorial-1-ros
from morse.builder import *

# Land robot
atrv = ATRV()

pose = Pose()
pose.translate(z = 0.75)
atrv.append(pose)

motion = MotionVW()
atrv.append(motion)

# Add default interface for our robot's components
atrv.add_default_interface('ros')

env = Environment('indoors-1/indoor-1')

########NEW FILE########
__FILENAME__ = tutorial-1-sockets
from morse.builder import *

# Land robot
atrv = ATRV()

pose = Pose()
pose.translate(z = 0.75)
atrv.append(pose)

motion = MotionVW()
atrv.append(motion)

# Scene configuration
motion.configure_service('socket')
pose.configure_service('socket')

env = Environment('indoors-1/indoor-1')
env.set_camera_location([5, -5, 6])
env.set_camera_rotation([1.0470, 0, 0.7854])

########NEW FILE########
__FILENAME__ = tutorial-1
from morse.builder import *

# Land robot
atrv = ATRV()

env = Environment('indoors-1/indoor-1')

########NEW FILE########
__FILENAME__ = tutorial-2-yarp
from morse.builder import *

# Land robot
atrv = ATRV()

pose = Pose()
pose.translate(x=-0.2000, z=0.9000)
atrv.append(pose)

camera = VideoCamera()
camera.translate(x=0.2000, z=0.9000)
atrv.append(camera)

motion = Waypoint()
atrv.append(motion)

# Scene configuration
motion.add_stream('yarp')
pose.add_stream('yarp')
camera.add_stream('yarp')

env = Environment('indoors-1/indoor-1')
env.set_camera_rotation([1.0470, 0, 0.7854])

########NEW FILE########
__FILENAME__ = armature
import logging; logger = logging.getLogger("morse." + __name__)
import math
from morse.core.blenderapi import mathutils

from collections import OrderedDict
import morse.core.actuator
from morse.core import status
from morse.core.blenderapi import version, CONSTRAINT_TYPE_KINEMATIC, CONSTRAINT_IK_DISTANCE
from morse.core.services import service, async_service, interruptible
from morse.core.exceptions import MorseRPCInvokationError
from morse.core.morse_time import time_isafter
from morse.helpers.morse_math import normalise_angle
from morse.helpers.components import add_property

class Armature(morse.core.actuator.Actuator):
    """
    **Armatures** are the MORSE generic way to simulate kinematic chains
    made of a combination of revolute joints (hinge) and prismatic
    joints (slider).

    This component only allows to *set* an armature configuration. To read the
    armature pose, you need an :doc:`armature pose sensor <../sensors/armature_pose>`.

    .. important:: 

        To be valid, special care must be given when creating armatures. If you
        want to add new one, please carefully read the :doc:`armature creation
        <../../dev/armature_creation>` documentation.


    This actuator offers two main ways to control a kinematic chain: either by
    setting the values of each joint individually (via a continuous datastream
    or via dedicated services: :py:meth:`translate`,
    :py:meth:`set_translation`, :py:meth:`rotate`, :py:meth:`set_rotation`) or
    by placing the end-effector and relying on a inverse kinematic solver (via
    the services :py:meth:`set_IK_target` and :py:meth:`move_IK_target`).

    .. note::

        When setting the joints with a datastream, the data structure that the
        armature actuator expects depends on the armature itself.  It is a
        dictionary of pair `(joint name, joint value)`.  Joint values are
        either radians (for revolute joints) or meters (for prismatic joints)

    To use inverse kinematics, you must first define *IK targets* to control
    your kinematic chain. You can create them :doc:`manually from Blender
    <../../dev/armature_creation>` or directly in your `Builder script` (refer
    to the `Examples` section below for an example).

    .. example::

        from morse.builder import *

        robot = ATRV()

        # imports an armature,
        # either from a Blender file...
        armature = Armature(model_name = "<blend file>")
        # ...or by providing the name of an existing armature:
        # armature = Armature(armature_name = "<name of armature>")
        # (note that you can combine both options to select an armature in a 
        # Blender file)

        # if you want to use inverse kinematics, you can create 'IK targets'
        # here as well:
        armature.create_ik_targets(["<name of the bone you want to control>", ...])

        # place your armature at the correct location
        armature.translate(<x>, <y>, <z>)
        armature.rotate(<rx>, <ry>, <rz>)

        # define one or several communication interfaces, like 'socket' or 'ros'
        # With ROS, this actuator exposes a JointTrajectoryAction interface.
        armature.add_interface(<interface>)

        robot.append(armature)

        env = Environment('empty')
        
    .. note::

        :tag:`ros` Armatures can be controlled in ROS through the
        `JointTrajectoryAction
        <http://wiki.ros.org/joint_trajectory_action>`_
        interface.

    :sees: :doc:`armature pose sensor <../sensors/armature_pose>`

    :noautoexample:
    """
    _name = "Armature Actuator"
    _short_desc="An actuator to manipulate Blender armatures in MORSE."

    add_property('distance_tolerance', 0.005, 'DistanceTolerance', 'float', "Tolerance in meters when translating a joint")
    add_property('angle_tolerance', 0.01, 'AngleTolerance', 'float', "Tolerance in radians when rotating a joint")
    add_property('radial_speed', 0.8, 'RotationSpeed', 'float', "Global rotation speed for the armature rotational joints (in rad/s)")
    add_property('linear_speed', 0.05, 'LinearSpeed', 'float', "Global linear speed for the armature prismatic joints (in m/s)")
    add_property('ik_target_radial_speed', 0.5, 'IKRotationSpeed', 'float', "Default speed of IK target rotation (in rad/s)")
    add_property('ik_target_linear_speed', 0.5, 'IKLinearSpeed', 'float', "Default speed of IK target motion (in m/s)")

    def __init__(self, obj, parent=None):
        """
        Creates a new instance of Armature.

        :param obj: the Blender **armature** object that is to be controlled.
        """     
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)
        
        # Initialize the values in local_data for each segment
        armature = self.bge_object

        for channel in armature.channels:
            self.local_data[channel.name] = 0.0

        self._ik_targets = {c.target: c for c in armature.constraints \
                            if c.type == CONSTRAINT_TYPE_KINEMATIC and \
                               c.ik_type == CONSTRAINT_IK_DISTANCE}

        # Initially desactivate all IK constraints
        for c in self._ik_targets.values():
            c.active = False

        # holds the destinations for the IK targets when async service
        # `move_IK_target` is called.
        self._ik_targets_destinations = {}

        # The axis along which the different segments rotate
        # Considering the constraints defined for the armature
        #  in the Blender file
        self._dofs = self.get_dofs()

        self.joint_speed = {}

        # Look for the armature's end effector, if any
        self._end_effector = None
        for child in self.bge_object.childrenRecursive:
            if 'end_effector' in child:
                logger.info("Found end effector (%s) for armature %s" % (child.name, obj.name))
                self._end_effector= child
                break

        # If we find an end effector, all armature children that do not have
        # the property 'internal' are considered to be mounted on the end
        # effector
        if self._end_effector:
            for child in self.bge_object.children:
                if not 'internal' in child:
                    child.setParent(self._end_effector)

        ####
        # Trajectory specific variables
        self._active_trajectory = None


        logger.info('%s armature initialized with joints [%s].' % (obj.name, ", ".join(self.local_data.keys())))

        if self._ik_targets:
            logger.info("%d IK targets available on this armature: %s." % (len(self._ik_targets), ", ".join([t.name for t in self._ik_targets.keys()])))

    def _suspend_ik_targets(self):
        for c in self._ik_targets.values():
            #Bug in Blender! cf http://developer.blender.org/T37892
            if version() < (2, 70, 0):
                if not c.active:
                    logger.info("Stop tracking IK target <%s>" % c.target.name)
                    c.active = False
            else:
                if c.active:
                    logger.info("Stop tracking IK target <%s>" % c.target.name)
                    c.active = False


    def _restore_ik_targets(self):
        for c in self._ik_targets.values():
            #Bug in Blender! cf http://developer.blender.org/T37892
            if version() < (2, 70, 0):
                if c.active:
                    c.active = True
                    logger.info("Tracking IK target <%s>" % c.target.name)
            else:
                if not c.active:
                    c.active = True
                    logger.info("Tracking IK target <%s>" % c.target.name)


    def _is_prismatic(self, channel):
        """
        Important: The detection of prismatic joint relies solely on a
        non-zero value for the IK parameter 'ik_stretch'.
        """
        return True if channel.ik_stretch else False

    def _get_joint(self, joint):
        """ Checks a given joint name exist in the armature,
        and returns it as a tuple (Blender channel, is_prismatic?)

        If the joint does not exist, throw an exception.
        """
        armature = self.bge_object

        if joint not in [c.name for c in armature.channels]:
            msg = "Joint <%s> does not exist in armature %s" % (joint, armature.name)
            raise MorseRPCInvokationError(msg)

        channel = armature.channels[joint]

        if self._is_prismatic(channel):
            return channel, True
        else:
            return channel, False

    def _get_joint_value(self, joint):
        """
        Returns the *value* of a given joint, either:
        - its absolute rotation in radian along its rotation axis, or
        - it absolute translation in meters along its translation axis.

        Throws an exception if the joint does not exist.

        :param joint: the name of the joint in the armature.
        """
        channel, is_prismatic = self._get_joint(joint)

        # Retrieve the motion axis
        axis_index = next(i for i, j in enumerate(self.find_dof(channel)) if j)

        if is_prismatic:
            return channel.pose_head[2] #The 'Z' value
        else: # revolute joint
            return channel.joint_rotation[axis_index]

    def _get_prismatic(self, joint):
        """ Checks a given prismatic joint name exist in the armature, and
        returns it.
        """
        channel, is_prismatic = self._get_joint(joint)

        if not is_prismatic:
            msg = "Joint %s is not a prismatic joint! " \
                  "Can not set the translation" % joint
            raise MorseRPCInvokationError(msg)

        return channel

    def _get_revolute(self, joint):
        """ Checks a given revolute joint name exist in the armature, and
        returns it.
        """
        channel, is_prismatic = self._get_joint(joint)

        if is_prismatic:
            msg = "Joint %s is not a revolute joint! Can not set the rotation" % joint
            raise MorseRPCInvokationError(msg)

        return channel

    def _clamp_joint(self, channel, rotation):

        ik_min, ik_max = self.get_IK_limits(channel.name)
        return max(ik_min, min(rotation, ik_max))

    @service
    def list_IK_targets(self):
        return [ik.name for ik in self._ik_targets.keys()]

    def _normalize_IK_transformation(self, 
                                     target_name, 
                                     translation, 
                                     euler_rotation = None, 
                                     relative = True):

        armature = self.bge_object
        target = [ik for ik in self._ik_targets.keys() if ik.name == target_name]
        if not target:
            raise MorseRPCInvokationError("IK target <%s> does not exist for armature %s" % (target_name, armature.name))

        target = target[0]

        if relative:
            currentPos = target.worldPosition
            translation = [translation[0] + currentPos[0],
                           translation[1] + currentPos[1],
                           translation[2] + currentPos[2]]

        if euler_rotation:
            current_orientation = target.worldOrientation.to_quaternion().normalized()
            rotation = mathutils.Euler(euler_rotation).to_quaternion().normalized()

            if relative:
                # computes the final IK target orientation by rotating the
                # current orientation by `rotation`
                final_orientation = current_orientation.copy()
                final_orientation.rotate(rotation)
            else:
                final_orientation = rotation
        else:
            final_orientation = None

        return target, translation, final_orientation

    @service
    def place_IK_target(self, name, translation, euler_rotation = None, relative = True):
        """
        Places instantaneously a IK (inverse kinematic) target to a given
        position and orientation.

        :sees: `move_IK_target` to move the IK target over time.

        :param name: name of the IK target (as returned by
        :py:meth:`list_IK_targets`)
        :param translation: a [x,y,z] translation vector, in the scene frame,
        in meters.
        :param rotation: a [rx,ry,rz] rotation, in the scene frame (ie, X,Y,Z 
        rotation axis are the scene axis). Angles in radians.
        :param relative: if True (default), translation and rotation are 
        relative to the current target pose.

        """
        self._restore_ik_targets()

        target, translation, rotation = self._normalize_IK_transformation(
                                                        name, 
                                                        translation, 
                                                        euler_rotation, 
                                                        relative)

        target.worldPosition = translation
        if rotation:
            target.worldOrientation = rotation

        # save the joint state computed from IK in local_data
        self._store_current_joint_state()

    @interruptible
    @async_service
    def move_IK_target(self, name, 
                             translation, euler_rotation = None, 
                             relative = True, 
                             linear_speed = None, radial_speed = None):
        """
        Moves an IK (inverse kinematic) target at a given speed (in m/s for
        translation, rad/s for rotation).

        Note that moving an IK target conflicts somewhat with the original
        purpose of the inverse kinematic solver, and overall continuity is not
        guaranteed (the IK solver may find a solution for a given target
        position that 'jumps' relative to the solution for the previous target
        position).

        :sees: `place_IK_target` to set instantaneously the IK target pose.

        :param name: name of the IK target (as returned by :py:meth:`list_IK_targets`)
        :param translation: a [x,y,z] translation vector, in the scene frame, 
        in meters.
        :param rotation: a [rx,ry,rz] rotation, in the scene frame (ie, X,Y,Z 
        rotation axis are the scene axis). Angles in radians.
        :param relative: if True (default), translation and rotation are 
        relative to the current target pose.
        :param linear_speed: (default: value of the `ik_target_linear_speed` 
        property) translation speed (in m/s).
        :param radial_speed: (default: value of the `ik_target_radial_speed` 
        property) rotation speed (in rad/s).

        """

        self._restore_ik_targets()

        target, translation, final_orientation = self._normalize_IK_transformation(
                                                            name, 
                                                            translation, 
                                                            euler_rotation, 
                                                            relative)

        if not linear_speed:
            linear_speed = self.ik_target_linear_speed
        if not radial_speed:
            radial_speed = self.ik_target_radial_speed

        if final_orientation:
            current_orientation = target.worldOrientation.to_quaternion().normalized()

            # uses mathutils.Vector.angle to return the angle in radians
            # between the 2 orientations
            radian_distance = current_orientation.axis.angle(final_orientation.axis)

            # we need to compute at initialization the total expected duration
            # of the rotation since quaternion interpolation relies on
            # Quaternion.slerp that takes a interpolation factor between 0.0
            # and 1.0.  During the rotation execution, we compute the factor
            # based on the current rotation duration and the total expected
            # duration
            initial_time_rotation = self.robot_parent.gettime() # in seconds
            total_rotation_duration = (radian_distance / radial_speed) 
        else:
            current_orientation = final_orientation = None
            initial_time_rotation = total_rotation_duration = None

        self._ik_targets_destinations[target] = (translation, 
                                                 linear_speed, 
                                                 current_orientation, 
                                                 final_orientation, 
                                                 initial_time_rotation, 
                                                 total_rotation_duration)

    @service
    def set_translation(self, joint, translation):
        """
        Translates instantaneously the given (prismatic) joint by the given
        translation. Joint speed limit is not taken into account.

        :sees: `Blender documentation on joint location <http://www.blender.org/documentation/blender_python_api_2_64_release/bge.types.html#bge.types.BL_ArmatureChannel.location>`_

        If the joint does not exist or is not a prismatic joint (slider),
        throws a MorseServiceFailed exception.

        The translation is always clamped to the joint limit.

        :param joint: name of the joint to move
        :param translation: absolute translation from the joint origin in the
        joint sliding axis, in meters

        """

        self._suspend_ik_targets()

        channel = self._get_prismatic(joint)

        # Retrieve the translation axis
        axis_index = next(i for i, j in enumerate(self.find_dof(channel)) if j)

        translation = self._clamp_joint(channel, translation)

        self.local_data[channel.name] = translation

        tmp = channel.location
        tmp[axis_index] = translation
        channel.location = tmp

    @service
    def set_translations(self, translations):
        """
        Sets in one call the translations of the prismatic joints in this
        armature.

        Has the same effect as applying `set_translation` on each of the joints
        independantly.

        Translations must be ordered from the root to the tip of the armature.

        If more translations are provided than the number of joints, the
        remaining ones are discarded. If less translations are provided, the
        maximum are applied.

        .. important::

            If a revolute joint is encountered while applying the translations,
            an exception is thrown, and **no** translation is applied.

        :sees: `set_translation`
        :param translations: a set of absolute translations, in meters
        """
        armature = self.bge_object

        nb_trans = min(len(translations), len(armature.channels))

        channels = [c for c in armature.channels]
        for i in range(nb_trans):
            if not self._is_prismatic(channels[i]):
                msg = "Joint %s is not a prismatic joint! " \
                      "Can not apply the translation set" % channels[i].name
                raise MorseRPCInvokationError(msg)

        for trans, channel in zip(translations[:nb_trans], channels[:nb_trans]):
            self.set_translation(channel.name, trans)


    @interruptible
    @async_service
    def translate(self, joint, translation, speed = None):
        """
        Translates a joint at a given speed (in m/s).

        :param joint: name of the armature's joint to translate
        :param translation: the absolute translation, relative to the joint
        origin, in meters
        :param speed: (default: value of 'linear_speed' property) translation
        speed, in m/s

        """

        self._suspend_ik_targets()

        channel = self._get_prismatic(joint) # checks the joint exist and is prismatic
        translation = self._clamp_joint(channel, translation)
        self.joint_speed[joint] = speed

        logger.info("Initiating translation of joint %s to %s"%(joint, translation))
        self.local_data[joint] = translation

    @service
    def set_rotation(self, joint, rotation):
        """
        Rotates instantaneously the given (revolute) joint by the given
        rotation. Joint speed limit is not taken into account.

        If the joint does not exist or is not a revolute joint (hinge),
        throws a MorseServiceFailed exception.

        The rotation is always clamped to the joint limit.

        :param joint: name of the joint to rotate
        :param rotation: absolute rotation from the joint origin along the
        joint rotation axis, in radians

        """

        self._suspend_ik_targets()

        channel = self._get_revolute(joint)

        # Retrieve the translation axis
        axis_index = next(i for i, j in enumerate(self.find_dof(channel)) if j)

        rotation = self._clamp_joint(channel, rotation)

        self.local_data[channel.name] = rotation

        tmp = channel.joint_rotation
        tmp[axis_index] = rotation
        channel.joint_rotation = tmp

    @service
    def set_rotations(self, rotations):
        """
        Sets in one call the rotations of the revolute joints in this armature.

        Has the same effect as applying `set_rotation` on each of the joints
        independantly.

        Rotations must be ordered from the root to the tip of the armature.

        If more rotations are provided than the number of joints, the remaining
        ones are discarded. If less rotations are provided, the maximum are
        applied.

        .. important::

            If a prismatic joint is encountered while applying the rotation,
            an exception is thrown, and **no** rotation is applied.

        :sees: `set_rotation`
        :param rotations: a set of absolute rotations, in radians
        """
        armature = self.bge_object

        nb_rot = min(len(rotations), len(armature.channels))

        channels = [c for c in armature.channels]
        for i in range(nb_rot):
            if self._is_prismatic(channels[i]):
                msg = "Joint %s is not a revolute joint! Can not apply the rotation set" % joint
                raise MorseRPCInvokationError(msg)

        for rot, channel in zip(rotations[:nb_rot], channels[:nb_rot]):
            self.set_rotation(channel.name, rot)



    @interruptible
    @async_service
    def rotate(self, joint, rotation, speed = None):
        """
        Rotates a joint at a given speed (in rad/s).

        :sees: `Blender documentation on joint rotation <http://www.blender.org/documentation/blender_python_api_2_64_release/bge.types.html#bge.types.BL_ArmatureChannel.joint_rotation>`_

        :param joint: name of the armature's joint to rotate
        :param rotation: rotation around the joint axis in radians
        :param speed: (default: value of 'radial_speed' property) rotation speed, in rad/s
        """

        self._suspend_ik_targets()

        channel = self._get_revolute(joint) # checks the joint exist and is revolute
        rotation = self._clamp_joint(channel, rotation)
        self.joint_speed[joint] = speed

        logger.info("Initiating rotation of %s to pos. %f (along the joint rotation axis)"%(joint, rotation))
        self.local_data[joint] = rotation

    def find_dof(self, channel):
        """
        Method that finds and returns the degree of freedom (dof) corresponding
        to the given channel.
        The dof has to be a blender_ik_setting.
        Returns a list [x,y,z] with the corresponding dofs as a boolean.
        """
        return [channel.ik_dof_x, 
                channel.ik_dof_y,
                channel.ik_dof_z]

    @service
    def get_dofs(self):
        """
        Returns a dictionary with keys the channels
        of the armature and as values the rotation axis of the joint.
        """
        armature = self.bge_object
        dofs = {}
        # find the dof of each channel
        for channel in armature.channels:
            dofs[channel.name] = self.find_dof(channel)

        return dofs

    @service
    def get_IK_limits(self, joint):
        """
        Returns the IK limits for the given joint.
        
        - For revolute joints, returns a pair `(ik_min,ik_max)`, in radians.
        - For prismatic joint, returns a pair `(0.0, max translation)`, in meters.
        """

        channel, is_prismatic = self._get_joint(joint)

        if is_prismatic:
            return 0.0, channel.ik_stretch
        else:
            # Retrieve the translation axis
            axis_index = next(i for i, j in enumerate(self.find_dof(channel)) if j)
            if axis_index == 0:
                return (channel.ik_min_x, 
                        channel.ik_max_x)
            elif axis_index == 1:
                return (channel.ik_min_y, 
                        channel.ik_max_y)
            elif axis_index == 2:
                return (channel.ik_min_z, 
                        channel.ik_max_z)

            assert False # should not reach this point.

    @async_service
    def trajectory(self, trajectory):
        """
        Executes a joint trajectory to the armature.

        The `trajectory` parameter should have the following structure:

        .. code-block:: python

            trajectory = {
                'starttime': <timestamp in second>,
                'points': [
                    {'positions': [...],
                     'velocities': [...],
                     'accelerations' [...],
                     'time_from_start': <seconds>}
                    {...},
                    ...
                    ]
                }

        .. warning::
            
            Currently, both `velocities` and `accelerations` are ignored.

        The trajectory execution starts after `starttime` timestamp passed
        (if omitted, the trajectory execution starts right away).
        
        `points` is the list of trajectory waypoints. It is assumed that the
        values in the waypoints are ordered the same way as in the set of
        joint of the armature (ie, from the root to the tip of the armature).
        `velocities` and `accelerations` are optional.

        The component attempts to achieve each waypoint at the time obtained
        by adding that waypoint's `time_from_start` value to `starttime`.

        :param trajectory: the trajectory to execute, as describe above.
        """

        self._suspend_ik_targets()

        # TODO: support velocities and accelerations via cubic/quintic spline
        # interpolation
        starttime = self.robot_parent.gettime()
        if 'starttime' in trajectory:
            trajectory["starttime"] = max(starttime, trajectory["starttime"])
        else:
            trajectory["starttime"] = starttime

        self._active_trajectory = trajectory

    def _exec_traj(self):

        t = self.robot_parent.gettime()
        trajectory = self._active_trajectory

        try:
            if time_isafter(trajectory["starttime"], t):
                return
            
            if time_isafter(t, trajectory["starttime"] + trajectory["points"][-1]["time_from_start"]):
                #trajectory execution is over!
                self._active_trajectory = None
                # TODO: check here the final pose match the last point pose
                self.completed(status.SUCCESS, None)

            for p in trajectory["points"]:
                end = trajectory["starttime"] + p["time_from_start"]
                if "started" in p and time_isafter(end, t):
                    # currently going to this waypoint: fine!
                    break

                elif "started" not in p and time_isafter(end, t):
                    # start the new waypoint
                    allocated_time = end - t
                    assert(allocated_time > 0)

                    target = OrderedDict(zip(self.local_data.keys(),
                                    p["positions"]))

                    for joint in target.keys():
                        # compute the distance based on actual current joint pose
                        dist = target[joint] - self._get_joint_value(joint)
                        self.joint_speed[joint] = dist/allocated_time

                    self.local_data = target

                    p["started"] = True
                    break

                elif "started" not in p and time_isafter(t, end):
                    logger.warning("Skipped a waypoint on armature <%s>. Wrong 'time_from_start'?" % self.name())

                # case: "started" and t > end: do nothing, go to next point
        except KeyError as ke:
            self._active_trajectory = None
            self.completed(status.FAILED, "Error: invalid trajectory: key %s was expected." % ke)

    def _store_current_joint_state(self):
        for joint in self.local_data.keys():
            self.local_data[joint] = self._get_joint_value(joint)

    def interrupt(self):
    
        self._store_current_joint_state()

        for joint in self.local_data.keys():
            if joint in self.joint_speed:
                del self.joint_speed[joint]

        self._active_trajectory = None

        self._ik_targets_destinations = {}

        morse.core.actuator.Actuator.interrupt(self)

    def _exec_ik_move(self, 
                      target, 
                      location, lspeed, 
                      initial_orientation, final_orientation, 
                      initial_time_rotation, total_rotation_duration):

        armature = self.bge_object

        curPos = target.worldPosition
        curOri = target.worldOrientation.to_quaternion()

        posReached = False
        oriReached = False

        # first, translation
        distx = location[0]-curPos[0]
        disty = location[1]-curPos[1]
        distz = location[2]-curPos[2]

        if     abs(distx) < self.distance_tolerance \
           and abs(disty) < self.distance_tolerance \
           and abs(distz) < self.distance_tolerance:
               posReached = True
        else:
            vx = math.copysign(min(lspeed / self.frequency, abs(distx)), distx)
            vy = math.copysign(min(lspeed / self.frequency, abs(disty)), disty)
            vz = math.copysign(min(lspeed / self.frequency, abs(distz)), distz)
            target.worldPosition = [curPos[0] + vx, curPos[1] + vy, curPos[2] + vz]

        # then, orientation (as quaternion!)
        oriReached = True
        if final_orientation:

            rotation_duration = self.robot_parent.gettime() - initial_time_rotation

            if not rotation_duration > total_rotation_duration:
                oriReached = False
                target.worldOrientation = initial_orientation.slerp(
                                                    final_orientation, 
                                                    rotation_duration / total_rotation_duration)
            else:
                # make sure we eventually reach the final position
                target.worldOrientation = final_orientation 

        # Update the armature to reflect the changes we just performed
        armature.update()

        # save the joint state computed from IK in local_data
        self._store_current_joint_state()

        if posReached and oriReached:
            self.completed(status.SUCCESS, None)

    def default_action(self):
        """
        Move the armature according to both the value of local_data

        """

        #TODO: 3 type of async service can be started: joint rotate/translate, 
        # traj execution and IK target move.
        # We need to re-organize the code to check none run at the same time and
        # to keep everything well organized/manageable.

        if self._ik_targets_destinations:

            for k,v in self._ik_targets_destinations.items():
                self._exec_ik_move(k,*v)

            # if we move IK targets, we do not want to do anything else.
            return

        if self._active_trajectory:
            self._exec_traj()


        armature = self.bge_object

        #TODO: we should no have to iterate over the whole armature when we do
        # not have to move at all!
        position_reached = True
        for channel in armature.channels:

            # we assume a joint is prismatic (translation joint) if its IK
            # 'stretch' parameter is non-null
            is_prismatic = self._is_prismatic(channel)

            joint = channel.name

            if joint in self.joint_speed and self.joint_speed[joint]:
                speed = self.joint_speed[joint]
            else:
                speed = self.linear_speed if is_prismatic else self.radial_speed


            # Retrieve the rotation or translation axis
            axis_index = next(i for i, j in enumerate(self.find_dof(channel)) if j)

            if is_prismatic:
                # we take the last index ('Z') of the pose of the HEAD of the
                # bone as the absolute translation of the joint. Not 100% sure
                # it is right...
                dist = self.local_data[joint] - channel.pose_head[2] 
            else:
                dist = self.local_data[joint] - channel.joint_rotation[axis_index]

            w = math.copysign(speed / self.frequency, dist)

            if is_prismatic:
                if not abs(dist) < self.distance_tolerance:
                    position_reached = False

                    trans = channel.location
                    trans[axis_index] += w
                    channel.location = trans
            else:
                if not abs(dist) < self.angle_tolerance:
                    position_reached = False

                    rot = channel.joint_rotation
                    rot[axis_index] += w
                    channel.joint_rotation = rot

            # Update the armature to reflect the changes with just performed
            armature.update()


        if position_reached: # True only when all joints match local_data
            if not self._active_trajectory: # _exec_traj() manage completion for trajectories
                self.completed(status.SUCCESS, None)
            if joint in self.joint_speed:
                del self.joint_speed[joint]



########NEW FILE########
__FILENAME__ = arucomarker
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.actuator
from morse.core.services import service, async_service, interruptible
from morse.core import status
from morse.helpers.components import add_data, add_property
from morse.core import mathutils
import math

class Arucomarker(morse.core.actuator.Actuator):
    """ 
    The ArUco marker is an AR-Marker that allows to compute the camera
    pose from images in the 'real world'. 
    
    See: http://www.uco.es/investiga/grupos/ava/node/26

    The purpose of this actuator is to  provide a virtual instance of
    such a marker in MORSE. By adding an ArUco marker to a MORSE
    simulation you can subsequently stream/export a (virtual) camera
    image and eventually use an AR Marker without a physical camera
    setup or, i.e, test algorithms or simulate visual servoring.

    .. example::

        from morse.builder import *

        ### Add a virtual ArUco marker to the scene
        robot = Morsy()

        aruco = Arucomarker()
        aruco.add_stream('ros', topic="/aruco_pose")
        aruco.properties(zoffset=0.3, xoffset=-0.09, yoffset=.0)

        robot.append(aruco)

        env = Environment('empty')


    :noautoexample: 
    """

    _name = "ArUco Marker"
    _short_desc = "A virtual representation of an ArUco Marker" 

    add_data('x',     0.0, 'float', 'X axis translation metres')
    add_data('y',     0.0, 'float', 'Y axis translation metres')
    add_data('z',     0.0, 'float', 'Z axis translation metres')
    add_data('roll',  0.0, 'float', 'X axis rotation in rad')
    add_data('pitch', 0.0, 'float', 'Y axis rotation in rad')
    add_data('yaw',   0.0, 'float', 'Z axis rotation in rad')

    """
    Initialises translation properties, they can be accessed via builder script
    These properties add a static offset to the marker. You may want to use this
    if you plan on aligning the marker to a virtual camera, which would allow you
    to test your tracking algorithms based on the image of a virtual camera for
    instance
    """
    add_property('_xoffset', 0.0, 'xoffset', 'float', "X axis translation offset in metres")
    add_property('_yoffset', 0.0, 'yoffset', 'float', "Y axis translation offset in metres")
    add_property('_zoffset', 0.0, 'zoffset', 'float', "Z axis translation offset in metres")    

    def __init__(self, obj, parent=None):
        logger.info("%s initialization" % obj.name)
        morse.core.actuator.Actuator.__init__(self, obj, parent)
        
        """ 
        Save the ArUco object and its parent to compute the relative
        position later on in default_action()
        """
        self.aruco = {}
        self.aruco['aruco']  = self.bge_object
        self.aruco['parent'] = self.robot_parent

        """ 
        Spawn the marker as specified in the builder script via translate
        The rotation is zeroed initially
        """
        self.local_data['x']     = self.aruco['aruco'].worldPosition[0] 
        self.local_data['y']     = self.aruco['aruco'].worldPosition[1] 
        self.local_data['z']     = self.aruco['aruco'].worldPosition[2]
        self.local_data['roll']  = 0.0 
        self.local_data['pitch'] = 0.0
        self.local_data['yaw']   = 0.0
        
        logger.info('Component initialized')

    @service
    def get_local_position(self):
        return self.aruco['aruco'].localPosition

    @service
    def get_world_position(self):
        return self.aruco['aruco'].worldPosition
    
    @service 
    def get_local_orientation(self):
        return self.aruco['aruco'].localOrientation

    @service
    def get_world_orientation(self):
        return self.aruco['aruco'].worldOrientation
    
    """ 
    Apply roation and translation, function 
    lifted from teleport actuator class +
    applying parents position in case it moves
    """
    def force_pose(self, position, orientation):
        me = self.aruco['aruco']
        parent = self.aruco['parent']
        pose3d = parent.position_3d
        parent_pose = mathutils.Vector((pose3d.x, pose3d.y, pose3d.z))
        if position:
            me.worldPosition = position + parent_pose
        if orientation:
            me.worldOrientation = orientation
    
    """ 
    The default action which is executed every LOGIC TICK
    Compute current location, i.e., provided via middleware (in metres)
    NOTE: By default, the ArUco translation (AT), as defined in the
    original ArUco library, corresponds to the MORSE translation 
    (MT) as follows:
    
    MTx =  ATz
    MTy =  ATx
    MTz = -ATy
 
    See example below
    """
    def default_action(self):
        position = mathutils.Vector( (self.local_data['z']+self._xoffset,
                                     self.local_data['x']+self._yoffset,
                                     (-1.0*self.local_data['y']+self._zoffset)) )

        orientation = mathutils.Euler([ self.local_data['roll' ],
                                        self.local_data['pitch'],
                                        self.local_data['yaw'  ] ])
       
        """ Convert Euler to Matrix, worldOrientation accepts Quat, Mat """
        orientation.order = "YZX"
        orientation_mat = orientation.to_matrix()
        self.force_pose(position, orientation_mat)

########NEW FILE########
__FILENAME__ = destination
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.actuator
from morse.helpers.components import add_data, add_property

class Destination(morse.core.actuator.Actuator):
    """
    This actuator reads the coordinates of a destination point, and moves the robot
    in a straight line towards the given point, without turning.  It provides a
    very simplistic movement, and can be used for testing or for robots with
    holonomic movement.  The speeds provided are internally adjusted to the Blender
    time measure.
    """

    _name = "Destination"
    _short_desc = "Instruct the robot to move towards a given target"

    add_data('x', 'current X pos', "float", "X coordinate of the destination")
    add_data('y', 'current Y pos', "float", "Y coordinate of the destination")
    add_data('z', 'current Z pos', "float", "Z coordinate of the destination")

    add_property('_tolerance', 0.5, 'Tolerance')
    add_property('_speed', 5.0, 'Speed')
    add_property('_type', 'Velocity', 'ControlType', 'string',
                 "Kind of control, can be one of ['Velocity', 'Position']")


    def __init__(self, obj, parent=None):

        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        self.destination = self.bge_object.position

        #self.local_data['speed'] = 0.0
        self.local_data['x'] = self.destination[0]
        self.local_data['y'] = self.destination[1]
        self.local_data['z'] = self.destination[2]

        logger.info('Component initialized')


    def default_action(self):
        """ Move the object towards the destination. """
        parent = self.robot_parent

        self.destination = [ self.local_data['x'], self.local_data['y'], self.local_data['z'] ]

        logger.debug("STRAIGHT GOT DESTINATION: {0}".format(self.destination))
        logger.debug("Robot {0} move status: '{1}'".format(parent.bge_object.name, parent.move_status))

        # Vectors returned are already normalised
        distance, global_vector, local_vector = self.bge_object.getVectTo(self.destination)

        logger.debug("My position: {0}".format(self.bge_object.position))
        logger.debug("GOT DISTANCE: {0}".format(distance))
        logger.debug("Global vector: {0}".format(global_vector))
        logger.debug("Local  vector: {0}".format(local_vector))

        if distance > self._tolerance:
            # Set the robot status
            parent.move_status = "Transit"
    
            # Scale the speeds to the time used by Blender
            try:
                if self._type == 'Position':
                    vx = global_vector[0] * self._speed / self.frequency
                    vy = global_vector[1] * self._speed / self.frequency
                    vz = global_vector[2] * self._speed / self.frequency
                else:
                    vx = global_vector[0] * self._speed
                    vy = global_vector[1] * self._speed
                    vz = global_vector[2] * self._speed
            # For the moment ignoring the division by zero
            # It happens apparently when the simulation starts
            except ZeroDivisionError:
                pass

        # If the target has been reached, change the status
        else:
            # Reset movement variables
            vx, vy, vz = 0.0, 0.0, 0.0
            #rx, ry, rz = 0.0, 0.0, 0.0

            parent.move_status = "Stop"
            logger.debug("TARGET REACHED")
            logger.debug("Robot {0} move status: '{1}'".format(parent.bge_object.name, parent.move_status))

        
        self.robot_parent.apply_speed(self._type, [vx, vy, vz], [0, 0, 0])

########NEW FILE########
__FILENAME__ = force_torque
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import mathutils
import morse.core.actuator
from morse.helpers.components import add_data, add_property

class ForceTorque(morse.core.actuator.Actuator):
    """
    This class will read force and torque as input 
    from an external middleware.
    The forces and torques are transformed from the actuator frame to the
    parent robot frame and then applied to the robot blender object.
    If the property RobotFrame is set to True it will be applied
    directly in the robot frame without changes.
    """

    _name = "Force/Torque Motion Controller"
    _short_desc="Motion controller using force and torque"


    add_data('force', [0.0, 0.0, 0.0], "vec3<float>", "force along x, y, z")
    add_data('torque', [0.0, 0.0, 0.0], "vec3<float>", "torque around x, y, z")

    add_property('_robot_frame', False, 'RobotFrame', 'bool', 'If set to true '
            'the inputs are applied in the Robot coordinate frame instead of the '
            'actuator frame.')


    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        logger.info('Component initialized')


    def default_action(self):
        """ Apply (force, torque) to the parent robot. """
        # Get the the parent robot
        robot = self.robot_parent

        if self._robot_frame:
            # directly apply local forces and torques to the blender object of the parent robot
            robot.bge_object.applyForce(self.local_data['force'], True)
            robot.bge_object.applyTorque(self.local_data['torque'], True)
        else:
            (loc, rot, scale) = robot.position_3d.transformation3d_with(self.position_3d).matrix.decompose()
            # rotate into robot frame, but still at actuator origin
            force = rot * mathutils.Vector(self.local_data['force'])
            torque = rot * mathutils.Vector(self.local_data['torque'])
            # add torque due to lever arm
            torque += loc.cross(force)
            robot.bge_object.applyForce(force, True)
            robot.bge_object.applyTorque(torque, True)

########NEW FILE########
__FILENAME__ = gripper
import logging; logger = logging.getLogger("morse." + __name__)

######################################################
#
#    gripper.py        Blender 2.59
#
#    Gilberto Echeverria
#    13 / 10 / 2010
#
######################################################

import morse.core.actuator
from morse.core import blenderapi
from morse.core.services import service
from morse.helpers.components import add_data, add_property

class Gripper(morse.core.actuator.Actuator):
    """
    Actuator capable of grabbing objects marked with the ``Graspable``
    Game Property.  Currently it only works using services: **grab** and
    **release**.  When instructed to grab an object, it will check if it
    is within range, and if so, will parent the grabbed object to
    itself.

    .. note::

        For objects to be detected and grabbed by the gripper, they must
        have the following settings in the **Physics Properties** panel:

            - **Actor** must be checked
            - **Collision Bounds** must be checked
            - **Physics Type** must be ``Rigid Body``

        This will work even for Static objects

    .. warning::

        This actuator does not simulate the physical interaction of the
        gripper fingers with the objects it grabs. Its purpose is to
        abstract the action of taking an object, for human-robot
        interaction experiments.
    """

    _name = "Gripper"
    _short_desc = "Instruct the robot to move towards a given target"

    add_data('grab', False, "bool", "Currently not used")

    # These properties are not used directly in the logic, but are used
    # in the builder to create the radar properly.
    # These value cannot be changed dynamically in bge.
    add_property('_angle', 60.0, 'Angle', 'float',
                 'Aperture angle of the radar capable to detecting the \
                  graspable objects (in degree)')
    add_property('_distance', 0.5, 'Distance', 'float',
                 'Detection distance in meter. Graspable objects further \
                 way from the gripper than this distance cannot be  \
                 held')

    def __init__(self, obj, parent=None):
        """
        Constructor method.
        Receives the reference to the Blender object.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        self._near_object = None
        self._grabbed_object = None

        # Variable to indicate whether the mesh should animate closing
        #  or opening the gripper
        self._animation = ''

        # Get references to the Logic Bricks to play animations
        self._contr = self.bge_object.controllers[0]
        self._close_anim = self._contr.actuators['Close_anim']
        self._open_anim = self._contr.actuators['Open_anim']

        logger.info('Component initialized')
        logger.setLevel(logging.DEBUG)


    def find_object(self):
        """
        Store the object that is within reach of the gripper Uses a
        Blender Radar Sensor to detect objects with the 'Graspable'
        property in front of this component
        """
        # Get reference to the Radar Blender sensor
        contr = blenderapi.controller()
        radar = contr.sensors['Radar']

        self._near_object = None
        if radar.triggered and radar.positive:
            min_distance = 100
            for test_obj in radar.hitObjectList:
                # Find the closest object and its distance
                new_distance = self.bge_object.getDistanceTo(test_obj)
                if new_distance < min_distance:
                    self._near_object = test_obj
                    min_distance = new_distance


    @service
    def grab(self):
        """
        Tries to grab an object close to the gripper.

        :returns: if successful (or if an object is already in hand), the
                  name of the object, else None.
        """
        # Check that no other object is being carried
        if not self._grabbed_object:
            # If the object is draggable
            if self._near_object is not None:
                logger.debug("Grabbing object: '%s'" % self._near_object)
                # Remove Physic simulation
                #self._near_object.suspendDynamics()
                # Parent the selected object to the gripper
                self._grabbed_object = self._near_object
                self._grabbed_object.setParent (self.bge_object)
                logger.debug("New parent: %s" % self._grabbed_object.parent)
                self._near_object = None

                # Execute the close grip animation:
                self._animation = 'close'
                return self._grabbed_object.name

            else:
                logger.debug("No 'Graspable' object within range of gripper")
                return None
        else:
            logger.debug("Already holding object %s" % self._grabbed_object )
            return self._grabbed_object.name

    @service
    def release(self):
        """
        Free the grabbed object.

        Let it fall down after resetting its rotation.
        Does nothing if no object is held.

        :returns: True if an object has been released, else False (if
                  no object was held).
        """
        # Clear the previously selected object, if any
        if self._grabbed_object is not None:
            logger.debug("Releasing object: '%s'" % self._near_object)
            # Remove the parent
            self._grabbed_object.removeParent()
            # Place the object on the nearest surface
            #morse.helpers.place_object.do_place(previous_object)
            # Reset rotation of object
            #self._grabbed_object.worldOrientation = [0.0, 0.0, 0.0]
            # Restore Physics simulation
            #previous_object.restoreDynamics()
            #previous_object.setLinearVelocity([0, 0, 0])
            #previous_object.setAngularVelocity([0, 0, 0])
            # Clear the object from dragged status
            self._grabbed_object = None

            # Execute the open grip animation:
            self._animation = 'open'
            return True

        else:
            logger.debug("No object currently being held: nothing to release.")
            return False

    def default_action(self):
        """
        Check if an object is within reach of the hand
        """
        self.find_object()

        # Play the animations when necessary
        if self._animation == 'close':
            self._contr.activate(self._close_anim)
            self._animation = ''
            logger.debug('Playing CLOSE animation')
        if self._animation == 'open':
            self._contr.activate(self._open_anim)
            self._animation = ''
            logger.debug('Playing OPEN animation')

########NEW FILE########
__FILENAME__ = joystick
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
from morse.core.actuator import Actuator
from morse.helpers.components import add_data, add_property

class Joystick(Actuator):
    """
    This actuator does not require a connection with external data. It
    simply responds to the joystick to generate movement instructions for
    the robot attached.
    """

    _name = "Joystick Actuator"
    _short_desc="A 'fake' actuator that allows to move a robot from the joystick."

    add_property('_type', 'Velocity', 'ControlType', 'string',
                 "Kind of control to move the parent robot, in ['Position', "
                 "'Velocity', 'Differential']")
    add_property('_speed', 1.0, 'Speed', 'float',
                 "Movement speed of the parent robot, in m/s")

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        Actuator.__init__(self, obj, parent)

        joysticks = blenderapi.joysticks()
        if joysticks.count(None) == len(joysticks):
            logger.error("No Joystick detected")
        else:
            logger.info("Found Joystick: " + repr(joysticks) )

        # Correct the speed considering the Blender clock
        if self._type == 'Position':
            self._speed = self._speed / self.frequency
        elif self._type == 'Differential':
            self._stopped = True
            # get track width for calculating wheel speeds from yaw rate
            parent = self.robot_parent
            self._trackWidth = parent._trackWidth
            self._radius = parent._wheelRadius

        """ Documentation says: ``bge.types.SCA_JoystickSensor.axisValues``
        Each specifying the value of an axis between -32767 and 32767 depending
        on how far the axis is pushed, 0 for nothing. The first 2 values are
        used by most joysticks and gamepads for directional control. 3rd and
        4th values are only on some joysticks and can be used for arbitary
        controls.
        """
        # speed_factor = - speed / max
        self._speed_factor = - self._speed / 32767.0

        logger.info('Component initialized')


    def default_action(self):
        """ Interpret joystick axis push and assign them to movement
            for the robot."""
        joystick_sensor = blenderapi.controller().sensors[0]
        # Reset movement variables
        vx, vy, vz = 0.0, 0.0, 0.0
        rx, ry, rz = 0.0, 0.0, 0.0

        rz = joystick_sensor.axisValues[0] * self._speed_factor
        vx = joystick_sensor.axisValues[1] * self._speed_factor

        # Give the movement instructions directly to the parent
        # The second parameter specifies a "local" movement
        if self._type == 'Position' or self._type == 'Velocity':
            self.robot_parent.apply_speed(self._type, [vx, vy, vz], [rx, ry, rz / 2.0])
        elif self._type == 'Differential':
            self.robot_parent.apply_vw_wheels(vx, -rz)

########NEW FILE########
__FILENAME__ = keyboard
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
from morse.core.actuator import Actuator
from morse.helpers.components import add_data, add_property

class Keyboard(Actuator):
    """
    This actuator does not require a connection with external data. It
    simply responds to the keyboard arrows to generate movement
    instructions for the robot attached.

    When parented to a robot, the user can press the arrow keys to modify the
    linear and angular velocities (V, W) of the robot.

    :kbd:`Up` forward
    :kbd:`Down` backwards
    :kbd:`Left` turn left
    :kbd:`Right` turn right
    """

    _name = "Keyboard Actuator"
    _short_desc="A 'fake' actuator that allows to move a robot from the keyboard."

    add_property('_type', 'Position', 'ControlType', 'string',
                 "Kind of control to move the parent robot, in ['Position', "
                 "'Velocity', 'Differential']")
    add_property('_speed', 1.0, 'Speed', 'float',
                 "Movement speed of the parent robot, in m/s")

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        Actuator.__init__(self, obj, parent)

        # Correct the speed considering the Blender clock
        if self._type == 'Position':
            self._speed = self._speed / self.frequency
        logger.info('Component initialized')


    def default_action(self):
        """ Interpret keyboard presses and assign them to movement
            for the robot."""
        keyboard = blenderapi.keyboard()
        is_actived = blenderapi.input_active()

        # Reset movement variables
        vx, vy, vz = 0.0, 0.0, 0.0
        rx, ry, rz = 0.0, 0.0, 0.0

        if keyboard.events[blenderapi.UPARROWKEY] == is_actived:
            vx = self._speed

        if keyboard.events[blenderapi.DOWNARROWKEY] == is_actived:
            vx = -self._speed

        if keyboard.events[blenderapi.LEFTARROWKEY] == is_actived:
            rz = self._speed

        if keyboard.events[blenderapi.RIGHTARROWKEY] == is_actived:
            rz = -self._speed

        if self._type == 'Position' or self._type == 'Velocity':
            self.robot_parent.apply_speed(self._type, [vx, vy, vz], [rx, ry, rz / 2.0])
        elif self._type == 'Differential':
            self.robot_parent.apply_vw_wheels(vx, rz)



########NEW FILE########
__FILENAME__ = light
# -*- coding: utf-8 -*-

import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
import morse.core.actuator
from morse.core.services import service
from morse.helpers.components import add_data, add_property
from math import pi

class Light(morse.core.actuator.Actuator):
    """
    This actuator is a simple On/Off light. Based on `SPOT
    <http://wiki.blender.org/index.php/Doc:2.6/Manual/Lighting/Lamps/Spot>`_ light.

    -  Emit in +X

    """
    _name = "Light"
    _short_desc = "A simple point light"

    add_data('emit', True, 'bool', 'On/Off light switch')
    
    add_property('_emit', True, 'emit', 'bool', "Set to False to initially disable the light")
    add_property('_distance', 10, 'distance', 'float', "Distance at which the light energy is halfed")
    add_property('_color', "(0,0,0)", 'color', 'string', "Light color")
    add_property('_size', pi/2, 'size', 'float', "Light spot size")
    add_property('_energy', 1.0, 'energy', 'float', "Light energy when On")

    def __init__(self, obj, parent=None):
        logger.info("%s initialization" % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        # get the light which is a child of the Empty object
        self.light = self.bge_object.children[0] 
        
        self.local_data['emit'] = self._emit
        self._last = not self.local_data['emit']

        logger.info('Component initialized')

    def default_action(self):
        """ Switch on/off the light. """
        # if no changes, return
        if self._last == self.local_data['emit']:
            return

        if self.local_data['emit']:
            self.light.energy = self._energy
        else:
            self.light.energy = 0.0

        # for each camera's scene: update the light
        for scene in blenderapi.get_scene_list():
            if scene.name not in ['S.MORSE_ENV', 'S.MORSE_LOGIC'] and \
                    self.light.name in scene.objects:
                scene.objects[self.light.name].energy = self.light.energy

        self._last = self.local_data['emit']

    @service
    def toggle(self, emit=None):
        """
        Toggle the light.

        :param emit: if emit is set to True/False, switch the light On/Off;
            if emit is not set, toggle the light (from On to Off and conversely)
        :return: Returns always True
        """
        if emit:
            self.local_data['emit'] = emit
        else:
            self.local_data['emit'] = not self.local_data['emit']
        return True

########NEW FILE########
__FILENAME__ = mocap_control
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.actuator
from morse.core.services import service
from math import pi
from morse.core import mathutils
from morse.helpers.components import add_data

class MocapControl(morse.core.actuator.Actuator):
    """ 
    Read the positions of the different joints at:
    head, neck, shoulders, torso, elbows, hands, hips, knees and feet
    And apply those positions to the control points (Empty's) of the armature
    """

    _name = "Mocap controller"
    _short_desc = "Controller for the motion of the human avatar, using the \
                   ASUS Xtion"

    add_data('head_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Head position")
    add_data('neck_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Neck position")
    add_data('left_hand_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Left Hand position")
    add_data('right_hand_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Right Hand position")
    add_data('left_elbow_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Left elbow position")
    add_data('right_elbow_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Right elbow position")
    add_data('left_shoulder_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Left shoulder position")
    add_data('right_shoulder_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Right shoulder position")
    add_data('left_hip_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Left hip position")
    add_data('right_hip_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Right hip position")
    add_data('left_foot_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Left foot position")
    add_data('right_foot_position', [0.0, 0.0, 0.0], "vec3<float>",
             "Right foot position")
    add_data('torso_position', [0.0, 0.0, 0.0], "vec3<float>",
            "torso position")
    add_data('left_knee_position', [0.0, 0.0, 0.0], "vec3<float>",
            "left knee position")
    add_data('right_knee_position', [0.0, 0.0, 0.0], "vec3<float>",
            "right knee position")

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        parent = self.robot_parent

        self.human_position = parent.bge_object.worldPosition

        # Find the IK target empties
        for obj in parent.bge_object.childrenRecursive:
            #if obj.name == "Head_Empty":# in obj.name:
            if "Head_Empty" in obj.name:
                self._head_empty = obj
            #if obj.name == "Neck_Empty":# in obj.name:
            if "Neck_Empty" in obj.name:
                self._neck_empty = obj
            #if obj.name == "Torso_Empty":# in obj.name:
            if "Torso_Empty" in obj.name:
                self._torso_empty = obj
            #if obj.name == "Hand_Empty.L":# in obj.name:
            if "Hand_Empty.L" in obj.name:
                self._hand_empty_l = obj
            #if obj.name == "Hand_Empty.R":# in obj.name:
            if "Hand_Empty.R" in obj.name:
                self._hand_empty_r = obj
            #if obj.name == "Elbow_Empty.L":# in obj.name:
            if "Elbow_Empty.L" in obj.name:
                self._elbow_empty_l = obj
            #if obj.name == "Elbow_Empty.R":# in obj.name:
            if "Elbow_Empty.R" in obj.name:
                self._elbow_empty_r = obj
            #if obj.name == "Shoulder_Empty.L":# in obj.name:
            if "Shoulder_Empty.L" in obj.name:
                self._shoulder_empty_l = obj
            #if obj.name == "Shoulder_Empty.R":# in obj.name:
            if "Shoulder_Empty.R" in obj.name:
                self._shoulder_empty_r = obj
            #if obj.name == "Hip_Empty.L":# in obj.name:
            if "Hip_Empty.L" in obj.name:
                self._hip_empty_l = obj
            #if obj.name == "Hip_Empty.R":# in obj.name:
            if "Hip_Empty.R" in obj.name:
                self._hip_empty_r = obj
            #if obj.name == "Knee_Empty.L":# in obj.name:
            if "Knee_Empty.L" in obj.name:
                self._knee_empty_l = obj
            #if obj.name == "Knee_Empty.R":# in obj.name:
            if "Knee_Empty.R" in obj.name:
                self._knee_empty_r = obj
            #if obj.name == "Foot_Empty.L":# in obj.name:
            if "Foot_Empty.L" in obj.name:
                self._foot_empty_l = obj
            #if obj.name == "Foot_Empty.R":# in obj.name:
            if "Foot_Empty.R" in obj.name:
                self._foot_empty_r = obj

        logger.info('Component initialized')


    def default_action(self):
        """ Apply the positions read to the IK targets of the joints """

        # Compute a rotation angle for the whole body, based on the
        # angle of the shoulders
        world_x_vector = mathutils.Vector([1, 0, 0])
        shoulders_vector = mathutils.Vector([
            (self._shoulder_empty_l.worldPosition[0] -
             self._shoulder_empty_r.worldPosition[0]),
            (self._shoulder_empty_l.worldPosition[1] -
             self._shoulder_empty_r.worldPosition[1]),
            (self._shoulder_empty_l.worldPosition[2] -
             self._shoulder_empty_r.worldPosition[2])  ])
        logger.debug ("Shoulder Vector: [%.4f, %.4f, %.4f]" % \
            (shoulders_vector[0], shoulders_vector[1], shoulders_vector[2]))

        try:
            # Measure the angle with respect to the X axis (in front of the man)
            body_rotation = shoulders_vector.angle(world_x_vector)
            # Correct the angle
            body_rotation -= pi/2
        except ValueError:
            # There will be an error if there is no user being tracked
            # by the Kinect
            body_rotation = 0.0
        logger.debug ("Angle with Y vector = %.4f" % body_rotation)

        # Apply the rotation to the toroso. The rest of the body should follow
        self._torso_empty.worldOrientation = [0.0, 0.0, body_rotation]

        # Put the ik targets in the correct positions
        self._set_object_position(self._head_empty.worldPosition,
                                  self.local_data['head_position'])
        self._set_object_position(self._neck_empty.worldPosition,
                                  self.local_data['neck_position'])
        self._set_object_position(self._torso_empty.worldPosition,
                                  self.local_data['torso_position'])
        self._set_object_position(self._hand_empty_l.worldPosition,
                                  self.local_data['left_hand_position'])
        self._set_object_position(self._hand_empty_r.worldPosition,
                                  self.local_data['right_hand_position'])
        self._set_object_position(self._elbow_empty_l.worldPosition,
                                  self.local_data['left_elbow_position'])
        self._set_object_position(self._elbow_empty_r.worldPosition,
                                  self.local_data['right_elbow_position'])
        self._set_object_position(self._shoulder_empty_l.worldPosition,
                                  self.local_data['left_shoulder_position'])
        self._set_object_position(self._shoulder_empty_r.worldPosition,
                                  self.local_data['right_shoulder_position'])
        self._set_object_position(self._hip_empty_l.worldPosition,
                                  self.local_data['left_hip_position'])
        self._set_object_position(self._hip_empty_r.worldPosition,
                                  self.local_data['right_hip_position'])
        self._set_object_position(self._knee_empty_l.worldPosition,
                                  self.local_data['left_knee_position'])
        self._set_object_position(self._knee_empty_r.worldPosition,
                                  self.local_data['right_knee_position'])
        self._set_object_position(self._foot_empty_l.worldPosition,
                                  self.local_data['left_foot_position'])
        self._set_object_position(self._foot_empty_r.worldPosition,
                                  self.local_data['right_foot_position'])

        #self._print_position("LEFT EMPTY", self._hand_empty_l.worldPosition)
        #self._print_position("RIGHT EMPTY", self._hand_empty_r.worldPosition)
        #self._print_position("HEAD", self._head_empty.worldPosition)
        #self._print_position("SHOULDER.L", \
        #                      self._shoulder_empty_l.worldPosition)
        #self._print_position("SHOULDER.R", \
        #                     self._shoulder_empty_r.worldPosition)

    def _set_object_position(self, joint, position):
        """ Add the position of the control point to the position of the
        Human robot
        """
        for i in range(3):
            joint[i] = self.human_position[i] + position[i]


    def _print_position(self, position_name, data):
        """ Format the data from the positions,
        in a way that the logger will like """
        text = "%s POS = [%.4f, %.4f, %.4f]" % \
               (position_name, data[0], data[1], data[2])
        logger.debug (text)

########NEW FILE########
__FILENAME__ = orientation
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.actuator
from morse.helpers.components import add_data
from morse.core import mathutils

class Orientation(morse.core.actuator.Actuator):
    """
    Motion controller changing immediately the robot orientation.

    This actuator reads the values of angles of rotation around the 3
    axis and applies them to the associated robot. This rotation is
    applied instantly (not in a realist way). Angles are expected in
    radians.
    """

    _name = "Orientation Actuator"
    _short_desc = "An actuator to change instantly robot orientation."

    add_data('yaw', 'Initial robot yaw', "float",
                    'Rotation of the robot around Z axis, in radian')
    add_data('pitch', 'Initial robot pitch', "float",
                      'Rotation of the robot around Y axis, in radian')
    add_data('roll', 'Initial robot roll', "float",
                      'Rotation of the robot around X axis, in radian')

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        self.orientation = self.bge_object.orientation.to_euler('XYZ')

        self.local_data['yaw'] = self.orientation.z
        self.local_data['pitch'] = self.orientation.y
        self.local_data['roll'] = self.orientation.x

        logger.info('Component initialized')

    def default_action(self):
        """ Change the parent robot orientation. """

        # New parent orientation
        orientation = mathutils.Euler([self.local_data['roll'],
                                       self.local_data['pitch'],
                                       self.local_data['yaw']])

        self.robot_parent.force_pose(None, orientation.to_matrix())

########NEW FILE########
__FILENAME__ = pa_10
import logging; logger = logging.getLogger("morse." + __name__)
import math
import morse.core.actuator
from morse.core import blenderapi
from morse.core import mathutils
from morse.helpers.morse_math import normalise_angle, rotation_direction
from morse.core.services import service
from morse.helpers.components import add_data, add_property

class PA10(morse.core.actuator.Actuator):
    """
    This actuator reads a list of angles for the segments of the
    Mitsubishi PA-10 arm and applies them as local rotations.

    Angles are expected in radians.
    """

    _name = "Mitsubishi PA-10"
    _short_desc = "PA-10 6-DOF robotic arm"

    add_property('_speed', 1.0, "Speed", "float", 'speed of each joint, in rad/s')
    add_property('_tolerance', math.radians(5), "Tolerance", "float", 'tolerance on the position, in radians')

    add_data('seg0', 0.0, "float", "first joint (base), in radians")
    add_data('seg1', 0.0, "float", "second joint, in radians")
    add_data('seg2', 0.0, "float", "third joint, in radians")
    add_data('seg3', 0.0, "float", "fourth joint, in radians")
    add_data('seg4', 0.0, "float", "fifth joint, in radians")
    add_data('seg5', 0.0, "float", "sixth joint (wrist), in radians")

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        # The axis along which the different segments rotate
        # Considering the rotation of the arm as installed in Jido
        self._dofs = ['z', 'y', 'y', 'z', 'y', 'z']

        self._segments = []
        segment = self.bge_object.children[0]
        for i in range(6):
            self._segments.append(segment)
            try:
                segment = segment.children[0]
            except IndexError:
                break
        logger.info ("Arm segment list: ", self._segments)

        # Get the references to the segment at the tip of the arm
        for child in self.bge_object.childrenRecursive:
            if 'PA10-6' in child.name:
                self._arm_tip = child
                break

        # Any other objects children of the Kuka arm are assumed
        #  to be mounted on the tip of the arm
        for child in self.bge_object.children:
            if not 'PA10' in child.name:
                child.setParent(self._arm_tip)

        # Variable to store the reference to the Sound actuator
        self._sound = None

        self._moving = False

        logger.info('Component initialized')
        #logger.setLevel(logging.DEBUG)


    def default_action(self):
        """ Apply rotation to the arm segments """
        # Get the reference to the Sound actuator
        if self._sound is None:
            logger.debug ("ACTIVATING THE SOUND ACTUATOR")
            contr = blenderapi.controller()
            self._sound = contr.actuators['Sound']
            contr.activate(self._sound)
            self._sound.stopSound()

        # Reset movement variables
        rx, ry, rz = 0.0, 0.0, 0.0

        # Scale the speeds to the time used by Blender
        try:
            rotation = self._speed / self.frequency
        # For the moment ignoring the division by zero
        # It happens apparently when the simulation starts
        except ZeroDivisionError:
            pass

        self._moving = False

        for i in range(6):
            key = ('seg%d' % i)
            target_angle = normalise_angle(self.local_data[key])

            # Get the next segment
            segment = self._segments[i]

            # Extract the angles
            rot_matrix = segment.localOrientation
            segment_matrix = mathutils.Matrix((rot_matrix[0], rot_matrix[1], rot_matrix[2]))
            segment_euler = segment_matrix.to_euler()

            # Use the corresponding direction for each rotation
            if self._dofs[i] == 'y':
                ry = rotation_direction(segment_euler[1], target_angle, self._tolerance, rotation)
                #logger.debug("PARAMETERS Y: %.4f, %.4f, %.4f, %.4f = %.4f" % (segment_euler[1], target_angle, _tolerance, rotation, ry))

            elif self._dofs[i] == 'z':
                rz = rotation_direction(segment_euler[2], target_angle, self._tolerance, rotation)
                #logger.debug("PARAMETERS Z: %.4f, %.4f, %.4f, %.4f = %.4f" % (segment_euler[2], target_angle, _tolerance, rotation, rz))

            logger.debug("ry = %.4f, rz = %.4f" % (ry, rz))

            # Give the movement instructions directly to the parent
            # The second parameter specifies a "local" movement
            segment.applyRotation([rx, ry, rz], True)

            if ry != 0.0 or rz != 0.0:
                self._moving = True

            # Reset the rotations for the next segment
            ry = rz = 0

        if self._moving:
            self._sound.startSound()
            logger.debug("STARTING SOUND")
        else:
            self._sound.stopSound()
            logger.debug("STOPPING SOUND")


    @service
    def set_rotation_array(self, seg0=0, seg1=0, seg2=0, seg3=0, seg4=0, seg5=0):
        """
        MORSE service to set the rotation for each of the arm joints.
        It receives an array containing the angle to give to each of
        the robot articulations. Angles are expected in radians. The length
        of the array should be equal to 6 or less, where any values not 
        specified will be considered as 0.0.

        :param seg0: 1st joint angle (base)
        :param seg1: 2nd joint angle
        :param seg2: 3rd joint angle
        :param seg3: 4th joint angle
        :param seg4: 5th joint angle
        :param seg5: 6th joint angle (wrist)
        """
        self.local_data['seg0'] = seg0
        self.local_data['seg1'] = seg1
        self.local_data['seg2'] = seg2
        self.local_data['seg3'] = seg3
        self.local_data['seg4'] = seg4
        self.local_data['seg5'] = seg5
        return None

########NEW FILE########
__FILENAME__ = ptu
import logging; logger = logging.getLogger("morse." + __name__)
from math import radians, sin, cos, asin, atan2, sqrt
from morse.core import blenderapi
from morse.core.actuator import Actuator
from morse.core import status
from morse.core.services import service
from morse.core.services import async_service
from morse.core.services import interruptible
from morse.helpers.morse_math import normalise_angle, rotation_direction
from morse.helpers.components import add_data, add_property

class PTU(Actuator):
    """
    This actuator reads the rotation values for pan and tilt, and applies
    them to the pan-tilt unit that must be set as children of this actuator.
    Angles are expected in radians.

    Unlike most other actuators, the Pan-Tilt unit is composed not only of an
    Empty object, but it also includes two meshes. These are the **PanBase** and
    the **TiltBase** that must also be imported when using this actuator.
    These meshes will rotate to produce the effect of a real Pan-Tilt unit.

    .. note:: When mounting a camera or stereo unit on top of the Pan-Tilt unit,
      make sure to parent the camera to the **PTU** object.

    This component can be configured to be operated manually as well as through data
    from a middleware. When using manual mode, the pan and tilt segments can be rotated
    using the following keys:

    -  :kbd:`Page Up` tilt up
    -  :kbd:`Page Down` tilt down
    -  :kbd:`Home` pan left
    -  :kbd:`Insert` pan right


    Code samples
    ------------

    - `Scenario with a PTU from the component unit-test
      <../../_modules/base/ptu_testing.html#PTUTest.setUpEnv>`_ :tag:`builder`
    - `Datastream usage, from the component unit-test
      <../../_modules/base/ptu_testing.html#PTUTest.test_datastream>`_ :tag:`pymorse` :tag:`datastream`
    - `Service usage, from the component unit-test
      <../../_modules/base/ptu_testing.html#PTUTest.test_set_service>`_ :tag:`pymorse` :tag:`service`
    """

    _name = "Pan-Tilt Unit"
    _short_desc = "A generic actuator to control pan-tilt supports"

    add_data('pan', 0.0, 'float', "Pan value, in radians")
    add_data('tilt', 0.0, 'float', "Tilt value, in radians")

    # Initialises a couple of properties. They can be changed by Builder scripts
    add_property('_speed', 1.0, 'Speed', 'float', "Rotation speed, in rad/s")
    add_property('_tolerance', radians(0.3), 'Tolerance', 'float')
    add_property('_is_manual_mode', False, 'Manual', 'boolean', 
                 "If true, the PTU can only move via the keyboard.")

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        Actuator.__init__(self, obj, parent)

        # Get the references (based on their name) to the childen object and
        # store a transformation3d structure for their position
        for child in self.bge_object.childrenRecursive:
            if 'PanBase' in child.name:
                self._pan_base = child
                self._pan_orientation = child.localOrientation
            elif 'TiltBase' in child.name:
                self._tilt_base = child
                self._tilt_orientation = child.localOrientation

        # Any other objects children of the PTU are assumed
        #  to be mounted on top of it
        for child in self.bge_object.children:
            if not 'PanBase' in child.name:
                child.setParent(self._tilt_base)

        # Check the bases were found, or exit with a message
        try:
            logger.info("Using pan base: '%s'" % self._pan_base.name)
            logger.info("Using tilt base: '%s'" % self._tilt_base.name)
        except AttributeError:
            logger.error("PTU is missing the pan and/or tilt bases. Module will not work!")
            return


        # Variables to store current angles
        self._current_pan = 0.0
        self._current_tilt = 0.0


        logger.info('Component initialized')


    @interruptible
    @async_service
    def set_pan_tilt(self, pan, tilt):
        """
        Move the platine to a given target position, represented by an
        angle couple.

        :param pan: Target pan angle, in radian
        :param tilt: Target tilt angle, in radian
        """

        logger.debug("Service 'set_pan_tilt' setting angles to %.4f, %.4f" % 
                                                                (pan, tilt))
        self.local_data['pan'] = pan
        self.local_data['tilt'] = tilt

    @service
    def get_pan_tilt(self):
        """
        Returns the current angles for the pan and tilt segments.

        :return: a couple of float, representing respectively the pan
                 and the tilt of the platine, in radian.
        """
        return self._current_pan, self._current_tilt

    @interruptible
    @async_service
    def look_at_point(self, x, y, z):
        """
        Move the platine to look towards a given point. The point is
        expected to be given in the world reference

        :param x: x coordinate of the target point (in meter)
        :param y: y coordinate of the target point (in meter)
        :param z: z coordinate of the target point (in meter)
        """
        self._aim_camera_at_point(x, y, z)

    @interruptible
    @async_service
    def look_at_object(self, obj_name):
        """
        Move the platine to look in the direction of the given object.

        :param obj_name: the (Blender) name of an object present in the scene
        """
        scene = blenderapi.scene()
        try:
            obj = scene.objects[obj_name]
        except KeyError:
            logger.error("Object '%s' not found in scene.\
                         Can not look at it" % obj_name)
            return False

        logger.debug ("Found object '%s'" % obj)
        self._aim_camera_at_point(obj.worldPosition[0], obj.worldPosition[1],
                                                        obj.worldPosition[2])


    def _aim_camera_at_point(self, x, y, z):
        """ Turn the unit to face a given point in space

        Receive the coordinates of the point to look at,
        given in world coordinates.

        Fill local_data with the corresponding pan and tilt to aim in that
        direction.

        Use the formulas at
        http://en.wikipedia.org/wiki/Spherical_coordinate_system#Cartesian_coordinates
        """
        goal_pos = [0, 0, 0]

        # Get the postitions with respect to the PTU
        goal_pos[0] = x - self.position_3d.x
        goal_pos[1] = y - self.position_3d.y
        goal_pos[2] = z - self.position_3d.z

        logger.debug("target  = [%.4f, %.4f, %.4f]" % (x, y, z))
        logger.debug("goal_pos = [%.4f, %.4f, %.4f]" % (goal_pos[0], goal_pos[1], goal_pos[2]))


        distance = sqrt(goal_pos[0] ** 2 + goal_pos[1] ** 2 + goal_pos[2] ** 2)
        theta = asin(goal_pos[2] / distance)
        phi = atan2(goal_pos[1], goal_pos[0])

        logger.debug("Theta = %.4f | Phi = %.4f" % (theta, phi))

        # Get the current rotation of the parent robot
        parent_pan = self.robot_parent.position_3d.euler.z
        parent_tilt = self.robot_parent.position_3d.euler.y

        # Adjust the rotation with respect to the parent
        self.local_data['pan'] = phi - parent_pan
        self.local_data['tilt'] = -theta + parent_tilt


    def default_action(self):
        """ Apply rotation to the platine unit """
        # Reset movement variables
        ry, rz = 0.0, 0.0

        if self._is_manual_mode:
            return

        try:
            normal_speed = self._speed / self.frequency
        # For the moment ignoring the division by zero
        # It happens apparently when the simulation starts
        except ZeroDivisionError:
            pass

        self._current_pan = self._pan_orientation.to_euler().z
        self._current_tilt = self._tilt_orientation.to_euler().y

        logger.debug("PTU: pan=%.4f, tilt=%.4f" % (self._current_pan,
                                                   self._current_tilt))

        # Get the angles in a range of -PI, PI
        target_pan = normalise_angle(self.local_data['pan'])
        target_tilt = normalise_angle(self.local_data['tilt'])
        logger.debug("Targets: pan=%.4f, tilt=%.4f" % (target_pan, target_tilt))

        if (abs(target_pan - self._current_pan) < self._tolerance and
            abs(target_tilt - self._current_tilt) < self._tolerance):
            self.completed(status.SUCCESS)

        # Determine the direction of the rotation, if any
        ry = rotation_direction(self._current_tilt, target_tilt,
                                self._tolerance, normal_speed)
        rz = rotation_direction(self._current_pan, target_pan,
                                self._tolerance, normal_speed)

        # Give the rotation instructions directly to the parent
        # The second parameter specifies a "local" movement
        self._pan_base.applyRotation([0.0, 0.0, rz], True)
        self._tilt_base.applyRotation([0.0, ry, 0.0], True)

########NEW FILE########
__FILENAME__ = rotorcraft_attitude
import logging; logger = logging.getLogger("morse." + __name__)

import morse.core.actuator
from math import degrees
from morse.core.mathutils import Vector
from morse.helpers.morse_math import normalise_angle
from morse.helpers.components import add_data, add_property

class RotorcraftAttitude(morse.core.actuator.Actuator):
    """
    This actuator reads roll,pitch, yaw rate and thrust commands as e.g.
    used to manually control a quadrotor via RC or by higher level
    control loops. This controller is meant to be used by quadrotors and
    similar flying robots with Rigid Body physics in blender. It is a
    simple PD-controller which applies torques to the robot to change
    and control the attitude. The yaw-rate input is integrated to yield
    an absolute yaw setpoint for the controller. Thrust is directly
    applied as force in z-direction of the robot.

    .. note:: Angle are given in aerospace North East Down convention (NED)
    """
    
    _name = "Rotorcraft attitude motion controller"
    _short_desc = "Motion controller using force and torque to achieve desired attitude."
    
    add_data('roll', 0.0, 'float', "roll angle in radians")
    add_data('pitch', 0.0, 'float', "pitch angle in radians")
    add_data('yaw', 0.0, 'float', "yaw angle in radians")
    add_data('thrust', 0.0, 'float', "collective thrust: 0 .. 1 (= 0 .. 100%)")

    add_property('_rp_pgain', 100.0, 'RollPitchPgain', 'float',
                 'proportional gain for roll/pitch control')
    add_property('_rp_dgain', 20.0, 'RollPitchDgain', 'float',
                 'derivative gain for roll/pitch control')
    add_property('_yaw_pgain', 16.0, 'YawPgain', 'float'
                 'proportional gain for yaw control')
    add_property('_yaw_dgain', 4.0, 'YawDgain', 'float',
                 'derivative gain for yaw control')
    add_property('_thrust_factor', 40.0, 'ThrustFactor', 'float',
                 'multiplication factor for applied thrust force in N')

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        #logger.setLevel(logging.DEBUG)

        # Make new reference to the robot velocities (mathutils.Vector)
        self.robot_w = self.robot_parent.bge_object.localAngularVelocity

        # get the robot inertia (list [ix, iy, iz])
        robot_inertia = self.robot_parent.bge_object.localInertia
        self.inertia = Vector(tuple(robot_inertia))
        logger.debug("robot inertia: (%.3f %.3f %.3f)" % tuple(self.inertia))

        # yaw setpoint in radians is just integrated from yaw rate input
        self.yaw_setpoint = 0.0

        self.prev_err = Vector((0.0, 0.0, 0.0))

        logger.info("Component initialized, runs at %.2f Hz ", self.frequency)


    def default_action(self):
        """ Run attitude controller and apply resulting force and torque to the parent robot. """
        # Get the the parent robot
        robot = self.robot_parent

        if self.local_data['thrust'] > 0:
            # yaw_rate and yaw_setpoint in NED
            self.yaw_setpoint += self.local_data['yaw'] / self.frequency
            # wrap angle
            self.yaw_setpoint = normalise_angle(self.yaw_setpoint)

            logger.debug("yaw setpoint: %.3f", degrees(self.yaw_setpoint))
            logger.debug("yaw current: %.3f   setpoint: %.3f", -degrees(self.position_3d.yaw), degrees(self.yaw_setpoint))

            # Compute errors
            #
            # e = att_sp - att = attitude error
            # current angles to horizontal plane in NED
            roll = self.position_3d.roll
            pitch = -self.position_3d.pitch
            yaw = -self.position_3d.yaw
            roll_err = self.local_data['roll'] - roll
            pitch_err = self.local_data['pitch'] - pitch
            # wrapped yaw error
            yaw_err = normalise_angle(self.yaw_setpoint - yaw)

            err = Vector((roll_err, pitch_err, yaw_err))
            logger.debug("attitude error: (% .3f % .3f % .3f)", degrees(err[0]), degrees(err[1]), degrees(err[2]))

            # derivative
            we = (err - self.prev_err) * self.frequency
            logger.debug("yaw rate error: %.3f", we[2])

            kp = Vector((self._rp_pgain, self._rp_pgain, self._yaw_pgain))
            kd = Vector((self._rp_dgain, self._rp_dgain, self._yaw_dgain))

            # torque = self.inertia * (kp * err + kd * we)
            t = []
            for i in range(3):
                t.append(self.inertia[i] * (kp[i] * err[i] + kd[i] * we[i]))
            # convert to blender frame and scale with thrust
            torque = Vector((t[0], -t[1], -t[2])) * self.local_data['thrust']
            logger.debug("applied torques: (% .3f % .3f % .3f)", torque[0], torque[1], torque[2])

            force = Vector((0.0, 0.0, self.local_data['thrust'] * self._thrust_factor))
            logger.debug("applied thrust force: %.3f", force[2])

            self.prev_err = err.copy()
        else:
            force = Vector((0.0, 0.0, 0.0))
            torque = Vector((0.0, 0.0, 0.0))

        # directly apply local forces and torques to the blender object of the parent robot
        robot.bge_object.applyForce(force, True)
        robot.bge_object.applyTorque(torque, True)

########NEW FILE########
__FILENAME__ = rotorcraft_waypoint
import logging; logger = logging.getLogger("morse." + __name__)

from morse.core import blenderapi
from morse.core.mathutils import Vector, Matrix
from math import radians, degrees, sin, cos, fabs, copysign
from morse.helpers.morse_math import normalise_angle
from morse.helpers.components import add_data, add_property

import morse.core.actuator
from morse.core.services import service, async_service, interruptible
from morse.core import status


class RotorcraftWaypoint(morse.core.actuator.Actuator):
    """
    This controller will receive a 3D destination point and heading
    and make the robot move to that location by changing attitude.
    This controller is meant for rotorcrafts like quadrotors.
    """

    _name = "Rotorcraft Waypoint motion controller"
    _short_desc = "Motion controller using force and torque to move a rotorcraft to a waypoint."

    add_data('x', 0.0, 'float', "waypoint x coordinate in meters")
    add_data('y', 0.0, 'float', "waypoint y coordinate in meters")
    add_data('z', 0.0, 'float', "waypoint z coordinate in meters")
    add_data('yaw', 0.0, 'float', "desired heading angle in radians")
    add_data('tolerance', 0.2, 'float', "waypoint tolerance in meters")

    add_property('_h_pgain', radians(6), 'HorizontalPgain', 'float',
                 'proportional gain for the outer horizontal position [xy] loop')
    add_property('_h_dgain', radians(8), 'HorizontalDgain', 'float',
                 'derivative gain for the outer horizontal position [xy] loop')
    add_property('_v_pgain', 8, 'VerticalPgain', 'float',
                 'proportional gain for the altitude loop')
    add_property('_v_dgain', 8, 'VerticalDgain', 'float',
                 'derivative gain for the altitude loop')
    add_property('_yaw_pgain', 12.0, 'YawPgain', 'float',
                 'proportional gain for yaw control of the inner loop')
    add_property('_yaw_dgain', 6.0, 'YawDgain', 'float',
                 'derivative gain for yaw control of the inner loop')
    add_property('_rp_pgain', 9.7, 'RollPitchPgain', 'float',
                 'proportional gain for roll/pitch control of the inner loop')
    add_property('_rp_dgain', 2, 'RollPitchDgain', 'float',
                 'derivative gain for roll/pitch control of the inner loop')
    add_property('_max_bank_angle', radians(30), 'MaxBankAngle', 'float',
                 'limit the maximum roll/pitch angle of the robot. This \
                  effectively limits the horizontal acceleration of the robot')
    add_property('_target', 'wp_target', 'Target', 'string',
                 'name of a blender object in the scene. When specified, \
                  this object will be placed at the coordinates given to \
                  the actuator, to indicate the expected destination of  \
                  the robot. Make sure that this object has NO_COLLISION')

    def __init__(self, obj, parent=None):

        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        logger.setLevel(logging.INFO)

        self._destination = self.robot_parent.bge_object.worldPosition
        self._wp_object = None

        # set desired position to current position
        self.local_data['x'] = self._destination[0]
        self.local_data['y'] = self._destination[1]
        self.local_data['z'] = self._destination[2]
        self.local_data['yaw'] = self.robot_parent.position_3d.yaw

        logger.info("inital wp: (%.3f %.3f %.3f)", self._destination[0], self._destination[0], self._destination[0])
        self._pos_initalized = False

        # Make new reference to the robot velocities (mathutils.Vector)
        self.robot_w = self.robot_parent.bge_object.localAngularVelocity

        # get the robot inertia (list [ix, iy, iz])
        robot_inertia = self.robot_parent.bge_object.localInertia
        self.inertia = Vector(tuple(robot_inertia))
        logger.info("robot inertia: (%.3f %.3f %.3f)" % tuple(self.inertia))

        self.nominal_thrust = self.robot_parent.bge_object.mass * 9.81
        logger.info("nominal thrust: %.3f", self.nominal_thrust)
        self._attitude_compensation_limit = cos(self._max_bank_angle) ** 2

        # current attitude setpoints in radians
        self.roll_setpoint = 0.0
        self.pitch_setpoint = 0.0
        self.yaw_setpoint = 0.0

        self.thrust = 0.0

        #previous attitude error
        self.prev_err = Vector((0.0, 0.0, 0.0))

        # Identify an object as the target of the motion
        try:
            wp_name = self._target
            if wp_name != '':
                scene = blenderapi.scene()
                self._wp_object = scene.objects[wp_name]
                logger.info("Using object '%s' to indicate motion target", wp_name)
        except KeyError as detail:
            self._wp_object = None
            logger.info("Not using a target object")

        logger.info("Component initialized, runs at %.2f Hz ", self.frequency)


    @service
    def setdest(self, x, y, z, yaw, tolerance=0.2):
        """
        Set a new waypoint and returns.

        The robot will try to go to this position, but the service 
        caller has no mean to know when the destination is reached
        or if it failed.

        In most cases, the asynchronous service 'goto' should be
        preferred.

        :param x: x coordinate of the waypoint (meter)
        :param y: y coordinate of the waypoint (meter)
        :param z: z coordinate of the waypoint (meter)
        :param yaw: orientation of the waypoint (radian)
        :param tolerance: distance considered to decide that the
                          waypoint has been reached (meter)

        :return: True (if the robot is already moving, the previous
                 target is replaced by the new one) except if the
                 destination is already reached. In this case, returns
                 False.
        """

        distance, gv, lv = self.robot_parent.bge_object.getVectTo([x, y, z])
        if distance - tolerance <= 0:
            logger.info("Robot already at destination (distance = {})."
                    " I do not set a new destination.".format(distance))
            return False

        self.local_data['x'] = x
        self.local_data['y'] = y
        self.local_data['z'] = z
        self.local_data['yaw'] = yaw
        self.local_data['tolerance'] = tolerance

        return True


    @interruptible
    @async_service
    def goto(self, x, y, z, yaw, tolerance=0.2):
        """ 
        Go to a new destination.

        The service returns when the destination is reached within
        the provided tolerance bounds.

        :param x: x coordinate of the waypoint (meter)
        :param y: y coordinate of the waypoint (meter)
        :param z: z coordinate of the waypoint (meter)
        :param yaw: orientation of the waypoint (radian)
        :param tolerance: distance considered to decide that the
                          waypoint has been reached (meter)
        """
        self.local_data['x'] = x
        self.local_data['y'] = y
        self.local_data['z'] = z
        self.local_data['yaw'] = yaw
        self.local_data['tolerance'] = tolerance


    @service
    def get_status(self):
        """ 
        Return the current status (Transit or Arrived)
        """
        return self.robot_parent.move_status


    def default_action(self):
        """ Move the object towards the destination. """
        robot = self.robot_parent

        if self._pos_initalized:
            self._destination = Vector((self.local_data['x'], self.local_data['y'], self.local_data['z']))
        else:
            self._destination = self.robot_parent.bge_object.worldPosition
            self.local_data['x'] = self._destination[0]
            self.local_data['y'] = self._destination[1]
            self.local_data['z'] = self._destination[2]
            self.local_data['yaw'] = self.robot_parent.position_3d.yaw
            self._pos_initalized = True

        #logger.debug("Robot %s move status: '%s'", robot.bge_object.name, robot.move_status)
        # Place the target marker where the robot should go
        if self._wp_object:
            self._wp_object.worldPosition = self._destination
            self._wp_object.worldOrientation = Matrix.Rotation(self.local_data['yaw'], 3, 'Z')

        # current angles to horizontal plane (not quite, but approx good enough)
        roll = self.position_3d.roll
        pitch = self.position_3d.pitch
        yaw = self.position_3d.yaw

        # current position and velocity of robot 
        pos_blender = robot.bge_object.worldPosition
        vel_blender = robot.bge_object.worldLinearVelocity

        pos_error = self._destination - pos_blender
        # zero velocity setpoint for now
        vel_error = -vel_blender

        logger.debug("pos current: (% .3f % .3f % .3f) setpoint: (% .3f % .3f % .3f)",
                     pos_blender[0], pos_blender[1], pos_blender[2],
                     self._destination[0], self._destination[1], self._destination[2])
        logger.debug("velocity: (% .3f % .3f % .3f)", vel_blender[0], vel_blender[1], vel_blender[2])

        # simple PD controller on horizontal position
        command_world_x = self._h_pgain * pos_error[0] + self._h_dgain * vel_error[0]
        command_world_y = self._h_pgain * pos_error[1] + self._h_dgain * vel_error[1]

        # setpoints in body frame
        self.roll_setpoint = sin(yaw) * command_world_x - cos(yaw) * command_world_y
        self.pitch_setpoint = cos(yaw) * command_world_x + sin(yaw) * command_world_y
        self.yaw_setpoint = self.local_data['yaw']

        # saturate max roll/pitch angles
        if fabs(self.roll_setpoint) > self._max_bank_angle:
            self.roll_setpoint = copysign(self._max_bank_angle, self.roll_setpoint)
        if fabs(self.pitch_setpoint) > self._max_bank_angle:
            self.pitch_setpoint = copysign(self._max_bank_angle, self.pitch_setpoint)

        # wrap yaw setpoint
        self.yaw_setpoint = normalise_angle(self.yaw_setpoint)

        logger.debug("roll  current: % 2.3f   setpoint: % 2.3f",
                     degrees(roll), degrees(self.roll_setpoint))
        logger.debug("pitch current: % 2.3f   setpoint: % 2.3f",
                     degrees(pitch), degrees(self.pitch_setpoint))
        logger.debug("yaw   current: % 2.3f   setpoint: % 2.3f",
                     degrees(yaw), degrees(self.yaw_setpoint))


        # compute thrust
        # nominal command to keep altitude (feed forward)
        thrust_attitude_compensation = max(self._attitude_compensation_limit, cos(roll) * cos(pitch))
        thrust_ff = self.nominal_thrust / thrust_attitude_compensation
        # feedback to correct altitude
        thrust_fb = self._v_pgain * pos_error[2] + self._v_dgain * vel_error[2]
        self.thrust = max(0, thrust_ff + thrust_fb)


        # Compute attitude errors
        #
        # e = att_sp - att = attitude error
        roll_err = normalise_angle(self.roll_setpoint - roll)
        pitch_err = normalise_angle(self.pitch_setpoint - pitch)
        yaw_err = normalise_angle(self.yaw_setpoint - yaw)

        err = Vector((roll_err, pitch_err, yaw_err))

        # derivative
        we = (err - self.prev_err) * self.frequency
        #we = mathutils.Vector((0.0, 0.0, 0.0))
        #logger.debug("yaw rate error: %.3f", we[2])

        kp = Vector((self._rp_pgain, self._rp_pgain, self._yaw_pgain))
        kd = Vector((self._rp_dgain, self._rp_dgain, self._yaw_dgain))

        #torque = self.inertia * (kp * err + kd * we)
        t = []
        for i in range(3):
            t.append(self.inertia[i] * (kp[i] * err[i] + kd[i] * we[i]))
        # scale with thrust
        torque = Vector((t[0], t[1], t[2])) * self.thrust / self.nominal_thrust
        logger.debug("applied torques: (% .3f % .3f % .3f)", torque[0], torque[1], torque[2])

        force = Vector((0.0, 0.0, self.thrust))
        logger.debug("applied thrust force: %.3f", force[2])

        self.prev_err = err.copy()

        # directly apply local forces and torques to the blender object of the parent robot
        robot.bge_object.applyForce(force, True)
        robot.bge_object.applyTorque(torque, True)


        # Vectors returned are already normalized
        wp_distance, global_vector, local_vector = self.bge_object.getVectTo(self._destination)

        #logger.debug("GOT DISTANCE: xyz: %.4f", wp_distance)

        # If the target has been reached, change the status
        if wp_distance - self.local_data['tolerance'] <= 0:
            robot.move_status = "Arrived"

            #Do we have a running request? if yes, notify the completion
            self.completed(status.SUCCESS, robot.move_status)

            #logger.debug("TARGET REACHED")
            #logger.debug("Robot %s move status: '%s'", robot.bge_object.name, robot.move_status)

        else:
            robot.move_status = "Transit"

########NEW FILE########
__FILENAME__ = sound
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
from morse.core.actuator import Actuator
from morse.helpers.components import add_data

class Sound(Actuator):
    """
    This actuator is a simple On/Off sound. Based on `Sound
    <http://wiki.blender.org/index.php/Doc:2.6/Manual/Game_Engine/Logic/Actuators/Sound>`_
    actuator.
    """
    _name = "Sound"
    _short_desc = "A simple sound actuator"

    add_data('mode', "stop", 'string', "mode, enum in ['play','pause','stop']")

    def __init__(self, obj, parent=None):
        logger.info("%s initialization" % obj.name)
        # Call the constructor of the parent class
        Actuator.__init__(self, obj, parent)

        self.local_data['mode'] = obj['mode']
        self._last_mode = None

        logger.info('Component initialized')

    def default_action(self):
        """ Apply ``play`` to this actuator. """
        # get the Blender Logic Controller
        contr = blenderapi.controller()
        # http://www.blender.org/documentation/blender_python_api_2_65_release/bge.types.html#bge.types.KX_SoundActuator
        if self.local_data['mode'] == self._last_mode:
            return
        act = contr.actuators[-1]
        contr.activate(act) # enables 3D effect (!)
        if self.local_data['mode'] == 'play':
            act.startSound()
        elif self.local_data['mode'] == 'pause':
            act.pauseSound()
        elif self.local_data['mode'] == 'stop':
            act.stopSound()
        # new last mode
        self._last_mode = self.local_data['mode']


########NEW FILE########
__FILENAME__ = stabilized_quadrotor
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import service
import morse.core.actuator
from morse.core import mathutils
from morse.helpers.filt2 import Filt2
from morse.helpers.components import add_data

class StabilizedQuadrotor(morse.core.actuator.Actuator):
    """ 

    This actuator controls a stabilized quadrotor using a linear model.
    Basically, it reads a command (phi, theta, psi, h), and computes,
    using a second order filter the speed and the position of the robot.
    The quadrotor must not have Rigid Body physics.

    .. note::
        Coordinates are given with respect to the origin of Blender's
        coordinate axis.

    .. note::
        The actuator does not consider friction force. Setting theta_c
        or phi_c to 0 leads to a constant speed on axis x or y.
    """

    _name = "Stabilized Flight for quadrotor"
    _short_desc = "Motion controller using linear model of a stabilized \
                   quadrotor"

    add_data('theta_c', 0.0, "float",
                    'Commands the pitch of the quadrotor. It is directly \
                     related to the quadrotor acceleration on the x axis.')
    add_data('phi_c', 0.0, "float",
                    'Commands the roll of the quadrotor. It is directly \
                     related to the quadrotor acceleration on the y axis.')
    add_data('psi_c', 0.0, "float",
                    'Commands the yaw of the quadrotor.')
    add_data('h_c', 0.0, "float",
            'Commands the z of the quadrotor.')


    def __init__(self, obj, parent=None):
        logger.info('%s initialization' %obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        # Env Variables
        self.v = [0.0, 0.0, 0.0]
        self.acc = [0.0, 0.0, 0.0]
        self.f_phi = Filt2(10.0, 0.7)
        self.f_theta = Filt2(10.0, 0.7)
        self.f_psi = Filt2(10.0, 0.7)
        self.f_h = Filt2(3.0, 0.5)

        logger.info('Component initialized')

    @service
    def set_cons(self, phi, theta, psi, h):
        """
        Specify a consign for the robot. It has the same effect that
        writing the corresponding constraint in the datastream.

        :param phi: commands the roll of the quadrotor
        :param theta: command the pitch of the quadrotor
        :param psi: command the yaw of the quadrotor
        :param h: the expected height for the quadrotor.
        """
        self.local_data['phi_c'] = phi
        self.local_data['theta_c'] = theta
        self.local_data['psi_c'] = self.local_data['psi_c'] + psi
        self.local_data['h_c'] = h

    @service
    def stop(self):
        """
        Stop the robot. It basically means that speed on the different
        axis is set to 0. Moreover, the different filters are reset.
        """
        self.v = [0.0, 0.0, 0.0]
        self.f_phi.init()
        self.f_theta.init()
        self.f_psi.init()

    def default_action(self):
        """ Apply ... to the parent robot. """
        # Ticks
        dt = 1.0 / self.frequency

        # Compute height and Euler Angles
        self.f_phi.simulate(self.local_data['phi_c'], dt)
        self.f_theta.simulate(self.local_data['theta_c'], dt)
        self.f_psi.simulate(self.f_psi.x[0]-self.local_data['psi_c'], dt)
        self.f_h.simulate(self.local_data['h_c'], dt)
        rot = mathutils.Euler([self.f_phi.x[0], self.f_theta.x[0],
                                                self.f_psi.x[0]])

        # Get the parent
        parent = self.robot_parent.bge_object

        # Compute acceleration
        # get previous height and vert. velocity
        main_to_origin = self.robot_parent.position_3d
        main_to_origin.update(parent)
        h =  main_to_origin.z

        # assume velocity
        acc_b = mathutils.Vector([0.0, 0.0,
                                  10.0 + 9.0 * (self.local_data['h_c'] - h) -
                                  2.0 * 0.7 * 3.0 * self.v[2]])
        acc_i = mathutils.Vector( rot.to_matrix()*acc_b )
        self.v[0] += dt * acc_i[0]
        self.v[1] += dt * acc_i[1]
        self.v[2] += dt * (acc_i[2] - 10.0)

        #Change the parent position
        prev_pos = parent.localPosition
        parent.localPosition = mathutils.Vector(prev_pos +
                dt * mathutils.Vector([self.v[0],self.v[1],self.v[2]]))
        #Change the parent orientation
        parent.orientation = rot.to_matrix()


########NEW FILE########
__FILENAME__ = steer_force
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.actuator
from morse.helpers.components import add_data

class SteerForce(morse.core.actuator.Actuator):
    """ 
    This actuator reads the values of the steering angle, the engine
    power and the braking force to drive a car like vehicle.  It is
    meant to work with robots implementing the `Blender Vehicle Wrapper
    <http://www.tutorialsforblender3d.com/Game_Engine/Vehicle/Vehicle_1.html>`_,
    such as the :doc:`Hummer robot <../robots/hummer>`.

    .. note:: 
        Robots implementing the Vehicle Wrapper must be pointing towards
        their local Y axis.  This means the robots will be oriented
        differently with respect to all other MORSE components.
    """

    _name = "Steer/Force Actuator"
    _short_desc = "Motion controller using engine force and steer angle speeds"

    add_data('steer', 0.0, "float",
                    'Angle of the wheels with respect to the vehicle \
                     (in radian)')
    add_data('force', 0.0, "float",
                      'The force applied to the traction wheels. \
                       A negative force will make the vehicle move forward. \
                       A positive force will make it go backwards.')
    add_data('brake', 0.0, "float",
                      'The force applied to the brake. \
                      It opposes to the force.')

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        logger.info('Component initialized')


    def default_action(self):
        """ Apply (steer, force) to the parent robot. """
        # Get the Blender object of the parent robot
        vehicle = self.robot_parent.vehicle

        # Update the steering value for these wheels:
        # The number at the end represents the wheel 'number' in the 
        # order they were created when initializing the robot.
        # Front wheels #0 and #1.
        # Rear wheels #2 and #3.
        vehicle.setSteeringValue(self.local_data['steer'], 0)
        vehicle.setSteeringValue(self.local_data['steer'], 1)

        # Update the Force (speed) for these wheels:
        vehicle.applyEngineForce(self.local_data['force'] * .4, 0)
        vehicle.applyEngineForce(self.local_data['force'] * .4, 1)
        vehicle.applyEngineForce(self.local_data['force'] * .4, 2)
        vehicle.applyEngineForce(self.local_data['force'] * .4, 3)

        # Brakes:
        # Applies the braking force to each wheel listed:
        # ['brakes'] = the game property value for the car labeled 'brakes'
        # Default value is 0:
        vehicle.applyBraking(self.local_data['brake'] * .1,  0)
        vehicle.applyBraking(self.local_data['brake'] * .1,  1)
        vehicle.applyBraking(self.local_data['brake'] * 1.3, 2)
        vehicle.applyBraking(self.local_data['brake'] * 1.3, 3)

########NEW FILE########
__FILENAME__ = teleport
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.actuator
from morse.core.services import service
from morse.core import mathutils
from morse.helpers.components import add_data
from morse.helpers.transformation import Transformation3d

class Teleport(morse.core.actuator.Actuator):
    """ 
    This actuator teleports the robot to the absolute position and
    orientation with respect to the origin of the Blender coordinate
    reference. Angles are expected in radians.

    .. note::
        Coordinates are given with respect to the origin of
        Blender's coordinate axis.
    """

    _name = "Teleport"
    _short_desc = "Motion controller which changes instantly robot pose \
                   (position and orientation)"

    add_data('x', 'initial robot X position', "float",
              "X coordinate of the destination, in meter")
    add_data('y', 'initial robot Y position', "float",
              "Y coordinate of the destination, in meter")
    add_data('z', 'initial robot Z position', "float",
             "Z coordinate of the destination, in meter")
    add_data('yaw', 'Initial robot yaw', "float",
             'Rotation of the robot around Z axis, in radian')
    add_data('pitch', 'Initial robot pitch', "float",
             'Rotation of the robot around Y axis, in radian')
    add_data('roll', 'Initial robot roll', "float",
             'Rotation of the robot around X axis, in radian')

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        pose3d = self.position_3d

        self.local_data['x'] = pose3d.x
        self.local_data['y'] = pose3d.y
        self.local_data['z'] = pose3d.z
        self.local_data['roll'] = pose3d.roll
        self.local_data['pitch'] = pose3d.pitch
        self.local_data['yaw'] = pose3d.yaw

        self.actuator2robot = self.position_3d.transformation3d_with(self.robot_parent.position_3d)

        logger.info('Component initialized')

    @service
    def translate(self, x, y = 0.0, z = 0.0):
        """
        Translate the actuator owner by the given (x,y,z) vector.

        This is a **relative** displacement.

        :param x: X translation, in meter
        :param y: (default: 0.0) Y translation, in meter
        :param z: (default: 0.0) Z translation, in meter
        """
        self.local_data['x'] += x
        self.local_data['y'] += y
        self.local_data['z'] += z

    @service
    def rotate(self, roll, pitch = 0.0, yaw=0.0):
        """
        Rotates the actuator owner by the given (roll,pitch,yaw).

        This is a **relative** rotation.

        :param roll: roll rotation, in radians
        :param pitch: (default: 0.0) pitch rotation, in radians
        :param yaw: (default: 0.0) yaw rotation, in radians
        """
        self.local_data['roll'] += roll
        self.local_data['pitch'] += pitch
        self.local_data['yaw'] += yaw


    def default_action(self):
        """ Change the parent robot pose. """

        # New parent position
        position = mathutils.Vector((self.local_data['x'],
                                     self.local_data['y'],
                                     self.local_data['z']))

        # New parent orientation
        orientation = mathutils.Euler([self.local_data['roll'],
                                       self.local_data['pitch'],
                                       self.local_data['yaw']])

        world2actuator = Transformation3d(None)
        world2actuator.translation = position
        world2actuator.rotation = orientation

        (loc, rot, _) = (world2actuator.matrix * self.actuator2robot.matrix).decompose()

        self.robot_parent.force_pose(loc, rot)

########NEW FILE########
__FILENAME__ = v_omega
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import service
import morse.core.actuator
from morse.helpers.components import add_data, add_property

class MotionVW(morse.core.actuator.Actuator):
    """ 
    This actuator reads the values of linear and angular speed and
    applies them to the robot as direct translation. The speeds provided
    are internally adjusted to the Blender time measure.
    """
    _name = 'Linear and angular speed (V, W) actuator'
    _short_desc = 'Motion controller using linear and angular speeds'

    add_data('v', 0.0, 'float',
             'linear velocity in x direction (forward movement) (m/s)')
    add_data('w', 0.0, 'float', 'angular velocity (rad/s)')

    add_property('_type', 'Velocity', 'ControlType', 'string',
                 "Kind of control, can be one of ['Velocity', 'Position']")

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        logger.info('Component initialized')


    @service
    def set_speed(self, v, w):
        """
        Modifies v and w according to the parameters

        :param v: desired linear velocity (meter by second)
        :param w: desired angular velocity (radian by second)
        """
        self.local_data['v'] = v
        self.local_data['w'] = w

    @service
    def stop(self):
        """
        Stop the robot

        Internally, it sets (v, w) to (0.0, 0.0)
        """
        self.local_data['v'] = 0.0
        self.local_data['w'] = 0.0

    def default_action(self):
        """ Apply (v, w) to the parent robot. """

        # Reset movement variables
        vx, vy, vz = 0.0, 0.0, 0.0
        rx, ry, rz = 0.0, 0.0, 0.0

        # Scale the speeds to the time used by Blender
        try:
            if self._type == 'Position':
                vx = self.local_data['v'] / self.frequency
                rz = self.local_data['w'] / self.frequency
            elif self._type == 'Velocity':
                vx = self.local_data['v']
                rz = self.local_data['w']
        # For the moment ignoring the division by zero
        # It happens apparently when the simulation starts
        except ZeroDivisionError:
            pass

        self.robot_parent.apply_speed(self._type, [vx, vy, vz], [rx, ry, rz])

########NEW FILE########
__FILENAME__ = v_omega_diff_drive
import logging

logger = logging.getLogger("morse." + __name__)
from morse.core.services import service
import morse.core.actuator
from morse.helpers.components import add_data


class MotionVWDiff(morse.core.actuator.Actuator):
    """
    This actuator reads the values of linear and angular speed and
    applies them to the robot as speeds for the wheels. It only works
    with robots of the type ``WheeledRobot``, such as the :doc:`Segway
    RMP 400 <../robots/segwayrmp400>` and the :doc:`Pioneer 3-DX
    <../robots/pioneer3dx>`.  The movement of the robot is more
    realistic, but also depends on more factors, such as the friction
    between the wheels and the surface.

    The speeds for the left and right wheels are calculated as:

            left_speed = (v - e w) / R
            right_speed = (v + e w) / R

    where:

        - **v** is the linear velocity given as parameter
        - **w** is the angular velocity given as parameter
        - **e** is half of the distance between the left and
        right wheels
        - **R** is the radius of the wheels

    """

    _name = 'Differential Driver Actuator: \
            Linear and angular speed (V, W) actuator'

    add_data('v', 0.0, 'float',
            'linear velocity in x direction (forward movement) (m/s)')
    add_data('w', 0.0, 'float', 'angular velocity (rad/s)')

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        self.local_data['v'] = 0.0
        self.local_data['w'] = 0.0

        logger.info('Component initialized')

    @service
    def set_speed(self, v, w):
        """
        Modifies v and w according to the parameters

        :param v: desired linear velocity (meter by second)
        :param w: desired angular velocity (radian by second)
        """
        self.local_data['v'] = v
        self.local_data['w'] = w

    @service
    def stop(self):
        """
        Stop the robot

        Internally, it sets (v, w) to (0.0, 0.0)
        """
        self.local_data['v'] = 0.0
        self.local_data['w'] = 0.0

    def default_action(self):
        """ Apply (v, w) to the parent robot. """

        self.robot_parent.apply_vw_wheels(self.local_data['v'],
                                          self.local_data['w'])


########NEW FILE########
__FILENAME__ = waypoint
######################################################
#
#    waypoint.py        Blender 2.5x
#
#    A script to control the movement of a robot given
#    a destination point in space.
#    The movement includes a basic obstacle avoidance
#    system, based on the demo by Sebastian Korczak
#               admin@myinventions.pl
#
#
#    Gilberto Echeverria
#    27 / 01 / 2011
#
######################################################


import logging; logger = logging.getLogger("morse." + __name__)
import math
from morse.core import status, blenderapi, mathutils
import morse.core.actuator
from morse.core.services import service, async_service, interruptible
from morse.helpers.components import add_data, add_property

class Waypoint(morse.core.actuator.Actuator):
    """
    This actuator reads the coordinates of a destination point, and moves the robot
    towards the given point, with the robot restricted to moving only forward,
    turning around its Z axis, and possibly going up and down.
    This controller is meant to be used mainly by non-holonomic robots.

    While a robot is moving towards a given waypoint, a property of the
    **Robot** will be changed in indicate the status of the robot.
    The ``movement_status`` property will take one of these values: **Stop**,
    **Transit** or **Arrived**.

    The movement speed of the robot is internally adjusted to the Blender time
    measure, following the formula: ``blender_speed = given_speed * tics``, where
    **tics** is the number of times the code gets executed per second.
    The default value in Blender is ``tics = 60``.

    This actuator also implements a simple obstacle avoidance mechanism. The blend
    file contains the **Motion_Controller** empty, as well as two additional Empty
    objects: **Radar.L** and **Radar.R**.
    These detect nearby objects to the left or right of the robot, and will
    instruct the robot to turn in the opposite direction of the obstacle.
    If the radar objects are not present, the controller will not have any obstacle
    avoidance, and the robot can get blocked by any object between it and the
    target.

    .. note:: For objects to be detectable by the radars, they must have the
        following settings in the **Physics Properties** panel:

        - **Actor** must be checked
        - **Collision Bounds** must be checked

        This will work even for Static objects
    """
    _name = "Waypoint"

    add_property('_obstacle_avoidance', True, 'ObstacleAvoidance', 'bool', "if "
            "true (default), will activate obstacle avoidance if the radars are"
            " present")
    add_property('_free_z', False, 'FreeZ', 'bool', "if false "
            "(default), the robot is only controlled on 'X' and heading; if "
            "true, 'Z' is also controlled (for aerial or submarine robots)")
    add_property('_angle_tolerance', math.radians(10), 'AngleTolerance',
                 'float',
                 "Tolerance in radian regarding the final heading of the robot")
    add_property('_speed', 1.0, 'Speed', 'float',
                 "movement speed for the robot, given in m/s")
    add_property('_target', "", 'Target', 'string',
            'name of a blender object in the scene. When specified, this \
            object will be placed at the coordinates given to the \
            actuator, to indicate the expected destination of the \
            robot')
    add_property('_ignore', [], 'Ignore', 'string',
            "List of property names. If the object detected by the \
            radars has any of these properties defined, it will be \
            ignored by the obstacle avoidance, and will not make the \
            robot change its trajectory. Useful when trying to move \
            close to an object of a certain kind")
    add_property('_type', 'Velocity', 'ControlType', 'string',
                 "Kind of control, can be one of ['Velocity', 'Position']")

    add_data('x', 0.0, "float",
              "X coordinate of the destination, in world frame, in meter")
    add_data('y', 0.0, "float",
              "Y coordinate of the destination, in world frame, in meter")
    add_data('z', 0.0, "float",
              "Z coordinate of the destination, in world frame, in meter")
    add_data('tolerance', 0.5, "float",
             "Tolerance, in meter, to consider the destination as reached.")
    add_data('speed', 1.0, "float",
             "If the property 'Speed' is set, use this speed as initial value.")

    def __init__(self, obj, parent=None):

        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        # Direction of the global vectors
        self.world_x_vector = mathutils.Vector([1, 0, 0])
        self.world_y_vector = mathutils.Vector([0, 1, 0])
        self.world_z_vector = mathutils.Vector([0, 0, 1])

        self._destination = self.bge_object.position
        self._projection = self.bge_object.position
        self._wp_object = None
        self._collisions = False

        # Variable to store current speed. Used for the stop/resume services
        self._previous_speed = 0

        self.local_data['x'] = self._destination[0]
        self.local_data['y'] = self._destination[1]
        self.local_data['z'] = self._destination[2]
        # Waypoint tolerance (in meters)
        self.local_data['tolerance'] = 0.5
        self.local_data['speed'] = self._speed

        # Identify an object as the target of the motion
        try:
            wp_name = self.bge_object['Target']
            if wp_name != '':
                scene = blenderapi.scene()
                self._wp_object = scene.objects[wp_name]
                logger.info("Using object '%s' to indicate motion target" %
                            wp_name)
        except KeyError:
            self._wp_object = None

        # Identify the collision detectors for the sides
        if self._obstacle_avoidance:
            for child in self.bge_object.children:
                if "Radar.R" in child.name:
                    self._radar_r = child
                if "Radar.L" in child.name:
                    self._radar_l = child
            try:
                logger.info("Radar Right is '%s'" % self._radar_r.name)
                logger.info("Radar Left  is '%s'" % self._radar_l.name)
                self._collisions = True
            except AttributeError:
                logger.warning("No radars found attached to the waypoint \
                               actuator.There will be no obstacle avoidance")

            # Convert a string listing the properties to avoid into a list
            # Objects with any of these properties will be ignored
            #  when doing obstacle avoidance
            try:
                props = self.bge_object['Ignore'].split(',')
                self.bge_object['Ignore'] = props
            except KeyError:
                self.bge_object['Ignore'] = []

        logger.info('Component initialized')


    @service
    def setdest(self, x, y, z, tolerance=0.5, speed=1.0):
        """
        Set a new waypoint and returns.

        The robot will try to go to this position, but the service
        caller has no mean to know when the destination is reached
        or if it failed.

        In most cases, the asynchronous service 'goto' should be
        prefered.

        :param x: x coordinate of the destination, in world frame, in meter
        :param y: y coordinate of the destination, in world frame, in meter
        :param z: z coordinate of the destination, in world frame, in meter
        :param tolerance: tolerance, in meter, to consider the
                          destination as reached. Optional (default: 0.5 m).
        :param speed: speed to join the goal. Optional (default 1m/s)

        :return: Returns always True (if the robot is already moving, the
                 previous target is replaced by the new one) except if
                 the destination is already reached. In this case,
                 returns ``False``.
        """

        distance, _, _ = self.bge_object.getVectTo([x, y, z])
        if distance - tolerance <= 0:
            logger.info("Robot already at destination (distance = {})."
                    " I do not set a new destination.".format(distance))
            return False

        self.local_data['x'] = x
        self.local_data['y'] = y
        self.local_data['z'] = z
        self.local_data['tolerance'] = tolerance
        self.local_data['speed'] = speed

        return True


    @interruptible
    @async_service
    def goto(self, x, y, z, tolerance=0.5, speed=1.0):
        """ 
        This method can be used to give a one time instruction to the
        actuator.  When the robot reaches the destination, it will send
        a reply, indicating that the new status of the robot is "Stop".

        :param x: x coordinate of the destination, in world frame, in meter
        :param y: y coordinate of the destination, in world frame, in meter
        :param z: z coordinate of the destination, in world frame, in meter
        :param tolerance: tolerance, in meter, to consider the
                          destination as reached. Optional (default: 0.5 m).
        :param speed: speed to join the goal. Optional (default 1m/s)
        """
        self.local_data['x'] = x
        self.local_data['y'] = y
        self.local_data['z'] = z
        self.local_data['tolerance'] = tolerance
        self.local_data['speed'] = speed

    def interrupt(self):
        self.local_data['x'] = self.position_3d.x
        self.local_data['y'] = self.position_3d.y
        self.local_data['z'] = self.position_3d.z
        self.local_data['speed'] = 0

        morse.core.actuator.Actuator.interrupt(self)

    @service
    #@async_service
    def stop(self):
        """
        This method will instruct the robot to set its speed to 0.0, and
        reply immediately. If a **goto** request is ongoing, it will
        remain "pending", as the current destination is not changed.
        """
        #self.local_data['x'] = self.bge_object.worldPosition[0]
        #self.local_data['y'] = self.bge_object.worldPosition[1]
        #self.local_data['z'] = self.bge_object.worldPosition[2]
        #self.local_data['tolerance'] = 0.5
        self._previous_speed = self.local_data['speed']
        self.local_data['speed'] = 0

        # Set the status of the robot
        self.robot_parent.move_status = "Stop"

        return self.robot_parent.move_status

    @service
    def resume(self):
        """
        Restores the speed to the same value as before the last call to
        the **stop** service. The robot will continue to the last
        waypoint specified.
        """
        self.local_data['speed'] = self._previous_speed
        self._previous_speed = 0

        # Set the status of the robot
        self.robot_parent.move_status = "Transit"

        return self.robot_parent.move_status


    @service
    def get_status(self):
        """
        Ask the actuator to send a message indicating the current
        movement status of the parent robot. There are three possible
        states: **Transit**, **Arrived** and **Stop**.
        """
        return self.robot_parent.move_status


    def default_action(self):
        """ Move the object towards the destination. """
        parent = self.robot_parent
        speed = self.local_data['speed']
        v = 0
        rz = 0

        self._destination = [ self.local_data['x'],
                              self.local_data['y'],
                              self.local_data['z'] ]
        self._projection = [ self.local_data['x'],
                             self.local_data['y'],
                             self.bge_object.worldPosition[2] ]

        logger.debug("Robot {0} move status: '{1}'".format(
                     parent.bge_object.name, parent.move_status))
        # Place the target marker where the robot should go
        if self._wp_object:
            self._wp_object.position = self._destination

        # Vectors returned are already normalized
        projection_distance, projection_vector, local_vector = \
                self.bge_object.getVectTo(self._projection)
        true_distance, global_vector, local_vector = \
            self.bge_object.getVectTo(self._destination)
        # Convert to the Blender Vector object
        global_vector = mathutils.Vector(global_vector)
        projection_vector = mathutils.Vector(projection_vector)
        # if Z is not free, distance is the projection distance
        if self._free_z:
            distance = true_distance
        else:
            distance = projection_distance

        logger.debug("GOT DISTANCE: xy: %.4f ; xyz: %.4f" %
                     (projection_distance, true_distance))
        logger.debug("Global vector: %.4f, %.4f, %.4f" %
                     (global_vector[0], global_vector[1], global_vector[2]))
        logger.debug("Local vector: %.4f, %.4f, %.4f" %
                     (local_vector[0], local_vector[1], local_vector[2]))
        logger.debug("Projection vector: %.4f, %.4f, %.4f" %
             (projection_vector[0], projection_vector[1], projection_vector[2]))

        # If the target has been reached, change the status
        if distance - self.local_data['tolerance'] <= 0:
            parent.move_status = "Arrived"

            #Do we have a running request? if yes, notify the completion
            self.completed(status.SUCCESS, parent.move_status)

            logger.debug("TARGET REACHED")
            logger.debug("Robot {0} move status: '{1}'".format(
                          parent.bge_object.name, parent.move_status))

        else:
            # Do nothing if the speed is zero
            if speed == 0:
                return

            parent.move_status = "Transit"

            angle_diff = 0
            rotation_direction = 0

            # If the projected distance is not null: else computing the
            # target angle is not possible!
            if projection_distance - self.local_data['tolerance'] / 2 > 0:
                ### Get the angle of the robot ###
                robot_angle = parent.position_3d.yaw

                ### Get the angle to the target ###
                target_angle = projection_vector.angle(self.world_x_vector)

                # Correct the direction of the turn according to the angles
                dot = projection_vector.dot(self.world_y_vector)
                logger.debug("Vector dot product = %.2f" % dot)
                if dot < 0:
                    target_angle *= -1

                ### Get the angle that the robot must turn ###
                if target_angle < robot_angle:
                    angle_diff = robot_angle - target_angle
                    rotation_direction = -1
                else:
                    angle_diff = target_angle - robot_angle
                    rotation_direction = 1

                # Make a correction when the angles change signs
                if angle_diff > math.pi:
                    angle_diff = (2 * math.pi) - angle_diff
                    rotation_direction *= -1

                logger.debug("Angles: R=%.4f, T=%.4f Diff=%.4f Direction = %d" %
                    (robot_angle, target_angle, angle_diff, rotation_direction))

            try:
                dt = 1 / self.frequency
                if distance < speed * dt:
                    v = distance  / dt
                else:
                    v = speed

                if abs(angle_diff) < speed * dt:
                    rotation_speed = angle_diff / dt / 2.0
                else:
                    rotation_speed = speed / 2.0

                # Compute the speeds
                if self._type == 'Position':
                    v /= self.frequency
                    rotation_speed /= self.frequency
            # For the moment ignoring the division by zero
            # It happens apparently when the simulation starts
            except ZeroDivisionError:
                pass

            # Allow the robot to rotate in place if the waypoing is
            #  to the side or behind the robot
            if angle_diff >= math.pi/3.0:
                logger.debug("Turning on the spot!!!")
                v = 0

            # Collision avoidance using the Blender radar sensor
            if self._collisions and v != 0 and self._radar_r['Rcollision']:
                # No obstacle avoidance when the waypoint is near
                if distance + self.local_data['tolerance'] > \
                   self._radar_r.sensors["Radar"].distance:
                    # Ignore obstacles with the properties specified
                    ignore = False
                    for prop in self.bge_object['Ignore']:
                        if prop in self._radar_r.sensors["Radar"].hitObject:
                            ignore = True
                            logger.debug("Ignoring object '%s' "
                                         "with property '%s'" %
                               (self._radar_r.sensors["Radar"].hitObject, prop))
                            break
                    if not ignore:
                        rz = rotation_speed
                        logger.debug("Obstacle detected to the RIGHT, "
                                     "turning LEFT")
            elif self._collisions and v != 0 and self._radar_l['Lcollision']:
                # No obstacle avoidance when the waypoint is near
                if distance + self.local_data['tolerance'] > \
                    self._radar_l.sensors["Radar"].distance:
                    # Ignore obstacles with the properties specified
                    ignore = False
                    for prop in self.bge_object['Ignore']:
                        if prop in self._radar_l.sensors["Radar"].hitObject:
                            ignore = True
                            logger.debug("Ignoring object '%s' "
                                         "with property '%s'" % \
                              (self._radar_l.sensors["Radar"].hitObject, prop))
                            break
                    if not ignore:
                        rz = - rotation_speed
                        logger.debug("Obstacle detected to the LEFT, "
                                     "turning RIGHT")
            # Test if the orientation of the robot is within tolerance
            elif -self._angle_tolerance < angle_diff < self._angle_tolerance:
                rz = 0
            # If not, rotate the robot in the corresponding direction
            else:
                rz = rotation_speed * rotation_direction

            if self._free_z:
                vx = math.fabs(v * local_vector.dot(self.world_x_vector))
                vz = v * local_vector.dot(self.world_z_vector)
            else:
                vx = v
                vz = 0
            logger.debug("Applying vx = %.4f, vz = %.4f, rz = %.4f (v = %.4f)" %
                        (vx, vz, rz, v))

            self.robot_parent.apply_speed(self._type, [vx, 0, vz], [0, 0, rz])

########NEW FILE########
__FILENAME__ = xy_omega
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.actuator
from morse.helpers.components import add_data, add_property

class MotionXYW(morse.core.actuator.Actuator):
    """
    This actuator reads the values of forwards movement x, sidewards
    movement y and angular speed w and applies them to the robot as
    direct translation. This controller is supposed to be used with
    robots that allow for sidewards movements.
    """

    _name = 'Linear and angular speed (Vx, Vy, W) actuator'

    _short_desc = 'Motion controller using linear and angular speeds'

    add_data('x', 0.0, 'float',
             'linear velocity in x direction (forward movement) (m/s)')
    add_data('y', 0.0, 'float',
             'linear velocity in y direction (sidewards movement) (m/s)')
    add_data('w', 0.0, 'float', 'angular velocity (rad/s)')

    add_property('_type', 'Velocity', 'ControlType', 'string',
                 "Kind of control, can be one of ['Velocity', 'Position']")

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.actuator.Actuator.__init__(self, obj, parent)

        logger.info('Component initialized')



    def default_action(self):
        """ Apply (x, y, w) to the parent robot. """

        # Reset movement variables
        vx, vy, vz = 0.0, 0.0, 0.0
        rx, ry, rz = 0.0, 0.0, 0.0

        # Scale the speeds to the time used by Blender
        try:
            if self._type == 'Position':
                vx = self.local_data['x'] / self.frequency
                vy = self.local_data['y'] / self.frequency
                rz = self.local_data['w'] / self.frequency
            else:
                vx = self.local_data['x']
                vy = self.local_data['y']
                rz = self.local_data['w']

        # For the moment ignoring the division by zero
        # It happens apparently when the simulation starts
        except ZeroDivisionError:
            pass

        self.robot_parent.apply_speed(self._type, [vx, vy, vz], [rx, ry, rz])

########NEW FILE########
__FILENAME__ = billboard
import logging; logger = logging.getLogger("morse." + __name__)
def reset_rotation (contr):
    """ Cancell the global rotation of the object

    This will make it remain still, as a "billboard",
    with respect to the user controlled camera
    """
    obj = contr.owner
    obj.worldOrientation = [0.0, 0.0, 0.0]


def display (contr):
    """ Toggle showing or hiding of component """
    if contr.sensors[0].positive:
        obj = contr.owner
        obj['Display'] = not obj['Display']
        obj.setVisible(obj['Display'])

########NEW FILE########
__FILENAME__ = calling
import logging; logger = logging.getLogger("morse." + __name__)
import os

from morse.core import blenderapi

""" Generic Python Module to be called by all MORSE components.
    It will locate the calling object in the dictionary,
    retrieve the stored instance and call its 'action' method. """

def robot_action(contr):
    """ Call the 'action' method of the correct robot. """
    scene = blenderapi.scene()
    # if current scene is not the main MORSE logic scene, pass
    if not scene or scene.name != 'S.MORSE_LOGIC':
        return
    # Do nothing if morse has not been properly initialised
    simu = blenderapi.persistantstorage()
    if "morse_initialised" not in simu or not simu.morse_initialised:
        return

    # Execute only when the sensor is really activated
    if contr.sensors[0].positive:
        obj = contr.owner

        # Do nothing if the component was not initialised.
        # Should be the case for external robots and components
        robot_object = simu.robotDict.get(obj, None)
        if robot_object:
            robot_object.action()

def component_action(contr):
    """ Call the 'action' method of the correct component. """
    scene = blenderapi.scene()
    # if current scene is not the main MORSE logic scene, pass
    if not scene or scene.name != 'S.MORSE_LOGIC':
        return
    # Do nothing if morse has not been properly initialised
    simu = blenderapi.persistantstorage()
    if "morse_initialised" not in simu or not simu.morse_initialised:
        return

    # Execute only when the sensor is really activated
    if contr.sensors[0].positive:
        obj = contr.owner

        # Do nothing if the component was not initialised.
        # Should be the case for external robots and components
        cmpt_object = simu.componentDict.get(obj.name, None)
        if cmpt_object:
            cmpt_object.action()

def sensor_action(contr):
    """ Call the 'action' method of the correct sensor. """
    component_action(contr)

def actuator_action(contr):
    """ Call the 'action' method of the correct actuator. """
    component_action(contr)

########NEW FILE########
__FILENAME__ = hud_text
def change_text(contr):
    """ Set the desired text in the HUD """
    obj = contr.owner
    obj['Text'] = '''
  * Esc :       stop and exit the simulation
  * H :         show this help message
  * V :         toggle display of robot camera on HUD
  * W, S :      move main camera forward/bakwards
  * A, D :      move main camera left/right
  * R, F :      move main camera up/down
  * Left CTRL:  hold to aim main camera with mouse
  * F5 :        toggle camera/human movement
  * F7 :        move CameraFP to robots
  * F8 :        reset position of CameraFP
  * F9 :        switch camera view
  * F11 :       reset positions of all objects
  * F12 :       forced exit from the simulation
'''

# TODO use a monospace font for text, not Arial.

########NEW FILE########
__FILENAME__ = camera
from morse.core import blenderapi

from mathutils import Vector, Matrix

def init():
    """
    Sets the camera on load
    """
    co =  blenderapi.controller()
    ow = co.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""
    
    camAct = co.actuators['Set_Camera']
    sobList =  blenderapi.scene().objects

    human = ow

    # if the Human is external, do not use his camera initially
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return
    
    humCam = sobList['Human_Camera' + suffix]
    
    try:
        worldCam = sobList['CameraFP']
        #check if there is a Camera displaying the world in the scene
    except KeyError:
        worldCam = None

    if ow['WorldCamera'] and worldCam:
        camAct.camera = worldCam
    else:
        camAct.camera = humCam
        blenderapi.mousepointer(visible = False)
    # set Camera following the human or displaying the world
    
    
    co.activate(camAct)

def collision():
    """
    Detect camera collision and place the camera accordingly
    """
    co =  blenderapi.controller()
    ow = co.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""
    
    ray = co.sensors['collision']
    right = co.sensors['RIGHT']
    left = co.sensors['LEFT']
    human =   blenderapi.scene().objects[ow.parent.parent['human_name']]

    # if the Human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return
    
    Orig_Pos = blenderapi.scene().objects['POS_3P_Cam_Orig' + suffix]
    distance = 0.05     # the distance the camera keeps to Objects

    # if near an object, place the camera slightly in front of it
    if ray.positive and not human['Manipulate'] and not (right.positive or
                                                         left.positive):
        hitPos = ray.hitPosition
        ow.worldPosition = (Vector(hitPos) -
                            Vector(ray.rayDirection).normalized()*distance)
        ow['prop_collision'] = True
        
    elif ray.positive and not human['Manipulate'] and right.positive:
        hitPos = (Vector(ray.hitPosition) + Vector(right.hitPosition))/2
        ow.worldPosition = (hitPos -
                            (Vector(ray.rayDirection) +
                             Vector(right.rayDirection)).normalized()*distance)
        ow['prop_collision'] = True
        
    elif ray.positive and not human['Manipulate'] and left.positive:
        hitPos = (Vector(ray.hitPosition) + Vector(left.hitPosition))/2
        ow.worldPosition = (hitPos -
                            (Vector(ray.rayDirection) +
                             Vector(left.rayDirection)).normalized()*distance)
        ow['prop_collision'] = True
        
    elif left.positive and not human['Manipulate'] and not (right.positive or
                                                            ray.positive):
        hitPos = left.hitPosition
        ow.worldPosition = (Vector(hitPos) -
                            Vector(left.rayDirection).normalized()*distance)
        ow['prop_collision'] = True
        
    elif right.positive and not human['Manipulate'] and not (left.positive or
                                                             ray.positive):
        hitPos = right.hitPosition
        ow.worldPosition = (Vector(hitPos) -
                            Vector(right.rayDirection).normalized()*distance)
        ow['prop_collision'] = True

    else:
        ow['prop_collision'] = False
        ow.worldPosition = Orig_Pos.worldPosition
    # else place the camera to its former position 


def change():
    """
    Changes camera position to 1st person while in Manipulation-Mode
    """
    co = blenderapi.controller()
    ow = co.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""
    
    track = co.actuators['TrackCamera']
    sobList = blenderapi.scene().objects

    human = sobList[ow["human_name"]]

    # if the Human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return
    
    FP = sobList['POS_1P_Cam' + suffix]
    FP_POS = sobList['POS_1P_Cam' + suffix].worldPosition
    TP_POS = sobList['POS_3P_Cam' + suffix].worldPosition
    head_target = sobList['Target_Empty' + suffix]
    hand_target = sobList['IK_Target_Look.R' + suffix]
    look_target = sobList['LOOK_TARGET' + suffix]
    right_hand = sobList['Hand_Grab.R' + suffix]
    mmb = ow.sensors['MMB']


    if ow.getDistanceTo(FP) < 0.08:
        # if the distance is smaller than 0.08,
        # snap the camera to the 'POS_1P_Cam'-empty
        ow['FP'] = True


    if not human['Manipulate']:
        ow['FP'] = False
        if not ow['prop_collision']:
            smooth_move(TP_POS, ow)
    else:
        if not ow['FP']:
            smooth_move(FP_POS, ow)
        else:
            ow.worldPosition = FP_POS


    # camera points to several empties according to the current situation
    if human['Manipulate']:
        track.object = head_target
    else:
        track.object = look_target
    co.activate(track)

def smooth_move(goal, owner):
    """This function moves this script's owner to 'goal'
    Change the smoothness to make the transition faster or slower
    higher value --> slower
    lower value --> faster
    recommended value: 10
    """
    smoothness = 10
    currLoc = owner.worldPosition
    destLoc = goal
    dX, dY, dZ = [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]
    
    dX = currLoc[0] - destLoc[0]        
    dY = currLoc[1] - destLoc[1]        
    dZ = currLoc[2] - destLoc[2]
    smoothVec = currLoc

    smoothVec[0] -= dX / smoothness
    smoothVec[1] -= dY / smoothness
    smoothVec[2] -= dZ / smoothness
    owner.worldPosition = smoothVec


def raylength():
    """
    Objects can only be grabbed if they are hit by the Ray-Sensor called 'Ray'.
    Set the ray's length ,
    so that it hits objects in a certain radius around the human's z-axis
    """
    co = blenderapi.controller()
    cam = co.owner
    ray = co.sensors['Ray']

    dir = Vector(ray.rayDirection)
    xy = Matrix.OrthoProjection('XY', 3) * dir
    # API Change in 2.59 builds - Vectors are now column vectors
    
    ray.range = 0.8/xy.length

########NEW FILE########
__FILENAME__ = carriing_pose
from morse.core import blenderapi
from mathutils import Vector

def move(cont):
    """
    Move the hand to a nice position for carriing objects.
    This script is executed as long as the Property 'moveArm' is True
    """
    ow = cont.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""
    
    dest = blenderapi.scene().objects['IK_Pose_Empty.R' + suffix]
    hips = blenderapi.scene().objects['Hips_Empty' + suffix]
    left_hand = blenderapi.scene().objects['IK_Target_Empty.L' + suffix]
    human = blenderapi.scene().objects[ow.parent.name + suffix]
    
    # get the Vector to the right position
    if human['Manipulate']:
        vect = ow.getVectTo(dest)
    else:
        walk_hand_position = human.worldPosition + human.worldOrientation*Vector((0.3, -0.3, 0.9))
        vect = ow.getVectTo(walk_hand_position)
    # vect[0] is Distance
    # vect[1] and vect[2] are the Vector in global and local coordinates

    ow.applyMovement(vect[1]/50)
    # use global coordinates to move the right hand a bit to the destination
    hips.applyMovement([0.0, 0.0, (0.92 - hips.localPosition[2])/10])
    # move the hips down
    left_hand.applyMovement([0.0, 0.0, (0.9 - left_hand.localPosition[2])/10])
    # also move the left hand to prevent a unnatural pose

    if vect[0] < 0.02:
        # if the owner is near enough to the right position, set this position
        ow.worldPosition = dest.worldPosition if human['Manipulate'] else walk_hand_position
        ow['moveArm'] = False
        # stop this script from being executed all the time
        # interaction.py will set the property again if needed


########NEW FILE########
__FILENAME__ = head
from morse.core import blenderapi

def set_body_position(co):
    """
    During grabbing the head moves. The 'Head_Empty' needs to follow.
    """
    ow = co.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""

    head = blenderapi.scene().objects['Head']
    human = blenderapi.scene().objects[ow.parent["human_name"]]



    if human['Manipulate']:
        ow.worldPosition = head.worldPosition

########NEW FILE########
__FILENAME__ = human_control
import logging; logger = logging.getLogger("morse." + __name__)

######################################################
#
#    human_control.py        Blender 2.55
#
#    Modified version of
#      view_camera.py by Gilberto Echeverria
#
#    Gilberto Echeverria
#    26 / 12 / 2010
#
######################################################

from morse.core import blenderapi
import math
import imp
from mathutils import Matrix

imp.reload(blenderapi)

AZERTY = False

# use different keys for QWERTZ/QWERTY or AZERTY keyboards
RIGHT  = blenderapi.DKEY
TURN_RIGHT = blenderapi.EKEY
BACKWARDS = blenderapi.SKEY

if AZERTY:
    FORWARDS = blenderapi.ZKEY
    LEFT = blenderapi.QKEY
    TURN_LEFT = blenderapi.AKEY
else:
    FORWARDS = blenderapi.WKEY
    LEFT = blenderapi.AKEY
    TURN_LEFT = blenderapi.QKEY

def lock_movement(contr):
    human = contr.owner
    keyboard = contr.sensors['All_Keys']

    scene = blenderapi.scene()

    if scene.active_camera.name != 'CameraFP':
        return

    keylist = keyboard.events
    for key in keylist:
        # key[0] == blenderapi.keycode, key[1] = status
        if key[1] == blenderapi.input_just_activated():
            if key[0] == blenderapi.F5KEY:
                human['move_cameraFP'] = not human['move_cameraFP']
                if human['move_cameraFP']:
                    logger.info("Moving CameraFP")
                else:
                    logger.info("Moving Human")
                

def move(contr):
    """ Read the keys for specific combinations
        that will make the camera move in 3D space. """
    
    # Get the currently active camera to adapt control method
    scene = blenderapi.scene()
    active_camera = scene.active_camera
    
    # get the object this script is attached to
    human = contr.owner

    # if the human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return
    
    # get the suffix of the human to reference the right objects
    suffix = human.name[-4:] if human.name[-4] == "." else ""

    # set the movement speed
    speed = human['Speed']

    # Get sensor named Mouse
    keyboard = contr.sensors['All_Keys']

    # Default movement speed
    move_speed = [0.0, 0.0, 0.0]
    rotation_speed = [0.0, 0.0, 0.0]

    human_camera = "Human_Camera" + suffix

    if human['move_cameraFP'] and active_camera.name != human_camera:
        return

    keylist = keyboard.events
    for key in keylist:
        # key[0] == blenderapi.keycode, key[1] = status
        if key[1] == blenderapi.input_active():
            if human['Manipulate']:
                if key[0] == FORWARDS:
                    move_speed[0] = speed
                elif key[0] == BACKWARDS:
                    move_speed[0] = -speed
                elif key[0] == TURN_LEFT:
                    rotation_speed[2] = speed
                elif key[0] == TURN_RIGHT:
                    rotation_speed[2] = -speed
                elif key[0] == RIGHT:
                    if active_camera.name == human_camera:
                        move_speed[1] = -speed
                    else:
                        rotation_speed[2] = -speed
                elif key[0] == LEFT:
                    if active_camera.name == human_camera:
                        move_speed[1] = speed
                    else:
                        rotation_speed[2] = speed
            else:
                if key[0] in (FORWARDS, BACKWARDS, LEFT, RIGHT):
                    move_speed[0] = speed
                    if active_camera.name != human_camera and key[0] == BACKWARDS:
                        move_speed[0] = -speed

            # The second parameter of 'applyMovement' determines
            #  a movement with respect to the object's local
            #  coordinate system
            human.applyMovement( move_speed, True )
            human.applyRotation( rotation_speed, True )

            """
            if key[0] == blenderapi.UPARROWKEY:
                move_speed[0] = speed
            elif key[0] == blenderapi.DOWNARROWKEY:
                move_speed[0] = -speed
            elif key[0] == blenderapi.LEFTARROWKEY:
                rotation_speed[2] = speed
            elif key[0] == blenderapi.RIGHTARROWKEY:
                rotation_speed[2] = -speed
            elif key[0] == blenderapi.AKEY:
                move_speed[2] = speed
            elif key[0] == blenderapi.EKEY:
                move_speed[2] = -speed
            """

        elif key[1] == blenderapi.input_just_activated():
            # Other actions activated with the keyboard
            # Reset camera to center
            if key[0] == blenderapi.NKEY and keyboard.positive:
                reset_view(contr)
            # Switch between look and manipulate
            elif key[0] == blenderapi.XKEY:
                toggle_manipulate(contr)

def read_status(contr):
    """ Check if the human is moving and set the flags
    
    This will trigger the walking animation even when the human
    is controlled via a motion actuator
    """
    human = contr.owner
    scene = blenderapi.scene()
    
    # get the suffix of the human to reference the right objects
    suffix = human.name[-4:] if human.name[-4] == "." else ""
    
    armature = scene.objects['HumanArmature' + suffix]
    tolerance = 0.001

    # TODO: Do not change the movement properties until the controllers
    #  are properly implemented to use velocity commands
    if False:
        speed = human.getLinearVelocity()
        logger.debug("Man going at speed [%.4f, %.4f, %.4f]" % (speed[0], speed[1], speed[2]))
        if speed[0] > tolerance:
           armature['movingForward'] = True 
        elif speed[0] < -tolerance:
           armature['movingBackward'] = True 
        else:
           armature['movingForward'] = False 
           armature['movingBackward'] = False 


def set_human_animation(contr):
    """ Toggle the animation actions (walking, standing still...) of 
    the armature. 
    """
    # Get sensor named Mouse
    armature = contr.owner

    # get the suffix of the human to reference the right objects
    suffix = armature.name[-4:] if armature.name[-4] == "." else ""

    scene = blenderapi.scene()
    active_camera = scene.active_camera
    human = scene.objects[armature.parent.name]

    # if the human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return    

    keyboard = contr.sensors['All_Keys']

    keylist = keyboard.events
    pressed = []      #all keys that are currently pressed
    for key in keylist:
        # key[0] == blenderapi.keycode, key[1] = status
        if key[1] == blenderapi.input_just_activated():
            pressed.append(key[0])
            # Keys for moving forward or turning
            """
            if key[0] == blenderapi.WKEY or key[0] == blenderapi.ZKEY:
                armature['movingForward'] = True
            elif key[0] == blenderapi.SKEY:
                armature['movingBackward'] = True
            """
            # TEST: Read the rotation of the bones in the armature
            if key[0] == blenderapi.BKEY:
                read_pose(contr)
            #elif key[0] == blenderapi.VKEY:
                #reset_pose(contr)
        #elif key[1] == blenderapi.input_just_released():
            """            
            if key[0] == blenderapi.WKEY or key[0] == blenderapi.ZKEY:
                armature['movingForward'] = False
            elif key[0] == blenderapi.SKEY:
                armature['movingBackward'] = False
        """
        elif key[1] == blenderapi.input_active():
            pressed.append(key[0])

    
    if human['move_cameraFP'] and active_camera.name != 'Human_Camera':
        return
    
    if (FORWARDS in pressed or LEFT in pressed or BACKWARDS in pressed or
        RIGHT in pressed):
        armature['movingForward'] = True
    else:
        armature['movingForward'] = False


def head_control(contr):
    """ Move the target of the head and camera

    Use the movement of the mouse to determine the rotation
    for the human head and camera. """
    # get the object this script is attached to
    human = contr.owner
    
    # if the human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return

    # get the suffix of the human to reference the right objects
    suffix = human.name[-4:] if human.name[-4] == "." else ""

    scene = blenderapi.scene()
    target = scene.objects['Target_Empty' + suffix]
    POS_EMPTY = scene.objects['POS_EMPTY' + suffix]
    Head_Empty = scene.objects['Head_Empty' + suffix]
    right_hand = scene.objects['Hand_Grab.R' + suffix]
    camera = scene.objects['Human_Camera' + suffix]
    mmb = contr.sensors['MMB']

    # Do not move the camera if the current view is using another camera
    if camera != blenderapi.scene().active_camera:
        return

    # If the manipulation mode is active, an object is grabbed
    # and the Middle Mouse Button is pressed, do nothing
    if (human['Manipulate'] and right_hand['selected'] != 'None' and
        right_hand['selected'] != '' and mmb.positive):
        return

    if mmb.positive:
        target = scene.objects['IK_Target_Empty.R' + suffix]

    # Get sensor named Mouse
    mouse = contr.sensors['Mouse']

    if mouse.positive:
        # get width and height of game window
        width = blenderapi.render().getWindowWidth()
        height = blenderapi.render().getWindowHeight()

        # get mouse movement from function
        move = mouse_move(human, mouse, width, height)

        # set mouse sensitivity
        sensitivity = human['Sensitivity']

        # Amount, direction and sensitivity
        left_right = move[0] * sensitivity
        up_down = move[1] * sensitivity

        if not human['FOCUSED']:
            POS_EMPTY.applyRotation([0.0, 0.0, left_right], True)
            if not ((Head_Empty.localOrientation.to_euler()[1] >= 0.7
                     and up_down < 0) or
                    (Head_Empty.localOrientation.to_euler()[1] <= -0.4
                     and up_down > 0)) and not human['Manipulate']:
                # capping the rotation to prevent the camera to be upside down
                if not mmb.positive:
                    Head_Empty.applyRotation([0.0, -up_down, 0.0], True)
                target.applyMovement([0.0, 0.0, up_down], True)
            elif human['Manipulate']:
                Head_Empty.applyRotation([0.0, -up_down, 0.0], True)
                target.applyMovement([0.0, 0.0, up_down], True)

        # Reset mouse position to the centre of the screen
        # Using the '//' operator (floor division) to produce an integer result
        blenderapi.render().setMousePosition(width//2, height//2)


def hand_control(contr):
    """ Move the hand following the mouse

    Use the movement of the mouse to determine the rotation
    for the IK arm (right arm)
    
    stays for better placing of objects - >(QKEY + EKEY) to rotate body<
    """
    # get the object this script is attached to
    human = contr.owner
    
    # if the human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return

    # get the suffix of the human to reference the right objects
    suffix = human.name[-4:] if human.name[-4] == "." else ""
    
    scene = blenderapi.scene()
    target = scene.objects['IK_Target_Empty.R' + suffix]
    right_hand = scene.objects['Hand_Grab.R' + suffix]
    mmb = human.sensors['MMB']

    # If the manipulation mode is inactive, do nothing
    if not human['Manipulate']:
        return

    # set mouse sensitivity
    sensitivity = human['Sensitivity']

    # Get sensors for mouse wheel
    wheel_up = contr.sensors['Wheel_Up']
    wheel_down = contr.sensors['Wheel_Down']
    keyboard = contr.sensors['All_Keys']

    keylist = keyboard.events
    for key in keylist:
        if key[1] == blenderapi.input_none() and key[0] == blenderapi.LEFTCTRLKEY:
            if wheel_up.positive:
                front = 50.0 * sensitivity
                target.applyMovement([front, 0.0, 0.0], True)

            if wheel_down.positive:
                back = -50.0 * sensitivity
                target.applyMovement([back, 0.0, 0.0], True)

    # If nothing grabbed or Middle Mouse Button is not pressed,
    # do nothing of the following
    if (right_hand['selected'] == 'None' or right_hand['selected'] == '' or
        (not mmb.positive)):
        #use head_control for this
        return

    # Get sensor named Mouse
    mouse = contr.sensors['Mouse']

    if mouse.positive:
        # get width and height of game window
        width = blenderapi.render().getWindowWidth()
        height = blenderapi.render().getWindowHeight()

        # get mouse movement from function
        move = mouse_move(human, mouse, width, height)

        # Amount, direction and sensitivity
        left_right = move[0] * sensitivity
        up_down = move[1] * sensitivity

        if not human['FOCUSED']:
            target.applyMovement([0.0, left_right, 0.0], True)
            target.applyMovement([0.0, 0.0, up_down], True)

        # Reset mouse position to the centre of the screen
        # Using the '//' operator (floor division) to produce an integer result
        blenderapi.render().setMousePosition(width//2, height//2)


def read_pose(contr):
    armature = contr.owner
    logger.info("The armature is: '%s' (%s)" % (armature, type(armature)))

    for channel in armature.channels:
        if 'X_' not in channel.name:
            rotation = channel.joint_rotation
            logger.info("\tChannel '%s': (%.4f, %.4f, %.4f)" % (channel, rotation[0], rotation[1], rotation[2]))


def reset_pose(contr):
    armature = contr.owner
    logger.info("Trying to reset the posture:")
    for channel in armature.channels:     
        channel.rotation_mode = 6
        
        channel.joint_rotation = [0.0, 0.0, 0.0]

        rotation = channel.joint_rotation
        logger.info("\tChannel '%s': (%.4f, %.4f, %.4f)" % (channel, rotation[0], rotation[1], rotation[2]))

    armature.update()

def reset_view(contr):
    """ Make the human model look forward """
    human = contr.owner
    
    # if the human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return
    
    # get the suffix of the human to reference the right objects
    suffix = human.name[-4:] if human.name[-4] == "." else ""
    
    scene = blenderapi.scene()
    target = scene.objects['Target_Empty' + suffix]
    # Reset the Empty object to its original position
    target.localPosition = [1.3, 0.0, 1.7]


def toggle_manipulate(contr):
    """ Switch mouse control between look and manipulate """
    human = contr.owner
    
    # if the human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return

    # get the suffix of the human to reference the right objects
    suffix = human.name[-4:] if human.name[-4] == "." else ""
    
    scene = blenderapi.scene()
    hand_target = scene.objects['IK_Target_Empty.R' + suffix]
    head_target = scene.objects['Target_Empty' + suffix]
    right_hand = scene.objects['Hand_Grab.R' + suffix]

    if human['Manipulate']:
        #blenderapi.render().showMouse(False)
        human['Manipulate'] = False
        # Place the hand beside the body
        if right_hand['selected'] == 'None' or right_hand['selected'] == '' or right_hand['selected'] is None:
            hand_target.localPosition = [0.3, -0.3, 0.9]
            head_target.setParent(human)
            head_target.localPosition = [1.3, 0.0, 1.7]
    else:
        #blenderapi.render().showMouse(True)
        human['Manipulate'] = True
        head_target.setParent(hand_target)
        # Place the hand in a nice position
        hand_target.localPosition = [0.6, 0.0, 1.4]
        head_target.worldPosition = hand_target.worldPosition	



def toggle_sit(contr):
    """ Change the stance of the human model

    Make the human sit down or stand up, using a preset animation.
    """
    human = contr.owner
        
    # if the human is external, do nothing
    if human.parent.get('External_Robot_Tag') or human.parent['disable_keyboard_control']:
        return

    # get the keyboard sensor
    sit_down_key = contr.sensors["sit_down"]

    # get the actuators
    sitdown = contr.actuators["sitdown"]
    standup = contr.actuators["standup"]
    hipsdown = contr.actuators["SitDown"]
    hipsup = contr.actuators["StandUp"]

    # Sitdown
    if sit_down_key.positive and human['statusStandUp']:
        contr.activate(sitdown)
        contr.activate(hipsdown)
        human['statusStandUp'] = False

    # Standup
    elif sit_down_key.positive and not human['statusStandUp']:
        contr.activate(standup)
        contr.activate(hipsup)
        human['statusStandUp'] = True



def mouse_move(human, mouse, width, height):
    """ Get the movement of the mouse as an X, Y coordinate. """
    # distance moved from screen center
    # Using the '//' operator (floor division) to produce an integer result
    x = width//2 - mouse.position[0]
    y = height//2 - mouse.position[1]

    # intialize mouse so it doesn't jerk first time
    try:
        human['mouseInit']
    except KeyError:
        x = 0
        y = 0
        # bug in Add Property
        # can't use True.  Have to use 1
        human['mouseInit'] = 1

    # return mouse movement
    return x, y

def applyrotate(destOr, owner):
    """
    Rotates the owner of this script to the given orientation.
    'smoothness' defines the speed of this rotation
    """
    smoothness = 10
    currOr = owner.worldOrientation
    dZ = [0.0,0.0,0.0]

    dZ = currOr.to_euler()[2] - destOr.to_euler()[2]

    # Blender allows multiples of 360 deg and negative angles
    # this is to get rid of those
    while dZ < math.pi:
        dZ += 2 * math.pi
    while dZ > math.pi:
        dZ -= 2 * math.pi

    owner.worldOrientation = (owner.worldOrientation *
                              Matrix.Rotation(-dZ/ smoothness, 3, 'Z'))
    # turn around a bit

def rotate(co):
    """
    Set the human orientation in reference to the camera orientation.
    """
       
    ow = co.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""
    
    keyboard = co.sensors['All_Keys']
    scene = blenderapi.scene()
    human_pos = co.owner
    pos =  scene.objects['POS_EMPTY' + suffix]
    active_camera = scene.active_camera
        
    # if the human is external, do nothing
    if human_pos.get('External_Robot_Tag') or human_pos['disable_keyboard_control']:
        return
    
    if human_pos['move_cameraFP'] and active_camera.name != ('Human_Camera'+suffix):
        return
    
    keylist = keyboard.events

    k = []    #initiate a list with all currently pressed keys
    for key in keylist:
        if key[1] ==  blenderapi.input_active():
            k.append(key[0])        # add all pressed keys to a list - as ASCII CODES

    pos.worldPosition = ow.worldPosition

    # Get active camera
    scene = blenderapi.scene()
    active_camera = scene.active_camera
    
    if ow['Manipulate']:
        ow.worldOrientation = pos.worldOrientation
        # lock camera to head in Manipulation Mode
    else:
        if FORWARDS in k and not(LEFT in k or RIGHT in k):  
            if active_camera.name == ("Human_Camera"+suffix):
                applyrotate(pos.worldOrientation, ow)
            else:
                applyrotate(human_pos.worldOrientation, ow) 
        elif LEFT in k and not(FORWARDS in k or BACKWARDS in k):
            if active_camera.name == ("Human_Camera"+suffix):
                applyrotate(pos.worldOrientation *
                            Matrix.Rotation(math.pi / 2, 3, 'Z'), ow)
            else: 
                applyrotate(human_pos.worldOrientation *
                            Matrix.Rotation(math.pi / 2, 3, 'Z'), ow)
            # turn around 90 deg
        elif RIGHT in k and not(FORWARDS in k or BACKWARDS in k):
            if active_camera.name == ("Human_Camera"+suffix):
                applyrotate(pos.worldOrientation *
                            Matrix.Rotation(math.pi * 3/2, 3, 'Z'), ow)
            else:
                applyrotate(human_pos.worldOrientation * Matrix.Rotation(math.pi * 3/2, 3, 'Z'), ow)
            # turn around 270 deg
        elif LEFT in k and FORWARDS in k:
            if active_camera.name == ("Human_Camera"+suffix):
                applyrotate(pos.worldOrientation *
                            Matrix.Rotation(math.pi / 4, 3, 'Z'), ow)
            else: 
                applyrotate(human_pos.worldOrientation *
                            Matrix.Rotation(math.pi / 4, 3, 'Z'), ow)
            # turn around 45 deg
        elif RIGHT in k and FORWARDS in k:
            if active_camera.name == ("Human_Camera"+suffix):
                applyrotate(pos.worldOrientation *
                            Matrix.Rotation(math.pi * 7 / 4, 3, 'Z'), ow)
            else:
                applyrotate(human_pos.worldOrientation *
                            Matrix.Rotation(math.pi * 7 / 4, 3, 'Z'), ow)
            # turn around 315 deg
        elif BACKWARDS in k and not(LEFT in k or RIGHT in k):
            if active_camera.name == ("Human_Camera"+suffix):
                applyrotate(pos.worldOrientation * Matrix.Rotation(math.pi, 3, 'Z'), ow)
            # turn around 180 deg if in game-mode
        elif LEFT in k and BACKWARDS in k:          
            if active_camera.name == ("Human_Camera"+suffix):
                applyrotate(pos.worldOrientation * Matrix.Rotation(math.pi * 3/4, 3, 'Z'), ow)
            else:
                applyrotate(human_pos.worldOrientation * Matrix.Rotation(math.pi / 4, 3, 'Z'), ow)
            # turn around 135 deg if in game-mode, else turn 45 deg
        elif RIGHT in k and BACKWARDS in k:
            if active_camera.name == ("Human_Camera"+suffix):
                applyrotate(pos.worldOrientation * Matrix.Rotation(math.pi * 5/4, 3, 'Z'), ow)
            else:
                applyrotate(human_pos.worldOrientation * Matrix.Rotation(math.pi * 7 / 4, 3, 'Z'), ow)
            # turn around 225 deg if in game mode, else turn 315 deg.



########NEW FILE########
__FILENAME__ = colorTargetGreen
from morse.core import blenderapi

objects = blenderapi.scene().objects
cube = objects['CubeSelect']
door = objects['Shelf_UpperDoor.R']

co = blenderapi.controller()
grab = co.sensors['GrabState']
layDown = co.sensors['OpenDoorState']

def color():
    if grab.positive:
        cube.color = [0.0, 1.0, 0.0, 1.0]
    elif layDown.positive:
        cube.color = [0.3, 0.3, 0.3, 1.0]
        door.color = [0.0, 1.0, 0.0, 1.0]
    

########NEW FILE########
__FILENAME__ = grab_cup
from morse.core import blenderapi

co = blenderapi.controller()
ow = co.owner

scene = blenderapi.scene()
scriptHolder = scene.objects['TUT_Script_Holder']

def test():
    if ow.parent and scriptHolder['Level'] == 4:
        if not 'init' in ow:
            ow['init'] = True
            scriptHolder['Level'] = 5
        
            

########NEW FILE########
__FILENAME__ = ManipulateState
from morse.core import blenderapi

co = blenderapi.controller()
sens = co.sensors['ManipulateState']
act = co.actuators[0]
objects = blenderapi.scene().objects

def add_level():
    if sens.positive and (objects['Human_Camera'].worldPosition == objects['POS_1P_Cam'].worldPosition):
        co.activate(act)

########NEW FILE########
__FILENAME__ = parse_file
from morse.core import blenderapi
import sys
import os

scene = blenderapi.scene()
scriptHolder = scene.objects['TUT_Script_Holder']

language = scriptHolder['Language']

# get the path once
for dir in sys.path:
    if os.path.exists(os.path.join(dir, "morse/blender/main.py")):
        path = os.path.join(dir, 'morse/blender/human_interaction/human_tut/data/' + language + '/')

def read_file():
    level = scriptHolder['Level']
    f = open(path + "explanations" + str(level) + ".txt", 'r')
    data=f.read()
    return data

########NEW FILE########
__FILENAME__ = PlaceOnStart
from morse.core import blenderapi

co = blenderapi.controller()
collision = co.sensors['Collision']
objects = blenderapi.scene().objects
human = objects['POS_EMPTY']

def place(): 
    if collision.positive:
        human.worldPosition = (30, -12, 0)

########NEW FILE########
__FILENAME__ = Tutorial_Script
from morse.core import blenderapi
import bgl
import blf
import parse_file


co = blenderapi.controller()
ow = co.owner

mainScene = blenderapi.scene()

font_id = 0

def write():
    """write on screen"""
    width = blenderapi.render().getWindowWidth()
    height = blenderapi.render().getWindowHeight()

    # OpenGL setup
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glLoadIdentity()
    bgl.gluOrtho2D(0, width, 0, height)
    bgl.glMatrixMode(bgl.GL_MODELVIEW)
    bgl.glLoadIdentity()

    # BLF drawing routine
    blf.size(font_id, height//40, 72)
    data = parse_file.read_file()
    data = data.splitlines()
    linePosition = height * 0.8
    for str in data:
        str_len = len(str)
        blf.position(font_id, (width * 0.05), linePosition, 0)
        blf.enable(font_id, blf.SHADOW)
        blf.shadow(font_id, 0, 1.0, 0.2, 0.0, 1.0)
        blf.draw(font_id,str)
        linePosition -= height * 0.05

def init():
    """init function - runs once"""
    # set the font drawing routine to run every frame
    mainScene.post_draw = [write]

        

########NEW FILE########
__FILENAME__ = interaction
import logging; logger = logging.getLogger("morse." + __name__)

import os

from bge import logic, texture
import bgl, blf
from mathutils import Matrix, Vector

from bpy import data

from morse.core import blenderapi
from morse.helpers import passive_objects

font_id = 0

windowWidth = blenderapi.render().getWindowWidth()
windowHeight = blenderapi.render().getWindowHeight()
scene= blenderapi.scene()
objects = scene.objects

texco=[(0,0), (1,0), (1,1), (0,1)]

def loadtexture(filepath):
    """ Loads a texture from an image (tga, jpg...any format supported by FFMPEG)
    and returns the texture buffer ID.
    """

    id_buf = bgl.Buffer(bgl.GL_INT, 1)
    bgl.glGenTextures(1, id_buf)
    id = id_buf.to_list()[0] if hasattr(id_buf, "to_list") else id_buf.list[0]
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, id)
    image = texture.ImageFFmpeg(filepath)
    if not image.image:
        logger.error("Error when loading " + filepath + ". File not found? Format not "
                     "supported by FFMPEG? (tga, jpg, png do work)")
        return -1
    else:
        im_buf = image.image
        bgl.glTexParameteri(bgl.GL_TEXTURE_2D, bgl.GL_TEXTURE_MAG_FILTER, bgl.GL_LINEAR)
        bgl.glTexParameteri(bgl.GL_TEXTURE_2D, bgl.GL_TEXTURE_MIN_FILTER, bgl.GL_LINEAR)
        bgl.glTexEnvf(bgl.GL_TEXTURE_ENV, bgl.GL_TEXTURE_ENV_MODE, bgl.GL_MODULATE)
        bgl.glTexImage2D(bgl.GL_TEXTURE_2D, 0, bgl.GL_RGBA, image.size[0], image.size[1], 0, bgl.GL_RGBA, bgl.GL_UNSIGNED_BYTE, im_buf)
        return id


# load overlay_closed.tga and overlay_open.tga into the global dictionary
if not "open" in  logic.globalDict:
    TexName = "overlay_open.tga"
    filepath = logic.expandPath(os.path.join(os.environ["MORSE_ROOT"], "share","morse","data","props",TexName))
    logic.globalDict["open"] = loadtexture(filepath)

open_id = logic.globalDict.get("open")

if not "closed" in logic.globalDict:
    TexName = "overlay_closed.tga"
    filepath = os.path.join(os.environ["MORSE_ROOT"], "share","morse","data","props",TexName)
    logic.globalDict["closed"] = loadtexture(filepath)

closed_id = logic.globalDict.get("closed")

# load CrossHairs.tga into the global dictionary
if not "crosshairs" in logic.globalDict:
    TexName = "overlay_crosshairs.tga"
    filepath = os.path.join(os.environ["MORSE_ROOT"], "share","morse","data","props",TexName)
    logic.globalDict["crosshairs"] = loadtexture(filepath)

crosshairs_id = logic.globalDict.get("crosshairs")


def open_door(door):
    if not door['Open']:     # opens the door
        if door['Door'].lower()=='right':
            door.applyRotation((0, 0, 1.4), False)
            # rotation around global Z-Axis - ~80 degrees
        elif door['Door'].lower()=='left':
            door.applyRotation((0, 0, -1.4), False)
    elif door['Open']:     # closes the door
        if door['Door'].lower()=='right':
            door.applyRotation((0, 0, -1.4), False)
            # rotation around global Z-Axis - ~80 degrees
        elif door['Door'].lower()=='left':
            door.applyRotation((0, 0, 1.4), False)
    door['Open'] = not door['Open']



def interact(cont):
    """
    Script for opening doors, drawers and grabbing objects
    
    press left mousebutton to open, close or grab
    press right mousebutton to drop the currently selected object
    """

    ow = cont.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""

    right_hand=objects['IK_Target_Empty.R' + suffix]
    look = objects['Target_Empty' + suffix]
    human = blenderapi.scene().objects[ow.parent.parent.parent.name]

    # if the human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return
    
    lmb=cont.sensors['LMB']
    ray = cont.sensors['Ray']
    cam = ray.owner
    lay_down_ray = cont.sensors['LayDownRay']
    rmb=cont.sensors['RMB']
    space = cont.sensors['SPACEBAR']
    head = objects['Head_Empty' + suffix]
    hand = objects['Hand.R' + suffix]

    
    # Get the focusing object:
    # A ray sensor is attached to the HumanCamera sensor.
    # It returns all colliding objects in a 10 cm range of the hand.
    # We filter the result to keep only objects that have the 'Object'
    # property or that have children with the 'Object' property.
    focus = None
    prox_obj = ray.hitObject                     # focused object
    if prox_obj:
        if 'Object' in prox_obj:
            focus = prox_obj
        elif 'Door' in prox_obj or 'Drawer' in prox_obj or 'Switch' in prox_obj:
            focus = prox_obj
        else:
            for obj in prox_obj.children:
                if 'Object' in obj:
                    focus = obj
    
    # set the overlay scene and change the displayed text
    # and texture
    if human['Manipulate'] and focus:
            
        can_be_manipulated = False

        if focus in passive_objects.graspable_objects():
            can_be_manipulated = True
            if not ow['selected']:
                ow['Status'] = 'Pick up ' + passive_objects.label(focus)
            else:
                ow['Status'] = passive_objects.label(focus)
        elif 'Door' in focus or 'Drawer' in focus:
            can_be_manipulated = True
            
            try:
                if focus['Open']:
                    ow['Status'] = 'Close ' + str(focus['Description'])
                else:
                    ow['Status'] = 'Open ' + str(focus['Description'])
            except KeyError:
                logger.warning('Key missing in focused Object ' + focus.name +
                      ' --- no description given')
        elif 'Switch' in focus:
            can_be_manipulated = True
            if objects[focus['Switch']]['On']:
                ow['Status'] = "Turn off " + focus['Switch']
            else:
                ow['Status'] = "Turn on " + focus['Switch']
        else:
            ow['Status'] = None
    else:
        ow['Status'] = None

    if human['Manipulate']:
        if not crosshairs in scene.post_draw:
            scene.post_draw.append(crosshairs)
    else:
        if crosshairs in scene.post_draw:
            scene.post_draw.remove(crosshairs)


    if ow['Status']:
        if not write_interaction_status in scene.post_draw:
            scene.post_draw.append(write_interaction_status)
        if not status_image in scene.post_draw:
            scene.post_draw.append(status_image)
    else:
        if write_interaction_status in scene.post_draw:
            scene.post_draw.remove(write_interaction_status)
        if status_image in scene.post_draw:
            scene.post_draw.remove(status_image)



    if space.positive:
        # blocks mouse movement if interactable object is focused 
        try:
            if ('Door' in focus or 'Object' in focus or 'Drawer' in focus) and not ow['selected']:

                human['FOCUSED'] = True
                vect = Matrix.OrthoProjection('XY', 3) * human.getVectTo(focus)[1]
                human.alignAxisToVect(vect, 0, 1.0)
                # align the local x axis to point to the focused object
            else:
                human['FOCUSED'] = False
        except TypeError:
            human['FOCUSED'] = False
    else:
        human['FOCUSED'] = False


    try:
        if focus in passive_objects.graspable_objects():
            if lmb.positive and not ow['selected']:
                # set a property - a property-sensor will fire the grab-function
                ow['grabbing'] = focus
        elif 'Door' in focus and lmb.positive:
            open_door(focus)
            # if you decide to use IPOs for the doors,
            # comment the previous line and uncomment the next line
            # the logic can be set with code in morse utils, which is currently
            # commented
            # focus['Open'] = not focus['Open']
        elif 'Drawer' in focus and lmb.positive:
            focus['Open'] = not focus['Open']
        elif 'Switch' in focus and lmb.positive:
            objects[focus['Switch']]['On'] = not objects[focus['Switch']]['On']
    except TypeError:
        pass


    if rmb.positive:                #drop selected Object
        ow['grabbing'] = None
        focused_object = lay_down_ray.hitObject
        if focused_object is not None:
            actor_focused = blenderapi.objectdata(focused_object.name).game.use_actor
        # accurate placing of objects under certain conditions
        if human['Manipulate'] and lay_down_ray.positive \
           and focused_object != ow['selected'] \
           and actor_focused:
            # check not to lay the object on itself
            if ow['selected']:
                right_hand['LayDown'] = lay_down_ray.hitPosition
                right_hand['LayDownObj'] = focused_object
        # otherwise just drop the object
        else:
            if ow['selected']:
                ow['selected'].removeParent()
                ow['selected'] = None
                right_hand['moveArm'] = True



def grab(cont):
    """
    Makes the right hand move to the object
    and parent the object to the hand if colliding
    """
    ow = cont.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""

    # Nothing selected for grabbing or already something in hand
    if not ow['grabbing'] or ow['selected']:
        return

    obj = ow['grabbing']

    coll = cont.sensors['Collision']

    human = objects[ow.parent.parent.parent.name + suffix]
    hand = objects['Hand.R' + suffix]
    hips = objects['Hips_Empty' + suffix]
    left_hand = objects['IK_Target_Empty.L' + suffix]
    right_hand = objects['IK_Target_Empty.R' + suffix]

    vect = right_hand.getVectTo(obj)
    move = vect[1]
    right_hand.applyMovement(move/50)

    if obj.worldPosition[2] < human.worldPosition[2] + 0.5:
        # if the object is located lower than 0.5 meters (local Position)
        hips.applyMovement([0.0, 0.0, -(hips.worldPosition[2]-0.5)/50])
        left_hand.applyMovement([0.0, 0.0, -(hips.worldPosition[2]-0.5)/50])

    # Do we actually touch the object?
    # Even if the physics shape consists of several compound objects,
    # the parent is considered when one of them is touched

    if coll.hitObject == obj:
        logger.debug("Grabbing %s" % obj)
        ow['grabbing'] = None
        ow['selected'] = obj
        obj.setParent(ow)
        right_hand['moveArm'] = True

def roll_hand_r(cont):
    """
    roll the right hand
    """
    armature = cont.owner
    human = armature.parent
    hand_r = armature.channels['Hand.R']

    # if the human is external, do nothing
    if human.get('External_Robot_Tag') or human['disable_keyboard_control']:
        return
    
    keyboard = cont.sensors['All_Keys']
    wheel_down = cont.sensors['WheelDown']
    wheel_up = cont.sensors['WheelUp']

    if not ((wheel_down.positive or wheel_up.positive) and human['Manipulate']):
        return
    
    roll_speed = 0.1
    
    keylist = keyboard.events
    for key in keylist:
        # key[0] == events.keycode, key[1] = status
        if key[1] == blenderapi.input_active() and key[0] == blenderapi.LEFTCTRLKEY:
            if wheel_down.positive:
                roll_speed = -roll_speed
            hand_r.rotation_quaternion += Vector((0.0, 0.0, roll_speed, 0.0))
            armature.update()
            


def lay_down(cont):
    """
    lay the object down to given coordinates
    """
    pos = cont.owner

    # get the suffix of the human to reference the right objects
    suffix = pos.name[-4:] if pos.name[-4] == "." else ""
    
    objects = blenderapi.scene().objects
    hand = objects['Hand_Grab.R' + suffix]
    
    obj = hand['selected']
    if obj is None or not pos['LayDown'] or not 'Collision' in obj.sensors:
        return

    obj_collision = obj.sensors['Collision']

    if not (obj_collision.positive and pos['LayDownObj'] in obj_collision.hitObjectList):
        vect = pos.getVectTo(Vector(pos['LayDown']))[1]
        pos.worldPosition += vect/75
    else:
        obj.removeParent()
        hand['selected'] = None
        pos['moveArm'] = True
        pos['LayDown'] = False
        pos['LayDownObj'] = None

def lay_down_visualize(cont):
    """
    Show a green rectangle if you can accurately place the selected object
    """
    ow = cont.owner

    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""
    
    scene = blenderapi.scene()
    objects = scene.objects
    human = objects[ow['human_name']]

    hand = objects['Hand_Grab.R' + suffix]
    ray = cont.sensors['LayDownRay']


    focused_object = ray.hitObject
    try:
        actor_focused = data.objects[focused_object.name].game.use_actor
    except AttributeError:
        actor_focused = False
        
    if human['Manipulate'] and ray.positive and \
       focused_object != hand['selected'] and hand['selected'] and \
       actor_focused:
        if not color_placing in scene.post_draw:
            scene.post_draw.append(color_placing)
            
    else:
        if color_placing in scene.post_draw:
            scene.post_draw.remove(color_placing)


def color_placing():
    """
    Draw the green rectangle via OpenGL-Wrapper
    """
    imageHeight = windowHeight * 0.05
    imageWidth = imageHeight

    x = windowWidth * 0.5 - imageWidth/2
    y = windowHeight * 0.5 - imageHeight/2
    
    gl_position = [[x, y],[x+imageWidth, y],[x+imageWidth, y+imageHeight],[x, y+imageHeight]]
    
    view_buf = bgl.Buffer(bgl.GL_INT, 4)
    bgl.glGetIntegerv(bgl.GL_VIEWPORT, view_buf)
    view = view_buf.to_list() if hasattr(view_buf, "to_list") else view_buf.list
    # Save the state
    bgl.glPushAttrib(bgl.GL_ALL_ATTRIB_BITS)      
    # Disable depth test so we always draw over things
    bgl.glDisable(bgl.GL_DEPTH_TEST)   
    # Disable lighting so everything is shadless
    bgl.glDisable(bgl.GL_LIGHTING)   
    # Make sure we're using smooth shading instead of flat
    bgl.glShadeModel(bgl.GL_SMOOTH)
    # Setup the matrices
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glPushMatrix()
    bgl.glLoadIdentity()
    bgl.gluOrtho2D(0, view[2], 0, view[3])
    bgl.glMatrixMode(bgl.GL_MODELVIEW)
    bgl.glPushMatrix()
    bgl.glLoadIdentity()
    
    
    # Enable alpha blending
    bgl.glEnable(bgl.GL_BLEND)
    bgl.glBlendFunc(bgl.GL_SRC_ALPHA, bgl.GL_ONE_MINUS_SRC_ALPHA)
    # Draw the colored quad
    bgl.glColor4f(0, 1, 0, 0.25)
    bgl.glEnable(bgl.GL_POLYGON_OFFSET_FILL)
    bgl.glPolygonOffset(1.0, 1.0)
    bgl.glBegin(bgl.GL_QUADS)
    for i in range(4):
       bgl.glTexCoord2f(texco[i][0], texco[i][1])
       bgl.glVertex2f(gl_position[i][0], gl_position[i][1])
    bgl.glEnd()

    bgl.glPopMatrix()
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glPopMatrix()
    bgl.glPopAttrib()

    
def write_interaction_status():
    """
    Write the interaction status on Screen
    The status is stored in a property
    """
    cam = blenderapi.scene().active_camera

    # get the suffix of the human to reference the right objects
    suffix = cam.name[-4:] if cam.name[-4] == "." else ""
    
    hand = objects['Hand_Grab.R' + suffix]
    
    # OpenGL setup
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glLoadIdentity()
    bgl.gluOrtho2D(0, windowWidth, 0, windowHeight)
    bgl.glMatrixMode(bgl.GL_MODELVIEW)
    bgl.glLoadIdentity()
    
    blf.size(font_id, int(windowHeight*0.04), 72)
    # draw a black shadow around the text
    blf.enable(font_id, blf.SHADOW)
    blf.shadow(font_id, 5, 0.0, 0.0, 0.0, 1.0)
    blf.position(font_id, windowWidth*0.4, windowHeight*0.4,0)
    blf.draw(font_id, hand['Status'])

def status_image():
    """
    Show the corrensponding Image for the status
    """
    imageHeight = windowHeight * 0.075
    imageWidth = imageHeight

    x = windowWidth * 0.35 - imageWidth/2
    y = windowHeight * 0.45 - imageHeight/2
    
    gl_position = [[x, y],[x+imageWidth, y],[x+imageWidth, y+imageHeight],[x, y+imageHeight]]

    cam = blenderapi.scene().active_camera

    # get the suffix of the human to reference the right objects
    suffix = cam.name[-4:] if cam.name[-4] == "." else ""

    hand = objects['Hand_Grab.R' + suffix]

    # select the right Image
    if hand["selected"]:
        tex_id = closed_id
    else:
        tex_id = open_id

    
    view_buf = bgl.Buffer(bgl.GL_INT, 4)
    bgl.glGetIntegerv(bgl.GL_VIEWPORT, view_buf)
    view = view_buf.to_list() if hasattr(view_buf, "to_list") else view_buf.list
    # Save the state
    bgl.glPushAttrib(bgl.GL_ALL_ATTRIB_BITS)      
    # Disable depth test so we always draw over things
    bgl.glDisable(bgl.GL_DEPTH_TEST)   
    # Disable lighting so everything is shadless
    bgl.glDisable(bgl.GL_LIGHTING)   
    # Unbinding the texture prevents BGUI frames from somehow picking up on
    # color of the last used texture
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, 0)      
    # Make sure we're using smooth shading instead of flat
    bgl.glShadeModel(bgl.GL_SMOOTH)
    # Setup the matrices
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glPushMatrix()
    bgl.glLoadIdentity()
    bgl.gluOrtho2D(0, view[2], 0, view[3])
    bgl.glMatrixMode(bgl.GL_MODELVIEW)
    bgl.glPushMatrix()
    bgl.glLoadIdentity()
    
    
    bgl.glEnable(bgl.GL_TEXTURE_2D)
    # Enable alpha blending
    bgl.glEnable(bgl.GL_BLEND)
    bgl.glBlendFunc(bgl.GL_SRC_ALPHA, bgl.GL_ONE_MINUS_SRC_ALPHA)
    # Bind the texture
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, tex_id)
    # Draw the textured quad
    bgl.glColor4f(1, 1, 1, 1)
    bgl.glEnable(bgl.GL_POLYGON_OFFSET_FILL)
    bgl.glPolygonOffset(1.0, 1.0)
    bgl.glBegin(bgl.GL_QUADS)
    for i in range(4):
       bgl.glTexCoord2f(texco[i][0], texco[i][1])
       bgl.glVertex2f(gl_position[i][0], gl_position[i][1])
    bgl.glEnd()
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, 0)

    bgl.glPopMatrix()
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glPopMatrix()
    bgl.glPopAttrib()

def crosshairs():
    """
    Show crosshais in Manipulation Mode
    Use the OpenGL-Wrapper to draw the image
    """
    
    imageHeight = windowHeight * 0.05
    imageWidth = imageHeight

    x = windowWidth * 0.5 - imageWidth/2
    y = windowHeight * 0.5 - imageHeight/2
    
    gl_position = [[x, y],[x+imageWidth, y],[x+imageWidth, y+imageHeight],[x, y+imageHeight]]
    
    view_buf = bgl.Buffer(bgl.GL_INT, 4)
    bgl.glGetIntegerv(bgl.GL_VIEWPORT, view_buf)
    view = view_buf.to_list() if hasattr(view_buf, "to_list") else view_buf.list
    # Save the state
    bgl.glPushAttrib(bgl.GL_ALL_ATTRIB_BITS)      
    # Disable depth test so we always draw over things
    bgl.glDisable(bgl.GL_DEPTH_TEST)   
    # Disable lighting so everything is shadless
    bgl.glDisable(bgl.GL_LIGHTING)   
    # Unbinding the texture prevents BGUI frames from somehow picking up on
    # color of the last used texture
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, 0)      
    # Make sure we're using smooth shading instead of flat
    bgl.glShadeModel(bgl.GL_SMOOTH)
    # Setup the matrices
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glPushMatrix()
    bgl.glLoadIdentity()
    bgl.gluOrtho2D(0, view[2], 0, view[3])
    bgl.glMatrixMode(bgl.GL_MODELVIEW)
    bgl.glPushMatrix()
    bgl.glLoadIdentity()
    
    bgl.glEnable(bgl.GL_TEXTURE_2D)
    # Enable alpha blending
    bgl.glEnable(bgl.GL_BLEND)
    bgl.glBlendFunc(bgl.GL_SRC_ALPHA, bgl.GL_ONE_MINUS_SRC_ALPHA)
    # Bind the texture
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, crosshairs_id)
    # Draw the textured quad
    bgl.glColor4f(1, 1, 1, 1)
    bgl.glEnable(bgl.GL_POLYGON_OFFSET_FILL)
    bgl.glPolygonOffset(1.0, 1.0)
    bgl.glBegin(bgl.GL_QUADS)
    for i in range(4):
       bgl.glTexCoord2f(texco[i][0], texco[i][1])
       bgl.glVertex2f(gl_position[i][0], gl_position[i][1])
    bgl.glEnd()
    bgl.glBindTexture(bgl.GL_TEXTURE_2D, 0)

    bgl.glPopMatrix()
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glPopMatrix()
    bgl.glPopAttrib()


########NEW FILE########
__FILENAME__ = limit_hand_control
from morse.core import blenderapi
import math


def limit(cont):
    """
    Limit the hand's location to a sphere (radius 0.7) around the shoulder
    """
    ow = cont.owner
    
    # get the suffix of the human to reference the right objects
    suffix = ow.name[-4:] if ow.name[-4] == "." else ""

    limitY = cont.actuators['LimitLocY']
    sobList =  blenderapi.scene().objects
    shoulder = sobList['Shoulder_Empty.R' + suffix]
    human = ow.parent
    
    
    try:
        if human['Manipulate']:
            limitY.min = -math.sqrt(0.7**2 - (shoulder.worldPosition[2] -
                                              ow.worldPosition[2])**2)

            limitY.max = -limitY.min
            cont.activate(limitY)
        
        else:
            cont.deactivate(limitY)
    except ValueError:
        pass

########NEW FILE########
__FILENAME__ = show_objects
import logging; logger = logging.getLogger("morse." + __name__)

from morse.core import blenderapi
import bgl
import blf

from morse.helpers import passive_objects

font_id =0

co = blenderapi.controller()
keyboard = co.sensors['All_Keys']

scene = blenderapi.scene()

windowWidth = blenderapi.render().getWindowWidth()
windowHeight = blenderapi.render().getWindowHeight()

def write():
    """
    Write the name of all active objects on Screen
    """
    # OpenGL setup
    bgl.glMatrixMode(bgl.GL_PROJECTION)
    bgl.glLoadIdentity()
    bgl.gluOrtho2D(0, windowWidth, 0, windowHeight)
    bgl.glMatrixMode(bgl.GL_MODELVIEW)
    bgl.glLoadIdentity()
    
    cam = scene.active_camera

    for obj in passive_objects.active_objects():
        # test if the object is in the view frustum
        if cam.pointInsideFrustum(obj.worldPosition):
            pos = cam.getScreenPosition(obj)
    
            blf.size(font_id, int(windowWidth * 0.02), 72)
            # draw a black shadow to increase contrast with white parts
            blf.enable(font_id, blf.SHADOW)
            blf.shadow(font_id, 5, 0.0, 0.0, 0.0, 1.0)
            blf.position(font_id, pos[0]*windowWidth, (1 - pos[1])*windowHeight,0)
            blf.draw(font_id, obj.name)


def test(contr):
    """
    Show which objects are interactable
    """
    keylist = keyboard.events

    for key in keylist:
        if key[0] == blenderapi.LEFTALTKEY:
            if key[1] == blenderapi.input_just_activated():
                #show text over all objects
                scene.post_draw.append(write)
                
            elif key[1] == blenderapi.input_just_released():
                #hide text of all objects
                scene.post_draw.remove(write)
                


########NEW FILE########
__FILENAME__ = lights
from morse.core import blenderapi

def change_light_energy():
    co = blenderapi.controller()
    ow = co.owner
    
    ow.energy = ow['Energy'] if ow['On'] else 0

########NEW FILE########
__FILENAME__ = main
import logging; logger = logging.getLogger("morse." + __name__)
from morse.helpers.morse_logging import SECTION, ENDSECTION
import sys
import os
import imp

# Force the full import of blenderapi so python computes correctly all
# values in its  namespace
import morse.core.blenderapi

# force a reload, since 'blenderapi' may have been already loaded
# *outside* the GameEngine
imp.reload(morse.core.blenderapi)
persistantstorage = morse.core.blenderapi.persistantstorage()

# The service management
from morse.core.services import MorseServices
from morse.core.sensor import Sensor
from morse.core.actuator import Actuator
from morse.core.modifier import register_modifier
from morse.helpers.loading import create_instance, create_instance_level
from morse.core.morse_time import TimeStrategies
from morse.core.zone import ZoneManager

# Override the default Python exception handler
sys_excepthook = sys.excepthook
def morse_excepthook(*args, **kwargs):
    logger.error("[ERROR][MORSE] Uncaught exception, quit Blender.", exc_info = tuple(args))
    sys_excepthook(*args, **kwargs)
    import os
    os._exit(-1)

# Uncaught exception quit BGE
sys.excepthook = morse_excepthook

# Constants for stream directions
IN = 'IN'
OUT = 'OUT'

# The file component_config.py is at the moment included
#  in the .blend file of the scene
try:
    import component_config
except ImportError as detail:
    logger.warning("%s.\nNo datastream/services/modifiers will be configured."
                    "\nMake sure the script 'component_config.py' is present"
                    "in the .blend file." % detail)

MULTINODE_SUPPORT = False
# The file multinode_config.py is at the moment included
#  in the .blend file of the scene
# Used to setup the multinode information
try:
    import multinode_config
    MULTINODE_SUPPORT = True
except ImportError as detail:
    logger.info("No multi-node scene configuration file found. "
                "Multi-node support disabled.")

from morse.core.exceptions import MorseServiceError

def no_op():
    pass

def _associate_child_to_robot(obj, robot_instance, unset_default):
    """ Reference the link of all obj to their associated robot_instance.
        If it is an external robot_instance, unset default_action
    """
    # Create an empty list for the components of this robot
    robot_instance.components = []
    for child in obj.childrenRecursive:
        try:
            # Look for the components tagged as such
            child['Component_Tag']
        except KeyError:
            continue

        robot_instance.components.append(child)

        if not 'classpath' in child:
            logger.error("No 'classpath' in child %s\n  Please make sure you "
                         "are using the new builder classes"%str(child.name))
            return False
        # Create an instance of the component class
        #  and add it to the component list of persistantstorage()
        instance = create_instance_level(child['classpath'],
                                         child.get('abstraction_level'),
                                         child, robot_instance)
        if instance:
            persistantstorage.componentDict[child.name] = instance
        else:
            logger.error("INITIALIZATION ERROR: the component '%s'"
                         " could not be properly initialized. Error when "
                         "creating the class instance", obj.name)
            return False

        # Unset the default action of components of external robots
        if unset_default:
            instance.default_action = no_op
            logger.info("Component " + child.name + " disabled: parent "  \
                                     + obj.name + " is an External robot.")
        else:
            logger.info("Component %s %s added to %s" %
                        (child.name, 
                         "(level: %s)" % child.get("abstraction_level") \
                                 if child.get("abstraction_level") else "",
                         obj.name)
                       )

    return True

# Create a list of the robots in the scene
def create_dictionaries ():
    """Creation of a list of all the robots and components in the scene.
       Uses the properties of the objects to determine what they are."""

    # Create a dictionary that stores initial positions of all objects
    # in the simulation, used to reset the simulation.
    persistantstorage.blender_objects = {}

    # Create a dictionary of the components in the scene
    persistantstorage.componentDict = {}

    # Create a dictionary of the robots in the scene
    persistantstorage.robotDict = {}

    # Create a dictionary of the external robots in the scene
    # Used for the multi-node simulation
    persistantstorage.externalRobotDict = {}

    # Create a dictionnary with the passive, but interactive (ie, with an
    # 'Object' property) objects in the scene.
    persistantstorage.passiveObjectsDict = {}

    # Create a dictionary with the modifiers
    persistantstorage.modifierDict = {}

    # Create a dictionary with the datastream interfaces used
    persistantstorage.datastreamDict = {}

    # this dictionary stores, for each components, the direction and the
    # configured datastream interfaces. Direction is 'IN' for streams
    # that are read by MORSE (typically, for actuators), and 'OUT'
    # for streams published by MORSE (typically, for sensors)
    persistantstorage.datastreams = {}

    # Create a dictionnary with the overlaid used
    persistantstorage.overlayDict = {}

    # Create a dictionnary for the 'service object', such as supervision
    persistantstorage.serviceObjectDict = {}

    # Create the 'request managers' manager
    persistantstorage.morse_services = MorseServices()

    # Create the zone manager
    persistantstorage.zone_manager = ZoneManager()

    scene = morse.core.blenderapi.scene()

    # Store the position and orientation of all objects
    for obj in scene.objects:
        if obj.parent is None:
            import mathutils
            pos = mathutils.Vector(obj.worldPosition)
            ori = mathutils.Matrix(obj.worldOrientation)
            persistantstorage.blender_objects[obj] = [pos, ori]

    # Get the list of passive interactive objects.

    # These objects have a 'Object' property set to true
    # (plus several other optional properties).
    # See the documentation for the up-to-date list
    # (doc/morse/user/others/passive_objects.rst) -- or read the code below :-)
    for obj in scene.objects:
        # Check the object has an 'Object' property set to true
        if 'Object' in obj and obj['Object']:
            details = {
                       'label': obj['Label'] if 'Label' in obj else str(obj),
                       'description': obj['Description'] if 'Description' in obj else "",
                       'type': obj['Type'] if 'Type' in obj else "Object",
                       'graspable': obj['Graspable'] if 'Graspable' in obj else False
                      }
            persistantstorage.passiveObjectsDict[obj] = details
            logger.info("Added {name} as a {graspable}active object".format(
                                 name = details['label'],
                                 graspable = "graspable " if details['graspable'] else ""))

    if not persistantstorage.passiveObjectsDict:
        logger.info("No passive objects in the scene.")

    # Get the robots
    for obj in scene.objects:
        if 'Robot_Tag' in obj or 'External_Robot_Tag' in obj:
            if not 'classpath' in obj:
                logger.error("No 'classpath' in %s\n  Please make sure you are "
                             "using the new builder classes"%str(obj.name))
                return False
            # Create an object instance and store it
            instance = create_instance_level(obj['classpath'], 
                                             obj.get('abstraction_level'),
                                             obj)

            if not instance:
                logger.error("Could not create %s"%str(obj['classpath']))
                return False
            # store instance in persistant storage dictionary
            if 'Robot_Tag' in obj:
                persistantstorage.robotDict[obj] = instance
            else:
                persistantstorage.externalRobotDict[obj] = instance

    if not (persistantstorage.robotDict or
            persistantstorage.externalRobotDict): # No robot!
        logger.error("INITIALIZATION ERROR: no robot in your simulation!"
                     "Do not forget that components _must_ belong to a"
                     "robot (you can not have free objects)")
        return False

    # Get the zones
    for obj in scene.objects:
        if 'Zone_Tag' in obj:
            persistantstorage.zone_manager.add(obj)
    
    # Get the robot and its instance
    for obj, robot_instance in persistantstorage.robotDict.items():
        if not _associate_child_to_robot(obj, robot_instance, False):
            return False
    
    # Get the external robot and its instance
    for obj, robot_instance in persistantstorage.externalRobotDict.items():
        if not _associate_child_to_robot(obj, robot_instance, True):
            return False
  
    # Check we have no 'free' component (they all must belong to a robot)
    for obj in scene.objects:
        try:
            obj['Component_Tag']
            if obj.name not in persistantstorage.componentDict.keys():
                logger.error("INITIALIZATION ERROR: the component '%s' "
                             "does not belong to any robot: you need to fix "
                             "that by parenting it to a robot." % obj.name)
                return False
        except KeyError as detail:
            pass
    
    # Will return true always (for the moment)
    return True


def check_dictionaries():
    """ Print the contents of the robot and component dictionaries."""
    logger.info ("")
    logger.info("------------------------------------")
    logger.info("-        SIMULATION SUMMARY        -")
    logger.info("------------------------------------")
    logger.info("Robots in the simulation:")
    for obj, robot_instance in persistantstorage.robotDict.items():
        logger.info("\tROBOT: '{0}'".format(obj))
        for component in robot_instance.components:
            logger.info ("\t\t- Component: '{0}'".format(component))

    if MULTINODE_SUPPORT:
        logger.info ("External robots (from other simulation nodes):")
        for obj, robot_position in persistantstorage.externalRobotDict.items():
            logger.info ("\tROBOT: '{0}'".format(obj))

    logger.info ("Available services:")

    if persistantstorage.morse_services.request_managers():
        for name, instance in persistantstorage.morse_services.request_managers().items():
            logger.info ("\t- Interface {0}".format(name))
            for component, service in instance.services().items():
                logger.info ("\t\t- %s: %s" % (component,service))

    else:
        logger.info ("\tNone")

    logger.info ("Modifiers in use:")
    if persistantstorage.modifierDict:
        for obj, modifier_variables in persistantstorage.modifierDict.items():
            logger.info ("\t- '{0}'".format(obj))
    else:
        logger.info ("\tNone")


    logger.info ("")

    if persistantstorage.datastreamDict:
        logger.info ("Datastream interfaces configured:")
        for obj, datastream_variables in persistantstorage.datastreamDict.items():
            logger.info ("\t- '{0}'".format(obj))

    logger.info("------------------------------------")
    logger.info ("")


def get_components_of_type(classname):
    components = []
    for component in persistantstorage.componentDict.values():
        logger.debug("Get component for class " + component.name() + ": " + component.__class__.__name__)
        if component.__class__.__name__ == classname:
            components.append(component)
    
    return components


def get_datastream_of_type(classname):
    for datastream_instance in persistantstorage.datastreamDict.values():
        if datastream_instance.__class__.__name__ == classname:
            return datastream_instance
    return None
    

def link_datastreams():
    """ Read the configuration script (inside the .blend file)
        and assign the correct datastream and options to each component. """
    try:
        component_list = component_config.component_datastream
    except (AttributeError, NameError) as detail:
        # Exit gracefully if there are no datastream specified
        logger.info ("No datastream section found in configuration file.")
        return True

    #for component_name, datastream_data in component_list.items():
    for component_name, datastream_list in component_list.items():
        # Get the instance of the object
        try:
            instance = persistantstorage.componentDict[component_name]
        except KeyError as detail:
            logger.error ("Component listed in component_config.py not found "
                          "in scene: %s" % detail)
            logger.error("INITIALIZATION ERROR: your configuration file is "
                         " not valid. Please check the name of your components "
                         " and restart the simulation.")
            return False

        # Do not configure middlewares for components that are external,
        #  that is, they are handled by another node.
        try:
            instance.robot_parent.bge_object['Robot_Tag']
            # If the robot is external, it will have the 'External_Robot_Tag'
            #  instead, and this test will fail
        except KeyError as detail:
            # Skip the configuration of this component
            continue

        # If the list contains only strings, insert the list inside another one.
        # This is done for backwards compatibility with the previous
        #  syntax that allowed only one middleware per component
        if isinstance (datastream_list[0], str):
            datastream_list = [datastream_list]

        # What is the direction of our stream?
        # -> for Sensors, they *publish*,
        # -> for Actuator, they *read*
        if isinstance(instance, Sensor):
            direction = OUT
        elif isinstance(instance, Actuator):
            direction = IN
        else:
            assert False

        persistantstorage.datastreams[component_name] = (direction, 
                                     [d[0] for d in datastream_list])

        # Register all datastream's in the list
        for datastream_data in datastream_list:

            datastream_name = datastream_data[0]
            logger.info("Component: '%s' using datastream '%s'" % (component_name, datastream_name))
            found = False
            missing_component = False
            
            # Look for the listed datastream in the dictionary of active datastream's
            for datastream_obj, datastream_instance in persistantstorage.datastreamDict.items():
                logger.debug("Looking for '%s' in '%s'" % (datastream_name, datastream_obj))
                if datastream_name in datastream_obj:
                    found = True
                    # Make the datastream object take note of the component
                    break

            if not found:
                datastream_instance = create_instance(datastream_name)
                if datastream_instance is not None:
                    persistantstorage.datastreamDict[datastream_name] = datastream_instance
                    logger.info("\tDatastream interface '%s' created" % datastream_name)
                else:
                    logger.error("INITIALIZATION ERROR: Datastream '%s' module"
                                 " could not be found! \n"
                                 " Could not import modules required for the "
                                 "desired datastream interface. Check that "
                                 "they can be found inside your PYTHONPATH "
                                 "variable.")
                    return False
            
            datastream_instance.register_component(component_name, instance, datastream_data)
            
    # Will return true always (for the moment)
    return True


def link_services():
    """ Read the configuration script (inside the .blend file)
        and assign the correct service handlers and options to each component.
    """
    try:
        component_list = component_config.component_service
    except (AttributeError, NameError) as detail:
        # Exit gracefully if there are no services specified
        logger.info("No service section found in configuration file.")
        return True

    for component_name, request_manager_data in component_list.items():
        # Get the instance of the object
        
        if component_name == "simulation": # Special case for the pseudo-component 'simulation'
            continue

        try:
            instance = persistantstorage.componentDict[component_name]
        except KeyError as detail:
            try:
                scene = morse.core.blenderapi.scene()
                robot_obj = scene.objects[component_name]
                instance = persistantstorage.robotDict[robot_obj]

            except KeyError as detail:
                logger.error("Component listed in component_config.py "
                             "not found in scene: %s" % detail)
                logger.error("INITIALIZATION ERROR: the component_services "
                             "section of your configuration file is not valid."
                             "Please check the name of your components and "
                             "restart the simulation.")
                return False

        for request_manager in request_manager_data:
            # Load required request managers
            if not persistantstorage.morse_services.add_request_manager(request_manager):
                return False
            
            persistantstorage.morse_services.register_request_manager_mapping(component_name, request_manager)
            instance.register_services()
            logger.info("Component: '%s' using middleware '%s' for services" %
                        (component_name, request_manager))
    
    return True


def load_overlays():
    """ Read and initialize overlays from the configuration script.
    """
    
    try:
        overlays_list = component_config.overlays
    except (AttributeError, NameError) as detail:
        # Exit gracefully if there are no services specified
        logger.info("No overlay section found in configuration file.")
        return True

    for request_manager_name, overlays in overlays_list.items():
        for overlaid_name, overlay_details in overlays.items():
            overlay_name, kwargs = overlay_details

            try:
                overlaid_object = persistantstorage.componentDict[overlaid_name]
            except KeyError:
                logger.error("Could not find the object to overlay: %s." %
                              overlaid_name)
                return False

            # Instanciate the overlay, passing the overlaid object to
            # the constructor + any optional arguments
            instance = create_instance(overlay_name, overlaid_object, **kwargs)
            persistantstorage.morse_services.register_request_manager_mapping(
                    instance.name(), request_manager_name)
            instance.register_services()
            persistantstorage.overlayDict[overlay_name] = instance
            logger.info("Component '%s' overlaid with '%s' using middleware "
                        "'%s' for services" %
                        (overlaid_object.name(),
                         overlay_name,
                         request_manager_name))
    return True


def add_modifiers():
    """ Read the configuration script (inside the .blend file)
        and assign the correct data modifiers to each component. """
    try:
        component_list = component_config.component_modifier
    except (AttributeError, NameError) as detail:
        # Exit gracefully if there are no modifiers specified
        logger.info("No modifiers section found in configuration file")
        return True

    for component_name, mod_list in component_list.items():
        # Get the instance of the object
        try:
            instance = persistantstorage.componentDict[component_name]
        except KeyError as detail:
            logger.warning("Component listed in component_config.py not "
                           "found in scene: %s" % detail)
            continue

        for mod_data in mod_list:
            modifier_name = mod_data[0]
            logger.info("Component: '%s' operated by '%s'" %
                        (component_name, modifier_name))
            # Make the modifier object take note of the component
            modifier_instance = register_modifier(modifier_name, instance,
                                                  mod_data[1])
            if not modifier_instance:
                return False
            persistantstorage.modifierDict[modifier_name] = modifier_instance

    return True

def init_multinode():
    """
    Initializes the MORSE node in a Multinode configuration.
    """
    logger.log(SECTION, 'MULTINODE INITIALIZATION')
    # Configuration for the multi-node simulation
    try:
        protocol = multinode_config.node_config["protocol"]
    except (NameError, AttributeError) as detail:
        protocol = "socket"

    # Get the correct class reference according to the chosen protocol
    if protocol == "socket":
        classpath = "morse.multinode.socket.SocketNode"
    elif protocol == "hla":
        classpath = "morse.multinode.hla.HLANode"

    try:
        server_address = multinode_config.node_config["server_address"]
        server_port = int(multinode_config.node_config["server_port"])
    except (NameError, AttributeError) as detail:
        logger.warning("No node configuration found. Using default values for "
                       "this simulation node.\n\tException: ", detail)
        server_address = "localhost"
        server_port = 65000

    try:
        node_name = multinode_config.node_config["node_name"]
    except (NameError, AttributeError) as detail:
        logger.warning("No node name defined. Using host name.\n"
                        "\tException: ", detail)
        node_name = os.uname()[1]

    logger.info ("This is node '%s'" % node_name)
    # Create the instance of the node class

    persistantstorage.node_instance = create_instance(classpath,
                                                      node_name, server_address, server_port)

def init(contr):
    """ General initialization of MORSE

    Here, all components, modifiers and middlewares are initialized.
    """
    
    init_logging()

    logger.log(SECTION, 'PRE-INITIALIZATION')
    # Get the version of Python used
    # This is used to determine also the version of Blender
    persistantstorage.pythonVersion = sys.version_info
    logger.info ("Python Version: %s.%s.%s" %
                    persistantstorage.pythonVersion[:3])
    logger.info ("Blender Version: %s.%s.%s" % morse.core.blenderapi.version())
    logger.info  ("Python path: %s" % sys.path)
    logger.info ("PID: %d" % os.getpid())

    persistantstorage.morse_initialised = False
    persistantstorage.time = TimeStrategies.make(morse.core.blenderapi.getssr()['time_management'])
    persistantstorage.current_time = persistantstorage.time.time
    # Variable to keep trac of the camera being used
    persistantstorage.current_camera_index = 0

    init_ok = True
    init_ok = init_ok and create_dictionaries()

    logger.log(SECTION, 'SUPERVISION SERVICES INITIALIZATION')
    init_ok = init_ok and init_supervision_services()


    logger.log(SECTION, 'SCENE INITIALIZATION')

    if MULTINODE_SUPPORT:
        init_multinode()

    init_ok = init_ok and link_services()
    init_ok = init_ok and add_modifiers()
    init_ok = init_ok and link_datastreams()
    init_ok = init_ok and load_overlays()

    if init_ok:
        check_dictionaries()
        persistantstorage.morse_initialised = True
        logger.log(ENDSECTION, 'SCENE INITIALIZED')
    else:
        logger.critical('INITIALIZATION FAILED!')
        logger.info("Exiting now.")
        contr = morse.core.blenderapi.controller()
        close_all(contr)
        quit(contr)
    
    # Set the default value of the logic tic rate to 60
    #bge.logic.setLogicTicRate(60.0)
    #bge.logic.setPhysicsTicRate(60.0)

def init_logging():
    from morse.core.ansistrm import ColorizingStreamHandler
    
    if "with-colors" in sys.argv:
        if "with-xmas-colors" in sys.argv:
            ch = ColorizingStreamHandler(scheme = "xmas")
        elif "with-reverse-colors" in sys.argv:
            ch = ColorizingStreamHandler(scheme = "dark")
        else:
            ch = ColorizingStreamHandler()
        
    else:
        ch = ColorizingStreamHandler(scheme = "mono")
    
    from morse.helpers.morse_logging import MorseFormatter
    # create logger
    logger = logging.getLogger('morse')
    logger.setLevel(logging.INFO)

    # create console handler and set level to debug
    
    ch.setLevel(logging.DEBUG)

    # create formatter
    formatter = MorseFormatter('%(message)s')

    # add formatter to ch
    ch.setFormatter(formatter)

    # add ch to logger
    logger.addHandler(ch)

def init_supervision_services():
    """ This method first loads the socket service manager, map the
    virtual 'simulation' component to it, loads any other request
    manager mapped to the 'simulation' component and register all
    simulation management services declared in
    :py:mod:`morse.core.supervision_services` 
    """

    from morse.services.supervision_services import Supervision
    from morse.services.communication_services import Communication
    from morse.services.time_services import TimeServices

    simulation_service = Supervision()
    communication_service = Communication()
    time_service= TimeServices()

    persistantstorage.serviceObjectDict[simulation_service.name()] = simulation_service
    persistantstorage.serviceObjectDict[communication_service.name()] = communication_service
    persistantstorage.serviceObjectDict[time_service.name()] = time_service

    # For each entries of serviceObjects, register the service as
    # requested by configuration + socket middleware i/o.
    try:
        for key, services in persistantstorage.serviceObjectDict.items():
            request_managers = component_config.component_service.get(key, [])
            request_managers.append("morse.middleware.socket_request_manager.SocketRequestManager")

            for request_manager in request_managers:
                try:
                    # Load required request managers
                    if not persistantstorage.morse_services.add_request_manager(request_manager):
                        return False

                    persistantstorage.morse_services.register_request_manager_mapping(key, request_manager)
                    logger.info("Adding '%s' to the middlewares for %s "
                                "control" % (request_manager, key))
                except MorseServiceError as e:
                    #...no request manager :-(
                    logger.critical(str(e))
                    logger.critical("SUPERVISION SERVICES INITIALIZATION FAILED")
                    return False

            services.register_services()

    except (AttributeError, NameError, KeyError):
        # Nothing to declare: skip to the next step.
        pass

    logger.log(ENDSECTION, "SUPERVISION SERVICES INITIALIZED")
    return True


def simulation_main(contr):
    """ This method is called at every simulation step.

    We do here all homeworks to manage the simulation at whole.
    """
    # Update the time variable
    try:
        persistantstorage.time.update()
        persistantstorage.current_time = persistantstorage.time.time
    except AttributeError:
        # If the 'base_clock' variable is not defined, there probably was
        #  a problem while doing the init, so we'll abort the simulation.
        logger.critical("INITIALIZATION ERROR: failure during initialization "
                        "of the simulator. Check the terminal for error "
                        "messages, and report them on the morse-dev@laas.fr "
                        "mailing list.")
        quit(contr)

    if 'serviceObjectDict' in persistantstorage:
        for ob in persistantstorage.serviceObjectDict.values():
            ob.action()

    if "morse_services" in persistantstorage:
        # let the service managers process their inputs/outputs
        persistantstorage.morse_services.process()
    
    if MULTINODE_SUPPORT:
        # Register the locations of all the robots handled by this node
        persistantstorage.node_instance.synchronize()


def switch_camera(contr):
    """ Cycle through the cameras in the scene during the game.
    """
    sensor = contr.sensors['F9_KEY']
    # Activate only once for each key press
    if sensor.positive and sensor.triggered:
        scene = morse.core.blenderapi.scene()
        index = persistantstorage.current_camera_index
        next_camera = scene.cameras[index]
        scene.active_camera = next_camera
        logger.info("Showing view from camera: '%s'" % next_camera.name)
        # Disable mouse cursor for Human camera
        if next_camera.name == "Human_Camera":
            morse.core.blenderapi.mousepointer(visible = False)
        else:
            morse.core.blenderapi.mousepointer(visible = True)
        # Update the index for the next call
        index = (index + 1) % len(scene.cameras)
        persistantstorage.current_camera_index = index


def close_all(contr):
    """ Close the open communication channels from middlewares
    Call the destructors of all component instances. This should also call
    the methods to close middlewares
    """
    logger.log(ENDSECTION, 'COMPONENTS FINALIZATION')
    # Force the deletion of the sensor objects
    if 'componentDict' in persistantstorage:
        for component_instance in persistantstorage.componentDict.values():
            component_instance.finalize()

    # Force the deletion of the robot objects
    if 'robotDict' in persistantstorage:
        for robot_instance in persistantstorage.robotDict.values():
           robot_instance.finalize() 

    logger.log(ENDSECTION, 'CLOSING REQUEST MANAGERS...')
    del persistantstorage.morse_services
    del persistantstorage.serviceObjectDict

    logger.log(ENDSECTION, 'CLOSING DATASTREAMS...')
    # Force the deletion of the datastream objects
    if 'datastreamDict' in persistantstorage:
        for obj, datastream_instance in persistantstorage.datastreamDict.items():
            if datastream_instance:
                import gc # Garbage Collector
                logger.debug("At closing time, %s has %s references" %
                        (datastream_instance,
                         gc.get_referents(datastream_instance)))
                del obj

    logger.log(ENDSECTION, 'CLOSING OVERLAYS...')
    del persistantstorage.overlayDict

    if MULTINODE_SUPPORT:
        logger.log(ENDSECTION, 'CLOSING MULTINODE...')
        persistantstorage.node_instance.finalize()


def finish(contr):
    """ Normal exit from the Game Engine, when pressing ESC key """
    sensor = contr.sensors['ESC_KEY']

    #execute only when the ESC key is released (if we don't test that,
    #the code get executed two time, when pressed, and when released)
    if not sensor.positive and sensor.triggered:
        close_all(contr)
        quit(contr)


def restart(contr):
    """ Call the Game Engine restart funcionality * DOES NOT WORK * """
    sensor = contr.sensors['F11_KEY']

    # Execute only when the F11 key is released (if we don't test that,
    #  the code get executed two times, when pressed, and when released)
    if not sensor.positive and sensor.triggered:

        logger.warning("Replacing everything at initial position")
        reset_objects(contr)
        return


def quit(contr):
    """ Exit graciously from the simulation """
    logger.log(ENDSECTION, 'EXITING SIMULATION')

    quitActuator = contr.actuators['Quit_sim']
    contr.activate(quitActuator)


def reset_objects(contr):
    """ Place all objects in the initial position

    Restore the position and rotation of objects and robots
    to their original state, during the simulation.
    """
    for b_obj, state in persistantstorage.blender_objects.items():
        # Stop physics simulation
        b_obj.suspendDynamics()
        b_obj.setLinearVelocity([0.0, 0.0, 0.0], True)
        b_obj.setAngularVelocity([0.0, 0.0, 0.0], True)
        b_obj.applyForce([0.0, 0.0, 0.0], True)
        b_obj.applyTorque([0.0, 0.0, 0.0], True)

        logger.debug("%s goes to %s" % (b_obj, state[0]))
        b_obj.worldPosition = state[0]
        b_obj.worldOrientation = state[1]
        # Reset physics simulation
        b_obj.restoreDynamics()

########NEW FILE########
__FILENAME__ = mocap_human_control
import logging; logger = logging.getLogger("morse." + __name__)

######################################################
#
#    mocap_human_control.py        Blender 2.61
#
#    Modified version of
#      human_control.py by Michael Karg
#
#    Gilberto Echeverria
#    09 / 07 / 2012
#
######################################################

import math
from morse.core import blenderapi

def move(contr):
    """ Read the keys for specific combinations
        that will make the camera move in 3D space. """
    # get the object this script is attached to
    human = contr.owner

    # set the movement speed
    speed = human['Speed']

    # Get sensor named Mouse
    keyboard = contr.sensors['All_Keys']

    # Default movement speed
    move_speed = [0.0, 0.0, 0.0]
    rotation_speed = [0.0, 0.0, 0.0]

    keylist = keyboard.events
    for key in keylist:
        if key[1] == blenderapi.input_active():
            if key[0] == blenderapi.IKEY:
                move_speed[0] = speed
            elif key[0] == blenderapi.KKEY:
                move_speed[0] = -speed
            elif key[0] == blenderapi.JKEY:
                rotation_speed[2] = speed
            elif key[0] == blenderapi.LKEY:
                rotation_speed[2] = -speed
            elif key[0] == blenderapi.UKEY:
                move_speed[1] = speed
            elif key[0] == blenderapi.OKEY:
                move_speed[1] = -speed

            # The second parameter of 'applyMovement' determines
            #  a movement with respect to the object's local
            #  coordinate system
            human.applyMovement( move_speed, True )
            human.applyRotation( rotation_speed, True )

        """
        elif key[1] == blenderapi.input_just_activated():
            # Other actions activated with the keyboard
            # Reset camera to center
            if key[0] == blenderapi.NKEY and keyboard.positive:
                reset_view(contr)
        """


def head_control(contr):
    """ Move the target of the head and camera

    Use the movement of the mouse to determine the rotation
    for the human head and camera. """
    # get the object this script is attached to
    human = contr.owner
    scene = blenderapi.scene()
    target = scene.objects['Head_Empty']
    # get the camera on the human head
    camera = scene.objects['Human_Camera']

    # set mouse sensitivity
    sensitivity = human['Sensitivity']

    # Do not move the camera if the current view is using another camera
    if camera != blenderapi.scene().active_camera:
        return

    # Get sensor named Mouse
    mouse = contr.sensors['Mouse']

    if mouse.positive:
        # get width and height of game window
        width = blenderapi.render().getWindowWidth()
        height = blenderapi.render().getWindowHeight()

        # get mouse movement from function
        move = mouse_move(human, mouse, width, height)

        # Amount, direction and sensitivity
        left_right = move[0] * sensitivity
        up_down = move[1] * sensitivity

        target.applyMovement([0.0, left_right, 0.0], True)
        target.applyMovement([0.0, 0.0, up_down], True)

        # Reset mouse position to the centre of the screen
        # Using the '//' operator (floor division) to produce an integer result
        blenderapi.render().setMousePosition(width//2, height//2)


def read_pose(contr):
    """ Test function to access the bone rotation data """
    armature = contr.owner
    logger.info("The armature is: '%s' (%s)" % (armature, type(armature)))

    for channel in armature.channels:
        if 'X_' not in channel.name:
            rotation = channel.joint_rotation
            logger.info("\tChannel '%s': (%.4f, %.4f, %.4f)" % (channel, rotation[0], rotation[1], rotation[2]))


def reset_view(contr):
    """ Make the human model look forward """
    human = contr.owner
    scene = blenderapi.scene()
    target = scene.objects['Head_Empty']
    # Reset the Empty object to its original position
    target.localPosition = [0.5, 0.0, 1.6]


def near_object(contr):
    """ Store the object that is near the hand
    
    This script is called from the logic bricks of Hand_Grab.R
    """
    scene = blenderapi.scene()
    hand_empty = scene.objects['Hand_Grab.R']
    near_sensor = hand_empty.sensors['Near']

    near_object = near_sensor.hitObject
    hand_empty['Near_Object'] = near_object

    #if near_object is not None:
        #hand_empty.parent.localOrientation = [math.pi/2, 0.0, 0.0]
        #logger.debug(near_object.name + " can be grasped!")


def grabbing(contr):
    """ Mark an object as selected by the user """
    scene = blenderapi.scene()
    human = contr.owner
    hand_empty = scene.objects['Hand_Grab.R']
    #sphere = scene.objects['SelectionSphere']
    lmb = human.sensors['LMB']
    selected_object = hand_empty['Near_Object']

    # Check that a button was pressed
    if lmb.getButtonStatus(blenderapi.LEFTMOUSE) == blenderapi.input_just_activated:
        # Check that no other object is being carried
        if contr.owner['DraggedObject'] is None or contr.owner['DraggedObject'] == '':
            # If the object is draggable
            if selected_object is not None and selected_object != '':
                # Clear the previously selected object, if any
                contr.owner['DraggedObject'] = selected_object
                # Remove Physic simulation
                #selected_object.suspendDynamics()
                # Parent the selected object to the hand target
                selected_object.setParent (hand_empty)

    # Drop the object when the left mouse button is released
    if lmb.getButtonStatus(blenderapi.LEFTMOUSE) == blenderapi.input_just_released:
    #if lmb.getButtonStatus(blenderapi.RIGHTMOUSE) == blenderapi.input_just_activated:
        # Clear the previously selected object, if any
        if contr.owner['DraggedObject'] is not None and contr.owner['DraggedObject'] != '':
            previous_object = contr.owner["DraggedObject"]
            # Remove the parent
            previous_object.removeParent()
            # Place the object on the nearest surface
            #morse.helpers.place_object.do_place(previous_object)
            # Reset rotation of object
            previous_object.worldOrientation = [0.0, 0.0, 0.0]
            # Restore Physics simulation
            #previous_object.restoreDynamics()
            #previous_object.setLinearVelocity([0, 0, 0])
            #previous_object.setAngularVelocity([0, 0, 0])
            # Clear the object from dragged status
            contr.owner['DraggedObject'] = None



def mouse_move(human, mouse, width, height):
    """ Get the movement of the mouse as an X, Y coordinate. """
    # distance moved from screen center
    # Using the '//' operator (floor division) to produce an integer result
    x = width//2 - mouse.position[0]
    y = height//2 - mouse.position[1]

    # intialize mouse so it doesn't jerk first time
    try:
        human['mouseInit']
    except KeyError:
        x = 0
        y = 0
        # bug in Add Property
        # can't use True.  Have to use 1
        human['mouseInit'] = 1

    # return mouse movement
    return x, y

########NEW FILE########
__FILENAME__ = view_camera
import logging; logger = logging.getLogger("morse." + __name__)
######################################################
#
#    view_camera.py        Blender 2.59
#
#    Modified version of
#    Tutorial for using MouseLook.py found at
#    www.tutorialsforblender3D.com
#
#    Gilberto Echeverria
#    15 / 09 / 2010
#
######################################################

import mathutils
from morse.core import blenderapi

start_position = []
start_orientation = []
keyboard_ctrl_objects = []

robots = []
current_robot = 0
# Matrix.Translation((-1, 0, 2)) * Euler((rad(60), 0, rad(-90)), 'XYZ').to_matrix().to_4x4()
camera_to_robot_transform = mathutils.Matrix( (
    ( 0.0, 0.5,  -0.866, -1.0),
    (-1.0, 0.0,   0.0,    0.0),
    ( 0.0, 0.866, 0.5,    2.0),
    ( 0.0, 0.0,   0.0,    1.0) ) )

def store_default(contr):
    """ Save the initial position and orientation of the camera """
    global start_position
    global start_orientation

    camera = contr.owner
    # Create a copy of the current positions
    start_position = mathutils.Vector(camera.worldPosition)
    start_orientation = mathutils.Matrix(camera.worldOrientation)

    # look for objects that define the move_cameraFP property to
    # disable keyboard control of the camera
    scene = blenderapi.scene()
    if not scene:
        # not ready, main reload(blenderapi)
        return
    for obj in scene.objects:
        if 'move_cameraFP' in obj.getPropertyNames():
            keyboard_ctrl_objects.append(obj)

def reset_position(camera):
    """ Put the camera in the initial position and orientation """
    camera.worldPosition = start_position
    camera.worldOrientation = start_orientation

def look_robot(camera):
    """ Put the camera above a robot """
    global robots, current_robot
    if not robots:
        robots = [r for r in blenderapi.persistantstorage().robotDict]
        if not robots: # if current node is just a 'watcher'
            logger.warning("no robots on current node")
            return

    robot = robots[ current_robot ]
    camera.worldTransform = robot.worldTransform * camera_to_robot_transform
    # switch between robots
    current_robot = (current_robot + 1) % len(robots)


def move(contr):
    """ Read the keys for specific combinations
        that will make the camera move in 3D space. """
    # get the object this script is attached to
    camera = contr.owner

    scene = blenderapi.scene()
    if not scene:
        # not ready, main reload(blenderapi)
        return

    # Do not move the camera if the current view is using another camera
    if camera != scene.active_camera:
        return

    # Do not move the camera if another object has set move_cameraFP
    for obj in keyboard_ctrl_objects:
        if not obj['move_cameraFP']:
            return

    # set camera position increment from the movement speed
    pos_inc = camera['Speed'] / blenderapi.getfrequency()

    # Get Blender keyboard sensor
    keyboard = contr.sensors['All_Keys']

    # Default movement
    move_translation = [0.0, 0.0, 0.0]

    keylist = keyboard.events
    for key in keylist:
        if key[1] == blenderapi.input_active():
            # Also add the corresponding key for an AZERTY keyboard
            if key[0] == blenderapi.WKEY or key[0] == blenderapi.ZKEY:
                move_translation[2] = -pos_inc
            elif key[0] == blenderapi.SKEY:
                move_translation[2] = pos_inc
            # Also add the corresponding key for an AZERTY keyboard
            elif key[0] == blenderapi.AKEY or key[0] == blenderapi.QKEY:
                move_translation[0] = -pos_inc
            elif key[0] == blenderapi.DKEY:
                move_translation[0] = pos_inc
            elif key[0] == blenderapi.RKEY:
                move_translation[1] = pos_inc
            elif key[0] == blenderapi.FKEY:
                move_translation[1] = -pos_inc
            else:
                move_translation[0] = 0
                move_translation[1] = 0
                move_translation[2] = 0

            # The second parameter of 'applyMovement' determines
            #  a movement with respect to the object's local
            #  coordinate system
            camera.applyMovement( move_translation, True )

        elif key[1] == blenderapi.input_just_activated():
            # Other actions activated with the keyboard
            # Reset camera to center
            if key[0] == blenderapi.F8KEY and keyboard.positive:
                reset_position(camera)
            if key[0] == blenderapi.F7KEY and keyboard.positive:
                look_robot(camera)


def rotate(contr):
    """ Read the movements of the mouse and apply them
        as a rotation to the camera. """
    # get the object this script is attached to
    camera = contr.owner

    scene = blenderapi.scene()
    if not scene:
        # not ready, main reload(blenderapi)
        return

    # Do not move the camera if the current view is using another camera
    if camera != scene.active_camera:
        return

    # Get sensor named Mouse
    mouse = contr.sensors['Mouse']
    # Get Blender keyboard sensor
    keyboard = contr.sensors['All_Keys']

    # Show the cursor
    mouse_visible = True

    keylist = keyboard.events
    for key in keylist:
        if key[1] == blenderapi.input_active():
            # Left CTRL key allow to rotate the camera
            if key[0] == blenderapi.LEFTCTRLKEY:
                # Hide the cursor while we control the camera
                mouse_visible = False
                if mouse.positive:
                    # get width and height of game window
                    width = blenderapi.render().getWindowWidth()
                    height = blenderapi.render().getWindowHeight()

                    # get mouse movement from function
                    move = mouse_move(camera, mouse, width, height)

                    # set mouse sensitivity
                    sensitivity = camera['Sensitivity']

                    # Amount, direction and sensitivity
                    leftRight = move[0] * sensitivity
                    upDown = move[1] * sensitivity

                    # set the values
                    camera.applyRotation( [0.0, 0.0, leftRight], 0 )
                    camera.applyRotation( [upDown, 0.0, 0.0], 1 )

                    # Center mouse in game window
                    # Using the '//' operator (floor division) to produce an integer result
                    blenderapi.render().setMousePosition(width//2, height//2)

    # Set the cursor visibility
    blenderapi.mousepointer(visible = mouse_visible)

def mouse_move(camera, mouse, width, height):
    """ Get the movement of the mouse as an X, Y coordinate. """
    # distance moved from screen center
    # Using the '//' operator (floor division) to produce an integer result
    x = width//2 - mouse.position[0]
    y = height//2 - mouse.position[1]
    
    # intialize mouse so it doesn't jerk first time
    try:
        camera['mouseInit']
    except KeyError:
        x = 0
        y = 0
        # bug in Add Property
        # can't use True.  Have to use 1
        camera['mouseInit'] = 1

    logger.debug("Read displacement: %s, %s" % (x, y))
    
    # return mouse movement
    return x, y

########NEW FILE########
__FILENAME__ = abstractcomponent
import logging; logger = logging.getLogger("morsebuilder." + __name__)
import os
import json
import copy

from morse.builder import bpymorse
from morse.builder.data import *

from morse.helpers.loading import get_class, load_module_attribute

class Configuration(object):
    datastream = {}
    modifier = {}
    service = {}
    overlay = {}

    def link_datastream(component, datastream_cfg):
        Configuration.datastream.setdefault(component.name, []).append(datastream_cfg)

    def _update_name(old_name, new_name, dict):
        """ Updated components name after renaming.

        TODO: since we update the dict 'inplace' we will run into
        trouble if an 'old' name matches a 'new' name...
        """
        try:
            dict[new_name] = dict.pop(old_name)
        except KeyError:
            pass

    def update_name(old_name, new_name):
        Configuration._update_name(old_name, new_name, Configuration.datastream)
        Configuration._update_name(old_name, new_name, Configuration.modifier)
        Configuration._update_name(old_name, new_name, Configuration.service)
        for k,v in Configuration.overlay.items():
            Configuration._update_name(old_name, new_name, v)

    def link_service(component, service_cfg):
        # Special case here for the pseudo component 'simulation' that
        # covers the simulator management services.
        if component == "simulation":
            Configuration.service.setdefault(component, []).append(service_cfg)
        else:
            Configuration.service.setdefault(component.name, []).append(service_cfg)

    def link_modifier(component, modifier_cfg):
        Configuration.modifier.setdefault(component.name, []).append(modifier_cfg)

    def link_overlay(component,  manager, overlay_cfg, kwargs):
        Configuration.overlay.setdefault(manager, {})[component.name] = [overlay_cfg, kwargs]

    def has_datastream_configuration(component, stream):
        try:
            confs = Configuration.datastream[component.name]
            for conf in confs:
                if conf[0] == MORSE_DATASTREAM_MODULE[stream]:
                    return True
        except KeyError:
            return False

    def has_service_configuration(component, stream):
        try:
            confs = Configuration.service[component.name]
            for conf in confs:
                if conf[0] == MORSE_SERVICE_DICT[stream]:
                    return True
        except KeyError:
            return False

    def _remove_entries(dict_, robot_list):
        if robot_list is None:
            return dict_
        else:
            res = {}
            for k, v in dict_.items():
                for robot in robot_list:
                    if k.startswith(robot):
                        res[k] = v
                        break
            return res


    def write_config(robot_list):
        """ Write the 'component_config.py' file with the supplied settings """
        if not 'component_config.py' in bpymorse.get_texts().keys():
            bpymorse.new_text()
            bpymorse.get_last_text().name = 'component_config.py'
        cfg = bpymorse.get_text('component_config.py')
        cfg.clear()
        cfg.write('component_datastream = ' + json.dumps(
            Configuration._remove_entries(Configuration.datastream, robot_list),
            indent=1) )
        cfg.write('\n')
        cfg.write('component_modifier = ' + json.dumps(
            Configuration._remove_entries(Configuration.modifier, robot_list),
            indent=1) )
        cfg.write('\n')
        cfg.write('component_service = ' + json.dumps(
            Configuration._remove_entries(Configuration.service, robot_list),
            indent=1) )
        cfg.write('\n')
        cleaned_overlays = {}
        for k, v in Configuration.overlay.items():
            cleaned_overlays[k] = Configuration._remove_entries(v, robot_list)
        cfg.write('overlays = ' + json.dumps(cleaned_overlays, indent=1) )
        cfg.write('\n')

class AbstractComponent(object):

    components = [] # set of all created components

    def __init__(self, obj=None, filename='', category=''):
        self.set_blender_object(obj)
        self._blender_filename = filename # filename for datastream configuration
        self._category = category # for morseable
        self.basename = None
        self.children = []

        AbstractComponent.components.append(self)

    def set_blender_object(self, obj):
        if obj: # Force matrix_parent_inverse to identity #139
            obj.matrix_parent_inverse.identity()
            # make sure the object is visible in the viewport
            # otherwise it can prevent from updating its properties
            obj.hide = False
        self._bpy_object = obj # bpy object

    def append(self, obj, level=1):
        """ Add a child to the current object

        Add the object given as an argument as a child of this object. The
        argument is an instance to another component. This method is generally
        used to add components to a robot.
        *e.g.*, : robot.append(sensor), will set the robot parent of the sensor.
        """
        obj._bpy_object.matrix_parent_inverse.identity()
        obj._bpy_object.parent = self._bpy_object
        obj.parent = self
        self.children.append(obj)

        import inspect
        try:
            frame = inspect.currentframe()
            builderscript_frame = inspect.getouterframes(frame)[level][0] # parent frame
            cmpts = builderscript_frame.f_locals
            if "self" in  cmpts: #some silly guy decided to write a class to describe a silly robot
                tmp = copy.copy(cmpts["self"].__dict__)
                tmp.update(cmpts)
                cmpts = tmp

            for name, component in cmpts.items():
                if component == obj:
                    if not component.basename: # do automatic renaming only if a name is not already manually set
                        component.basename = name

        finally:
            del builderscript_frame
            del frame


    @staticmethod
    def close_context(level = 1):
        import inspect
        try:
            frame = inspect.currentframe()
            builderscript_frame = inspect.getouterframes(frame)[level][0] # parent frame
            cmpts = builderscript_frame.f_locals

            for name, component in cmpts.items():
                if isinstance(component, AbstractComponent):

                    if hasattr(component, "parent"):
                        continue

                    # do automatic renaming only if a name is not already manually set
                    # component.name accessor set both basename and bpy.name,
                    # which is the correct behaviour here. The bpy_name may be
                    # rewritten by _rename_tree, to get the correct hierarchy.
                    if not component.basename:
                        Configuration.update_name(component.name, name)
                        component.name = name

        finally:
            del builderscript_frame
            del frame


    @property
    def name(self):
        return self._bpy_object.name
    @name.setter
    def name(self, value):
        if value:
            if '.' in value:
                raise SyntaxError("Invalid component name: <%s>. Dots are not allowed." % value)
            self.basename = value
            self._bpy_object.name = value
    @property
    def location(self):
        return self._bpy_object.location
    @location.setter
    def location(self, xyz):
        self._bpy_object.location = xyz
    @property
    def scale(self):
        return self._bpy_object.scale
    @scale.setter
    def scale(self, xyz):
        self._bpy_object.scale = xyz
    @property
    def rotation_euler(self):
        return self._bpy_object.rotation_euler
    @rotation_euler.setter
    def rotation_euler(self, xyz):
        self._bpy_object.rotation_euler = xyz
    def translate(self, x=0.0, y=0.0, z=0.0):
        """ Translate the current object

        The translation will add (x, y, z) to the current object location.
        default: x=0, y=0, z=0, unit: meter
        """
        old = self._bpy_object.location
        self._bpy_object.location = (old[0]+x, old[1]+y, old[2]+z)
    def rotate(self, x=0.0, y=0.0, z=0.0):
        """ Rotate the current object

        The rotation is an euler rotation relative to the object's center.
        default: x=0, y=0, z=0, unit: radian
        """
        old = self._bpy_object.rotation_euler
        self._bpy_object.rotation_euler = (old[0]+x, old[1]+y, old[2]+z)

    def property_value(self, name):
        try:
            return self._bpy_object.game.properties[name].value
        except KeyError:
            return None

    def properties(self, **kwargs):
        """ Add/modify the game properties of the Blender object

        Usage example:

        .. code-block:: python

            self.properties(capturing = True, classpath='module.Class', speed = 5.0)

        will create and/or set the 3 game properties Component_Tag, classpath, and
        speed at the value True (boolean), 'module.Class' (string), 5.0 (float).
        In Python the type of numeric value is 'int', if you want to force it to
        float, use the following: float(5) or 5.0
        Same if you want to force to integer, use: int(a/b)
        For the TIMER type, see the class timer(float) defined in this module:

        .. code-block:: python

            self.properties(my_clock = timer(5.0), my_speed = int(5/2))

        """
        bpymorse.properties(self._bpy_object, **kwargs)

    def select(self):
        bpymorse.select_only(self._bpy_object)

    def get_child(self, name, objects=None, recursive=True):
        """ get_child returns the child named :param name: 
        
        If several children match the name, a warning is printed and
        the first one is returned.

        :param name: the textual name of the child
        :param objects: if specified, look for the child in this list of bpy Objects
        :param recursive: (default: True) if true, search for the child recursively
        """
        if objects is None:
            objects = self._bpy_object.children
        for obj in objects:
            if obj.name == name:
                return obj
        # fix Blender shorten the name
        # ie. 'torso_lift_armature' -> 'torso_lift_armatu.000'
        test_prefix = name.rsplit('.')[0]
        # look for candidates
        candidates = [obj for obj in objects \
                      if obj.name.startswith(test_prefix)]
        if len(candidates) > 0:
            if len(candidates) > 1:
                logger.warning(test_prefix + ": more than 1 candidate: " + \
                               str(candidates))
            return candidates[0]
        
        # nothing found yet. Start to search recursively:
        if recursive:
            for obj in objects:
                found = self.get_child(name, obj.children, recursive)
                if found: return found

        return None

    def configure_mw(self, datastream, method=None, path=None, component=None):
        logger.warning("configure_mw is deprecated, use add_stream instead")
        return self.add_stream(datastream, method, path, component)

    def add_stream(self, datastream, method=None, path=None, classpath=None, direction = None, **kwargs):
        """ Add a data stream interface to the component

        Do the binding between a component and the method to export/import its
        data. This must be used in general by sensors and actuators. A single
        component can make several calls to this function to add bindings with
        more than one middleware.

        :param datastream: enum in ['ros', 'socket', 'yarp', 'text', 'pocolibs']
        :param classpath: if set, force to use the configuration of the given
                          component, instead of our own (default=None).

        You can pass other argument to this method, they will be added as a map
        to the configuration.

        .. code-block:: python

            component.add_stream('ros', topic='/myrobots/data')

        """
        if not classpath:
            classpath = self.property_value("classpath")

        if not classpath:
            logger.error("%s: no classpath defined for this "
                         "component! Check component definition " % self.name)
            return

        level = self.property_value("abstraction_level") or "default"

        config = []
        # Configure the datastream for this component
        if not method:
            if not classpath in MORSE_DATASTREAM_DICT:

                # Check if we can use default interface...
                from morse.core.actuator import Actuator
                from morse.core.sensor import Sensor
                klass = get_class(classpath)
                if klass and \
                   issubclass(klass, Actuator) and \
                   datastream in INTERFACE_DEFAULT_IN:

                    logger.warning("%s: no interfaces available for this "
                                   "component! Trying to use default one "
                                   "for %s." % (classpath, datastream))
                    config = [INTERFACE_DEFAULT_IN[datastream]]

                elif klass and \
                     issubclass(klass, Sensor) and \
                     datastream in INTERFACE_DEFAULT_OUT:

                    logger.warning("%s: no interfaces available for this "
                                   "component! Trying to use default one "
                                   "for %s." % (classpath, datastream))
                    config = [INTERFACE_DEFAULT_OUT[datastream]]

                else:
                    logger.error("%s: no interfaces available for this component!"
                                " Check builder/data.py." % classpath)
                    return

            else:
                interfaces = MORSE_DATASTREAM_DICT[classpath]

                if not level in interfaces:

                    if level == "default": # we need to look for the default level
                        module_name, class_name = classpath.rsplit('.', 1)
                        klass = load_module_attribute(module_name, class_name)

                        if not hasattr(klass, "_levels"):
                            logger.error("Component <%s> does not declare any "
                                        "default interface. You must call "
                                        "`add_stream` with an explicit method "
                                        "and Python module." % str(classpath))
                            return

                        # iterate over levels to find the one with the default flag
                        for key, value in klass._levels.items():
                            if value[2]:
                                level = key
                                # set the right default level
                                self.properties(abstraction_level = level)
                                logger.info("Using default level <%s> for "
                                            "component <%s>" % (level, classpath))
                                break

                        if level == "default":
                            logger.error("Component <%s> does not declare any"
                                        "default interface, and none of its "
                                        "abstraction levels is marked as the "
                                        "default one. You must call `add_stream`"
                                        " with an explicit method and Python "
                                        "module." % str(classpath))
                            return

                        if not level in interfaces:
                            logger.error("%s: no interfaces defined for this "
                                        "component for abstraction level <%s>!"
                                        "Check builder/data.py." %
                                        (classpath, level))
                            return

                    else:
                        logger.error("%s: no interfaces defined for this component"
                                    "for abstraction level <%s>! Check "
                                    "builder/data.py." %
                                    (classpath, level))

                interfaces = interfaces[level]
                if not datastream in interfaces:
                    logger.error("%s: no %s interface defined for this component "
                                "for abstraction level <%s>! "
                                "Check builder/data.py." %
                                (classpath, datastream, level))
                    return

                config = interfaces[datastream]
                if isinstance(config, list):
                    config = config[0]

                if config == INTERFACE_DEFAULT_OUT:
                    config = INTERFACE_DEFAULT_OUT[datastream]
                if config == INTERFACE_DEFAULT_IN:
                    config = INTERFACE_DEFAULT_IN[datastream]
                if isinstance(config, str):
                    config = [config]

        elif not path:
            config = [method]
        else:
            config = [method, path]

        if datastream in MORSE_DATASTREAM_MODULE:
            datastream_classpath = MORSE_DATASTREAM_MODULE[datastream]
        else:
            datastream_classpath = datastream

        config.insert(0, datastream_classpath)
        config.append(kwargs) # append additional configuration (eg. topic name)
        Configuration.link_datastream(self, config)

    def configure_service(self, interface, component=None, config=None):
        logger.warning("configure_service is deprecated, use add_service instead")
        return self.add_service(interface, component, config)

    def add_service(self, interface, component=None, config=None):
        """ Add a service interface to the component

        Similar to the previous function. Its argument is the name of the
        interface to be used.
        """ 
        if not component:
            component = self
        if not config:
            config = MORSE_SERVICE_DICT[interface]
        Configuration.link_service(component, config)

    def add_interface(self, interface, **kwargs):
        """ Add a service and stream interface to the component

        Its argument is the name of the interface to be used.
        """
        self.add_service(interface)
        self.add_stream(interface, **kwargs)

    def alter(self, modifier_name, classpath=None, **kwargs):
        """ Add a modifier specified by its first argument to the component """
        # Configure the modifier for this component
        config = []
        if not classpath:
            obj_classpath = self.property_value('classpath')
            classpath = MORSE_MODIFIER_DICT[modifier_name][obj_classpath]
        config.append(classpath)
        config.append(kwargs)
        Configuration.link_modifier(self, config)

    def configure_modifier(self, mod, config=None, **kwargs):
        logger.error("configure_modifier is deprecated, use alter instead")
        return self.alter(mod, config, **kwargs)

    def add_overlay(self, datastream, overlay, config=None, **kwargs):
        """ Add a service overlay for a specific service manager to the component

        Similar to the add_stream function. Its argument is the name of the
        datastream to be used.
        """
        if not config:
            config = MORSE_SERVICE_DICT[datastream]
        Configuration.link_overlay(self, config, overlay, kwargs)

    def configure_overlay(self, datastream, overlay, config=None, **kwargs):
        logger.warning("configure_overlay is deprecated, use add_overlay instead")
        return self.add_overlay(datastream, overlay, config, **kwargs)

    def level(self, level):
        """ Set the 'realism level' of the component.

        Some components define several abstraction level that impact what data
        are exported.

        See each component documentation for the list of available levels.
        """
        self.properties(abstraction_level = level)

    def frequency(self, frequency=None, delay=0):
        """ Set the frequency of the Python module

        :param frequency: (int) Desired frequency,
            0 < frequency < logic tics
        :param delay: (int) Delay between repeated pulses
            (in logic tics, 0 = no delay)
            if frequency is set, delay is obtained by fps / frequency.
        """
        if frequency:
            delay = max(0, bpymorse.get_fps() // frequency - 1)
        sensors = [s for s in self._bpy_object.game.sensors if s.type == 'ALWAYS']
        # New MORSE_LOGIC sensor, see AbstractComponent.morseable() bellow
        morselogic = [s for s in sensors if s.name.startswith('MORSE_LOGIC')]
        if len(morselogic) > 1:
            logger.warning(self.name + " has too many MORSE_LOGIC sensors to "+\
                    "tune its frequency, change it through Blender")
        elif len(morselogic) > 0:
            morselogic[0].frequency = delay
        # Backward compatible (some actuators got special logic)
        elif len(sensors) > 1:
            logger.warning(self.name + " has too many Game Logic sensors to "+\
                    "tune its frequency, change it through Blender")
        elif len(sensors) > 0:
            sensors[0].frequency = delay
        else:
            logger.warning(self.name + " has no 'ALWAYS' Game Logic sensor. "+\
                           "Unable to tune its frequency.")

    def is_morseable(self):
        for sensor in self._bpy_object.game.sensors:
            if sensor.type == 'ALWAYS':
                for controller in sensor.controllers:
                    if controller.type == 'PYTHON' and \
                       controller.module.startswith("calling."):
                        return True

        return False

    def morseable(self, calling_module=None):
        """ Make this component simulable in MORSE

        :param calling_module: Module called each simulation cycle.
                               enum in ['calling.sensor_action',
                                        'calling.actuator_action',
                                        'calling.robot_action']

        """
        if not calling_module:
            calling_module = 'calling.'+self._category[:-1]+'_action'
        # add default class to this component
        if calling_module == 'calling.robot_action':
            self.properties(Robot_Tag = True, classpath = 'morse.core.robot.Robot')
        elif calling_module == 'calling.sensor_action':
            self.properties(Component_Tag = True, classpath = 'morse.core.sensor.Sensor')
        elif calling_module == 'calling.actuator_action':
            self.properties(Component_Tag = True, classpath = 'morse.core.actuator.Actuator')
        else:
            logger.warning(self.name + ": unknown category: " + calling_module)

        # add Game Logic sensor and controller to simulate the component
        # Sensor: Always --- Controller: Python: module = 'calling.XXX_action'
        self.select()
        bpymorse.add_sensor(type='ALWAYS', name='MORSE_LOGIC')
        sensor = self._bpy_object.game.sensors[-1]
        sensor.use_pulse_true_level = True
        bpymorse.add_controller(type='PYTHON')
        controller = self._bpy_object.game.controllers[-1]
        controller.mode = 'MODULE'
        controller.module = calling_module
        controller.link(sensor = sensor)

    def append_meshes(self, objects=None, component=None, prefix=None):
        """ Append the objects to the scene

        The ``objects`` are located either in:
        MORSE_COMPONENTS/``self._category``/``component``.blend/Object/
        or in: MORSE_RESOURCE_PATH/``component``/Object/

        If `component` is not set (neither as argument of `append_meshes` nor
        through the :py:class:`AbstractComponent` constructor), a Blender
        `Empty` is created instead.

        :param objects: list of the objects names to append
        :param component: component in which the objects are located
        :param prefix: filter the objects names to append (used by PassiveObject)
        :return: list of the imported (selected) Blender objects
        """


        component = component or self._blender_filename

        if not component: # no Blender resource: simply create an empty
            bpymorse.deselect_all()
            bpymorse.add_morse_empty()
            return [bpymorse.get_first_selected_object(),]


        if component.endswith('.blend'):
            filepath = os.path.abspath(component) # external blend file
        else:
            filepath = os.path.join(MORSE_COMPONENTS, self._category,
                                    component + '.blend')

        looked_dirs = [filepath]

        if not os.path.exists(filepath):
            # Search for some blend file in different paths
            filepath = None
            resource_path = MORSE_RESOURCE_PATH.split(os.pathsep)
            for path in resource_path:
                tmp = os.path.join(path, component)
                looked_dirs.append(tmp)
                if os.path.exists(tmp):
                    filepath = tmp
                    break
            # Check if we got a match

            if not filepath:
                logger.error("Error while trying to load '%s': model not found.\n"
                             "I was looking for one of these files: \n%s\n"
                             "Either provide an absolute path, or a path relative \n"
                             "to MORSE assets directories ($MORSE_RESOURCE_PATH \n"
                             "or default path, typically $PREFIX/share/morse/data)."% (component, looked_dirs))
                raise FileNotFoundError("%s '%s' not found"%(self.__class__.__name__, component))

        if not objects: # link_append all objects from blend file
            objects = bpymorse.get_objects_in_blend(filepath)

        if prefix: # filter (used by PassiveObject)
            objects = [obj for obj in objects if obj.startswith(prefix)]

        # Format the objects list for link_append
        objlist = [{'name':obj} for obj in objects]

        bpymorse.deselect_all()
        # Append the objects to the scene, and (auto)select them
        bpymorse.link_append(directory=filepath + '/Object/', link=False,
                             autoselect=True, files=objlist)

        return bpymorse.get_selected_objects()

    def append_collada(self, component=None):
        """ Append Collada objects to the scene

        :param component: component in which the objects are located
        :return: list of the imported Blender objects
        """
        if not component:
            component = self._blender_filename

        if component.endswith('.dae'):
            filepath = os.path.abspath(component) # external blend file
        else:
            filepath = os.path.join(MORSE_COMPONENTS, self._category,
                                    component + '.dae')

        if not os.path.exists(filepath):
            logger.error("Collada file %s for external asset import can" \
                         "not be found.\nEither provide an absolute path, or" \
                         "a path relative to MORSE assets directory (typically"\
                         "$PREFIX/share/morse/data)" % filepath)
            return

        # Save a list of objects names before importing Collada
        objects_names = [obj.name for obj in bpymorse.get_objects()]
        # Import Collada from filepath
        bpymorse.collada_import(filepath=filepath)
        # Get a list of the imported objects
        imported_objects = [obj for obj in bpymorse.get_objects() \
                            if obj.name not in objects_names]

        return imported_objects

    def _make_transparent(self, obj, alpha):
        obj.game.physics_type = 'NO_COLLISION'
        for m in obj.material_slots:
            m.material.use_transparency = True
            m.material.alpha = alpha
            m.material.transparency_method = 'Z_TRANSPARENCY'
        for c in obj.children:
            self._make_transparent(c, alpha)

    def _set_color(self, obj, rgb):
        if len(obj.material_slots) > 0:
            obj.active_material.diffuse_color = rgb
        for c in obj.children:
            self._set_color(c, rgb)

    def set_color(self, r, g, b):
        """ Set the color of the component.
        
        Will try to apply the RGB color to the active material
        of all the meshes that are children of this component.
        """
        if self._bpy_object:
            self._set_color(self._bpy_object, (r,g,b))

    def profile(self):
        """ Watch the average time used during the simulation.

        Display the profile of the component on the viewport in percent.
        As Blender would for framerate and other debug-properties.
        """
        if self._category is not 'sensors':
            logger.warning("profile currently supports only sensors (%s)"%self)
        for key in ["profile", "profile_action", "profile_modifiers",
                    "profile_datastreams"]:
            prop = bpymorse._property_new(self._bpy_object, key, "0")
            prop.show_debug = True
        bpymorse.get_context_scene().game_settings.show_debug_properties = True

    def __str__(self):
        return self.name

class timer(float):
    __doc__ = "this class extends float for the game properties configuration"

########NEW FILE########
__FILENAME__ = actuators
import logging; logger = logging.getLogger("morsebuilder." + __name__)
from morse.builder.creator import ComponentCreator, ActuatorCreator
from morse.builder.blenderobjects import *

class Arucomarker(ActuatorCreator):
    _classpath = "morse.actuators.arucomarker.Arucomarker"
    _blendname = "arucomarker"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)
        self.append_meshes(['white_plane', 'arplane', 'arplane.back'])

class Destination(ActuatorCreator):
    _classpath = "morse.actuators.destination.Destination"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class ForceTorque(ActuatorCreator):
    _classpath = "morse.actuators.force_torque.ForceTorque"
    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class MocapControl(ActuatorCreator):
    _classpath = "morse.actuators.mocap_control.MocapControl"

    def __init__(self):
        ActuatorCreator.__init__(self)

# Gripper uses Actuator from morse.builder
class Gripper(ActuatorCreator):
    _classpath = "morse.actuators.gripper.Gripper"
    _blendname = "gripper"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name,
                    action = ActuatorCreator.USE_BLEND,
                    make_morseable = False)
        self.properties(Angle = 60.0, Distance = 0.5)
    def properties(self, **kwargs):
        radar = self._bpy_object.game.sensors["Radar"]
        if 'Angle' in kwargs:
            radar.angle = kwargs['Angle']
        if 'Distance' in kwargs:
            radar.distance = kwargs['Distance']
        ActuatorCreator.properties(self, **kwargs)


class Keyboard(ActuatorCreator):
    _classpath = "morse.actuators.keyboard.Keyboard"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)
        self.properties(Speed = 1.0)

class Joystick(ActuatorCreator):
    _classpath = "morse.actuators.joystick.Joystick"

    def __init__(self, name=None, index=0):
        """ Create a new Joystick controller

        :param index: Which joystick to use
        :type index:  int in [0, 7], default 0
        """
        ActuatorCreator.__init__(self, name)
        self.properties(Speed = 1.0)
        obj = bpymorse.get_context_object()
        # replace Always sensor by Joystick sensor
        sensor = obj.game.sensors[-1]
        sensor.type = 'JOYSTICK'
        # need to get the new Joystick Sensor object
        sensor = obj.game.sensors[-1]
        sensor.use_pulse_true_level = True
        sensor.joystick_index = index
        sensor.event_type = 'AXIS'
        sensor.use_all_events = True

class Orientation(ActuatorCreator):
    _classpath = "morse.actuators.orientation.Orientation"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class PA10(ActuatorCreator):
    _classpath = "morse.actuators.pa_10.PA10"
    _blendname = "pa_10"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name,
                action = ComponentCreator.USE_BLEND,
                make_morseable = False)
        self.properties(Speed = 1.0)

class PTU(ActuatorCreator):
    _classpath = "morse.actuators.ptu.PTU"
    _blendname = "ptu"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)
        self.properties(Speed = 1.0, Manual = False, Tolerance = 0.01)
        # append PanBase with its logic
        self.append_meshes(['PanBase', 'TiltBase'])

class RotorcraftAttitude(ActuatorCreator):
    _classpath = "morse.actuators.rotorcraft_attitude.RotorcraftAttitude"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class RotorcraftWaypoint(ActuatorCreator):
    _classpath = "morse.actuators.rotorcraft_waypoint.RotorcraftWaypoint"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class StabilizedQuadrotor(ActuatorCreator):
    _classpath = "morse.actuators.stabilized_quadrotor.StabilizedQuadrotor"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class SteerForce(ActuatorCreator):
    _classpath = "morse.actuators.steer_force.SteerForce"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class Teleport(ActuatorCreator):
    _classpath = "morse.actuators.teleport.Teleport"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class MotionVW(ActuatorCreator):
    _classpath = "morse.actuators.v_omega.MotionVW"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class MotionVWDiff(ActuatorCreator):
    _classpath = "morse.actuators.v_omega_diff_drive.MotionVWDiff"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class Waypoint(ActuatorCreator):
    _classpath = "morse.actuators.waypoint.Waypoint"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)
        self.properties(Target = "")
        # append 2 Radar with logic
        self.add_lr_radars()

    def add_lr_radars(self):
        self.add_radar('Radar.L', 'Lcollision', +1)
        self.add_radar('Radar.R', 'Rcollision', -1)
    def add_radar(self, name, collision, fact):
        bpymorse.deselect_all()
        bpymorse.add_object(type='EMPTY')
        # bpymorse.add_empty(type='ARROWS')
        obj = bpymorse.get_context_object()
        obj.name = name
        obj.location = (0.7, fact*0.4, 0.8)
        obj.parent = self._bpy_object
        bpymorse.new_game_property(type='BOOL', name=collision)
        prop = obj.game.properties[-1]
        prop.value = False
        bpymorse.add_sensor(type="RADAR")
        sensor = obj.game.sensors[-1]
        sensor.angle = 5.0
        sensor.distance = 3.0
        sensor.axis = 'XAXIS'
        sensor.use_pulse_true_level = True
        sensor.frequency = 20
        self.radar_set_collision(obj, sensor, 'LOGIC_AND',  collision, True)
        self.radar_set_collision(obj, sensor, 'LOGIC_NAND', collision, False)
    def radar_set_collision(self, obj, sensor, controller_type, collision, value):
        bpymorse.add_controller(type=controller_type)
        controller = obj.game.controllers[-1]
        bpymorse.add_actuator(type='PROPERTY')
        actuator = obj.game.actuators[-1]
        actuator.mode = 'TOGGLE'
        actuator.property = collision
        actuator.mode = 'ASSIGN'
        actuator.value = str(value)
        controller.link(sensor = sensor, actuator = actuator)

class MotionXYW(ActuatorCreator):
    _classpath = "morse.actuators.xy_omega.MotionXYW"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)

class Light(ActuatorCreator):
    _classpath = "morse.actuators.light.Light"
    def __init__(self, name=None):
        self.light = None
        ActuatorCreator.__init__(self, name)
        self.light = Spot("LightSpot")
        self.append(self.light)
        self.properties(Emit=True)
        
    def properties(self, **kwargs):
        ActuatorCreator.properties(self, **kwargs)
        if self.light:
            spot = self.light._bpy_object.data
            if spot.type == 'SPOT':
                if "size" in kwargs.keys():
                    spot.spot_size = kwargs['size']
                if "distance" in kwargs.keys():
                    spot.distance = kwargs['distance']
                if "color" in kwargs.keys():
                    import re
                    spot.color = tuple(int(v) for v in re.findall("[0-9]+", kwargs['color']))

class Sound(ActuatorCreator):
    _classpath = "morse.actuators.sound.Sound"

    def __init__(self, name=None):
        ActuatorCreator.__init__(self, name)
        self.properties(mode="play")
        #self.select()
        bpymorse.add_actuator(type="SOUND", name="MORSE_SOUND")
        actuator = self._bpy_object.game.actuators[-1]
        controller =  self._bpy_object.game.controllers[-1]
        controller.link(actuator=actuator)
    def open(self, filepath):
        # just to raise a FileNotFoundError
        open(filepath).close()
        actuator = self._bpy_object.game.actuators[-1]
        #if bpy.ops.sound.open.poll():
        bpymorse.open_sound(filepath=filepath)
        actuator.sound = bpymorse.get_last_sound()
        actuator.use_sound_3d = True
        actuator.distance_3d_max = 10000.0

class Armature(ActuatorCreator):
    _classpath = "morse.actuators.armature.Armature"

    def __init__(self, name = None, armature_name = None, model_name = None):
        """ Initialize an armature

        Either `armature_name` or `model_name` or both must be specified.
        

        :param armature_name: Armature object name
        :param model_name: Armature model name, if any
        """
        
        if not armature_name and not model_name:
            raise MorseBuilderError("You need to specify either the name of " \
                    "an armature or a Blender model in order to create an " \
                    "armature actuator.")

        if model_name:
            ActuatorCreator.__init__(self, 
                                    name, 
                                    action = ComponentCreator.USE_BLEND,
                                    blendfile = model_name,
                                    blendobject = armature_name,
                                    make_morseable = True)

        else:
            ActuatorCreator.__init__(self, 
                                name, 
                                action = ComponentCreator.LINK_EXISTING_OBJECT,
                                blendobject = armature_name,
                                make_morseable = True)


        self.ik_targets = []

        # the user may have created IK constraints on the armature, without
        # setting an IK target. In that case, we add such a target
        for bone in self._bpy_object.pose.bones:
            for c in bone.constraints:
                if c.type == 'IK' and c.ik_type == 'DISTANCE':
                    if not c.target:
                        self.create_ik_targets([bone.name])

    def _get_posebone(self, bone_name):
        """ Returns a given PoseBone in the armature.

        If the joint does not exist, throw an exception.
        """
        armature = self._bpy_object

        if bone_name not in [c.name for c in armature.pose.bones]:
            msg = "Joint <%s> does not exist in model %s." % (bone_name, armature.name)
            msg += " Did you add a skeleton to your model in MakeHuman?"
            raise MorseBuilderError(msg)

        return armature.pose.bones[bone_name]

    def create_ik_targets(self, bones):

        # Bug with iTaSC! cf http://developer.blender.org/T37894
        if bpymorse.version() < (2, 70, 0):
            if self._bpy_object.pose.ik_solver == 'ITASC':
                logger.warn("Due to a bug in Blender (T37894), only the standard " \
                            "IK solver can be used with IK targets. Switching " \
                            "from iTaSC to standard IK solver.")
                self._bpy_object.pose.ik_solver = 'LEGACY'

        for target in bones:
            posebone = self._get_posebone(target)
            bpymorse.add_morse_empty("ARROWS")
            empty = bpymorse.get_first_selected_object()
            empty.scale = [0.01, 0.01, 0.01]

            empty.matrix_local = posebone.bone.matrix_local
            empty.location = posebone.bone.tail_local

            existing_ik = [c for c in posebone.constraints if c.type == 'IK']
            if len(existing_ik) == 1:
                ik_constraint = existing_ik[0]
            elif existing_ik:
                raise MorseBuilderError("Bone %s has several IK constraints." \
                        "MORSE supports only one IK constraint per bone. Please " \
                        "remove other ones.")
            else:
                ik_constraint = posebone.constraints.new("IK")

            ik_constraint.ik_type = "DISTANCE"
            ik_constraint.use_rotation = True
            ik_constraint.use_tail = True
            ik_constraint.target = empty

            self.ik_targets.append((empty, target))


    def after_renaming(self):
        for empty, target in self.ik_targets:
            empty.name = "ik_target." + self.name + "." + target

class KukaLWR(Armature):
    """
    This actuator provides a KUKA LWR mesh with the associated kinematic chain.

    An IK target is available on the last join, allowing for cartesian control of
    the arm.

    See :doc:`the general documentation on armatures <../actuators/armature>` for details.
    """
    _name = "KUKA LWR"
    _short_desc="7DoF KUKA Lightweight Robotic Arm (LWR)"

    def __init__(self, name=None):
        Armature.__init__(self, name, model_name = "kuka_lwr")
        self.create_ik_targets(["kuka_7"])

# end morse.builder.actuators

########NEW FILE########
__FILENAME__ = blenderobjects
import math
from morse.builder.abstractcomponent import AbstractComponent
from morse.builder import bpymorse

class Mesh(AbstractComponent):
    mesh_primitive_add = bpymorse.add_mesh_monkey # you must set it in subclasses
    def __init__(self, name):
        AbstractComponent.__init__(self)
        bpymorse.deselect_all()
        self.mesh_primitive_add()
        obj = bpymorse.get_first_selected_object()
        obj.name = name
        # no collision by default for components
        obj.game.physics_type = 'NO_COLLISION'
        self.set_blender_object(obj)

    def color(self, r=0.1, g=0.1, b=0.1):
        if not self._bpy_object.active_material:
            self._bpy_object.active_material = bpymorse.create_new_material()
        self._bpy_object.active_material.diffuse_color = (r, g, b)

class Plane(Mesh):
    mesh_primitive_add = bpymorse.add_mesh_plane

class Cube(Mesh):
    mesh_primitive_add = bpymorse.add_mesh_cube

class Sphere(Mesh):
    mesh_primitive_add = bpymorse.add_mesh_uv_sphere

class IcoSphere(Mesh):
    mesh_primitive_add = bpymorse.add_mesh_ico_sphere

class Cylinder(Mesh):
    mesh_primitive_add = bpymorse.add_mesh_cylinder

class Cone(Mesh):
    mesh_primitive_add = bpymorse.add_mesh_cone

class Torus(Mesh):
    mesh_primitive_add = bpymorse.add_mesh_torus
    
class Empty(Mesh):
    mesh_primitive_add = bpymorse.add_object
    
class Coordsys(AbstractComponent):
    mesh_primitive_add = bpymorse.add_object
    def __init__(self, name):
        AbstractComponent.__init__(self)
        bpymorse.deselect_all()
        self.mesh_primitive_add()
        obj = bpymorse.get_first_selected_object()
        obj.name = name
        obj.empty_draw_type = 'ARROWS'
        obj.empty_draw_size = 0.1
        self.set_blender_object(obj)

class Spot(AbstractComponent):
    def __init__(self, name, lamp_type='SPOT'):
        AbstractComponent.__init__(self)
        bpymorse.deselect_all()
        bpymorse.add_lamp(type=lamp_type)
        obj = bpymorse.get_first_selected_object()
        obj.name = name
        # no collision by default for components
        obj.game.physics_type = 'NO_COLLISION'
        self.set_blender_object(obj)
        # Emit in +X
        self.rotate(y=-math.pi/2)
        if lamp_type is 'SPOT':
            spot = bpymorse.get_last_lamp()
            spot.spot_size = math.pi / 2
            spot.distance = 10

class Camera(AbstractComponent):
    def __init__(self, name):
        AbstractComponent.__init__(self)
        bpymorse.deselect_all()
        bpymorse.add_camera()
        obj = bpymorse.get_first_selected_object()
        obj.name = name
        # no collision by default for components
        obj.game.physics_type = 'NO_COLLISION'
        self.set_blender_object(obj)
        # Camera look in +Z
        self.rotate(y=math.pi, z=math.pi)

########NEW FILE########
__FILENAME__ = bpymorse
""" This module wraps the calls to the Blender Python API. This is intended
for all the cases we need to run MORSE code outside Blender (mostly for
documentation generation purposes).
"""
from morse.core.exceptions import MorseBuilderNoComponentError

bpy = None

try:
    import bpy
except ImportError:
    print("WARNING: MORSE is running outside Blender! (no bpy)")

def empty_method(*args, **kwargs):
    print(args, kwargs)

select_all = empty_method
add_mesh_monkey = empty_method
add_mesh_plane = empty_method
add_mesh_cube = empty_method
add_mesh_uv_sphere = empty_method
add_mesh_ico_sphere = empty_method
add_mesh_cylinder = empty_method
add_mesh_cone = empty_method
add_mesh_torus = empty_method
add_lamp = empty_method
add_camera = empty_method
new_material = empty_method
new_text = empty_method
new_game_property = empty_method
add_sensor = empty_method
add_controller = empty_method
add_actuator = empty_method
link_append = empty_method
collada_import = empty_method
add_object = empty_method
add_empty = empty_method
new_mesh = empty_method
new_object = empty_method
apply_transform = empty_method
open_sound = empty_method
new_scene = empty_method
armatures = empty_method

if bpy:
    select_all = bpy.ops.object.select_all
    add_mesh_monkey = bpy.ops.mesh.primitive_monkey_add
    add_mesh_plane = bpy.ops.mesh.primitive_plane_add
    add_mesh_cube = bpy.ops.mesh.primitive_cube_add
    add_mesh_uv_sphere = bpy.ops.mesh.primitive_uv_sphere_add
    add_mesh_ico_sphere = bpy.ops.mesh.primitive_ico_sphere_add
    add_mesh_cylinder = bpy.ops.mesh.primitive_cylinder_add
    add_mesh_cone = bpy.ops.mesh.primitive_cone_add
    add_mesh_torus = bpy.ops.mesh.primitive_torus_add
    add_lamp = bpy.ops.object.lamp_add
    add_camera = bpy.ops.object.camera_add
    new_material = bpy.ops.material.new
    new_text = bpy.ops.text.new
    new_game_property = bpy.ops.object.game_property_new
    add_sensor = bpy.ops.logic.sensor_add
    add_controller = bpy.ops.logic.controller_add
    add_actuator = bpy.ops.logic.actuator_add
    link_append = bpy.ops.wm.link_append
    collada_import = bpy.ops.wm.collada_import
    add_object = bpy.ops.object.add
    if bpy.app.version >= (2, 65, 0):
        add_empty = bpy.ops.object.empty_add
    new_mesh = bpy.data.meshes.new
    new_object = bpy.data.objects.new
    apply_transform = bpy.ops.object.transform_apply
    open_sound = bpy.ops.sound.open
    new_scene = bpy.ops.scene.new
    armatures = bpy.data.armatures

def version():
    if bpy:
        return bpy.app.version
    else:
        return 0,0,0


def create_new_material():
    all_materials = get_materials().keys()
    new_material()
    material_name = [name for name in get_materials().keys() \
                     if name not in all_materials].pop()
    return get_material(material_name)

def add_morse_empty(shape = 'ARROWS'):
    """Add MORSE Component Empty object which hlods MORSE logic"""
    if bpy.app.version >= (2, 65, 0):
        add_empty(type = shape)
    else:
        add_object(type='EMPTY')

def deselect_all():
    select_all(action='DESELECT')

def get_first_selected_object():
    if bpy and bpy.context.selected_objects:
        return bpy.context.selected_objects[0]
    else:
        return None

def get_selected_objects():
    if bpy:
        return bpy.context.selected_objects
    else:
        return []

def get_lamps():
    if bpy:
        return bpy.data.lamps
    else:
        return []

def get_lamp(name_or_id):
    if bpy and bpy.data.lamps:
        return bpy.data.lamps[name_or_id]
    else:
        return None

def get_last_lamp():
    return get_lamp(-1)

def get_materials():
    if bpy:
        return bpy.data.materials
    else:
        return []

def get_material(name_or_id):
    if bpy and bpy.data.materials:
        return bpy.data.materials[name_or_id]
    else:
        return None

def get_last_material():
    return get_material(-1)

def get_texts():
    if bpy:
        return bpy.data.texts
    else:
        return []

def get_text(name_or_id):
    if bpy and bpy.data.texts:
        return bpy.data.texts[name_or_id]
    else:
        return None

def get_last_text():
    return get_text(-1)

def get_sounds():
    if bpy:
        return bpy.data.sounds
    else:
        return []

def get_sound(name_or_id):
    if bpy and bpy.data.sounds:
        return bpy.data.sounds[name_or_id]
    else:
        return None

def get_last_sound():
    return get_sound(-1)

def get_scenes():
    if bpy:
        return bpy.data.scenes
    else:
        return []

def get_scene(name_or_id):
    if bpy and bpy.data.scenes:
        return bpy.data.scenes[name_or_id]
    else:
        return None

def set_active_scene(name_or_id):
    if bpy:
        scene = get_scene(name_or_id)
        if scene:
            bpy.data.screens['Default'].scene = scene
            bpy.context.screen.scene = scene
            return scene
        else:
            return None
    else:
        return None

def get_last_scene():
    return get_scene(-1)

def select_only(obj):
    if bpy:
        deselect_all()
        obj.select = True
        bpy.context.scene.objects.active = obj

def delete(objects):
    if not bpy:
        return
    if not isinstance(objects, list):
        objects = [objects]
    for obj in objects:
        if isinstance(obj, str):
            obj = bpy.data.objects[obj]
        select_only(obj)
        bpy.ops.object.delete()

def get_objects():
    if bpy:
        return bpy.data.objects
    else:
        return []

def get_object(name_or_id):
    if bpy and bpy.data.objects:
        return bpy.data.objects[name_or_id]
    else:
        return None

def get_fps():
    if bpy:
        return bpy.context.scene.game_settings.fps
    else:
        return -1

def get_context_object():
    if bpy:
        return bpy.context.object
    else:
        return None

def get_context_scene():
    if bpy:
        return bpy.context.scene
    else:
        return None

def get_context_window():
    if bpy:
        return bpy.context.window
    else:
        return None

def set_debug(debug=True):
    bpy.app.debug = debug

def get_objects_in_blend(filepath):
    if not bpy:
        return []
    objects = []
    try:
        with bpy.data.libraries.load(filepath) as (src, _):
            try:
                objects = [obj for obj in src.objects]
            except UnicodeDecodeError as detail:
                logger.error("Unable to open file '%s'. Exception: %s" % \
                             (filepath, detail))
    except IOError as detail:
        logger.error(detail)
        raise MorseBuilderNoComponentError("Component not found")
    return objects

def save(filepath=None, check_existing=False, compress=True):
    """ Save .blend file

    :param filepath: File Path
    :type  filepath: string, (optional, default: current file)
    :param check_existing: Check and warn on overwriting existing files
    :type  check_existing: boolean, (optional, default: False)
    :param compress: Compress, Write compressed .blend file
    :type  compress: boolean, (optional, default: True)
    """
    if not bpy:
        return
    if not filepath:
        filepath = bpy.data.filepath
    bpy.ops.wm.save_mainfile(filepath=filepath, check_existing=check_existing,
            compress=compress)

def set_speed(fps=0, logic_step_max=0, physics_step_max=0):
    """ Tune the speed of the simulation

    :param fps: Nominal number of game frames per second
        (physics fixed timestep = 1/fps, independently of actual frame rate)
    :type fps: int in [1, 250], default 0
    :param logic_step_max: Maximum number of logic frame per game frame if
        graphics slows down the game, higher value allows better
        synchronization with physics
    :type logic_step_max: int in [1, 5], default 0
    :param physics_step_max: Maximum number of physics step per game frame
        if graphics slows down the game, higher value allows physics to keep
        up with realtime
    :type physics_step_max: int in [1, 5], default 0

    usage::

        bpymorse.set_speed(120, 5, 5)

    .. warning:: This method must be called at the top of your Builder script,
      before creating any component.
    """
    get_context_scene().game_settings.fps = fps
    get_context_scene().game_settings.logic_step_max = logic_step_max
    get_context_scene().game_settings.physics_step_max = physics_step_max

def get_properties(obj):
    return {n: p.value for n,p in obj.game.properties.items()}

def properties(obj, **kwargs):
    """ Add/modify the game properties of the Blender object

    Usage example:

    .. code-block:: python

        properties(obj, capturing = True, classpath='module.Class', speed = 5.0)

    will create and/or set the 3 game properties Component_Tag, classpath, and
    speed at the value True (boolean), 'module.Class' (string), 5.0 (float).
    In Python the type of numeric value is 'int', if you want to force it to
    float, use the following: float(5) or 5.0
    Same if you want to force to integer, use: int(a/b)
    For the TIMER type, see the class timer(float) defined in this module:

    .. code-block:: python

        properties(obj, my_clock = timer(5.0), my_speed = int(5/2))

    """
    for key in kwargs.keys():
        if key in obj.game.properties.keys():
            _property_set(obj, key, kwargs[key])
        else:
            _property_new(obj, key, kwargs[key])

def _property_new(obj, name, value, ptype=None):
    """ Add a new game property for the Blender object

    :param name: property name (string)
    :param value: property value
    :param ptype: property type (enum in ['BOOL', 'INT', 'FLOAT', 'STRING', 'TIMER'],
                  optional, auto-detect, default=None)
    """
    select_only(obj)
    new_game_property()
    # select the last property in the list (which is the one we just added)
    obj.game.properties[-1].name = name
    return _property_set(obj, -1, value, ptype)

def _property_set(obj, name_or_id, value, ptype=None):
    """ Really set the property for the property referenced by name_or_id

    :param name_or_id: the index or name of property (OrderedDict)
    :param value: the property value
    :param ptype: property type (enum in ['BOOL', 'INT', 'FLOAT', 'STRING', 'TIMER'],
                  optional, auto-detect, default=None)
    """
    if ptype is None:
        # Detect the type (class name upper case)
        ptype = value.__class__.__name__.upper()
    if ptype == 'STR':
        # Blender property string are called 'STRING' (and not 'str' as in Python)
        ptype = 'STRING'
    obj.game.properties[name_or_id].type = ptype
    obj.game.properties[name_or_id].value = value
    return obj.game.properties[name_or_id]

def set_viewport(viewport_shade='WIREFRAME', clip_end=1000):
    """ Set the default view mode

    :param viewport_shade: enum in ['BOUNDBOX', 'WIREFRAME', 'SOLID', 'TEXTURED'], default 'WIREFRAME'
    """
    for area in bpy.context.window.screen.areas:
        if area.type == 'VIEW_3D':
            for space in area.spaces:
                if space.type == 'VIEW_3D':
                    space.viewport_shade = viewport_shade
                    space.clip_end = clip_end

def set_viewport_perspective(perspective='CAMERA'):
    """ Set the default view view_perspective

    Equivalent to ``bpy.ops.view3d.viewnumpad`` with good context.

    :param perspective: View, Preset viewpoint to use
    :type  perspective: enum in ['FRONT', 'BACK', 'LEFT', 'RIGHT', 'TOP',
                                 'BOTTOM', 'CAMERA'], default 'CAMERA'
    """
    for area in bpy.context.window.screen.areas:
        if area.type == 'VIEW_3D':
            for space in area.spaces:
                if space.type == 'VIEW_3D':
                    space.region_3d.view_perspective = perspective

def fullscreen(fullscreen=True):
    """ Run the simulation fullscreen

    :param fullscreen: Start player in a new fullscreen display
    :type  fullscreen: Boolean, default: True
    """
    if not bpy:
        return
    bpy.context.scene.game_settings.show_fullscreen = fullscreen

########NEW FILE########
__FILENAME__ = creator
import logging; logger = logging.getLogger("morsebuilder." + __name__)
from morse.builder import AbstractComponent, bpymorse
from morse.core.exceptions import *

class ComponentCreator(AbstractComponent):
    _classpath = None
    _blendname = None

    APPEND_EMPTY = 0
    USE_BLEND = 1
    LINK_EXISTING_OBJECT = 2

    def __init__(self, 
                 name, 
                 category, 
                 action = APPEND_EMPTY, 
                 blendfile = "", 
                 blendobject = None,
                 make_morseable = True):
        """ ComponentCreator constructor

        This class allow to create simulation components from MORSE builder
        scripts. It initially consists in an Empty object, to which you can
        then add meshs of your choice. It adds automaticaly the logic (Always
        sensor link to a Python controller). And set the default physics_type
        to 'NO_COLLISION'.

        :param name: (string) component name (used as Blender object name)
        :param category: (string) one of ['actuators', 'sensors', 'robots']
        :param action: indicate what to do with the `blendfile` and
        `blendobject` parameters. Must be one of [APPEND_EMPTY, USE_BLEND,
        LINK_EXISTING_OBJECT]. 
            - If APPEND_EMPTY (default), a new Blender `Empty` is created and
            `blendfile` and `blendobject` are ignored.
            - If USE_BLEND, `blendfile` is treated as the path to a Blender file,
            and if `blendobject` is also specified, the given object is
            selected (otherwise, the last object selected in the Blender file
            is returned).
            - If LINK_EXISTING_OBJECT, `blendfile` is ignored and `blendobject`
            is treated as the name of a Blender object which is already present
            in the scene.
        :param blendfile: (string, default:"") path to a Blender file (.blend)
        containing meshes for the component. Must be in MORSE_RESOURCE_PATH.
        :param blendobject: (string, default:None) Name of the Blender object
        to use (cf above for details).
        :param make_morseable: (boolean) Add Morse logic. Make it false
            if you add some blend file which already contains the
            necessary logic (default: True).
        """
        AbstractComponent.__init__(self, filename=blendfile, category=category)
        bpymorse.deselect_all()
        if action == ComponentCreator.APPEND_EMPTY:
            bpymorse.add_morse_empty()
        elif action == ComponentCreator.USE_BLEND:
            self.append_meshes()
            if blendobject:
                bpymorse.select_only(bpymorse.get_object(blendobject))
        elif action == ComponentCreator.LINK_EXISTING_OBJECT:
            bpymorse.select_only(bpymorse.get_object(blendobject))

        obj = bpymorse.get_first_selected_object()
        if name:
            obj.name = name
            self.basename = name
        # no collision by default for components
        obj.game.physics_type = 'NO_COLLISION'
        self.set_blender_object(obj)
        # Add MORSE logic
        if make_morseable:
            self.morseable()

        self.properties(Component_Tag = True, classpath = self.__class__._classpath)

    def parent_root(self, objects):
        # Parent the root objects with this Component
        for child in objects:
            if not child.parent:
                child.matrix_parent_inverse.identity()
                child.parent = self._bpy_object

    def append_meshes(self, objects=None, component=None, prefix=None):
        """ Append the objects to this component

        Overloads :py:meth:`morse.builder.abstractcomponent.AbstractComponent.append_meshes`

        :param objects: list of the objects names to append
        :param component: component in which the objects are located
        :return: list of the imported Blender objects
        """
        imported_objects = AbstractComponent.append_meshes(self, objects,
                                                           component, prefix)
        self.parent_root(imported_objects)

        return imported_objects

    def append_collada(self, component=None):
        """ Append Collada objects to this component

        Overloads :py:meth:`morse.builder.abstractcomponent.AbstractComponent.append_collada`

        :param component: component in which the objects are located
        :return: list of the imported Blender objects
        """
        imported_objects = AbstractComponent.append_collada(self, component)
        self.parent_root(imported_objects)

        return imported_objects

class SensorCreator(ComponentCreator):
    def __init__(self, name="SensorCreator",
                       action = ComponentCreator.APPEND_EMPTY,
                       make_morseable = True):

        ComponentCreator.__init__(self, 
                                  name, 
                                  'sensors',
                                  action,
                                  blendfile = self.__class__._blendname, 
                                  make_morseable = make_morseable)


class ActuatorCreator(ComponentCreator):

    def __init__(self, name="ActuatorCreator", 
                       action = ComponentCreator.APPEND_EMPTY,
                       blendfile = None,
                       blendobject = None,
                       make_morseable = True):

        if not blendfile:
            blendfile = self.__class__._blendname

        ComponentCreator.__init__(self, 
                                name, 
                                'actuators', 
                                action, 
                                blendfile,
                                blendobject,
                                make_morseable)



# helpers

def get_properties_str(name):
    """ Returns the Game properties of the Blender object represented by the name

    get_properties_str('Sick') gives
    laser_range = 30.0, Component_Tag = True, scan_window = 180.0, 
    Visible_arc = True, resolution = 0.25,
    classpath = 'morse.sensors.sick.LaserScannerClass'
    """
    obj = bpymorse.get_object(name)
    properties_dictionary = get_properties(obj)
    return ", ".join(["%s = %s"%(pname, properties_dictionary[pname]) \
                      for pname in properties_dictionary])

def get_properties(obj):
    import json
    properties_dictionary = {}
    properties = obj.game.properties
    for name in properties.keys():
        properties_dictionary[name] = properties[name].value
        if properties[name].type == 'TIMER':
            properties_dictionary[name] = "timer(%f)"%properties_dictionary[name]
        elif type(properties_dictionary[name]) is str:
            properties_dictionary[name] = json.dumps(properties_dictionary[name])
    return properties_dictionary

########NEW FILE########
__FILENAME__ = data
""" This module holds MORSE Builder API settings

MORSE_COMPONENTS:
Default path to Morse components.

MORSE_RESOURCE_PATH:
Path list to Morse components (like the shell PATH variable).

The search path for components. It is a colon-separated list of directories in
which MORSE looks for components. A zero-length (null) directory name in the
value of PATH indicates the current directory. A null directory name may appear
as two adjacent colons, or as an initial or trailing colon. The default path is
``MORSE_COMPONENTS``, wich means this list always contains morse components path.
You can export it before to start morse (commonly in ``~/.bashrc``) as::

    export MORSE_RESOURCE_PATH="/home/user/my_own_components:/home/user/my_own_environments"

MORSE_MODIFIERS:
Path to the modifiers modules.

MORSE_DATASTREAM_MODULE:
Path to the middleware modules.

MORSE_MODIFIER_DICT:
Associate a modifier function to a component.
"""
import os

MORSE_COMPONENTS = os.path.join(os.getenv('MORSE_ROOT', '/usr/local'),
                                'share', 'morse', 'data')

MORSE_RESOURCE_PATH = ':'.join([MORSE_COMPONENTS,
                                os.getenv('MORSE_RESOURCE_PATH', '')])

MORSE_DATASTREAM_MODULE = {
    'ros': 'morse.middleware.ros_datastream.ROSDatastreamManager',
    'socket': 'morse.middleware.socket_datastream.SocketDatastreamManager',
    'yarp': 'morse.middleware.yarp_datastream.YarpDatastreamManager',
    'pocolibs': 'morse.middleware.pocolibs_datastream.PocolibsDatastreamManager',
    'text': 'morse.middleware.text_datastream.TextDatastreamManager',
    'moos': 'morse.middleware.moos_datastream.MOOSDatastreamManager'
}

MORSE_MODIFIER_DICT = {
    'NED': {
        'morse.sensors.pose.Pose': "morse.modifiers.ned.CoordinatesToNED",
        'morse.sensors.gps.GPS': "morse.modifiers.ned.CoordinatesToNED",
        'morse.sensors.gyroscope.Gyroscope': "morse.modifiers.ned.AnglesToNED",
        'morse.actuators.destination.Destination': "morse.modifiers.ned.CoordinatesFromNED",
        'morse.actuators.waypoint.Waypoint': "morse.modifiers.ned.CoordinatesFromNED",
        'morse.actuators.orientation.Orientation': "morse.modifiers.ned.AnglesFromNED",
        'morse.actuators.teleport.Teleport': "morse.modifiers.ned.CoordinatesFromNED",
    },
    'UTM' : {
        'morse.sensors.pose.Pose': "morse.modifiers.utm.CoordinatesToUTM",
        'morse.sensors.gps.GPS': "morse.modifiers.utm.CoordinatesToUTM",
        'morse.actuators.destination.Destination': "morse.modifiers.utm.CoordinatesFromUTM",
        'morse.actuators.waypoint.Waypoint': "morse.modifiers.utm.CoordinatesFromUTM",
    },                  
    'PoseNoise' : {
        'morse.sensors.odometry.Odometry': "morse.modifiers.pose_noise.PoseNoiseModifier",
        'morse.sensors.pose.Pose': "morse.modifiers.pose_noise.PoseNoiseModifier",
        'morse.sensors.gps.GPS': "morse.modifiers.pose_noise.PositionNoiseModifier",
        'morse.sensors.gyroscope.Gyroscope': "morse.modifiers.pose_noise.OrientationNoiseModifier",
    },
    'IMUNoise' : {
        'morse.sensors.imu.IMU': "morse.modifiers.imu_noise.IMUNoiseModifier",
    },
    'Noise' : {
        'morse.sensors.imu.IMU': "morse.modifiers.imu_noise.IMUNoiseModifier",
        'morse.sensors.odometry.Odometry': "morse.modifiers.pose_noise.PoseNoiseModifier",
        'morse.sensors.pose.Pose': "morse.modifiers.pose_noise.PoseNoiseModifier",
        'morse.sensors.gps.GPS': "morse.modifiers.pose_noise.PositionNoiseModifier",
        'morse.sensors.gyroscope.Gyroscope': "morse.modifiers.pose_noise.OrientationNoiseModifier",
    }
}

INTERFACE_DEFAULT_OUT = {
        "socket": "morse.middleware.socket_datastream.SocketPublisher",
        "yarp": "morse.middleware.yarp_datastream.YarpPublisher",
        "yarp_json": "morse.middleware.yarp.yarp_json.YarpJsonPublisher",
        "text": "morse.middleware.text_datastream.Publisher",
        "moos": "morse.middleware.moos.abstract_moos.StringPublisher"
}

INTERFACE_DEFAULT_IN = {
        "socket": "morse.middleware.socket_datastream.SocketReader",
        "yarp": "morse.middleware.yarp_datastream.YarpReader",
        "yarp_json": "morse.middleware.yarp.yarp_json.YarpJsonReader",
}

MORSE_DATASTREAM_DICT = {
    "morse.sensors.accelerometer.Accelerometer": {
        "default": {
            "ros": 'morse.middleware.ros.accelerometer.TwistPublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            }
        },
    "morse.sensors.armature_pose.ArmaturePose": {
        "default": {
            "ros": 'morse.middleware.ros.jointstate.JointStatePublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT
            }
        },
    "morse.sensors.battery.Battery": {
        "default": {
            "ros": 'morse.middleware.ros.battery.Float32Publisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            }
        },
    "morse.sensors.clock.Clock": {
        "default": {
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "moos": INTERFACE_DEFAULT_OUT,
            "ros": 'morse.middleware.ros.clock.ClockPublisher',
            }
        },
    "morse.sensors.depth_camera.DepthCamera": {
        "default": {
            "socket": 'morse.middleware.sockets.depth_camera.DepthCameraPublisher',
            "ros": 'morse.middleware.ros.depth_camera.DepthCameraPublisher',
            'pocolibs': 'morse.middleware.pocolibs.sensors.stereopixel.Spix3DImagePoster'
            }
        },
    "morse.sensors.depth_camera.DepthCameraRotationZ": {
        "default": {
            "ros": 'morse.middleware.ros.depth_camera.DepthCameraPublisher',
            'pocolibs': 'morse.middleware.pocolibs.sensors.velodyne.Velodyne3DImage'
            }
        },
    "morse.sensors.gps.GPS": {
        "simple": {
            "ros": 'morse.middleware.ros.gps.NavSatFixPublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "yarp_json": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "pocolibs": ['morse.middleware.pocolibs.sensors.pom.PomSensorPoster',
                         'morse.middleware.pocolibs.sensors.pom.PomPoster'],
            "moos": 'morse.middleware.moos.gps.GPSNotifier'
            },
        "raw": {
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "yarp_json": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            },
        "extended": {
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "yarp_json": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            }
        },
    "morse.sensors.gyroscope.Gyroscope": {
        "default": {
            "ros": 'morse.middleware.ros.StringPublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "pocolibs": ['morse.middleware.pocolibs.sensors.pom.PomSensorPoster',
                         'morse.middleware.pocolibs.sensors.pom.PomPoster'],
            "moos": 'morse.middleware.moos.gyroscope.GyroscopeNotifier'
            }
        },
    "morse.sensors.human_posture.HumanPosture": {
        "default": {
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "pocolibs": 'morse.middleware.pocolibs.sensors.human_posture.HumanPoster'
            }
        },
    "morse.sensors.imu.IMU": {
        "default": {
            "ros": 'morse.middleware.ros.imu.ImuPublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "moos": 'morse.middleware.moos.imu.IMUNotifier'
            }
        },
    "morse.sensors.laserscanner.LaserScanner": {
        "raw": {
            "ros": ['morse.middleware.ros.laserscanner.LaserScanPublisher',
                    'morse.middleware.ros.laserscanner.PointCloud2Publisher'],
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": 'morse.middleware.yarp.laserscanner.YarpLaserScannerPublisher',
            'moos': 'morse.middleware.moos.sick.LIDARNotifier'
            },
        "rssi": {
            "socket": INTERFACE_DEFAULT_OUT
            },        
        "range": {
            "ros": 'morse.middleware.ros.infrared.RangePublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            }
        },
    "morse.sensors.odometry.Odometry": {
        "differential": {
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT
            },
        "raw": {
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT
            },
        "integrated": {
            "ros": 'morse.middleware.ros.odometry.OdometryPublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "pocolibs": ['morse.middleware.pocolibs.sensors.pom.PomSensorPoster',
                         'morse.middleware.pocolibs.sensors.pom.PomPoster']
            }
        },
    "morse.sensors.pose.Pose": {
        "default": {
            "ros": ['morse.middleware.ros.pose.PoseStampedPublisher',
                    'morse.middleware.ros.pose.TFPublisher'],
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "pocolibs": ['morse.middleware.pocolibs.sensors.pom.PomSensorPoster',
                         'morse.middleware.pocolibs.sensors.pom.PomPoster'],
            'moos': 'morse.middleware.moos.pose.PoseNotifier'
            }
        },
    "morse.sensors.proximity.Proximity": {
        "default": {
            "ros": 'morse.middleware.ros.StringPublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "yarp_json": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            }
        },
    "morse.sensors.ptu_posture.PTUPosture": {
        "default": {
            "ros": 'morse.middleware.ros.jointstate.JointStatePublisher',
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "pocolibs": 'morse.middleware.pocolibs.sensors.platine_posture.PlatinePoster'
            }
        },
    "morse.sensors.stereo_unit.StereoUnit": {
        "default": {
            "pocolibs": 'morse.middleware.pocolibs.sensors.viam.ViamPoster'
            }
        },
    "morse.sensors.search_and_rescue.SearchAndRescue": {
        "default": {
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "yarp_json": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            "pocolibs": 'morse.middleware.pocolibs.sensors.target.TargetPoster'
            }
        },
    "morse.sensors.semantic_camera.SemanticCamera": {
        "default": {
            "ros": ['morse.middleware.ros.semantic_camera.SemanticCameraPublisher',
                    'morse.middleware.ros.semantic_camera.SemanticCameraPublisherLisp'],
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "pocolibs": 'morse.middleware.pocolibs.sensors.viman.VimanPoster'
            }
        },
    "morse.sensors.thermometer.Thermometer": {
        "default": {
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            }
        },
    "morse.sensors.velocity.Velocity": {
        "default": {
            "ros": ['morse.middleware.ros.velocity.TwistStampedPublisher'],
            "socket": INTERFACE_DEFAULT_OUT,
            "yarp": INTERFACE_DEFAULT_OUT,
            "text": INTERFACE_DEFAULT_OUT,
            }
        },
    "morse.sensors.video_camera.VideoCamera": {
        "default": {
            "ros": 'morse.middleware.ros.video_camera.VideoCameraPublisher',
            "socket": 'morse.middleware.sockets.video_camera.VideoCameraPublisher',
            "yarp": 'morse.middleware.yarp_datastream.YarpImagePublisher',
            "pocolibs": 'morse.middleware.pocolibs.sensors.viam.ViamPoster'
            }
        },
    "morse.sensors.depth_camera.DepthVideoCamera": {
        "default": {
            "ros": 'morse.middleware.ros.video_camera.VideoCameraPublisher',
            "socket": 'morse.middleware.sockets.video_camera.VideoCameraPublisher',
            "yarp": 'morse.middleware.yarp_datastream.YarpImagePublisher',
            "pocolibs": 'morse.middleware.pocolibs.sensors.viam.ViamPoster'
            }
        },

    "morse.actuators.armature.Armature": {
        "default": {
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            "pocolibs": 'morse.middleware.pocolibs.actuators.lwr.LwrPoster'
            }
        },
    "morse.actuators.arucomarker.Arucomarker": {
        "default": {
            "ros": 'morse.middleware.ros.read_pose.PoseReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.destination.Destination": {
        "default": {
            "ros": 'morse.middleware.ros.destination.PointReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.force_torque.ForceTorque": {
        "default": {
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            "ros": 'morse.middleware.ros.force_torque.WrenchReader',
            }
        },
    "morse.actuators.gripper.Gripper": {
        "default": {
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.light.Light": {
        "default": {
            "ros": 'morse.middleware.ros.light.BoolReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.mocap_control.MocapControl": {
        "default": {
            "pocolibs": 'morse.middleware.pocolibs.actuators.niut.NiutPoster'
            }
        },
    "morse.actuators.orientation.Orientation": {
        "default": {
            "ros": 'morse.middleware.ros.orientation.QuaternionReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.ptu.PTU": {
        "default": {
            "ros": 'morse.middleware.ros.platine.Vector3Reader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            "pocolibs": ['morse.middleware.pocolibs.actuators.platine.PlatinePoster',
                         'morse.middleware.pocolibs.actuators.platine.PlatineAxisPoster']
            }
        },
    "morse.actuators.rotorcraft_attitude.RotorcraftAttitude": {
        "default": {
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.rotorcraft_waypoint.RotorcraftWaypoint": {
        "default": {
            "ros": 'morse.middleware.ros.read_pose.PoseReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.stabilized_quadrotor.StabilizedQuadrotor": {
        "default": {
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
        "morse.actuators.steer_force.SteerForce": {
        "default": {
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            'moos' : 'morse.middleware.moos.motion.MotionReader'
            }
        },
        "morse.actuators.v_omega.MotionVW": {
        "default": {
            "ros": 'morse.middleware.ros.motion_vw.TwistReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            "pocolibs": 'morse.middleware.pocolibs.actuators.genpos.GenPosPoster',
            'moos' : 'morse.middleware.moos.motion.MotionReader'
            }
        },
    "morse.actuators.v_omega_diff_drive.MotionVWDiff": {
        "default": {
            "ros": 'morse.middleware.ros.motion_vw.TwistReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            "pocolibs": 'morse.middleware.pocolibs.actuators.genpos.GenPosPoster',
            'moos' : 'morse.middleware.moos.motion.MotionReader'
            }
        },
    "morse.actuators.xy_omega.MotionXYW": {
        "default": {
            "ros": 'morse.middleware.ros.motion_xyw.TwistReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.teleport.Teleport": {
        "default": {
            "ros": 'morse.middleware.ros.read_pose.PoseReader',
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            }
        },
    "morse.actuators.waypoint.Waypoint": {
        "default": {
            "socket": INTERFACE_DEFAULT_IN,
            "yarp": INTERFACE_DEFAULT_IN,
            "yarp_json": INTERFACE_DEFAULT_IN,
            }
        }
}

MORSE_SERVICE_DICT = {
    "socket": "morse.middleware.socket_request_manager.SocketRequestManager",
    "yarp": "morse.middleware.yarp_request_manager.YarpRequestManager",
    "yarp_json": "morse.middleware.yarp_json_request_manager.YarpRequestManager",
    "pocolibs": "morse.middleware.pocolibs_request_manager.PocolibsRequestManager",
    "ros": "morse.middleware.ros_request_manager.RosRequestManager",
}

########NEW FILE########
__FILENAME__ = environment
import logging; logger = logging.getLogger("morsebuilder." + __name__)
import os
import json
from morse.core import mathutils
from morse.builder.morsebuilder import *
from morse.builder.abstractcomponent import Configuration
from morse.core.morse_time import TimeStrategies

class Environment(Component):
    """ Class to configure the general environment of the simulation

    It handles the background environment in which your robots are simulated,
    general properties of the simulation, the default location and orientation
    of the camera, the Blender Game Engine settings, configure the parameters
    for the multi-node simulation and also writes the 'component_config.py' file.
    """
    multinode_distribution = dict()

    def __init__(self, filename, fastmode = False, component_renaming = True):
        """
        :param fastmode: (default: False) if True, disable most visual
                         effects (like lights...) to get the fastest
                         running simulation.  Useful for unit-tests for
                         instance, or in simulations where realistic
                         environment texturing is not required (*e.g.*,
                         no video camera)

        """
        Component.__init__(self, 'environments', filename)
        AbstractComponent.components.remove(self) # remove myself from the list of components to ensure my destructor is called

        self._handle_default_interface()

        # Rename the components according to their variable names
        if component_renaming:
            self._rename_components()

        self.fastmode = fastmode

        self._created = False
        self._camera_location = [5, -5, 5]
        self._camera_rotation = [0.7854, 0, 0.7854]
        self._environment_file = filename
        self._multinode_configured = False
        self._display_camera = None
        self.is_material_mode_custom = False
        self._node_name = None
        self._physics_step_sub = 2
        # Add empty object holdings MORSE Environment's properties
        # for UTM modifier configutation ( uses env.properties(...) )
        bpymorse.deselect_all()
        bpymorse.add_morse_empty()
        obj = bpymorse.get_context_object()
        obj.name = 'MORSE.Properties'
        self.set_blender_object(obj)
        # Init. camera's properties
        self.set_camera_speed()
        self.set_camera_clip()

        self.set_gravity()

    def is_internal_camera(self, camera):
        return not self._multinode_configured or \
            self._node_name in self.multinode_distribution and \
            camera._bpy_object.parent.name in self.multinode_distribution[self._node_name]

    def _write_multinode(self, node_name):
        """ Configure this node according to its name
            and the multinode_distribution dictionnary.
        """
        if not self._multinode_configured:
            return
        if not node_name in self.multinode_distribution.keys():
            logger.warning("Node " + node_name + " is not defined in the " + \
                "env.multinode_distribution dict. It will manage no robot!")
            self.multinode_distribution[node_name] = []
        for obj in bpymorse.get_objects():
            p = obj.game.properties
            # Here we check that all objects declared for this node are robots
            if obj.name in self.multinode_distribution[node_name]:
                if not 'Robot_Tag' in p:
                    logger.warning(obj.name + " is not a robot!." + \
                        " Will not be published by this MORSE node.")
                else:
                    logger.info("Node " + node_name + \
                        " will publish robot" + obj.name)
            # Here, we make external other robots
            if 'Robot_Tag' in p:
                if not obj.name in self.multinode_distribution[node_name]:
                    logger.debug("Node " + node_name + \
                        " will not publish robot " + obj.name)
                    p['Robot_Tag'].name = 'External_Robot_Tag'
                    # Make external robots static
                    # This should stop them from drifting downwards
                    obj.game.physics_type = 'STATIC'

        """ Write the 'multinode_config.py' script """
        node_config = { 'protocol': self._protocol,
                        'node_name': node_name,
                        'server_address': self._server_address,
                        'server_port': self._server_port,}
        # Create the config file if it does not exist
        if not 'multinode_config.py' in bpymorse.get_texts().keys():
            bpymorse.new_text()
            bpymorse.get_last_text().name = 'multinode_config.py'
        cfg = bpymorse.get_text('multinode_config.py')
        cfg.clear()
        cfg.write('node_config = ' + json.dumps(node_config, indent=1) )
        cfg.write('\n')

    def _rename_components(self):
        """ Rename Blender objects after the variable name used
        in the Builder script and there hierarchy.

        If a name is already set (with 'obj.name=...'), it is used as it,
        and only the hierarchy is added to the name.
        """

        AbstractComponent.close_context(3)

        for component in AbstractComponent.components:
            if isinstance(component, Robot):

                def renametree(cmpt, fqn):
                    if not cmpt.basename:
                        return
#                        raise SyntaxError("You need to assign the component of type %s to a variable" %
#                                        cmpt)
                    list_name = [cmpt._bpy_object.name for cmpt in AbstractComponent.components if cmpt != component ]
                    fqn.append(cmpt.basename)
                    new_name = '.'.join(fqn)

                    i = 1
                    while new_name in list_name:
                        fqn.pop()
                        fqn.append("%s_%03d" % (cmpt.basename, i))
                        new_name = '.'.join(fqn)
                        i += 1

                    Configuration.update_name(cmpt.name, new_name)
                    cmpt._bpy_object.name = new_name
                    for child in cmpt.children:
                        renametree(child, fqn[:])

                renametree(component, [])

    def _handle_default_interface(self):
        """
        Handle the semantic of default interface.

        For each robot, for each of this children, if the child has no
        specific configuration for its 'default_interface', the function
        adds it automatically.
        """
        for component in AbstractComponent.components:
            if isinstance(component, Robot) and component.default_interface:
                for child in component.children:
                    if child.is_morseable():
                        if not Configuration.has_datastream_configuration(
                                child, component.default_interface):
                            child.add_stream(component.default_interface)
                        if not Configuration.has_service_configuration(
                                child, component.default_interface):
                            child.add_service(component.default_interface)



    def place_camera(self, location):
        logger.warning("`place_camera` is deprecated, use `set_camera_location` instead")
        self.set_camera_location(location)

    def aim_camera(self, rotation):
        logger.warning("`aim_camera` is deprecated, use `set_camera_rocation` instead")
        self.set_camera_rotation(rotation)

    def set_camera_location(self, location):
        """ Set the location of the default camera.

        :param location: list with the new 3D coordinates for the camera.

        .. code-block:: python

            env.set_camera_location([10.0, -10.0, 3.0])

        """
        self._camera_location = location

    def set_camera_rotation(self, rotation):
        """ Set the orientation of the default camera

        :param rotation: list with an euler rotation for the camera.

        .. code-block:: python

            env.set_camera_rotation([1.3300, 0, 0.7854])

        """
        self._camera_rotation = rotation

    def set_camera_clip(self, clip_start=0.1, clip_end=100):
        """ Set the simulator's Camera near and far clipping distance

        :param clip_start: Camera near clipping distance, float in meters (default 0.1)
        :param clip_end: Camera far clipping distance, float in meters (default 100)
        """
        self._camera_clip_start = clip_start
        self._camera_clip_end   = clip_end

    def set_camera_speed(self, speed=2.0):
        """ Set the simulator's Camera speed

        :param speed: desired speed of the camera, in meter by second.
        """
        self._camera_speed = speed

    def _cfg_camera_scene(self):
        scene = bpymorse.get_context_scene()
        scene.name = 'S.MORSE_LOGIC'
        from morse.builder.sensors import VideoCamera
        cfg_camera_scene = []
        for component in AbstractComponent.components:
            # do not create scene for external camera
            if isinstance(component, VideoCamera) and \
                    self.is_internal_camera(component):
                res_x = component.property_value('cam_width')
                res_y = component.property_value('cam_height')
                name = 'S.%dx%d' % (res_x, res_y)
                if not name in cfg_camera_scene:
                    # Create a new scene for the Camera
                    bpymorse.new_scene(type='LINK_OBJECTS')
                    scene = bpymorse.get_context_scene()
                    scene.name = name
                    scene.render.resolution_x = res_x
                    scene.render.resolution_y = res_y
                    scene.game_settings.physics_engine = 'NONE'
                    # TODO disable logic and physic in this created scene
                    cfg_camera_scene.append(name)

    def create(self, name=None):
        """ Generate the scene configuration and insert necessary objects

        Should always be called at the very end of the Builder script. It will
        finalise the building process and write the configuration files.
        """
        # Invoke special methods of component that must take place *after* renaming
        for component in AbstractComponent.components:
            if hasattr(component, "after_renaming"):
                component.after_renaming()

        # Compute node name
        if name is None:
            try:
                self._node_name = os.environ["MORSE_NODE"]
            except KeyError:
                self._node_name = os.uname()[1]
        else:
            self._node_name = name

        # Create a new scene for each camera, with specific render resolution
        # Must be done at the end of the builder script, after renaming
        # and before adding 'Scene_Script_Holder'
        self._cfg_camera_scene()

        # Create a new scene for the MORSE_LOGIC (Scene_Script_Holder, CameraFP)
        scene = bpymorse.set_active_scene('S.MORSE_LOGIC')
        scene.game_settings.physics_engine = 'BULLET'
        scene.game_settings.physics_step_sub = self._physics_step_sub
        # set simulation view resolution (4:3)
        scene.render.resolution_x = 800
        scene.render.resolution_y = 600

        # define 'Scene_Script_Holder' as the blender object of Enrivonment
        if not 'Scene_Script_Holder' in bpymorse.get_objects():
            # Add the necessary objects
            base = Component('props', 'basics')

        # Set Scene_Script_Holder as core Environment object
        self.set_blender_object(bpymorse.get_object('Scene_Script_Holder'))
        # Copy properties (for UTM modifier configuration)
        _properties = bpymorse.get_properties(bpymorse.get_object('MORSE.Properties'))
        self.properties(**_properties)

        # Write the configuration of the datastreams, and node configuration
        if not self.multinode_distribution:
            robot_list = None
        else:
            robot_list = self.multinode_distribution.get(self._node_name, [])
            if not isinstance(robot_list, list):
                robot_list = [robot_list]
        Configuration.write_config(robot_list)
        self._write_multinode(self._node_name)

        # Change the Screen material
        if self._display_camera:
            self._set_scren_mat()

        # Write the name of the 'environment file'
        self.properties(environment_file = str(self._environment_file))

        # Default time management
        if 'time_management' not in self._bpy_object.game.properties.keys():
            self.properties(time_management = TimeStrategies.BestEffort)

        if self.fastmode:
            # SINGLETEXTURE support has been removed between 2.69 and
            # 2.70. Handle properly the case where it is not defined
            # anymore.
            try:
                self.set_material_mode('SINGLETEXTURE')
            except TypeError:
                self.set_material_mode('MULTITEXTURE')
            self.set_viewport("WIREFRAME")
        elif not self.is_material_mode_custom:
            # make sure OpenGL shading language shaders (GLSL) is the
            # material mode to use for rendering
            self.set_material_mode('GLSL')

        # Set the unit system to use for button display (in edit mode) to metric
        bpymorse.get_context_scene().unit_settings.system = 'METRIC'
        # Select the type of Framing to Extend,
        # Show the entire viewport in the display window,
        # viewing more horizontally or vertically.
        bpymorse.get_context_scene().game_settings.frame_type = 'EXTEND'
        # Start player with a visible mouse cursor
        bpymorse.get_context_scene().game_settings.show_mouse = True

        # Set the position of the camera
        camera_fp = bpymorse.get_object('CameraFP')
        camera_fp.location = self._camera_location
        camera_fp.rotation_euler = self._camera_rotation
        camera_fp.game.properties['Speed'].value = self._camera_speed
        camera_fp.data.clip_start = self._camera_clip_start
        camera_fp.data.clip_end   = self._camera_clip_end
        camera_fp.data.lens = 20 # set focal length in mm
        # Make CameraFP the active camera
        bpymorse.deselect_all()
        camera_fp.select = True
        bpymorse.get_context_scene().objects.active = camera_fp
        # Set default camera
        bpymorse.get_context_scene().camera = camera_fp
        # Set viewport to Camera
        bpymorse.set_viewport_perspective()

        hud_text = bpymorse.get_object('Keys_text')
        hud_text.scale.y = 0.027 # to fit the HUD_plane

        self._created = True
        # in case we are in edit mode, do not exit on error with CLI
        sys.excepthook = sys_excepthook # Standard Python excepthook

    def set_horizon_color(self, color=(0.05, 0.22, 0.4)):
        """ Set the horizon color

        See `World/Background on the Blender Manual
        <http://wiki.blender.org/index.php/Doc:2.6/Manual/World/Background>`_
        for more information about this particular setting.

        :param color: (0.0, 0.0, 0.0) < (R, B, G) < (1.0, 1.0, 1.0)
                      default: dark azure (0.05, 0.22, 0.4)
        """
        # Set the color at the horizon to dark azure
        bpymorse.get_context_scene().world.horizon_color = color

    def show_debug_properties(self, value=True):
        """ Display the value of the game-properties marked as debug

        :param value: indicate whether to show or not this information
        """
        if isinstance(value, bool):
            bpymorse.get_context_scene().game_settings.show_debug_properties = value

    def show_framerate(self, value=True):
        """ Display framerate and profile information of the simulation

        :param value: indicate whether to show or not this information
        """
        if isinstance(value, bool):
            bpymorse.get_context_scene().game_settings.show_framerate_profile = value

    def show_physics(self, value=True):
        """ Display of the bounding boxes of objects during the simulation

        :param value: indicate whether to show or not this information
        """
        if isinstance(value, bool):
            bpymorse.get_context_scene().game_settings.show_physics_visualization = value

    def set_gravity(self, gravity=9.81):
        """ Set the gravity for the specific scene

        :param gravity: float, default: 9.81
        """
        if isinstance(gravity, float):
            bpymorse.get_context_scene().game_settings.physics_gravity = gravity
            bpymorse.get_context_scene().gravity = mathutils.Vector((0.0, 0.0, -gravity))

    def set_material_mode(self, material_mode='GLSL'):
        """ Material mode to use for rendering

        - ``SINGLETEXTURE`` Singletexture, Singletexture face materials.
        - ``MULTITEXTURE`` Multitexture, Multitexture materials.
        - ``GLSL`` GLSL, OpenGL shading language shaders.

        :param material_mode: enum in ['SINGLETEXTURE', 'MULTITEXTURE', 'GLSL']
        """
        bpymorse.get_context_scene().game_settings.material_mode = material_mode
        self.is_material_mode_custom = True

    def set_viewport(self, viewport_shade='WIREFRAME', clip_end=1000):
        """ Set the default view mode

        :param viewport_shade: enum in ['BOUNDBOX', 'WIREFRAME', 'SOLID', 'TEXTURED'], default 'WIREFRAME'
        """
        bpymorse.set_viewport(viewport_shade, clip_end)

    def set_auto_start(self, auto_start=True):
        bpymorse.get_context_scene().render.engine = 'BLENDER_GAME'
        bpymorse.get_context_scene().game_settings.use_auto_start = auto_start

    def set_time_strategy(self, strategy):
        """ Choose the time strategy for the current simulation

        :param strategy:  the strategy to choose. Must be one of value
        of :py:class:`morse.builder.TimeStrategies`
        """
        if strategy == TimeStrategies.FixedSimulationStep:
            bpymorse.get_context_scene().game_settings.use_frame_rate = 0
        elif strategy == TimeStrategies.BestEffort:
            bpymorse.get_context_scene().game_settings.use_frame_rate = 1
        else:
            raise ValueError(strategy)

        self.properties(time_management = strategy)

    def fullscreen(self, fullscreen=True):
        """ Run the simulation fullscreen

        :param fullscreen: Start player in a new fullscreen display
        :type  fullscreen: Boolean, default: True
        """
        bpymorse.fullscreen(fullscreen)

    def set_debug(self, debug=True):
        """ Set Blender debug mode

        :param debug: set when blender is running in debug mode (started with --debug)
        :type  debug: Boolean, default: True
        """
        bpymorse.set_debug(debug)

    def set_stereo(self, mode='ANAGLYPH', eye_separation=0.1, stereo='STEREO'):
        """ Configure to render image in stereo mode

        (anaglyphs allows to see in 3d with special red-cyan glasses)

        :param mode: Stereographic techniques. enum in ['QUADBUFFERED',
                     'ABOVEBELOW', 'INTERLACED', 'ANAGLYPH', 'SIDEBYSIDE',
                     'VINTERLACE'], default 'ANAGLYPH'
        :param eye_separation: Distance between the eyes. float in [0.01, 5], default 0.1
        :param stereo: enum in ['NONE', 'STEREO', 'DOME'], default 'STEREO'
        """
        bpymorse.get_context_scene().game_settings.stereo = stereo
        bpymorse.get_context_scene().game_settings.stereo_mode = mode
        bpymorse.get_context_scene().game_settings.stereo_eye_separation = eye_separation

    def set_animation_record(self, record=True):
        """ Record the simulation as a Blender animation (F-Curves)

        See the tutorial: `Recording Game Physics to Keyframes
        <http://cgcookie.com/blender/2011/05/10/tip-recording-game-physics-to-keyframes/>`_
        for more information about this particular setting.

        :param record: boolean, default True
        """
        bpymorse.get_context_scene().game_settings.use_animation_record = record

    def set_physics_step_sub(self, step_sub):
        """ Configure the number of physics sub step per physics step.

        Basically, if you increase the step_sub value, your simulation
        will spent more time in computing physics, but it will be more
        precise. The default value is 2.

        See also
        http://www.blender.org/documentation/blender_python_api_2_63_0/bpy.types.SceneGameData.html#bpy.types.SceneGameData.physics_step_sub
        """
        self._physics_step_sub = step_sub

    def configure_multinode(self, protocol='socket',
            server_address='localhost', server_port='65000', distribution=None):
        """ Provide the information necessary for the node to connect to a multi-node server.

        :param protocol: Either 'socket' or 'hla'
        :param server_address: IP address where the multi-node server can be found
        :param server_port: Used only for 'socket' protocol. Currently it should always be 65000
        :param distribution: A Python dictionary. The keys are the names of the
                nodes, and the values are lists with the names of the robots handled by
                each node

        .. code-block:: python

            dala1 = ATRV()
            dala2 = ATRV()

            env = Environment('land-1/trees')
            env.configure_multinode(
                    protocol='socket',
                    server_address='localhost',
                    server_port='65000',
                    distribution={
                        "nodeA": [dala1.name],
                        "nodeB": [dala2.name],
                    })

        """
        self._protocol = protocol
        self._server_address = server_address
        self._server_port = server_port
        if distribution is not None:
            self.multinode_distribution = distribution
        self._multinode_configured = True

    def configure_service(self, datastream):
        logger.warning("configure_service is deprecated, use add_service instead")
        return self.add_service(datastream)

    def add_service(self, datastream):
        """ Override AbstractComponent method

        Use it to define which ``datastream`` expose the *simulator internals
        services* (*i.e.*, the services used to remotely control the simulator
        behaviour):

        .. code-block:: python

            env = Environement('indoors-1/indoor-1', fastmode = True)
            # Set the simulation management services to be available from ROS:
            env.configure_service('ros')

        """
        AbstractComponent.add_service(self, datastream, "simulation")

    def select_display_camera(self, robot_camera):
        """ Select the camera that will be displayed on the HUD Screen object

        :param robot_camera: AbstractComponent reference to the camera desired to be displayed
        """
        self._display_camera = robot_camera

    def _set_scren_mat(self):
        """ Set the material of the Screen object to the same as the one indicated in the _display_camera variable
        """
        camera = None
        screen = bpymorse.get_object('Screen')
        caption = bpymorse.get_object('CameraID_text')
        blender_component = self._display_camera._bpy_object
        # Find the mesh object with a texture called 'ScreenMat'
        for child in blender_component.children:
            if 'CameraMesh' in child.name:
                camera = child
                break
        if not camera:
            logger.warning("BUILDER WARNING: Argument to 'select_display_camera' is not a camera (%s). Camera display will not work" % self._display_camera.name)
            return
        # Find the material with name "ScreenMat"
        for mat in camera.material_slots:
            if "ScreenMat" in mat.name:
                material = mat.material
                break
        logger.debug ("Setting material %s for the Screen" % material)
        screen.active_material = material

        # Make the screen visible when starting the scene
        screen.game.properties['Visible'].value = True

        # Change the text with the name of the camera being displayed
        caption.game.properties['Text'].value = self._display_camera.name

    def save(self, filepath=None, check_existing=False, compress=True):
        """ Save .blend file

        :param filepath: File Path
        :type  filepath: string, (optional, default: current file)
        :param check_existing: Check and warn on overwriting existing files
        :type  check_existing: boolean, (optional, default: False)
        :param compress: Compress, Write compressed .blend file
        :type  compress: boolean, (optional, default: True)
        """
        bpymorse.save(filepath=filepath, check_existing=check_existing,
                compress=compress)

    def set_log_level(self, component, level):
        """ 
        Set the debug level of the component to the level level.

        :param component: the class name of the component
        :param level: a string representing the level of debug to set

        XXX not persistent (if you save the scene and reload it directly
        from blender, the logger is not set at the right level.
        """

        my_logger = logging.getLogger('morse.' + component)
        my_logger.setLevel(level.upper())

    def __del__(self):
        """ Call the create method if the user has not explicitly called it """
        if not self._created:
            self.create()

########NEW FILE########
__FILENAME__ = morsebuilder
import logging; logger = logging.getLogger("morsebuilder." + __name__)
import sys
import math
from morse.builder.blenderobjects import Cube
from morse.builder import bpymorse
from morse.builder.abstractcomponent import AbstractComponent
from morse.core.exceptions import *

"""
Morse Builder API

To test this module you can c/p the following code in Blender Python console::

.. code-block:: python

    import sys
    sys.path.append("/usr/local/lib/python3/dist-packages")
    from morse.builder import *
    atrv=ATRV()

The string passed to the differents Components Classes must be an existing
.blend file-name, ie. for ``ATRV()`` the file ``atrv.blend`` must exists
in the folder ``MORSE_COMPONENTS/robots/``.
"""

# Override the default Python exception handler
sys_excepthook = sys.excepthook
def morse_excepthook(*args, **kwargs):
    logger.error("[ERROR][MORSE] Uncaught exception, quit Blender.", exc_info = tuple(args))
    sys_excepthook(*args, **kwargs)
    import os
    os._exit(-1)

# Uncaught exception quit Blender
sys.excepthook = morse_excepthook

class PassiveObject(AbstractComponent):
    """ Allows to import any Blender object to the scene.
    """

    def __init__(self, filename="props/objects", prefix=None, keep_pose=False):
        """ Initialize a PassiveObject

        :param filename: The Blender file to load. Path can be absolute
                         or if no extension relative to MORSE assets'
                         installation path (typically, $PREFIX/share/morse/data)
        :param prefix: (optional) the prefix of the objects to load in the
                       Blender file. If not set, all objects present in the file
                       are loaded. If set, all objects **prefixed** by this
                       name are imported.
        :param keep_pose: If set, the object pose (translation and rotation)
                        in the Blender file is kept. Else, the object
                        own center is placed at origin and all rotation are
                        reset.
        :return: a new AbstractComponent instance.
        """
        AbstractComponent.__init__(self, filename=filename)

        logger.info("Importing the following passive object(s): %s" % prefix)

        imported_objects = self.append_meshes(prefix=prefix)
        # Here we use the fact that after appending, Blender select the objects
        # and the root (parent) object first ( [0] )
        self.set_blender_object(imported_objects[0])

        if not keep_pose:
            self.location = (0.0, 0.0, 0.0)
            self.rotation_euler = (0.0, 0.0, 0.0)

    def setgraspable(self):
        """
        Makes an object graspable to the human avatar by adding a NEAR collision
        sensor to the object.

        This function also set the object to be an active game object (property
        'Object' set to true), and set the object label to the Blender object
        name (if not already set).
        """
        obj = self._bpy_object

        if not "Label" in obj.game.properties:
            self.properties(Object = True, Graspable = True, Label = obj.name)
        else:
            self.properties(Object = True, Graspable = True)

        # Add collision sensor for object placement
        if not 'Collision' in obj.game.sensors:
            bpymorse.add_sensor(type = 'NEAR')
            sens = obj.game.sensors[-1]
            sens.name = 'Collision'
            sens.distance = 0.05
            sens.reset_distance = 0.075
            bpymorse.add_controller()
            contr = obj.game.controllers[-1]
            contr.link(sensor = sens)

class Zone(Cube):
    def __init__(self, type):
        Cube.__init__(self, 'xxx')
        # Need to create a new material before calling make_transparent
        self._bpy_object.active_material = bpymorse.create_new_material()
        self._make_transparent(self._bpy_object, 1e-6)
        self.properties(Zone_Tag = True, Type = type)

    @property
    def size(self):
        return self._bpy_object.scale
    @size.setter
    def size(self, value):
        self._bpy_object.scale = value

    def rotate(self, x=0.0, y=0.0, z=0.0):
        logger.warning("rotate is not supported for Zone")

class Component(AbstractComponent):
    """ Append a morse-component to the scene

    cf. `bpy.ops.wm.link_append` and `bpy.data.libraries.load`
    """
    def __init__(self, category='', filename='', make_morseable=True):
        """ Initialize a MORSE component

        :param category: The category of the component (folder in
            MORSE_COMPONENTS)
        :param filename: The name of the component (file in
            MORSE_COMPONENTS/category/name.blend) If ends with '.blend',
            append the objects from the Blender file.
        :param make_morseable: If the component has no property for the
            simulation, append default Morse ones. See self.morseable()
        """
        AbstractComponent.__init__(self, filename=filename, category=category)
        imported_objects = self.append_meshes()
        # Here we use the fact that after appending, Blender select the objects
        # and the root (parent) object first ( [0] )
        self.set_blender_object(imported_objects[0])
        # If the object has no MORSE logic, add default one
        if make_morseable and category in ['sensors', 'actuators', 'robots'] \
                and not self.is_morseable():
            self.morseable()


class Robot(Component):
    def __init__(self, filename = '', name = None):
        Component.__init__(self, 'robots', filename)
        self.properties(Robot_Tag = True)
        self.default_interface = None
        if name:
            self.name = name

    def set_friction(self, friction=0.0):
        """ Set  Coulomb friction coefficient

        :param friction: [0, 100], default 0.0
        :type  friction: float
        """
        for slot in self._bpy_object.material_slots: # ['TireMat']
            slot.material.physics.friction = friction

    def set_mass(self, mass):
        """ Set component's mass

        :param mass: The component's mass
        :type  mass: float

        .. note::
            The object must have a physics controller for the mass to be
            applied, otherwise the mass value will be returned as 0.0.
        """
        self._bpy_object.game.mass = mass

    def add_default_interface(self, stream):
        """ Add a service and stream interface to all components of the robot

        .. note::
            If add_stream or add_service is used explicitly for some
            components and the specified interface is the same it will be
            added twice.
        """
        self.default_interface = stream

    def make_external(self):
        self._bpy_object.game.properties['Robot_Tag'].name = 'External_Robot_Tag'
    
    def make_ghost(self, alpha=0.3):
        """ Make this robot a ghost
        
        The robot is made transparent, with no collision.
        
        .. note::
             A ghost robot has no influence on other simulated robots
             (no collision, invisible to laser sensors) except for video sensors.
        
        :param alpha: Transparency alpha coefficient (0 for invisible, 1 for opaque, default is 0.3)
        """
        self._make_transparent(self._bpy_object, alpha)

    def set_rigid_body(self):
        """ Configure this robot to use rigid_body physics """
        self._bpy_object.game.use_actor = True
        self._bpy_object.game.physics_type = 'RIGID_BODY'
        self._bpy_object.game.use_sleep = True

    def set_no_collision(self):
        """ Configure this robot to not use physics at all """
        self._bpy_object.game.physics_type = 'NO_COLLISION'

    def set_dynamic(self):
        self._bpy_object.game.physics_type = 'DYNAMIC'
        self._bpy_object.game.use_actor = True
        self._bpy_object.game.use_sleep = True

    def set_collision_bounds(self):
        self._bpy_object.game.use_collision_bounds = True
        self._bpy_object.game.collision_bounds_type = 'CONVEX_HULL'
        self._bpy_object.game.use_collision_compound = True

class GroundRobot(Robot):
    def __init__(self, filename, name):
        Robot.__init__(self, filename, name)
        self.properties(GroundRobot = True)

class WheeledRobot(GroundRobot):
    def __init__(self, filename, name):
        Robot.__init__(self, filename, name)

    def unparent_wheels(self):
        """ Make the wheels orphans, but keep the transformation applied to
            the parent robot """
        # Force Blender to update the transformation matrices of objects
        bpymorse.get_context_scene().update()

        wheels = [child for child in self._bpy_object.children if \
                  "wheel" in child.name.lower()]
        wnames = ['None'] * 5
        keys = ['WheelFLName', 'WheelFRName', 'WheelRLName',
                'WheelRRName', 'CasterWheelName']
        properties = bpymorse.get_properties(self._bpy_object)
        for i in range(5):
            key = keys[i]
            expected_wheel = properties.get(key, None)
            if expected_wheel:
                for wheel in wheels:
                    if wheel.name.startswith(expected_wheel):
                        wnames[i] = wheel.name

        self.properties(WheelFLName = wnames[0], WheelFRName = wnames[1],
                        WheelRLName = wnames[2], WheelRRName = wnames[3],
                        CasterWheelName = wnames[4])
        for wheel in wheels:
            # Make a copy of the current transformation matrix
            transformation = wheel.matrix_world.copy()
            wheel.parent = None
            wheel.matrix_world = transformation
            # This method should be easier, but does not seem to work
            #  because of an incorrect context error
            #bpy.ops.object.parent_clear(type='CLEAR_KEEP_TRANSFORM')

    def after_renaming(self):
        self.unparent_wheels()
        for obj in self.children:
            old = obj._bpy_object.rotation_euler
            obj._bpy_object.rotation_euler = (old[0], old[1], old[2]+math.pi/2)

            # Switch the values of X and Y location
            tmp_x = obj._bpy_object.location[0]
            obj._bpy_object.location[0] = -obj._bpy_object.location[1]
            obj._bpy_object.location[1] = tmp_x


########NEW FILE########
__FILENAME__ = human
import logging; logger = logging.getLogger("morserobots." + __name__)
from morse.builder import bpymorse
from morse.builder import GroundRobot
from morse.builder.actuators import Armature
from morse.builder.sensors import ArmaturePose

class Human(GroundRobot):
    """ Append a human model to the scene.

    The human model currently available in MORSE comes with its
    own subjective camera and several features for object manipulation.

    It also exposes a :doc:`human posture component <../sensors/human_posture>`
    that can be accessed by the ``armature`` member.

    Usage example:

    .. code-block:: python

       #! /usr/bin/env morseexec

       from morse.builder import *

       human = Human()
       human.translate(x=5.5, y=-3.2, z=0.0)
       human.rotate(z=-3.0)

       human.armature.add_stream('pocolibs')

    Currently, only one human per simulation is supported.
    """
    def __init__(self, filename='human', name = None):
        """ The 'style' parameter is only to switch to the mocap_human file.

        :param filename: 'human' (default) or 'mocap_human'
        """
        GroundRobot.__init__(self, filename, name)

        self.suffix = self.name[-4:] if self.name[-4] == "." else ""

        self.armature = None
        if filename == 'mocap_human':
            self.properties(classpath="morse.robots.mocap_human.MocapHuman")
        else:
            self.properties(classpath="morse.robots.human.Human")

        try:
            self.armature = Armature(armature_name = "HumanArmature" + self.suffix)
            self.append(self.armature)
        except KeyError:
            logger.error("Could not find the human armature! (I was looking " +\
                         "for an object called 'HumanArmature' in the human" +\
                         " children). I won't be able to export the human pose" +\
                         " to any middleware.")

        # Add an armature sensor. "joint_stateS" to match standard ROS spelling.
        self.joint_states = ArmaturePose()
        self.armature.append(self.joint_states)

        # fix for Blender 2.6 Animations
        armature_object = self.get_child(self.armature.name)
        if armature_object:
            hips = self.get_child("Hips_Empty")
            # IK human has no object called Hips_Empty, so avoid this step
            if hips:
                for i, actuator in enumerate(hips.game.actuators):
                    actuator.layer = i
                for i, actuator in enumerate(armature_object.game.actuators):
                    actuator.layer = i

    def after_renaming(self):
        if self._blender_filename == 'mocap_human':
            # no need for mocap
            return

        # Store the human real name (ie, after renaming) in its link 'POS_EMPTY' and 'Human_Camera' object, for later control.

        pos_empty = bpymorse.get_object("POS_EMPTY" + self.suffix)
        bpymorse.select_only(pos_empty)

        bpymorse.new_game_property()
        prop = pos_empty.game.properties
        # select the last property in the list (which is the one we just added)
        prop[-1].name = "human_name"
        prop[-1].type = "STRING"
        prop[-1].value = self.name

        human_camera = bpymorse.get_object("Human_Camera" + self.suffix)
        bpymorse.select_only(human_camera)

        bpymorse.new_game_property()
        prop = human_camera.game.properties
        # select the last property in the list (which is the one we just added)
        prop[-1].name = "human_name"
        prop[-1].type = "STRING"
        prop[-1].value = self.name

    def add_interface(self, interface):
        if interface == "socket":
            self.joint_states.add_stream("socket")
            self.armature.add_service('socket')

        elif interface == "ros":

            self.joint_states.add_stream("ros")

            self.armature.add_service("ros")
            self.armature.add_overlay("ros",
              "morse.middleware.ros.overlays.armatures.ArmatureController")

        elif interface == "pocolibs":
            self.armature.properties(classpath="morse.sensors.human_posture.HumanPosture")
            self.add_stream(interface)


    def use_world_camera(self):
        self.properties(WorldCamera = True)

    def disable_keyboard_control(self):
        self.properties(disable_keyboard_control = True)

########NEW FILE########
__FILENAME__ = morserobots
import logging; logger = logging.getLogger("morserobots." + __name__)

from morse.builder import Robot, GroundRobot, WheeledRobot

class Morsy(GroundRobot):
    def __init__(self, name=None):
        GroundRobot.__init__(self, "morsy", name)
        self.properties(classpath = "morse.robots.morsy.Morsy")

        self.set_dynamic()
        mesh = self.get_child('morsy_mesh')
        mesh.game.physics_type = 'NO_COLLISION'

        self._bpy_object.game.radius = 0.08

        self.set_collision_bounds()

    def set_color(self, color = (0.0, 0.0, 0.8)):
        """
        Allows to change Morsy's body color.
        """
        mats = self.get_child('morsy_mesh').material_slots.keys()
        [body_mat] = [mat for mat in mats if mat.startswith('body')] # account for body.001, body.002...
        self.get_child('morsy_mesh').material_slots[body_mat].material.diffuse_color = color

class ATRV(GroundRobot):
    def __init__(self, name=None):
        GroundRobot.__init__(self, "atrv", name)
        self.properties(classpath = "morse.robots.atrv.ATRV")

class B21(GroundRobot):
    def __init__(self, name=None):
        GroundRobot.__init__(self, "b21", name)
        self.properties(classpath = "morse.robots.b21.B21")

        self.set_rigid_body()
        self.set_collision_bounds()

        collision = self.get_child('b21_collision')
        collision.game.physics_type = 'STATIC'

# see src/morse/robots/environment.py
class FakeRobot(Robot):
    def __init__(self, name=None):
        Robot.__init__(self, name = name) # no Blender model -> a simple Empty will be created
        self.properties(classpath = "morse.robots.fakerobot.FakeRobot")
        self.set_no_collision()

class Hummer(GroundRobot):
    def __init__(self, name=None):
        GroundRobot.__init__(self, "hummer", name)
        self.properties(classpath = "morse.robots.hummer.Hummer",
                        brakes = 0.0, friction = 200.0, force = 0.0,
                        steer = 0.0, init = 0, cid = 0)

class Jido(GroundRobot):
    def __init__(self, name=None):
        GroundRobot.__init__(self, "jido", name)
        self.properties(classpath = "morse.robots.jido.Jido")

        self.set_dynamic()
        self.set_collision_bounds()
        self._bpy_object.game.radius = 0.01

        mesh = self.get_child('JidoBase')
        mesh.game.physics_type = 'STATIC'

# see human.py
#class MocapHuman(Robot):
#    def __init__(self, name="Human"):
#        Robot.__init__(self, "mocap_human")
#        self.name = name
#        self.properties(classpath = "morse.robots.mocap_human.MocapHuman",\
#                        Sensitivity = 0.001, Speed = 0.01, \
#                        DraggedObject = "", move_cameraFP = True)
#        # Mouse Game Logic

class Pioneer3DX(WheeledRobot):
    def __init__(self, name=None):
        WheeledRobot.__init__(self, "pioneer3dx", name)
        self.properties(classpath = "morse.robots.pioneer3dx.Pioneer3DX",
                        HasSuspension = False, HasSteering = False,
                        Influence = 0.1, Friction = 0.8,
                        WheelFLName = "Wheel_L", WheelFRName = "Wheel_R",
                        WheelRLName = "None", WheelRRName = "None",
                        CasterWheelName = "CasterWheel", 
                        FixTurningSpeed = 0.52)

class QUAD2012(Robot):
    def __init__(self, name=None):
        Robot.__init__(self, "quadrotor", name)
        self.properties(classpath = "morse.robots.quadrotor.Quadrotor")
        # Collision - Motion Game Logic
        self.set_no_collision()

class Quadrotor(Robot):
    def __init__(self, name=None):
        Robot.__init__(self, "quadrotor_dynamic", name)
        self.properties(classpath = "morse.robots.quadrotor_dynamic.Quadrotor")

class RMax(Robot):
    def __init__(self, name=None):
        Robot.__init__(self, "rmax", name)
        self.properties(classpath = "morse.robots.rmax.RMax",
                        NoGravity = True)

        self.set_rigid_body()
        rotor = self.get_child('Rotor')
        rotor.game.physics_type = 'NO_COLLISION'

class SegwayRMP400(WheeledRobot):
    def __init__(self, name=None):
        WheeledRobot.__init__(self, "segwayrmp400", name)
        self.properties(classpath = "morse.robots.segwayrmp400.SegwayRMP400",
                        HasSuspension = False, HasSteering = False,
                        Influence = 0.1, Friction = 0.8, FixTurningSpeed = 1.16,
                        WheelFLName = "wheel1", WheelFRName = "wheel2",
                        WheelRLName = "wheel3", WheelRRName = "wheel4")

class Submarine(Robot):
    def __init__(self, name=None):
        Robot.__init__(self, "submarine", name)
        self.properties(classpath = "morse.robots.submarine.Submarine",
                        NoGravity = True)
        self.set_rigid_body()
        self.set_collision_bounds()

class Victim(GroundRobot):
    def __init__(self, name=None):
        GroundRobot.__init__(self, "victim", name)
        self.properties(classpath = "morse.robots.victim.Victim",
                        Victim_Tag = True, Requirements = "1,2,3",
                        Injured = True, Severity = 10)


class PatrolBot(WheeledRobot):
    def __init__(self, name=None):
        WheeledRobot.__init__(self, "patrolbot", name)
        self.properties(classpath = "morse.robots.patrolbot.PatrolBot",
                        HasSuspension = False, HasSteering = False,
                        Influence = 0.1, Friction = 0.8,
                        WheelFLName = "Wheel_L", WheelFRName = "Wheel_R",
                        WheelRLName = "None", WheelRRName = "None",
                        CasterWheelName = "CasterWheel")




########NEW FILE########
__FILENAME__ = pr2
import logging; logger = logging.getLogger("pr2." + __name__)

from morse.builder import *
from morse.builder.sensors import *
from morse.builder.actuators import *

class BarePR2(GroundRobot):
    """
    A PR2 model, without any sensor or actuator.
    """
    def __init__(self, name = None):
        GroundRobot.__init__(self, 'pr2', name)
        self.properties(classpath = "morse.robots.pr2.PR2",
                        COLOR = "0.0, 0.0, 1.0")

    def set_color(self, color = (0.0, 0.0, 0.8)):
        """
        Allows to change the PR2 head color.
        """
        self.get_child("head_tilt_link").material_slots['HeadTilt'].material.node_tree.nodes['Material'].material.diffuse_color = color

class BasePR2(BarePR2):
    """
    A PR2 only equipped with its armatures for the arms, the torso and the
    head.

    It also provides the compound sensor ``pr2.joint_state`` that exports the
    whole joint state of the robot.

    """
    def __init__(self, name = None):
        BarePR2.__init__(self, name)

        # Armatures and armature pose sensors
        # The armatures are already present in the PR2 blender model.

         # torso
        self.torso = Armature(armature_name = "torso_armature")
        self.torso_pose = ArmaturePose()
        self.torso_pose.name = "pose"
        self.torso.append(self.torso_pose)
        self.append(self.torso)

        # head
        self.head = Armature(armature_name = "head_armature")
        self.head_pose = ArmaturePose()
        self.head_pose.name = "pose"
        self.head.append(self.head_pose)
        self.torso.append(self.head)

        # arms
        self.l_arm = Armature(armature_name = "l_arm_armature")
        self.l_arm_pose = ArmaturePose()
        self.l_arm_pose.name = "pose"
        self.l_arm.append(self.l_arm_pose)
        self.torso.append(self.l_arm)

        self.r_arm = Armature(armature_name = "r_arm_armature")
        self.r_arm_pose = ArmaturePose()
        self.r_arm_pose.name = "pose"
        self.r_arm.append(self.r_arm_pose)
        self.torso.append(self.r_arm)

        # joint state
        self.joint_state = CompoundSensor([self.torso_pose, self.head_pose, self.l_arm_pose, self.r_arm_pose])
        self.append(self.joint_state)


    def add_interface(self, interface):
        if interface == "socket":
            self.joint_state.add_stream("socket", "morse.middleware.sockets.jointstate.PR2JointStatePublisher")
            self.torso.add_service('socket')
            self.head.add_service('socket')
            self.l_arm.add_service('socket')
            self.r_arm.add_service('socket')
        elif interface == "ros":

            self.joint_state.add_stream("ros", 
                                        "morse.middleware.ros.jointstate.JointStatePR2Publisher",
                                        topic = "/joint_states")
            self.joint_state.add_service("ros")



            self.torso_pose.add_stream("ros",
                        "morse.middleware.ros.jointtrajectorycontrollers.JointTrajectoryControllerStatePublisher",
                        topic="/torso_lift_controller/state")
            self.torso.add_overlay("ros",
              "morse.middleware.ros.overlays.armatures.ArmatureController",
              namespace = "/torso_lift_controller")



            self.head_pose.add_stream("ros",
                       "morse.middleware.ros.jointtrajectorycontrollers.JointTrajectoryControllerStatePublisher",
                       topic="/head_controller/state")
            self.head.add_overlay("ros",
              "morse.middleware.ros.overlays.armatures.ArmatureController",
              namespace = "/head_controller")


            self.l_arm_pose.add_stream("ros",
                      "morse.middleware.ros.jointtrajectorycontrollers.JointTrajectoryControllerStatePublisher",
                      topic="/l_arm_controller/state")
            self.l_arm.add_overlay("ros",
              "morse.middleware.ros.overlays.armatures.ArmatureController",
              namespace = "/l_arm_controller")


            self.r_arm_pose.add_stream("ros", 
                 "morse.middleware.ros.jointtrajectorycontrollers.JointTrajectoryControllerStatePublisher",
                 topic="/r_arm_controller/state")
            self.r_arm.add_overlay("ros",
              "morse.middleware.ros.overlays.armatures.ArmatureController",
              namespace = "/r_arm_controller")


class LocalizedPR2(BasePR2):
    def __init__(self, name = None, with_keyboard = True, show_laser = False):
        BasePR2.__init__(self, name)

        ###################################
        # Actuators
        ###################################


        # Motion controller
        self.motion = MotionXYW()
        self.motion.properties(ControlType = 'Position')
        self.append(self.motion)

        # (optionally) keyboard controller
        if with_keyboard:
            keyboard = Keyboard()
            self.append(keyboard)

        ###################################
        # Sensors
        ###################################

        self.pose = Pose()
        self.append(self.pose)

    def add_interface(self, interface):

        BasePR2.add_interface(self, interface)

        if interface == "ros": 
            self.motion.add_stream("ros", topic="/cmd_vel")
            self.pose.add_stream("ros", method="morse.middleware.ros.pose.TFPublisher")


class NavPR2(BasePR2):
    """
    A PR2 equipped with sensors and actuators required for 2D navigation.

    """
    def __init__(self, name = None, with_keyboard = True, show_laser = False):
        BasePR2.__init__(self, name)

        ###################################
        # Actuators
        ###################################


        # Motion controller
        self.motion = MotionXYW()
        self.motion.properties(ControlType = 'Position')
        self.append(self.motion)

        # (optionally) keyboard controller
        if with_keyboard:
            keyboard = Keyboard()
            self.append(keyboard)

        ###################################
        # Sensors
        ###################################

        # Odometry
        self.odometry = Odometry()
        self.append(self.odometry)


        # Base laser scanner
        self.base_scan = Hokuyo()
        self.base_scan.translate(x=0.275, z=0.252)
        self.append(self.base_scan)
        self.base_scan.properties(Visible_arc = show_laser)
        self.base_scan.properties(laser_range = 30.0)
        self.base_scan.properties(resolution = 1.0)
        self.base_scan.properties(scan_window = 180.0)
        self.base_scan.create_laser_arc()


        ###################################
        ###################################

        logger.info("PR2 created.")

    def add_interface(self, interface):

        BasePR2.add_interface(self, interface)

        if interface == "socket":
            pass
        elif interface == "ros": 
            self.base_scan.add_stream("ros", topic="/scan")
            self.odometry.add_stream("ros", topic="/odom")
            self.motion.add_stream("ros", topic="/cmd_vel")



########NEW FILE########
__FILENAME__ = sensors
import logging; logger = logging.getLogger("morse.builder." + __name__)
import math
from morse.builder.creator import SensorCreator, bpymorse
from morse.builder.blenderobjects import *

class Accelerometer(SensorCreator):
    _classpath = "morse.sensors.accelerometer.Accelerometer"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cube("AccelerometerCube")
        mesh.scale = (.04, .04, .02)
        mesh.color(.3, .9, .6)
        self.append(mesh)

class ArmaturePose(SensorCreator):
    _classpath = "morse.sensors.armature_pose.ArmaturePose"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)

class Battery(SensorCreator):
    _classpath = "morse.sensors.battery.Battery"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cylinder("BatteryCylinder")
        mesh.scale = (.01, .01, .04)
        mesh.color(.2, .2, .2)
        self.append(mesh)
        self.properties(DischargingRate = 0.05)

class CompoundSensor(SensorCreator):
    _classpath = "morse.sensors.compound.CompoundSensor"

    def __init__(self, sensors, name=None):
        SensorCreator.__init__(self, name)

        self.sensors = sensors

    def after_renaming(self):
        # Ensures this is called only when all components have been (automatically) renamed.
        self.properties(sensors = ",".join([str(s) for s in self.sensors]))

class GPS(SensorCreator):
    _classpath  = "morse.sensors.gps.GPS"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Sphere("GPSSphere")
        mesh.scale = (.04, .04, .01)
        mesh.color(.5, .5, .5)
        self.append(mesh)

class Gyroscope(SensorCreator):
    _classpath = "morse.sensors.gyroscope.Gyroscope"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Sphere("GyroscopeSphere")
        mesh.scale = (.04, .04, .01)
        mesh.color(.8, .4, .1)
        self.append(mesh)

class IMU(SensorCreator): 
    _classpath = "morse.sensors.imu.IMU"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cube("IMUCube")
        mesh.scale = (.04, .04, .02)
        mesh.color(.3, .9, .6)
        self.append(mesh)

class Odometry(SensorCreator):
    _classpath = "morse.sensors.odometry.Odometry"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cylinder("OdometryCylinder")
        mesh.scale = (.02, .02, .02)
        mesh.color(.5, .5, .5)
        self.append(mesh)

class Pose(SensorCreator):
    _classpath = "morse.sensors.pose.Pose"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cube("PoseCube")
        mesh.scale = (.04, .04, .02)
        mesh.color(.8, .3, .1)
        self.append(mesh)

class Proximity(SensorCreator):
    _classpath = "morse.sensors.proximity.Proximity"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cylinder("ProximityCylinder")
        mesh.scale = (.02, .02, .02)
        mesh.color(.5, .5, .5)
        self.append(mesh)
        self.properties(Range = 30.0, Track = "Robot_Tag")
        self.frequency(12)

class PTUPosture(SensorCreator):
    _classpath = "morse.sensors.ptu_posture.PTUPosture"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)

class SearchAndRescue(SensorCreator):
    _classpath = "morse.sensors.search_and_rescue.SearchAndRescue"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cylinder("SearchAndRescueCylinder")
        mesh.scale = (.15, .04, .04)
        mesh.color(.2, .8, .6)
        mesh.rotate(y = math.pi / 2)
        self.append(mesh)
        self.frequency(6)
        self.properties(Heal_range = 2.0, Abilities = "1,2")
        # add Radar freq: 3 Hz, prop: Injured, angle: 60.0, distance: 10.0
        bpymorse.add_sensor(type="RADAR", name="Radar")
        obj = bpymorse.get_context_object()
        sensor = obj.game.sensors[-1]
        sensor.angle = 60.0
        sensor.distance = 10.0
        sensor.use_pulse_true_level = True
        sensor.frequency = 20
        sensor.property = "Injured"
        # link it to the Python controller
        controller = obj.game.controllers[-1]
        controller.link(sensor = sensor)

    def properties(self, **kwargs):
        self.select()
        # We may be use it before the definition of radar
        # But angle and distance can only be defined by user, in case
        # where we are sure that Radar is well defined
        try:
            radar = self._bpy_object.game.sensors["Radar"]
            if 'Angle' in kwargs:
                radar.angle = kwargs['Angle']
            if 'Distance' in kwargs:
                radar.distance = kwargs['Distance']
            if 'Freq' in kwargs:
                radar.freq = kwargs['Freq']
        except KeyError:
            pass
        SensorCreator.properties(self, **kwargs)

class StereoUnit(SensorCreator):
    _classpath = "morse.sensors.stereo_unit.StereoUnit"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cube("StereoUnitCube")
        mesh.scale = (.025, .24, .01)
        mesh.color(.8, .8, .8)
        self.append(mesh)

class Thermometer(SensorCreator):
    _classpath = "morse.sensors.thermometer.Thermometer"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Cylinder("ThermometerCylinder")
        mesh.scale = (.02, .02, .04)
        mesh.color(0, .6, .5)
        self.append(mesh)

# abstract class
class LaserSensorWithArc(SensorCreator):
    _classpath  = "morse.sensors.laserscanner.LaserScanner"

    def get_ray_material(self):
        if 'RayMat' in bpymorse.get_materials():
            return bpymorse.get_material('RayMat')

        ray_material = bpymorse.create_new_material()
        ray_material.diffuse_color = (.9, .05, .2)
        ray_material.use_shadeless = True
        ray_material.use_raytrace = False # ? is it needed ?
        ray_material.use_cast_buffer_shadows = False # ? is it needed ?
        ray_material.use_cast_approximate = False # ? is it needed ?
        ray_material.use_transparency = True
        ray_material.transparency_method = 'Z_TRANSPARENCY'
        ray_material.alpha = 0.3
        ray_material.name = 'RayMat'
        # link material to object as: Arc_XXX.active_material = ray_material
        return ray_material

    def create_laser_arc(self):
        """ Create an arc for use with the laserscanner sensor

        The arc is created using the parameters in the laserscanner Empty.
        'resolution and 'scan_window' are used to determine how many points
        will be added to the arc.
        """
        scene = bpymorse.get_context_scene()
        laserscanner_obj = self._bpy_object

        # Delete previously created arc
        for child in laserscanner_obj.children:
            if child.name.startswith("Arc_"):
                scene.objects.unlink( child )

        # Read the parameters to create the arc
        properties = laserscanner_obj.game.properties
        resolution = properties['resolution'].value
        window = properties['scan_window'].value
        # Parameters for multi layer sensors
        try:
            layers = properties['layers'].value
            layer_separation = properties['layer_separation'].value
            layer_offset = properties['layer_offset'].value
        except KeyError as detail:
            layers = 1
            layer_separation = 0.0
            layer_offset = 0.0
        logger.debug ("Creating %d arc(s) of %.2f degrees, resolution %.2f" % \
                      (layers, window, resolution))
        mesh = bpymorse.new_mesh( "ArcMesh" )
        # Add the center vertex to the list of vertices
        verts = [ [0.0, 0.0, 0.0] ]
        faces = []
        vertex_index = 0

        # Set the vertical angle, in case of multiple layers
        if layers > 1:
            v_angle = layer_separation * (layers-1) / 2.0
        else:
            v_angle = 0.0

        # Initialise the parameters for every layer
        for layer_index in range(layers):
            start_angle = -window / 2.0
            end_angle = window / 2.0
            # Offset the consecutive layers
            if (layer_index % 2) == 0:
                start_angle += layer_offset
                end_angle += layer_offset
            logger.debug ("Arc from %.2f to %.2f" % (start_angle, end_angle))
            logger.debug ("Vertical angle: %.2f" % v_angle)
            arc_angle = start_angle

            # Create all the vertices and faces in a layer
            while arc_angle <= end_angle:
                # Compute the coordinates of the new vertex
                new_vertex = [ math.cos(math.radians(arc_angle)),
                               math.sin(math.radians(arc_angle)),
                               math.sin(math.radians(v_angle)) ]
                verts.append(new_vertex)
                vertex_index += 1
                # Add the faces after inserting the 2nd vertex
                if arc_angle > start_angle:
                    faces.append([0, vertex_index-1, vertex_index])
                # Increment the angle by the resolution
                arc_angle = arc_angle + resolution

            v_angle -= layer_separation

        mesh.from_pydata( verts, [], faces )
        mesh.update()
        # Compose the name of the arc
        arc_name = "Arc_%d" % window
        arc = bpymorse.new_object( arc_name, mesh )
        arc.data = mesh
        # Remove collision detection for the object
        arc.game.physics_type = 'NO_COLLISION'
        arc.hide_render = True
        # Link the new object in the scene
        scene.objects.link( arc )
        # Set the parent to be the laserscanner Empty
        arc.parent = laserscanner_obj
        # Set the material of the arc
        arc.active_material = self.get_ray_material()
        return arc

    def after_renaming(self):
        arc = [child for child in self._bpy_object.children
               if child.name.startswith("Arc_")]
        if not arc:
            self.create_laser_arc()

class Hokuyo(LaserSensorWithArc):
    """
    A laser scanner configured to mimick the Hokuyo sensor.

    See :doc:`the laser scanners general documentation <../sensors/laserscanner>` for details.
    """
    _blendname = "sick"
    _name = "Hokuyo"
    _short_desc = "Hokuyo laser scanner"

    def __init__(self, name=None):
        LaserSensorWithArc.__init__(self, name)
        mesh = Cylinder("HokuyoCylinder")
        mesh.scale = (.04, .04, .08)
        mesh.color(0, 0, 0)
        self.append(mesh)
        # set components-specific properties
        self.properties(Visible_arc = False, laser_range = 30.0,
                scan_window = 270.0, resolution = 0.25)
        # set the frequency to 10 Hz
        self.frequency(10)

class Sick(LaserSensorWithArc):
    """
    A laser scanner configured to mimick the SICK sensor.

    See :doc:`the laser scanners general documentation <../sensors/laserscanner>` for details.
    """
    _blendname = "sick"
    _name = "SICK"
    _short_desc = "SICK laser scanner"


    def __init__(self, name=None):
        LaserSensorWithArc.__init__(self, name)
        # set components-specific properties
        self.properties(Visible_arc = False, laser_range = 30.0,
                scan_window = 180.0, resolution = 1.0)
        # set the frequency to 10 Hz
        self.frequency(10)
        # append sick mesh, from MORSE_COMPONENTS/sensors/sick.blend
        self.append_meshes(['SickMesh'])

class SickLDMRS(LaserSensorWithArc):
    """
    A laser scanner configured to mimick the SICK LD-MRS sensor.

    See :doc:`the laser scanners general documentation <../sensors/laserscanner>` for details.
    """
    _blendname = "sick"
    _name = "SICK LD-MRS"
    _short_desc = "SICK LD-MRS laser scanner"


    def __init__(self, name=None):
        LaserSensorWithArc.__init__(self, name)
        # set components-specific properties
        self.properties(Visible_arc = False, laser_range = 30.0,
                scan_window = 100.0, resolution = 0.25, layers = 4,
                layer_separation = 0.8, layer_offset = 0.125)
        mesh = Cube("SickMesh")
        mesh.scale = (.05, .0825, .044)
        mesh.color(1., 1., .9)
        self.append(mesh)
        # set the frequency to 4 Hz
        self.frequency(4)

class Infrared(LaserSensorWithArc):
    """
    A laser scanner configured to mimick a infra-red proximity sensor.

    See :doc:`the laser scanners general documentation <../sensors/laserscanner>` for details.
    """
    _name = "Infrared Proximity Sensor"
    _short_desc = "Infra-red (IR) proximity sensor."

    def __init__(self, name=None):
        LaserSensorWithArc.__init__(self, name)
        mesh = Cube("InfraredCube")
        mesh.scale = (.02, .02, .02)
        mesh.color(.8, .8, .8)
        self.append(mesh)
        # set components-specific properties
        self.properties(Visible_arc = True, laser_range = 2.0,
                scan_window = 20.0, resolution = 1.0)
        # set the frequency to 10 Hz
        self.frequency(10)
        # create default Arc_
        self.create_laser_arc()

class Velocity(SensorCreator):
    _classpath = "morse.sensors.velocity.Velocity"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        mesh = Sphere("VelocitySphere")
        mesh.scale = (.04, .04, .01)
        mesh.color(.5, .5, .5)
        self.append(mesh)

class VideoCamera(SensorCreator):
    _classpath = "morse.sensors.video_camera.VideoCamera"
    _blendname = "camera"
    def __init__(self, name=None):
        SensorCreator.__init__(self, name)
        self.camera = Camera("CameraRobot")
        self.camera.name = "CameraRobot"
        self.append(self.camera)
        self.properties(cam_width = 256, cam_height = 256, cam_focal = 35.0,
                        capturing = True, Vertical_Flip = True)
        # set the frequency to 20 Hz
        self.frequency(20)
        # add toggle capture action (`Space` key)
        bpymorse.add_sensor(type="KEYBOARD")
        obj = bpymorse.get_context_object()
        sensor = obj.game.sensors[-1]
        sensor.key = 'SPACE'
        bpymorse.add_controller(type='LOGIC_AND')
        controller = obj.game.controllers[-1]
        bpymorse.add_actuator(type='PROPERTY')
        actuator = obj.game.actuators[-1]
        actuator.mode = 'TOGGLE'
        actuator.property = 'capturing'
        controller.link(sensor = sensor, actuator = actuator)
        # looking in +X
        SensorCreator.rotate(self, x=math.pi/2, z=math.pi/2)
        # append CameraMesh with its textures
        self.append_meshes(['CameraMesh'], "camera")
        self.rotate(z=math.pi)
    def rotate(self, x=0, y=0, z=0):
        SensorCreator.rotate(self, x=y, y=z, z=x)

class DepthCamera(VideoCamera):
    _classpath = "morse.sensors.depth_camera.DepthCamera"
    _blendname = "camera"

    def __init__(self, name=None):
        VideoCamera.__init__(self, name)
        self.properties(cam_near=1.0, cam_far=20.0, retrieve_depth=True,
                        Vertical_Flip=False)

class Velodyne(DepthCamera):
    _classpath = "morse.sensors.depth_camera.DepthCameraRotationZ"
    _blendname = "velodyne"

    def __init__(self, name=None):
        DepthCamera.__init__(self, name)
        self.properties(rotation=self.camera._bpy_object.data.angle)

VelodyneZB = Velodyne # morse 1.1 compatible

class SemanticCamera(VideoCamera):
    _classpath = "morse.sensors.semantic_camera.SemanticCamera"
    _blendname = "camera"

    def __init__(self, name=None):
        VideoCamera.__init__(self, name)
        self.properties(cam_width = 512, cam_height = 512, Vertical_Flip = False)


class VelodyneRayCast(LaserSensorWithArc):
    _classpath = "morse.sensors.laserscanner.LaserScannerRotationZ"
    _blendname = "velodyne"

    def __init__(self, name=None):
        LaserSensorWithArc.__init__(self, name)
        # set components-specific properties
        self.properties(Visible_arc = True, laser_range = 50.0,
                        scan_window = 31.500, resolution = 0.5)
        # append velodyne mesh, from MORSE_COMPONENTS/sensors/velodyne.blend
        arc = self.create_laser_arc()
        # Select only arc (active)
        bpymorse.select_only(arc)
        # Rotate Arc to scan vertically
        arc.rotation_euler = (math.radians(90), math.radians(12), 0)
        bpymorse.apply_transform(rotation=True)
        self.append_meshes(['VelodyneMesh'])

class Clock(SensorCreator):
    _classpath = "morse.sensors.clock.Clock"

    def __init__(self, name=None):
        SensorCreator.__init__(self, name)

class Kinect(SensorCreator):
    """
    Microsoft Kinect RGB-D camera, implemented as a pair of depth camera and video
    camera.

    See the general documentation for :doc:`video cameras
    <../sensors/video_camera>` and :doc:`depth cameras
    <../sensors/depth_camera>` for details.

    """
    _name = "Kinect"
    _short_desc="Microsoft Kinect RGB-D sensor"

    def __init__(self, name="Kinect"):
        # meta sensor composed of 2 cameras (rgb and depth)
        SensorCreator.__init__(self, name)
        mesh = Cube("KinectMesh")
        mesh.scale = (.02, .1, .02)
        mesh.color(.8, .8, .8)
        self.append(mesh)
        self.video_camera = VideoCamera('rgb')
        self.video_camera.properties(cam_width = 128, cam_height=128)
        self.depth_camera = DepthCamera('depth')
        self.depth_camera.properties(classpath='morse.sensors.depth_camera.DepthVideoCamera')
        self.depth_camera.properties(cam_width = 128, cam_height=128, Vertical_Flip=True)
        self.append(self.video_camera)
        self.append(self.depth_camera)
        # TODO find Kinect spec for cameras positions
        self.video_camera.location = (.06, +.08, .04)
        self.depth_camera.location = (.06, -.08, .04)
    def add_stream(self, *args, **kwargs):
        # Override AbstractComponent method
        self.video_camera.add_stream(*args, **kwargs)
        self.depth_camera.add_stream(*args, **kwargs)
    def profile(self):
        # Override AbstractComponent method
        self.video_camera.profile()
        self.depth_camera.profile()
    def frequency(self, frequency):
        # Override AbstractComponent method
        self.video_camera.frequency(frequency)
        self.depth_camera.frequency(frequency)

class Collision(SensorCreator):
    _classpath = "morse.sensors.collision.Collision"

    def __init__(self, name=None):
        """ Sensor to detect objects colliding with the current object,
        with more settings than the Touch sensor
        """
        SensorCreator.__init__(self, name)
        obj = bpymorse.get_context_object()
        # Sensor, Collision Sensor, detects static and dynamic objects but
        # not the other collision sensor objects.
        obj.game.physics_type = 'SENSOR'
        # Specify a collision bounds type other than the default
        obj.game.use_collision_bounds = True
        # replace Always sensor by Collision sensor
        sensor = obj.game.sensors[-1]
        sensor.type = 'COLLISION'
        # need to get the new Collision Sensor object
        sensor = obj.game.sensors[-1]
        sensor.use_pulse_true_level = True # FIXME doesnt seems to have any effect
        # Component mesh (eye sugar)
        mesh = Cube("CollisionMesh")
        mesh.scale = (.02, .02, .02)
        mesh.color(.8, .2, .1)
        self.append(mesh)
    def properties(self, **kwargs):
        SensorCreator.properties(self, **kwargs)
        if 'collision_property' in kwargs:
            try:
                sensor = self._bpy_object.game.sensors[-1]
                sensor.property = kwargs['collision_property']
            except KeyError:
                pass

########NEW FILE########
__FILENAME__ = abstractobject
import logging; logger = logging.getLogger("morse." + __name__)
from abc import ABCMeta, abstractmethod
import morse.core.services
from collections import OrderedDict

from morse.core.exceptions import MorseRPCInvokationError, MorseServiceAlreadyRunningError

class AbstractObject(object):
    """ An abstract object. All components in MORSE (either physical components
    like actuators or sensors or pseudo components like component overlays) 
    inherit from AbstractObject.
    
    This abstract class provides all RPC service-related mechanics.
    """

    # Make this an abstract class
    __metaclass__ = ABCMeta

    def __init__(self):
        
        self.on_completion = None
        """ When a task is considered 'completed' (the semantic of
        'completed' is left to each component), the default_action
        method is expected to call this callback (if not None) with
        the task status (from ``core.status.*``) + optional return value
        as a tuple.

        For instance::

          self.on_completion((status.FAILED, "Couldn't reach the target"))
          self.on_completion((status.SUCCESS, {'x':1.0, 'y':0.54}))
          self.on_completion((status.SUCCESS))
        """
        
        # Dictionary to store the data used by each component
        self.local_data = OrderedDict()
        
        # Define lists of dynamically added functions
        self.del_functions = []
        

    def finalize(self):
        """ Destructor method. """
        logger.info("%s: I'm dying!!" % self.name())
        # Call specific functions added to this object
        for function in self.del_functions:
            function()
    
    def register_services(self):
        """
        Register the component services, if any.
        Methods to register are marked '_morse_service' by the '@service' decorator.
        """
        for fn in [getattr(self, fn) for fn in dir(self) if hasattr(getattr(self, fn), "_morse_service")]:
            name = fn._morse_service_name if fn._morse_service_name else fn.__name__
            morse.core.services.do_service_registration(fn, self.name(), name, fn._morse_service_is_async)
    
    
    def completed(self, status, result = None):
        """ This method must be invoked by the component when a service completes.

        Calling this method triggers the notification of task completion to the client.

        :param morse.core.status status: status (success, failure...) of the task

        :param result: results of the service, if any (may be any valid Python object)

        """
        if self.on_completion:
            """ In overlays or in a chain of service, it is legal to call again a
            service in the completion handler. However, to test if there
            is a running service or not for a service, we test if
            self.on_completion is None or not. So, we need to make sure
            that self.on_completion is None when calling the completion
            handler. To do that, store another reference, clean up the
            one stored in self.on_completion, and call it through our reference
            """
            fn = self.on_completion
            self.on_completion = None
            fn((status, result))

    def interrupt(self):
        """ This method is automatically invoked by the component when a
        service is interrupted, basically to notify to the client that
        the task has been interrupted.

        It can be overriden in each component to provide a true
        interrupt, for exemple resseting the speed command to 0.0.

        If you override it, do not forget to call ``self.completed`` with
        ``status.PREEMPTED``.

        """
        import morse.core.status

        self.completed(morse.core.status.PREEMPTED)

    def set_service_callback(self, cb):
        """ Sets the callback function that is to be invoked when the current
        request completes.

        This is automatically set by the @async_service decorator and should
        not usually be directly called.
        """

        if self.on_completion: # A callback is already registered -> a service is running
            old_cb = self.on_completion
            if not hasattr(old_cb.service, "_morse_service_interruptible"):
                # No policy (interruptible/noninterruptible) set for
                # the service currently running. We throw an exception 
                # to be caught by the middleware. Up to it to define 
                # the default policy.
                raise MorseServiceAlreadyRunningError(old_cb.service, "A service (" + \
                        old_cb.service.__name__ + ") is already running. I do not know what to do.")

            interruptible = old_cb.service._morse_service_interruptible

            if interruptible:
                self.interrupt()
            else:
                raise MorseRPCInvokationError("A non-interruptible service (" + old_cb.service.__name__ + ") is already running")

        self.on_completion = cb
    
    @abstractmethod
    def name(self):
        """ The name of the component, as appearing when exposing services for
        instance.
        """
        pass
    
    def print_data(self):
        """ Print the current data for the component instance. """
        for variable, data in self.local_data.items():
            res = variable + str(data) + " "
            logger.info("%s" % res)

########NEW FILE########
__FILENAME__ = actuator
import logging; logger = logging.getLogger("morse." + __name__)
from abc import ABCMeta, abstractmethod
import morse.core.object

class Actuator(morse.core.object.Object):
    """ Basic Class for all actuator objects.

    Provides common attributes. """

    # Make this an abstract class
    __metaclass__ = ABCMeta

    def __init__ (self, obj, parent=None):
        """ Constructor method. """
        # Call the constructor of the parent class
        morse.core.object.Object.__init__(self, obj, parent)

        # Define lists of dynamically added functions
        self.input_functions = []
        self.input_modifiers = []

    def finalize(self):
        self._active = False
        morse.core.object.Object.finalize(self)
        del self.input_functions[:]
        del self.input_modifiers[:]


    def action(self):
        """ Call the action functions that have been added to the list. """
        # Do nothing if this component has been deactivated
        if not self._active:
            return

        # Update the component's position in the world
        self.position_3d.update(self.bge_object)

        received = False
        status = False

        # First the input functions
        for function in self.input_functions:
            status = function(self)
            received = received or status

        if received:
            # Data modification functions
            for function in self.input_modifiers:
                function()

        # Call the regular action function of the component
        self.default_action()

########NEW FILE########
__FILENAME__ = ansistrm
#
# Based on https://gist.github.com/758430
# Copyright (C) 2010-2011 Vinay Sajip. All rights reserved. Licensed under the new BSD license.
#
import logging
import os
from morse.helpers.morse_logging import SECTION, ENDSECTION

if os.name == 'nt':
    import ctypes
    import re

class ColorizingStreamHandler(logging.StreamHandler):
    # color names to indices
    color_map = {
        'black': 0,
        'red': 1,
        'green': 2,
        'yellow': 3,
        'blue': 4,
        'magenta': 5,
        'cyan': 6,
        'white': 7,
    }

    #levels to (background, foreground, bold/intense, blink -- only if bold = False)
    bright_scheme = {
        logging.DEBUG: (None, 'blue', False, False),
        logging.INFO: (None, 'white', False, False),
        logging.WARNING: (None, 'yellow', False, False),
        logging.ERROR: (None, 'red', False, False),
        logging.CRITICAL: ('red', 'white', True, False),
        SECTION: (None, 'green', True, False),
        ENDSECTION: (None, 'green', False, False),
    }
    
    dark_scheme = {
        logging.DEBUG: (None, 'blue', False, False),
        logging.INFO: (None, 'black', False, False),
        logging.WARNING: (None, 'yellow', False, False),
        logging.ERROR: (None, 'red', False, False),
        logging.CRITICAL: ('red', 'black', True, False),
        SECTION: (None, 'green', True, False),
        ENDSECTION: (None, 'green', False, False),
    }

    mono_scheme = {
        logging.DEBUG: (None, None, False, False),
        logging.INFO: (None, None, False, False),
        logging.WARNING: (None, None, False, False),
        logging.ERROR: (None, None, False, False),
        logging.CRITICAL: (None, None, False, False),
        SECTION: (None, None, False, False),
        ENDSECTION: (None, None, False, False),
    }

    xmas_scheme = {
        logging.DEBUG: ('red', 'yellow', False, True),
        logging.INFO: ('red', 'white', False, True),
        logging.WARNING: ('red', 'yellow', False, True),
        logging.ERROR: ('red', 'yellow', False, True),
        logging.CRITICAL: ('red', 'white', False, True),
        SECTION: ('red', 'yellow', False, True),
        ENDSECTION: ('red', 'white', False, True),
    }
    
    csi = '\x1b['
    reset = '\x1b[0m'
    
    def __init__(self, scheme = None):
        logging.StreamHandler.__init__(self)
        if scheme == "xmas":
            self.level_map = self.xmas_scheme
        elif scheme == "dark":
            self.level_map = self.dark_scheme
        elif scheme == "mono":
            self.level_map = self.mono_scheme
        else:
            self.level_map = self.bright_scheme
    
    @property
    def is_tty(self):
        isatty = getattr(self.stream, 'isatty', None)
        return isatty and isatty()

    def emit(self, record):
        try:
            message = self.format(record)
            # Don't do anything if the StreamHandler does not exist
            if message is None:
                return
            stream = self.stream
            if not self.is_tty:
                stream.write(message)
            else:
                self.output_colorized(message)
            stream.write(getattr(self, 'terminator', '\n'))
            self.flush()
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            self.handleError(record)

    if os.name != 'nt':
        def output_colorized(self, message):
            self.stream.write(message)
    else:
        ansi_esc = re.compile(r'\x1b\[((?:\d+)(?:;(?:\d+))*)m')

        nt_color_map = {
            0: 0x00,    # black
            1: 0x04,    # red
            2: 0x02,    # green
            3: 0x06,    # yellow
            4: 0x01,    # blue
            5: 0x05,    # magenta
            6: 0x03,    # cyan
            7: 0x07,    # white
        }

        def output_colorized(self, message):
            parts = self.ansi_esc.split(message)
            write = self.stream.write
            h = None
            fd = getattr(self.stream, 'fileno', None)
            if fd is not None:
                fd = fd()
                if fd in (1, 2): # stdout or stderr
                    h = ctypes.windll.kernel32.GetStdHandle(-10 - fd)
            while parts:
                text = parts.pop(0)
                if text:
                    write(text)
                if parts:
                    params = parts.pop(0)
                    if h is not None:
                        params = [int(p) for p in params.split(';')]
                        color = 0
                        for p in params:
                            if 40 <= p <= 47:
                                color |= self.nt_color_map[p - 40] << 4
                            elif 30 <= p <= 37:
                                color |= self.nt_color_map[p - 30]
                            elif p == 1:
                                color |= 0x08 # foreground intensity on
                            elif p == 0: # reset to default color
                                color = 0x07
                            else:
                                pass # error condition ignored
                        ctypes.windll.kernel32.SetConsoleTextAttribute(h, color)

    def colorize(self, message, record):
        if record.levelno in self.level_map:
            bg, fg, bold, blink = self.level_map[record.levelno]
            params = []
            if bg in self.color_map:
                params.append(str(self.color_map[bg] + 40))
            if fg in self.color_map:
                params.append(str(self.color_map[fg] + 30))
            if bold:
                params.append('1')
            elif blink:
                params.append('5')
            if params:
                message = ''.join((self.csi, ';'.join(params),
                                   'm', message, self.reset))
        return message

    def format(self, record):
        try:
            message = logging.StreamHandler.format(self, record)
        # Catch the case when there is a zombie logger, when re-launching
        #  the simulation with 'p'.
        # This seems to be caused by an incorrect cleaning on the Builder
        except AttributeError as detail:
            return None
        if self.is_tty:
            message = self.colorize(message, record)
        return message

def main():
    root = logging.getLogger()
    root.setLevel(logging.DEBUG)
    root.addHandler(ColorizingStreamHandler())
    logging.debug('DEBUG')
    logging.info('INFO')
    logging.warning('WARNING')
    logging.error('ERROR')
    logging.critical('CRITICAL')

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = blenderapi
""" This module wraps the calls to the Blender Python API. This is intended
for all the cases we need to run MORSE code outside Blender (mostly for
documentation generation purposes).
"""

import sys

fake = False

# running in Blender?
if sys.executable.endswith('blender'):
    import bpy
    try:
        import bge
    except ImportError:
        # Can fail if we are in Blender but not yet in the GameEngine,
        # typically at 'Builder' stage.
        fake = True
else:
    print("WARNING: MORSE is running outside Blender! (sys.executable != blender)")
    fake = True

from morse.core import mathutils

UPARROWKEY = None
DOWNARROWKEY = None
RIGHTARROWKEY = None
LEFTARROWKEY = None
LEFTCTRLKEY = None
LEFTALTKEY = None

AKEY = None
BKEY = None
DKEY = None
EKEY = None
FKEY = None
IKEY = None
JKEY = None
KKEY = None
LKEY = None
NKEY = None
OKEY = None
QKEY = None
RKEY = None
SKEY = None
UKEY = None
VKEY = None
WKEY = None
XKEY = None
ZKEY = None

LEFTMOUSE = None
RIGHTMOUSE = None

F5KEY = None
F7KEY = None
F8KEY = None

CONSTRAINT_TYPE_KINEMATIC = None
CONSTRAINT_IK_DISTANCE = None

if not fake:
    UPARROWKEY = bge.events.UPARROWKEY
    DOWNARROWKEY = bge.events.DOWNARROWKEY
    RIGHTARROWKEY = bge.events.RIGHTARROWKEY
    LEFTARROWKEY = bge.events.LEFTARROWKEY
    LEFTCTRLKEY = bge.events.LEFTCTRLKEY
    LEFTALTKEY = bge.events.LEFTALTKEY
    AKEY = bge.events.AKEY
    BKEY = bge.events.AKEY
    DKEY = bge.events.DKEY
    EKEY = bge.events.EKEY
    FKEY = bge.events.FKEY
    IKEY = bge.events.IKEY
    JKEY = bge.events.JKEY
    KKEY = bge.events.KKEY
    LKEY = bge.events.LKEY
    NKEY = bge.events.NKEY
    OKEY = bge.events.OKEY
    QKEY = bge.events.QKEY
    RKEY = bge.events.RKEY
    SKEY = bge.events.SKEY
    UKEY = bge.events.UKEY
    VKEY = bge.events.UKEY
    WKEY = bge.events.WKEY
    XKEY = bge.events.XKEY
    ZKEY = bge.events.ZKEY

    LEFTMOUSE = bge.events.LEFTMOUSE
    RIGHTMOUSE = bge.events.RIGHTMOUSE

    F8KEY = bge.events.F8KEY
    F7KEY = bge.events.F7KEY
    F5KEY = bge.events.F5KEY

    CONSTRAINT_TYPE_KINEMATIC = bge.logic.CONSTRAINT_TYPE_KINEMATIC
    CONSTRAINT_IK_DISTANCE = bge.logic.CONSTRAINT_IK_DISTANCE

def input_active():
    if not fake:
        return bge.logic.KX_INPUT_ACTIVE
    else:
        return None

def input_just_activated():
    if not fake:
        return bge.logic.KX_INPUT_JUST_ACTIVATED
    else:
        return None

def input_just_released():
    if not fake:
        return bge.logic.KX_INPUT_JUST_RELEASED
    else:
        return None

def input_none():
    if not fake:
        return bge.logic.KX_INPUT_NONE
    else:
        return None

def keyboard():
    if not fake:
        return bge.logic.keyboard
    else:
        return None

def controller():
    if not fake:
        return bge.logic.getCurrentController()
    else:
        return None

def scene():
    if not fake:
        return bge.logic.getCurrentScene()
    else:
        return None

def add_scene(name, overlay=1):
    if not fake:
        return bge.logic.addScene(name, overlay)
    else:
        return None

def get_scene_list():
    if not fake:
        return bge.logic.getSceneList()
    else:
        return None

def get_scene_map():
    if not fake:
        return {s.name: s for s in bge.logic.getSceneList()}
    else:
        return None

def render():
    if not fake:
        return bge.render
    else:
        return None


def hascameras():
    if not fake:
        return hasattr(bge.logic, 'cameras')
    else:
        return None


def initcameras():
    if not fake:
        bge.logic.cameras = {}


def cameras():
    if not fake:
        return bge.logic.cameras
    else:
        return None


def mousepointer(visible = True):
    if not fake:
        bge.logic.mouse.visible = visible


def constraints():
    if not fake:
        return bge.constraints
    else:
        return None


def texture():
    if not fake:
        return bge.texture
    else:
        return None

def objectdata(name):
    if not fake:
        return bpy.data.objects[name]
    else:
        return None

def materialdata(name):
    if not fake:
        return bpy.data.materials[name]
    else:
        return None

def game_settings():
    if not fake:
        return bpy.context.scene.game_settings
    else:
        return None


def getalwayssensors(obj):
    if not fake:
        return [s for s in obj.sensors if isinstance(s, bge.types.SCA_AlwaysSensor)]
    else:
        return []

def getfrequency():
    if not fake:
        return bge.logic.getLogicTicRate()
    else:
        return 0

class PersistantStorage(dict):
        __getattr__= dict.__getitem__
        __setattr__= dict.__setitem__
        __delattr__= dict.__delitem__

def persistantstorage():
    """Simply returns the bge.logic object, that persists
    between calls to the script.
    """
    if not fake:
        if not hasattr(bge.logic, "morsedata"):
            bge.logic.morsedata = PersistantStorage()
        return bge.logic.morsedata
    else:
        return {}

def version():
    if not fake:
        return bpy.app.version
    else:
        return 0,0,0

def getssr():
    if not fake:
        return bge.logic.getCurrentScene().objects["Scene_Script_Holder"]
    else:
        return None

def joysticks():
    if not fake:
        return bge.logic.joysticks
    else:
        return None

def isfastmode():
    for area in bpy.context.window.screen.areas:
        if area.type == 'VIEW_3D':
            for space in area.spaces:
                if space.type == 'VIEW_3D':
                    return space.viewport_shade == 'WIREFRAME'

def gravity():
    if not fake:
        sce = scene()
        # All supported version of blender do not support it, so well
        # guess if we don't have the support
        if hasattr(sce, 'gravity'):
            return sce.gravity
        else:
            return mathutils.Vector((0.0, 0.0, -9.81))
    else:
        return None

########NEW FILE########
__FILENAME__ = datastream
import logging; logger = logging.getLogger("morse." + __name__)
# Modules necessary to dynamically add methods to Middleware subclasses
import os
import sys
import re
import types

from abc import ABCMeta, abstractmethod

from morse.core.sensor import Sensor
from morse.core.actuator import Actuator
from morse.middleware import AbstractDatastream
from morse.helpers.loading import create_instance


def register_datastream(classpath, component, args):
    datastream = create_instance(classpath, component, args)
    # Check that datastream implements AbstractDatastream
    if not isinstance(datastream, AbstractDatastream):
        logger.warning("%s should implement morse.middleware.AbstractDatastream"%classpath)
    # Determine weither to store the function in input or output list,
    #   what is the direction of our stream?
    if isinstance(component, Sensor):
        # -> for Sensors, they *publish*,
        component.output_functions.append(datastream.default)
    elif isinstance(component, Actuator):
        # -> for Actuator, they *read*
        component.input_functions.append(datastream.default)
    else:
        logger.error("The component is not an instance of Sensor or Actuator")
        return None
    # from morse.core.abstractobject.AbstractObject
    component.del_functions.append(datastream.finalize)

    return datastream


class DatastreamManager(object):
    """ Basic class for all middlewares that export a datastream interface (ie,
    all of them)

    Provides common attributes. """

    # Make this an abstract class
    __metaclass__ = ABCMeta

    def __del__(self):
        """ Destructor method. """
        logger.info("Closing datastream interface <%s>." % self.__class__.__name__)


    def register_component(self, component_name, component_instance, mw_data):
        datastream_classpath = mw_data[1] # aka. function name
        datastream_args = None
        if len(mw_data) > 2:
            datastream_args = mw_data[2] # aka. kwargs, a dictonnary of args

        # Create a socket server for this component
        return register_datastream(datastream_classpath, component_instance,
                                                         datastream_args)



########NEW FILE########
__FILENAME__ = exceptions
class MorseError(Exception):
    """ General MORSE Error. """
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class MorseEnvironmentError(MorseError):
    """ Morse Error triggered while manipulating MORSE environments
    (typically, wrong permissions on a file or inexistant environment).
    """
    pass


class MorseMiddlewareError(MorseError):
    """ Morse Error caused by a Middleware.
    """
    pass

class MorseMultinodeError(MorseError):
    """ Morse Error caused by a Multinode configuration.
    """
    pass

class MorseServiceError(MorseError):
    """ Morse Error caused by a Service.
    """
    pass

class MorseRPCInvokationError(MorseServiceError):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class MorseServiceAlreadyRunningError(MorseRPCInvokationError):
    def __init__(self, running_service, value):
        self.value = value
        self.running_service = running_service
    def __str__(self):
        return repr(self.value)

class MorseMethodNotFoundError(MorseRPCInvokationError):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class MorseWrongArgsError(MorseRPCInvokationError):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class MorseRPCNbArgsError(MorseWrongArgsError):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class MorseRPCTypeError(MorseWrongArgsError):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class MorseBuilderError(MorseError):
    """ Morse Error caused by the Builder API.
    """
    pass

class MorseBuilderNoComponentError(MorseBuilderError):
    """ Morse Error caused by a wrong component in Builder.
    """
    def __init__(self, value):
        self.value = value
        import sys
        sys.exit("Unable to create simulation scene. Check builder script for typos.\nExecution terminated!")

class MorseBuilderBadSyntaxError(MorseBuilderError):
    """ Morse Error caused by a mistyped method or object name in Builder.
    """
    def __init__(self, value):
        self.value = value
        import sys
        sys.exit("Method or object name not found. Check builder script for typos.\nExectution terminated!")

########NEW FILE########
__FILENAME__ = mathutils
""" This module wraps the calls to the Blender 'mathutils' API. This is intended
for all the cases we need to run MORSE code outside Blender (mostly for
documentation generation purposes).
"""

import sys

# running in Blender?
if not sys.executable.endswith('blender'):
    print("WARNING: MORSE is running outside Blender! "
          "(sys.executable != blender)")

    def Matrix(*args):
        return None
    def Vector(*args):
        return None
    def Euler(*args):
        return None
    def Quaternion(*args):
        return None
else:
    from mathutils import Matrix, Vector, Euler, Quaternion


########NEW FILE########
__FILENAME__ = modifier
import logging; logger = logging.getLogger("morse." + __name__)
# Modules necessary to dynamically add methods to Middleware subclasses

from morse.modifiers import AbstractModifier
from morse.core.sensor import Sensor
from morse.core.actuator import Actuator
from morse.helpers.loading import create_instance

def register_modifier(classpath, component, args):
    modifier = create_instance(classpath, component, args)
    if not modifier:
        logger.error("INITIALIZATION ERROR: Modifier '%s' module could not be "
                     "found!\n\n Could not import modules necessary for the "
                     "selected modifier. Check that they can be found inside "
                     "your PYTHONPATH variable." % classpath)
        return None

    # Check that modifier implements AbstractDatastream
    if not isinstance(modifier, AbstractModifier):
        logger.error("%s should implement morse.middleware.AbstractModifier" %
                     classpath)
        return None

    # Determine weither to store the function in input or output list,
    #   what is the direction of our stream?
    if isinstance(component, Sensor):
        # -> for Sensors, they *publish*,
        component.output_modifiers.append(modifier.modify)
    elif isinstance(component, Actuator):
        # -> for Actuator, they *read*
        component.input_modifiers.append(modifier.modify)
    else:
        logger.error("Component %s is not an instance of Sensor or Actuator" %
                     component.__class__)
        return None

    return modifier

########NEW FILE########
__FILENAME__ = morse_time
"""
This module deals with the time management in Morse, providing several
possible implementations.

At the moment, it provides two implementations:
    - best effort (i.e. try to simulate at real-time, by dropping
      frame). The simulation is less acurate, because the physical steps
      are not really constant.
    - fixed simulation step. Compute all physical / logical step. The
      simulation will be more precise, but the simulation time will
      differ from computer clock time.
"""

import logging
logger = logging.getLogger("morse." + __name__)
import time
from morse.core import blenderapi
from morse.helpers.statistics import Stats

class BestEffortStrategy:
    def __init__ (self):
        self.time = time.time()

        self._stat_jitter = Stats()
        self._stat_nb_frame = Stats()
        self._time_frame = 0.0
        self._last_time = 0.0
        self._nb_frame = 0

        logger.info('Morse configured in Best Effort Mode')

    def update (self):
        self.time = time.time()
        self._update_statistics()

    def name(self):
        return 'Best Effort'
    
    @property
    def mean(self):
        return self._stat_jitter.mean

    def statistics(self):
        return {
            "mean_time" : self._stat_jitter.mean,
            "variance_time": self._stat_jitter.variance,
            "mean_frame_by_sec": self._stat_nb_frame.mean,
            "variance_frame_by_sec": self._stat_nb_frame.variance
        }

    def _update_statistics(self):
        if self._last_time == 0.0:
            self._last_time = self.time
        else:
            ds = self.time - self._last_time
            self._last_time = self.time
            self._stat_jitter.update(ds)

        if self._nb_frame == 0:
            self._time_frame = self.time
            self._nb_frame = 1
        else:
            if self.time - self._time_frame > 1.0:
                self._stat_nb_frame.update(self._nb_frame)
                self._nb_frame = 0
            else:
                self._nb_frame = self._nb_frame + 1

class FixedSimulationStepStrategy:
    def __init__ (self):
        self.time = time.time()
        self._incr = 1.0 / blenderapi.getfrequency()

        self._stat_jitter = Stats()
        self._last_time = 0.0

        logger.info('Morse configured in Fixed Simulation Step Mode with '
                    'time step of %f sec ( 1.0 /  %d)' %
                    (self._incr, blenderapi.getfrequency()))

    def update (self):
        self.time = self.time + self._incr
        self._update_statistics()

    def name (self):
        return 'Fixed Simulation Step'

    @property
    def mean(self):
        return self._incr

    def statistics (self):
        return {
            "mean_time" : self._stat_jitter.mean,
            "variance_time": self._stat_jitter.variance,
            "diff_real_time": self.time - time.time()
        }

    def _update_statistics(self):
        if self._last_time == 0.0:
            self._last_time = time.time()
        else:
            ds = time.time() - self._last_time
            self._last_time = time.time()
            self._stat_jitter.update(ds)

class TimeStrategies:
    (BestEffort, FixedSimulationStep) = range(2)

    internal_mapping = {
        BestEffort:
            { "impl": BestEffortStrategy,
              "python_repr": b"TimeStrategies.BestEffort",
              "human_repr" : "Best Effort"
            },
        FixedSimulationStep:
            { "impl": FixedSimulationStepStrategy,
              "python_repr": b"TimeStrategies.FixedSimulationStep",
              "human_repr": "Fixed Simulation Step"
            }
        }

    @staticmethod
    def make(strategy):
        try:
            return TimeStrategies.internal_mapping[strategy]["impl"]()
        except KeyError:
            return None
    @staticmethod
    def python_repr(strategy):
        try:
            return TimeStrategies.internal_mapping[strategy]["python_repr"]
        except KeyError:
            return None

    @staticmethod
    def human_repr(strategy):
        try:
            return TimeStrategies.internal_mapping[strategy]["human_repr"]
        except KeyError:
            return None


def time_isafter(t1, t2):
    """ Returns true if t1 > t2 in morse_time. Returns false otherwise """
    return t2 - t1 < blenderapi.persistantstorage().time.mean / 2

########NEW FILE########
__FILENAME__ = multinode
import logging; logger = logging.getLogger("morse." + __name__)
from abc import ABCMeta, abstractmethod

class SimulationNodeClass (object):
    """ Class defining the behaviour of a simulation node.

    It will be used to synchronise the simulation when done
    on two or more simulation nodes.
    """

    # Make this an abstract class
    __metaclass__ = ABCMeta
    
    def __init__(self, name, server_address, server_port):
        self.node_name = name
        self.host = server_address
        self.port = server_port
        self.initialize()

    def __del__(self):
        self.finalize()

    @abstractmethod
    def initialize(self):
        """ 
        Initialize the MORSE node.
        """
        pass

    @abstractmethod
    def synchronize(self):
        """
        Synchronize simulation nodes.
        Publishes node's robots to the other simulation nodes and
        update node's external robots from data published by other simulation
        nodes.
        """
        pass

    @abstractmethod
    def finalize(self):
        """
        Finalize the MORSE node.
        """
        pass

########NEW FILE########
__FILENAME__ = object
import logging; logger = logging.getLogger("morse." + __name__)
from abc import ABCMeta, abstractmethod
from collections import OrderedDict
from morse.core.abstractobject import AbstractObject

import morse.helpers.transformation
from morse.core.services import service

from morse.core import blenderapi

class Object(AbstractObject):
    """ Basic Class for all 3D objects (components) used in the simulation.
        Provides common attributes.
    """

    # Make this an abstract class
    __metaclass__ = ABCMeta

    def __init__ (self, obj, parent=None):

        AbstractObject.__init__(self)

        # Fill in the data sent as parameters
        self.bge_object = obj
        self.robot_parent = parent

        self.level = self.bge_object.get("abstraction_level", "default")

        # Variable to indicate the activation status of the component
        self._active = True

        self.check_level()

        # Define the position of sensors with respect
        #  to their robot parent
        # TODO: implement this using morse.helpers.transformation
        if parent:
            self.relative_position = obj.getVectTo(parent.bge_object)

        # Create an instance of the 3d transformation class
        self.position_3d = morse.helpers.transformation.Transformation3d(obj)

        self.initialize_local_data()
        self.update_properties()

        # The actual frequency at which the action is called
        # The frequency of the game sensor specifies how many times
        # the action is skipped when the logic brick is executed.
        # e.g. game sensor frequency = 0 -> sensor runs at full logic rate
        sensors = blenderapi.getalwayssensors(obj)
        self._frequency = blenderapi.getfrequency()
        # New MORSE_LOGIC sensor, see AbstractComponent.morseable()
        morselogic = [s for s in sensors if s.name.startswith('MORSE_LOGIC')]
        if len(morselogic) == 1:
            self._frequency /= morselogic[0].frequency + 1
        # Backward compatible (some actuators got special logic)
        elif len(sensors) == 1:
            self._frequency /= sensors[0].frequency + 1
        elif len(sensors) == 0:
            logger.warning("Can't get frequency for " + self.name() + \
                           " as the Game Logic sensor calling the action can't be found.")
        else:
            logger.warning(self.name() + " has too many Game Logic sensors to get " + \
                    "an unambiguous frequency for the action.")

    def check_level(self):

        if self.level == "default":
            return # fine

        if hasattr(self, '_levels') and self.level in self._levels:
            return #fine

        msg = "Component <%s> has no abstraction level <%s>. Please check your scene." % (self.name(), self.level)
        logger.error(msg)
        raise ValueError(msg)


    def initialize_local_data(self):
        """
        Creates and initializes 'local data' fields, according to the
        current component abstraction level.
        """

        all_data_fields = OrderedDict()

        for cls in reversed(type(self).__mro__):
            if hasattr(cls, '_data_fields'):
                all_data_fields.update(cls._data_fields)

        for name, details in all_data_fields.items():
            default_value, type_, doc, level = details
            if level == "all" or self.level in level:
                self.local_data[name] = default_value


    def fetch_properties(self):
        """
        Returns the "_properties" of a component
        :return: a dictionary of the field "_properties"
        """
        all_properties = OrderedDict()

        #fetches '_properties'
        for cls in reversed(type(self).__mro__):
            if hasattr(cls, '_properties'):
                all_properties.update(cls._properties)

        return all_properties

    @service
    def get_properties(self):
        """     
        Returns the properties of a component.

        :return: a dictionary of the current component's properties

        """
        all_properties = self.fetch_properties()

        return {'properties': all_properties}


    @service
    def get_configurations(self):
        """     
        Returns the configurations of a component (parsed from the properties).

        :return: a dictionary of the current component's configurations

        """
        all_properties = self.fetch_properties()
        tmp = {}
        #parses 'all_properties' to get only "key"-"value"-pairs
        #"key" is python_name and "value" is default_value
        for item in all_properties.items():
            tmp[item[0]] = getattr(self, item[1][3])
        transform = self.robot_parent.position_3d.transformation3d_with(self.position_3d)
        rotation = [ list(vec) for vec in transform.rotation_matrix ]
        translation = list(transform.translation)
        tmp['object_to_robot'] = {'rotation': rotation, 'translation': translation}
        return {'configurations': tmp}


    def update_properties(self):
        """
        Takes all registered properties (see add_property), and update
        their values according to the values set in Blender object.
        """

        all_properties = self.fetch_properties()

        for name, details in all_properties.items():
            default_value, _, _, python_name = details
            val = default_value

            try:
                val = self.bge_object[name]
            except KeyError:
                pass
            setattr(self, python_name, val)

    def name(self):
        return self.bge_object.name

    def action(self):
        """ Call the regular action function of the component.

        Can be redefined in some of the subclases (sensor and actuator).
        """
        self.default_action()

    def in_zones(self, name = None, type = None):
        """
        Determine which zone(s) contain(s) current object

        If a :param name: is precised, check only if this specific zone
        contains the position
        If a :param type: is precised, only search in the zone of this
        type.
        """
        zone_manager = blenderapi.persistantstorage().zone_manager
        return zone_manager.contains(self, name = name, type = type)

    @abstractmethod
    def default_action(self):
        """ Base action performed by any object.

        This method should be implemented by all subclasses that
        will be instanced (GPS, v_Omega, ATRV, etc.).
        """
        pass

    def toggle_active(self):
        self._active = not self._active

    @property
    def frequency(self):
        """ Frequency of the object action in Hz (float). """
        return self._frequency

########NEW FILE########
__FILENAME__ = overlay
import logging; logger = logging.getLogger("morse." + __name__)
logger.setLevel(logging.DEBUG)
from abc import ABCMeta, abstractmethod
from functools import partial
from morse.core.abstractobject import AbstractObject
from morse.core.exceptions import MorseRPCInvokationError

class MorseOverlay(AbstractObject):
    """ This class allows to define 'overlay'. An 'overlay' is a pseudo component
    that masks a MORSE default component behind a custom facet (with for instance
    custom signatures for services, ports, etc.).
    
    This is especially useful when integrating MORSE into an existing robotic
    architecture where components have custom services/ports/topics whose 
    signature does not match MORSE defaults.
    
    As of MORSE 0.4, only services can currently be overlaid.
    """

    # Make this an abstract class
    __metaclass__ = ABCMeta

    def __init__ (self, overlaid_object):
        
        AbstractObject.__init__(self)
        
        # Fill in the data sent as parameters
        self.overlaid_object = overlaid_object
        
        if not self.overlaid_object:
            logger.critical("[INTERNAL ERROR] An overlay can not be initialized before " + \
            "the component it overlays!")

    def _chain_callback(self, fn, result):
        logger.debug("Calling " + self.name() + " chain callback")

        if fn:
            result = fn(result)

        self.on_completion(result)
        self.on_completion = None

    def chain_callback(self, fn = None):
        """ When calling a component asynchronous service from
        an overlay, a callback (used to notify the client upon
        service completion) must be passed through. This callback
        does not usually appear in the service signature since it
        is added by the ``@async_service`` decorator.

        Under normal circumstances, you must use this method as
        callback.

        For instance, assume a ``Dummy`` component and an overlay
        ``MyDummy``:

        .. code-block:: python

            class Dummy(MorseObject):
                @async_service
                def dummy_service(self, arg1):
                    # Here, dummy_service has a callback parameter added
                    # by the decorator
                    pass

            class MyDummy(MorseAbstractobject):
                @async_service
                def mydummy_service(self, arg1):
                    # [...do smthg useful]

                    # We call the overlaid asynchronous service
                    # 'dummy_service' by passing a special callback
                    # returned by 'self.chain_callback()'
                    self.overlaid_object.dummy_service(self.chain_callback(), arg1)

        ``chain_callback`` takes a functor as an optional parameter.
        This functor is called after the (overlaid) service completion, but
        just before notifying the simulator client.

        It can be used for output formatting for instance.

        The functor *must* take one single parameter (a tuple ``(status, result)``)
        and must as well return a tuple ``(status, result)``.

        .. code-block:: python

            class MyDummy(MorseAbstractobject):

                def mydummy_on_completion(self, result):
                    # This functor - here a simple function - simply
                    # format the result output.
                    # It could do anything else.
                    status, value = result
                    return (status, " . ".join(value))

                @async_service
                def mydummy_service(self, arg1):
                    self.overlaid_object.dummy_service(self.chain_callback(self.mydummy_on_completion), arg1)

        :param fn: a functor to be called on service completion, before 
                    notifying the clients. Must have the following signature:
                    (status, result) fn((status, result))

        """
        return partial(self._chain_callback, fn)
        

    def name(self):
        """ Returns the overlaid component name.
        
        By default, the name of the class of the overlaid component.
        
        Override this method in your overlay to expose an alternative name.
        """
        return self.overlaid_object.name()

    def interrupt(self):
        if self.overlaid_object.on_completion:
            self.overlaid_object.interrupt()
        else:
            AbstractObject.interrupt(self)

########NEW FILE########
__FILENAME__ = request_manager
import logging; logger = logging.getLogger("morse." + __name__)
#logger.setLevel(logging.DEBUG)
import os
import sys
import uuid
from functools import partial
from abc import ABCMeta, abstractmethod

from morse.core.exceptions import *
from morse.core import status, blenderapi

class RequestManager(object):
    """ Basic Class for all request dispatchers, i.e., classes that
    implement a *request service*.

    A request service offers typically 2 things:
      - the ability for a component (a robot, a sensor or the
        simulator as a whole) to expose a RPC method (typically for
        remote configuration or debug),
      - an interface with a specific middleware to serialize the 
        RPC call and communicate with the outside world.

    Components can register such a service with the 'register_service'
    method. Please check its documentation for details.
 
    To implement a concrete RequestManager (for a new middleware, for instance),
    the following methods must be overloaded:
        - :py:meth:`initialization`: perform here middleware specific initialization
        - :py:meth:`finalization`: perform here middleware specific finalization
        - :py:meth:`post_registration`: put here all middleware specific code
          that must be executed when a new service is registered.
        - :py:meth:`on_service_completion`: this method is called when a 'long term'
          request completes. You should implement here a way to notify
          your clients.
        - :py:meth:`main`: this method is called at each step of the
          simulation. You should read there incoming requests and write back
          results.

    When a new request arrives, you must pass it to :py:meth:`on_incoming_request`
    that dispatch or invoke properly the request.

    Subclasses are also expected to overload the special :py:meth:`__str__`
    method to provide middleware specific names.

   """

    # Make this an abstract class
    __metaclass__ = ABCMeta

    def __init__ (self):
        """ Constructor method.
        """

        # This map holds the list of all registered services
        # It associates a tuple (component,service) to a tuple
        # (rpc_callback, is_async)
        self._services = {}

        # This hold the mapping request id <-> result for asynchronous
        # requests.
        # Keys are request ids, values are either 'None' for pending
        # requests or a tuple (True|False, result|error_msg) for
        # completed service calls.
        # It is updated on each call to :py:meth:`_update_pending_calls`
        self._completed_requests = {}

        # Holds a mapping request_id -> (component, service)
        self._pending_requests = {}


        if not self.initialization():
            raise MorseServiceError("Couldn't create the service manager! Initialization failure")

    @abstractmethod
    def initialization(self):
        """This method is meant to be overloaded by middlewares to perform
        specific initializations.

        Must return True is the initialization is successful, False in other cases.
        """
        pass

    @abstractmethod
    def finalization(self):
        """This method is meant to be overloaded by middlewares to perform
        specific finalizations.

        Must return True is the finalization is successful, False in other cases.
        """
        pass

    def __str__(self):
        """ Should be overloaded by subclasses to help debug request handling
        for each middleware implementation.
        """
        return "Generic request manager"

    @abstractmethod
    def post_registration(self, component_name, service_name, is_async):
        """ This method is meant to be overloaded by middlewares that have
        specific initializations to do when a new service is exposed.

        :param string component_name: name of the component that declare this 
            service
        :param string service_name: Name of the service (if not overloaded 
            in the @service decorator, should be the Python function name that
            implement the service)
        :param boolean is_async: If true, means that the service is asynchronous.
        :return: True if the registration succeeded.
        :rtype: boolean
        """
        pass


    def register_async_service(self, component_name, callback, service_name = None):
        """ Allows a component to register an asynchronous RPC method.

        A asynchronous method can last for several cycles without blocking the simulator.
        The callback method must take as first parameter a callable that must be used
        to set the results of the service upon completion.

        For example, consider the following sample of asynchronous service::

            def complex_computation(result_setter, param1, param2):
                do_computation_step() #should stay short, but can last several simulation steps

                if computation_done:
                    result_setter(computation_results)

            request_manager.register_async_service("computer", complex_computation)

        As soon as the 'result_setter' is called with the results of the service,
        the clients of this service are notified via their middlewares.

        See :py:meth:`register_service` for detailed documentation of parameters.
        """
        self.register_service(component_name, callback, service_name, True)


    def register_service(self, component_name, callback, service_name = None, async = False):
        """ Allows a component to register a synchronous RPC method that is made
        publicly available to the outside world.

        :param string component_name: name of the component that declare this service
        :param callable callback: the method name to invoke on incoming
               request.
               If service_name is not defined, it will also be used as
               the public name of the service.
               If async is false (synchronous service), the method is expected to
               return immediately. In this case, its return value is immediately
               send back to the original caller.
        :param boolean async: if true, the service is asynchronous: it can last for
               several cycles without blocking the communication interface.
               See :py:meth:`register_async_service` for details.
        :param service_name: if defined, service_name is used as public
               name for this RPC method.
        """
        
        if hasattr(callback, '__call__'):
            service_name = service_name if service_name else callback.__name__

            self._services[(component_name, service_name)] = (callback, async)

            if self.post_registration(component_name, service_name, async):
                logger.info(str(self) + ": " + \
                    ("Asynchronous" if async else "Synchronous") + \
                    " service '" + service_name + "' for component '" + \
                    component_name + "' successfully registered")
            else:
                logger.info(str(self) + ": Did not register service <%s> " % service_name + \
                        "(could not complete the post-registration step).")

        else:
            logger.error(str(self) + ": Error while registering a new service: " + str(callback) + \
                    " is not a callable object.")
    
    def services(self):
        """ Returns the list of all components and services registered with this
        request manager.
        
        :return: a dictionary of {components:[services...]} listing all services
                 registered with this request manager.
        """
        services = {}
        for component, service in self._services.keys():
            services.setdefault(component, []).append(service)
        
        return services
        
    def on_incoming_request(self, component, service, params):
        """ This method handles incoming requests: it figures out who
        registered the service, checks if the service returns immediately
        or must be started and only later checked for termination, invokes
        the service, and returns the service result (for service that returns
        immediately).

        If something goes wrong while trying to call the method, a
        :py:class:`morse.core.exceptions.MorseRPCInvokationError` is raised.

        If everything goes well, the method return a tuple: ``(True,
        return_value)`` or ``(False, request_id)``. The first item tells
        if the service is a synchronous (short-term) service (value is
        ``True``) or an asynchronous service (``False``).

        For asynchronous services, the returned request id should allow to track
        the completion of the service. Upon completion, :py:meth:`on_service_completion`
        is invoked.

        """

        logger.info("Incoming request " + service + " for " + component + "!")

        #Unique ID for our request
        request_id = uuid.uuid1()

        try:
            method, is_async = self._services[(component, service)]
        except KeyError:
            raise MorseMethodNotFoundError("The request " + service + " has not been registered in " + str(self))

        if is_async:

            # Creates a result setter functor: this functor is used as
            # callback for the asynchronous service.
            result_setter = partial(self._completed_requests.__setitem__, request_id)
            try:
                # Invoke the method with unpacked parameters
                # This method may throw MorseRPCInvokationError if the
                # service initialization fails.
                method(result_setter, *params) if params else method(result_setter)

                # Store the component and service associated to this service
                # (for instance, for later interruption)
                self._pending_requests[request_id] = (component, service)

            except AttributeError as e:
                raise MorseRPCTypeError(str(self) + ": wrong parameter type for service " + service + ". " + str(e))
            except TypeError as e:

                # Check if the type error comes from a wrong # of args.
                # We perform this check only after an exception is
                # thrown to avoid loading the inspect module by default.
                import inspect, traceback
                logger.debug(traceback.format_exc())
                if not params:
                    raise MorseRPCNbArgsError(str(self) + ": parameters expected for service " + service + "! " + str(e))
                elif len(params) != (len(inspect.getargspec(method)[0]) - 2): # -2 because of self and callback
                    raise MorseRPCNbArgsError(str(self) + ": wrong # of parameters for service " + service + ". " + str(e))
                else:
                    raise MorseRPCTypeError(str(self) + ": wrong parameter type for service " + service + ". " + str(e))

            logger.debug("Asynchronous request '" + str(request_id) + "' successfully started.")
            return False, request_id

        else: #Synchronous service.
            #Invoke the method
            logger.info("Synchronous service -> invoking it now.")
            try:
                values = method(*params) if params else method() #Invoke the method with unpacked parameters
            except AttributeError as e:
                raise MorseRPCTypeError(str(self) + ": wrong parameter type for service " + service + ". " + str(e))
            except TypeError as e:
                # Check if the type error comes from a wrong # of args.
                # We perform this check only after an exception is
                # thrown to avoid loading the inspect module by default.
                # TODO: Does it make sense?
                import inspect, traceback
                logger.debug(traceback.format_exc())
                if not params:
                    raise MorseRPCNbArgsError(str(self) + ": parameters expected for service " + service + "! " + str(e))
                if len(params) != (len(inspect.getargspec(method)[0]) - 1): # -1 because of 'self'
                    raise MorseRPCNbArgsError(str(self) + ": wrong # of parameters for service " + service + ". " + str(e))
                else:
                    raise MorseRPCTypeError(str(self) + ": wrong parameter type for service " + service + ". " + str(e))

            # If we are here, no exception has been raised by the
            # service, which mean the service call is successful. Good.
            values = (status.SUCCESS, values)
            logger.info("Done. Result: " + str(values))
            return True, values

    def abort_request(self, request_id):
        """ This method will interrupt a running asynchronous service,
        uniquely described by its request_id
        """
        component_name, service_name = self._pending_requests[request_id]

        for component in blenderapi.persistantstorage().componentDict.values():
            if component.name() == component_name:
                logger.info("calling  interrupt on %s" % str(component))
                component.interrupt()
                return

        # if not found, search in the overlay dictionnary
        for overlay in blenderapi.persistantstorage().overlayDict.values():
            if overlay.name() == component_name:
                logger.info("calling  interrupt on %s" % str(overlay))
                overlay.interrupt()
                return


    def _update_pending_calls(self):
        """This method is called at each simulation steps and check if pending requests are
        completed or not.
        On completion, it calls the :py:meth:`on_service_completion` method.
        """

        if self._completed_requests:
            for request, result in list(self._completed_requests.items()):
                if result:
                    logger.debug(str(self) + ": Request " + str(request) + " is now completed.")
                    del self._pending_requests[request]
                    del self._completed_requests[request]
                    self.on_service_completion(request, result)

    @abstractmethod
    def on_service_completion(self, request_id, result):
        """ This method is called when a asynchronous request completes.

        Subclasses are expected to overload this method with code to notify
        the original request emitter.

        :param uuid request_id: the request id, as return by :py:meth:`on_incoming_request`
                    when processing an asynchronous request
        :param result: the service execution result.
        """
        pass

    @abstractmethod
    def main(self):
        """ This is the main method of the RequestManagerClass: it reads
        external incoming requests, dispatch them through the
        :py:meth:`on_incoming_request` method, and write back answers.
        
        Subclasses are expected to overload this method.
        """
        pass

    def process(self):
        """This method is the one actually called from the MORSE main loop.

        It simply updates the list of pending requests (if any) and calls
        the main processing method.
        """
        self._update_pending_calls()
        self.main()

########NEW FILE########
__FILENAME__ = robot
import logging; logger = logging.getLogger("morse." + __name__)
from abc import ABCMeta
import morse.core.object
from morse.core import blenderapi
from morse.helpers.components import add_property

class Robot(morse.core.object.Object):
    """ Basic Class for all robots

    Inherits from the base object class.
    """
    add_property('_no_gravity', False, 'NoGravity', 'bool',
                'Indicate if we want to consider the gravity for this \
                robot If true, the behaviour is less realistic as the \
                simulator will automatically compensate it. This setting \
                is useful for non-realistic model flying or submarine \
                robot ')
    add_property('_is_ground_robot', False, 'GroundRobot', 'bool',
                 'Indicate if the robot is a ground robot, i.e. \
                  basically if it has no way to control its position on the \
                  Z axis')

    # Make this an abstract class
    __metaclass__ = ABCMeta

    def __init__ (self, obj, parent=None):
        """ Constructor method. """
        # Call the constructor of the parent class
        morse.core.object.Object.__init__(self, obj, parent)
        
        # Add the variable move_status to the object
        self.move_status = "Stop"

        # shift against the simulator time (in ms)
        self.time_shift = 0.0

        self.is_dynamic = bool(self.bge_object.getPhysicsId())

    def action(self):
        """ Call the regular action function of the component. """
        # Update the component's position in the world
        self.position_3d.update(self.bge_object)

        self.default_action()

    def gettime(self):
        """ Return the current time, as seen by the robot, in seconds """
        return blenderapi.persistantstorage().current_time + self.time_shift

    def apply_speed(self, kind, linear_speed, angular_speed):
        """
        Apply speed parameter to the robot

        :param string kind: the kind of control to apply. Can be one of
        ['Position', 'Velocity'].
        :param list linear_speed: the list of linear speed to apply, for
        each axis, in m/s.
        :param list angular_speed: the list of angular speed to apply,
        for each axis, in rad/s.
        """

        parent = self.bge_object
        must_fight_against_gravity = self.is_dynamic and self._no_gravity

        if must_fight_against_gravity:
            parent.applyForce(-blenderapi.gravity())

        if kind == 'Position':
            if must_fight_against_gravity:
                parent.worldLinearVelocity = [0.0, 0.0, 0.0]
            parent.applyMovement(linear_speed, True)
            parent.applyRotation(angular_speed, True)
        elif kind == 'Velocity':
            if self._is_ground_robot:
                linear_speed[2] = parent.localLinearVelocity[2]
            # Workaround against 'strange behaviour' for robot with
            # 'Dynamic' Physics Controller. [0.0, 0.0, 0.0] seems to be
            # considered in a special way, i.e. is basically ignored.
            # Setting it to 1e-6 instead of 0.0 seems to do the trick!
            if angular_speed == [0.0, 0.0, 0.0]:
                angular_speed = [0.0, 0.0, 1e-6]
            parent.setLinearVelocity(linear_speed, True)
            parent.setAngularVelocity(angular_speed, True)

    def force_pose(self, position, orientation):
        parent = self.bge_object

        if self.is_dynamic:
            parent.applyForce(-blenderapi.gravity())
            parent.worldLinearVelocity = [0.0, 0.0, 0.0]
            parent.suspendDynamics()

        if position:
            parent.worldPosition = position

        if orientation:
            parent.worldOrientation = orientation

        if self.is_dynamic:
            parent.restoreDynamics()

########NEW FILE########
__FILENAME__ = sensor
import logging; logger = logging.getLogger("morse." + __name__)
from abc import ABCMeta
import time # profiler
import morse.core.object
from morse.core.services import service
from morse.helpers.components import add_data
from morse.core import blenderapi

class Sensor(morse.core.object.Object):
    """ Basic Class for all sensors

    Inherits from the base object class.
    """

    add_data('timestamp', 0.0, 'float', 
             'number of seconds in simulated time')
    if logger.isEnabledFor(logging.DEBUG):
        add_data('simulator_time', 0.0, 'float', 
                 "number of seconds in real world (Only for debug)")


    # Make this an abstract class
    __metaclass__ = ABCMeta

    def __init__ (self, obj, parent=None):
        """ Constructor method. """
        # Call the constructor of the parent class
        morse.core.object.Object.__init__(self, obj, parent)

        # Define lists of dynamically added functions
        self.output_functions = []
        self.output_modifiers = []

        self.profile = None
        if "profile" in self.bge_object:
            self.time = {}
            self.profile = ["profile", "profile_action", "profile_modifiers",
                            "profile_datastreams"]
            for key in self.profile:
                self.time[key] = 0.0
            self.time_start = time.time()

    def finalize(self):
        self._active = False
        morse.core.object.Object.finalize(self)
        del self.output_functions[:]
        del self.output_modifiers[:]

    def sensor_to_robot_position_3d(self):
        """
        Compute the transformation which will transform a vector from
        the sensor coordinate-frame to the associated robot frame
        """
        main_to_origin = self.robot_parent.position_3d
        main_to_sensor = main_to_origin.transformation3d_with(self.position_3d)
        return main_to_sensor

    def action(self):
        """ Call the action functions that have been added to the list. """
        # Do nothing if this component has been deactivated
        if not self._active:
            return

        # Update the component's position in the world
        self.position_3d.update(self.bge_object)

        self.local_data['timestamp'] = self.robot_parent.gettime()
        if logger.isEnabledFor(logging.DEBUG):
            self.local_data['simulator_time'] = time.time()

        # record the time before performing the default action for profiling
        if self.profile:
            time_before_action = time.time()

        # Call the regular action function of the component
        self.default_action()

        # record the time before calling modifiers for profiling
        if self.profile:
            time_before_modifiers = time.time()

        # Data modification functions
        for function in self.output_modifiers:
            function()

        # record the time before calling datastreams for profiling
        if self.profile:
            time_before_datastreams = time.time()

        # Lastly output functions
        for function in self.output_functions:
            function(self)

        # profiling
        if self.profile:
            time_now = time.time()
            self.time["profile"] += time_now - time_before_action
            self.time["profile_action"] += time_before_modifiers - time_before_action
            self.time["profile_modifiers"] += time_before_datastreams - time_before_modifiers
            self.time["profile_datastreams"] += time_now - time_before_datastreams
            morse_time = time_now - self.time_start
            for key in self.profile:
                ratio = self.time[key] / morse_time
                # format the display
                self.bge_object[key] = "%4.1f%% %s"% (100.0 * ratio, '' * int(10 * ratio))
            if morse_time > 1: # re-init mean every sec
                for key in self.profile:
                    self.time[key] = 0.0
                self.time_start = time.time()

    @service
    def get_local_data(self):
        """
        Returns the current data stored in the sensor.

        :return: a dictionary of the current sensor's data
        """
        return self.local_data

########NEW FILE########
__FILENAME__ = services
import logging; logger = logging.getLogger("morse." + __name__)
import sys


from functools import partial

from morse.core import blenderapi
from morse.core.exceptions import MorseServiceError
from morse.helpers.loading import create_instance

class MorseServices:
    def __init__(self, impls = None):
        """ Initializes the different MORSE request managers from a list
        of Python classes.

        :param list impls: a list of Python class names (strings) with their module
                path that implement the RequestManager interface.
        """
        if not impls: impls = []
        
        self._request_managers = {}
        self._service_mappings = {}
    
        for impl in impls:
            self.add_request_manager(impl)

    def add_request_manager(self, classpath):
        """ Initializes and adds a new request manager from its name.

        :param string classpath: the name (and path) of the Python class that
                implements the RequestManager interface (eg:
                'morse.middleware.socket_request_manager.SocketRequestManager',
                'morse.middleware.yarp_request_manager.YarpRequestManager',...).
        :return: True if the request manager has been successfully loaded.
        """
        # Check if the request manager do not already exist
        if not classpath in self._request_managers:
            instance = create_instance(classpath)
            if not instance:
                logger.error("Request Manager %s not found. Check for typos in the configuration file!"%classpath)
                return False

            # In case of instantiation failure, this may raise a MorseServiceError exception
            self._request_managers[classpath] = instance
            logger.info("Successfully initialized the %s request manager." % classpath)
        
        return True


    def register_request_manager_mapping(self, component, request_manager):
        """Adds a mapping between a component and a request manager: all
        services exposed by this component are handled by this request manager.

        A component may have 0, 1 or more request managers. if more than one,
        each request manager can independently invoke the service.
        
        :param string component: the name of the component that use *request_manager*
                as request manager.
        :param string request_manager: the classpath of the request manager (eg:
                'morse.middleware.socket_request_manager.SocketRequestManager',
                'morse.middleware.yarp_request_manager.YarpRequestManager',...).
        """

        if not request_manager in self._request_managers:
            raise MorseServiceError("Request manager '%s' has not been registered!" % request_manager)

        instance = self._request_managers[request_manager]

        if component in self._service_mappings:
            self._service_mappings[component].add(instance)
        else:
            self._service_mappings[component] = {instance, }


    def __del__(self):
        """ Removes all registered request managers, calling their destructors. """
        logger.info("Deleting all request managers...")
        for rqst_manager in self._request_managers.values():
            if not rqst_manager.finalization():
                logger.warning("finalization of the service manager did not complete successfully!")
            
            logger.info("%s: service manager closed." % rqst_manager)
            
        self._request_managers.clear()
        self._service_mappings.clear()
        
    def get_request_managers(self, component):
        if not component in self._service_mappings:
            logger.error("no service manager is available for the " + component + " component! This error " +  \
                "can have several causes. Maybe you forgot to add the middleware 'empty', or " + \
                "you are using a middleware that does not currently support requests. ")
            raise MorseServiceError("No request manager has been mapped to the component %s" % component)
        
        return self._service_mappings[component]

    def request_managers(self):
        """ Returns the list of active request managers.

        :returns: a dictionary of active request managers {class name: instance}
        """
        return self._request_managers

    def process(self):
        """ Calls the *process()* method of each registered request manager.
        """
        for name, instance in self._request_managers.items():
            instance.process()


def do_service_registration(fn, component_name = None, service_name = None, async = False, request_managers = None):

    if blenderapi.fake: #doc mode
        return

    if not component_name:
        logger.error("A service has been registered without component: " + str(fn))
        return

    if not request_managers:
        request_managers = blenderapi.persistantstorage().morse_services.get_request_managers(component_name)

    for manager in request_managers:
        name = service_name if service_name else fn.__name__
        logger.debug("Registering service " + name + " in " + component_name + " (using " + manager.__class__.__name__ + ")")
        manager.register_service(component_name, fn, name, async)

def async_service(fn = None, component = None, name = None):
    """  The @async_service decorator.

    Refer to the @service decorator for most of the doc.

    Asynchronous service specifics:

    - The function that is decorated is expected to simply start the
      service, and immediately return.
    - If the service can not be started, the function must throw a
      :py:class:`MorseRPCInvokationError` with a error message
      explaining why the initialization failed.  

      """
    return service(fn, component, name, async = True)

def service(fn = None, component = None, name = None, async = False):
    """ The @service decorator.

    This decorator can be used to automagically register a service in
    MORSE. Simply decorate the method you want to export as a RPC service
    with @service and MORSE automatically add and register it with the
    right middleware (depending on what is specified in the simulation
    configuration file).

    This decorator works both with free function and for methods in
    classes inheriting from
    :py:class:`morse.core.object.Object`. In the former case,
    you must specify a component (your service will belong to this
    namespace), in the later case, it is automatically set to the name
    of the corresponding MORSE component.

    :param callable fn: [automatically set by Python to point to the
      decorated function] 
    :param string component: you MUST set this parameter to define the
      name of the component which export the service ONLY for free
      functions. Cf explanation above.
    :param string name: by default, the name of the service is the name
      of the method. You can override it by setting the 'name' argument.
    :param boolean async: if set to True (default value when using 
      @async_service), a new 'callback' parameter is added to the method.
      This callback is used to notify the service initiator that the service
      completed. The callback does not need to be build manually: 
      :py:meth:`morse.core.request_manager.RequestManager.on_incoming_request`
      takes care of it.
    """
    if hasattr(fn, "__call__"):
        # If the @service decorator has no explicit parameter, then Python
        # pass directly the function -> a callable. We can register it.
        if not component:
            # If component is not defined, we assume it is a class method.
            # In this case, the service registration is defered to the
            # class instanciation (cf object.py), and we simply mark
            # this method as a service.
            logger.debug("In @service: Decorating method "+ fn.__name__)
            dfn = fn
            if async:
                def decorated_fn(self, callback, *param):
                    # Stores in the callback the original calling
                    # service.
                    try:
                        callback.service = decorated_fn
                    except AttributeError:
                        raise MorseServiceError("Invalid callback for async service. Did you forget to pass the chain callback from an overlay?")

                    self.set_service_callback(callback)
                    try:
                        fn(self, *param)
                    except BaseException as e:
                        # Failure during service invokation? remove the
                        # callback and re-raise
                        self.on_completion = None
                        raise e

                dfn = decorated_fn
                dfn.__name__ = fn.__name__
                dfn.__doc__ = fn.__doc__

                # Copy all special values the original method may have.
                # This is useful in case of cascading decorator (cf
                # @ros_action for instance).
                for attr, value in fn.__dict__.items():
                    setattr(dfn, attr, value)

            dfn._morse_service = True
            dfn._morse_service_name = name
            dfn._morse_service_is_async = async

            return dfn

        else:
            if async:
                logger.warning("asynchronous service must be declared within a MorseObject class.")
                return

            logger.debug("In @service: Decorating free function "+ fn.__name__)
            # We assume it's a free function, and we register it.
            do_service_registration(fn, component, name, async)
            return fn
    else:
         # ...else, we build a new decorator
        return partial(service, component = component, name = name, async = async)

def interruptible(fn):
    """ The @interruptible decorator.

    Use this decorator to set an (asynchronous) service to be 
    interruptible.

    If MORSE receives a request for a new service while an
    interruptible service is running, the running service is
    preempted (the requester receives a :data:`morse.core.status.PREEMPTED` 
    status), and the new one is started.

    See also :meth:`noninterruptible` decorator.
    """
    logger.debug("In @interruptible: Decorating method "+ fn.__name__)
    fn._morse_service_interruptible = True

    return fn

def noninterruptible(fn):
    """ The @noninterruptible decorator.

    Use this decorator to set an (asynchronous) service to be non
    interruptible.

    If MORSE receives a request for a new service while a non
    interruptible service is running, a failure message is returned
    to the requester.

    See also :meth:`interruptible` decorator.
    """
    logger.debug("In @noninterruptible: Decorating method "+ fn.__name__)
    fn._morse_service_interruptible = False

    return fn


########NEW FILE########
__FILENAME__ = status
#Request status constants

#: The request was successfully achieved
SUCCESS = "SUCCESS"

#: The request was interupted and replaced by another one
PREEMPTED = "PREEMPTED"

#:The request failed.
FAILED = "FAILED"



########NEW FILE########
__FILENAME__ = wheeled_robot
import logging; logger = logging.getLogger("morse." + __name__)
from abc import ABCMeta
from math import sqrt
import morse.core.robot
from morse.core import blenderapi
from morse.core import mathutils
from morse.helpers.components import add_property

class PhysicsWheelRobot(morse.core.robot.Robot):
    """ Abstract base class for robots with wheels that turn as
        the robot moves.
        The wheels must be children of the robot in the Blender file.
        """
    # Make this an abstract class
    __metaclass__ = ABCMeta

    add_property('_has_suspension', True, 'HasSuspension', 'bool', 
                 'Determine if the underlaying robot has suspension, \
                  i.e. wheels can move independently of the body of the \
                  robot')
    add_property('_has_steering', True, 'HasSteering', 'bool',
                 'Determine if the wheels turn independently of the body \
                  of the robot.')

    # Local dictionaries to store references to the wheels
    _wheel_index = ['FL', 'FR', 'RL', 'RR']

    def __init__(self, obj, parent):
        morse.core.robot.Robot.__init__(self, obj, parent)
        self._wheels = {}
        self._wheel_positions = {}
        self._wheel_orientations = {}
        self._wheel_joints = {}

    def action(self):
        """ Overload the 'action' method of the Robot
            This one will compute the transformations considering the different
            axis orientation used by this kind of robots """
        # Update the component's position in the world
        self.position_3d.update_Y_forward(self.bge_object)

        self.default_action()


    def get_wheels(self):
        # get pointers to and physicsIds of all objects
        # get wheel pointers - needed by wheel speed sensors and to
        # set up constraints
        # bullet vehicles always have 4 wheels
        scene = blenderapi.scene()

        self._wheel_radius = None

        caster_wheel_name = self.bge_object.get('CasterWheelName', None)

        #  inherited from the parent robot
        for index in self._wheel_index:
            name = "Wheel%sName" % index
            # Get the actual name of the object from the properties
            #  of the parent robot
            try:
                wheel = scene.objects[self.bge_object[name]]
            except:
                #import traceback
                #traceback._exc()
                wheel = None

            if wheel:
                self._wheels[index] = wheel
                logger.info("\tWheel %s: %s" % (index, wheel.name))
                self._wheel_positions[index] = \
                    mathutils.Vector(wheel.worldPosition)
                self._wheel_orientations[index] = \
                    mathutils.Matrix(wheel.worldOrientation)
                # Make the wheels orphans
                wheel.removeParent()
                # Keep their transformations
                #wheel.worldPosition = self._wheel_positions[index]
                #wheel.worldOrientation = self._wheel_orientations[index]

                # get wheel radius if not already computed
                if wheel.name != caster_wheel_name and not self._wheel_radius:
                    self._wheel_radius = self.get_wheel_radius(self.bge_object[name])

        logger.debug("get_wheels %s" % self._wheels)

        # Add a free rotating wheel if indicated in the robot
        if caster_wheel_name and caster_wheel_name != 'None':
            wheel = scene.objects[caster_wheel_name]
            wheel_position = mathutils.Vector(wheel.worldPosition)
            self.attach_caster_wheel_to_body(wheel, self.bge_object, wheel_position)

    def get_track_width(self):
        # get lateral positions of the wheels
        pos_l = self._wheel_positions['FL']
        pos_r = self._wheel_positions['FR']

        diff_x = pos_l[0] - pos_r[0]
        diff_y = pos_l[1] - pos_r[1]
        diff_z = pos_l[2] - pos_r[2]
        return sqrt( diff_x ** 2 + diff_y ** 2 + diff_z ** 2)

    def get_wheel_radius(self, wheel_name):
        dims = blenderapi.objectdata(wheel_name).dimensions
        # average the x and y dimension to get diameter - divide by 2 for radius
        radius = (dims[0]+dims[1])/4
        return radius


class MorsePhysicsRobot(PhysicsWheelRobot):
    """ Basic Class for robots using individual physics constraints

    Inherits from the base robot class.
    """

    add_property('_fix_turning', 0.0, 'FixTurningSpeed', 'double', 
                'Overwrite the value of the distance between wheels in '
                'the computations of the wheel speeds. This effectively '
                'changes the turning speed of the robot, and can be used '
                'to compensate for the slip of the wheels while turning. '
                'If the value 0.0 is used, the real distance between wheels '
                'is used.')

    def __init__ (self, obj, parent=None):
        """ Constructor method. """
        # Call the constructor of the parent class
        PhysicsWheelRobot.__init__(self, obj, parent)

        # get wheel references and ID's
        self.get_wheels()

        # construct the vehicle
        self.build_vehicle()

        if self._fix_turning != 0.0:
            self._trackWidth = self._fix_turning

        logger.warn("Using wheel separation of %.4f" % self._trackWidth)

        # Force speed at 0.0 at startup
        self.apply_vw_wheels(0.0, 0.0)


    def build_vehicle(self):
        """ Apply the constraints to the vehicle parts. """

        # chassis ID - main object should be chassis model
        self._chassis_ID = self.bge_object.getPhysicsId()

        # get track width
        self._trackWidth = self.get_track_width()

        # set up wheel constraints
        # add wheels to either suspension arms or vehicle chassis
        if self._has_suspension:
            self.build_model_with_suspension()
        else:
            self.build_model_without_suspension()

#    def build_model_with_suspension(self):
#        """ Add all the constraints to attach the wheels to
#        the a-arms and then the a-arms to the body """
#        scene = blenderapi.scene()
#        # get suspension arm ID's
#        # front left A-arm
#        try:
#            if self.bge_object['ArmFLName']:
#                self._armFL=scene.objects[self.bge_object['ArmFLName']]
#        except:
#            import traceback
#            traceback.print_exc()
#
#        # front right A-arm
#        try:
#            if self.bge_object['ArmFRName']:
#                self._armFR=scene.objects[self.bge_object['ArmFRName']]
#        except:
#            import traceback
#            traceback.print_exc()
#
#        # rear left arm
#        try:
#            if self.bge_object['ArmRLName']:
#                self._armRL=self.bge_object['ArmRLName']
#        except:
#            import traceback
#            traceback.print_exc()
#
#        # rear right arm
#        try:
#            if self.bge_object['ArmRRName']:
#                self._armRR=self.bge_object['ArmRRName']
#        except:
#            import traceback
#            traceback.print_exc()
#
#        # put together front wheels and suspension
#        self._wheelFLJoint=self.AttachWheelWithSuspension(self._wheelFL,self.bge_object,self._armFL)
#        self._wheelFRJoint=self.AttachWheelWithSuspension(self._wheelFR,self.bge_object,self._armFR)
#
#        self._wheelRLJoint=self.AttachWheelWithSuspension(self._wheelRL,self.bge_object,self._armRL)
#        self._wheelRRJoint=self.AttachWheelWithSuspension(self._wheelRR,self.bge_object,self._armRR)

    def build_model_without_suspension(self):
        """ Add all the constraints to attach the wheels to the body """
        for index in self._wheels.keys():
            self._wheel_joints[index] = self.attach_wheel_to_body(
                    self._wheels[index], self.bge_object,
                    self._wheel_positions[index])

    def attach_wheel_to_body(self, wheel, parent, wheel_pos):
        """ Attaches the wheel to the given parent using a 6DOF constraint

        Set the wheel positions relative to the robot in case the
        chassis was moved by the builder script or manually in blender
        """

        result = parent.getVectTo(wheel)
        ## result is a unit vector (result[2]) and a length(result[0])
        ## multiply them together to get the complete vector
        wheel_pos = result[0] * result[2]

        logger.debug("Added wheel '%s' at ('%f','%f','%f')" %
                (wheel.name, wheel_pos[0], wheel_pos[1], wheel_pos[2]))

        # create constraint to allow wheel to spin
        # For an explanation on the parameters, see:
        # http://www.tutorialsforblender3d.com/GameModule/ClassKX_PyConstraintBinding_1f.html
        joint = blenderapi.constraints().createConstraint(
                parent.getPhysicsId(),  # get physics ID of the parent object
                wheel.getPhysicsId(),   # get physics ID of the wheel object
                12,                     # 6dof constraint
                wheel_pos[0], wheel_pos[1], wheel_pos[2],  # pivot position
                0,0,0,                  # pivot axis
                128)    # flag, 128=disable collision between wheel and parent
        # no parameters are set on x axis to allow full rotation about it
        joint.setParam(4, 0.0, 0.0) # no rotation about Y axis - min=0, max=0
        joint.setParam(5, 0.0, 0.0) # no rotation about Z axis - min=0, max=0
        return joint # return a reference to the constraint

    def attach_caster_wheel_to_body(self, wheel, parent, wheel_pos):
        """ Attaches a freely rotating wheel to the given parent
        using a 6DOF constraint. It can also rotate around the Z axis """

        result = parent.getVectTo(wheel)
        ## result is a unit vector (result[2]) and a length(result[0])
        ## multiply them together to get the complete vector
        wheel_pos = result[0] * result[2]

        logger.debug("Added caster wheel '%s' at ('%f','%f','%f')" %
                (wheel.name, wheel_pos[0], wheel_pos[1], wheel_pos[2]))

        # create constraint to allow wheel to spin
        joint = blenderapi.constraints().createConstraint(
                parent.getPhysicsId(),  # get physics ID of the parent object
                wheel.getPhysicsId(),   # get physics ID of the wheel object
                12,                     # 6dof constraint
                wheel_pos[0], wheel_pos[1], wheel_pos[2],  # pivot position
                0, 0, 0,                  # pivot axis
                128)    # flag, 128=disable collision between wheel and parent
        # no parameters are set on x and z axis to allow full rotation about it
        joint.setParam(4, 0.0, 0.0) # no rotation about Y axis - min=0, max=0
        joint.setParam(5, 0.0, 0.0) # no rotation about Z axis - min=0, max=0
        return joint # return a reference to the constraint

    def apply_vw_wheels(self, vx, vw):
        """ Apply (v, w) to the parent robot. """

        # calculate desired wheel speeds and set them
        if abs(vx) < 0.001 and abs(vw) < 0.001:
            # stop the wheel when velocity is below a given threshold
            for index in self._wheels.keys():
                self._wheel_joints[index].setParam(9, 0, 100.0)

            self._stopped = True
        else:
            # this is need to "wake up" the physic objects if they have
            # gone to sleep apply a tiny impulse straight down on the
            # object
            if self._stopped:
                self.bge_object.applyImpulse(
                   self.bge_object.position, (0.0, 0.1, -0.000001))

            # no longer stopped
            self._stopped = False

            # Another formula for computing left and right wheel speeds:
            # http://arri.uta.edu/acs/jmireles/Robotics/KinematicsMobileRobots.pdf
            v_ws_l = vx - (self._trackWidth / 2.0) * vw
            v_ws_r = vx + (self._trackWidth / 2.0) * vw

            # convert to angular speeds
            w_ws_l = v_ws_l / self._wheel_radius
            w_ws_r = v_ws_r / self._wheel_radius

            # set wheel speeds - front and rear wheels have the same speed
            # Left side wheels
            self._wheel_joints['FL'].setParam(9, w_ws_l, 100.0)
            if 'RL' in self._wheels:
                self._wheel_joints['RL'].setParam(9, w_ws_l, 100.0)
            # Right side wheels
            self._wheel_joints['FR'].setParam(9, w_ws_r, 100.0)
            if 'RR' in self._wheels:
                self._wheel_joints['RR'].setParam(9, w_ws_r, 100.0)

            logger.debug("New speeds set: left=%.4f, right=%.4f" %
                         (w_ws_l, w_ws_r))


    def AttachWheelWithSuspension(self, wheel, parent, suspensionArm):
        """ Attaches the wheel to the a-arm and then the a-arm to the body """
        # TODO: fill this in later - model after Bueraki code
        pass

#    def getWheelSpeeds(self):
#        """ Returns the angular wheel velocity in rad/sec"""
#        # true parameters tell it velocities are local
#        # wheels should be rotating about local Z axis
#        wsFL=self._wheelFL.getAngularVelocity(True)
#        wsFR=self._wheelFR.getAngularVelocity(True)
#        wsRL=self._wheelRL.getAngularVelocity(True)
#        wsRR=self._wheelRR.getAngularVelocity(True)
#        return [wsFL[2], wsFR[2], wsRL[2], wsRR[2]]
#
#    def getWheelAngle(self):
#        """ Returns the accumulated wheel angle in radians"""
#        # true parameters tell it velocities are local
#        # wheels should be rotating about local Z axis
#        wcFL=self._wheelFL.localOrientation.to_euler()
#        wcFR=self._wheelFR.localOrientation.to_euler()
#        wcRL=self._wheelRL.localOrientation.to_euler()
#        wcRR=self._wheelRR.localOrientation.to_euler()
#        return [wcFL[1], wcFR[1], wcRL[1], wcRR[1]]
#
#    def AttachWheelToWheel(self,wheel1,wheel2):
#        # add both wheels on each side to each other but with no
#        # constraints on their motion so that no collision can be set
#        # between them
#        pass

########NEW FILE########
__FILENAME__ = zone
import logging
logger = logging.getLogger("morse." + __name__)
from morse.core import mathutils
import morse.core.object
from sys import float_info

class Zone:
    """ 
    Creates a named zone in the 3D environment. This can be used by
    components via the :py:class:morse.core.ZoneManagerto trigger
    specific behaviours when the component is inside the zone.

    The main method is the contains one, which allow to decide if a
    point is part of a zone (and so potentially to trigger some
    behaviour).

    Note that for simplicity, we currently assume the zone axis follows
    the world axis.
    """
    def __init__(self, obj):
        self.name = obj.name
        self.type = obj['Type']
        self.obj = obj

        mesh = obj.meshes[0]

        # Get list of unique vertexes
        vertexes_ = set()
        for v_index in range(24):
            vertex = mesh.getVertex(0, v_index)
            vertexes_.add(vertex.getXYZ()[:])

        vertexes = [mathutils.Vector(p) for p in vertexes_]

        # Compute range
        self._min_values = [float_info.max, float_info.max, float_info.max]
        self._max_values = [-float_info.max, -float_info.max, -float_info.max]

        for i in range(len(vertexes)):
            for j in range(3):
                # XXX Here, we assume there is no rotation
                vertexes[i][j] = vertexes[i][j] * obj.worldScale[j] + obj.worldPosition[j]
                if self._min_values[j] > vertexes[i][j]:
                    self._min_values[j] = vertexes[i][j]
                if self._max_values[j] < vertexes[i][j]:
                    self._max_values[j] = vertexes[i][j]

    def contains(self, pos):
        """
        Verify if a pos (represented by a vector) is contained in the zone

        The implementation assumes that the zone is a rectangle, with
        axis following world axis.
        """
        res = True
        for i in range(3):
            res = res and pos[i] >= self._min_values[i]
            res = res and pos[i] <= self._max_values[i]
        return res


class ZoneManager:
    """
    Handle the different zones, allowing to search for them
    'efficiently' (at least in an abstract way)
    """
    def __init__(self):
        self.all_zones = {}
        self.zones_by_type = {}

    def add(self, obj):
        new_zone = Zone(obj)
        logger.info("Adding zone %s of type %s" % (new_zone.name, new_zone.type))

        self.all_zones[new_zone.name] = new_zone

        zone_type = self.zones_by_type.get(new_zone.type, None)
        if not zone_type:
            self.zones_by_type[new_zone.type] = {}
            zone_type = self.zones_by_type[new_zone.type]
        zone_type[new_zone.name] = new_zone

    def _get_subset(self, name = None, type = None):
        search_list = self.all_zones

        if name:
            if name in self.all_zones:
                search_list = {name: [self.all_zones[name]]}
            else:
                search_list = {}
        if type:
            if type in self.zones_by_type:
                search_list = self.zones_by_type[type]
            else:
                search_list = {}
        return search_list


    def is_in(self, obj_or_pos, name = None, type = None):
        """
        Determine if obj_or_pos is  in a zone

        If :param obj_or_pos: is a :py:class:morse.core.object.Object,
        consider the position of the object. Otherwise, assume it is a
        position.
        If a :param name: is precised, check only if this specific zone
        contains the position
        If a :param type: is precised, only search in the zone of this
        type.
        """
        pos = obj_or_pos
        if (isinstance(obj_or_pos, morse.core.object.Object)):
            pos = obj_or_pos.position_3d.translation

        search_list = self._get_subset(name, type)

        for zone in search_list.values():
            if zone.contains(pos):
                return True

        return False

    def contains(self, obj_or_pos, name = None, type = None):
        """
        Determine which zone(s) contain(s) the position pos

        If :param obj_or_pos: is a :py:class:morse.core.object.Object,
        consider the position of the object. Otherwise, assume it is a
        position.
        If a :param name: is precised, check only if this specific zone
        contains the position
        If a :param type: is precised, only search in the zone of this
        type.

        The method returns the list of zones containing the position,
        considering the previous limitation
        """
        pos = obj_or_pos
        if (isinstance(obj_or_pos, morse.core.object.Object)):
            pos = obj_or_pos.position_3d.translation

        search_list = self._get_subset(name, type)

        res = []

        for zone in search_list.values():
            if zone.contains(pos):
                res.append(zone)

        return res

########NEW FILE########
__FILENAME__ = environments
import sys
import os
import logging
import re
import shutil

def pyprint(code):
    print(code)

if "-c" in sys.argv or \
   "--with-colors" in sys.argv or \
   "--with-reverse-color" in sys.argv:
    try:
        # If Pygments is installed, use it to nicely render Python code.
        from pygments import highlight
        from pygments.lexers import PythonLexer
        from pygments.formatters import Terminal256Formatter

        def pyprint(code):
            print(highlight(code, PythonLexer(), Terminal256Formatter(style="monokai")))

    except ImportError:
        pass


from morse.core.exceptions import MorseEnvironmentError

logger = logging.getLogger('morse')
##


substr = re.compile("@(.*?)@")

DEFAULT_TEMPLATES_PATH = "share/morse/data/templates"

# no good way to know if a file is binary or not. So use a list of extensions
BINARY_FILE_EXT = [".blend"] 

joinpth = os.path.join # little shortcut...

###################

## Attention! the first file of each of these lists is used to check
## if the component already exist: do not put file in "append" mode 
## (like __init__.py) as first entry.

BASIC = ["default.py", 
         "scripts/@env@_client.py",
         "src/@env@/__init__.py", 
         "src/@env@/builder/__init__.py"]

ROBOT = ["src/@env@/robots/@name@.py", 
         "src/@env@/robots/__init__.py", 
         "src/@env@/builder/robots/@name@.py", 
         "src/@env@/builder/robots/__init__.py", 
         "data/@env@/robots/@name@.blend"]

SENSOR = ["src/@env@/sensors/@name@.py", 
          "src/@env@/sensors/__init__.py", 
          "src/@env@/builder/sensors/@name@.py",
          "src/@env@/builder/sensors/__init__.py"]

ACTUATOR = ["src/@env@/actuators/@name@.py", 
            "src/@env@/actuators/__init__.py", 
            "src/@env@/builder/actuators/@name@.py",
            "src/@env@/builder/actuators/__init__.py"]

###################

NEW_ROBOT_MSG = ["""
A template for a new robot called <{name}> has been 
added to the <{env}> environment.

----------------------------------------------------------
To complete the equipment of your robot, edit:
{prefix}/src/{env}/builder/robots/{name}.py

You can also modify its Blender mesh:
{prefix}/data/{env}/robots/{name}.blend

For advanced usage, you may also edit its internal 
definition here:
{prefix}/src/{env}/robots/{name}.py
----------------------------------------------------------

To use the robot in your simulation script, add the following
lines:

""", ("""from {env}.builder.robots import {classname}

# add a new {name} robot in the simulation
{name} = {classname}()
#{name}.translate(...)
#{name}.add_default_interface('socket')

""", 'python'),
"""----------------------------------------------------------
Happy simulation!
"""]

NEW_ACTUATOR_MSG = ["""
A template for a new actuator called <{name}> has been 
added to the <{env}> environment.

----------------------------------------------------------
Edit {prefix}/src/{env}/actuators/{name}.py to implement the
behaviour of your actuator.

----------------------------------------------------------
To use it on your robot, edit your robot description in
{prefix}/src/{env}/builder/robots/
and add these lines:

""", ("""from {env}.builder.actuators import {classname}

# create a new {name} actuator
{name} = {classname}()

robot.append({name})

""", 'python'),
"""----------------------------------------------------------
Happy simulation!
"""]

NEW_SENSOR_MSG = ["""
A template for a new sensor called <{name}> has been 
added to the <{env}> environment.

----------------------------------------------------------
Edit {prefix}/src/{env}/sensors/{name}.py to implement the
behaviour of your sensor.

----------------------------------------------------------
To use it on your robot, edit your robot description in
{prefix}/src/{env}/builder/robots/
and add these lines:

""", ("""from {env}.builder.sensors import {classname}

# create a new {name} sensor
{name} = {classname}()

robot.append({name})

""", 'python'),
"""----------------------------------------------------------
Happy simulation!
"""]


#################################################################

class Environment():

    def __init__(self, morse_prefix, env_name, env_path = None):
        """
        :param morse_prefix" the installation 
            prefix of MORSE
        :param env_name: the name of the environment
            we want to modify.
        :param env_path: the relative or absolute 
            path to the environment. Default to `env_name`.
        """
        self.morse_prefix = morse_prefix
        self.env = env_name
        self.path = env_path or env_name
        self.abspath = os.path.abspath(self.path)

        self.tpls = joinpth(os.path.normpath(self.morse_prefix),
                            os.path.normpath(DEFAULT_TEMPLATES_PATH))

    def _make_safe_name(self, name):
        tmp = "".join(c for c in name if c.isalnum() or c==' ').rstrip()
        tmp.replace(" ", "_")
        if tmp[0].isdigit():
            tmp = "_" + tmp
        return tmp

    def _substitute_str(self, instr, **kwargs):
        res = instr
        for kw in substr.findall(instr):
            if kw in kwargs:
                res = res.replace("@%s@" % kw, kwargs[kw])
        return res

    def _configure(self, origin, target, **kwargs):
        """ Create a temporary file which is the configured version of
        ``origin``: every @keyword@ present in ``origin`` is replaced by
        the value passed as named argument.

        The configured file is saved as ``target``

        For instance:

        test.tpl:
            print("@text@")

        -> invokation:

        _configure("test.tpl", "test.py", text = "Hello World")

        """

        # do not configure binary files
        if os.path.splitext(target)[1] in BINARY_FILE_EXT:
            shutil.copy(origin, target)
            return

        with open(origin, 'r') as infile:
            content = infile.readlines()
            if content and "#APPEND" in content[0]:
                with open(target, 'a') as outfile:
                    for l in content[1:]:
                        outfile.write(self._substitute_str(l, **kwargs))

            else:
                with open(target, 'w') as outfile:
                    for l in content:
                        outfile.write(self._substitute_str(l, **kwargs))

    def check_writable(self, path):
        if not os.access(path, os.W_OK):
            raise MorseEnvironmentError("You do not have write permission "
                                        "in <%s>!" % self.path)

    def check_env_exists(self):
        if not os.access(self.path, os.F_OK):
            raise MorseEnvironmentError("<%s> (expected in \"%s\") does not "
                                        "exist! You may want to create first "
                                        "the environment with 'morse create "
                                        "<env>'." % (self.env, self.path))

        self.check_writable(self.path)

    def _install_files(self, files, force = False, **kwargs):

        firstfile = True

        for f in files:
            path, name = os.path.split(f)

            newpath = self._substitute_str(path, **kwargs)
            newname = self._substitute_str(name, **kwargs)

            try:
                os.makedirs(joinpth(self.path, newpath))
            except OSError: # path already exists
                pass

            if firstfile and \
               not force and \
               os.path.exists(joinpth(self.path, newpath, newname)):
                    raise MorseEnvironmentError("A component called <%s> already "
                            "exist. Use 'morse add -f ...' to overwrite." % newname)

            firstfile = False
            self._configure(joinpth(self.tpls, path, name + ".tpl"),
                            joinpth(self.path, newpath, newname),
                            **kwargs)


    def _print_info_msg(self, msg, **kwargs):
        for part in msg:
            if isinstance(part, tuple) and part[1] == 'python':
                part = part[0].format(**kwargs)
                pyprint(part)
            else:
                part = part.format(**kwargs)
                print(part)

    def create(self, force = False):
        """ Initializes a new environment content.
        """

        self.check_writable(".")

        if os.access(self.path, os.F_OK):
            if force:
                shutil.rmtree(self.path)
            else:
                logger.error("A directory called \"%s\" already "
                             "exists!" % self.path)
                sys.exit()

        self._install_files(BASIC, env = self.env)

    def add_component(self, cmpttype, name, force = False):

        self.check_env_exists()

        safename = self._make_safe_name(name)
        if safename != name:
            logger.warning("Replaced name <%s> by suitable identifier: "
                           "<%s>" % (name, safename))

        try:
            if cmpttype == "robot":
                ok = self._install_files(ROBOT,
                                         force = force,
                                         name = safename,
                                         classname = safename.capitalize(),
                                         env = self.env)

                self._print_info_msg(NEW_ROBOT_MSG,
                                     prefix= self.abspath,
                                     name = safename,
                                     classname = safename.capitalize(),
                                     env = self.env)
            elif cmpttype == "sensor":
                desc = input("Enter a short description for sensor <%s>: " % safename)
                self._install_files(SENSOR,
                                    force = force,
                                    name = safename,
                                    classname = safename.capitalize(),
                                    env = self.env,
                                    shortdesc = desc)
                self._print_info_msg(NEW_SENSOR_MSG,
                                     prefix= self.abspath,
                                     name = safename,
                                     classname = safename.capitalize(),
                                     env = self.env)
            elif cmpttype == "actuator":
                desc = input("Enter a short description for actuator <%s>: " % safename)
                self._install_files(ACTUATOR,
                                    force = force,
                                    name = safename,
                                    classname = safename.capitalize(),
                                    env = self.env,
                                    shortdesc = desc)
                self._print_info_msg(NEW_ACTUATOR_MSG,
                                     prefix= self.abspath,
                                     name = safename,
                                     classname = safename.capitalize(),
                                     env = self.env)
            else:
                raise MorseEnvironmentError("Unknown component type %s" % cmpttype)
        except MorseEnvironmentError as mee:
            logger.error(mee.value)

########NEW FILE########
__FILENAME__ = colors
from morse.core import blenderapi

def RGBtoHue(rgbList):
    """ Convert an RGB color to Hue """
    R = rgbList[0]
    G = rgbList[1]
    B = rgbList[2]
    
    # min, max, delta;
    min_rgb = min( R, G, B )
    max_rgb = max( R, G, B )
    delta = max_rgb - min_rgb

    if not delta:
        return 0
    if R == max_rgb:
        H = ( G - B ) / delta # between yellow & magenta
    elif G == max_rgb:
        H = 2 + ( B - R ) / delta # between cyan & yellow
    else:
        H = 4 + ( R - G ) / delta # between magenta & cyan
    H *= 60 # convert to deg
    if H < 0:
        H += 360
    return int(H)


def retrieveHue(obj):
    """ Convert the color of an object to hue

    Retrieve the first material of the first mesh of an object
    and return the hue of this material.
    """
    try:
        mesh = obj.meshes[0] # There can be more than one mesh...
    except IndexError as detail:
        # Nothing will happen if the object has no materials
        return None

    if mesh is not None:
        bMat = blenderapi.materialdata(mesh.getMaterialName(0)[2:])
        return RGBtoHue(bMat.diffuse_color)
    
    return None

########NEW FILE########
__FILENAME__ = components
from collections import OrderedDict
import inspect

def _set_cls_value(kind, name, value):
    curframe = inspect.currentframe()
    try:
        calframe = inspect.getouterframes(curframe, 3)
        try:
            cls_locals =  calframe[2][0].f_locals
            if not kind in cls_locals:
               cls_locals[kind] = OrderedDict()
            cls_locals[kind][name] = value
        finally:
            del calframe
    finally:
        del curframe


def add_level(name, classname, doc = "(no documentation available yet)", default=False):
    """ Defines an abstraction level for a component.

    Abstraction levels are predefined subsets of the component output or
    input, defining a particular functional level for your component.

    .. note::
        Two special level names are reserved: `all` and `default`. You can
        not use them.

    :param name: name of the level
    :param classpath: classpath (ie, module path + classname) that implements
                      the level, or None to use the current class.
    :param doc: short description of the level.
    """
    if name in ["all", "default"]:
        raise NameError("%s is a reserved level name. You can not use it." % name)

    _set_cls_value('_levels', name, (classname, doc, default))


def add_data(name, default_value, type = "", doc = "(no documentation available yet)", level = "all"):
    """
    Defines a new data field for this component, either for export (sensors)
    or for import (actuators).

    .. note::
        Several fields with the same name may be present if they belong to
        different 'abstraction levels'.

    :param name: name of the field
    :param default_value: initial value of the field
    :param type: indicative type value, currently only used for documentation
    :param doc: description of the field
    :param level: (default: `all`) abstraction level this field belong to.
                  Only useful when levels are defined for the component
                  with `add_level` statements.

    """

    if isinstance(level, str) and level is not "all":
        level = [level]
    _set_cls_value('_data_fields', name, (default_value, type, doc, level))

def add_property(python_name, default_value, name, type = "", doc = "(no documentation available yet)"):
    """ Add a property to the current class of component

    :param python_name: name of the Python variable. It will be
                        dynamically added to the component Python
                        script.
    :param default_value: the default value
    :param string name: the name of the property. If used in 
                        the Blender logic bricks, it must match the
                        Blender name.
    :param type: type of the property, for documentation
    :param doc: description of the property.
    """

    _set_cls_value('_properties', name, (default_value, type, doc, python_name))

########NEW FILE########
__FILENAME__ = filt2
import math

class Filt2:
   """ filtre du second ordre Yann """
   def __init__(self, wn = 1.0, ksi = 1.0):
      self.wn = wn
      self.ksi = ksi
      self.x = [0.0, 0.0, 0.0, 0.0 ]
      self.xn = [0.0, 0.0 ]

   def setParam(self,wn , ksi):
      self.wn = wn
      self.ksi = ksi

   def init():
      self.x = [0.0, 0.0, 0.0, 0.0 ]

   def simulate(self,u, dt):
      self.xn[0] = self.x[0] + (self.x[3] + self.x[1])*dt/2.0
      self.xn[1] += (self.x[2] + self.wn * self.wn * (u - self.x[0]) - 2.0 * self.ksi * self.wn * self.x[1]) * dt / 2.0

      self.x[2] = self.wn * self.wn * (u - self.x[0]) - 2.0 * self.ksi * self.wn * self.x[1]
      self.x[3] = self.x[1]
      self.x[0] = self.xn[0]
      self.x[1] = self.xn[1]


########NEW FILE########
__FILENAME__ = loading
"""Loading
Helpers for 'classpath' configuration
"""
import logging; logger = logging.getLogger("morse." + __name__)
import sys

def get_class(classpath):
    """ Returns the class object from a full classpath (like toto.tata.MyTata)
    """
    module_name, class_name = classpath.rsplit('.', 1)
    klass = load_module_attribute(module_name, class_name)

    if not klass:
        logger.error("Could not load the class %s in %s"% (class_name, module_name))
        return None

    return klass


def load_module_attribute(module_name, attribute_name):
    """Dynamically import a Python attribute."""
    try:
        __import__(module_name)
    except ImportError as detail:
        logger.error("Module not found: %s" % detail)
        return None
    module = sys.modules[module_name]
    # Create an instance of the object class
    try:
        attribute = getattr(module, attribute_name)
    except AttributeError as detail:
        logger.error("Module attribute not found: %s" % detail)
        return None
    return attribute

def create_instance(classpath, *args, **kwargs):
    """Creates an instances of a class."""

    klass = get_class(classpath)

    if not klass:
        logger.error("Could not create an instance of %s"%str(classpath))
        return None

    return klass(*args, **kwargs)


def create_instance_level(classpath, level, *args, **kwargs):
    """Creates an instances of a class from a component abstration level."""

    klass = get_class(classpath)

    if not klass:
        logger.error("Could not create an instance of %s"%str(classpath))
        return None

    # Component abstration levels
    if level:

        if not hasattr(klass, "_levels"):
            if level != "default":
                logger.error("Class <%s> does not define abstraction levels. You can not use them here." % str(classpath))
                return None

        if level == "default":
            # iterate over levels to find the one with the default flag
            for key, value in klass._levels.items():
                if value[2]:
                    level = key
                    logger.info("Using default level <%s> for component <%s>" % (level, classpath))
                    break

            if level == "default":
                logger.error("Class <%s> does not define a default abstraction level. You must explicitely set one with <cmpt>.level(<level>). Check the component documentation." % classpath)
                return None

        if level not in klass._levels:
            logger.error("Class <%s> does not define the abstraction level <%s>. Check your scene." % (classpath, level))
            return None

        # The level may define a custom classpath to implement the component
        # behaviour, or 'None' if the parent class is to be used.
        if klass._levels[level][0]:
            return create_instance(klass._levels[level][0], *args, **kwargs)

    return klass(*args, **kwargs)

########NEW FILE########
__FILENAME__ = morse_logging
import logging
import time

starttime = time.time()

SECTION = 25 #INFO = 20, WARNING = 30
logging.addLevelName('SECTION', SECTION)

ENDSECTION = 23 #INFO = 20, WARNING = 30
logging.addLevelName('ENDSECTION', ENDSECTION)

class MorseFormatter(logging.Formatter):
    def __init__(self, *args, **kwargs):
        # can't do super(...) here because Formatter is an
        # old school class
        logging.Formatter.__init__(self, *args, **kwargs)

    def format(self, record):
        level = record.levelname
        module = ".".join(record.name.split(".")[-2:])
        message = logging.Formatter.format(self, record)

        if module not in ["morse", "morse.main", "blender.main"]:
            message = "[" + module + "] " + message

        if level == 'SECTION':
            message = "\n[" + message + "]"

        if level == 'ENDSECTION':
            message = "[" + message + "]"

        if level in ['DEBUG', 'INFO', 'WARNING']:
            message = "[{0: 9.3f}] ".format(record.created - starttime) + message

        return message

########NEW FILE########
__FILENAME__ = morse_math
import logging; logger = logging.getLogger("morse." + __name__)
import math

# euler_angle(object) returns a tuple yaw, pitch, roll, in degree,
# corresponding to the transformation between the origin frame
# and the object frame.
#
# It uses the built-in blender function to_euler
def euler_angle(ob):
    rot_matrix = ob.worldOrientation

    # XXX If we want to have the right handle, we definivly need to transpose
    # the matrix here, but why ?
    rot_matrix.transpose()
    euler = rot_matrix.to_euler()

    return [euler.z, euler.x, euler.y]


def get_rotation_matrix(object):
    """ Return a the rotation matrix of an object.
    Used to transform another object to this one's coordinate system. """

    import copy
    return copy.copy(object.worldOrientation)

def invert_rotation_matrix(object):
    """ Return the inverse of the rotation matrix of an object.

    Used to get the position of another object with respect to
    this one. """
    rotation_matrix = get_rotation_matrix(object)

    # Return a new inverted matrix (requires Blender 2.58)
    return rotation_matrix.inverted()


def normalise_angle(angle):
    """ Force the given angle to be between PI and -PI
    
    This function expects an angle given in radians
    It will reduce the input angle to be less than PI,
    and give it the correct sign.

    Using new method proposed by David Hodo:
    hododav@tigermail.auburn.edu
    """
    return ((angle+math.pi)%(2*math.pi))-math.pi


def rotation_direction(current_angle, target_angle, tolerance, speed):
    """ Test the direction in which a rotation should be made

    Using the current angle of a component and the next desired angle.
    Angles are expected in radians """
    # Check which direction to rotate
    if current_angle < (target_angle - tolerance):
        rotation = speed
    elif current_angle > (target_angle + tolerance):
        rotation = -speed
    # If the angle is within the tolerance, don't rotate
    else:
        rotation = 0

    return rotation


def print_matrix_33(matrix):
    """ print_matrix_33 prints a 3x3 @matrix on stdout """
    for row in matrix:
        line = "[% .4f % .4f % .4f]" % (row[0], row[1], row[2])
        logger.info(line)

def print_matrix_44(matrix):
    """ print_matrix_44 prints a 4x4 @matrix on stdout """
    for row in matrix:
        line = "[% .4f % .4f % .4f % .4f]" % (row[0], row[1], row[2], row[3])
        logger.info(line)

def print_vector (vector):
    """ print a vector with 4 decimals per value """
    line = "[% .4f % .4f % .4f]" % (vector[0], vector[1], vector[2])
    logger.info(line)


def fill_vector(vector, point):
    """ Copy the contents of a list into an existing vector structure. """
    for i in range(3):
        vector[i] = point[i]

########NEW FILE########
__FILENAME__ = motion
import math

def object_is_moving(bge_object):
    """ Check if an object is currently in motion
        
    Will work only for 'dynamic' or 'rigid body' objects in Blender.
    An object is considered to be in motion if any of the three
    components of its velocity vector is greater than an arbitrary
    tolerance.
    """
    # Minimum speed that will trigger the motion "sensor"
    motion_tolerance = 0.01
    speed = bge_object.getLinearVelocity()
    moving = False
    for i in range(3):
        # Test that the local speed is larger than a predefined limit
        if math.fabs(speed[i]) > motion_tolerance:
            moving = True

    return moving

########NEW FILE########
__FILENAME__ = passive_objects
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi


def active_objects():
    """ Returns all active objects in current scene, ie objects that have their
    'Object' property set to True.
    """
    return blenderapi.persistantstorage().passiveObjectsDict.keys()

def graspable_objects():
    """ Returns all objects in current scene that have the
    'Graspable' property set to True, amongst active objects.
    """
    return [obj for (obj, details) in blenderapi.persistantstorage().passiveObjectsDict.items() if details['graspable']]

def details(obj):
    """ Returns a dictionary containing the differents properties for a given
    active object.

    If the object is not active (ie, it has no 'Object' property, or the
    property is set to False), None is returned.

    If no label is available, it defaults to the Blender name.
    The description field may be an empty string.
    If no type is available, it defaults to 'Object'.
    If the graspable flag is not present, it defaults to False.

    :param name: the Blender name of the object.
    :return: a dictionary {'label':string, 'description':string, 'type':string, 'graspable':bool}

    """
    if not obj in blenderapi.persistantstorage().passiveObjectsDict.keys():
        return None
    else:
        return blenderapi.persistantstorage().passiveObjectsDict[obj]

def label(obj):
    """ Returns the label of a given active object.

    If the object is not active (ie, it has no 'Object' property, or the
    property is set to False), None is returned.

    If no label is available, it defaults to the Blender name.

    :param name: the Blender name of the object.
    :return: the label

    """

    det = details(obj)
    return det['label'] if det else None

def obj_from_label(label):
    """ Returns the label of a given active object.

    If the object is not active (ie, it has no 'Object' property, or the
    property is set to False), None is returned.

    If no label is available, it defaults to the Blender name.

    :param name: the Blender name of the object.
    :return: the label

    """
    for obj, det in blenderapi.persistantstorage().passiveObjectsDict.items():
        if det['label'] == label:
            return obj

########NEW FILE########
__FILENAME__ = statistics
"""
Statistics helper for Morse usage
"""

class Stats:
    """
    A simple class to compute basic statistics on some values, computed
    incrementaly
    """
    def __init__(self):
        self.n = 0
        self.mean = 0.0
        self.m2 = 0.0

    def update(self, x):
        self.n = self.n + 1
        delta = x - self.mean
        self.mean = self.mean + delta/self.n
        self.m2 = self.m2 + delta * (x - self.mean)

    @property
    def variance(self):
        return self.m2 / (self.n - 1)

########NEW FILE########
__FILENAME__ = transformation
from morse.core import blenderapi
from morse.core import mathutils
from math import sqrt

class Transformation3d:
    """
    Transformation3d represents a generic 3D transformation. It is used
    by each component of the simulator to know their position in the
    world. Blender does not propose such an interface, only some
    rotation matrix and translation vector.

    Internally, we store an internal 4x4 matrix, and use it to compute
    transformation.  the euler representation is then calculated on base
    of matrix (euler ZYX convention)

    Note : Blender store its matrix in column major mode ...
    """

    def __init__(self, obj):
        """
        Construct a transformation3d. Generate the identify
        transformation if no object is associated to it. Otherwise,
        returns the transformation3D between this object and the world
        reference

        """
        self.matrix = mathutils.Matrix(([1, 0, 0, 0],
                                        [0, 1, 0, 0],
                                        [0, 0, 1, 0],
                                        [0, 0, 0, 1]))

        self.euler = mathutils.Euler([0, 0, 0])
        if obj is not None:
            self.update(obj)

        # For use only by robots moving along the Y axis
        self.correction_matrix = mathutils.Matrix(([0.0, 1.0, 0.0],
                                                   [-1.0, 0.0, 0.0],
                                                   [0.0, 0.0, 1.0]))


    @property
    def x(self):
        """
        Return the translation along the x-axis
        """
        if blenderapi.version() < (2, 62, 0):
            return self.matrix[3][0]
        else:
            return self.matrix[0][3]

    @property
    def y(self):
        """
        Return the translation along the y-axis
        """
        if blenderapi.version() < (2, 62, 0):
            return self.matrix[3][1]
        else:
            return self.matrix[1][3]

    @property
    def z(self):
        """
        Return the translation along the z-axis
        """
        if blenderapi.version() < (2, 62, 0):
            return self.matrix[3][2]
        else:
            return self.matrix[2][3]

    @property
    def yaw(self):
        """
        Returns Euler Z axis, in radian
        """
        return self.euler.z

    @property
    def pitch(self):
        """
        Returns Euler Y axis, in radian
        """
        return self.euler.y

    @property
    def roll(self):
        """
        Returns Euler X axis, in radian
        """
        return self.euler.x

    @property
    def rotation(self):
        """
        Returns the rotation as a unit quaternion
        """
        return self.matrix.to_quaternion()

    @rotation.setter
    def rotation(self, value):
        rmat = value.to_matrix()
        for i in range(0, 3):
            self.matrix[i][0:3] = rmat[i][0:3]
        self.euler = self.matrix.to_euler()

    @property
    def rotation_matrix(self):
        """
        Returns the rotation as a 3x3 matrix
        """
        return self.matrix.to_3x3()

    @property
    def translation(self):
        return self.matrix.translation

    @translation.setter
    def translation(self, value):
        self.matrix.translation = value


    def transformation3d_with(self, t3d):
        """
        Compute the transformation between itself and another
        transformation t3d. In other words, A.transformation3d_with(B)
        returns inv(A) * B.

        self is not modified by the call of this function
        """
        res = Transformation3d(None)
        o2m = self.matrix.copy()
        o2m.invert()
        res.matrix = o2m * t3d.matrix
        res.euler = res.matrix.to_euler()
        return res

    def distance(self, t3d):
        """ 
        Compute the 3d distance between two transformations. 

        nor self, nor t3d are modified by the call of this method
        """
        diff_x = self.x - t3d.x
        diff_y = self.y - t3d.y
        diff_z = self.z - t3d.z

        return sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z)

    def distance_2d(self, t3d):
        """ 
        Compute the 2d distance between two transformations. 

        nor self, nor t3d are modified by the call of this method
        """
        diff_x = self.x - t3d.x
        diff_y = self.y - t3d.y

        return sqrt(diff_x * diff_x + diff_y * diff_y)

    def update(self, obj):
        """
        Update the transformation3D to reflect the transformation
        between obj (a blender object) and the blender world origin
        """
        self.matrix = obj.worldOrientation.to_4x4()

        pos = obj.worldPosition
        for i in range(0, 3):
            if blenderapi.version() < (2, 62, 0):
                self.matrix[3][i] = pos[i]
            else:
                self.matrix[i][3] = pos[i]
        self.matrix[3][3] = 1

        self.euler = self.matrix.to_euler()

    def update_Y_forward(self, obj):
        """
        Update the transformation3D to reflect the transformation
        between obj (a blender object) and the blender world origin.
        In this case, the robot moves forwar along the Y axis.

        Change the values of yaw, pitch, roll for Blender vehicles
        Robots that use the Blender vehicle constraints move in the
        direction of the Y axis, contrary to most of the MORSE components
        that move along the X axis.
        """
        self.matrix = (obj.worldOrientation * self.correction_matrix).to_4x4()

        pos = obj.worldPosition
        for i in range(0, 3):
            if blenderapi.version() < (2, 62, 0):
                self.matrix[3][i] = pos[i]
            else:
                self.matrix[i][3] = pos[i]
        self.matrix[3][3] = 1

        self.euler = self.matrix.to_euler()


    def __str__(self):
        """
        String representation of a transformation3D
        """
        res = "x : " + str(self.x)
        res += " y : " + str(self.y)
        res += " z : " + str(self.z)
        res += " yaw : " + str(self.yaw)
        res += " pitch : " + str(self.pitch)
        res += " roll : " + str(self.roll)
        return res

########NEW FILE########
__FILENAME__ = abstract_datastream
from abc import ABCMeta, abstractmethod

class AbstractDatastream(object):
    """
    The class is inherited by all serializers/deserializers.
    Concrete classes need to implement :py:meth:`default`.
    """
    _type_name = "(this serializer does not document its output/input type)"
    _type_url = ""

    __metaclass__ = ABCMeta

    def __init__(self, component_instance, kwargs):
        self.component_instance = component_instance
        self.kwargs = kwargs
        self.initialize()

    @property
    def component_name(self):
        return self.component_instance.bge_object.name

    @property
    def data(self):
        return self.component_instance.local_data

    def __str__(self):
        return '%s(%s)'%(self.__class__.__name__, self.component_name)

    def initialize(self):
        """ initialize the specific datastream

        Can be overriden if needed
        """
        pass

    @abstractmethod
    def default(self, ci='unused'):
        """ default method called by MORSE logic

        Sensor: must read `local_data`, format and publish them.
        Actuator: must read a new incoming command and update `local_data`.
        """
        # :param ci: kept for backward compatibility, unused component_instance
        #            passed from Sensor / Actuator default_action
        pass

    def finalize(self):
        """ finalize the specific datastream

        Can be overriden if needed
        """
        pass

    def __del__(self):
        self.finalize()

########NEW FILE########
__FILENAME__ = abstract_moos
import logging; logger = logging.getLogger("morse.moos")
import pymoos.MOOSCommClient

from morse.middleware import AbstractDatastream
from morse.core import blenderapi


class AbstractMOOS(AbstractDatastream):
    """ Base class for all MOOS Publishers and Subscribers """
    # used to generate documentation, TODO fill in subclasses
    _type_name = "db entries"
    _type_url = ""
    _moosapp = None

    def initialize(self):
        """ Initialize the MOOS app"""
        logger.info("MOOS datastream initialize %s"%self)
        if not AbstractMOOS._moosapp:
            m = pymoos.MOOSCommClient.MOOSApp()
            #m.SetOnConnectCallBack( m.DoRegistrations )
            #m.SetOnMailCallBack( m.MailCallback )

            logger.info("%s" % m.GetLocalIPAddress())

            fundamental_frequency = 10 # [Hz]
            m.Run( "127.0.0.1", 9000, "MORSE_SIM", fundamental_frequency)
            AbstractMOOS._moosapp = m
            logger.info("MOOS datastream interface initialized")
        # all instance share the same static MOOSApp
        self.m = AbstractMOOS._moosapp

    def finalize(self):
        """ Kill the morse MOOS app."""
        if AbstractMOOS._moosapp:
            AbstractMOOS._moosapp.Close()
            AbstractMOOS._moosapp = None
        logger.info("MOOS datastream finalize %s"%self)


#
# Example (String)
#

class StringPublisher(AbstractMOOS):
    """ Publish a string containing a printable representation of the
    local data. """

    def default(self, ci='unused'):
        logger.debug("Posting message to the MOOS database.")
        current_time = blenderapi.persistantstorage().current_time
        #iterate through all objects of the component_instance and post the data
        for variable, data in self.data.items():
            name = "%s_%s" % (self.component_name, variable)
            logger.debug("name: %s, type: %s, data: %s"%
                                (name, type(data), str(data)))
            self.m.Notify(name, str(data), current_time)



class StringReader(AbstractMOOS):
    """ Log messages. """

    def default(self, ci='unused'):
        # get latest mail from the MOOS comm client
        messages = self.m.FetchRecentMail()

        # log messages
        for message in messages:
            logger.info("message: %s" % str(message))


########NEW FILE########
__FILENAME__ = gps
import logging; logger = logging.getLogger("morse." + __name__)
import pymoos.MOOSCommClient
from morse.middleware.moos import AbstractMOOS

class GPSNotifier(AbstractMOOS):
    """ Notify GPS """

    def default(self, ci='unused'):
        cur_time = pymoos.MOOSCommClient.MOOSTime()
        
        self.m.Notify('zEast', self.data['x'], cur_time)
        self.m.Notify('zNorth', self.data['y'], cur_time)
        self.m.Notify('zHeight', self.data['z'], cur_time)

########NEW FILE########
__FILENAME__ = gyroscope
import logging; logger = logging.getLogger("morse." + __name__)
import pymoos.MOOSCommClient
from morse.middleware.moos import AbstractMOOS

class GyroscopeNotifier(AbstractMOOS):
    """ Notify Gyroscope """

    def default(self, ci = 'unused'):
        cur_time = pymoos.MOOSCommClient.MOOSTime()
        
        self.m.Notify('zYaw', self.data['yaw'], cur_time)
        self.m.Notify('zRoll', self.data['roll'], cur_time)
        self.m.Notify('zPitch', self.data['pitch'], cur_time)

########NEW FILE########
__FILENAME__ = imu
import logging; logger  =  logging.getLogger("morse." + __name__)
import pymoos.MOOSCommClient
from morse.middleware.moos import AbstractMOOS

class IMUNotifier(AbstractMOOS):
    """ Notify IMU """

    def default(self,  ci = 'unused'):
        cur_time = pymoos.MOOSCommClient.MOOSTime()

        vel = self.data['velocity']
        acc = self.data['acceleration']

        # post angular rates
        self.m.Notify('zGyroX', vel[3], cur_time)
        self.m.Notify('zGyroY', vel[4], cur_time)
        self.m.Notify('zGyroZ', vel[5], cur_time)

        # post accelerations
        self.m.Notify('zAccelX', acc[0], cur_time)
        self.m.Notify('zAccelY', acc[1], cur_time)
        self.m.Notify('zAccelZ', acc[2], cur_time)

########NEW FILE########
__FILENAME__ = motion
import logging; logger = logging.getLogger("morse." + __name__)
import pymoos.MOOSCommClient
from morse.middleware.moos import AbstractMOOS

class MotionReader(AbstractMOOS):
    """ Read motion commands and update local data. """

    def initialize(self):
        AbstractMOOS.initialize(self)
        # register for control variables from the database
        self.m.Register("cVelocity")
        self.m.Register("cYawRate")

    def default(self, ci='unused'):
        current_time = pymoos.MOOSCommClient.MOOSTime()
        # get latest mail from the MOOS comm client
        messages = self.m.FetchRecentMail()

        # look for command messages: cYawRate and cVelocity
        for message in messages:
            if (message.GetKey() =="cVelocity") and (message.IsDouble()):
                self.data['v'] = message.GetDouble() # command linear velocity [m/s]
            elif  (message.GetKey()=="cYawRate") and (message.IsDouble()):
                self.data['w'] = message.GetDouble() # command angular velocity [m/s]
            elif  (message.GetKey() =="cSteer") and (message.IsDouble()):
                self.data['steer'] = message.GetDouble() # command steer angle [deg]
            elif  (message.GetKey( )=="cThrottle") and (message.IsDouble()):
                self.data['force'] = message.GetDouble() # command engine force
            elif  (message.GetKey() =="cBrake") and (message.IsDouble()):
                self.data['brake'] = message.GetDouble() # command angular velocity [m/s]


########NEW FILE########
__FILENAME__ = pose
import logging; logger = logging.getLogger("morse." + __name__)
import pymoos.MOOSCommClient
from morse.middleware.moos import AbstractMOOS
from morse.core import blenderapi

class PoseNotifier(AbstractMOOS):
    """ Notify Pose """

    def default(self,  ci='unused'):
        cur_time=pymoos.MOOSCommClient.MOOSTime()

        # post the simulation time so that it can be synced to MOOSTime
        self.m.Notify('actual_time', 
                      blenderapi.persistantstorage().current_time, cur_time)
        # post the robot position
        self.m.Notify('simEast', self.data['x'], cur_time)
        self.m.Notify('simNorth', self.data['y'], cur_time)
        self.m.Notify('simHeight', self.data['z'], cur_time)
        self.m.Notify('simYaw', self.data['yaw'], cur_time)
        self.m.Notify('simRoll', self.data['roll'], cur_time)
        self.m.Notify('simPitch', self.data['pitch'], cur_time)

########NEW FILE########
__FILENAME__ = sick
import logging; logger = logging.getLogger("morse." + __name__)
import pymoos.MOOSCommClient
from morse.middleware.moos import AbstractMOOS
from morse.core import blenderapi

class LIDARNotifier(AbstractMOOS):
    """ Notify LIDAR """

    def initialize(self):
        AbstractMOOS.initialize(self)
        # post lidar settings to the database only once at startup
        cur_time=blenderapi.persistantstorage().current_time
        self.m.Notify('sScanAngle',
            self.component_instance.scan_window, cur_time)
        self.m.Notify('sScanResolution',
            self.component_instance.resolution, cur_time)
        self.m.Notify('sScanRange',
            self.component_instance.laser_range, cur_time)

    def default(self,  ci='unused'):
        cur_time=pymoos.MOOSCommClient.MOOSTime()
        num_readings = self.component_instance.scan_window / \
                      self.component_instance.resolution

        # build string of the form: '[1x180]{4.9, 29.2, ..., 2.98}'
        # replace [] in python string conversion to {} expected by MOOS parsing code
        laserscan = str(self.data['range_list']).replace('[', '{').replace(']', '}')
        # add array size to beginning of string
        #laserscan = '[1x' + '{0:.0}'.format(num_readings) + ']'+laserscan
        laserscan = '[1x' + '%.0f' % num_readings + ']'+laserscan

        self.m.Notify('zLidarDist', laserscan, cur_time)

########NEW FILE########
__FILENAME__ = moos_datastream
import logging; logger = logging.getLogger("morse." + __name__)

from morse.core.datastream import DatastreamManager

class MOOSDatastreamManager(DatastreamManager):
    """ Handle communication between Blender and MOOS."""


########NEW FILE########
__FILENAME__ = genpos
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.pocolibs_datastream import PocolibsDataStreamInput, poster_name
from genPos.struct import *

class GenPosPoster(PocolibsDataStreamInput):
    _type_name = "GENPOS_CART_SPEED"
    _type_url = "http://trac.laas.fr/git/genPos-genom/tree/genPosStruct.h#n90"
     
    def initialize(self):
        PocolibsDataStreamInput.initialize(self, GENPOS_CART_SPEED)

    def default(self, component):
        speed = self.read()
        if speed:
            self.data['v'] = speed.v
            self.data['w'] = speed.w

########NEW FILE########
__FILENAME__ = lwr
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.pocolibs_datastream import PocolibsDataStreamInput
from lwr.struct import *

class LwrPoster(PocolibsDataStreamInput):
    
    _type_name = "Gb_q7"
    _type_url = "http://trac.laas.fr/git/gbM/tree/src/gbStruct.h#n92"

    def initialize(self):
        PocolibsDataStreamInput.initialize(self, Gb_q7)

    def default(self, ci):
        gbm_conf = self.read()
        if gbm_conf:
            self.data['kuka_1'] = gbm_conf.q1
            self.data['kuka_2'] = gbm_conf.q2
            self.data['kuka_3'] = gbm_conf.q3
            self.data['kuka_4'] = gbm_conf.q4
            self.data['kuka_5'] = gbm_conf.q5
            self.data['kuka_6'] = gbm_conf.q6
            self.data['kuka_7'] = gbm_conf.q7


########NEW FILE########
__FILENAME__ = niut
import logging

logger = logging.getLogger("morse." + __name__)
from morse.middleware.pocolibs_datastream import PocolibsDataStreamInput
from niut.struct import *
from morse.core import mathutils

# Define a transformation matrix for the position of the Kinect/Xtion sensor
transformation_matrix = mathutils.Matrix()


class NiutPoster(PocolibsDataStreamInput):
    _type_name = "NIUT_HUMAN_LIST"

    _type_url = "http://trac.laas.fr/git/niut-genom/tree/niutStruct.h#n82"

    def initialize(self):
        PocolibsDataStreamInput.initialize(self, NIUT_HUMAN_LIST)

        self.couples = \
            [('head_position', NIUT_HEAD),
            ('neck_position', NIUT_NECK),
            ('torso_position', NIUT_TORSO),
            ('left_hand_position', NIUT_LEFT_HAND),
            ('right_hand_position', NIUT_RIGHT_HAND),
            ('left_elbow_position', NIUT_LEFT_ELBOW),
            ('right_elbow_position', NIUT_RIGHT_ELBOW),
            ('left_shoulder_position', NIUT_LEFT_SHOULDER),
            ('right_shoulder_position', NIUT_RIGHT_SHOULDER),
            ('left_hip_position', NIUT_LEFT_HIP),
            ('right_hip_position', NIUT_RIGHT_HIP),
            ('left_knee_position', NIUT_LEFT_KNEE),
            ('right_knee_position', NIUT_RIGHT_KNEE),
            ('left_foot_position', NIUT_LEFT_FOOT),
            ('right_foot_position', NIUT_RIGHT_FOOT)]

        _create_transform_matrix()

    def _store_joint_position(self, joints, ik_target, joint_index):
        joint_position = joints[joint_index].position
        # Convert the GEN_POINT_3D into a Blender vector
        position_vector = mathutils.Vector([joint_position.x, joint_position.y, joint_position.z])
        if transformation_matrix:
            #logger.error("Kinect position: [%.4f, %.4f, %.4f]" % (transformation_matrix[0][3], transformation_matrix[1][3], transformation_matrix[2][3]))
            new_position = position_vector * transformation_matrix
            new_position = new_position + mathutils.Vector(
                [transformation_matrix[0][3], transformation_matrix[1][3], transformation_matrix[2][3]])
        else:
            new_position = position_vector

        self.data[ik_target] = new_position


    def default(self, ci=''):
        human_list = self.read()
        if human_list:
            for i in range(0, 16):
                if human_list.users[i].state == NIUT_TRACKING:
                    joints = human_list.users[i].skeleton.joint
                    for target, idx in self.couples:
                        self._store_joint_position(joints, target, idx)
                    return


def _create_transform_matrix():
    """ Construct the transformation matrix
    from the Kinect to the Blender frame of reference
    """
    global transformation_matrix

    #         Y  X                  Z  Y
    #         | /                   | /
    # KinCam  |/ ____ Z  ,   World  |/_____X
    # Transformation of the Kinect frame of reference to that of Blender
    kinect_matrix = mathutils.Matrix((
        [0.0, 1.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0],
        [1.0, 0.0, 0.0, 0.0],
        [0.0, 0.0, 0.0, 1.0]))

    # Additional rotation of the physical sensor, with respect to the Blender world
    # Currently set to 25.5 degrees around the Y axis
    kinect_rotation = mathutils.Matrix((
        [1.0, 0.0, -0.445, 0.0],
        [0.0, 1.0, 0.0, 0.0],
        [0.445, 0.0, 1.0, 0.0],
        [0.0, 0.0, 0.0, 1.0]))

    # Spin the positions around the Z axis, to match with the Blender human
    rotation_matrix = mathutils.Matrix((
        [-1.0, 0.0, 0.0, 0.0],
        [0.0, -1.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0],
        [0.0, 0.0, 0.0, 1.0]))

    # Position of the kinect with respect to the human.
    # XXX: Make this adjustable from the real position in the scene
    kinect_position = [2.0, 0.0, 2.0]
    #logger.error("Kinect position: [%.4f, %.4f, %.4f]" % (kinect_position[0], kinect_position[1], kinect_position[2]))

    transformation_matrix = kinect_matrix * kinect_rotation * rotation_matrix
    # Add the position of the Kinect sensor
    transformation_matrix[0][3] = kinect_position[0]
    transformation_matrix[1][3] = kinect_position[1]
    transformation_matrix[2][3] = kinect_position[2]

########NEW FILE########
__FILENAME__ = platine
from morse.middleware.pocolibs_datastream import PocolibsDataStreamInput, poster_name
from pom.struct import *
from platine.struct import *

class PlatinePoster(PocolibsDataStreamInput):
    _type_name = "POM_SE_POSTER"
    _type_url = "http://trac.laas.fr/git/pom-genom/tree/pomStruct.h#n167"

    def initialize(self):
        PocolibsDataStreamInput.initialize(self, POM_SE_POSTER)

    def default(self, component):
        pos = self.read()
        if pos:
            euler = pos.seConfig.euler
            self.data['pan'] = euler.yaw
            self.data['tilt'] = euler.pitch

class PlatineAxisPoster(PocolibsDataStreamInput):
    _type_name = "PLATINE_AXIS_STR"
    _type_url = "http://trac.laas.fr/git/platine-genom/tree/platineStruct.h#n16"

    def initialize(self):
        PocolibsDataStreamInput.initialize(self, PLATINE_AXIS_STR)

    def default(self, component):
        pos = self.read()
        if pos:
            self.data['pan'] = pos.pan
            self.data['tilt'] = pos.tilt


########NEW FILE########
__FILENAME__ = fingers
import logging; logger = logging.getLogger("morse." + __name__)
logger.setLevel(logging.DEBUG)

from morse.core.services import service
from morse.core.overlay import MorseOverlay
from morse.middleware.pocolibs_datastream import DummyPoster


class Fingers(MorseOverlay):
    def __init__(self, overlaid_object):
        # Call the constructor of the parent class
        MorseOverlay.__init__(self, overlaid_object)
        self.ctrl = DummyPoster('fingerCntrl')

    def name(self):
        return "fingers"

    @service
    def Init(self, grasped, mode):
        pass

    @service
    def OpenGrip(self):
        self.overlaid_object.release()

    @service
    def CloseGrip(self):
        grasped = self.overlaid_object.grab()
        if grasped:
            return [1]
        else:
            return [0]




########NEW FILE########
__FILENAME__ = platine_overlay
import logging; logger = logging.getLogger("morse." + __name__)
#logger.setLevel(logging.DEBUG)
from morse.core.services import service, async_service, interruptible
from morse.core.overlay import MorseOverlay
from morse.core import status
from functools import partial

from morse.middleware.pocolibs.actuators.platine import PlatinePoster
from morse.middleware.pocolibs_datastream import PosterNotFound, DummyPoster

import math

class PlatineModule(MorseOverlay):
    def __init__(self, overlaid_object):
        # Call the constructor of the parent class
        MorseOverlay.__init__(self, overlaid_object)
        self._clean_track = False
        self._rot = 1.0
        self.cntrl = DummyPoster("platineCntrl")

    def _dummy_completion(self, *args):
        logger.debug("enter in _dummy_completion")
        pass

    def _compute_real_angle(self, deg, absolute, pan, tilt):
        if deg == 'PLATINE_DEG' or deg == '1':
            logger.debug("converting degree to radian")
            tilt = math.radians(tilt)
            pan  = math.radians(pan)

        if absolute == 'PLATINE_RELATIVE' or absolute == '0':
            logger.debug("calculing absolute coordinate")
            current_pan, current_tilt = self.overlaid_object.get_pan_tilt()
            tilt =  current_tilt + tilt
            pan = current_pan + pan

        return (self._rot * pan), tilt

    def _set_pan_tilt(self, pan, tilt, wait):
        if wait == 'PLATINE_TRUE' or wait == '1':
            self.overlaid_object.set_pan_tilt(self.chain_callback(), pan, tilt)
        else:
            self.overlaid_object.set_pan_tilt(partial(self._dummy_completion), pan, tilt)
            self.completed(status.SUCCESS)

    def _interrupt(self):
        pan, tilt = self.overlaid_object.get_pan_tilt()
        self.overlaid_object.local_data['tilt'] = tilt
        self.overlaid_object.local_data['pan'] = pan

    def interrupt(self):
        if self._clean_track:
            self.overlaid_object.input_functions.pop()
            self.completed(status.PREEMPTED)
        self._interrupt()
        MorseOverlay.interrupt(self)

    @service
    def InitDriver(self, serial, baud, rot):
        self._serial = serial
        self._baud = baud
        self._rot = float(rot)

    @service
    def GetSerialParams(self):
        return self._serial, self._baud, self._rot
    
    @interruptible
    @async_service
    def CmdPosCoord(self, deg, absolute, pan, tilt, wait, dummy):
        r_pan, r_tilt =  self._compute_real_angle(deg, absolute, float(pan), - float(tilt))
        self._set_pan_tilt(r_pan, r_tilt, wait)

    @interruptible
    @async_service
    def CmdPosTilt(self, deg, absolute, tilt, wait, dummy):
        c_pan, c_tilt = self.overlaid_object.get_pan_tilt()
        r_pan, r_tilt =  self._compute_real_angle(deg, absolute,
                                                  0.0, - float(tilt))
        self._set_pan_tilt(c_pan, r_tilt, wait)

    @interruptible
    @async_service
    def CmdPosPan(self, deg, absolute, pan, wait, dummy):
        c_pan, c_tilt = self.overlaid_object.get_pan_tilt()
        r_pan, r_tilt = self._compute_real_angle(deg, absolute, float(pan), 0.0)
        self._set_pan_tilt(r_pan, c_tilt, wait)

    @interruptible
    @async_service
    def AimAtTargetPoint(self, p1, p2, p3, p4, p5, p6, frame, p7, x, y, z):
        self.overlaid_object.look_at_point(self.chain_callback(), float(x), float(y), float(z))

    @interruptible
    @async_service
    def TrackPos(self, poster_name):
        try:
            poster = PlatinePoster(self.overlaid_object, 
                    {'poster': poster_name, 'delay': False })
        except PosterNotFound:
            return self.completed(status.FAILED, ["POSTER_NOT_FOUND"])

        self._clean_track = True
        self.overlaid_object.input_functions.append(poster.read)

    @interruptible
    @async_service
    def Stop(self):
        self._interrupt()
        self.completed(status.SUCCESS)

    def name(self):
        return "platine"

########NEW FILE########
__FILENAME__ = rflex_overlay
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import service, async_service, interruptible
from morse.core.overlay import MorseOverlay
from morse.core import status
from morse.middleware.pocolibs.actuators.genpos import GenPosPoster
from morse.middleware.pocolibs_datastream import PosterNotFound, DummyPoster

class RflexModule(MorseOverlay):
    def __init__(self, overlaid_object):
        # Call the constructor of the parent class
        MorseOverlay.__init__(self, overlaid_object)
        self._clean_track = False
        self._cntrl = DummyPoster("rflexCntrl")

    def interrupt(self):
        self.overlaid_object.stop()
        if self._clean_track:
            self.overlaid_object.input_functions.pop()
        MorseOverlay.interrupt(self)

    @service
    def InitClient(self, *args):
        pass

    @service
    def EndClient(self, *args):
        pass

    @service
    def SetWdogRef(self, *args):
        pass

    @service
    def GetWdogRef(self, *args):
        pass

    @service
    def SetMode(self, mode):
        self._mode = mode

    @service
    def GetMode(self):
        return status.SUCCESS, self._mode

    @service
    def PomTagging(self, *args):
        pass

    @service 
    def SetPos(self, *args):
        pass

    @service 
    def SetPosFromMEPoster(self, *args):
        pass

    @service 
    def SetVarparams(self, *args):
        pass

    @async_service
    def Stop(self, *args):
        self.overlaid_object.stop()
        del self.overlaid_object.input_functions[:]
        self.completed(status.SUCCESS)

    @async_service
    def TrackEnd(self, *args):
        self.overlaid_object.stop()
        self.completed(status.SUCCESS)

    @async_service
    def GotoSpeed(self, numRef, updatedPeriod, v, vt, w, *args):
        self.overlaid_object.set_speed(float(v), float(w))
        self.completed(status.SUCCESS)

    @interruptible
    @async_service
    def TrackSpeedStart(self, poster_name):
        try:
            poster = GenPosPoster(self.overlaid_object, 
                    { 'poster' : poster_name, 'delay' : False })
        except PosterNotFound:
            return self.completed(status.FAILED, ["POSTER_NOT_FOUND"])

        self._clean_track = True
        self.overlaid_object.input_functions.append(poster.default)


    @service
    def GetGeoConfig(self, *args):
        pass

    @service
    def SetGeoConfig(self, *args):
        pass

    @service
    def SonarOn(self, *args):
        pass

    @service
    def SonarOff(self, *args):
        pass

    @service
    def BrakeOn(self, *args):
        pass

    @service
    def BrakeOff(self, *args):
        pass

    @service
    def GetJoystick(self, *args):
        pass

    @service
    def MonitorBattery(self, *args):
        pass

    @service
    def Gyro(self, *args):
        pass

    @service
    def GetGyro(self, *args):
        pass

    @service 
    def SetOdometryMethod(self, *args):
        pass

    @service
    def Log(self, *args):
        pass

    @service
    def StopLog(self, *args):
        pass

    def name(self):
        return "rflex"


########NEW FILE########
__FILENAME__ = stereopixel_overlay
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import service, async_service, interruptible
from morse.core.overlay import MorseOverlay
from morse.core import status
from morse.middleware.pocolibs_datastream import DummyPoster

class StereopixelModule(MorseOverlay):
    def __init__(self, overlaid_object):
        # Call the constructor of the parent class
        MorseOverlay.__init__(self, overlaid_object)
        self._cntrl = DummyPoster("stereopixelCntrl")

    def Acquire_cb(self, answer):
        status, res = answer
        nb_pts = self.overlaid_object.local_data['nb_points']
        return status, [nb_pts, 0, 0, nb_pts]

    @service
    def Init(self, *args):
        pass

    @service
    def GetCorrelationParams(self, *args):
        pass

    @service
    def SetCorrelationParams(self, *args):
        pass

    @service
    def GetBlobFilterParams(self, *args):
        pass

    @service
    def SetBlobFilterParams(self, *args):
        pass

    @service 
    def GetFrameCoord(self, *args):
        pass

    @service
    def SetFrameCoord(self, *args):
        pass

    @service 
    def SetSaveParams(self, *args):
        pass

    @service
    def GetSaveParams(self, *args):
        pass

    @service
    def SaveDisparity(self, *args):
        pass

    @service
    def CVDumpDisparity(self, *args):
        pass

    @service
    def Sav3DImage(self, *args):
        pass

    @interruptible
    @async_service
    def Compute(self):
        self.overlaid_object.capture(self.chain_callback(self.Acquire_cb), 1)

    def name(self):
        return "stereopixel"


########NEW FILE########
__FILENAME__ = velodyne_overlay
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import service, async_service, interruptible
from morse.core.overlay import MorseOverlay
from morse.core import status
from morse.middleware.pocolibs_datastream import DummyPoster

class VelodyneModule(MorseOverlay):
    def __init__(self, overlaid_object):
        # Call the constructor of the parent class
        MorseOverlay.__init__(self, overlaid_object)
        self._cntrl = DummyPoster("velodyneCntrl")

    @service
    def Init(self, *args):
        pass

    @service
    def GetInitParams(self, *args):
        pass

    @service
    def FOVRemoveHeadingSector(self, *args):
        pass

    @service
    def FOVRemoveLine(self, *args):
        pass

    @service
    def StartAcquisition(self, *args):
        pass

    @service
    def StopAcquisition(self, *args):
        pass

    @service
    def OneShot(self, *args):
        pass

    @service
    def SetTargetDetectionParams(self, *args):
        pass

    @service
    def GetTargetDetectionParams(self, *args):
        pass

    @service
    def SetTargetParams(self, *args):
        pass

    @service
    def GetTargetParams(self, *args):
        pass

    @service
    def StopTargetDetection(self, *args):
        pass

    @service
    def DumpTarget(self, *args):
        pass

    @service
    def SetSaveParams(self, *args):
        pass

    @service
    def SetSaveIm3DParams(self, *args):
        pass

    @service
    def GetSaveParams(self, *args):
        pass

    @service
    def GetSaveIm3DParams(self, *args):
        pass

    @service
    def Save(self, *args):
        pass

    @service
    def SaveIm3d(self, *args):
        pass

    def name(self):
        return "velodyne"


########NEW FILE########
__FILENAME__ = viam_overlay
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import service, async_service, interruptible
from morse.core.overlay import MorseOverlay
from morse.core import status
from morse.middleware.pocolibs_datastream import DummyPoster

class ViamModule(MorseOverlay):
    def __init__(self, overlaid_object):
        # Call the constructor of the parent class
        MorseOverlay.__init__(self, overlaid_object)
        self._cntrl = DummyPoster("viamCntrl")

    def Acquire_cb(self, answer):
        status, res = answer
        return status, [ self._bench, self._n]

    @service
    def Init(self, *args):
        pass

    @service
    def Configure(self, *args):
        pass

    @service
    def Reset(self, *args):
        pass

    @service
    def DriverLoad(self, *args):
        pass

    @service
    def BusPrint(self, *args):
        pass

    @service 
    def BankCreate(self, *args):
        pass

    @service
    def CameraCreate(self, *args):
        pass

    @service 
    def BankAddCamera(self, *args):
        pass

    @service
    def PushFormatFilter(self, *args):
        pass

    @service
    def UpdateFormatFilter(self, *args):
        pass

    @service
    def PushGeoFilter(self, *args):
        pass

    @service
    def UpdateGeoFilter(self, *args):
        pass

    @service
    def PushLumFilter(self, *args):
        pass

    @service
    def UpdateLumFilter(self, *args):
        pass

    @service
    def PushColorFilter(self, *args):
        pass

    @service
    def UpdateColorFilter(self, *args):
        pass

    @service
    def PushImProcFilter(self, *args):
        pass

    @service
    def UpdateImProcFilter(self, *args):
        pass

    @service
    def PushMiscFilter(self, *args):
        pass

    @service
    def UpdateMiscFilter(self, *args):
        pass

    @service 
    def FilterList(self, *args):
        pass

    @service
    def FilterGetCap(self, *args):
        pass

    @service
    def CameraListHWModes(self, *args):
        pass

    @service
    def CameraSetHWMode(self, *args):
        pass

    @service
    def Display(self, *args):
        pass

    @service
    def Calibrate(self, *args):
        pass

    @service
    def CalibrationIO(self, *args):
        pass

    @service
    def Save(self, *args):
        pass


    @interruptible
    @async_service
    def Acquire(self, bench, n):
        n = int(n)
        self._n = n
        self._bench = bench
        if n == 0:
            n = -1
        self.overlaid_object.capture(self.chain_callback(self.Acquire_cb), n)

    @async_service
    def Stop(self, bench):
        self.completed(status.SUCCESS)

    def name(self):
        return "viam"


########NEW FILE########
__FILENAME__ = human_posture
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.pocolibs_datastream import *
from spark.struct import *

class HumanPoster(PocolibsDataStreamOutput):
    _type_name = "STRUCT_SPARK_CONFIGURATION"
    _type_url = "http://trac.laas.fr/git/spark-genom/tree/sparkStruct.h#n226"

    def initialize(self):
        PocolibsDataStreamOutput.initialize(self, STRUCT_SPARK_CONFIGURATION)

        self.obj = STRUCT_SPARK_CONFIGURATION()
        self.obj.dofNb = 50
        self.obj.changed = 1

    def default(self, component):
        raw_dofs = list(self.data.values())
        #for i in range(self.obj.dofNb):
        for i in range(18):
            self.obj.dof[i] = raw_dofs[i]

        #swap pitch and yaw
        self.obj.dof[5] = raw_dofs[3]
        self.obj.dof[3] = raw_dofs[5]
        #swap right shoulder: X <- Y, Y <- Z, Z <- X
        self.obj.dof[18] = raw_dofs[19]
        self.obj.dof[19] = raw_dofs[20]
        self.obj.dof[20] = raw_dofs[18]
        #Right arm length
        self.obj.dof[21] = 0
        self.obj.dof[22] = raw_dofs[21]
        self.obj.dof[23] = 0

        for i in range(24, 27):
            self.obj.dof[i] = raw_dofs[i-2]
        #left shoulder:
        #X <- Y
        self.obj.dof[27] = -raw_dofs[26]
        #Y <- Z
        self.obj.dof[28] = raw_dofs[27]
        #Z <- X
        self.obj.dof[29] = raw_dofs[25]

        self.obj.dof[30] = 0
        self.obj.dof[31] = raw_dofs[28]
        self.obj.dof[32] = 0

        for i in range(33, self.obj.dofNb):
                self.obj.dof[i] = raw_dofs[i-4]
        self.write(self.obj)


########NEW FILE########
__FILENAME__ = platine_posture
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.pocolibs_datastream import *
from platine.struct import *
from math import degrees

class PlatinePoster(PocolibsDataStreamOutput):
    _type_name = "PLATINE_STATES"
    _type_url = "http://trac.laas.fr/git/platine-genom/tree/platineStruct.h#n53"

    def initialize(self):
        PocolibsDataStreamOutput.initialize(self, PLATINE_STATES)

        self.obj = PLATINE_STATES()

    def default(self, ci):
        self.obj.stateRad.pos.pan = self.data['pan']
        self.obj.stateRad.pos.tilt = self.data['tilt']
        self.obj.stateDeg.pos.pan = degrees(self.data['pan'])
        self.obj.stateDeg.pos.tilt = degrees(self.data['tilt'])
        self.write(self.obj)


########NEW FILE########
__FILENAME__ = pom
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.pocolibs_datastream import *
from pom.struct import *

class PomSensorPosPoster(PocolibsDataStreamInput):
    def initialize(self):
        PocolibsDataStreamInput.initialize(self, POM_SENSOR_POS)

class PomSensorPoster(PocolibsDataStreamOutput):
    _type_name = "POM_ME_POS"
    _type_url = "http://trac.laas.fr/git/pom-genom/tree/pomStruct.h#n180"

    def initialize(self):
        PocolibsDataStreamOutput.initialize(self, POM_ME_POS)

        # Initialise the object
        self.obj = POM_ME_POS()
        self.obj.kind = POM_ME_ABSOLUTE
        self.obj.confidence = float(self.component_instance.bge_object['confidence'])

        # search for the reference poster
        ref_frame = self.component_instance.bge_object['reference_frame']
        self.ref_poster = PomSensorPosPoster(self.component_instance, { 'poster': ref_frame })

    def default(self, ci):
        ref = self.ref_poster.read()
        if ref:
            self.obj.main.euler.x = self.data.get('x', 0.0)
            self.obj.main.euler.y = self.data.get('y', 0.0)
            self.obj.main.euler.z = self.data.get('z', 0.0)
            self.obj.main.euler.yaw = self.data.get('yaw', 0.0)
            self.obj.main.euler.pitch = self.data.get('pitch', 0.0)
            self.obj.main.euler.roll = self.data.get('roll', 0.0)
            self.obj.date1 = ref.date
            self.write(self.obj)

class PomPoster(PocolibsDataStreamOutput):
    _type_name = "POM_POS"
    _type_url = "http://trac.laas.fr/git/pom-genom/tree/pomStruct.h#n211"

    def initialize(self):
        PocolibsDataStreamOutput.initialize(self, POM_POS)

        # Initialise the object
        self.obj = POM_POS()
        self.obj.date = 0
        self.obj.pomTickDate = 0

    def default(self, ci):
        self.obj.mainToOrigin.euler.x = self.data.get('x', 0.0)
        self.obj.mainToOrigin.euler.y = self.data.get('y', 0.0)
        self.obj.mainToOrigin.euler.z = self.data.get('z', 0.0)
        self.obj.mainToOrigin.euler.yaw = self.data.get('yaw', 0.0)
        self.obj.mainToOrigin.euler.pitch = self.data.get('pitch', 0.0)
        self.obj.mainToOrigin.euler.roll = self.data.get('roll', 0.0)
        self.obj.date += 1
        self.obj.pomTickDate = self.obj.date
        self.write(self.obj)


########NEW FILE########
__FILENAME__ = stereopixel
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
from morse.middleware import AbstractDatastream
from morse.middleware.pocolibs_datastream import poster_name, PocolibsDatastreamManager

try:
    from morse.middleware.pocolibs.stereopixel import *
except ImportError:
    if not blenderapi.fake:
        raise


class Spix3DImagePoster(AbstractDatastream):
    _type_name = "Spix3DImage"
    _type_url = "http://trac.laas.fr/git/stereopixel-genom/tree/stereopixelClient.h#n57"

    def initialize(self):
        name = poster_name(self.component_name, self.kwargs)
        self.obj = Stereopixel(name, self.component_instance.image_width,
                                     self.component_instance.image_height)

    def default(self, ci):
        if not self.component_instance.capturing:
            return

        main_to_origin = self.component_instance.robot_parent.position_3d
        pom_date, t = PocolibsDatastreamManager.compute_date()
        main_to_sensor = main_to_origin.transformation3d_with(
                    self.component_instance.position_3d)

        info = StereopixelSimu()
        info.nb_pts = self.data['nb_points']

        info.x_rob = main_to_origin.x
        info.y_rob = main_to_origin.y
        info.z_rob = main_to_origin.z
        info.yaw_rob = main_to_origin.yaw
        info.pitch_rob = main_to_origin.pitch
        info.roll_rob = main_to_origin.roll

        info.x_cam = main_to_sensor.x
        info.y_cam = main_to_sensor.y
        info.z_cam = main_to_sensor.z
        info.yaw_cam = main_to_sensor.yaw
        info.pitch_cam = main_to_sensor.pitch
        info.roll_cam = main_to_sensor.roll

        info.pom_tag = pom_date

        self.obj.post(info, self.data['points'])

    def finalize(self):
        self.obj.finalize()
        AbstractDatastream.finalize(self)

########NEW FILE########
__FILENAME__ = target
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.pocolibs_datastream import *
from genPos.struct import *

class TargetPoster(PocolibsDataStreamOutput):
    _type_name = "GENPOS_TRAJ_POINTS"
    _type_url = "http://trac.laas.fr/git/genPos-genom/tree/genPosStruct.h#n144"

    def initialize(self):
        PocolibsDataStreamOutput.initialize(self, GENPOS_TRAJ_POINTS)

        # Initialise the object
        self.obj = GENPOS_TRAJ_POINTS()
        self.obj.numRef = 0

    def default(self, ci):
        target_dict = self.data['victim_dict']
        self.obj.numRef += 1

        if target_dict:
        # if multiple target, just take the first one
            for target in target_dict.values():
                self.obj.nbPts = 1
                self.obj.points[0].x = target['coordinate']['x']
                self.obj.points[0].y = target['coordinate']['y']
        else:
            self.obj.nbPts = 0

        self.write(self.obj)


########NEW FILE########
__FILENAME__ = velodyne
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
from math import pi
from morse.middleware import AbstractDatastream
from morse.middleware.pocolibs_datastream import poster_name, PocolibsDatastreamManager

try:
    from morse.middleware.pocolibs.velodyne import *
except ImportError:
    if not blenderapi.fake:
        raise


class Velodyne3DImage(AbstractDatastream):
    _type_name = "velodyne3DImage"
    _type_url = "http://trac.laas.fr/git/velodyne-genom/tree/velodyneClient.h#n48"

    def initialize(self):
        name = poster_name(self.component_name, self.kwargs)
        # if we want to use a static DepthCamera as a Velodyne
        # then num_rotation = 1 will prevent buffering.
        num_rotation = 1
        if 'rotation' in dir(self.component_instance):
            num_rotation += int(2 * pi / self.component_instance.rotation)
        logger.info("num_rotation %d" % num_rotation)
        self.obj = Velodyne(name, self.component_instance.image_width,
                                     self.component_instance.image_height, num_rotation)

    def default(self, ci):
        if not self.component_instance.capturing:
            return

        main_to_origin = self.component_instance.robot_parent.position_3d
        pom_date, t = PocolibsDatastreamManager.compute_date()
        main_to_sensor = main_to_origin.transformation3d_with(
                    self.component_instance.position_3d)

        info = VelodyneSimu()
        info.nb_pts = self.data['nb_points']

        info.x_rob = main_to_origin.x
        info.y_rob = main_to_origin.y
        info.z_rob = main_to_origin.z
        info.yaw_rob = main_to_origin.yaw
        info.pitch_rob = main_to_origin.pitch
        info.roll_rob = main_to_origin.roll

        info.x_cam = main_to_sensor.x
        info.y_cam = main_to_sensor.y
        info.z_cam = main_to_sensor.z
        info.yaw_cam = main_to_sensor.yaw
        info.pitch_cam = main_to_sensor.pitch
        info.roll_cam = main_to_sensor.roll

        info.pom_tag = pom_date

        self.obj.post(info, self.data['points'])

    def finalize(self):
        self.obj.finalize()
        AbstractDatastream.finalize(self)

########NEW FILE########
__FILENAME__ = viam
import logging; logger = logging.getLogger("morse." + __name__)
import math
from morse.core import blenderapi
from morse.middleware import AbstractDatastream
from morse.middleware.pocolibs_datastream import poster_name, PocolibsDatastreamManager

try:
    from morse.middleware.pocolibs.viam import *
except ImportError:
    if not blenderapi.fake:
        raise

class ViamPoster(AbstractDatastream):
    _type_name = "ViamImageBank"
    _type_url = "http://trac.laas.fr/git/viam-genom/tree/viamStruct.h?h=viam-genom-1#n346"

    def initialize(self):
        name = poster_name(self.component_name, self.kwargs)
        self.camera_order = []

        """ Prepare the data for a viam poster """
        self.cameras = []
        self.pos_cam = []
        # Get the names of the data for the cameras
        try:
            # Stereo unit case
            for camera_name in self.component_instance.camera_list:
                camera_instance = blenderapi.persistantstorage().componentDict[camera_name]

                self.add_camera(camera_name, camera_instance)
        except AttributeError:
            # Video camera case
            self.add_camera(self.component_name, self.component_instance)


        if len(self.camera_order) == 1:
            self.obj = Viam(name, 'mono_bank', 0, self.cameras)

        # This is the case for a stereo camera
        if len(self.camera_order) == 2:
            baseline = math.sqrt( math.pow(self.pos_cam[0][0] - self.pos_cam[1][0], 2) +
                                  math.pow(self.pos_cam[0][1] - self.pos_cam[1][1], 2) +
                                  math.pow(self.pos_cam[0][2] - self.pos_cam[1][2], 2))

            # viam expects first the left camera, then the right camera
            # Check the y difference between the two cameras
            if self.pos_cam[0][1] < self.pos_cam[1][1]:
                self.cameras.reverse()
                self.camera_order.reverse()

            # Create the actual poster
            self.obj = Viam(name, 'stereo_bank', baseline, self.cameras)

        if len(self.camera_order) > 2:
            logger.error("ViamPoster called with more than 2 cameras")

    def add_camera(self, camera_name, camera_instance):
        # Create an image structure for each camera
        image_init = { 'name': camera_name,
                       'width': int(camera_instance.image_width),
                       'height': int(camera_instance.image_height),
                       'focal': float(camera_instance.image_focal)
                     }

        self.pos_cam.append(camera_instance.bge_object.localPosition)
        self.cameras.append(image_init)
        self.camera_order.append(camera_name)

    def default(self, ci):

        first_cam = blenderapi.persistantstorage().componentDict[self.camera_order[0]]
        main_to_origin = first_cam.robot_pose

        pom_robot_position =  ViamPos()
        pom_robot_position.x = main_to_origin.x
        pom_robot_position.y = main_to_origin.y
        pom_robot_position.z = main_to_origin.z
        pom_robot_position.yaw = main_to_origin.yaw
        pom_robot_position.pitch = main_to_origin.pitch
        pom_robot_position.roll = main_to_origin.roll

        # Compute the current time
        pom_date, t = PocolibsDatastreamManager.compute_date()

        ors_cameras = []
        ors_images = []

        # Cycle throught the cameras on the base
        # In normal circumstances, there will be two for stereo
        for camera_name in self.camera_order:
            camera_instance = blenderapi.persistantstorage().componentDict[camera_name]
            main_to_sensor = main_to_origin.transformation3d_with(
                    camera_instance.position_3d)
            imX = camera_instance.image_width
            imY = camera_instance.image_height
            try:
                image_data = camera_instance.local_data['image']
            except KeyError as detail:
                logger.warning("Camera image not found to read by VIAM poster.\n \
                        \tThe 'Class' property in the Camera component could be \
                        wrongly defined")

            # Don't create a poster if the camera is disabled
            if image_data is None or not camera_instance.capturing:
                logger.debug("Camera '%s' not capturing. Exiting viam poster" % \
                        camera_instance.bge_object.name)
                return

            # Fill in the structure with the image information
            camera_data = ViamSimuImage()
            camera_data.width = imX
            camera_data.height = imY
            camera_data.pom_tag = pom_date
            camera_data.tacq_sec = t.second
            camera_data.tacq_usec = t.microsecond
            camera_data.x = main_to_sensor.x
            camera_data.y = main_to_sensor.y
            camera_data.z = main_to_sensor.z
            camera_data.yaw = main_to_sensor.yaw
            camera_data.pitch = main_to_sensor.pitch
            camera_data.roll = main_to_sensor.roll
            camera_data.flipped = camera_instance.vertical_flip

            ors_cameras.append(camera_data)
            ors_images.append(image_data)

        self.obj.post(pom_robot_position, ors_cameras, ors_images)

    def finalize(self):
        self.obj.finalize()
        AbstractDatastream.finalize(self)

########NEW FILE########
__FILENAME__ = viman
import logging; logger = logging.getLogger("morse." + __name__)
import time
import re
from morse.core import blenderapi
from morse.helpers.transformation import Transformation3d
from morse.helpers import passive_objects
from morse.middleware.pocolibs_datastream import *
from viman.struct import *

object_config_file = "objectList_cfg"

def _fill_world_matrix(obj, t3d):
    """ Fill the world matix part of the structure

    This function receives the Blender rotation matrix and position of an object
    It calls a module function to fill out data structure of type VimanThetaMat
    """

    obj.thetaMatOrigin.nx = t3d.matrix[0][0]
    obj.thetaMatOrigin.ox = t3d.matrix[1][0]
    obj.thetaMatOrigin.ax = t3d.matrix[2][0]
    obj.thetaMatOrigin.px = t3d.x

    obj.thetaMatOrigin.ny = t3d.matrix[0][1]
    obj.thetaMatOrigin.oy = t3d.matrix[1][1]
    obj.thetaMatOrigin.ay = t3d.matrix[2][1]
    obj.thetaMatOrigin.py = t3d.y

    obj.thetaMatOrigin.nz = t3d.matrix[0][2]
    obj.thetaMatOrigin.oz = t3d.matrix[1][2]
    obj.thetaMatOrigin.az = t3d.matrix[2][2]
    obj.thetaMatOrigin.pz = t3d.z

def _fill_robot_matrix(obj, robot, obj_3dpose):
    """ Fill the world matix part of the structure

    This function receives the Blender rotation matrix and position of an object
    It calls a module function to fill out data structure of type VimanThetaMat
    """
    robot3d = robot.position_3d

    t3d = robot3d.transformation3d_with(obj_3dpose)

    obj.thetaMatRobot.nx = t3d.matrix[0][0]
    obj.thetaMatRobot.ox = t3d.matrix[1][0]
    obj.thetaMatRobot.ax = t3d.matrix[2][0]
    obj.thetaMatRobot.px = t3d.x

    obj.thetaMatRobot.ny = t3d.matrix[0][1]
    obj.thetaMatRobot.oy = t3d.matrix[1][1]
    obj.thetaMatRobot.ay = t3d.matrix[2][1]
    obj.thetaMatRobot.py = t3d.y

    obj.thetaMatRobot.nz = t3d.matrix[0][2]
    obj.thetaMatRobot.oz = t3d.matrix[1][2]
    obj.thetaMatRobot.az = t3d.matrix[2][2]
    obj.thetaMatRobot.pz = t3d.z


class VimanPoster(PocolibsDataStreamOutput):
    _type_name = "VimanObjectPublicArray"
    _type_url = "http://trac.laas.fr/git/viman-genom/tree/vimanStruct.h#n139"

    def initialize(self):
        PocolibsDataStreamOutput.initialize(self, VimanObjectPublicArray)

        # Initialise the object
        self.obj = VimanObjectPublicArray()

        self.scene_object_list = []

        #If provided, read the list of ARToolkit tags to fill the list of objects
        #to export.
        self.scene_object_list += self._read_object_list()

        #Complete the list with the objects already tracked by the semantic cam.
        if 'passiveObjectsDict' in blenderapi.persistantstorage():
            self.scene_object_list += [obj['label'] for obj in blenderapi.persistantstorage().passiveObjectsDict.values()]

        if not self.scene_object_list:
            logger.error("No VIMAN object to track. Make sure some objects have " +\
                   "the game property 'Object' defined. Disabling poster for now.")
            return None

        # Init the data structures used by this poster
        self.obj.nbObjects = len(self.scene_object_list)
        i = 0
        for object in self.scene_object_list:
            logger.info("Adding " + object + " to the objects tracked by VIMAN")
            self.obj.objects[i].name = bytes(str(object), 'utf-8')
            i += 1

    def _read_object_list(self):
        """ Open the file specified in the object_config_file variable

        Read the list of component names"""

        scene_object_list = []
        logger.info("Reading '%s' config file for VIMAN poster" % object_config_file)

        try:
            fp = open(object_config_file, "r")
            for line in fp:
                match = re.search('object (\w+)', line)
                if match is not None:
                    scene_object_list.append(match.group(1))
                    logger.debug("\t- %s" % match.group(1))
            fp.close()
        except IOError as detail:
            logger.debug(detail)
            logger.info("ARToolkit tag library not found. Skipping it.")
            return []

        return scene_object_list

    def default(self, ci):
        seen_objects = [obj['name'] for obj in self.data['visible_objects']]
        parent = self.component_instance.robot_parent

        i = 0
        for object_id in self.scene_object_list:
            try:
                t = time.time()
                tacq_sec = int(t)
                tacq_usec = int((t - tacq_sec) * 1000)
                self.obj.objects[i].tacq_sec = tacq_sec
                self.obj.objects[i].tacq_usec = tacq_usec

                if object_id in seen_objects:
                    obj = passive_objects.obj_from_label(object_id)

                    position_3d = Transformation3d(obj)
                    logger.debug("VIMAN " + object_id + "(" + obj.name +
                                 ") is visible at " + str(position_3d))
                    self.obj.objects[i].found_Stereo = 1
                    _fill_world_matrix(self.obj.objects[i], position_3d)
                    _fill_robot_matrix(self.obj.objects[i], parent, position_3d)
                else:
                    self.obj.objects[i].found_Stereo = 0
            except KeyError as detail:
                logger.debug("WARNING: Object %s not found in the scene" % detail)
            i += 1
        self.write(self.obj)



########NEW FILE########
__FILENAME__ = pocolibs_datastream
import logging; logger = logging.getLogger("morse." + __name__)
import datetime
from ctypes import *
from morse.middleware import AbstractDatastream
from morse.core.datastream import *

try:
    P = CDLL("libposterLib.so")
except OSError:
    import morse.core.blenderapi
    if not morse.core.blenderapi.fake:
        logger.error('Cannot find libposterLib.so : check your LD_LIBRARY_PATH')
        raise


class PosterNotFound(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class InvalidRead(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def poster_name(component_name, mw_data):
    # Check if the name of the poster has been given in mw_data
    poster_name = ''
    if 'poster' in mw_data:
        poster_name = mw_data['poster']
    else:
        # Compose the name of the poster, based on the parent and module names
        poster_name = component_name

    return poster_name

class DummyPoster:
    def __init__(self, name):
        self.poster_id = c_void_p()
        c_name = create_string_buffer(bytes(name, 'utf-8'))
        P.posterCreate(c_name, 8, byref(self.poster_id))

    def __del__(self):
        P.posterDelete(self.poster_id)
        self.poster_id = None

class PocolibsDataStreamOutput(AbstractDatastream):

    def initialize(self, kind):
        self.poster_id = c_void_p()
        o = kind()
        self.name = poster_name(self.component_name, self.kwargs)
        c_name = create_string_buffer(bytes(self.name, 'utf-8'))
        logger.info("Create poster %s of size %d" % (self.name, sizeof(o)))
        r = P.posterCreate(c_name, sizeof(o), byref(self.poster_id))
        if r != 0:
            P.posterFind(c_name, byref(self.poster_id))

    def write(self, obj):
        r = P.posterWrite(self.poster_id, 0, byref(obj), sizeof(obj))
        if r != sizeof(obj):
            raise "too bad : write failed"

    def finalize(self):
        logger.info("Releaase poster %s" % self.name)
        P.posterDelete(self.poster_id)
        self.poster_id = None

class PocolibsDataStreamInput(AbstractDatastream):
    def initialize(self, kind):
        self.poster_id = c_void_p()
        name = poster_name(self.component_name, self.kwargs)
        delay = self.kwargs.get('delay', True)
        self.name = name
        self.c_name = create_string_buffer(bytes(name, 'utf-8'))

        self.o = kind()
        self.found = False
        self._find()
        if not self.found and not delay:
            raise PosterNotFound(self.name)

    def _find(self):
        logger.debug("Searching to read %s" % self.name)
        r = P.posterFind(self.c_name, byref(self.poster_id))
        if r == 0:
            self.found = True

    def read(self):
        if not self.found:
            self._find()

        if self.found:
            r = P.posterRead(self.poster_id, 0, byref(self.o), sizeof(self.o))
            if r != sizeof(self.o):
                raise InvalidRead(self.name)
            return self.o
        else:
            return None

    def finalize(self):
        if self.found:
            P.posterForget(self.poster_id)

class PocolibsDatastreamManager(DatastreamManager):
    """ Handle communication between Blender and Pocolibs."""

    def compute_date():
        """ Compute the current time

        ( we only require that the date
        increases using a constant step so real time is ok)
        """
        t = datetime.datetime.now()
        date = int(t.hour * 3600* 1000 + t.minute * 60 * 1000 +
                t.second * 1000 + t.microsecond / 1000)

        return date, t

########NEW FILE########
__FILENAME__ = pocolibs_request_manager
import logging; logger = logging.getLogger("morse." + __name__)
logger.setLevel(logging.DEBUG)
import sys
import socket
import select

from morse.core.exceptions import *
from morse.core.request_manager import RequestManager
from morse.core import status

class PocolibsRequestManager(RequestManager):
    """Implements Pocolibs requests to control the MORSE simulator.
    
    This is done by re-implementing (parts of) the TCLserv protocol.
    """
    
    HOST = '' #all available interfaces
    PORT = 9473 # TCL serv port + 1

    def __str__(self):
        return "Pocolibs service manager"

    def initialization(self):
        
        #  socket -> identifier (int)
        self._clients = {} 

        # socket cmd -> socket answer (may be the same)
        self._answer_clients = {}  
        
        # Clients that have pending (ie asynchronous) requests
        # map intern_rqst_id -> (client, rqst_id, request_name)
        self._intern_pending_requests = {} 
        # Map pocolibs rqst_id -> intern_rqst_id 
        self._internal_mapping = {}

        self._next_client_id = 0
        self._next_rqst_id = 0
        
        self._landing_request = None
        
        # Holds the output queue as a dictionary {socket:[message...]}
        self._results_to_output = {}

        self._server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        try:
            self._server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self._server.bind((PocolibsRequestManager.HOST, PocolibsRequestManager.PORT))
            self._server.listen(1)
        except socket.error as msg:
            self._server.close()
            self._server = None
            
        if not self._server:
            logger.info('Could not bind the Pocolibs server. Port busy?')
            return False

        logger.info("Pocolibs request manager now listening on port " + str(PocolibsRequestManager.PORT) + ".")
        
        # Prepare 'select'
        self._inputs = [self._server]
        self._outputs = []
        
        self._quitting = False
        
        return True

    def finalization(self):
        """ Terminate the ports used to accept requests """
        if self._clients:
            logger.info("Closing client sockets...")
            for s in self._clients.keys():
                s.shutdown(socket.SHUT_RDWR)
        
        if self._server:
            logger.info("Closing Pocolibs server...")
            self._server.shutdown(socket.SHUT_RDWR)
            del self._server

        return True

    def _encode_answer(self, rqst_id, fqn, result):
        state, value = result
        component, rqst = fqn.strip("::").split("::")

        res = str(rqst_id) + " " + fqn + " TERM "
        if state == status.SUCCESS:
            res += "OK" + (" " + "  ".join([str(i) for i in value]) if value else "")
        elif state == status.PREEMPTED:
            res += "S_" + component + "_stdGenoM_ACTIVITY_INTERRUPTED"
        else:
            if value:
                res +=  "S_" + component + "_" + str(value[0])
            else:
                res +=  "S_" + component + "_UNKNOWN_ERROR"
        return res

    def on_service_completion(self, intern_rqst_id, result):
        
        s = None
        
        try:
            s, rqst_id, fqn = self._intern_pending_requests[intern_rqst_id]
        except KeyError:
            logger.info(str(self) + ": ERROR: I can not find the socket which requested " + \
                  intern_rqst_id + ". Skipping it.")
            return

        del self._intern_pending_requests[intern_rqst_id]
        del self._internal_mapping[rqst_id]
        res = self._encode_answer(rqst_id, fqn, result)
        self._results_to_output.setdefault(self._answer_clients[s], []).append(res)
        

    def post_registration(self, component, service, is_async):
        return True # No post-registration steps

    def _remove_client(self, i):
        del self._clients[i]
        del self._answer_clients[i]
        self._inputs.remove(i)
        self._outputs.remove(i)

    def main(self):
        
        inputready, outputready, exceptready = [],[],[]

        try:
            inputready, outputready, exceptready = select.select(self._inputs, self._outputs, [], 0) #timeout = 0 : Never block, just poll
        except select.error:
            pass
        except socket.error:
            pass

        for i in inputready:
            if i == self._server:
                conn, addr = self._server.accept()
                
                data = ""
                data = conn.recv(1024).decode('ascii')
                
                data = data.strip("\n\r")
                
                if data == "HELLO":
                    conn.send(("HELLO " + str(self._next_client_id) + "\r\n").encode('ascii'))
                    logger.info('Pocolibs request manager: new connection from %s', str(addr) )
                    self._clients[conn] = self._next_client_id
                    self._answer_clients[conn] = conn
                    self._inputs.append(conn)
                    self._outputs.append(conn)
                    self._next_client_id += 1
                else:
                    logger.info("Incorrect connection attempt - was expecting 'HELLO\\n', got '" + data + "'.")
                    conn.close()

            else:
                data = None
                try:
                    data = i.recv(1024).decode('ascii')
                except socket.error as msg:
                    logger.warning("Client " + str(self._clients[i]) +
                                    " disconnected : error " + str(msg))
                    self._remove_client(i)

                if not data:
                    logger.warning("Client disconnected without BYE")
                    self._remove_client(i)
                    continue

                logger.debug("[Client " + str(self._clients[i]) + "]: " + data)

                if data.startswith("BYE"):
                    logger.info("Client " + str(self._clients[i]) + " is leaving. Bye bye")
                    self._remove_client(i)
                    continue
                    
                ok, msg = self._dispatch(data, self._clients[i])
        
                if ok:
                    self._results_to_output.setdefault(i, []).append("OK " + msg)
                else:
                    self._results_to_output.setdefault(i, []).append("ERROR " + msg)
                
                # After dispatching, we have a new, 'landing', request. Let's deal
                # with it.
                if self._landing_request:
                    
                    rqst_id, fqn, is_sync, result = self._landing_request
                    
                    if is_sync:
                        res = self._encode_answer(rqst_id, fqn, result)
                        self._results_to_output.setdefault(self._answer_clients[i], []).append(res)
                    else:
                        activity_id = 0 #TODO: For now, we do not support more than one instance of the same request
                        res = str(rqst_id) + " " + fqn + " ACK " + str(activity_id)
                        self._results_to_output.setdefault(self._answer_clients[i], []).append(res)
                        
                        # Stores the mapping request/socket to notify
                        # the right client when the service completes.
                        # (cf :py:meth:on_service_completion)
                        # Here, 'result' is the internal request id while
                        # 'rqst_id' is the id used by the socket client.
                        self._intern_pending_requests[result] = (i, rqst_id, fqn)
                        self._internal_mapping[rqst_id] = result
                        
                    self._landing_request = None
        
        if self._results_to_output:
            for o in outputready:
                if o in self._results_to_output:
                    for r in self._results_to_output[o]:
                        try:
                            o.send((r + "\r\n").encode('ascii'))
                            logger.debug("Sending [" + r + "] to " + str(self._clients[o]))
                        except socket.error as msg:
                            logger.warning("It seems that a socket client left. Closing the socket. "
                                           "Error " + msg)
                            self._remove_client(o)
                            
                    del self._results_to_output[o]


    def _dispatch(self, raw, client_id):
        """ This method implements the TCLserv protocol.
        
        :param raw: the raw string, as read on the socket
        :return: a tuple (status, message). status == True means the request
                 has been successfully dispatched. In that case, and if the 
                 request is a RQST command, 'message' contains the request id 
                 that will be used in subsequent ACK or TERM messages.
                 In other cases, 'message' contains the return value of the 
                 request (and can be empty).
                 status == False means that the disptaching failed. 'message'
                 contains the error message.
        """
        
        req = raw.split()        
        cmd = req[0]
        
        if cmd  == "REPLYTO":
            if client_id != int(req[1]):
                s_client = None
                s_reply = None
                for s, id in self._clients.items():
                    if id == client_id:
                        s_client = s
                    elif id == int(req[1]):
                        s_reply = s

                if s_client and s_reply:
                    self._answer_clients[s_client] = s_reply

            return True, str(req[1])
        
        if cmd == "RQST":
            component, rqst = req[1].strip("::").split("::")
            params = req[2:]
            logger.info("Incoming pocolibs request " + rqst + 
                    " for component " + component + 
                    " with params " + str(params))
            
            rqst_id = self._next_rqst_id
            self._next_rqst_id += 1
            
            try:
                # on_incoming_request returns either 
                #(True, result) if it's a synchronous
                # request that has been immediately executed, or
                # (False, request_id) if it's an asynchronous request whose
                # termination will be notified via
                # on_service_completion.
                # _landing_request will containt:
                #    - the request id
                #    - the request TCL 'full qualified name' (eg ::component::meth)
                #    - the 'is synchronous' flag
                #    - a value, as explained above
                self._landing_request = (rqst_id,"::" + component + "::" + rqst) + \
                                        self.on_incoming_request(component, rqst, params)
                
            except MorseMethodNotFoundError:
                # Request not found for module
                return False, "1 invalid command name \\\"" + rqst + "Send\\\""
            except MorseRPCNbArgsError:
                logger.debug("Exception catched %s" % sys.exc_info())
                # Wrong # of args
                return False, "1 wrong # args"
            except MorseRPCTypeError:
                # Wrong # of args
                return False, "1 wrong type in args"

            return True, str(rqst_id)

        if cmd == "ABORT":
            rqst_id = int(req[1])
            logger.debug("ABORT request %s " % str(rqst_id))
            self.abort_request(self._internal_mapping[rqst_id])
            return True, ""
            
        if cmd == "cs::lsmbox": # want to list available modules
            return True, " ".join(self.services().keys())
        
        if cmd == "info":
            if req[1] == "commands":
                # The client want to retrieve the list of available requests.
                # Rebuild a 'TCL like' list of methods for the required module.
                component = req[2].split("::")[0]
                return True, " ".join(["::" + component + "::" + method + "Send" for method in self.services()[component]])
                
        if cmd in ["LM", "cs::init", "exec", "modules::connect", "ACK", "UNLM", "KILL"]:
            # Not needed in simulation
            return True, ""
        
        logger.error("command " + cmd + " not implemented!")
        return False, "0 command " + cmd + " not implemented!"


########NEW FILE########
__FILENAME__ = abstract_ros
import logging; logger = logging.getLogger("morse.ros")
import re
try:
    import roslib
except ImportError as error:
    logger.error("Could not find ROS. source setup.[ba]sh ?")
    raise error
import rospy

from std_msgs.msg import String, Header
from geometry_msgs.msg import TransformStamped

from morse.middleware.ros.tfMessage import tfMessage
from morse.middleware import AbstractDatastream

from morse.core.blenderapi import persistantstorage

try:
    import mathutils
except ImportError:
    # running outside Blender
    mathutils = None

class classproperty(object):
    def __init__(self, fget):
        self.fget = fget
    def __get__(self, owner_self, owner_cls):
        return self.fget(owner_cls)

class AbstractROS(AbstractDatastream):
    """ Base class for all ROS Publishers and Subscribers """
    ros_class = Header # default

    @classproperty
    def _type_name(cls):
        # returns the standard ROS message name from its Python class
        return "%s/%s"%(cls.ros_class.__module__.split('.')[0], cls.ros_class.__name__)

    @classproperty
    def _type_url(cls):
        # used to generate documentation
        return "http://ros.org/doc/api/%s/html/msg/%s.html"%tuple(cls._type_name.split('/'))

    def initialize(self):
        # Initialize MORSE-ROS-node. If already initialized, does nothing
        name = 'morse'
        morse_ps = persistantstorage() # dict
        if 'node_instance' in morse_ps:
            name = 'morse_%s' % morse_ps.node_instance.node_name
        rospy.init_node(name, log_level=rospy.DEBUG, disable_signals=True)

        logger.info("ROS node %s initialized %s" % (name, self) )
        self.topic = None

        if 'topic' in self.kwargs:
            self.topic_name = self.kwargs['topic']
        else:
            self.topic_name = self.get_topic_name()

    def get_topic_name(self):
        # robot.001.sensor.001 = robot001.sensor001
        topic_name = re.sub(r'\.([0-9]+)', r'\1', self.component_name)
        # '/robot001/sensor001'
        return '/' + topic_name.replace('.', '/')

    def finalize(self):
        """ Cleaning """
        # Unregister the topic if one exists
        if self.topic:
            self.topic.unregister()
        logger.info("ROS datastream finalize %s"%self)


class ROSPublisher(AbstractROS):
    """ Base class for all ROS Publishers """
    default_frame_id = 'USE_TOPIC_NAME'

    def initialize(self):
        AbstractROS.initialize(self)
        topic_name = self.topic_name
        if 'topic_suffix' in self.kwargs: # used for /robot/camera/image
            topic_name += self.kwargs['topic_suffix']
        # do not create a topic if no ros_class set (for TF publish only)
        if self.ros_class != Header:
            # Generate a publisher for the component
            self.topic = rospy.Publisher(topic_name, self.ros_class)
        if self.default_frame_id is 'USE_TOPIC_NAME': # morse convention
            self.frame_id = self.kwargs.get('frame_id', self.topic_name)
        else: # default_frame_id was overloaded in subclass
            self.frame_id = self.kwargs.get('frame_id', self.default_frame_id)
        self.sequence = 0 # for ROS msg Header
        logger.info('ROS publisher initialized for %s'%self)

    def get_ros_header(self):
        header = Header()
        header.stamp = self.get_time()
        header.seq = self.sequence
        # http://www.ros.org/wiki/geometry/CoordinateFrameConventions#Multi_Robot_Support
        header.frame_id = self.frame_id
        return header

    def get_time(self):
        return rospy.Time.from_sec(self.data['timestamp'])

    # Generic publish method
    def publish(self, message):
        """ Publish the data on the rostopic
        """
        self.topic.publish(message)
        self.sequence += 1


class ROSPublisherTF(ROSPublisher):
    """ Base class for all ROS Publishers with TF support """
    topic_tf = None

    def initialize(self):
        ROSPublisher.initialize(self)
        if not ROSPublisherTF.topic_tf:
            ROSPublisherTF.topic_tf = rospy.Publisher("/tf", tfMessage)

    def finalize(self):
        ROSPublisher.finalize(self)
        ROSPublisherTF.topic_tf.unregister()

    def get_robot_transform(self):
        """ Get the transformation relative to the robot origin

        Return the local position, orientation and scale of this components
        """
        rel_pos = self.component_instance.sensor_to_robot_position_3d()
        return rel_pos.translation, rel_pos.rotation

    def publish_with_robot_transform(self, message):
        self.publish(message)
        self.send_transform_robot(message.header.stamp, message.header.frame_id)

    def send_transform_robot(self, time=None, child=None, parent=None):
        """ Send the transformation relative to the robot

        :param time: default now
        :param child: default topic_name or 'frame_id' in kwargs
        :param parent: default 'base_link' or 'parent_frame_id' in kwargs
        """
        translation, rotation = self.get_robot_transform()
        if not time:
            time = self.get_time()
        if not child:
            # our frame_id (component frame)
            child = self.frame_id
        if not parent:
            # get parent frame_id (aka. the robot)
            parent = self.kwargs.get('parent_frame_id', 'base_link')
        #rospy.loginfo("t:%s,r:%s"%(str(translation), str(rotation)))
        # send the transformation
        self.sendTransform(translation, rotation, time, child, parent)

    # TF publish method
    def publish_tf(self, message):
        """ Publish the TF data on the rostopic
        """
        ROSPublisherTF.topic_tf.publish(message)

    def sendTransform(self, translation, rotation, time, child, parent):
        """
        :param translation: the translation of the transformtion as geometry_msgs/Vector3
        :param rotation: the rotation of the transformation as a geometry_msgs/Quaternion
        :param time: the time of the transformation, as a rospy.Time()
        :param child: child frame in tf, string
        :param parent: parent frame in tf, string

        Broadcast the transformation from tf frame child to parent on ROS topic ``"/tf"``.
        """

        t = TransformStamped()
        t.header.frame_id = parent
        t.header.stamp = time
        t.child_frame_id = child
        t.transform.translation = translation
        t.transform.rotation = rotation

        tfm = tfMessage([t])

        self.publish_tf(tfm)


class ROSSubscriber(AbstractROS):
    """ Base class for all ROS Subscribers """

    def initialize(self):
        AbstractROS.initialize(self)
        self.message = None
        # Generate a subscriber for the component
        self.topic = rospy.Subscriber(self.topic_name, self.ros_class, self.callback)
        logger.info('ROS subscriber initialized for %s'%self)

    def callback(self, message):
        if self.message is None:
            self.message = message

    def default(self, ci='unused'):
        # If a new message has been received
        if self.message:
            # Update local_data
            self.update(self.message)
            # Free message for new reception
            self.message = None
            # Tell MORSE that we can apply modifiers
            return True

        return False

    def update(self, message):
        """ Update `local_data` with :param message:

        Called when component.default_action is triggered
        and a new message was received
        """
        pass

#
# Example (String)
#

class StringPublisher(ROSPublisher):
    """ Publish a string containing a printable representation of the local data. """
    ros_class = String

    def default(self, ci='unused'):
        self.publish(repr(self.data))


class StringReader(ROSSubscriber):
    """ Subscribe to a String topic and log its data decoded as UTF-8. """
    ros_class = String

    def update(self, message):
        logger.info("Received String message %s on topic %s" % \
                    (message.data.decode("utf-8"), # String message decode
                     self.topic_name))

########NEW FILE########
__FILENAME__ = accelerometer
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Twist
from morse.middleware.ros import ROSPublisher

class TwistPublisher(ROSPublisher):
    """ Publish the velocity of the acceleromter sensor.
    No angular information, only linear ones.
    """
    ros_class = Twist

    def default(self, ci='unused'):
        twist = Twist()

        # Fill twist-msg with the values from the sensor
        twist.linear.x = self.data['velocity'][0]
        twist.linear.y = self.data['velocity'][1]
        twist.linear.z = self.data['velocity'][2]

        self.publish(twist)

########NEW FILE########
__FILENAME__ = battery
import roslib; roslib.load_manifest('std_msgs')
from std_msgs.msg import Float32
from morse.middleware.ros import ROSPublisher

class Float32Publisher(ROSPublisher):
    """ Publish the charge of the battery sensor. """
    ros_class = Float32

    def default(self, ci='unused'):
        msg = Float32()
        msg.data = self.data['charge']

        self.publish(msg)

########NEW FILE########
__FILENAME__ = clock
import roslib; roslib.load_manifest('rospy'); roslib.load_manifest('rosgraph_msgs')
import rospy
from rosgraph_msgs.msg import Clock
from morse.middleware.ros import ROSPublisher

class ClockPublisher(ROSPublisher):
    """ Publish the simulator clock. """
    ros_class = Clock

    def initialize(self):
        ROSPublisher.initialize(self)

    def default(self, ci='unused'):
        msg = Clock()
        msg.clock = self.get_time()

        self.publish(msg)

########NEW FILE########
__FILENAME__ = depth_camera
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('sensor_msgs')
from sensor_msgs.msg import PointCloud2, PointField
from morse.middleware.ros import ROSPublisherTF

class DepthCameraPublisher(ROSPublisherTF):
    """ Publish the depth field from the Camera perspective as XYZ point-cloud.
    And send the transformation between the camera and the robot through TF.
    """
    ros_class = PointCloud2

    def default(self, ci='unused'):
        if not self.component_instance.capturing:
            return # press [Space] key to enable capturing

        # This message holds a collection of N-dimensional points, which may
        # contain additional information such as normals, intensity, etc. The
        # point data is stored as a binary blob, its layout described by the
        # contents of the "fields" array.

        # The point cloud data may be organized 2d (image-like) or 1d
        # (unordered). Point clouds organized as 2d images may be produced by
        # camera depth sensors such as stereo or time-of-flight.
        pc2 = PointCloud2()
        # Time of sensor data acquisition, and the coordinate frame ID (for 3d
        # points).
        pc2.header = self.get_ros_header()
        # 2D structure of the point cloud. If the cloud is unordered, height is
        # 1 and width is the length of the point cloud.
        pc2.height = 1
        pc2.width = self.data['nb_points']
        # Describes the channels and their layout in the binary data blob.
        pc2.fields = [PointField('x', 0, PointField.FLOAT32, 1),
                      PointField('y', 4, PointField.FLOAT32, 1),
                      PointField('z', 8, PointField.FLOAT32, 1)]
        pc2.is_dense = True         # True if there are no invalid points
        pc2.is_bigendian = False    # Is this data bigendian?
        pc2.point_step = 12         # Length of a point in bytes
        pc2.row_step = len(self.data['points']) # Length of a row in bytes

        # Actual point data, size is (row_step*height)
        # memoryview from PyMemoryView_FromMemory() implements the buffer interface
        pc2.data = bytes(self.data['points'])

        self.publish_with_robot_transform(pc2)


########NEW FILE########
__FILENAME__ = destination
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Point
from morse.middleware.ros import ROSSubscriber

class PointReader(ROSSubscriber):
    """ Subscribe to a Point topic and set x,y,z local data. """
    ros_class = Point

    def update(self, message):
        self.data["x"] = message.x
        self.data["y"] = message.y
        self.data["z"] = message.z

########NEW FILE########
__FILENAME__ = force_torque
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Wrench
from morse.middleware.ros import ROSSubscriber

class WrenchReader(ROSSubscriber):
    """ Subscribe to a Wrench topic and set force and torque (x,y,z) local data. """
    ros_class = Wrench

    def update(self, message):
        self.data["force"][0] = message.force.x
        self.data["force"][1] = message.force.y
        self.data["force"][2] = message.force.z
        self.data["torque"][0] = message.torque.x
        self.data["torque"][1] = message.torque.y
        self.data["torque"][2] = message.torque.z
        logger.debug("Applying force: [%s, %s, %s], torque: [%s, %s, %s]"%
                     (message.force.x, message.force.y, message.force.z,
                      message.torque.x, message.torque.y, message.torque.z))

########NEW FILE########
__FILENAME__ = gps
import roslib; roslib.load_manifest('sensor_msgs')
from sensor_msgs.msg import NavSatFix
from morse.middleware.ros import ROSPublisher

class NavSatFixPublisher(ROSPublisher):
    """ Publish the GPS position of the robot. """
    ros_class = NavSatFix

    def default(self, ci='unused'):
        gps = NavSatFix()
        gps.header = self.get_ros_header()

        gps.latitude = self.data['x']
        gps.longitude = self.data['y']
        gps.altitude = self.data['z']

        self.publish(gps)

########NEW FILE########
__FILENAME__ = helpers

import rospkg
import sys
import os

def ros_add_to_syspath(node):
    rp = rospkg.RosPack()
    path = os.path.join(rp.get_path(node),"src")
    sys.path.append(path)


########NEW FILE########
__FILENAME__ = imu
import roslib; roslib.load_manifest('sensor_msgs')
from sensor_msgs.msg import Imu
from morse.middleware.ros import ROSPublisher

class ImuPublisher(ROSPublisher):
    """ Publish the data of the IMU sensor (without covariance). """
    ros_class = Imu
    default_frame_id = '/imu'

    def default(self, ci='unused'):
        imu = Imu()
        imu.header = self.get_ros_header()

        imu.orientation = self.component_instance.bge_object.worldOrientation.to_quaternion()

        imu.angular_velocity.x = self.data['angular_velocity'][0]
        imu.angular_velocity.y = self.data['angular_velocity'][1]
        imu.angular_velocity.z = self.data['angular_velocity'][2]

        imu.linear_acceleration.x = self.data['linear_acceleration'][0]
        imu.linear_acceleration.y = self.data['linear_acceleration'][1]
        imu.linear_acceleration.z = self.data['linear_acceleration'][2]

        self.publish(imu)

########NEW FILE########
__FILENAME__ = infrared
import roslib; roslib.load_manifest('sensor_msgs')
from sensor_msgs.msg import Range
from morse.middleware.ros import ROSPublisher

class RangePublisher(ROSPublisher):
    """ Publish the range of the infrared sensor. """
    ros_class = Range

    def default(self, ci='unused'):
        msg = Range()
        msg.radiation_type = Range.INFRARED
        msg.field_of_view = 20
        msg.min_range = 0
        msg.max_range = self.component_instance.bge_object['laser_range']
        tmp = msg.max_range
        for ray in self.data['range_list']:
            if tmp > ray:
                tmp = ray
        msg.range = tmp

        self.publish(msg)

########NEW FILE########
__FILENAME__ = jido_posture
import roslib; roslib.load_manifest('sensor_msgs')
from sensor_msgs.msg import JointState
from morse.middleware.ros import ROSPublisher

class JointStatePublisher(ROSPublisher):
    """ Publish the data of the posture sensor (for Jido). """
    ros_class = JointState

    def default(self, ci='unused'):
        js = JointState()
        js.header = self.get_ros_header()

        js.name = [
           'kuka_arm_0_joint', 'kuka_arm_1_joint', 'kuka_arm_2_joint',
           'kuka_arm_3_joint', 'kuka_arm_4_joint', 'kuka_arm_5_joint',
           'kuka_arm_6_joint', 'head_pan_joint', 'head_tilt_joint'
        ]
        js.position = [
            self.data['seg0'],
            self.data['seg1'],
            self.data['seg2'],
            self.data['seg3'],
            self.data['seg4'],
            self.data['seg5'],
            self.data['seg6'],
            self.data['pan'],
            self.data['tilt']
        ]
        #js.velocity = [1, 1, 1, 1, 1, 1, 1]
        #js.effort = [50, 50, 50, 50, 50, 50, 50]

        self.publish(js)

########NEW FILE########
__FILENAME__ = jointpositions
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('motion_control_msgs')
from motion_control_msgs.msg import JointPositions
from morse.middleware.ros import ROSSubscriber

class JointPositionsReader(ROSSubscriber):

    ros_class = JointPositions

    def update(self, msg):

        joint_names = msg.names
       
        for joint in joint_names:
                # update the joint values of each of the joints
                self.data[joint] = msg.positions[joint]

########NEW FILE########
__FILENAME__ = jointstate
from sensor_msgs.msg import JointState
from morse.middleware.sockets.jointstate import fill_missing_pr2_joints
from morse.middleware.ros import ROSPublisher

class JointStatePublisher(ROSPublisher):
    """ Publish the data of the posture sensor. """
    ros_class = JointState

    def default(self, ci='unused'):
        js = JointState()
        js.header = self.get_ros_header()

        # collect name and positions of jointstates from sensor
        js.name = self.data.keys()
        js.position = self.data.values()
        # for now leaving out velocity and effort
        #js.velocity = [1, 1, 1, 1, 1, 1, 1]
        #js.effort = [50, 50, 50, 50, 50, 50, 50]

        self.publish(js)


class JointStatePR2Publisher(ROSPublisher):
    """ Publish the data of the posture sensor after filling missing PR2 joints. """
    ros_class = JointState

    def default(self, ci='unused'):
        js = JointState()
        js.header = self.get_ros_header()

        joints =  fill_missing_pr2_joints(self.data)
        js.name = joints.keys()
        js.position = joints.values()

        self.publish(js)

########NEW FILE########
__FILENAME__ = jointtrajectorycontrollers
# ROS imports: pr2_controllers_msgs is not catkinized in fuerte
from morse.middleware.ros.helpers import ros_add_to_syspath
ros_add_to_syspath("pr2_controllers_msgs")
from pr2_controllers_msgs.msg import JointTrajectoryControllerState
from morse.middleware.ros import ROSPublisher

class JointTrajectoryControllerStatePublisher(ROSPublisher):
    """ Publish the data of the pr2 joint sensor. """
    ros_class = JointTrajectoryControllerState

    def default(self, ci='unused'):
        js = JointTrajectoryControllerState()
        js.header = self.get_ros_header()

        js.joint_names = self.data.keys()
        js.actual.positions = self.data.values()

        js.actual.velocities = [0.0] * len(self.data)
        js.actual.accelerations = [0.0] * len(self.data)

        self.publish(js)

########NEW FILE########
__FILENAME__ = kuka_jointpositions
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('motion_control_msgs')
from motion_control_msgs.msg import JointPositions
from morse.middleware.ros import ROSSubscriber

class JointPositionsReader(ROSSubscriber):

    ros_class = JointPositions

    def update(self, msg):

        for i in range(7):
            self.data["kuka_%i"%(i+1)] = msg.positions[i]


########NEW FILE########
__FILENAME__ = kuka_jointstate
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('sensor_msgs')
from sensor_msgs.msg import JointState
from morse.middleware.ros import ROSSubscriber

class JointStateReader(ROSSubscriber):
    """ Subscribe to a JointState topic and set kuka_{1-7} to the position[0-6]. """
    ros_class = JointState

    def update(self, message):
        logger.debug("Received JointState names: %s on topic %s"%(message.name, self.topic_name))
        logger.debug("Received JointState positons: %s on topic %s"%(message.position, self.topic_name))
        logger.debug("Received JointState velocity: %s on topic %s"%(message.velocity, self.topic_name))

        for i in range(7):
            self.data["kuka_%i"%(i+1)] = message.position[i]


########NEW FILE########
__FILENAME__ = kuka_jointstate_pub
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('sensor_msgs')
from sensor_msgs.msg import JointState
from morse.middleware.ros import ROSPublisher

class JointStatePublisher(ROSPublisher):
    """ Publishes a JointState topic and set kuka_{1-7} to the position[0-6]. """
    ros_class = JointState

    def default(self, ci='unused'):
        message = JointState()
        message.name = [''] * 7
        message.position = [0] * 7
        message.velocity = [0] * 7
        message.effort = [0] * 7
        for i in range(7):
            message.name[i] = "arm_%i_joint"%i
            message.position[i] = self.data["kuka_%i"%(i+1)]

        self.publish(message)


########NEW FILE########
__FILENAME__ = laserscanner
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('sensor_msgs')
import math
import struct
import itertools
from sensor_msgs.msg import LaserScan, PointCloud2, PointField
from morse.middleware.ros import ROSPublisher, ROSPublisherTF

class LaserScanPublisher(ROSPublisher):
    """ Publish the ``range_list`` of the laser scanner. """
    ros_class = LaserScan
    default_frame_id = '/base_laser_link'

    def default(self, ci='unused'):
        laserscan = LaserScan()
        laserscan.header = self.get_ros_header()

        # Note: Scan time and laser frequency are chosen as standard values
        laser_frequency = 40 # TODO ? component_instance.frequency()
        scan_window = self.component_instance.bge_object['scan_window']
        num_readings = scan_window / self.component_instance.bge_object['resolution']

        laserscan.angle_max = scan_window * math.pi / 360
        laserscan.angle_min = laserscan.angle_max * -1
        laserscan.angle_increment = scan_window / num_readings * math.pi / 180
        laserscan.time_increment = 1 / laser_frequency / num_readings
        laserscan.scan_time = 1.0
        laserscan.range_min = 0.3
        laserscan.range_max = self.component_instance.bge_object['laser_range']
        # ROS expect the ranges to be sorted clockwise.
        # see morse.builder.sensor.LaserSensorWithArc.create_laser_arc
        # where we create the ray from -window / 2.0 to +window / 2.0
        laserscan.ranges = self.data['range_list']

        self.publish(laserscan)

class PointCloud2Publisher(ROSPublisherTF):
    """ Publish the ``point_list`` of the laser scanner. """
    ros_class = PointCloud2

    def default(self, ci='unused'):
        points = self.data['point_list']
        size = len(points)

        pc2 = PointCloud2()
        pc2.header = self.get_ros_header()
        pc2.height = 1
        pc2.width = size
        pc2.is_dense = False
        pc2.is_bigendian = False
        pc2.fields = [PointField('x', 0, PointField.FLOAT32, 1),
                      PointField('y', 4, PointField.FLOAT32, 1),
                      PointField('z', 8, PointField.FLOAT32, 1)]
        pc2.point_step = 12
        pc2.row_step = size * 12

        pc2.data = pack_xyz_float32(points)

        self.publish(pc2)
        self.send_transform_robot()

def pack_xyz_float32(points):
    flatten = itertools.chain.from_iterable(points)
    return struct.pack('%if'%len(points)*3, *flatten)

########NEW FILE########
__FILENAME__ = light
import roslib; roslib.load_manifest('std_msgs')
from std_msgs.msg import Bool
from morse.middleware.ros import ROSSubscriber

class BoolReader(ROSSubscriber):
    """ Subscribe to a boolean topic to control if we must or not emit light. """
    ros_class = Bool

    def update(self, message):
        self.data["emit"] = message.data

########NEW FILE########
__FILENAME__ = motion_vw
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Twist
from morse.middleware.ros import ROSSubscriber

class TwistReader(ROSSubscriber):
    """ Subscribe to a motion command and set ``v`` and ``w`` local data. """
    ros_class = Twist

    def update(self, message):
        self.data["v"] = message.linear.x
        self.data["w"] = message.angular.z # yaw

########NEW FILE########
__FILENAME__ = motion_xyw
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Twist
from morse.middleware.ros import ROSSubscriber

class TwistReader(ROSSubscriber):
    """ Subscribe to a motion command and set ``x``, ``y`` and ``w`` local data. """
    ros_class = Twist

    def update(self, message):
        self.data["x"] = message.linear.x
        self.data["y"] = message.linear.y
        self.data["w"] = message.angular.z # yaw
        logger.debug("Executing x,y,omega movement: <%s, %s, %s>"%
                     (message.linear.x, message.linear.y, message.angular.z))

########NEW FILE########
__FILENAME__ = odometry
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('rospy'); roslib.load_manifest('nav_msgs'); roslib.load_manifest('geometry_msgs')
import rospy
from geometry_msgs.msg import Vector3, Quaternion, Pose, Twist
from nav_msgs.msg import Odometry
from morse.middleware.ros import ROSPublisherTF, mathutils

class OdometryPublisher(ROSPublisherTF):
    """ Publish the odometry of the robot. And send the transformation between
    ``frame_id`` and ``child_frame_id`` args, default '/odom' and
    '/base_footprint' through TF.
    """
    ros_class = Odometry
    default_frame_id = '/odom'

    def initialize(self):
        ROSPublisherTF.initialize(self)
        # store the frame ids
        self.child_frame_id = self.kwargs.get("child_frame_id", "/base_footprint")

        logger.info("Initialized the ROS odometry sensor with frame_id '%s' " +\
                    "and child_frame_id '%s'", self.frame_id, self.child_frame_id)

    def default(self, ci='unused'):
        odometry = Odometry()
        odometry.header = self.get_ros_header()
        odometry.child_frame_id = self.child_frame_id

        # fill pose and twist
        odometry.pose.pose = self.get_pose()
        odometry.twist.twist = self.get_twist()

        self.publish(odometry)

        # send current odometry transform
        self.sendTransform(self.get_position(),
                           self.get_orientation(),
                           odometry.header.stamp,
                           odometry.child_frame_id,
                           odometry.header.frame_id)


    def get_orientation(self):
        """ Get the orientation from the local_data and return a quaternion """
        euler = mathutils.Euler((self.data['roll'],
                                 self.data['pitch'],
                                 self.data['yaw']))
        quaternion = euler.to_quaternion()
        return quaternion

    def get_position(self):
        """ Get the position from the local_data and return a ROS Vector3 """
        position = Vector3()
        position.x = self.data['x']
        position.y = self.data['y']
        position.z = self.data['z']
        return position

    def get_pose(self):
        """ Get the pose from the local_data and return a ROS Pose """
        pose = Pose()
        pose.position = self.get_position()
        pose.orientation = self.get_orientation()
        return pose

    def get_twist(self):
        """ Get the twist from the local_data and return a ROS Twist """
        twist = Twist()
        twist.linear.x = self.data['vx']
        twist.linear.y = self.data['vy']
        twist.linear.z = self.data['vz']
        twist.angular.x = self.data['wx']
        twist.angular.y = self.data['wy']
        twist.angular.z = self.data['wz']
        return twist

########NEW FILE########
__FILENAME__ = orientation
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('geometry_msgs')
import math
from geometry_msgs.msg import Quaternion
from morse.middleware.ros import ROSSubscriber, mathutils

class QuaternionReader(ROSSubscriber):
    """ Subscribe to a Quaternion topic and set roll,pitch,yaw local data. """
    ros_class = Quaternion

    def update(self, message):
        quaternion = mathutils.Quaternion((message.w, message.x, message.y, message.z))
        euler = quaternion.to_euler()
        self.data["roll"] = euler.x
        self.data["pitch"] = euler.y
        self.data["yaw"] = euler.z
        logger.debug("Set orientation to RPY (%.3f %.3f %.3f)" % \
                     tuple(math.degrees(a) for a in euler))

########NEW FILE########
__FILENAME__ = armatures
from morse.middleware.ros_request_manager import ros_action
from morse.core.services import interruptible
from morse.core.overlay import MorseOverlay
from morse.core import status
from morse.core.exceptions import MorseServiceError

import logging; logger = logging.getLogger("morse."+ __name__)

import rospy # to set the parameters

from control_msgs.msg import JointTrajectoryAction

class ArmatureController(MorseOverlay):
    """
    This overlay provides a ROS JointTrajectoryAction interface to armatures.

    It is meant to be applied on a Armature actuator.

    Besides the ROS action server, it also sets a ROS parameter with the list of
    joints.
    """

    def __init__(self, overlaid_object, namespace = None):
        # Call the constructor of the parent class
        MorseOverlay.__init__(self, overlaid_object)

        joints = list(overlaid_object.local_data.keys())

        self.namespace = namespace

        name = self.name().replace(".", "/")

        rospy.set_param(name + "/joints", joints)
        rospy.set_param(name + "/joint_trajectory_action/joints", joints)

    def _stamp_to_secs(self, stamp):
        return stamp.secs + stamp.nsecs / 1e9

    def joint_trajectory_action_result(self, result):
        return result

    def name(self):

        if self.namespace:
            return self.namespace
        else:
            return MorseOverlay.name(self)

    @interruptible
    @ros_action(type = JointTrajectoryAction)
    def joint_trajectory_action(self, req):

        # Fill a MORSE trajectory structure from ROS JointTrajectory
        traj = {}

        req = req.trajectory
        traj["starttime"] = self._stamp_to_secs(req.header.stamp)

        joint_names = req.joint_names
        target_joints = self.overlaid_object.local_data.keys()
        diff = set(joint_names).difference(set(target_joints))

        if diff:
            raise MorseServiceError("Trajectory contains unknown joints! %s" % diff)

        points = []
        for p in req.points:
            point = {}

            # Re-order joint values to match the local_data order

            pos = dict(zip(joint_names, p.positions))
            point["positions"] = [pos[j] for j in target_joints if j in pos]
            vel = dict(zip(joint_names, p.velocities))
            point["velocities"] = [vel[j] for j in target_joints if j in vel]

            acc = dict(zip(joint_names, p.accelerations))
            point["accelerations"] = [acc[j] for j in target_joints if j in acc]

            point["time_from_start"] = self._stamp_to_secs(p.time_from_start)
            points.append(point)

        traj["points"] = points
        logger.info(traj)
        
        self.overlaid_object.trajectory(
                self.chain_callback(self.joint_trajectory_action_result),
                traj)


########NEW FILE########
__FILENAME__ = waypoints
import logging; logger = logging.getLogger("morse." + __name__)

from morse.core.services import interruptible
from morse.middleware.ros_request_manager import ros_action
from morse.core.overlay import MorseOverlay
from morse.core import status

from morse.middleware.ros.helpers import ros_add_to_syspath
ros_add_to_syspath("move_base_msgs")
from move_base_msgs.msg import *

class WayPoint(MorseOverlay):

    def __init__(self, overlaid_object):
        # Call the constructor of the parent class
        MorseOverlay.__init__(self, overlaid_object)

    def move_base_on_completion(self, result):
        state, value = result

        logger.info("MoveBase completed! got value " + str(value))

        return state, MoveBaseResult()

    @interruptible
    @ros_action(type = MoveBaseAction)
    def move_base(self, req):
        logger.info("Going to (%d, %d)" % (req.target_pose.pose.position.x, req.target_pose.pose.position.y))

        self.overlaid_object.goto(
                self.chain_callback(self.move_base_on_completion),
                req.target_pose.pose.position.x,
                req.target_pose.pose.position.y,
                req.target_pose.pose.position.z)


########NEW FILE########
__FILENAME__ = platine
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Vector3
from morse.middleware.ros import ROSSubscriber

class Vector3Reader(ROSSubscriber):
    """ Subscribe to a Vector3 topic and set pan,tilt local data, according to
    the rotation axis (pan: y-axis, tilt: z-axis).
    """
    ros_class = Vector3

    def update(self, message):
        self.data["pan"] = message.y
        self.data["tilt"] = message.z

########NEW FILE########
__FILENAME__ = pose
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Pose, PoseStamped, PoseWithCovarianceStamped, Vector3, Quaternion
from morse.middleware.ros import ROSPublisher, ROSPublisherTF, mathutils

def get_orientation(self):
    """ Get the orientation from the local_data
    and return a ROS geometry_msgs.Quaternion
    """
    ros_quat = Quaternion()
    if 'orientation' in self.data:
        mathutils_quat = self.data['orientation']
    else:
        euler = mathutils.Euler((self.data['roll'],
                                 self.data['pitch'],
                                 self.data['yaw']))
        mathutils_quat = euler.to_quaternion()

    ros_quat.x = mathutils_quat.x
    ros_quat.y = mathutils_quat.y
    ros_quat.z = mathutils_quat.z
    ros_quat.w = mathutils_quat.w

    return ros_quat

def get_position(self):
    """ Get the position from the local_data
    and return a ROS geometry_msgs.Vector3
    """
    position = Vector3()
    if 'position' in self.data:
        position.x = self.data['position'][0]
        position.y = self.data['position'][1]
        position.z = self.data['position'][2]
    else:
        position.x = self.data['x']
        position.y = self.data['y']
        position.z = self.data['z']

    return position

def get_pose(self):
    """ Get the pose from the local_data
    and return a ROS geometry_msgs.Pose
    """
    pose = Pose()
    pose.position = get_position(self)
    pose.orientation = get_orientation(self)

    return pose


class PosePublisher(ROSPublisher):
    """ Publish the position and orientation of the robot as
    ROS geomeetry_msgs.Pose message.
    """
    ros_class = Pose

    def default(self, ci='unused'):
        if 'valid' not in self.data or self.data['valid']:
            pose = get_pose(self)
            self.publish(pose)


class PoseStampedPublisher(ROSPublisher):
    """ Publish the position and orientation of the robot
    as ROS geometry_msgs.PoseStamped message.
    """
    ros_class = PoseStamped
    default_frame_id = '/map'

    def default(self, ci='unused'):
        if 'valid' not in self.data or self.data['valid']:
            pose = PoseStamped()
            pose.header = self.get_ros_header()
            pose.pose = get_pose(self)
            self.publish(pose)


class PoseWithCovarianceStampedPublisher(ROSPublisher):
    """ Publish the position and orientation of the robot including the covariance. """
    ros_class = PoseWithCovarianceStamped
    default_frame_id = '/map'

    def default(self, ci='unused'):
        if 'valid' not in self.data or self.data['valid']:
            pose = PoseWithCovarianceStamped()
            pose.header = self.get_ros_header()
            pose.pose.pose = get_pose(self)
            if 'covariance_matrix' in self.data:
                pose.pose.covariance = self.data['covariance_matrix']
            self.publish(pose)


class TFPublisher(ROSPublisherTF):
    """ Publish the transformation between
    ``frame_id`` and ``child_frame_id`` args, default '/map' and
    '/base_link' through TF.
    """
    default_frame_id = '/map'

    def initialize(self):
        ROSPublisherTF.initialize(self)
        # store the frame ids
        self.child_frame_id = self.kwargs.get("child_frame_id", "/base_link")

        logger.info("Initialized the ROS TF publisher with frame_id '%s' " + \
                    "and child_frame_id '%s'", self.frame_id, self.child_frame_id)

    def default(self, ci='unused'):
        if 'valid' not in self.data or self.data['valid']:
            header = self.get_ros_header()
            # send current odometry transform
            self.sendTransform(get_position(self),
                               get_orientation(self),
                               header.stamp,
                               self.child_frame_id,
                               header.frame_id)

########NEW FILE########
__FILENAME__ = ptu_posture
import roslib; roslib.load_manifest('sensor_msgs')
from sensor_msgs.msg import JointState
from morse.middleware.ros import ROSPublisher

class JointStatePublisher(ROSPublisher):
    """ Publish the data of the posture sensor as a ROS JointState message """
    ros_class = JointState

    def default(self, ci='unused'):
        js = JointState()
        js.header = self.get_ros_header()
        js.name = ['head_pan_joint', 'head_tilt_joint']

        js.position = [
            self.data['pan'],
            self.data['tilt']
        ]

        self.publish(js)

########NEW FILE########
__FILENAME__ = read_asctec_ctrl_input
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('asctec_msgs')
import math
from asctec_msgs.msg import CtrlInput
from morse.middleware.ros import ROSSubscriber

class CtrlInputReader(ROSSubscriber):
    """ Subscribe to a CtrlInput topic and set pitch,roll,yaw,thrust local data. """
    ros_class = CtrlInput

    def update(self, message):
        max_angle = math.radians(30)
        max_yaw_rate = math.radians(90)
        yaw_deadband = 5
        asctec_scale = 2047

        roll = message.roll / asctec_scale * max_angle
        pitch = message.pitch / asctec_scale * max_angle
        if math.fabs(message.yaw) > yaw_deadband:
            yaw_rate = max_yaw_rate / asctec_scale * (message.yaw - math.copysign(yaw_deadband, message.yaw))
        else:
            yaw_rate = 0.0
        thrust = message.thrust / 4095
        self.data["pitch"] = pitch
        self.data["roll"] = roll
        self.data["yaw"] = yaw_rate
        self.data["thrust"] = thrust

        logger.debug("new RPY thrust setpoint: (% .2f % .2f % .3f %3f)",
                     math.degrees(roll), math.degrees(pitch), math.degrees(yaw_rate), message.thrust)

########NEW FILE########
__FILENAME__ = read_pose
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Pose, PoseStamped
from morse.middleware.ros import ROSSubscriber, mathutils

class PoseReader(ROSSubscriber):
    """ Subscribe to a Pose topic and set ``position`` as Vector and ``x``, ``y``, ``z``
    and ``orientation`` as Quaternion and ``roll``, ``pitch``, ``yaw`` local data.
    """
    ros_class = Pose

    def update(self, message):
        self.data["x"] = message.position.x
        self.data["y"] = message.position.y
        self.data["z"] = message.position.z
        self.data['position'] = mathutils.Vector((message.position.x, message.position.y, message.position.z))

        quaternion = mathutils.Quaternion((message.orientation.w,
                                           message.orientation.x,
                                           message.orientation.y,
                                           message.orientation.z))
        self.data['orientation'] = quaternion
        euler = quaternion.to_euler()
        self.data['roll'] = euler.x
        self.data['pitch'] = euler.y
        self.data['yaw'] = euler.z


class PoseStampedReader(ROSSubscriber):
    """ Subscribe to a PoseStamped topic and set ``position`` as Vector and ``x``, ``y``, ``z``
    and ``orientation`` as Quaternion and ``roll``, ``pitch``, ``yaw`` local data.
    """
    ros_class = PoseStamped

    def update(self, message):
        self.data["x"] = message.pose.position.x
        self.data["y"] = message.pose.position.y
        self.data["z"] = message.pose.position.z
        self.data['position'] = mathutils.Vector((message.pose.position.x, message.pose.position.y, message.pose.position.z))

        quaternion = mathutils.Quaternion((message.pose.orientation.w,
                                           message.pose.orientation.x,
                                           message.pose.orientation.y,
                                           message.pose.orientation.z))
        self.data['orientation'] = quaternion
        euler = quaternion.to_euler()
        self.data['roll'] = euler.x
        self.data['pitch'] = euler.y
        self.data['yaw'] = euler.z

########NEW FILE########
__FILENAME__ = semantic_camera
import logging; logger = logging.getLogger("morse." + __name__)
import json
import roslib; roslib.load_manifest('rospy'); roslib.load_manifest('std_msgs')
import rospy
from std_msgs.msg import String
from morse.middleware.ros import ROSPublisherTF
from morse.middleware.socket_datastream import MorseEncoder

class SemanticCameraPublisher(ROSPublisherTF):
    """ Publish the data of the semantic camera as JSON in a ROS String message.
    And send TF transform between '/map' and ``object.name``.
    """
    ros_class = String

    def initialize(self):
        if not self.component_instance.relative:
            self.default_frame_id = '/map'
        ROSPublisherTF.initialize(self)

    def default(self, ci='unused'):
        for obj in self.data['visible_objects']:
            # send tf-frame for every object
            self.sendTransform(obj['position'], obj['orientation'],
                               self.get_time(), str(obj['name']), self.frame_id)
        string = String()
        string.data = json.dumps(self.data['visible_objects'], cls=MorseEncoder)
        self.publish(string)


class SemanticCameraPublisherLisp(ROSPublisherTF):
    """ Publish the data of the semantic camera as a ROS String message,
    that contains a lisp-list (each field are separated by a space).

    This function was designed for the use with CRAM and the Adapto group.
    """
    ros_class = String

    def initialize(self):
        if not self.component_instance.relative:
            self.default_frame_id = '/map'
        ROSPublisherTF.initialize(self)

    def default(self, ci='unused'):
        string = String()
        string.data = "("
        for obj in self.data['visible_objects']:
            description = obj['description'] or '-'

            # send tf-frame for every object
            self.sendTransform(obj['position'], obj['orientation'],
                               self.get_time(), str(obj['name']), self.frame_id)

            # Build string from name, description, location and orientation in the global world frame
            string.data += "(" + str(obj['name']) + " " + description + " " + \
                           str(obj['position'].x) + " " + \
                           str(obj['position'].y) + " " + \
                           str(obj['position'].z) + " " + \
                           str(obj['orientation'].x) + " " + \
                           str(obj['orientation'].y) + " " + \
                           str(obj['orientation'].z) + " " + \
                           str(obj['orientation'].w) + ")"

        string.data += ")"
        self.publish(string)

########NEW FILE########
__FILENAME__ = tfMessage
"""autogenerated by genmsg_py from tfMessage.msg. Do not edit."""
import roslib.message
import struct

import geometry_msgs.msg
import std_msgs.msg
try:
    import genpy # ROS Fuerte
except ImportError:
    pass

class tfMessage(roslib.message.Message):
  _md5sum = "94810edda583a504dfda3829e70d7eec"
  _type = "tf/tfMessage"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """geometry_msgs/TransformStamped[] transforms

================================================================================
MSG: geometry_msgs/TransformStamped
# This expresses a transform from coordinate frame header.frame_id
# to the coordinate frame child_frame_id
#
# This message is mostly used by the 
# <a href="http://www.ros.org/wiki/tf">tf</a> package. 
# See it's documentation for more information.

Header header
string child_frame_id # the frame id of the child frame
Transform transform

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.secs: seconds (stamp_secs) since epoch
# * stamp.nsecs: nanoseconds since stamp_secs
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: geometry_msgs/Transform
# This represents the transform between two coordinate frames in free space.

Vector3 translation
Quaternion rotation

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

"""
  __slots__ = ['transforms']
  _slot_types = ['geometry_msgs/TransformStamped[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.
    
    The available fields are:
       transforms
    
    @param args: complete set of field values, in .msg order
    @param kwds: use keyword arguments corresponding to message field names
    to set specific fields. 
    """
    if args or kwds:
      super(tfMessage, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.transforms is None:
        self.transforms = []
    else:
      self.transforms = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    @param buff: buffer
    @type  buff: StringIO
    """
    try:
      length = len(self.transforms)
      buff.write(_struct_I.pack(length))
      for val1 in self.transforms:
        _v1 = val1.header
        buff.write(_struct_I.pack(_v1.seq))
        _v2 = _v1.stamp
        _x = _v2
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v1.frame_id.encode()
        length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.child_frame_id.encode()
        length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _v3 = val1.transform
        _v4 = _v3.translation
        _x = _v4
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v5 = _v3.rotation
        _x = _v5
        buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    @param str: byte array of serialized message
    @type  str: str
    """
    try:
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.transforms = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.TransformStamped()
        _v6 = val1.header
        start = end
        end += 4
        (_v6.seq,) = _struct_I.unpack(str[start:end])
        _v7 = _v6.stamp
        _x = _v7
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        _v6.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.child_frame_id = str[start:end]
        _v8 = val1.transform
        _v9 = _v8.translation
        _x = _v9
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v10 = _v8.rotation
        _x = _v10
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
        self.transforms.append(val1)
      return self
    except struct.error as e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    @param buff: buffer
    @type  buff: StringIO
    @param numpy: numpy python module
    @type  numpy module
    """
    try:
      length = len(self.transforms)
      buff.write(_struct_I.pack(length))
      for val1 in self.transforms:
        _v11 = val1.header
        buff.write(_struct_I.pack(_v11.seq))
        _v12 = _v11.stamp
        _x = _v12
        buff.write(_struct_2I.pack(_x.secs, _x.nsecs))
        _x = _v11.frame_id
        length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1.child_frame_id
        length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _v13 = val1.transform
        _v14 = _v13.translation
        _x = _v14
        buff.write(_struct_3d.pack(_x.x, _x.y, _x.z))
        _v15 = _v13.rotation
        _x = _v15
        buff.write(_struct_4d.pack(_x.x, _x.y, _x.z, _x.w))
    except struct.error as se: self._check_types(se)
    except TypeError as te: self._check_types(te)

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    @param str: byte array of serialized message
    @type  str: str
    @param numpy: numpy python module
    @type  numpy: module
    """
    try:
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.transforms = []
      for i in range(0, length):
        val1 = geometry_msgs.msg.TransformStamped()
        _v16 = val1.header
        start = end
        end += 4
        (_v16.seq,) = _struct_I.unpack(str[start:end])
        _v17 = _v16.stamp
        _x = _v17
        start = end
        end += 8
        (_x.secs, _x.nsecs,) = _struct_2I.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        _v16.frame_id = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        val1.child_frame_id = str[start:end]
        _v18 = val1.transform
        _v19 = _v18.translation
        _x = _v19
        start = end
        end += 24
        (_x.x, _x.y, _x.z,) = _struct_3d.unpack(str[start:end])
        _v20 = _v18.rotation
        _x = _v20
        start = end
        end += 32
        (_x.x, _x.y, _x.z, _x.w,) = _struct_4d.unpack(str[start:end])
        self.transforms.append(val1)
      return self
    except struct.error as e:
      raise roslib.message.DeserializationError(e) #most likely buffer underfill

try: 
  _struct_I = roslib.message.struct_I
except AttributeError:
  _struct_I = genpy.message.struct_I

_struct_4d = struct.Struct("<4d")
_struct_2I = struct.Struct("<2I")
_struct_3d = struct.Struct("<3d")

########NEW FILE########
__FILENAME__ = velocity
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import TwistStamped
from morse.middleware.ros import ROSPublisher

class TwistStampedPublisher(ROSPublisher):
    """ Publish the twist of the robot. """
    ros_class = TwistStamped
    default_frame_id = '/map'

    def default(self, ci='unused'):
        twist = TwistStamped()
        twist.header = self.get_ros_header()
        twist.twist.linear.x = self.data['world_linear_velocity'][0]
        twist.twist.linear.y = self.data['world_linear_velocity'][1]
        twist.twist.linear.z = self.data['world_linear_velocity'][2]
        twist.twist.angular.x = self.data['angular_velocity'][0]
        twist.twist.angular.y = self.data['angular_velocity'][1]
        twist.twist.angular.z = self.data['angular_velocity'][2]

        self.publish(twist)

########NEW FILE########
__FILENAME__ = video_camera
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('sensor_msgs'); roslib.load_manifest('rospy')
import rospy
from sensor_msgs.msg import Image, CameraInfo
from morse.middleware.ros import ROSPublisherTF

class VideoCameraPublisher(ROSPublisherTF):
    """ Publish the image from the Camera perspective.
    And send the intrinsic matrix information in a separate topic of type
    `sensor_msgs/CameraInfo <http://ros.org/wiki/rviz/DisplayTypes/Camera>`_.
    """
    ros_class = Image

    def initialize(self):
        self.kwargs['topic_suffix'] = '/image'
        ROSPublisherTF.initialize(self)
        # Generate a publisher for the CameraInfo
        self.topic_camera_info = rospy.Publisher(self.topic_name+'/camera_info', CameraInfo)

    def finalize(self):
        ROSPublisherTF.finalize(self)
        # Unregister the CameraInfo topic
        self.topic_camera_info.unregister()

    def default(self, ci='unused'):
        if not self.component_instance.capturing:
            return # press [Space] key to enable capturing

        image_local = self.data['image']

        image = Image()
        image.header = self.get_ros_header()
        image.height = self.component_instance.image_height
        image.width = self.component_instance.image_width
        image.encoding = 'rgba8'
        image.step = image.width * 4

        # VideoTexture.ImageRender implements the buffer interface
        image.data = bytes(image_local)

        # fill this 3 parameters to get correcty image with stereo camera
        Tx = 0
        Ty = 0
        R = [1, 0, 0, 0, 1, 0, 0, 0, 1]

        intrinsic = self.data['intrinsic_matrix']

        camera_info = CameraInfo()
        camera_info.header = image.header
        camera_info.height = image.height
        camera_info.width = image.width
        camera_info.distortion_model = 'plumb_bob'
        camera_info.D = [0]
        camera_info.K = [intrinsic[0][0], intrinsic[0][1], intrinsic[0][2],
                         intrinsic[1][0], intrinsic[1][1], intrinsic[1][2],
                         intrinsic[2][0], intrinsic[2][1], intrinsic[2][2]]
        camera_info.R = R
        camera_info.P = [intrinsic[0][0], intrinsic[0][1], intrinsic[0][2], Tx,
                         intrinsic[1][0], intrinsic[1][1], intrinsic[1][2], Ty,
                         intrinsic[2][0], intrinsic[2][1], intrinsic[2][2], 0]

        self.publish_with_robot_transform(image)
        self.topic_camera_info.publish(camera_info)

########NEW FILE########
__FILENAME__ = waypoint2D
import logging; logger = logging.getLogger("morse." + __name__)
import roslib; roslib.load_manifest('geometry_msgs')
from geometry_msgs.msg import Pose2D
from morse.middleware.ros import ROSSubscriber

class Pose2DReader(ROSSubscriber):
    """ Subscribe to a Pose2D topic and set ``x``, ``y``, ``z`` local data.
    This is designed to be used with the waypoint actuator.
    """
    ros_class = Pose2D

    def update(self, message):
        logger.debug("Received Pose2D: < %s, %s, %s > on topic %s"% \
                (message.x, message.y, message.theta, self.topic_name ))
        self.data["x"] = message.x
        self.data["y"] = message.y
        self.data["z"] = message.theta

########NEW FILE########
__FILENAME__ = ros_datastream
""" The ROS 'datastream manager' is responsible for ROS topic management in
MORSE.  It publishes simulated sensors and subscribes to topics controlling
simulated actuators.

As you may have noticed, the
:py:class:`morse.middleware.ros_datastream.ROSDatastreamManager` class is
actually empty: contrary to sockets, for instance, that always use direct JSON
serialization of MORSE Python objects, there is no generic way to encode/decode
ROS messages.

Thus, `morse/middleware/ros` contains one specific
serialization/deserialization class for each sensor/actuator. These classes
inherit either from :py:class:`morse.middleware.ros.abstract_ros.ROSPublisher`
or from:py:class:`morse.middleware.ros.abstract_ros.ROSSubscriber`.

If you want to add support for a new type of topic, you likely want to add it
as a new serialization implementation in this directory.

Note also that management of ROS services and ROS actions takes place in
`ros_request_manager.py`.
"""
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.datastream import DatastreamManager

class ROSDatastreamManager(DatastreamManager):
    """ Handle communication between Blender and ROS."""


########NEW FILE########
__FILENAME__ = ros_request_manager
import logging; logger = logging.getLogger("morse." + __name__)

import re
import threading
from functools import partial

from morse.core import status, services
from morse.core.request_manager import RequestManager

try:
    import roslib; roslib.load_manifest('rospy'); roslib.load_manifest('actionlib_msgs')
    import rospy
    import actionlib_msgs
except ImportError as ie:
    raise ImportError("Could not import some ROS modules."
                      " Check your ROS configuration is ok. Details:\n" + str(ie))

def ros_timer(callable_obj, frequency):
    # Shamelessly stolen from actionlib/action_server.py

    rate = rospy.Rate(frequency)

    rospy.logdebug("Starting timer")
    while not rospy.is_shutdown():
        try:
            rate.sleep()
            callable_obj()
        except rospy.exceptions.ROSInterruptException:
            rospy.logdebug("Sleep interrupted")


class RosAction:
    """ Implements a minimal action state machine.

    See http://www.ros.org/wiki/actionlib/DetailedDescription
    for the possible states.
    """
    def __init__(self, manager, component, action, rostype):

        self.manager = manager

        self._pending_goals = {}
        self.goal_lock = threading.Lock()

        self.component = component
        self._action = action

        # robot.001.sensor.001 = robot001.sensor001
        name = re.sub(r'\.([0-9]+)', r'\1', component)
        self.name = name.replace(".", "/") + "/" + action


        # Retrieves the types of the goal msg, feedback msg and result
        # msg (check roslib.message.Message for details)
        rosinstance = rostype()
        types = [type(getattr(rosinstance, t)) for t in rosinstance.__slots__]

        self.result_type = types[1]
        self.feedback_type = types[2]

        # Create the 5 topics required by an action server
        self.goal_topic = rospy.Subscriber(self.name + "/goal", types[0], self.on_goal)
        self.result_topic = rospy.Publisher(self.name + "/result", types[1])
        self.feedback_topic = rospy.Publisher(self.name + "/feedback", types[2])

        self.cancel_topic = rospy.Subscriber(self.name + "/cancel", actionlib_msgs.msg.GoalID, self.on_cancel)
        self.status_topic = rospy.Publisher(self.name + "/status", actionlib_msgs.msg.GoalStatusArray)

        # read the frequency with which to publish status from the parameter server
        # (taken from actionlib/action_server.py)
        self.status_frequency = rospy.get_param(self.name + "/status_frequency", 5.0)

        status_list_timeout = rospy.get_param(self.name + "/status_list_timeout", 5.0)
        self.status_list_timeout = rospy.Duration(status_list_timeout)

        self.status_timer = threading.Thread(None, ros_timer, None, (self._publish_status,self.status_frequency) )
        self.status_timer.start()

    def setstatus(self, id, status):

        with self.goal_lock:
            goal_id = self._pending_goals[id]['goal_id']
            goal_status = actionlib_msgs.msg.GoalStatus(goal_id = goal_id,
                                                   status = status)
            self._pending_goals[id]['status'] = goal_status

    def getstatus(self, id):

        with self.goal_lock:
            return self._pending_goals[id]['status'].status

    def set_internal_id(self, id, morse_id):

        with self.goal_lock:
            self._pending_goals[id]['morse_id'] = morse_id

    def manage_internal_id(self, morse_id):
        """ Check if this ROS action manager manages the given
        internal request ID.

        This is used by RosRequestManager to dispatch the service
        'on completion' event.
        """
        return self.get_id_from_internal_id(morse_id) is not None

    def get_id_from_internal_id(self, morse_id):

        with self.goal_lock:
            for id, goal in self._pending_goals.items():
                if goal.setdefault('morse_id') == morse_id:
                    return id

    def on_goal(self, goal):
        logger.info("Got a new goal for ROS action " + self.name)

        # Workaround for encoding issues (-> goal_id.id comes as bytes,
        # and must be converted to string before being reserialized)
        id = actionlib_msgs.msg.GoalID(id = goal.goal_id.id,
                                       stamp = goal.goal_id.stamp)

        with self.goal_lock:
            self._pending_goals[id.id] = {'goal_id': id, 'status': None}

        self.setstatus(id.id, actionlib_msgs.msg.GoalStatus.PENDING)

        is_sync, morse_id = self.manager.on_incoming_request(self.component, self._action, [goal.goal])

        # is_sync should be only True for ROS services!
        if is_sync:
            # TODO: clean terminated goals 'after a few seconds' (as
            # said by actionlib doc)
            self.setstatus(id.id, actionlib_msgs.msg.GoalStatus.REJECTED)
            logger.error("Internal error: This ROS action is bound to a "
                         "synchronous MORSE service! ({})".format(component_name + '.' + service_name))

        self.set_internal_id(id.id, morse_id)
        self.setstatus(id.id, actionlib_msgs.msg.GoalStatus.ACTIVE)
        logger.debug("Started action. GoalID=" + id.id + " MORSE ID=" + str(morse_id))

    def on_cancel(self, goal_id):
        logger.info("Got a cancel request for ROS action " + self.name)

        current_status = None

        try:
            current_status = self.getstatus(goal_id.id)
        except KeyError:
            # Unknown GoalID...? skipping this cancel request.
            logger.info("I can not find any goal matching this cancel request. Skipping it.")
            return

        if current_status == actionlib_msgs.msg.GoalStatus.PENDING:
            self.setstatus(goal_id.id, actionlib_msgs.msg.GoalStatus.RECALLING)
        else: #current status = ACTIVE (or smth else...)
            self.setstatus(goal_id.id, actionlib_msgs.msg.GoalStatus.PREEMPTING)
            self.manager.abort_request(self._pending_goals[goal_id.id]['morse_id'])

    def on_result(self, morse_id, state, result):

        logger.info("Got a result for action " + self.name + ": " + str(state) + " " + str(result))
        id = self.get_id_from_internal_id(morse_id)

        if state == status.PREEMPTED:
            logger.info("The action " + self.name + " has been preempted. "
                         "Reporting it to ROS system.")
            self.setstatus(id, actionlib_msgs.msg.GoalStatus.PREEMPTED)
        if state == status.FAILED:
            logger.info("The action " + self.name + " has been aborted. "
                         "Reporting it to ROS system.")
            self.setstatus(id, actionlib_msgs.msg.GoalStatus.ABORTED)
        if state == status.SUCCESS:
            logger.debug("The action " + self.name + " has succeeded. Reporting"
                         " it to ROS system and publishing results.")
            self.setstatus(id, actionlib_msgs.msg.GoalStatus.SUCCEEDED)

        self.publish_result(id, result)

    def publish_result(self, goal_id, result):

        goal_status = None

        with self.goal_lock:
            goal_status = self._pending_goals[goal_id]['status']

        res = self.result_type(status = goal_status,
                               result = result)
        
        self.result_topic.publish(res)


    def _publish_status(self):
        """ This private method is called asynchronously to update the status of pending goals.
        """

        status_array = actionlib_msgs.msg.GoalStatusArray()

        with self.goal_lock:
            for goal in self._pending_goals.values():
                if goal['status']:
                    status_array.status_list.append(goal['status'])

        status_array.header.stamp = rospy.Time.now()
        self.status_topic.publish(status_array)

class RosRequestManager(RequestManager):

    def __init__(self):
        RequestManager.__init__(self)

        self._services = {}
        self._actions = []

    def __str__(self):
        return "ROS Request Manager"

    def initialization(self):

        # Init MORSE-node in ROS
        rospy.init_node('morse', log_level = rospy.DEBUG, disable_signals=True)
        logger.info("ROS node 'morse' successfully created.")

        return True

    def finalization(self):
        # do not shutdown ros since we cant restart it later on (see rospy).
        return True

    def register_ros_action(self, method, component_name, service_name):

        rostype = None
        try:
            rostype = method._ros_action_type # Is it a ROS action?
            logger.info(component_name + "." + service_name + " is a ROS action of type " + str(rostype))
        except AttributeError:
            logger.info(component_name + "." + service_name + " has no ROS-specific action type. Skipping it.")
            return False

        self._actions.append(RosAction(self, component_name, service_name, rostype))

        logger.info("Created new ROS action server for {}.{}".format(
                                                    component_name,
                                                    service_name))

        return True


    def register_ros_service(self, method, component_name, service_name):

        rostype = None
        try:
            rostype = method._ros_service_type # Is it a ROS service?
            logger.info(component_name + "." + service_name + " is a ROS service of type " + str(rostype))
        except AttributeError:
            logger.info(component_name + "." + service_name + " has no ROS-specific service type. Skipping it.")
            return False

        cb = self.add_ros_handler(component_name, service_name)

        # robot.001.sensor.001 = robot001.sensor001
        name = re.sub(r'\.([0-9]+)', r'\1', component_name)
        _service_name = name.replace(".", "/") + "/" + service_name

        try:
            s = rospy.Service(_service_name, rostype, cb)
            logger.info("Created new ROS service for %s.%s" % \
                         (component_name, service_name))
        except Exception as e:
            logger.warning("Could not initiate rospy.Service\n" + str(e))

        return True
    
    def post_registration(self, component_name, service_name, is_async):
        """ We create here ROS services (for *synchronous* services) and ROS
        actions (for *asynchronous* services).

        In order not to interfere with neither ROS own service wrapping mechanism or
        MORSE service invokation mechanisms, we create here, 'on the fly', handlers 
        for each service exposed through ROS.
        
        ROS requires type for the services/actions. Those can be set with the
        :py:meth:`ros_action` and :py:meth:`ros_service` decorators.
        If none is set, the action/service is discarded.
        """
        
        rostype = None
        
        # TODO: I access here an internal member of the parent class to 
        # retrieve the ROS type, if set. _services should probably be 
        # 'officially' exposed
        method, is_async = self._services[(component_name, service_name)]
        
        if is_async:
            return self.register_ros_action(method, component_name, service_name)
        else:
            return self.register_ros_service(method, component_name, service_name)

    def add_ros_handler(self, component_name, service_name):
        """ Dynamically creates custom ROS->MORSE dispatchers
        for ROS *services* only.

        ROS actions are dealt with in the :py:class:`RosAction` class.
        """

        def innermethod(request):
            # TODO: when this will be actually called? If ROS service
            # management lives in its own thread, it can be basically
            # called at any time, which is dangerous.

            # The request type is generated from the .srv definition.
            # roslib.message.Message defines the method __getstate__()
            # the retrieve a 'flat' view of all parameters.
            args = request.__getstate__()

            logger.info("ROS->MORSE dispatcher for " + service_name + \
                         " got incoming request: " + str(args))
            is_sync, value = self.on_incoming_request(component_name, service_name, args)

            # is_sync should be always True for ROS services!
            if not is_sync:
                logger.error("Internal error: This ROS "
                             "service is bound to an asynchronous MORSE"
                             " service! ({})".format(component_name + '.' + service_name))
                raise rospy.service.ServiceException("MORSE Internal error! Check MORSE logs for details.")


            state, result = value

            if state == status.SUCCESS:
                # Here, we 'hope' that the return value of the MORSE
                # service is a valid dataset to construct the
                # ServiceResponse expected by ROS
                return result,
            else:
                # failure!
                raise rospy.service.ServiceException(result)

        innermethod.__doc__ = "This method is invoked directly by MORSE when " +\
        "a new service request comes in. This handler simply redispatch it to " +\
        "MORSE own service invokation system.\n\n" +\
        "The method takes a ROS ServiceRequest as unique parameter, and must " +\
        "return a ROS ServiceResponse"

        innermethod.__name__ = "_" + service_name + "_ros_handler"
        
        logger.debug("Created new ROS->MORSE dispatcher for service {}.{}".format(
                                                    component_name,
                                                    service_name))
        return innermethod

    def on_service_completion(self, request_id, result):
        # First, figure out which 'ROSAction' manages this request id:
        manager = None

        for action in self._actions:
            if action.manage_internal_id(request_id):
                manager = action
                break

        if manager is None:
            logger.error("A ROS action call has been lost! Nobody manage request " + request_id)

        # Then, dispatch the 'on completion' event.
        status, value = result
        manager.on_result(request_id, status, value)

    def main(self):
        pass

def ros_action(fn = None, type = None, name = None):
    """ The @ros_action decorator.
    
    This decorator is very similar to the standard 
    :py:meth:`morse.core.services.async_service` decorator. It sets a 
    class method to be a asynchronous service, exposed as a ROS action of
    type `type`.
    
    This decorator can only be used on methods in classes inheriting from 
    :py:class:`morse.core.object.Object`.
    
    :param callable fn: [automatically set by Python to point to the
      decorated function] 
    :param class type: you MUST set this parameter to define the
      type of the ROS action.
    :param string name: by default, the name of the service is the name
      of the method. You can override it by setting the 'name' argument.
      Your ROS action will appear as /component_instance/<name>/...
    """
    if not type:
        logger.error("You must provide a valid ROS action type when using the " + \
        "@ros_action decorator, e.g. @ros_action(type=MyRosAction). Action ignored.")
        return
    
    if not hasattr(fn, "__call__"):
        return partial(ros_action, type = type, name = name)
        
    fn._ros_action_type = type
    return services.service(fn, component = None, name = name, async = True)
        

def ros_service(fn = None, type = None, component = None, name = None):
    """ The @ros_service decorator.
    
    This decorator is very similar to the standard 
    :py:meth:`morse.core.services.service` decorator. It sets a free function or
    class method to be a (synchronous) service, exposed as a ROS service of
    type `type`.

    This decorator works both with free function and for methods in
    classes inheriting from
    :py:class:`morse.core.object.Object`. In the former case,
    you must specify a component (your service will belong to this
    namespace), in the later case, it is automatically set to the name
    of the corresponding MORSE component.

    :param callable fn: [automatically set by Python to point to the
      decorated function] 
    :param class type: you MUST set this parameter to define the
      type of the ROS action.
    :param string component: you MUST set this parameter to define the
      name of the component which export the service ONLY for free
      functions. Cf explanation above.
    :param string name: by default, the name of the service is the name
      of the method. You can override it by setting the 'name' argument.
      Your ROS service will appear as /<name>
    """    
    if not type:
        logger.error("You must provide a valid ROS action type when using the " + \
        "@ros_action decorator, e.g. @ros_action(type=MyRosAction). Service ignored.")
        return
        
    if not hasattr(fn, "__call__"):
        return partial(ros_service, type = type, component = component, name = name)

    fn._ros_service_type = type
    return services.service(fn, component = component, name = name, async = False)

########NEW FILE########
__FILENAME__ = depth_camera
import sys
import json
import base64
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.socket_datastream import SocketPublisher

class DepthCameraPublisher(SocketPublisher):
    """
    Data of the DepthCamera gets JSON encoded to send via sockets
    """

    _type_name = 'a JSON-Encoded message for the DepthCamera'

    def encode(self):
        if not self.component_instance.capturing:
            return bytes() # press [Space] key to enable capturing

        points = self.data['points']

        if sys.version_info < (3,4):
            points = bytes( points )

        data = base64.b64encode( points ).decode() # get string
        intrinsic = [ list(vec) for vec in self.data['intrinsic_matrix'] ]

        res = {
            'timestamp': self.data['timestamp'],
            'height':    self.component_instance.image_height,
            'width':     self.component_instance.image_width,
            'points':    data,
            'intrinsic_matrix': intrinsic,
        }

        return (json.dumps(res) + '\n').encode()

########NEW FILE########
__FILENAME__ = jointstate
import logging; logger = logging.getLogger("morse." + __name__)
import json
from morse.middleware.socket_datastream import SocketPublisher

def fill_missing_pr2_joints(joints):

    pr2_joints = {
                'laser_tilt_mount_joint':0.0, 
                'fl_caster_rotation_joint':0.0, 
                'fl_caster_l_wheel_joint':0.0, 
                'fl_caster_r_wheel_joint':0.0, 
                'fr_caster_rotation_joint':0.0, 
                'fr_caster_l_wheel_joint':0.0, 
                'fr_caster_r_wheel_joint':0.0, 
                'bl_caster_rotation_joint':0.0, 
                'bl_caster_l_wheel_joint':0.0, 
                'bl_caster_r_wheel_joint':0.0, 
                'br_caster_rotation_joint':0.0, 
                'br_caster_l_wheel_joint':0.0, 
                'br_caster_r_wheel_joint':0.0, 
                'r_gripper_motor_slider_joint':0.0, 
                'r_gripper_motor_screw_joint':0.0, 
                'r_gripper_l_finger_joint':0.0, 
                'r_gripper_r_finger_joint':0.0, 
                'r_gripper_l_finger_tip_joint':0.0, 
                'r_gripper_r_finger_tip_joint':0.0, 
                'r_gripper_joint':0.0, 
                'l_gripper_motor_slider_joint':0.0, 
                'l_gripper_motor_screw_joint':0.0, 
                'l_gripper_l_finger_joint':0.0, 
                'l_gripper_r_finger_joint':0.0, 
                'l_gripper_l_finger_tip_joint':0.0, 
                'l_gripper_r_finger_tip_joint':0.0, 
                'l_gripper_joint':0.0, 
                'torso_lift_joint':0.0, 
                'torso_lift_motor_screw_joint':0.0, 
                'head_pan_joint':0.0, 
                'head_tilt_joint':0.0, 
                'l_shoulder_pan_joint':0.0, 
                'l_shoulder_lift_joint':0.0, 
                'l_upper_arm_roll_joint':0.0, 
                'l_elbow_flex_joint':0.0, 
                'l_forearm_roll_joint':0.0, 
                'l_wrist_flex_joint':0.0, 
                'l_wrist_roll_joint':0.0, 
                'r_shoulder_pan_joint':0.0, 
                'r_shoulder_lift_joint':0.0, 
                'r_upper_arm_roll_joint':0.0, 
                'r_elbow_flex_joint':0.0, 
                'r_forearm_roll_joint':0.0, 
                'r_wrist_flex_joint':0.0, 
                'r_wrist_roll_joint':0.0}

    for k, v in joints.items():
        if k != 'timestamp':
            for name, value in v.items():
                pr2_joints[name] = value

    return pr2_joints

class PR2JointStatePublisher(SocketPublisher):

    _type_name = "a JSON dict containing the values of each of the Willow Garage's PR2 joints"

    def encode(self):
        joints =  fill_missing_pr2_joints(self.component_instance.local_data)
        return (json.dumps(joints) + '\n').encode()

########NEW FILE########
__FILENAME__ = video_camera
import sys
import json
import base64
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.socket_datastream import SocketPublisher

class VideoCameraPublisher(SocketPublisher):
    """ Publish a base64 encoded RGBA image """

    _type_name = 'base64 encoded RGBA image'

    def process(self, image):
        if sys.version_info < (3,4):
            return bytes( image )
        else:
            # Python 3.4 base64.b64encode supports memoryview, which is faster
            # TODO Blender 2.7 ? else: image = memoryview( image )
            return image

    def encode(self):
        if not self.component_instance.capturing:
            return bytes() # press [Space] key to enable capturing

        image = self.process( self.data['image'] )

        data = base64.b64encode( image ).decode() # get string
        intrinsic = [ list(vec) for vec in self.data['intrinsic_matrix'] ]

        res = {
            'timestamp': self.data['timestamp'],
            'height':    self.component_instance.image_height,
            'width':     self.component_instance.image_width,
            'image':     data,
            'intrinsic_matrix': intrinsic,
        }

        return (json.dumps(res) + '\n').encode()

class Video8uPublisher(VideoCameraPublisher):
    """ Publish a base64 encoded grayscale (8U) image """

    _type_name = 'base64 encoded grayscale (8U) image'

    def process(self, image):
        memv = memoryview( image )
        # Grayscale model used for HDTV developed by the ATSC (Wikipedia)
        i8u = [ int(0.2126 * memv[index] +
                    0.7152 * memv[index + 1] +
                    0.0722 * memv[index + 2] )
                for index in range(0, len(memv), 4) ]
        return bytearray( i8u )

########NEW FILE########
__FILENAME__ = socket_datastream
import logging; logger = logging.getLogger("morse." + __name__)
import socket
import select
import json
import errno
from morse.core.datastream import DatastreamManager
from morse.helpers.transformation import Transformation3d
from morse.middleware import AbstractDatastream
from morse.core import services
from morse.core.exceptions import MorseRPCInvokationError

try:
    import mathutils
except ImportError:
    # running outside Blender
    mathutils = None

class MorseEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, mathutils.Vector):
            return obj[:]
        if isinstance(obj, mathutils.Matrix):
            # obj[:][:] gives list(mathutils.Vector)
            return [list(vec) for vec in obj]
        if isinstance(obj, mathutils.Quaternion):
            return {'x' : obj.x, 'y': obj.y, 'z': obj.z, 'w': obj.w }
        if isinstance(obj, mathutils.Euler):
            return {'yaw': obj.z, 'pitch': obj.y, 'roll': obj.x }
        if isinstance(obj, Transformation3d):
            return {'x': obj.x, 'y': obj.y, 'z': obj.z,
                    'yaw': obj.yaw, 'pitch': obj.pitch, 'roll': obj.roll }
        return json.JSONEncoder.default(self, obj)

class SocketServ(AbstractDatastream):

    def initialize(self):
        # List of socket clients
        self._client_sockets = []
        self._message_size = 4096

        self._server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self._server.bind(('', self.kwargs['port']))
        self._server.listen(1)

        logger.info("Socket Mw Server now listening on port " + str(self.kwargs['port']) + \
                    " for component " + str(self.component_name) + ".")

    def finalize(self):
        """ Terminate the ports used to accept requests """
        if self._client_sockets:
            logger.info("Closing client sockets...")
            for s in self._client_sockets:
                s.close()

        if self._server:
            try:
                logger.info("Shutting down connections to server...")
                self._server.shutdown(socket.SHUT_RDWR)
            except socket.error as err_info:
                # ignore exception raised on OSX for closed sockets
                if err_info.errno != errno.ENOTCONN:
                    raise
            logger.info("Closing socket server...")
            self._server.close()

    def close_socket(self, sock):
        try:
            self._client_sockets.remove(sock)
            sock.close()
        except socket.error as error_info:
            logger.warning("Socket error catched while closing: " + str(error_info))
            del self._server
        except:
            pass

class SocketPublisher(SocketServ):

    _type_name = "straight JSON serialization"

    def default(self, ci='unused'):
        sockets = self._client_sockets + [self._server]

        try:
            inputready, outputready, _ = select.select(sockets, sockets, [], 0)
        except select.error:
            pass
        except socket.error:
            pass

        if self._server in inputready:
            sock, _ = self._server.accept()
            self._client_sockets.append(sock)

        if outputready:
            message = self.encode()
            for o in outputready:
                try:
                    o.send(message)
                except socket.error:
                    self.close_socket(o)

    def encode(self):
        js = json.dumps(self.component_instance.local_data, cls=MorseEncoder)
        return (js + '\n').encode()

class SocketReader(SocketServ):

    _type_name = "straight JSON deserialization"

    def default(self, ci='unused'):
        sockets = self._client_sockets + [self._server]
        try:
            inputready, outputready, exceptready = select.select(sockets, [], [], 0)
        except select.error:
            pass
        except socket.error:
            pass

        for i in inputready:
            if i == self._server:
                sock, addr = self._server.accept()
                logger.debug("New client connected to %s datastream" % self.component_name)
                if self._client_sockets:
                    logger.warning("More than one client trying to write on %s datastream!!" % self.component_name)
                self._client_sockets.append(sock)
            else:
                try:
                    buf = []
                    msg = ""
                    full_msg = False
                    while not full_msg:
                        msg = i.recv(self._message_size).decode()
                        logger.debug("received msg %s" % msg)
                        if not msg: # client disconnected
                            self.close_socket(i)
                        else:
                            buf.append(msg)
                            full_msg = (len(msg) != self._message_size)
                    if not msg.endswith('\n'):
                        logger.error("Malformed message on socket datastream "+\
                                "(no linefeed at the end): <%s>" % msg)
                        continue
                    msg = ''.join(buf).rstrip("\n").split("\n")
                    logger.debug("received msg %s" % msg)
                    if len(msg)>1:
                        logger.warning("Messages missed on socket datastream! <%s>" % msg[:-1])
                    self.component_instance.local_data = self.decode(msg[-1]) # keep only the last msg if we got several in row
                except socket.error as detail:
                    self.close_socket(i)

    def decode(self, msg):
        return json.loads(msg)


class SocketDatastreamManager(DatastreamManager):
    """ External communication using sockets. """

    def __init__(self):
        """ Initialize the socket connections """
        # Call the constructor of the parent class
        DatastreamManager.__init__(self)

        # port -> MorseSocketServ
        self._server_dict = {}

        # component name (string)  -> Port (int)
        self._component_nameservice = {}

        # Base port
        self._base_port = 60000

        # Register two special services in the socket service manager:

        # TODO To use a new special component instead of 'simulation',
        # uncomment the line :-)
        # blenderapi.persistantstorage().morse_services.register_request_manager_mapping("streams", "SocketRequestManager")
        services.do_service_registration(self.list_streams, 'simulation')
        services.do_service_registration(self.get_stream_port, 'simulation')
        services.do_service_registration(self.get_all_stream_ports, 'simulation')

    def list_streams(self):
        """ List all publish streams.
        """
        return list(self._component_nameservice.keys())

    def get_stream_port(self, name):
        """ Get stream port for stream name.
        """
        port = -1
        try:
            port = self._component_nameservice[name]
        except KeyError:
            pass
        
        if port < 0:
            raise MorseRPCInvokationError("Stream unavailable for component %s" % name)
        
        return port

    def get_all_stream_ports(self):
        """ Get stream ports for all streams.
        """
        return self._component_nameservice

    def register_component(self, component_name, component_instance, mw_data):
        """ Open the port used to communicate by the specified component.
        """
        register_success = False
        must_inc_base_port = False

        if not 'port' in mw_data[2]:
            must_inc_base_port = True
            mw_data[2]['port'] = self._base_port

        while not register_success:
            try:
                # Create a socket server for this component
                serv = DatastreamManager.register_component(self, component_name,
                                                 component_instance, mw_data)
                register_success = True
            except socket.error as error_info:
                if error_info.errno ==  errno.EADDRINUSE:
                    mw_data[2]['port'] += 1
                    if must_inc_base_port:
                        self._base_port += 1
                else:
                    raise

        self._server_dict[mw_data[2]['port']] = serv
        self._component_nameservice[component_name] = mw_data[2]['port']
        if must_inc_base_port:
            self._base_port += 1

########NEW FILE########
__FILENAME__ = socket_request_manager
import logging; logger = logging.getLogger("morse." + __name__)
import socket
import select
import json

from morse.core.request_manager import RequestManager, MorseRPCInvokationError
from morse.core import status

SERVER_HOST = '' #all available interfaces
SERVER_PORT = 4000
MAX_TRIES = 10 # Number of alternative ports to try if the default is already busy

class SocketRequestManager(RequestManager):
    """Implements services to control the MORSE simulator over
    raw ASCII sockets.

    The syntax of requests is:

    >>> id component_name service [params with Python syntax]

    ``id`` is an identifier set by the client to conveniently identify
    the request. It must be less that 80 chars in [a-zA-Z0-9].

    The server answers:

    >>> id status result_in_python|error_msg

    ``status`` is one of the constants defined in :py:mod:`morse.core.status`.

    """

    def __str__(self):
        return "Socket service manager"

    def initialization(self):
        global SERVER_PORT
        self._client_sockets = []
        
        # For asynchronous request, this holds the mapping between a
        # request_id and the socket which requested it.
        self._pending_sockets = {}

        # Stores for each socket client the pending results to write
        # back.
        self._results_to_output = {}

        self._server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        port_ok = False
        for i in range(MAX_TRIES):
            try:
                self._server.bind((SERVER_HOST, SERVER_PORT))
                self._server.listen(1)
                port_ok = True
                break
            except socket.error as msg:
                SERVER_PORT += 1

        if not port_ok:
            logger.error("Couldn't bind the socket server! Port busy?")
            self._server.close()
            self._server = None
            return False

        logger.info("Socket service manager now listening on port " + str(SERVER_PORT) + ".")

        return True

    def finalization(self):
        """ Terminate the ports used to accept requests """
        if self._client_sockets:
            logger.info("Closing client sockets...")
            for s in self._client_sockets:
                s.close()

        if self._server:
            logger.info("Shutting down connections to server...")
            self._server.shutdown(socket.SHUT_RDWR)
            logger.info("Closing socket server...")
            self._server.close()
            del self._server

        return True


    def on_service_completion(self, request_id, results):

        s = None

        try:
            s, id = self._pending_sockets[request_id]
            del self._pending_sockets[request_id]
        except KeyError:
            logger.info(str(self) + ": ERROR: I can not find the socket which requested " + str(request_id))
            return

        if s in self._results_to_output:
            self._results_to_output[s].append((id, results))
        else:
            self._results_to_output[s] = [(id, results)]

    def post_registration(self, component, service, is_async):
        return True

    def main(self):
        
        sockets = self._client_sockets + [self._server]

        try:
            inputready, outputready, exceptready = select.select(sockets, sockets, [], 0) #timeout = 0 : Never block, just poll
        except select.error:
            pass
        except socket.error:
            pass

        for i in inputready:
            if i == self._server:
                sock, addr = self._server.accept()

                logger.info("Accepted new service connection from " + str(addr))
                self._client_sockets.append(sock)

            else:
                raw = i.recv(4096)
                if not raw:
                    # an empty read means that the remote host has
                    # disconnected itself
                    logger.debug("Socket closed by client! Closing it on my side.")
                    i.close()
                    self._client_sockets.remove(i)
                    continue
                raw = raw.decode()
                assert(raw[-1] == '\n')
                for req in raw[:-1].split('\n'):
                    req = req.strip()

                    component = service = "undefined"

                    try:
                        try:
                            id, req = req.split(None, 1)
                        except ValueError: # Request contains < 2 tokens.
                            id = req
                            raise MorseRPCInvokationError("Malformed request! ")

                        id = id.strip()

                        logger.info("Got '" + req + "' (id = " + id + ") from " + str(i))

                        if len(req.split()) == 1 and req in ["cancel"]:
                            # Aborting a running request!
                            for internal_id, user_id in self._pending_sockets.items():
                                if user_id[1] == id:
                                    self.abort_request(internal_id)

                        else:
                            component, service, params = self._parse_request(req)

                            # on_incoming_request returns either 
                            #(True, result) if it's a synchronous
                            # request that has been immediately executed, or
                            # (False, request_id) if it's an asynchronous request whose
                            # termination will be notified via
                            # on_service_completion.
                            is_sync, value = self.on_incoming_request(component, service, params)

                            if is_sync:
                                if i in self._results_to_output:
                                    self._results_to_output[i].append((id, value))
                                else:
                                    self._results_to_output[i] = [(id, value)]
                            else:
                                # Stores the mapping request/socket to notify
                                # the right socket when the service completes.
                                # (cf :py:meth:on_service_completion)
                                # Here, 'value' is the internal request id while
                                # 'id' is the id used by the socket client.
                                self._pending_sockets[value] = (i, id)


                    except MorseRPCInvokationError as e:
                        if i in self._results_to_output:
                            self._results_to_output[i].append((id, (status.FAILED, e.value)))
                        else:
                            self._results_to_output[i] = [(id, (status.FAILED, e.value))]

        if self._results_to_output:
            for o in outputready:
                if o in self._results_to_output:
                    for r in self._results_to_output[o]:
                        return_value = None
                        try:
                            if r[1][1]:
                                return_value = json.dumps(r[1][1])
                        except TypeError as te:
                            logger.error("Error while serializing a service return value to JSON!\n" +\
                                    "Details:" + te.value)
                        response = "%s %s%s" % (r[0], r[1][0], (" " + return_value) if return_value else "")
                        try:
                            o.send((response + "\n").encode())
                            logger.info("Sent back " + response + " to " + str(o))
                        except socket.error:
                            logger.warning("It seems that a socket client left while I was sending stuff to it. Closing the socket.")
                            o.close()
                            self._client_sockets.remove(o)

                    del self._results_to_output[o]


    def _parse_request(self, req):
        """
        Parse the incoming request.
        """

        tokens = req.split(None, 2)

        if len(tokens) < 1 or len(tokens) > 3:
            raise MorseRPCInvokationError("Malformed request: at least 3 values and at most 4 are expected (id, component, service, [params])")

        if len(tokens) == 2:
            component, service = tokens
            p = None
        else:
            component, service, params = tokens
            
            params = params.strip()

            if params:
                try:
                    p =  json.loads(params)
                except (NameError, SyntaxError, ValueError) as e:
                    raise MorseRPCInvokationError("Invalid request syntax: error while parsing the parameters: <%s>. %s" % (params, str(e)))
            else:
                p = None
        return component, service, p

########NEW FILE########
__FILENAME__ = text_datastream
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
import re
from morse.core.datastream import *
from morse.middleware.abstract_datastream import AbstractDatastream

class BasePublisher(AbstractDatastream):
    def initialize(self):
        self.filename = self._get_filename()
        self.file = open(self.filename, 'wb')
        self.index = 0

        line = self.header()
        self.file.write(line.encode())

    def finalize(self):
        self.file.close()

    def _get_filename(self):
        if 'file' in self.kwargs:
            return self.kwargs['file']
        else:
            filename = re.sub(r'\.([0-9]+)', r'\1', self.component_name)
            return filename + '.txt'

    def default(self, ci):
        line = self.encode_data()
        self.index += 1
        self.file.write(line.encode())
        self.file.flush()

    def header(self):
        return ""

    def encode_data(self):
        return ""

class Publisher(BasePublisher):

    _type_name = "key = value format with timestamp and index value"
    def header(self):
        lines = ['ROBOT %s || SENSOR %s\n' % (self.component_instance.robot_parent.name(), self.component_name),
                 '(distance, globalVector(3), localVector(3))\n',
                 repr(self.component_instance.relative_position) + '\n\n']
        return ''.join(lines)

    def encode_data(self):
        parent_position = self.component_instance.robot_parent.position_3d
        lines = ['==> Data at X,Y,Z: [%.6f %.6f %.6f]'
                 'yaw,pitch,roll: [%.6f %.6f %.6f] | index %d | time %.2f\n'
                 % (parent_position.x, parent_position.y, parent_position.z,
                    parent_position.yaw, parent_position.pitch, parent_position.roll,
                    self.index, blenderapi.persistantstorage().current_time)]

        for variable, data in self.data.items():
            if isinstance(data, float):
                lines.append("\t%s = %.6f\n" % (variable, data))
            else:
                lines.append("\t%s = %s\n" % (variable, repr(data)))
        return ''.join(lines)

class CSVPublisher(BasePublisher):
    _type_name = "CSV like : values separated by semi-column"

    def header(self):
        lines = ['ROBOT %s || SENSOR %s\n' % (self.component_instance.robot_parent.name(), self.component_name),
                 '(distance, globalVector(3), localVector(3))\n',
                 repr(self.component_instance.relative_position) + '\n\n']

        return ''.join(lines)

    def encode_data(self):
        lines = []
        for variable, data in self.data.items():
            if isinstance(data, float):
                lines.append("%.6f;" % data)
            else:
                lines.append("%s;" % repr(data))
        return ''.join(lines) + '\n'

class TextDatastreamManager(DatastreamManager):
    """ Produce text files as output for the components """


########NEW FILE########
__FILENAME__ = laserscanner
import logging; logger = logging.getLogger("morse." + __name__)
from morse.middleware.yarp_datastream import YarpPublisher

class YarpLaserScannerPublisher(YarpPublisher):
    def encode(self, bottle):
        self.encode_message(bottle, self.data['point_list'],
                           self.component_name)

class YarpLaserScannerDistancePublisher(YarpPublisher):
    def encode(self, bottle):
        self.encode_message(bottle, self.data['range_list'],
                                   self.component_name)



########NEW FILE########
__FILENAME__ = yarp_json
import logging; logger = logging.getLogger("morse." + __name__)
import json
from collections import OrderedDict
from morse.middleware.yarp_datastream import YarpPublisher, YarpReader
from morse.middleware.socket_datastream import MorseEncoder


class YarpJsonPublisher(YarpPublisher):
    _type_name = "json encoded data in yarp::bottle"
    def encode(self, bottle):
        js = json.dumps(self.data, cls=MorseEncoder)
        bottle.addString(js)

class YarpJsonReader(YarpReader):
    def default(self, ci):
        message_bottle = self.port.read(False)

        if message_bottle is not None:
            message_data = message_bottle.get(0).toString()

            # Deserialise the data directly into a temporary ordered dictionary
            json_dict = json.loads(message_data, object_pairs_hook=OrderedDict)
            # Fill the component's 'local_data' dictionary,
            #  while also casting to the correct data types
            for variable, data in self.data.items():
                if isinstance(data, int):
                    self.data[variable] = int(json_dict[variable])
                elif isinstance(data, float):
                    self.data[variable] = float(json_dict[variable])
                elif isinstance(data, str):
                    self.data[variable] = json_dict[variable]
                else:
                    logger.error("Unknown data type at 'read_json_data'")

class YarpJsonWaypointReader(YarpReader):

    def default(self, ci):
        """
        Read a destination waypoint in the format used for ROSACE

        The structure read by JSON is expected to have two properties:
        point: structure with 'x', 'y', 'z'
        radius: the tolerance around those points
        """
        message_bottle = self.port.read(False)
        if message_bottle is not None:
            message_data = message_bottle.get(0).toString()

            # Deserialise the data directly into a temporary ordered dictionary
            json_dict = json.loads(message_data, object_pairs_hook=OrderedDict)
            point = json_dict['point']
            tolerance = json_dict['radius']
            self.data['x'] = float(point['x'])
            self.data['y'] = float(point['y'])
            self.data['z'] = float(point['z'])
            self.data['tolerance'] = float(tolerance)
            self.data['speed'] = 3.0


########NEW FILE########
__FILENAME__ = yarp_datastream
import logging; logger = logging.getLogger("morse." + __name__)
import sys
import re
import yarp
import mathutils
from morse.helpers.transformation import Transformation3d
from morse.middleware.abstract_datastream import AbstractDatastream
from morse.core.datastream import *

class YarpPort(AbstractDatastream):
    def initialize(self, port_creator_fn, is_input):
        self.is_input = is_input
        self.port_name = self._get_port_name()
        self.port = port_creator_fn()
        self.port.open(self.port_name)
        if 'topic' in self.kwargs:
            self.connect2topic(self.kwargs['topic'])

    def _get_port_name(self):
        if 'port' in self.kwargs:
            return self.kwargs['port']
        else:
            port_name = re.sub(r'\.([0-9]+)', r'\1', self.component_name)
            # '/robot001/sensor001'
            return '/morse/' + port_name.replace('.', '/') + \
                   ('/in' if self.is_input else '/out')

    def connect2topic(self, topic):
        """ Connect a yarp port to a specific yarp topic. """
        if self.is_input:
            yarp.Network.connect("topic://"+topic, self.port_name)
        else:
            yarp.Network.connect(self.port_name, "topic://"+topic)

    def finalize(self):
        self.port.close()

class YarpPublisher(YarpPort):
    _type_name = "yarp::Bottle"

    def initialize(self):
        YarpPort.initialize(self, yarp.BufferedPortBottle, False)

    def encode_message(self, bottle, data, component_name):
        """ Prepare the content of the bottle 

        This function can be recursively called in case of list processing
        """
        if isinstance(data, int):
            bottle.addInt(data)
        elif isinstance(data, float):
            bottle.addDouble(data)
        elif isinstance(data, str):
            bottle.addString(data)
        elif isinstance(data, tuple):
            self.encode_message(bottle, list(data), component_name)
        elif isinstance(data, list):
            m_bottle = bottle.addList()
            for m_data in data:
                self.encode_message(m_bottle, m_data, component_name)
        elif isinstance(data, dict):
            for key, value in data.items():
                m_bottle = bottle.addList()
                self.encode_message(m_bottle, key, component_name)
                self.encode_message(m_bottle, value, component_name)
        elif isinstance(data, mathutils.Vector):
            self.encode_message(bottle, data[:], component_name)
        elif isinstance(data, mathutils.Matrix):
            self.encode_message(bottle, data[:], component_name)
        elif isinstance(data, mathutils.Quaternion):
            self.encode_message(bottle,
                    [data.x , data.y, data.z, data.w], component_name)
        elif isinstance(data, mathutils.Euler):
            self.encode_message(bottle,
                    [data.z , data.y, data.x], component_name)
        elif isinstance(data, Transformation3d):
            self.encode_message(bottle,
                    [data.x , data.y, data.z,
                     data.yaw, data.pitch, data.roll], component_name)
        else:
            logger.error("Unknown data type in component '%s'" % component_name)

    def default(self, ci):
        bottle = self.port.prepare()
        bottle.clear()
        self.encode(bottle)
        self.port.write()

    def encode(self, bottle):
        for data in self.data.values():
            self.encode_message(bottle, data, self.component_name)

class YarpImagePublisher(YarpPort):

    _type_name = "yarp::ImageRGBA"

    def initialize(self):
        YarpPort.initialize(self, yarp.BufferedPortImageRgba, False)

    def default(self, ci):
        # Wrap the data in a YARP image
        img = yarp.ImageRgba()
        img.setTopIsLowIndex(0)
        img.setQuantum(1)

        # Get the image data from the camera instance
        img_string = self.data['image']
        img_X = self.component_instance.image_width
        img_Y = self.component_instance.image_height

        # Check that an image exists:
        if img_string is not None and img_string != '':
            try:
                data = img_string
                # Pass the data as is, from the bge.texture module
                # NOTE: This requires the patch to yarp-python bindings
                img.setExternal(data,img_X,img_Y)
            except TypeError as detail:
                logger.info("No image yet: %s" % detail)

            # Copy to image with "regular" YARP pixel order
            # Otherwise the image is upside-down
            img2 = self.port.prepare()
            img2.copy(img)

            # Write the image
            self.port.write()

class YarpReader(YarpPort):
    _type_name = "yarp::Bottle"

    def initialize(self):
        YarpPort.initialize(self, yarp.BufferedPortBottle, True)

    def default(self, ci):
        message_data = self.port.read(False)

        if message_data is not None:
            # Data elements are of type defined in data_types
            i = 0
            for variable, data in self.data.items():
                if isinstance(data, int):
                    msg_data = message_data.get(i).asInt()
                    self.data[variable] = msg_data
                    logger.debug("read %s as %d" % (variable, msg_data))
                elif isinstance(data, float):
                    msg_data = message_data.get(i).asDouble()
                    self.data[variable] = msg_data
                    logger.debug("read %s as %f" % (variable, msg_data))
                elif isinstance(data, str):
                    msg_data = message_data.get(i).toString()
                    self.data[variable] = msg_data
                    logger.debug("read %s as %s" % (variable, msg_data))
                else:
                    logger.error("Unknown data type at 'read_message', "
                                 "with component '%s'" % self.component_name)
                    logger.info("DATA: ", data, " | TYPE: ", type(data))
                i += 1
            return True

        else:
            return False

class YarpDatastreamManager(DatastreamManager):
    """ Handle communication between Blender and YARP."""

    def __init__(self):
        """ Initialize the network and connect to the yarp server."""
        # Call the constructor of the parent class
        DatastreamManager.__init__(self)

        yarp.Network.init()


    def __del__(self):
        """ Close all open YARP ports. """
        self.finalize()

    def finalize(self):
        """ Close all currently opened ports and release the network."""
        yarp.Network.fini()
        logger.info('Yarp Mid: ports have been closed.')



########NEW FILE########
__FILENAME__ = yarp_json_request_manager
import logging; logger = logging.getLogger("morse." + __name__)
import sys
import yarp
import json
from collections import OrderedDict

from morse.core.request_manager import RequestManager, MorseRPCInvokationError
from morse.core import status


class YarpRequestManager(RequestManager):
    """Implements services to control the MORSE simulator over YARP

    The syntax of requests is:
    >>> id component_name service [params with Python syntax]

    'id' is an identifier set by the client to conveniently identify
    the request. It must be less that 80 chars in [a-zA-Z0-9].

    The server answers:
    >>> id OK|FAIL result_in_python|error_msg

    """

    def __str__(self):
        return "Yarp service manager"

    def initialization(self):

        # Create dictionaries for the input and output ports
        self._yarp_request_ports = dict()
        self._yarp_reply_ports = dict()
        # Create a dictionary for the port names
        self._component_ports = dict()

        # For asynchronous request, this holds the mapping between a
        # request_id and the socket which requested it.
        self._pending_ports = dict()

        # Stores for each port the pending results to write back.
        self._results_to_output = dict()

        # Create a dictionary for the evailable bottles
        self._in_bottles = dict()
        self._reply_bottles = dict()

        return True


    def finalization(self):
        logger.info("Closing yarp request ports...")
        for port in self._yarp_request_ports.values():
            port.close()

        return True


    def on_service_completion(self, request_id, results):
        port = None

        try:
            port, id = self._pending_ports[request_id]
        except KeyError:
            logger.info(str(self) + ": ERROR: I can not find the port which requested " + request_id)
            return

        if port in self._results_to_output:
            self._results_to_output[port].append((id, results))
        else:
            self._results_to_output[port] = [(id, results)]


    def post_registration(self, component_name, service, is_async):
        """ Register a connection of a service with YARP """
        # Get the Network attribute of yarp,
        #  then call its init method
        self._yarp_module = sys.modules['yarp']
        self.yarp_object = self._yarp_module.Network()

        # Create the names of the ports
        request_port_name = '/ors/services/{0}/request'.format(component_name)
        reply_port_name = '/ors/services/{0}/reply'.format(component_name)

        if not component_name in self._yarp_request_ports.keys():
            # Create the ports to accept and reply to requests
            request_port = self._yarp_module.BufferedPortBottle()
            reply_port = self._yarp_module.BufferedPortBottle()
            request_port.open(request_port_name)
            reply_port.open(reply_port_name)
            self._yarp_request_ports[component_name] = request_port
            self._yarp_reply_ports[component_name] = reply_port
        
            # Create bottles to use in the responses
            bottle_in = self._yarp_module.Bottle()
            self._in_bottles[component_name] = bottle_in
            bottle_reply = self._yarp_module.Bottle()
            self._reply_bottles[component_name] = bottle_reply

            logger.info("Yarp service manager now listening on port " + request_port_name + ".")
            logger.info("Yarp service manager will reply on port " + reply_port_name + ".")

        return True


    def main(self):
        """ Read commands from the ports, and prepare the response""" 
        # Read data from available ports
        for component_name, port in self._yarp_request_ports.items():
            # Get the bottles to read and write
            bottle_in = self._in_bottles[component_name] 
            bottle_reply = self._reply_bottles[component_name] 
            bottle_in = port.read(False)
            if bottle_in is not None:
                logger.debug("Received command from port '%s'" % component_name)
                id = 'unknown'

                try:
                    try:
                        id, component_name, service, params = self._parse_request(bottle_in)
                    except ValueError: # Request contains < 2 tokens.
                        raise MorseRPCInvokationError("Malformed request!")

                    logger.info("Got '%s | %s | %s' (id = %s) from %s" % (component_name, service, params, id, component_name))

                    # on_incoming_request returns either 
                    # (True, result) if it's a synchronous
                    # request that has been immediately executed, or
                    # (False, request_id) if it's an asynchronous request whose
                    # termination will be notified via
                    # on_service_completion.
                    is_sync, value = self.on_incoming_request(component_name, service, params)

                    if is_sync:
                        if port in self._results_to_output:
                            self._results_to_output[port].append((id, value))
                        else:
                            self._results_to_output[port] = [(id, value)]
                    else:
                        # Stores the mapping request/socket to notify
                        # the right port when the service completes.
                        # (cf :py:meth:on_service_completion)
                        # Here, 'value' is the internal request id while
                        # 'id' is the id used by the socket client.
                        self._pending_ports[value] = (port, id)


                except MorseRPCInvokationError as e:
                    if port in self._results_to_output:
                        self._results_to_output[port].append((id, (status.FAILED, e.value)))
                    else:
                        self._results_to_output[port] = [(id, (status.FAILED, e.value))]
        
        if self._results_to_output:
            for component_name, port in self._yarp_request_ports.items():
                if port in self._results_to_output:
                    for r in self._results_to_output[port]:
                        response = OrderedDict([
                            ('id', r[0]),
                            ('status', r[1][0]),
                            ('reply', (r[1][1] if r[1][1] else "")) ])
                            #('reply', "%s" % str(r[1][1]) if r[1][1] else "") ])
                        json_response = json.dumps(response)
                        # Send the reply through the same yarp port
                        reply_port = self._yarp_reply_ports[component_name]
                        bottle_reply = reply_port.prepare()
                        bottle_reply.clear()
                        bottle_reply.addString(json_response)
                        reply_port.write()
                        logger.debug("Sent back '" + str(response) + "'. Component: " + component_name + ". Port: " + str(port))
                            
                    del self._results_to_output[port]


    def _parse_request(self, bottle):
        """
        Parse the incoming bottle.
        """
        try:
            request_msg = bottle.get(0).toString()
            request = json.loads(request_msg, object_pairs_hook=OrderedDict)
        except (IndexError, ValueError) as e:
            raise MorseRPCInvokationError('Malformed request: expected a json econded request with this format: \'{id:13, component:Motion_Controller, service:goto, params:[5, 5, 0]}\' (all values enclosed in strings)')

        id = request['id']
        component_name = request['component']
        service = request['service']
        try:
            params = request['params']
            import ast
            p =  ast.literal_eval(params)
        except (NameError, SyntaxError) as e:
            raise MorseRPCInvokationError("Invalid request syntax: error while parsing the parameters. " + str(e))

        return id, component_name, service, p

########NEW FILE########
__FILENAME__ = yarp_request_manager
import logging; logger = logging.getLogger("morse." + __name__)
import sys
import yarp

from morse.core.request_manager import RequestManager, MorseRPCInvokationError
from morse.core import status


class YarpRequestManager(RequestManager):
    """Implements services to control the MORSE simulator over YARP

    The syntax of requests is:
    >>> id component_name service [params with Python syntax]

    'id' is an identifier set by the client to conveniently identify
    the request. It must be less that 80 chars in [a-zA-Z0-9].

    The server answers:
    >>> id OK|FAIL result_in_python|error_msg

    """

    def __str__(self):
        return "Yarp service manager"

    def initialization(self):

        # Create dictionaries for the input and output ports
        self._yarp_request_ports = dict()
        self._yarp_reply_ports = dict()
        # Create a dictionary for the port names
        self._component_ports = dict()

        # For asynchronous request, this holds the mapping between a
        # request_id and the socket which requested it.
        self._pending_ports = dict()

        # Stores for each port the pending results to write back.
        self._results_to_output = dict()

        # Create a dictionary for the evailable bottles
        self._in_bottles = dict()
        self._reply_bottles = dict()

        return True


    def finalization(self):
        logger.info("Closing yarp request ports...")
        for port in self._yarp_request_ports.values():
            port.close()

        return True


    def on_service_completion(self, request_id, results):
        port = None

        try:
            port, id = self._pending_ports[request_id]
        except KeyError:
            logger.info(str(self) + ": ERROR: I can not find the port which requested " + request_id)
            return

        if port in self._results_to_output:
            self._results_to_output[port].append((id, results))
        else:
            self._results_to_output[port] = [(id, results)]


    def post_registration(self, component_name, service, is_async):
        """ Register a connection of a service with YARP """
        # Get the Network attribute of yarp,
        #  then call its init method
        self._yarp_module = sys.modules['yarp']
        self.yarp_object = self._yarp_module.Network()

        # Create the names of the ports
        request_port_name = '/morse/services/{0}/request'.format(component_name)
        reply_port_name = '/morse/services/{0}/reply'.format(component_name)

        if not component_name in self._yarp_request_ports.keys():
            # Create the ports to accept and reply to requests
            request_port = self._yarp_module.BufferedPortBottle()
            reply_port = self._yarp_module.BufferedPortBottle()
            request_port.open(request_port_name)
            reply_port.open(reply_port_name)
            self._yarp_request_ports[component_name] = request_port
            self._yarp_reply_ports[component_name] = reply_port
        
            # Create bottles to use in the responses
            bottle_in = self._yarp_module.Bottle()
            self._in_bottles[component_name] = bottle_in
            bottle_reply = self._yarp_module.Bottle()
            self._reply_bottles[component_name] = bottle_reply

            logger.info("Yarp service manager now listening on port " + request_port_name + ".")
            logger.info("Yarp service manager will reply on port " + reply_port_name + ".")

        return True


    def main(self):
        """ Read commands from the ports, and prepare the response""" 
        # Read data from available ports
        for component_name, port in self._yarp_request_ports.items():
            # Get the bottles to read and write
            bottle_in = self._in_bottles[component_name] 
            bottle_reply = self._reply_bottles[component_name] 
            bottle_in = port.read(False)
            if bottle_in is not None:
                logger.debug("Received command from port '%s'" % component_name)

                try:
                    try:
                        id, component_name, service, params = self._parse_request(bottle_in)
                    except ValueError: # Request contains < 2 tokens.
                        raise MorseRPCInvokationError("Malformed request! ")

                    logger.info("Got '%s | %s | %s' (id = %s) from %s" % (component_name, service, params, id, component_name))

                    # on_incoming_request returns either 
                    #(True, result) if it's a synchronous
                    # request that has been immediately executed, or
                    # (False, request_id) if it's an asynchronous request whose
                    # termination will be notified via
                    # on_service_completion.
                    is_sync, value = self.on_incoming_request(component_name, service, params)

                    if is_sync:
                        if port in self._results_to_output:
                            self._results_to_output[port].append((id, value))
                        else:
                            self._results_to_output[port] = [(id, value)]
                    else:
                        # Stores the mapping request/socket to notify
                        # the right port when the service completes.
                        # (cf :py:meth:on_service_completion)
                        # Here, 'value' is the internal request id while
                        # 'id' is the id used by the socket client.
                        self._pending_ports[value] = (port, id)


                except MorseRPCInvokationError as e:
                    if port in self._results_to_output:
                        self._results_to_output[port].append((id, (status.FAILED, e.value)))
                    else:
                        self._results_to_output[port] = [(id, (status.FAILED, e.value))]
        
        if self._results_to_output:
            for component_name, port in self._yarp_request_ports.items():
                if port in self._results_to_output:
                    for r in self._results_to_output[port]:
                        response = "%s %s %s" % (r[0], r[1][0], str(r[1][1]) if r[1][1] else "")
                        # Send the reply through the same yarp port
                        reply_port = self._yarp_reply_ports[component_name]
                        bottle_reply = reply_port.prepare()
                        bottle_reply.clear()
                        bottle_reply.addString(response)
                        reply_port.write()
                        logger.debug("Sent back '" + response + "'. Component: " + component_name + ". Port: " + str(port))
                            
                    del self._results_to_output[port]


    def _parse_request(self, bottle):
        """
        Parse the incoming bottle.
        """
        try:
            id = bottle.get(0).asInt()
            component_name = bottle.get(1).toString()
            service = bottle.get(2).toString()
        except IndexError as e:
            raise MorseRPCInvokationError("Malformed request: at least 3 values and at most 4 are expected (id, component_name, service, [params])")

        try:
            params = bottle.get(3).toString()
            import ast
            p =  ast.literal_eval(params)
        except (NameError, SyntaxError) as e:
            raise MorseRPCInvokationError("Invalid request syntax: error while parsing the parameters. " + str(e))

        return id, component_name, service, p

########NEW FILE########
__FILENAME__ = abstract_modifier
from abc import ABCMeta, abstractmethod

from morse.core import blenderapi

class AbstractModifier(object):
    """
    The class is inherited by all modifiers.
    Concrete classes need to implement :py:meth:`modify`.
    """
    _type_name = "(this modifier does not document its output/input type)"
    _type_url = ""

    __metaclass__ = ABCMeta

    def __init__(self, component_instance, kwargs):
        self.component_instance = component_instance
        self.kwargs = kwargs
        self.initialize()

    @property
    def component_name(self):
        """ get the component name
        """
        return self.component_instance.bge_object.name

    @property
    def data(self):
        """ get the component local data
        """
        return self.component_instance.local_data
    
    def parameter(self, arg, prop=None, default=None):
        """ get a modifier parameter
        
        The parameter is (by priority order):
        1. get from modifier kwargs
        2. get from the scene properties
        3. set to None 
        """
        ssr = blenderapi.getssr()
        if arg in self.kwargs:
            return self.kwargs[arg]
        else:
            try:
                if prop:
                    x = ssr[prop]
                else:
                    x = ssr[arg]
                return x
            except KeyError:
                return default

    def __str__(self):
        return '%s(%s)'%(self.__class__.__name__, self.component_name)
    
    def key_error(self, detail):
        """ logs a standard warning if some data has not been found in the component
        """ 
        logger.warning("Unable to use %s on component %s. It does not have data %s." 
                       % (self.__class__.__name__, self.component_name, detail))

    def initialize(self):
        """ initialize the specific modifier

        Can be overridden if needed
        """
        pass

    @abstractmethod
    def modify(self):
        """ default method called by MORSE logic
        
        All modifiers have to override this method.
        """
        pass

    def finalize(self):
        """ finalize the specific modifier
        
        Can be overridden if needed
        """
        pass

    def __del__(self):
        self.finalize()

########NEW FILE########
__FILENAME__ = imu_noise
import logging; logger = logging.getLogger("morse." + __name__)
import random

from morse.helpers.components import add_property
from morse.modifiers.abstract_modifier import AbstractModifier

class IMUNoiseModifier(AbstractModifier):
    """
    This modifier allows to simulate Gaussian noise for accelerometer and
    gyroscope sensors of an IMU.
    No bias is modeled so far.
    """

    _name = "IMUNoise"
    
    add_property('_gyro_std_dev', {'x': 0.5, 'y': 0.5, 'z': 0.5}, "gyro_std", type = "dict", 
                 doc = "Standard deviation for noise applied to angular velocities as dictionary with x,y,z as floats")
    add_property('_accel_std_dev', {'x': 0.5, 'y': 0.5, 'z': 0.5}, "accel_std", type = "dict", 
                 doc="Standard deviation for noise applied to linear accelerations as dictionary with x,y,z as floats")
    
    def initialize(self):
        gyro_std = self.parameter("gyro_std", default=0.5)
        if isinstance(gyro_std, dict):
            self._gyro_std_dev = gyro_std
        else:
            self._gyro_std_dev = {'x': float(gyro_std), 'y': float(gyro_std), 'z': float(gyro_std)}
        accel_std = self.parameter("accel_std", default=0.5)
        if isinstance(accel_std, dict):
            self._accel_std_dev = accel_std
        else:
            self._accel_std_dev = {'x': float(accel_std), 'y': float(accel_std), 'z': float(accel_std)}
        logger.info("IMU Noise standard deviations: gyro x:%.4f, y:%.4f, z:%.4f,  accel x:%.4f, y:%.4f, z:%.4f,",
                    self._gyro_std_dev.get('x', 0), self._gyro_std_dev.get('y', 0), self._gyro_std_dev.get('z'),
                    self._accel_std_dev.get('x', 0), self._accel_std_dev.get('y', 0), self._accel_std_dev.get('z', 0))

    def modify(self):
        axes = ['x', 'y', 'z']
        for i in range(0, 3):
            if axes[i] in self._gyro_std_dev:
                self.data['angular_velocity'][i] = \
                    random.gauss(self.data['angular_velocity'][i], self._gyro_std_dev[axes[i]])
            if axes[i] in self._accel_std_dev:
                self.data['linear_acceleration'][i] = \
                    random.gauss(self.data['linear_acceleration'][i], self._accel_std_dev[axes[i]])


########NEW FILE########
__FILENAME__ = ned
import logging; logger = logging.getLogger("morse." + __name__)
import math

from morse.modifiers.abstract_modifier import AbstractModifier

class NEDModifier(AbstractModifier):
    """ 
    This modifier converts the coordinates generated by the MORSE simulator to
    change to the North, East, Down (NED) coordinate system, instead of the East,
    North, Up (ENU) system normally used by Blender.

    This is achieved by switching the direction of the X and Y axis, as well as
    inverting the sense of the Z axis.

    This modifier attempts to alter data ``x``, ``y`` and ``z`` for position, 
    and ``yaw``, ``pitch`` and ``roll`` for orientation. 

    The NED modifier provides as modifiers:
    
    * :py:class:`morse.modifiers.ned.CoordinatesToNED`
    * :py:class:`morse.modifiers.ned.CoordinatesFromNED`
    * :py:class:`morse.modifiers.ned.AnglesToNED`
    * :py:class:`morse.modifiers.ned.AnglesFromNED`

    """
    
    _name = "NED"
    
    def modify(self):
        pass
    
class CoordinatesToNED(NEDModifier):
    """ Convert the coordinates from ENU to NED. """
    def modify(self):
        try:
            tmp = self.data['x']
            self.data['x'] = self.data['y']
            self.data['y'] = tmp
            self.data['z'] = - self.data['z']
        except KeyError as detail:
            self.key_error(detail)

class CoordinatesFromNED(NEDModifier):        
    """ Convert the coordinates from NED to ENU. """
    def modify(self):
        try:
            tmp = self.data['x']
            self.data['x'] = self.data['y']
            self.data['y'] = tmp
            self.data['z'] = - self.data['z']
        except KeyError as detail:
            self.key_error(detail)

class AnglesToNED(NEDModifier):
    """ Convert the angles from ENU to NED. """
    def modify(self):
        try:
            roll = math.pi/2 - self.data['yaw']
            self.data['yaw'] = self.data['roll']
            self.data['pitch'] = - self.data['pitch']
            self.data['roll'] = roll
        except KeyError as detail:
            self.key_error(detail)

class AnglesFromNED(NEDModifier):
    """ Convert the angles from NED to ENU. """
    def modify(self):
        try:
            yaw = math.pi/2 - self.data['roll']
            self.data['pitch'] = - self.data['pitch']
            self.data['roll'] = self.data['yaw']
            self.data['yaw'] = yaw
        except KeyError as detail:
            self.key_error(detail)

########NEW FILE########
__FILENAME__ = odometry_noise
import logging; logger = logging.getLogger("morse." + __name__)

from morse.modifiers.abstract_modifier import AbstractModifier
from math import cos, sin

class OdometryNoiseModifier(AbstractModifier):
    """
    This modifier allows to simulate two common issues when calculating odometry :

    - an error in the scale factor used to compute the distance from the value
      returned by the odometer (parameter **factor**)
    - the gyroscope natural drift (parameter **gyro_drift** (rad by tick))
    
    Modified data
    -------------

    The modifier only accumulate errors for a 2D odometry sensor. It modifies so
    the following variables :

    - **dS** by the scale factor
    - **dx** considering the scale factor and gyroscope drift
    - **dy** considering the scale factor and gyroscope drift
    - **dyaw** considering the gyroscope drift
    - **x** considering the scale factor and gyroscope drift
    - **y** considering the scale factor and gyroscope drift
    - **yaw** considering the gyroscope drift
    - **vx** considering the new **dx**
    - **vy** considering the new **dy**
    - **wz** considering the new **dyaw**

    Available methods
    -----------------

    - ``noisify``: Simulate drift of gyroscope and possible error in the scale
      factor
    """
    
    def initialize(self):
        self._factor = float(self.parameter("factor", default=1.05))
        self._gyro_drift = float(self.parameter("gyro_drift", default=0))
        self._drift_x = 0.0
        self._drift_y = 0.0
        self._drift_yaw = 0.0

    def modify(self):
        # Basic 2D odometry implementation dx = dS * sin(yaw) and
        #                                  dy = dS * cos(yaw)
        # If we have some error on  dS and yaw, we have
        # dx      = factor * dS * sin(yaw + drift_yaw)
        #         = factor * dS * sin(yaw) * cos(drift_yaw) +
        #           factor * dS * cos(yaw)  * sin(drift_yaw)
        #         = factor * ( dx * cos(drift_yaw) +  dy * sin(drift_yaw))
        # Same thing to compute dy
        try:
            self._drift_yaw += self._gyro_drift
            dx = self._factor * ( self.data['dx'] * cos(self._drift_yaw) +
                                  self.data['dy'] * sin(self._drift_yaw))
            dy = self._factor * ( self.data['dy'] * cos(self._drift_yaw) -
                                  self.data['dx'] * sin(self._drift_yaw))
            
            self._drift_x +=  dx - self.data['dx']
            self._drift_y +=  dy - self.data['dy']
            
            self.data['dS'] *= self._factor
            self.data['dx'] = dx
            self.data['dy'] = dy
            self.data['dyaw'] += self._gyro_drift
            
            self.data['x'] += self._drift_x
            self.data['y'] += self._drift_y
            self.data['yaw'] += self._drift_yaw
            
            freq = self.component_instance.frequency
            
            self.data['vx'] = self.data['dx'] / freq
            self.data['vy'] = self.data['dy'] / freq
            self.data['wz'] = self.data['dyaw'] / freq
        
        except KeyError as detail:
            self.key_error(detail)


########NEW FILE########
__FILENAME__ = pose_noise
import logging; logger = logging.getLogger("morse." + __name__)
import random
from math import radians, degrees, cos
from morse.core.mathutils import Vector, Quaternion

from morse.helpers.components import add_property
from morse.modifiers.abstract_modifier import AbstractModifier

class NoiseModifier(AbstractModifier):
    """ 
    This modifier allows to simulate Gaussian noise for pose measurements.
    If the variable ``orientation`` exists, it is taken to be a unit quaternion
    and noise added to it. Otherwise rotational noise will be added to the roll,
    pitch and yaw variables.

    This modifier attempts to alter data ``x``, ``y`` and ``z`` for position, 
    and either ``orientation`` or ``yaw``, ``pitch`` and ``roll`` for orientation. 

    The PoseNoise modifier provides as modifiers:
    
    * :py:class:`morse.modifiers.pose_noise.PositionNoiseModifier`
    * :py:class:`morse.modifiers.pose_noise.OrientationNoiseModifier`
    * :py:class:`morse.modifiers.pose_noise.PoseNoiseModifier`

    """

    _name = "PoseNoise"

    add_property('_pos_std_dev', {'x': 0.05, 'y': 0.05, 'z': 0.05}, "pos_std", type="dict",
                 doc="Standard deviation for position noise as dictionary with x,y,z as floats")
    add_property('_rot_std_dev', {'roll': radians(5), 'pitch': radians(5), 'yaw': radians(5)},
                "rot_std", type="dict",
                 doc="Standard deviation for rotation noise of roll,pitch,yaw axes as floats in radians")
    add_property('_2D', False, "_2D", type="bool",
                 doc="If True, noise is only applied to 2D pose attributes (i.e., x, y and yaw)")

    def initialize(self):
        pos_std = self.parameter("pos_std", default=0.05)
        if isinstance(pos_std, dict):
            self._pos_std_dev = pos_std
        else:
            self._pos_std_dev = {'x': float(pos_std), 'y': float(pos_std), 'z': float(pos_std)}
        rot_std = self.parameter("rot_std", default=radians(5))
        if isinstance(rot_std, dict):
            self._rot_std_dev = rot_std
        else:
            self._rot_std_dev = {'roll': float(rot_std), 'pitch': float(rot_std), 'yaw': float(rot_std)}
        self._2D = bool(self.parameter("_2D", default=False))
        if self._2D:
            logger.info("Noise modifier standard deviations: x:%.4f, y:%.4f, yaw:%.3f deg",
                        self._pos_std_dev.get('x', 0),
                        self._pos_std_dev.get('y', 0),
                        degrees(self._rot_std_dev.get('yaw', 0)))
        else:
            logger.info("Noise modifier standard deviations: x:%.4f, y:%.4f, z:%.4f, "
                        "roll:%.3f deg, pitch:%.3f deg, yaw:%.3f deg",
                        self._pos_std_dev.get('x', 0),
                        self._pos_std_dev.get('y', 0),
                        self._pos_std_dev.get('z', 0),
                        degrees(self._rot_std_dev.get('roll', 0)),
                        degrees(self._rot_std_dev.get('pitch', 0)),
                        degrees(self._rot_std_dev.get('yaw', 0)))

class PositionNoiseModifier(NoiseModifier):
    """ Add a gaussian noise to a position 
    """
    def modify(self):
        data_vars = ['x', 'y']
        if not self._2D:
            data_vars.append('z')
        for variable in data_vars:
            if variable in self.data and variable in self._pos_std_dev:
                self.data[variable] = random.gauss(self.data[variable], self._pos_std_dev[variable])

class OrientationNoiseModifier(NoiseModifier):
    """ Add a gaussian noise to an orientation 
    """
    def modify(self):
        data_vars = []
        if not self._2D:
            data_vars.append('roll')
            data_vars.append('pitch')
        data_vars.append('yaw')
        # generate a gaussian noise rotation vector
        rot_vec = Vector((0.0, 0.0, 0.0))
        for i in range(len(data_vars)):
            if data_vars[i] in self._rot_std_dev:
                rot_vec[i] = random.gauss(rot_vec[i], self._rot_std_dev[data_vars[i]])
        # convert rotation vector to a quaternion representing the random rotation
        angle = rot_vec.length
        if angle > 0:
            axis = rot_vec / angle
            noise_quat = Quaternion(axis, angle)
        else:
            noise_quat = Quaternion()
            noise_quat.identity()
        try:
            self.data['orientation'] = (noise_quat * self.data['orientation']).normalized()
        except KeyError:
            # for eulers this is a bit crude, maybe should use the noise_quat here as well...
            for var in data_vars:
                if var in self.data and var in self._rot_std_dev:
                    self.data[var] = random.gauss(self.data[var], self._rot_std_dev[var])

class PoseNoiseModifier(PositionNoiseModifier, OrientationNoiseModifier):
    """ Add a gaussian noise to both position and orientation 
    """
    def modify(self):
        PositionNoiseModifier.modify(self)
        OrientationNoiseModifier.modify(self)

########NEW FILE########
__FILENAME__ = utm
import logging; logger = logging.getLogger("morse." + __name__)

from morse.helpers.components import add_property
from morse.modifiers.abstract_modifier import AbstractModifier

class UTMModifier(AbstractModifier):
    """ 
    This modifier converts the coordinates generated by the MORSE simulator to use
    UTM global coordinates. This is achieved by setting the offset of the Blender
    origin with respect to the UTM reference. The offset can be either given in
    the modifier parameters, or globally defined as three
    properties of the ``Scene_Script_Holder`` object of the scene: ``UTMXOffset``,
    ``UTMYOffset`` and ``UTMZOffset``.
    
    .. note:: Due to limitation in Blender, to pass offset outside of range
      [-10000.0, 10000.0] as global scene properties,
      you need to pass the offset value as a string.

    This modifier attempts to alter data ``x``, ``y`` and ``z`` of modified components.

    The UTM modifier provides as modifiers:
    
    * :py:class:`morse.modifiers.utm.CoordinatesToUTM`
    * :py:class:`morse.modifiers.utm.CoordinatesFromUTM`

    """
    
    _name = "UTM"
    
    add_property('_x_offset', 0, "x_offset", type = "float", doc = "UTM X Offset")
    add_property('_y_offset', 0, "y_offset", type = "float", doc = "UTM Y Offset")
    add_property('_z_offset', 0, "z_offset", type = "float", doc = "UTM Z Offset")
        
    def initialize(self):
        """ Initialize the UTM coordinates reference. 
        """
        self._x_offset = float(self.parameter('x_offset', prop='UTMXOffset', default=0))
        self._y_offset = float(self.parameter('y_offset', prop='UTMYOffset', default=0))
        self._z_offset = float(self.parameter('z_offset', prop='UTMZOffset', default=0))
        logger.info("UTM reference point is (%s,%s,%s)" 
                    % (self._x_offset, self._y_offset, self._z_offset))

class CoordinatesToUTM(UTMModifier):
    """ Converts from Blender coordinates to UTM coordinates.
    """
    def modify(self):
        try:
            self.data['x'] += self._x_offset
            self.data['y'] += self._y_offset
            self.data['z'] += self._z_offset
        except KeyError as detail:
            self.key_error(detail)

class CoordinatesFromUTM(UTMModifier):
    """ Converts from UTM coordinates to Blender coordinates.
    """
    def modify(self):
        try:
            self.data['x'] -= self._x_offset
            self.data['y'] -= self._y_offset
            self.data['z'] -= self._z_offset
        except KeyError as detail:
            self.key_error(detail)

########NEW FILE########
__FILENAME__ = hla
import logging; logger = logging.getLogger("morse." + __name__)
import mathutils
import os

from morse.core import blenderapi
from morse.core.exceptions import MorseMultinodeError
from morse.core.multinode import SimulationNodeClass

logger.setLevel(logging.INFO)

try:
    import hla
    import hla.rti as rti
    import hla.omt as fom
except (ImportError, SyntaxError):
    logger.error("No HLA binding found or imported!")
    raise MorseMultinodeError("'hla' python not found, or has syntax errors")

"""
Defines the 'MorseVector' type that will be transfered on the HLA federation.
"""
MorseVector = fom.HLAfixedArray("MorseVector", fom.HLAfloat32LE, 3)

class MorseAmbassador(rti.FederateAmbassador):
    """
    The Federate Ambassador of the MORSE node.
    
    """
    def __init__(self, rtia, federation, time_regulation, time):
        self.objects = []
        self.rtia_ = rtia
        self.constrained = False
        self.regulator = False
        self.tag = time_regulation
        self.federation = federation
        self.current_time = time
        self.lookahead = 0
        logger.debug("MorseAmbassador created.")
    
    def initialize(self):
        try:
            self.out_robot = self.rtia_.getObjectClassHandle("Robot")
            self.out_position = self.rtia_.getAttributeHandle("position",
                self.out_robot)
            self.out_orientation = self.rtia_.getAttributeHandle(
                "orientation", self.out_robot)
        except rti.NameNotFound:
            logger.error("'Robot' (or attributes) not declared in FOM." + \
                "Your '.fed' file may not be up-to-date.")
            return False
        
        self.rtia_.publishObjectClass(self.out_robot, 
            [self.out_position, self.out_orientation])

        robot_dict = blenderapi.persistantstorage().robotDict
        for obj, local_robot_data in robot_dict.items():
            self.objects.append(self.rtia_.registerObjectInstance(
                    self.out_robot, obj.name))
            logger.info(
                "Pose of robot %s will be published on the %s federation.", 
                obj.name, self.federation)
        
        self.in_robot = self.rtia_.getObjectClassHandle("Robot")
        self.in_position = self.rtia_.getAttributeHandle("position", 
            self.in_robot)
        self.in_orientation = self.rtia_.getAttributeHandle("orientation", 
            self.in_robot)
        self.rtia_.subscribeObjectClassAttributes(self.in_robot, 
            [self.in_position, self.in_orientation])
        # TSO initialization
        if self.tag:
            self.tag = False
            self.lookahead = 1
            self.current_time = self.rtia_.queryFederateTime()
            logger.debug("Initial Federate time is %s", self.current_time)
            self.rtia_.enableTimeConstrained()
            self.rtia_.enableTimeRegulation(self.current_time, self.lookahead)
            while not self.constrained and not self.regulator and not self.tag:
                self.rtia_.tick(0, 1)
        logger.debug("MorseAmbassador initialized")

    def terminate(self):
        for obj in self.objects:
            self.rtia_.deleteObjectInstance(obj, 
                self.rtia_.getObjectInstanceName(obj))

    def discoverObjectInstance(self, object, objectclass, name):
        logger.info(
            "Robot %s will have its pose reflected in the current node...", 
            name)

    def reflectAttributeValues(self, object, attributes, tag, order, transport, 
                               time=None, retraction=None):
        scene = blenderapi.scene()
        obj_name = self.rtia_.getObjectInstanceName(object)
        logger.debug("RAV %s", obj_name)
        try:
            obj = scene.objects[obj_name]
            if self.in_position in attributes:
                pos, offset = MorseVector.unpack(attributes[self.in_position])
                # Update the positions of the robots
                obj.worldPosition = pos
            if self.in_orientation in attributes:
                ori, offset = MorseVector.unpack(attributes[self.in_orientation])
                # Update the orientations of the robots
                obj.worldOrientation = mathutils.Euler(ori).to_matrix()
        except KeyError as detail:
            logger.debug("Robot %s not found in this simulation scenario," + \
                "but present in another node. Ignoring it!", obj_name)
    
    def timeConstrainedEnabled(self, time):
        logger.debug("Constrained at time %s", time)
        self.current_time = time
        self.constrained = True
    
    def timeRegulationEnabled(self, time):
        logger.debug("Regulator at time %s", time)
        self.current_time = time
        self.regulator = True
    
    def timeAdvanceGrant(self, time):
        self.current_time = time
        self.tag = True
    
class HLANode(SimulationNodeClass):
    """
    Implements multinode simulation using HLA.
    """
    
    time_sync = False
    fom = "morse.fed"
    federation = "MORSE"
    
    def initialize(self):
        """
        Initializes HLA (connection to RTIg, FOM file, publish robots...)
        
        """
        logger.info("Initializing HLA node.")
        if os.getenv("CERTI_HTTP_PROXY") is None:
            os.environ["CERTI_HTTP_PROXY"] = ""
        os.environ["CERTI_HOST"] = str(self.host)
        os.environ["CERTI_TCP_PORT"] = str(self.port)
        logger.debug("CERTI_HTTP_PROXY= %s", os.environ["CERTI_HTTP_PROXY"])
        logger.debug("CERTI_HOST= %s", os.environ["CERTI_HOST"])
        logger.debug("CERTI_TCP_PORT= %s", os.environ["CERTI_TCP_PORT"])
        try:
            logger.debug("Creating RTIA...")
            self.rtia = rti.RTIAmbassador()
            logger.debug("RTIA created!")
            try:
                self.rtia.createFederationExecution(self.federation, self.fom)
                logger.info("%s federation created", self.federation)
            except rti.FederationExecutionAlreadyExists:
                logger.debug("%s federation already exists", self.federation)
            except rti.CouldNotOpenFED:
                logger.error("FED file not found! " + \
                    "Please check that the '.fed' file is in the CERTI " + \
                    "search path of RTIg.")
                return False
            except rti.ErrorReadingFED:
                logger.error("Error when reading FED file! " + \
                    "Please check the '.fed' file syntax.")
                return False
            logger.debug("Creating MorseAmbassador...")
            self.morse_ambassador = MorseAmbassador(self.rtia, self.federation,
                self.time_sync, 0)
            try:
                self.rtia.joinFederationExecution(self.node_name, 
                    self.federation, self.morse_ambassador)
            except rti.FederateAlreadyExecutionMember:
                logger.error("A Federate with name %s has already registered."+\
                    " Change the name of your federate or " + \
                    "check your federation architecture.", self.node_name)
                return False
            except rti.CouldNotOpenFED:
                logger.error("FED file not found! Please check that the " + \
                    "'.fed' file is in the CERTI search path.")
                return False
            except rti.ErrorReadingFED:
                logger.error("Error when reading FED file! "+ \
                    "Please check the '.fed' file syntax.")
                return False
            if not self.morse_ambassador.initialize():
                return False
            logger.info("HLA middleware initialized.")
        except Exception as error:
            logger.error("Error when connecting to the RTIg: %s." + \
                "Please check your HLA network configuration.", error)
            raise
            
    def finalize(self):
        """
        Close all open HLA connections.
        
        """
        logger.info("Resigning from the HLA federation")
        if self.morse_ambassador:
            self.morse_ambassador.terminate()
        self.rtia.resignFederationExecution(
            rti.ResignAction.DeleteObjectsAndReleaseAttributes)
            
    def synchronize(self):
        self.morse_ambassador.tag = False
        scene = blenderapi.scene()
        t = self.morse_ambassador.current_time + self.morse_ambassador.lookahead
        for obj in self.morse_ambassador.objects:
            obj_name = self.rtia.getObjectInstanceName(obj)
            obj_pos = scene.objects[obj_name].worldPosition.to_tuple()
            obj_ori = scene.objects[obj_name].worldOrientation.to_euler()
            hla_att = {
                self.morse_ambassador.out_position:
                    MorseVector.pack([obj_pos[0], obj_pos[1], obj_pos[2]]),
                self.morse_ambassador.out_orientation:
                    MorseVector.pack([obj_ori.x, obj_ori.y, obj_ori.z])}
            try:
                self.rtia.updateAttributeValues(obj, hla_att, "update", t)
            except rti.InvalidFederationTime:
                logger.debug("Invalid time for UAV: %s; Federation time is %s",
                    t, self.rtia.queryFederateTime())
        if self.time_sync:
            self.rtia.timeAdvanceRequest(t)
            while not self.morse_ambassador.tag:
                self.rtia.tick(0, 1)
            logger.debug("Node simulation time:" + \
                self.morse_ambassador.current_time)
        else:
            self.rtia.tick()

########NEW FILE########
__FILENAME__ = socket
import logging; logger = logging.getLogger("morse." + __name__)
import mathutils

from morse.core import blenderapi
from morse.core.multinode import SimulationNodeClass

import asyncore
import threading
from pymorse import StreamJSON

class SocketNode(SimulationNodeClass):
    """ 
    Implements multinode simulation using sockets.
    """

    out_data = {}

    def initialize(self):
        """
        Create the socket that will be used to commmunicate to the server.
        """
        self.node_stream = None
        logger.debug("Connecting to %s:%d" % (self.host, self.port) )
        try:
            self.node_stream = StreamJSON(self.host, self.port)
            self.async_thread = threading.Thread( target = asyncore.loop, kwargs = {'timeout': .1} )
            self.async_thread.start()
            if self.node_stream.connected:
                logger.info("Connected to %s:%s" % (self.host, self.port) )
        except Exception as err:
            logger.info("Multi-node simulation not available!")
            logger.warning("Unable to connect to %s:%s"%(self.host, self.port) )
            logger.warning(str(err))

    def _exchange_data(self, out_data):
        """ Send and receive pickled data through a socket """
        # Use the existing socket connection
        self.node_stream.publish([self.node_name, out_data])
        return self.node_stream.get(timeout=.1) or self.node_stream.last()

    def synchronize(self):
        if not self.node_stream:
            logger.debug("not self.node_stream")
            return
        if not self.node_stream.connected:
            logger.debug("not self.node_stream.connected")
            return

        # Get the coordinates of local robots
        for obj, local_robot_data in blenderapi.persistantstorage().robotDict.items():
            #self.out_data[obj.name] = [obj.worldPosition.to_tuple()]
            euler_rotation = obj.worldOrientation.to_euler()
            self.out_data[obj.name] = [obj.worldPosition.to_tuple(), [euler_rotation.x, euler_rotation.y, euler_rotation.z]]
        # Send the encoded dictionary through a socket
        #  and receive a reply with any changes in the other nodes
        in_data = self._exchange_data(self.out_data)
        logger.debug("Received: %s" % in_data)

        if not in_data:
            return

        try:
            self.update_scene(in_data, blenderapi.scene())
        except Exception as e:
            logger.warning("error while processing incoming data: " + str(e))

    def update_scene(self, in_data, scene):
        # Update the positions of the external robots
        for obj_name, robot_data in in_data.items():
            try:
                obj = scene.objects[obj_name]
            except Exception as e:
                logger.debug("%s not found in this simulation scenario, but present in another node. Ignoring it!" % obj_name)
                continue
            if obj not in blenderapi.persistantstorage().robotDict:
                obj.worldPosition = robot_data[0]
                obj.worldOrientation = mathutils.Euler(robot_data[1]).to_matrix()

    def finalize(self):
        """ Close the communication socket. """
        if self.node_stream:
            self.node_stream.close()
            # asyncore.close_all() # make sure all connection are closed
            self.async_thread.join(timeout=1)

########NEW FILE########
__FILENAME__ = atrv
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot

class ATRV(morse.core.robot.Robot):
    """
    Definition for the well-known ATRV robot, distributed by I-Robot.
    """

    _name = "iRobot ATRV platform"

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = b21
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot

class B21(morse.core.robot.Robot):
    """
    Definition for the B21 platform, distributed by RWI. This
    cylindrical robot for Human-Robot interactions.
    """

    _name = 'RWI B21 platform'

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = fakerobot
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot


class FakeRobot(morse.core.robot.Robot):
    """
    This is a special case of component in MORSE. Since all sensors or actuators
    must be attached to one robot, it would not normally be possible to use
    "stand-alone" sensors in the environment.

    If you need to use a sensor in this way, (*i.e.* for motion capture sensors,
    or independent cameras) you should add an **virtual (fake)
    robot** to the scene, and make it the parent of your stand-alone
    sensors.

    This robot has no visual representation, and consists of a single Blender
    Empty. Its only purpose is to provide the base to attach sensors. A single
    fake robot can be the parent of as many
    sensors/actuators as needed.
    """

    _name = 'Fake virtual robot'

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = grasping_robot
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.robot import Robot
from morse.core.services import service
from morse.core import blenderapi

class GraspingRobot(Robot):
    """ Class definition for a "virtual" robot.

    This robot class does not have a graphical representation,
    and it can not move.
    Its only purpose is to define the service grasp that may be
    used by other robot to pick up object.

    The robot need to have a "hand_name" with a near sensor in order to
    be able to use the grasp service.
    """

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        Optionally it gets the name of the object's parent,
        but that information is not currently used for a robot.
        """
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        Robot.__init__(self, obj, parent)

        self.hand_name = 'todefine'
        logger.info('Component initialized')

    @service
    def grasp(self, grab, obj_name=None):
        """
        Grasp near object.

        :param grab: set to True to take an object and False to release it.
        :param obj_name: when None, the robot will just grasp the nearest
                         object without any consideration for the object name.
        """
        logger.debug("morse grasp request received")
        grasping_robot = self.bge_object
        scene = blenderapi.scene()
        if self.hand_name == "todefine":
            logger.error("grasp failed because hand_name was not defined")
        hand_empty = scene.objects[self.hand_name]

        near_sensor = hand_empty.sensors['Near']

        if grab:
            logger.debug("seq t")
            # Check that no other object is being carried
            if (grasping_robot['DraggedObject'] is None or
            grasping_robot['DraggedObject'] == '') :
                logger.debug("Hand is free, I can grab")
                # If name was specified
                if obj_name:
                    near_objects = [obj for obj in near_sensor.hitObjectList
                                    if obj.name == obj_name]
                    if not near_objects:
                        logger.warning("no object named %s in %s"%(obj_name,
                              str(near_sensor.hitObjectList) ))
                        near_object = None
                    else:
                        near_object = near_objects[0]
                else:
                    near_object = near_sensor.hitObject

                hand_empty['Near_Object'] = near_object
                selected_object = hand_empty['Near_Object']
                # If the object is draggable
                if selected_object is not None and selected_object != '':
                    # Clear the previously selected object, if any
                    logger.debug("Object to grab is %s" % selected_object.name)
                    grasping_robot['DraggedObject'] = selected_object
                    # Remove Physic simulation
                    selected_object.suspendDynamics()
                    #Put object in the hand
                    selected_object.worldPosition = hand_empty.worldPosition
                    # Parent the selected object to the hand target
                    selected_object.setParent (hand_empty)
                    logger.debug( "OBJECT %s PARENTED TO %s" %
                                (selected_object.name, hand_empty.name) )
        else:
            if (grasping_robot['DraggedObject'] is not None and
            grasping_robot['DraggedObject'] != '') :
                previous_object = grasping_robot["DraggedObject"]
                # Restore Physics simulation
                previous_object.restoreDynamics()
                previous_object.setLinearVelocity([0, 0, 0])
                previous_object.setAngularVelocity([0, 0, 0])
                # Remove the parent
                previous_object.removeParent()
                # Clear the object from dragged status
                grasping_robot['DraggedObject'] = None
                logger.debug("JUST DROPPED OBJECT %s" % previous_object.name)

    def default_action(self):
        """ Main function of this component """
        pass

########NEW FILE########
__FILENAME__ = human
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
from morse.robots.grasping_robot import GraspingRobot
from morse.core.services import service

class Human(GraspingRobot):
    """ Class definition for the human as a robot entity.

    Sub class of GraspingRobot.
    """

    def __init__(self, obj, parent=None):
        """ Call the constructor of the parent class """
        logger.info('%s initialization' % obj.name)
        GraspingRobot.__init__(self, obj, parent)

        # We define here the name of the human grasping hand:
        self.hand_name = 'Hand_Grab.R'

        logger.info('Component initialized')

    @service
    def move(self, speed, rotation):
        """ Move the human. """

        human = self.bge_object

        if not human['Manipulate']:
            human.applyMovement( [speed,0,0], True )
            human.applyRotation( [0,0,rotation], True )
        else:
            scene = blenderapi.scene()
            target = scene.objects['IK_Target_Empty.R']

            target.applyMovement([0.0, rotation, 0.0], True)
            target.applyMovement([0.0, 0.0, -speed], True)

    @service
    def move_head(self, pan, tilt):
        """ Move the human head. """

        human = self.bge_object
        scene = blenderapi.scene()
        target = scene.objects['Target_Empty']

        if human['Manipulate']:
            return

        target.applyMovement([0.0, pan, 0.0], True)
        target.applyMovement([0.0, 0.0, tilt], True)

    @service
    def move_hand(self, diff, tilt):
        """ Move the human hand (wheel).

        A request to use by a socket.
        Done for wiimote remote control.
        """

        human = self.bge_object
        if human['Manipulate']:
            scene = blenderapi.scene()
            target = scene.objects['IK_Target_Empty.R']
            target.applyMovement([diff, 0.0, 0.0], True)  
        
    @service
    def toggle_manipulation(self):
        """ Change from and to manipulation mode.

        A request to use by a socket.
        Done for wiimote remote control.
        """

        human = self.bge_object
        scene = blenderapi.scene()
        hand_target = scene.objects['IK_Target_Empty.R']
        head_target = scene.objects['Target_Empty']

        if human['Manipulate']:
            human['Manipulate'] = False
            # Place the hand beside the body
            hand_target.localPosition = [0.0, -0.3, 0.8]
            head_target.setParent(human)
            head_target.localPosition = [1.3, 0.0, 1.7]
        else:
            human['Manipulate'] = True
            head_target.setParent(hand_target)
            # Place the hand in a nice position
            hand_target.localPosition = [0.6, 0.0, 1.4]
            # Place the head in the same place
            head_target.localPosition = [0.0, 0.0, 0.0]

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = hummer
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot
import PhysicsConstraints

from morse.helpers.components import add_property


class Hummer(morse.core.robot.Robot):
    """ 
    This is a generic car like robot. It is driven using steering, power
    and braking as provided by the :doc:`steer/force actuator
    <../actuators/steer_force>`.  This vehicle uses the Blender `vehicle
    wrapper
    <http://www.blender.org/documentation/blender_python_api_2_59_0/bge.types.html#bge.types.KX_VehicleWrapper>`_
    constraint, to give it a realistic behaviour, including the
    interaction of the wheels with the ground and suspension.
    """

    _name = 'Hummer car robot'

    add_property('friction', 200.0, 'friction', 'double',
                 "Wheel's friction to the ground. Determines how fast \
                 the robot can accelerate from a standstill.  Also    \
                 affects steering wheel's ability to turn the vehicle.\
                 A value of ``0`` gives very low acceleration. Higher \
                 values permit a higher acceleration.  ")

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        #
        #  This section runs only once to create the vehicle:
        #
        for child in obj.children:
            if 'wheel1' in child.name:
                wheel1 = child
                wheel1.removeParent()
            if 'wheel2' in child.name:
                wheel2 = child
                wheel2.removeParent()
            if 'wheel3' in child.name:
                wheel3 = child
                wheel3.removeParent()
            if 'wheel4' in child.name:
                wheel4 = child
                wheel4.removeParent()

        obj['init'] = 1
        physicsid = obj.getPhysicsId()
        vehicle = PhysicsConstraints.createConstraint(physicsid, 0, 11)
        obj['cid'] = vehicle.getConstraintId()
        self.vehicle = PhysicsConstraints.getVehicleConstraint(obj['cid'])

        # Wheel location from vehicle center
        wx = 1.3
        wy = 1.6
        wz = -.5

        #wheelAttachDirLocal:
        #Direction the suspension is pointing
        wheelAttachDirLocal = [0, 0, -1]

        #wheelAxleLocal:
        #Determines the rotational angle where the
        #wheel is mounted.
        wheelAxleLocal = [-1, 0, 0]

        #suspensionRestLength:
        #The length of the suspension when it's fully
        #extended:
        suspensionRestLength = .3

        #wheelRadius:
        #Radius of the Physics Wheel.
        #Turn on Game:Show Physics Visualization to see
        #a purple line representing the wheel radius.
        wheelRadius = .5

        #hasSteering:
        #Determines whether or not the coming wheel
        #assignment will be affected by the steering
        #value:	
        hasSteering = 1

        #
        #	Front wheels:
        #

        logger.debug(dir(wheel1))

        #Where the wheel is attached to the car based
        #on the vehicle's Center
        wheelAttachPosLocal = [wx, wy, wz]

        #creates the first wheel using all of the variables
        #created above:
        self.vehicle.addWheel(wheel1, wheelAttachPosLocal, wheelAttachDirLocal,
                                      wheelAxleLocal, suspensionRestLength,
                                      wheelRadius, hasSteering)

        #Positions this wheel on the opposite side of the car by using a
        #negative values for the x position.
        wheelAttachPosLocal = [-wx, wy, wz]

        #creates the second wheel:
        self.vehicle.addWheel(wheel2, wheelAttachPosLocal, wheelAttachDirLocal,
                                      wheelAxleLocal, suspensionRestLength,
                                      wheelRadius, hasSteering)

        #
        #	Rear Wheels:
        #

        #Change the hasSteering value to 0 so the rear wheels don't turn
        #when the steering value is changed.
        hasSteering = 0

        # Adjust the location the rear wheels are attached. 
        wx = 1.3
        wy = 2.3

        # Set the wheelAttachPosLocal to the new location for rear wheels:
        # -y moves the position toward the back of the car
        wheelAttachPosLocal = [wx, -wy, wz]

        #Creates the 3rd wheel (first rear wheel)
        self.vehicle.addWheel(wheel3, wheelAttachPosLocal, wheelAttachDirLocal,
                                      wheelAxleLocal, suspensionRestLength,
                                      wheelRadius, hasSteering)

        #Adjust the attach position for the next wheel:
        # changed to -x to place the wheel on the opposite side of the car
        # the same distance away from the vehicle's center
        wheelAttachPosLocal = [-wx, -wy, wz]

        #create the last wheel using the above variables:
        self.vehicle.addWheel(wheel4, wheelAttachPosLocal, wheelAttachDirLocal,
                                      wheelAxleLocal, suspensionRestLength,
                                      wheelRadius, hasSteering)

      #The Rolling Influence:
        #How easy it will be for the vehicle to roll over while turning:
        #0 = Little to no rolling over
        # .1 and higher easier to roll over
        #Wheels that loose contact with the ground will be unable to
        #steer the vehicle as well.
        #influence = 0.1
        influence = 0.05
        self.vehicle.setRollInfluence(influence, 0)
        self.vehicle.setRollInfluence(influence, 1)
        self.vehicle.setRollInfluence(influence, 2)
        self.vehicle.setRollInfluence(influence, 3)

        #Stiffness:
        #Affects how quickly the suspension will 'spring back'
        #0 = No Spring back
        # .001 and higher = faster spring back
        #stiffness = 10.0
        stiffness = 15
        self.vehicle.setSuspensionStiffness(stiffness, 0)
        self.vehicle.setSuspensionStiffness(stiffness, 1)
        self.vehicle.setSuspensionStiffness(stiffness, 2)
        self.vehicle.setSuspensionStiffness(stiffness, 3)

        #Dampening:
        #Determines how much the suspension will absorb the
        #compression.
        #0 = Bounce like a super ball
        #greater than 0 = less bounce
        damping = 10
        self.vehicle.setSuspensionDamping(damping, 0)
        self.vehicle.setSuspensionDamping(damping, 1)
        self.vehicle.setSuspensionDamping(damping, 2)
        self.vehicle.setSuspensionDamping(damping, 3)

        #Compression:
        #Resistance to compression of the overall suspension length.
        #0 = Compress the entire length of the suspension
        #Greater than 0 = compress less than the entire suspension length.
        #10 = almost no compression
        compression = 2
        self.vehicle.setSuspensionCompression(compression, 0)
        self.vehicle.setSuspensionCompression(compression, 1)
        self.vehicle.setSuspensionCompression(compression, 2)
        self.vehicle.setSuspensionCompression(compression, 3)

        #Friction:
        #Wheel's friction to the ground
        #How fast you can accelerate from a standstill.
        #Also affects steering wheel's ability to turn vehicle.
        #0 = Very Slow Acceleration:
        # .1 and higher = Faster Acceleration / more friction:
        self.vehicle.setTyreFriction(self.friction, 0)
        self.vehicle.setTyreFriction(self.friction, 1)
        self.vehicle.setTyreFriction(self.friction, 2)
        self.vehicle.setTyreFriction(self.friction, 3)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        #
        #  This section runs continuously after the initial set up:
        #  Updating Speed, Friction, Braking, Suspension, etc:
        #
        pass

########NEW FILE########
__FILENAME__ = jido
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot

class Jido(morse.core.robot.Robot):
    """
    Definition of the very specific LAAS robot Jido. It is built on a NeoBotix base.
    """

    _name = 'LAAS Jido robot'

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        # Add the variable move_status to the object
        self.move_status = "Stop"

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = mocap_human
import logging; logger = logging.getLogger("morse." + __name__)
from morse.robots.grasping_robot import GraspingRobot
from morse.core.services import service
from morse.core import blenderapi

class MocapHuman(GraspingRobot):
    """ Class definition for the human avatar as a robot entity
    Sub class of Morse_Object.
    This human is set to be controlled using data from an Xtion/Kinect sensor
    """

    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            Optionally it gets the name of the object's parent,
            but that information is not currently used for a robot. """
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        GraspingRobot.__init__(self, obj, parent)

        """
        We define here the name of the human_mocap grasping hand.
        """
        self.hand_name = 'Hand_Grab.R'

        logger.info('Component initialized')

    @service
    def move(self, speed, rotation):
        """ Move the human.
        """
        human = self.bge_object

        #if not human['Manipulate']:
        human.applyMovement( [speed, 0.0, 0.0], True )
        human.applyMovement( [0.0, rotation, 0.0], True )
        #else :
        #    scene = blenderapi.scene()
        #    target = scene.objects['Hand_Grab.R']
        #    target.applyMovement([0.0, rotation, 0.0], True)
        #    target.applyMovement([0.0, 0.0, -speed], True)


    @service
    def move_head(self, pan, tilt):
        """ Move the human head.
        """
        human = self.bge_object
        scene = blenderapi.scene()
        target = scene.objects['IK_Target_Empty.Head']

        if human['Manipulate']:
            return

        target.applyMovement([0.0, pan, 0.0], True)
        target.applyMovement([0.0, 0.0, tilt], True)

    @service
    def move_hand(self, diff, tilt):
        """ move the human hand (wheel). a request to use by a socket.
        Done for wiimote remote control.
        """
        human = self.bge_object
        if human['Manipulate']:
            scene = blenderapi.scene()
            target = scene.objects['IK_Target_Empty.R']
            target.applyMovement([diff, 0.0, 0.0], True)

    @service
    def toggle_manipulation(self):
        """ Switch manipulation mode on and off. a request to use by a socket.
        Done for wiimote remote control.
        """
        human = self.bge_object
        scene = blenderapi.scene()
        hand_target = scene.objects['IK_Target_Empty.R']
        head_target = scene.objects['IK_Target_Empty.Head']
        torso = scene.objects['Torso_Reference_Empty']

        if human['Manipulate']:
            human['Manipulate'] = False
            # Place the hand beside the body
            hand_target.localPosition = [0.3, -0.3, 0.9]
            # Make the head follow the body
            head_target.setParent(torso)
            # Put the head_target in front and above the waist
            head_target.localPosition = [0.5, 0.0, 0.5]
            logger.debug("Moving head_target to CENTER: %s" % head_target.localPosition)

            #hand_target.localPosition = [0.0, -0.3, 0.8]
            #head_target.setParent(human)
            #head_target.localPosition = [1.3, 0.0, 1.7]
        else:
            human['Manipulate'] = True
            # Place the hand in a nice position
            hand_target.localPosition = [0.6, 0.0, 1.4]
            # Make the head follow the hand
            head_target.setParent(hand_target)
            # Reset the head_target position to the same as its parent
            head_target.localPosition = [0.0, 0.0, 0.0]
            logger.debug("Moving head_target to HAND: %s" % head_target.localPosition)


            #head_target.setParent(hand_target)
            # Place the hand in a nice position
            #hand_target.localPosition = [0.6, 0.0, 1.4]
            # Place the head in the same place
            #head_target.localPosition = [0.0, 0.0, 0.0]

    @service
    def switch_cameras(self):
        """ Change between the main camera view in MORSE and the first person camera """
        scene = blenderapi.scene()
        index = blenderapi.persistantstorage().current_camera_index
        next_camera = scene.cameras[index]
        scene.active_camera = next_camera
        logger.info("Showing view from camera: '%s'" % next_camera.name)
        # Disable mouse cursor for Human camera
        if next_camera.name == "Human_Camera":
            blenderapi.mousepointer(visible = False)
        else:
            blenderapi.mousepointer(visible = True)
        # Update the index for the next call
        index = (index + 1) % len(scene.cameras)
        blenderapi.persistantstorage().current_camera_index = index



    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = morsy
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot

class Morsy(morse.core.robot.Robot):
    """
    Morsy is the little mascot of the MORSE project.

    The model does not feature any particular behaviour. It's main
    purpose is for teaching and examples.
    """

    _name = 'The MORSE Morsy mascot'

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = patrolbot
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.wheeled_robot

class PatrolBot(morse.core.wheeled_robot.MorsePhysicsRobot):
    """
    The Research PatrolBot, developed by MobileRobots, is a
    differential-drive robot to carry payloads and sensors over all
    normal indoor surfaces in wheelchair-accessible facilities. The
    PatrolBot is an all-purpose indoor base, it can travel at speeds up
    to 2 m/s, and can carry up to 40kg over flat surfaces.
    """

    _name = 'PatrolBot robot'

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        morse.core.wheeled_robot.MorsePhysicsRobot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = pioneer3dx
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.wheeled_robot

class Pioneer3DX(morse.core.wheeled_robot.MorsePhysicsRobot):
    """ 
    This robot uses the Physics Constraints in Blender to allow the wheels to
    behave more realistically. The wheels turn as the robot moves, and they have
    ``Rigid Body`` physics, so that they can also have collisions with nearby
    objects.

    It has two differential drive wheels, and an additional caster wheel for
    stability.  Since the wheels of this robot use the ``Rigid Body`` physics, it
    must be controlled with the :doc:`v_omega_diff_drive
    <../actuators/v_omega_diff_drive>` actuator.
    """

    _name = 'Pionner 3-DX platform'
              
    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            Optionally it gets the name of the object's parent,
            but that information is not currently used for a robot. """
        logger.info('%s initialization' % obj.name)

        # Call the constructor of the parent class
        morse.core.wheeled_robot.MorsePhysicsRobot.__init__(self, obj, parent)

        logger.info('Component initialized')


    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = pr2
import logging; logger = logging.getLogger("morse." + __name__)
from morse.robots.grasping_robot import GraspingRobot
from morse.core.services import service
from morse.core import blenderapi

class PR2(GraspingRobot):
    """ 
    The MORSE model of the Willow Garage's PR2 robot.

    The PR2 uses the :doc:`armature_actuator <../actuators/armature>`
    for control of the armatures.

    Model Info
    ----------

    The model is imported from a Collada file that is generated from the
    `PR2 URDF file  <http://www.ros.org/wiki/pr2_description>`_.
    The .dae file can be found at:
    ``$MORSE_ROOT/data/robots/pr2/pr2.dae``
    The imported .blend file can be found at:
    ``$MORSE_ROOT/data/robots/pr2/pr2_25_original.blend``

    The URDF to Collada converter changed all the object names, so these
    were remapped to the original URDF names. A renamed version of the
    PR2 model can be found at:
    ``$MORSE_ROOT/data/robots/pr2/pr2_25_rename.blend`` , this file
    includes the script that is used to rename all the objects.

    A model with MORSE integration for the armature can be found at
    (**This is the model that you probably want to use in MORSE**):
    ``$MORSE_ROOT/data/robots/pr2/pr2_25_morse.blend``.

    TODO
    ----

    - Create sensors and actuators to control the PR2 armature. `A
      SensorActuator class would be handy for this
      <https://sympa.laas.fr/sympa/arc/morse-users/2011-07/msg00099.html>`_.
    - Expand the armature to include the hands.
    - Add an actuator to control the movement of the PR2 base.
    - ROS integration.
    - ...

    """

    _name = 'PR2 robot'

    def __init__(self, obj, parent=None):
        """ 
        Constructor method.
        Receives the reference to the Blender object.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        GraspingRobot.__init__(self, obj, parent)

        """
        We define here the name of the pr2 grasping hand:
        """
        self.hand_name = 'Hand.Grasp.PR2'

        self.armatures = []
        # Search armatures and torso in all objects parented to the pr2 empty
        for obj in self.bge_object.childrenRecursive:
            # Check if obj is an armature
            if type(obj).__name__ == 'BL_ArmatureObject':
                self.armatures.append(obj.name)
            if obj.name == 'torso_lift_joint':
                self.torso = obj

        # constant that holds the original height of the torso from the ground
        # These values come from the pr2 urdf file
        self.TORSO_BASE_HEIGHT = (0.739675 + 0.051)
        self.TORSO_LOWER = 0.0  # lower limit on the torso z-translantion
        self.TORSO_UPPER = 0.31  # upper limit on the torso z-translation
        
        logger.info('Component initialized')

    
    @service
    def get_armatures(self):
        """
        Returns a list of all the armatures on the PR2 robot.
        """
        return self.armatures

    @service
    def set_torso(self, height):
        """
        MORSE Service that sets the z-translation of the torso to original_z + height.
        """
        if self.TORSO_LOWER < height < self.TORSO_UPPER:
            self.torso.localPosition = [-0.05, 0, self.TORSO_BASE_HEIGHT + height]
            return "New torso z position: " + str(self.torso.localPosition[2])
        else:
            return "Not a valid height, value has to be between 0.0 and 0.31!"
            
    @service
    def get_torso(self):
        """
        Returns the z-translation of the torso.
        """
        return self.torso.localPosition[2] - self.TORSO_BASE_HEIGHT

    @service
    def get_torso_minmax(self):
        """
        Returns the minimum an maximum z-translation that the torso can
        make from the base.  Returns a list [min,max]
        """
        return [self.TORSO_LOWER, self.TORSO_UPPER]

    def default_action(self):
        """
        Main function of this component.
        """
        pass

########NEW FILE########
__FILENAME__ = quadrotor
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot


class Quadrotor(morse.core.robot.Robot):
    """
    Definition of a generic **quadrotor** without ``Rigid Body`` physics.
    It is expected to be used with actuators such as:

    - :doc:`../actuators/stabilized_quadrotor`

    .. example::
        from morse.builder import *

        quadrotor = QUAD2012()

        # place your component at the correct location
        quadrotor.translate(<x>, <y>, <z>)
        quadrotor.rotate(<rx>, <ry>, <rz>)

        # define one or several communication interface, like 'socket'
        quadrotor.add_interface(<interface>)

        env = Environment('empty')


    .. note::

        The rotation of the rotors is fixed and only for show. Its speed
        can be adjusted in the Logic panel in Blender (shown with
        :kbd:`F4`) when the **cube** object are selected.

    :noautoexample:
    """

    _name = 'Quadrotor'

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = quadrotor_dynamic
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot

class Quadrotor(morse.core.robot.Robot):
    """
    Simple definition of a quadrotor, with ``Rigid Body`` physics.

    It is expected to be used with actuators such as:
        - :doc:`../actuators/force_torque`
        - :doc:`../actuators/rotorcraft_attitude`
        - :doc:`../actuators/rotorcraft_waypoint`
    """

    _name = 'Quadrotor with dynamics'

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = rmax
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot

class RMax(morse.core.robot.Robot):
    """
    Simple definition of the **Yamaha RMAX** unmanned helicopter.

    .. note::

        The rotation of the rotor is fixed and only for show. Its speed
        can be adjusted in the Logic panel in Blender (shown with
        :kbd:`F4`) when the rotor object is selected.
    """

    _name = 'Yamaha RMAX platform'

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = segwayrmp400
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.wheeled_robot
from morse.helpers.components import add_property

class SegwayRMP400(morse.core.wheeled_robot.MorsePhysicsRobot):
    """
    Simple definition of the RMP400 platform distributed by Segway.

    This robot uses the Physics Constraints in Blender to allow the wheels to
    behave more realistically. The wheels turn as the robot moves, and they have
    ``Rigid Body`` physics, so that they can also have collisions with nearby
    objects.

    It has four differential drive wheels, with the pairs of wheels on each side
    always moving at the same speed. Since the wheels of this robot use the
    ``Rigid Body`` physics, it must be controlled with the :doc:`v_omega_diff_drive
    <../actuators/v_omega_diff_drive>` actuator.

    """

    _name = 'Segway RMP 400 platform'


    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            Optionally it gets the name of the object's parent,
            but that information is not currently used for a robot. """
        logger.info('%s initialization' % obj.name)

        # Call the constructor of the parent class
        morse.core.wheeled_robot.MorsePhysicsRobot.__init__(self, obj, parent)

        logger.info('Component initialized')


    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = submarine
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot

class Submarine(morse.core.robot.Robot):
    """
    A generic submarine robot. The robot has no mass and its physics is
    set to "NoCollision".
    """

    _name = 'Submarine robot'

    def __init__(self, obj, parent=None):
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        logger.info('Component initialized')

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = victim
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.robot
from morse.core.services import service


class Victim(morse.core.robot.Robot):
    """ Class definition for the pseudo-robot that represents
        a human victim. Mainly used for the ROSACE rescue scenario.
        Sub class of Morse_Object. """

    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            Optionally it gets the name of the object's parent,
            but that information is not currently used for a robot. """
        # Call the constructor of the parent class
        logger.info('%s initialization' % obj.name)
        morse.core.robot.Robot.__init__(self, obj, parent)

        if self.bge_object['Injured']:
            #  Set the mesh color to red
            obj.color = [1.0, 0.5, 0.5, 1.0]
        else:
            #  Set the mesh color to red
            obj.color = [1.0, 1.0, 1.0, 1.0]

        # Convert the 'Requirements' property,
        #  from a string to a list of integers
        obj['Requirements'] = [int(x) for x in obj['Requirements'].split(",")]

        logger.info('Component initialized')


    @service
    def heal(self):
        """ Change the status of the victim
        
        Change the material to a green color,
        and the status to healed.
        """
        if self.bge_object['Severity'] > 0:
            self.bge_object['Severity'] -= 1
            # Set the colors depending on the severity of the injuries
            red = 1 - self.bge_object['Severity'] * 0.05
            green = 0.5 + red
            self.bge_object.color = [red, green, 0.5, 1.0]

        # When fully healed, mark as not injured
        if self.bge_object['Severity'] == 0:
            self.bge_object['Injured'] = False


    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = accelerometer
import logging; logger = logging.getLogger("morse." + __name__)
import math
import morse.core.sensor
from morse.helpers.components import add_data

class Accelerometer(morse.core.sensor.Sensor):
    """ 
    This sensor emulates an Accelerometer/Podometer, measuring the
    distance that a robot has moved, the current speed and current
    acceleration. Measurements are done for the 3 axes (X, Y, Z) for
    velocity and acceleration. The values for velocity and acceleration
    are measured at each tic of the Game Engine, measuring the
    difference in distance from the previous tic, and the estimated time
    between tics (60 tics per second is the default in Blender).
    """

    _name = "Accelerometer"

    add_data('distance', 0.0, "float", 
             'distance travelled since the last tick, in meter')
    add_data('velocity', [0.0, 0.0, 0.0], "vec3<float>", 
             'Instantaneous speed in X, Y, Z, in meter sec^-1')
    add_data('acceleration', [0.0, 0.0, 0.0], "vec3<float>", 
             'Instantaneous acceleration in X, Y, Z, in meter sec^-2')

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        # Variables to store the previous position
        self.ppx = 0.0
        self.ppy = 0.0
        self.ppz = 0.0
        # Variables to store the previous velocity
        self.pvx = 0.0
        self.pvy = 0.0
        self.pvz = 0.0
        # Make a new reference to the sensor position
        self.p = self.bge_object.position
        self.v = [0.0, 0.0, 0.0]            # Velocity
        self.pv = [0.0, 0.0, 0.0]           # Previous Velocity
        self.a = [0.0, 0.0, 0.0]            # Acceleration

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)


    def default_action(self):
        """ Compute the speed and accleration of the robot

        The speed and acceleration are computed using the blender tics
        to measure time.
        When computing velocity as v = d / t, and t = 1 / frequency, then
        v = d * frequency
        where frequency is computed from the blender tics and number of skipped
        logic steps for this sensor.
        """
        # Compute the difference in positions with the previous loop
        dx = self.p[0] - self.ppx
        dy = self.p[1] - self.ppy
        dz = self.p[2] - self.ppz
        self.local_data['distance'] = math.sqrt(dx**2 + dy**2 + dz**2)
        logger.debug("DISTANCE: %.4f" % self.local_data['distance'])

        # Store the position in this instant
        self.ppx = self.p[0]
        self.ppy = self.p[1]
        self.ppz = self.p[2]

        # Scale the speeds to the time used by Blender
        self.v[0] = dx * self.frequency
        self.v[1] = dy * self.frequency
        self.v[2] = dz * self.frequency
        logger.debug("SPEED: (%.4f, %.4f, %.4f)" %
                    (self.v[0], self.v[1], self.v[2]))

        self.a[0] = (self.v[0] - self.pvx) * self.frequency
        self.a[1] = (self.v[1] - self.pvy) * self.frequency
        self.a[2] = (self.v[2] - self.pvz) * self.frequency
        logger.debug("ACCELERATION: (%.4f, %.4f, %.4f)" %
                     (self.a[0], self.a[1], self.a[2]))

        # Update the data for the velocity
        self.pvx = self.v[0]
        self.pvy = self.v[1]
        self.pvz = self.v[2]

        # Store the important data
        self.local_data['velocity'] = self.v
        self.local_data['acceleration'] = self.a

########NEW FILE########
__FILENAME__ = armature_pose
import logging; logger = logging.getLogger("morse." + __name__)
import math
import morse.core.sensor
from morse.core.services import service, async_service, interruptible
from morse.core import blenderapi
from morse.helpers.components import add_property

class ArmaturePose(morse.core.sensor.Sensor):
    """
    The sensor streams the joint state (ie, the rotation or translation value
    of each joint belonging to the armature) of its parent armature.

    .. note::

        This sensor **must** be added as a child of the armature
        you want to sense. See the *Examples* section below for an example.

    .. example::

        robot = ATRV()

        arm = KukaLWR()
        robot.append(arm)
        arm.translate(z=0.9)

        arm_pose = ArmaturePose()
        # the sensor is appended to the armature, *not* to the robot
        arm.append(arm_pose)

    This component only allows to *read* armature configuration. To change the
    armature pose, you need an :doc:`armature actuator <../actuators/armature>`.

    .. important:: 
    
        To be valid, special care must be given when creating armatures. If you
        want to add new one, please carefully read the :doc:`armature creation
        <../../dev/armature_creation>` documentation.


    .. note::

        The data structure on datastream exported by the armature sensor
        depends on the armature.  It is a dictionary of pair `(joint name,
        joint value)`.  Joint values are either radians (for revolute joints)
        or meters (for prismatic joints)


    :sees: :doc:`armature actuator <../actuators/armature>`
    :noautoexample:
    """
    _name = "Armature Pose Sensor"
    _short_desc = "Returns the joint state of a MORSE armature"

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        self.armature = self._get_armature(self.bge_object)
        if not self.armature:
            logger.error("The armature pose sensor has not been parented to an armature! " + \
                    "This sensor must be a child of an armature. Check you scene.")
            return

        logger.debug("Found armature <%s>" % self.armature.name)

        self._armature_actuator = None

        # Define the variables in 'local_data'
        for channel in self.armature.channels:
            self.local_data[channel.name] = 0.0

        logger.info('Component <%s> initialized, runs at %.2f Hz' % (self.bge_object.name, self.frequency))

    def _get_armature(self, obj):
        if hasattr(obj, "channels"):
            return obj
        elif not obj.parent:
            logger.error("Could not find parent armature from armature sensor <%s>!" % self.name())
            return None
        else:
            return self._get_armature(obj.parent)

    def _get_armature_actuator(self):
        # Get the reference to the class instance of the armature actuator
        component_dict = blenderapi.persistantstorage().componentDict
        if self.armature and self.armature.name in component_dict:
            self._armature_actuator = component_dict[self.armature.name]
        else:
            logger.error("Could not find armature actuator <%s> from armature sensor <%s>!" % (self.armature.name, self.name()))

    @service
    def get_joints(self):
        """
        Returns the list of joints of the armature.

        :return: the (ordered) list of joints in the armature, from root to tip.
        """
        return [c.name for c in self.armature.channels]

    @service
    def get_state(self):
        """
        Returns the joint state of the armature, ie a dictionnary with joint
        names as key and the corresponding rotation or translation as value
        (respectively in radian or meters).

        """
        joints = {}
        # get the rotation of each channel
        for channel in self.armature.channels:
            joints[channel.name] = self.get_joint(channel.name)

        return joints

    @service
    def get_joint(self, joint):
        """
        Returns the *value* of a given joint, either:
        - its absolute rotation in radian along its rotation axis, or
        - it absolute translation in meters along its translation axis.

        Throws an exception if the joint does not exist.

        :param joint: the name of the joint in the armature.
        """
        if not self._armature_actuator:
            self._get_armature_actuator()

        return self._armature_actuator._get_joint_value(joint) # reuse helper functions from armature actuator

    @service
    def get_joints_length(self):
        """
        Returns a dict with the armature joints' names as key and
        and the corresponding bone length as value (in meters).
        """
        lengths_dict = {}
        for channel in self.armature.channels:
            # find the length of the current channel
            #head = channel.pose_head
            #tail = channel.pose_tail
            diff = channel.pose_head - channel.pose_tail
            length = math.sqrt(diff[0]**2 + diff[1]**2 + diff[2]**2)
            lengths_dict[channel.name] = length
        return lengths_dict

    def default_action(self):
        """ Get the x, y, z, yaw, pitch and roll of the armature,
        and the rotation angle for each of the segments. """

        if not self.armature:
            return
        if not self._armature_actuator:
            self._get_armature_actuator()

        joints = self.get_state()
        for k,v in joints.items():
            self.local_data[k] = v

########NEW FILE########
__FILENAME__ = battery
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.sensor
from morse.helpers.components import add_data, add_property

class Battery(morse.core.sensor.Sensor):
    """
    This sensor emulates the remaining charge of a battery on the robot.
    It is meant to be used only as an informative measure, to be taken in
    consideration by the planning algorithms. It does not prevent the robot
    from working.

    The charge of the battery decreases with time, using a predefined
    **Discharge rate** specified as a property of the Blender object.
    This rate is independent of the actions performed by the robot, and
    only dependant on the time elapsed since the beginning of the simulation.

    If the battery enters in a **Charging zone**, the battery will
    gradually recharge.
    """

    _name = "Battery Sensor"

    add_property('_discharging_rate', 0.05, 'DischargingRate', "float",
                  "Battery discharging rate, in percent per seconds")

    add_data('charge', 100.0, "float", "Initial battery level, in percent")

    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            The second parameter should be the name of the object's parent. """
        logger.info("%s initialization" % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        self._time = self.robot_parent.gettime()

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)

    def default_action(self):
        """ Main function of this component. """
        charge = self.local_data['charge']
        dt = self.robot_parent.gettime() - self._time 

        if self.in_zones(type = 'Charging'):
            charge = charge + dt * self._discharging_rate
            if charge > 100.0:
                charge = 100.0
        else:
            charge = charge - dt * self._discharging_rate
            if charge < 0.0:
                charge = 0.0

        # Store the data acquired by this sensor that could be sent
        #  via a middleware.
        self.local_data['charge'] = float(charge)
        # update the current time
        self._time = self.robot_parent.gettime()

########NEW FILE########
__FILENAME__ = camera
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
import morse.core.sensor
from morse.helpers.components import add_property

def copy_pose(obj_from, obj_to):
    obj_to.worldPosition = obj_from.worldPosition
    obj_to.worldOrientation = obj_from.worldOrientation

class Camera(morse.core.sensor.Sensor):
    """
    A generic camera class, which is expected to be used as a base class
    for real camera. Concrete instantiation are currently:

    - :doc:`video_camera <../sensors/video_camera>`
    - :doc:`depth_camera <../sensors/depth_camera>`
    - :doc:`semantic_camera <../sensors/semantic_camera>`

    .. note::
        The cameras make use of Blender's **bge.texture** module, which
        requires a graphic card capable of GLSL shading. Also, the 3D view
        window in Blender must be set to draw **Textured** objects.

    .. note::
        The streaming of data from this sensor can be toggled off and on by
        pressing the SPACE key during the simulation. This will affect all the
        video cameras on the scene.

        Toggling off the cameras can help make the simulation run faster,
        specially when there are several cameras. However, the lack of
        data on the stream may cause problems to some middlewares.

    .. warning::
        Contrary to most of objects in Morse, the X axis of the camera
        is not "in front" of the camera. Here, Morse follows the
        "standard convention for camera", i.e.  X and Y are in the image
        plane, and Z is in the depth axis of the camera.
    """

    _name = "Generic Camera"
    _short_desc = "Base class for cameras in MORSE"

    # Set the values of image size from the variables
    #  in the Blender Logic Properties
    add_property('image_width', 256, 'cam_width')
    add_property('image_height', 256, 'cam_height')
    add_property('image_focal', 25.0, 'cam_focal')
    add_property('near_clipping', 0.1, 'cam_near')
    add_property('far_clipping', 100.0, 'cam_far')
    add_property('vertical_flip', False, 'Vertical_Flip')
    add_property('retrieve_depth', False, 'retrieve_depth')
    add_property('retrieve_zbuffer', False, 'retrieve_zbuffer')

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info("%s initialization" % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        # Set the background color of the scene
        self.bg_color = [143, 143, 143, 255]

        self._texture_ok = False
        self._camera_running = False

        self.scene_name = 'S.%dx%d' % (self.image_width, self.image_height)

        persistantstorage = morse.core.blenderapi.persistantstorage()
        parent_name = self.robot_parent.name()
        is_parent_external = False

        for robot in persistantstorage.externalRobotDict.keys():
            if robot.name == parent_name:
                is_parent_external = True
                break

        if not is_parent_external:
            logger.info("Adding scene %s" % self.scene_name)
            blenderapi.add_scene(self.scene_name, overlay=0)
        logger.info('Component initialized, runs at %.2f Hz', self.frequency)

    def default_action(self):
        """ Update the texture image. """
        # Configure the texture settings the first time the sensor is called
        if not self._texture_ok:
            self._texture_ok = True
            if blenderapi.isfastmode():
                logger.warning("Running in fastmode! No camera support!")
            else:
                # Prepare the camera object in Blender
                self._setup_video_texture()

                # Exit if the cameras could not be prepared
                if not blenderapi.hascameras():
                    logger.warning("Blender's bge.logic does not have the 'cameras' variable, \
                            something must have failed when configuring the cameras")
                else:
                    self._camera_running = True


        if self._camera_running:
            # Update all objects pose/orientation before to refresh the image
            self._update_scene()
            # Call the bge.texture method to refresh the image
            blenderapi.cameras()[self.name()].refresh(True)

    def _update_scene(self):
        for _to, _from in self._scene_syncable_objects:
            try:
                copy_pose(_from, _to)
            except Exception as e:
                logger.warning(str(e))

    def _setup_video_texture(self):
        """ Prepare this camera to use the bge.texture module.
        Extract the references to the Blender camera and material where
        the images will be rendered.
        """
        for child in self.bge_object.children:
            # The camera object that will produce the image in Blender
            if 'CameraRobot' in child.name:
                camera = child
            # The object that contains the material where the image is rendered
            if 'CameraMesh' in child.name:
                screen = child
                # Considering it consists of a single mesh
                mesh = child.meshes[0]
                # Get the material name
                for material in mesh.materials:
                    material_index = material.getMaterialIndex()
                    mesh_material_name = mesh.getMaterialName(material_index)
                    if 'MAScreenMat' in mesh_material_name:
                        material_name = mesh_material_name

        try:
            logger.debug("\tCAMERA: %s" % camera.name)
            logger.debug("\tSCREEN: %s" % screen.name)
            logger.debug("\tMATERIAL: %s" % material_name)
        except UnboundLocalError:
            logger.error("The video camera could not be properly initialized."
                         "The children object could not be found."
                         "Best solution is to re-link the camera.")
            return False

        # Get the reference to the scene
        scene_map = blenderapi.get_scene_map()
        logger.info("Scene %s from %s"% (self.scene_name, repr(scene_map.keys()) ) )
        self._scene = scene_map[self.scene_name]
        self._morse_scene = scene_map['S.MORSE_LOGIC']

        """
        Compute the relation between objects in the current scene and
        objects in the main logic scene.

        The logic is a bit complex, as in the case of group, we can have
        objects with the same name (but different ids). So, in this
        case, we follow the hierarchy on both scene to find
        correspondance (assuming no recursive group)

        known_ids is used to track objects alreay referenced and not
        include it twice (and possibly missing the fact that the same
        name can reference multiples different objects)

        I'm definitively not sure it is correct at all, it is a really
        really dark corner of Blender :). But it seems to do the job!
        """
        self._scene_syncable_objects = []
        known_ids = set()
        for obj in self._scene.objects:
            if obj.name != '__default__cam__' and id(obj) not in known_ids:
                members = obj.groupMembers
                if not members:
                    self._scene_syncable_objects.append(
                            (obj, self._morse_scene.objects[obj.name]))
                    known_ids.add(id(obj))
                else:
                    main_members = self._morse_scene.objects[obj.name].groupMembers
                    for i in range(0, len(main_members)):
                        self._scene_syncable_objects.append(
                                (members[i], main_members[i]))
                        known_ids.add(id(members[i]))
                        childs = members[i].childrenRecursive
                        main_childs = main_members[i].childrenRecursive
                        for child in childs:
                            self._scene_syncable_objects.append(
                                    (child, main_childs[child.name]))
                            known_ids.add(id(child))


        # Link the objects using bge.texture
        if not blenderapi.hascameras():
            blenderapi.initcameras()

        mat_id = blenderapi.texture().materialID(screen, material_name)
        vt_camera = blenderapi.texture().Texture(screen, mat_id)
        vt_camera.source = blenderapi.texture().ImageRender(self._scene, camera)

        # Set the focal length of the camera using the Game Logic Property
        camera.lens = self.image_focal
        logger.info("\tFocal length of the camera is: %s" % camera.lens)
        
        # Set the clipping distances of the camera using the Game Logic Property
        camera.near = self.near_clipping
        logger.info("\tNear clipping distance of the camera is: %s" %
                       camera.near)
        camera.far = self.far_clipping
        logger.info("\tFar clipping distance of the camera is: %s" %
                       camera.far)

        # Set the background to be used for the render
        vt_camera.source.background = self.bg_color
        # Define an image size. It must be powers of two. Default 512 * 512
        vt_camera.source.capsize = [self.image_width, self.image_height]
        logger.info("Camera '%s': Exporting an image of capsize: %s pixels" %
                (self.name(), vt_camera.source.capsize))

        # Reverse the image (boolean game-property)
        vt_camera.source.flip = self.vertical_flip

        try:
            # Use the Z-Buffer as an image texture for the camera
            if self.retrieve_zbuffer:
                vt_camera.source.zbuff = True
            # Use the Z-Buffer as input with an array of depths
            if self.retrieve_depth:
                vt_camera.source.depth = True
        except AttributeError as detail:
            logger.warn("%s\nPlease use Blender > 2.65 for Z-Buffer support" %
                        detail)

        blenderapi.cameras()[self.name()] = vt_camera

########NEW FILE########
__FILENAME__ = clock
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.sensor

class Clock(morse.core.sensor.Sensor):
    """ 
    This sensor returns the current time, measured by the robot (in s).
    """
    _name = "Clock"

    def __init__(self, obj, parent=None):
        """ Constructor method.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)


    def default_action(self):
        """
        Do nothing, we are only interested in the 'timestamp'
        automatically put by sensor.
        """
        pass

########NEW FILE########
__FILENAME__ = collision
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.sensor import Sensor
from morse.helpers.components import add_data, add_property
from morse.core import blenderapi

class Collision(Sensor):
    """
    Sensor to detect objects colliding with the current object,
    with more settings than the Touch sensor
    """
    _name = "Collision"
    _short_desc = "Detect objects colliding with the current object."

    add_data('collision', False, "bool", "objects colliding with the current object")
    add_data('objects', "", "string", "A list of colliding objects.")

    # These properties are not used directly in the logic, but are used
    # in the builder to create the radar properly.
    # These value cannot be changed dynamically in bge.
    add_property('_collision_property', "", 'collision_property', 'string',
                 'Only look for objects with this property, '
                 'default "" (all objects)')

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        Sensor.__init__(self, obj, parent)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)

    def default_action(self):
        """ Is currently in collision """
        controller  = blenderapi.controller()
        sensor = controller.sensors[-1]
        # see hitObjectList and hitObject for last collided object(s)
        self.local_data['collision'] = sensor.positive
        self.local_data['objects'] = ','.join([o.name for o in sensor.hitObjectList])
        # logger.debug(self.local_data['objects'])

########NEW FILE########
__FILENAME__ = compound
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.sensor
from morse.core import blenderapi
from morse.helpers.components import add_property

class CompoundSensor(morse.core.sensor.Sensor):
    """
    This special sensor is constructed by passing a list of other sensors, and
    creates a new datastream from the concatenation of other sensors'
    `local_data`.

    More accurately, it streams a dictionary of `{<sensor name>: <sensor
    local_data>}`.

    Note that services exposed by original sensors *are not* exposed by the
    compound sensor.

    :noautoexample:
    """
    _name = "Compound Sensor"
    _short_desc = "Special sensor that merges other sensors' outputs"

    # Set the values of image size from the variables
    #  in the Blender Logic Properties
    add_property('sensors', [], 'sensors', "The list of sensor names to merge.")

    def __init__(self, obj, parent=None):
        """ Constructor method.

        The object *must* have a property listing the sensors names to
        merge in this compound sensor. These sensors must be children (direct
        or not) of the parent of the compound sensor.

        Receives the reference to the Blender object.
        The second parameter is the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        if not self.sensors:
            logger.error("The compound sensor <%s> has no sensors list associated!" % obj.name)
            return

        self._initialized = False

    def _get_sensors_references(self):
        # Get the reference to all components
        component_dict = blenderapi.persistantstorage().componentDict

        for s in self.sensors.split(','):
            if s in component_dict:
                self.local_data[s] = component_dict[s].local_data
            else:
                logger.warning("Sensor <%s> not found while creating compound sensor <%s>!" % (s, self.name()))

        if self.local_data:
            logger.info('Compound sensor <%s> initialized with sensors %s' % (self.name(), list(self.local_data.keys())))
        else:
            logger.error("The compound sensor <%s> found none of the expected sensors!" % self.name())


    def default_action(self):
        """
        Default action does nothing at all, since self.local_data stores
        references to sub sensors' local_data, so it get updated for free.
        """
        if not self._initialized:
            self._get_sensors_references()
            self._initialized = True

########NEW FILE########
__FILENAME__ = depth_camera
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import async_service
from morse.core import status, mathutils
import morse.core.blenderapi
from morse.sensors.camera import Camera
from morse.sensors.video_camera import VideoCamera
from morse.helpers.components import add_data, add_property

class AbstractDepthCamera(VideoCamera):

    add_property('near_clipping', 1.0, 'cam_near')
    add_property('far_clipping', 20.0, 'cam_far')
    add_property('retrieve_depth', True, 'retrieve_depth')

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        # Call the constructor of the VideoCamera class
        VideoCamera.__init__(self, obj, parent)
        # Component specific initialize (converters)
        self.initialize()

    # abstractmethod
    def process_image(self, image):
        pass
    # abstractmethod
    def initialize(self):
        pass

    def default_action(self):
        """ Update the texture image. """
        # Grab an image from the texture
        if self.bge_object['capturing'] and (self._n != 0) :

            # Call the action of the Camera class
            Camera.default_action(self)

            self.process_image(morse.core.blenderapi.cameras()[self.name()].source)

            self.capturing = True

            if self._n > 0:
                self._n -= 1
                if self._n == 0:
                    self.completed(status.SUCCESS)
        else:
            self.capturing = False



class DepthCamera(AbstractDepthCamera):
    """
    This sensor generates a 3D point cloud from the camera perspective.

    See also :doc:`../sensors/camera` for generic informations about Morse cameras.
    """

    _name = "Depth (XYZ) camera"
    _short_desc = "A camera capturing 3D points cloud"

    add_data('points', 'none', 'memoryview', "List of 3D points from the depth "
             "camera. memoryview of a set of float(x,y,z). The data is of size "
             "``(nb_points * 12)`` bytes (12=3*sizeof(float).")
    add_data('nb_points', 0, 'int', "the number of points found in the "
             "points list. It must be inferior to cam_width * cam_height")

    def initialize(self):
        from morse.sensors.zbufferto3d import ZBufferTo3D
        # Store the camera parameters necessary for image processing
        self.converter = ZBufferTo3D(self.local_data['intrinsic_matrix'][0][0],
                                     self.local_data['intrinsic_matrix'][1][1],
                                     self.near_clipping, self.far_clipping,
                                     self.image_width, self.image_height)

    def process_image(self, image):
        pts = self.converter.recover(image)
        self.local_data['points'] = pts
        self.local_data['nb_points'] = int(len(pts) / 12)


class DepthVideoCamera(AbstractDepthCamera):
    """
    This sensor generates a Depth 'image' from the camera perspective.

    "Depth images are published as sensor_msgs/Image encoded as 32-bit float.
    Each pixel is a depth (along the camera Z axis) in meters."
    [ROS Enhancement Proposal 118](http://ros.org/reps/rep-0118.html) on Depth
    Images.

    If you are looking for PointCloud data, you can use external tools like
    [depth_image_proc](http://ros.org/wiki/depth_image_proc) which will use the
    ``intrinsic_matrix`` and the ``image`` to generate it, or eventually the
    ``XYZCameraClass`` in this module.
    """

    _name = "Depth camera"

    add_data('image', 'none', 'buffer', "Z-Buffer captured by the camera, "
             "converted in meters. memoryview of float of size "
             "``(cam_width * cam_height * sizeof(float))`` bytes.")

    def initialize(self):
        from morse.sensors.zbuffertodepth import ZBufferToDepth
        # Store the camera parameters necessary for image processing
        self.converter = ZBufferToDepth(self.near_clipping, self.far_clipping,
                                        self.image_width, self.image_height)

    def process_image(self, image):
        # Convert the Z-Buffer
        self.local_data['image'] = self.converter.recover(image)


class RawImage(AbstractDepthCamera):
    """
    This sensor gets raw Z-Buffer from the camera perspective.

    See also :doc:`../sensors/camera` for generic informations about Morse cameras.
    """

    _name = "Depth camera (raw Z-Buffer)"

    add_data('image', 'none', 'buffer', "Raw Z-Buffer captured by the camera, "
             "not converted. bgl.Buffer of float of size "
             "``(cam_width * cam_height * sizeof(float))`` bytes.")

    def process_image(self, image):
        """Same behaviour as VideoCamera

        Let the middleware deal with image processing. For example convert and
        publish in C++, without having to re-serialize a Python object.
        """
        self.local_data['image'] = image


class DepthCameraRotationZ(DepthCamera):
    """Used for Velodyne sensor"""

    add_property('rotation', 0.01745, 'rotation')

    def default_action(self):
        DepthCamera.default_action(self)
        self.applyRotationZ(self.rotation)
    def applyRotationZ(self, rotation):
        # The second parameter specifies a "local" movement
        self.bge_object.applyRotation([0, rotation, 0], True)

########NEW FILE########
__FILENAME__ = gps
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.sensor
from morse.helpers.components import add_property, add_data, add_level
import math, time
from morse.core import mathutils
from morse.core import blenderapi

class GPS(morse.core.sensor.Sensor):
    """
    A GPS sensor which returns the position either in Blender or Geodetic coordinates.

    This sensor always provides perfect data on the levels "raw" and "extended".
    To obtain more realistic readings, it is recommended to add modifiers.

    - **Noise modifier**: Adds random Gaussian noise to the data

    coordinates in Blender: :math:`x` -> east and :math:`y` -> north

    The "heading" is Clockwise (mathematically negative).


    Conversion of Geodetic coordinates into ECEF-r, LTP into ECEF-r and vice versa
    ------------------------------------------------------------------------------

    Conversion of Geodetic coordinates into ECEF-r
    ++++++++++++++++++++++++++++++++++++++++++++++

    To be able to simulate a GPS-sensor :math:`P` (the Blender origin) must
    be defined in the properties in Geodetic coordinates (longitude,
    latitude, altitude).  For the transformation [Psas_] the
    coordinates must be in decimal degrees (no North, minutes,
    etc.). The result is a point :math:`x_0` in the ``ECEF-r`` coordinates.


    Conversion of ECEF-r into LTP[Psas_]
    ++++++++++++++++++++++++++++++++++++

    For this conversion :math:`x_0` is the base. A point :math:`x_e` is given
    in the ``ECEF-r`` coordinates and the goal is to get :math:`x_t` (:math:`=
    x_e` in the ``LTP``-coordinates).

    .. image:: ../../../media/conversion_coordinates.png

    1. Transform :math:`P` (Blender origin, geodetic coordinates
    (stored in the properties)) into :math:`x0` (geocentric (``ECEF-r``)
    coordinates)

    2. Calculate :math:`R_{te}[1]` with longitude, latitude and altitude;
    matrix is the rotation part of the transformation

    3. Transform :math:`x_e` into :math:`x_t` with :math:`x_t = R_{te} * (x_e-x_0)`


    Conversion of LTP into ECEF-r
    +++++++++++++++++++++++++++++

    Known: :math:`P` in Geodetic coordinates ( :math:`x_0` in ``ECEF-r``) and
    :math:`x_t` in ``LTP``-coordinates

    Goal: :math:`x_e` (:math:`= x_t` in ``ECEF-r`` coordinates)

    Based on the transformation described above the transformation is
    calculated with the transposed matrix :math:`R_{te}`: :math:`x_e = x_0 +
    (R_{te})' * x_t` [Psas_]

    Conversion of ECEF-r into Geodetic coordinates
    ++++++++++++++++++++++++++++++++++++++++++++++

    The last transformation is from ``ECEF-r`` coordinates into Geodetic
    coordinates.  This transformation is calculated with the Vermeille's method
    [FoIz_].  The result is the point :math:`x_e` in "GPS-coordinates" in
    radians.

    Sources
    +++++++

    .. _FoIz: 

     "3.4 Vermeille's Method(2002)" in
     "Comparative Analysis of the Performance of Iterative and
     Non-iterative Solutions to the Cartesian to Geodetic Coordinate
     Transformation", Hok Sum Fok and H. Bki Iz,
     http://www.lsgi.polyu.edu.hk/staff/zl.li/Vol_5_2/09-baki-3.pdf

    .. _Psas:

     "Conversion of Geodetic coordinates to the Local Tangent
     Plane", Version 2.01,
     http://psas.pdx.edu/CoordinateSystem/Latitude_to_LocalTangent.pdf
    """

    _name = "GPS"
    
    _short_desc = "A GPS sensor that returns coordinates ."

    add_level("simple", None,
              doc = "simple GPS: only current position in Blender is exported",
              default = True)
    add_level("raw", "morse.sensors.gps.RawGPS",
              doc = "raw GPS: position in Geodetic coordinates and velocity \
                      are exported")
    add_level("extended", "morse.sensors.gps.ExtendedGPS",
              doc = "extended GPS: adding information to fit a standard \
                      GPS-sentence")

    add_data('x', 0.0, "float",
             'x coordinate of the sensor, in world coordinate, in meter',
             level = "simple")
    add_data('y', 0.0, "float",
             'y coordinate of the sensor, in world coordinate, in meter',
             level = "simple")
    add_data('z', 0.0, "float",
             'z coordinate of the sensor, in world coordinate, in meter',
             level = "simple")
    add_data('longitude', 0.0, "double",
             'longitude in degree [-180,180] or [0,360]', level = ["raw", "extended"])
    add_data('latitude', 0.0, "double",
             'latitude in degree [-90,90]', level = ["raw", "extended"])
    add_data('altitude', 0.0, "double",
             'altitude in m a.s.l.', level = ["raw", "extended"])
    add_data('velocity', [0.0, 0.0, 0.0], "vec3<float>",
             'Instantaneous speed in X, Y, Z, in meter sec^-1', level = ["raw", "extended"])
    add_data('date', 0000000, "DDMMYY",
             'current date in DDMMYY-format', level = "extended")
    add_data('time', 000000, "HHMMSS",
             'current time in HHMMSS-format', level = "extended")
    add_data('heading', 0, "float",
             'heading in degrees [0,360] to geographic north',
             level = "extended")

    add_property('longitude', 0.0, 'longitude', 'double',
                 'longitude in degree [-180,180] or [0,360] of the \
                  Blender origin')
    add_property('latitude', 0.0, 'latitude', 'double',
             'latitude in degree [-90,90] of the Blender origin')
    add_property('altitude', 0.0, 'altitude', 'double',
             'altitude in m a.s.l. of the Blender origin')

    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            The second parameter should be the name of the object's parent. """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)


    def default_action(self):
        """
        Main function of this component.
        """
        x = self.position_3d.x
        y = self.position_3d.y
        z = self.position_3d.z

        # Store the data acquired by this sensor that could be sent
        #  via a middleware.
        self.local_data['x'] = float(x)
        self.local_data['y'] = float(y)
        self.local_data['z'] = float(z)

class RawGPS(GPS):
    """
    This sensor emulates a GPS, providing the exact coordinates in the
    Blender scene. The coordinates provided by the GPS are with respect
    to the origin of the Blender coordinate reference.
    """

    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            The second parameter should be the name of the object's parent. """
        # Call the constructor of the parent class
        GPS.__init__(self, obj, parent)
        
        ##copied from accelerometer
        # Variables to store the previous position
        self.ppx = 0.0
        self.ppy = 0.0
        self.ppz = 0.0
        # Variables to store the previous velocity
        self.pvx = 0.0
        self.pvy = 0.0
        self.pvz = 0.0
        # Make a new reference to the sensor position
        self.p = self.bge_object.position
        self.v = [0.0, 0.0, 0.0] # Velocity
        self.pv = [0.0, 0.0, 0.0] # Previous Velocity

    
    def default_action(self):
        """
        Calculates speed and GPS-position

        Configurations are the GPS-values for the Blenderorigin
        Transforms point from LTP to Geodetic coordinates

        Refer to:
        - Conversion of Geodetic coordinates to the Local Tangent Plane,
          Version 2.01,
          http://psas.pdx.edu/CoordinateSystem/Latitude_to_LocalTangent.pdf
        - Comparative Analysis of the Performance of Iterative and Non-iterative
          Solutions to the Cartesian to Geodetic Coordinate Transformation, 
          Hok Sum Fok and H.   Bki Iz,
          http://www.lsgi.polyu.edu.hk/staff/zl.li/Vol_5_2/09-baki-3.pdf
        """

        ####
        #Speed
        ####
        ##copied from accelerometer
        # Compute the difference in positions with the previous loop
        self.dx = self.p[0] - self.ppx
        self.dy = self.p[1] - self.ppy
        self.dz = self.p[2] - self.ppz

        # Store the position in this instant
        self.ppx = self.p[0]
        self.ppy = self.p[1]
        self.ppz = self.p[2]

        # Scale the speeds to the time used by Blender
        self.v[0] = self.dx * self.frequency
        self.v[1] = self.dy * self.frequency
        self.v[2] = self.dz * self.frequency

        # Update the data for the velocity
        self.pvx = self.v[0]
        self.pvy = self.v[1]
        self.pvz = self.v[2]


        ####
        #GPS
        ####

        ####
        #constants in calculations
        #a: WGS-84 Earth semimajor axis
        #ecc: first eccentricity
        ####
        a  = float(6378137)
        ecc = 8.181919191e-2

        def convert_GPS_to_ECEF(P):
            """
            converts gps-data(radians) to ECEF-r coordinates
            """
            N = a/math.sqrt(1-(ecc**2*(math.sin(P[1])**2)))
            h = P[2]
            x0 = [ (h + N)*math.cos(P[1])*math.cos(P[0]),
                   (h + N)*math.cos(P[1])*math.sin(P[0]),
                   (h + (1 - ecc**2) * N)*math.sin(P[1])]
            return x0

        def convert_LTP_to_ECEF(P):
            """
            converts point in LTP(Blender) to ECEF-r coordinates
            """
            x0 = convert_GPS_to_ECEF(P) #P->x0
            x0 = mathutils.Vector(x0)
            transform_matrix = [[-math.sin(P[0]), math.cos(P[0]), 0],
               [-math.cos(P[0]) * math.sin(P[1]), 
                -math.sin(P[1])*math.sin(P[0]), math.cos(P[1])],
               [math.cos(P[1])*math.cos(P[0]), math.cos(P[1])*math.sin(P[0]), math.sin(P[1])]]
            transform_matrix = mathutils.Matrix(transform_matrix)
            transform_matrix.invert()
            xe = x0 + transform_matrix*xt  #transformed xt -> xe
            return xe

        def vermeille_method(xe):
            """
            converts point in ECEF-r coordinates into Geodetic (GPS) via
            Vermeille's method
            """
            #"just intermediary parameters" see FoIz
            p = (xe[0]**2+xe[1]**2)/a**2
            q = (1-ecc**2)/a**2*xe[2]**2
            r = (p+q-ecc**4)/6
            s = ecc**4 * (p*q)/(4*r**3)
            t = (1+s+math.sqrt(s*(2+s)))**(1/3.0)
            u = r*(1+t+1/t)
            v = math.sqrt(u**2+(ecc**4*q))
            w = ecc**2*((u+v-q)/(2*v))
            k = math.sqrt(u+v+w**2)-w
            D = (k*(math.sqrt(xe[0]**2+xe[1]**2)))/(k+ecc**2)
            gps_coords = [2*math.atan(xe[1]/(xe[0]+(math.sqrt(xe[0]**2+xe[1]**2)))),
                          2*math.atan(xe[2]/(D+math.sqrt(D**2+xe[2]**2))),
                         ((k+ecc**2-1)/k)*math.sqrt(D**2+xe[2]**2)]
            return gps_coords

        #P -> Blender origin in Geodetic coordinates
        P = [self.longitude, self.latitude, self.altitude]

        #current position
        xt = self.position_3d.translation
        xt = mathutils.Vector(xt)

        #P (in degrees) to radians
        for i in range(len(P)-1):
            P[i] = math.radians(P[i])

        ####
        #GPS -> ECEF-r
        ####
        xe = convert_LTP_to_ECEF(P)

        ####
        #ECEF-r -> GPS
        ####
        gps_coords = vermeille_method(xe)

        #gps_coords (in radians) to degrees
        for i in range(len(gps_coords)-1):
            gps_coords[i] = math.degrees(gps_coords[i])


        #compose message as close as possible to a GPS-standardprotocol
        self.local_data['longitude'] = gps_coords[0]
        self.local_data['latitude'] = gps_coords[1]
        self.local_data['altitude'] = gps_coords[2]
        self.local_data['velocity'] = self.v

class ExtendedGPS(RawGPS):
    """
    Additional information to fit a standard GPS-sentence
    """
    def __init__(self, obj, parent=None):
        """
        Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent. 
        """
        # Call the constructor of the parent class
        RawGPS.__init__(self, obj, parent)

    def default_action(self):
        """
        Adds additional information (date, time and heading) to the
        message of the RawGPS
        """
        # Call the default_action of the parent class
        RawGPS.default_action(self)
        current_time = time.gmtime(blenderapi.persistantstorage().current_time)
        date = time.strftime("%d%m%y", current_time)
        time_h_m_s = time.strftime("%H%M%S", current_time)
        heading = (2*math.pi - math.atan2(self.dy, self.dx) + math.pi/2)%(2*math.pi)
        self.local_data['date'] = date
        self.local_data['time'] = time_h_m_s   
        self.local_data['heading'] = math.degrees(heading)


########NEW FILE########
__FILENAME__ = gyroscope
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.sensor
from morse.helpers.components import add_data

class Gyroscope(morse.core.sensor.Sensor):
    """
    This sensor emulates a Gyroscope, providing the yaw, pitch and roll
    angles of the sensor object with respect to the Blender world
    reference axes.

    Angles are given in radians.
    """

    _name = "Gyroscope"

    add_data('yaw', 0.0, "float",
             'rotation around the Z axis of the sensor, in radian')
    add_data('pitch', 0.0, "float",
             'rotation around the Y axis of the sensor, in radian')
    add_data('roll', 0.0, "float",
             'rotation around the X axis of the sensor, in radian')

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)


    def default_action(self):
        """ Get the yaw, pitch and roll of the blender object. """
        yaw = self.position_3d.yaw
        pitch = self.position_3d.pitch
        roll = self.position_3d.roll

        # Store the values in the robot's object
        self.robot_parent.yaw = yaw
        self.robot_parent.pitch = pitch
        self.robot_parent.roll = roll

        # Store the data acquired by this sensor that could be sent
        #  via a middleware.
        self.local_data['yaw'] = float(yaw)
        self.local_data['pitch'] = float(pitch)
        self.local_data['roll'] = float(roll)

########NEW FILE########
__FILENAME__ = human_posture
import logging; logger = logging.getLogger("morse." + __name__)
import math
import morse.core.sensor
from morse.helpers.components import add_data

class HumanPosture(morse.core.sensor.Sensor):
    """ 
    This sensor collects the positions of the bones in the human armature
    for the file ``$MORSE_ROOT/data/robots/human.blend``.

    It stores the position and orientation of the general armature
    object, as well as the local rotation of each individual bone. The
    rotation angles are given in radians.

    This sensor will only work for the ``human.blend`` model, as it
    uses a specific naming convention for each of the bones.

    You can also check to general documentation of the :doc:`human
    component <../others/human>`.

    .. image:: ../../../media/human_joints.png
      :align: center
      :width: 600
    """

    _name = "Human Posture"

    add_data('x', 0.0, "float",
             'global X position of the armature in the scene, in meter')
    add_data('y', 0.0, "float",
             'global Y position of the armature in the scene, in meter')
    add_data('z', 0.0, "float",
             'global Z position of the armature in the scene, in meter')
    add_data('yaw', 0.0, "float",
             'rotation angle with respect to the Z axis, in radian')
    add_data('pitch', 0.0, "float",
             'rotation angle with respect to the Y axis, in radian')
    add_data('roll', 0.0, "float",
             'rotation angle with respect to the X axis, in radian')
    add_data('empty1', 0.0, "float")
    add_data('empty2', 0.0, "float")
    add_data('empty3', 0.0, "float")
    add_data('empty4', 0.0, "float")
    add_data('empty5', 0.0, "float")
    add_data('empty6', 0.0, "float")

    add_data('dof_12', 0.0, 'float',
             'rotation around the X axis for the torso, in radian')
    add_data('dof_13', 0.0, 'float',
             'rotation around the Y axis for the torso, in radian')
    add_data('dof_14', 0.0, 'float',
             'rotation around the Z axis for the torso, in radian')

    add_data('dof_15', 0.0, 'float',
             'rotation around the Z axis for the head, in radian')
    add_data('dof_16', 0.0, 'float',
             'rotation around the Y axis for the head, in radian')
    add_data('dof_17', 0.0, 'float',
             'rotation around the X axis for the head, in radian')

    add_data('dof_18', 0.0, 'float',
             'rotation around the X axis for the right shoulder, in radian')
    add_data('dof_19', 0.0, 'float',
             'rotation around the Y axis for the right shoulder, in radian')
    add_data('dof_20', 0.0, 'float',
             'rotation around the Z axis for the right shoulder, in radian')

    add_data('dof_21', 0.0, 'float',
             'elongation of the right arm, in meter')

    add_data('dof_22', 0.0, 'float',
            'rotation around the Z axis for the right elbow, in radian')

    add_data('dof_23', 0.0, 'float', 'R_POINT')

    add_data('dof_24', 0.0, 'float',
             'rotation around the X axis for the right wrist, in radian')
    add_data('dof_25', 0.0, 'float',
             'rotation around the Y axis for the right wrist, in radian')
    add_data('dof_26', 0.0, 'float',
             'rotation around the Z axis for the right wrist, in radian')

    add_data('dof_27', 0.0, 'float',
            'rotation around the X axis for the left shoulder, in radian')
    add_data('dof_28', 0.0, 'float',
            'rotation around the Y axis for the left shoulder, in radian')
    add_data('dof_29', 0.0, 'float',
            'rotation around the Z axis for the left shoulder, in radian')

    add_data('dof_30', 0.0, 'float',
             'elongation of the left arm, in meter')

    add_data('dof_31', 0.0, 'float',
             'rotation around the Z axis for the left elbow, in radian')

    add_data('dof_32', 0.0, 'float', 'L_POINT')

    add_data('dof_33', 0.0, 'float', 
            'rotation around the X axis for the left wrist, in radian')
    add_data('dof_34', 0.0, 'float', 
            'rotation around the Y axis for the left wrist, in radian')
    add_data('dof_35', 0.0, 'float', 
            'rotation around the Z axis for the left wrist, in radian')

    add_data('dof_36', 0.0, 'float', 
            'rotation around the X axis for the right hip, in radian')
    add_data('dof_37', 0.0, 'float', 
            'rotation around the Y axis for the right hip, in radian')
    add_data('dof_38', 0.0, 'float', 
            'rotation around the Z axis for the right hip, in radian')

    add_data('dof_39', 0.0, 'float',
            'rotation around the Z axis for the right knee, in radian')

    add_data('dof_40', 0.0, 'float',
            'rotation around the X axis for the right ankle, in radian')
    add_data('dof_41', 0.0, 'float',
            'rotation around the Y axis for the right ankle, in radian')
    add_data('dof_42', 0.0, 'float',
            'rotation around the Z axis for the right ankle, in radian')

    add_data('dof_43', 0.0, 'float',
             'rotation around the X axis for the left hip, in radian')
    add_data('dof_44', 0.0, 'float',
             'rotation around the Y axis for the left hip, in radian')
    add_data('dof_45', 0.0, 'float',
             'rotation around the Z axis for the left hip, in radian')

    add_data('dof_46', 0.0, 'float',
             'rotation around the Z axis for the left knee, in radian')

    add_data('dof_47', 0.0, 'float',
             'rotation around the X axis for the left ankle, in radian')
    add_data('dof_48', 0.0, 'float',
             'rotation around the Y axis for the left ankle, in radian')
    add_data('dof_49', 0.0, 'float',
             'rotation around the Z axis for the left ankle, in radian')

    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            The second parameter should be the name of the object's parent. """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)

    def _read_pose(self, armature):

        for channel in armature.channels:
            if 'X_' not in channel.name:
                logger.debug("\tChannel '%s': (%.4f, %.4f, %.4f)" %
                                        (channel,
                                         channel.joint_rotation[0],
                                         channel.joint_rotation[1],
                                         channel.joint_rotation[2]))
                if channel.name == 'Chest':
                    self.local_data['dof_12'] = channel.joint_rotation[2] #y
                    self.local_data['dof_13'] = channel.joint_rotation[0] #x
                    self.local_data['dof_14'] = channel.joint_rotation[1] #z
                if channel.name == 'Head':
                    self.local_data['dof_15'] = - channel.joint_rotation[0] #z axis
                    self.local_data['dof_16'] = channel.joint_rotation[2] #x axis
                    self.local_data['dof_17'] = channel.joint_rotation[1] #y axis

                if channel.name == 'UpArm.R':
                    self.local_data['dof_18'] = - channel.joint_rotation[1]
                    self.local_data['dof_19'] = - channel.joint_rotation[0]
                    self.local_data['dof_20'] = channel.joint_rotation[2]
                if channel.name == 'ForeArm.R':
                    self.local_data['dof_21'] = channel.joint_rotation[2]
                if channel.name == 'Hand.R':
                    self.local_data['dof_22'] = channel.joint_rotation[0]
                    self.local_data['dof_23'] = channel.joint_rotation[1]
                    self.local_data['dof_24'] = channel.joint_rotation[2]
                 
                if channel.name == 'UpArm.L':
                    self.local_data['dof_25'] = - channel.joint_rotation[1]
                    self.local_data['dof_26'] = - channel.joint_rotation[0]
                    self.local_data['dof_27'] = channel.joint_rotation[2]
                if channel.name == 'ForeArm.L':
                    self.local_data['dof_28'] = channel.joint_rotation[2]
                if channel.name == 'Hand.L':
                    self.local_data['dof_29'] = channel.joint_rotation[0]
                    self.local_data['dof_30'] = channel.joint_rotation[1]
                    self.local_data['dof_31'] = channel.joint_rotation[2]
                 
                if channel.name == 'UpLeg.R' :
                    self.local_data['dof_32'] = channel.joint_rotation[1]
                    self.local_data['dof_33'] = channel.joint_rotation[0]
                    self.local_data['dof_34'] = - channel.joint_rotation[2]
                if channel.name == 'LoLeg.R':
                    self.local_data['dof_35'] = channel.joint_rotation[0]
                if channel.name == 'Foot.R':
                    self.local_data['dof_36'] = channel.joint_rotation[0]
                    self.local_data['dof_37'] = channel.joint_rotation[1]
                    self.local_data['dof_38'] = channel.joint_rotation[2]
                 
                if channel.name == 'UpLeg.L':
                    self.local_data['dof_39'] = channel.joint_rotation[1]
                    self.local_data['dof_40'] = channel.joint_rotation[0]
                    self.local_data['dof_41'] = - channel.joint_rotation[2]
                if channel.name == 'LoLeg.L':
                    self.local_data['dof_42'] = channel.joint_rotation[0]
                if channel.name == 'Foot.L':
                    self.local_data['dof_43'] = channel.joint_rotation[0]
                    self.local_data['dof_44'] = channel.joint_rotation[1]
                    self.local_data['dof_45'] = channel.joint_rotation[2]


    def default_action(self):
        """ Extract the human posture """
        self.local_data['x'] = float(self.position_3d.x)
        self.local_data['y'] = float(self.position_3d.y)
        self.local_data['z'] = float(self.position_3d.z)
        self.local_data['yaw'] = float(self.position_3d.yaw) - (math.pi/2)
        self.local_data['pitch'] = float(self.position_3d.pitch)
        self.local_data['roll'] = float(self.position_3d.roll)

        self._read_pose(self.bge_object)

        logger.debug("LOCAL_DATA: ", self.local_data)

########NEW FILE########
__FILENAME__ = imu
import logging; logger = logging.getLogger("morse." + __name__)
import math
import morse.core.sensor
from morse.core import mathutils, blenderapi
from morse.helpers.components import add_data

"""
Important note:

    The 'logger.debug' instructions take some processor work, even if they are
    not displayed. For this reason, it is best to comment out these lines in
    the 'default_action' method.
"""

class IMU(morse.core.sensor.Sensor):
    """
    This sensor emulates an Inertial Measurement Unit (IMU), measuring
    the angular velocity and linear acceleration including acceleration
    due to gravity.

    If the robot has a physics controller, the velocities are directly
    read from it's properties ``localAngularVelocity`` and
    ``worldLinearVelocity``. Otherwise the velocities are calculated by
    simple differentiation. Linear acceleration is always computed by
    differentiation of the linear velocity. The measurements are given
    in the IMU coordinate system, so the location and rotation of the
    IMU with respect to the robot is taken into account.
    """

    _name = "Inertial measurement unit"

    add_data('angular_velocity', [0.0, 0.0, 0.0], "vec3<float>",
             'rates in IMU x, y, z axes (in radian . sec ^ -1)')
    add_data('linear_acceleration', [0.0, 0.0, 0.0], "vec3<float>",
             'acceleration in IMU x, y, z axes (in m . sec ^ -2)')

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        # The robot needs a physics controller!
        # Since the imu does not have physics,
        self.has_physics = bool(self.robot_parent.bge_object.getPhysicsId())

        if not self.has_physics:
            logger.warning("The robot doesn't have a physics controller,"
                           "falling back to simple IMU sensor.")

        if self.has_physics:
            # make new references to the robot velocities and use those.
            self.robot_w = self.robot_parent.bge_object.localAngularVelocity
            self.robot_vel = self.robot_parent.bge_object.worldLinearVelocity
        else:
            # reference to sensor position
            self.pos = self.bge_object.worldPosition
            # previous position
            self.pp = self.pos.copy()
            # previous attitude euler angles as vector
            self.patt = mathutils.Vector(self.position_3d.euler)

        # previous linear velocity
        self.plv = mathutils.Vector((0.0, 0.0, 0.0))
        # previous angular velocity
        self.pav = mathutils.Vector((0.0, 0.0, 0.0))

        self.gravity = - blenderapi.gravity()

        # imu2body will transform a vector from imu frame to body frame
        self.imu2body = self.sensor_to_robot_position_3d()
        # rotate vector from body to imu frame
        self.rot_b2i = self.imu2body.rotation.conjugated()
        logger.debug("imu2body rotation RPY [% .3f % .3f % .3f]" % tuple(math.degrees(a) for a in self.imu2body.euler))
        logger.debug("imu2body translation [% .3f % .3f % .3f]" % tuple(self.imu2body.translation))

        if self.imu2body.translation.length > 0.01:
            self.compute_offset_acceleration = True
        else:
            self.compute_offset_acceleration = False

        # reference for rotating a vector from imu frame to world frame
        self.rot_i2w = self.bge_object.worldOrientation

        logger.info("IMU Component initialized, runs at %.2f Hz ", self.frequency)

    def sim_imu_simple(self):
        """
        Simulate angular velocity and linear acceleration measurements via simple differences.
        """

        # Compute the differences with the previous loop
        #dp = self.pos - self.pp
        #deuler = mathutils.Vector(self.position_3d.euler - self.peuler)

        # linear and angular velocities
        lin_vel = (self.pos - self.pp) * self.frequency
        att = mathutils.Vector(self.position_3d.euler)
        ang_vel = (att - self.patt) * self.frequency

        # linear acceleration in imu frame
        dv_imu = self.rot_i2w.transposed() * (lin_vel - self.plv) * self.frequency

        # measurement includes gravity and acceleration
        accel_meas = dv_imu + self.rot_i2w.transposed() * self.gravity

        # save current position and attitude for next step
        self.pp = self.pos.copy()
        self.peuler = att
        # save velocity for next step
        self.plv = lin_vel
        self.pav = ang_vel

        return ang_vel, accel_meas

    def sim_imu_with_physics(self):
        """
        Simulate angular velocity and linear acceleration measurements using the physics of the robot.
        """

        # rotate the angular rates from the robot frame into the imu frame
        rates = self.rot_b2i * self.robot_w
        #logger.debug("rates in robot frame (% .4f, % .4f, % .4f)", self.robot_w[0], self.robot_w[1], self.robot_w[2])
        #logger.debug("rates in imu frame   (% .4f, % .4f, % .4f)", rates[0], rates[1], rates[2])

        # differentiate linear velocity in world (inertial) frame
        # and rotate to imu frame
        dv_imu = self.rot_i2w.transposed() * (self.robot_vel - self.plv) * self.frequency
        #logger.debug("velocity_dot in imu frame (% .4f, % .4f, % .4f)", dv_imu[0], dv_imu[1], dv_imu[2])

        # rotate acceleration due to gravity into imu frame
        g_imu = self.rot_i2w.transposed() * self.gravity

        # measurement includes gravity and acceleration
        accel_meas = dv_imu + g_imu

        if self.compute_offset_acceleration:
            # acceleration due to rotation (centripetal)
            # is zero if imu is mounted in robot center (assumed axis of rotation)
            a_centripetal = self.rot_b2i * rates.cross(rates.cross(self.imu2body.translation))
            #logger.debug("centripetal acceleration (% .4f, % .4f, % .4f)", a_rot[0], a_rot[1], a_rot[2])

            # linear acceleration due to angular acceleration
            a_alpha = self.rot_b2i * (self.robot_w - self.pav).cross(self.imu2body.translation) * self.frequency

            # final measurement includes acceleration due to rotation center not in IMU
            accel_meas += a_centripetal + a_alpha

        # save velocity for next step
        self.plv = self.robot_vel.copy()
        self.pav = self.robot_w.copy()

        return rates, accel_meas

    def default_action(self):
        """
        Get the speed and acceleration of the robot and transform it into the imu frame
        """
        if self.has_physics:
            (rates, accel) = self.sim_imu_with_physics()
        else:
            (rates, accel) = self.sim_imu_simple()

        # Store the important data
        self.local_data['angular_velocity'] = rates
        self.local_data['linear_acceleration'] = accel

########NEW FILE########
__FILENAME__ = laserscanner
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
from morse.core.sensor import Sensor
from morse.helpers.components import add_data, add_property, add_level
from morse.builder import bpymorse
"""
Important note:

    The 'logger.debug' instructions take some processor work, even if they are
    not displayed. For this reason, it is best to comment out these lines in
    the 'default_action' method.
"""

class LaserScanner(Sensor):
    """
    This is a generic sensor class used to emulate laser range scanners,
    including a variety of SICK and Hokuyo sensors.

    This sensor works by generating a series of rays in predefined directions, and
    then computing whether any active object is found within a certain distance
    from the origin of the sensor.

    The resolution and detection range can be completely configured using the MORSE
    Builder API.  This will generate a flat mesh with a semi-circular shape, where
    its vertices represent the directions in which the rays of the sensor are cast.
    It is also possible to create a sensor with multiple scan layers, such as the
    SICK LD-MRS. This is configured using the parameters specified below.

    .. note::

        Objects in the scene with the **No collision** setting in their Game
        properties will not be detected by this sensor


    +-----------------------------------------------------------+------------------------------------------------------------------+
    | .. figure:: ../../../media/sensors/laserscanners/sick.png | .. figure:: ../../../media/sensors/laserscanners/sick-ld-mrs.png |
    |    :width: 200                                            |    :width: 200                                                   |
    |                                                           |                                                                  |
    |    SICK LMS500                                            |    SICK LD-MRS                                                   |
    +-----------------------------------------------------------+------------------------------------------------------------------+
    |.. figure:: ../../../media/sensors/laserscanners/hokuyo.png|                                                                  |
    |   :width: 200                                             |                                                                  |
    |                                                           |                                                                  |
    |   Hokuyo                                                  |                                                                  |
    +-----------------------------------------------------------+------------------------------------------------------------------+

    LaserScanner with remission values
    ___________________________________

    Remission "is the reflection or scattering of light by a material." 
    (http://en.wikipedia.org/wiki/Remission_%28spectroscopy%29)

    The level "rssi" adds a list of remission values to the LaserScanner. If a ray 
    during the scan hits an object the rssi-value is the specular intenisty of the 
    object's material; If it does not hit an object with a material the remission 
    value is set to 0. 

    The intensity of the material can be changed in Blender (Property -> Material -> 
    Specular -> Intensity). The important options are highlighted in the first image.

    +---------------------------------------------------------------------------------+
    | .. figure:: ../../../media/rssi_blender_intensity_material.png                  |
    |    :align:  center                                                              |
    |                                                                                 |
    |    Specular intensity of a material in Blender                                  |
    +---------------------------------------------------------------------------------+
    | .. figure:: ../../../media/rssi_laserscanner_example.png                        |
    |    :align:  center                                                              |
    |                                                                                 |
    |    Example of the LaserScanner with remission values                            |
    +---------------------------------------------------------------------------------+

    In the second image the sensor is illustrated. Above every box the material 
    properties and a corresponding excerpt from the socket stream is displayed.

    .. note::
        
        The remission values are **not** comparable to any physical remission value 
        and are **not** calculated. They are just based on a property of a visual effect.
    

    Configuration of the scanning parameters
    ----------------------------------------

    The number and direction of the rays emitted by the sensor is determined by the
    vertices of a semi-circle mesh parented to the sensor. The sensor will cast
    rays from the center of the sensor in the direction of each of the vertices in
    the semi-circle.

    Three preconfigured scanners are available: a **SICK LMS500** laser scanner, a
    **Hokuyo** and a **SICK LD-MRS**. The example below shows how to add them
    in a simulation:

    .. code-block:: python

        from morse.builder import *

        # Append a sick laser
        sick = Sick() # range: 30m, field: 180deg, 180 sample points

        hokuyo = Hokuyo() # range: 30m, field: 270deg, 1080 sample points

        sick_ld_mrs = SickLDMRS() # range: 30m, field 100deg, 4 layers, 400 points per layer

    All these default parameters can be changed i(cf *Configuration
    parameters* below). An example of how to change the arc object using the
    Builder API is show below:

    .. code-block:: python

        from morse.builder import *

        # Append a sick laser
        sick = Sick()
        sick.properties(resolution = 5)
        sick.properties(scan_window = 90)
        sick.properties(laser_range = 5.0)

    .. note::

        In some special cases (like multi-robot setups), you may need to
        additionally call ``sick.create_sick_arc()`` after setting your
        scanner properties.

        The ray will be created from (-window/2) to (+window/2). So the
        ``range_list`` will contain the range clockwise.


    Another example for the SICK LD-MRS:

    .. code-block:: python

        from morse.builder import *

        sick = SickLDMRS()
        sick.properties(Visible_arc = True)
        sick.properties(resolution = 1.0)
        sick.properties(scan_window = 100)
        sick.properties(laser_range = 50.0)
        sick.properties(layers = 4)
        sick.properties(layer_separation = 0.8)
        sick.properties(layer_offset = 0.25)

    As with any other component, it is possible to adjust the refresh frequency of
    the sensor, after it has been defined in the builder script. For example, to
    set the frequency to 1 Hz:

    .. code-block:: python

        sick.frequency(1.0)
    """

    _name = "Laser Scanner Sensors"
    _short_desc = "Generic laser range sensors"

    add_level("raw", None, doc = "raw laserscanner: \
                    Laserscan with point_list and range_list", default = True )
    add_level("rssi", "morse.sensors.laserscanner.RSSILaserScanner", doc = "laserscanner with rssi: \
                    Laserscan with point_list, range_list and remission_list")

    add_data('point_list', [], "list", "Array that stores the positions of \
            the points found by the laser. The points are given with respect \
            to the location of the sensor, and stored as lists of three \
            elements. The number of points depends on the geometry of the arc \
            parented to the sensor (see below). The point (0, 0, 0) means that\
            this ray has not it anything in its range", level =["raw", "rssi"] )
    add_data('range_list', [], "list", "Array that stores the distance to the \
            first obstacle detected by each ray. The order indexing of this \
            array is the same as for point_list, so that the element in the \
            same index of both lists will correspond to the measures for the \
            same ray. If the ray does not hit anything in its range it returns \
            laser_range", level =["raw", "rssi"])
    add_data('remission_list', [], "list", "Array that stores the remission \
            value for the points found by the laser. The specular intensity \
            is set as the remission value. If no object is hit, the remission \
            value is set to 0", level ="rssi")

    add_property('laser_range', 30.0, 'laser_range', "float",
                 "The distance in meters from the center of the sensor to which\
                  it is capable of detecting other objects.")
    add_property('resolution', 1.0, 'resolution', "float",
                 "The angle between each laser in the sensor. Expressed in \
                  degrees in decimal format. (i. e.), half a degree is     \
                  expressed as 0.5. Used when creating the arc object.")
    add_property('scan_window', 180.0, 'scan_window', "float",
                 "The full angle covered by the sensor. Expressed in degrees \
                  in decimal format. Used when creating the arc object.")
    add_property('visible_arc', False, 'Visible_arc', "boolean",
                 "if the laser arc should be displayed during the simulation")
    add_property('layers', 1, 'layers', "integer",
                  "Number of scanning planes used by the sensor.")
    add_property('layer_separation', 0.8, 'layer_separation', "float",
                 "The angular distance between the planes, in degrees.")
    add_property('layer_offset', 0.125, 'layer_offset', "float",
                 "The horizontal distance between the scan points in \
                  consecutive scanning layers. Must be given in degrees.")

    def __init__(self, obj, parent=None):
        """
        Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        Sensor.__init__(self, obj, parent)

        arc_prefix = 'Arc_'

        # Look for a child arc to use for the scans
        for child in obj.children:
            if arc_prefix in child.name:
                self._ray_arc = child
                logger.info("Sick: Using arc object: '%s'" % self._ray_arc)
                break

        # Set its visibility, according to the settings
        self._ray_arc.setVisible(self.visible_arc)
        self._ray_list = []

        # Create an empty list to store the intersection points
        self.local_data['point_list'] = []
        self.local_data['range_list'] = []


        # Get the datablock of the arc, to extract its vertices
        ray_object = blenderapi.objectdata(self._ray_arc.name)
        for vertex in ray_object.data.vertices:
            logger.debug ("Vertex %d = %s" % (vertex.index, vertex.co))

            # Skip the first vertex.
            # It is the one located at the center of the sensor
            if vertex.index == 0:
                continue

            # Store the position of the vertex in a list
            # The position is already given as a mathutils.Vector
            self._ray_list.append(vertex.co)

            # Insert empty points into the data list
            self.local_data['point_list'].append([0.0, 0.0, 0.0])
            # Insert zeros into the range list
            self.local_data['range_list'].append(0.0)

            logger.debug("RAY %d = [%.4f, %.4f, %.4f]" %
                         (vertex.index, self._ray_list[vertex.index-1][0],
                                        self._ray_list[vertex.index-1][1],
                                        self._ray_list[vertex.index-1][2]))

        # Get some information to be able to deform the arcs
        if self.visible_arc:
            self._layers = 1
            if 'layers' in self.bge_object:
                self._layers = self.bge_object['layers']
            self._vertex_per_layer = len(self._ray_list) // self._layers

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)


    def default_action(self):
        """
        Do ray tracing from the SICK object using a semicircle

        Generates a list of lists, with the points located.
        Also deforms the geometry of the arc associated to the SICK,
        as a way to display the results obtained.
        """
        #logger.debug("ARC POSITION: [%.4f, %.4f, %.4f]" %
        #                (self.bge_object.position[0],
        #                 self.bge_object.position[1],
        #                 self.bge_object.position[2]))

        # Get the inverse of the transformation matrix
        inverse = self.position_3d.matrix.inverted()

        index = 0
        for ray in self._ray_list:
            # Transform the ray to the current position and rotation
            #  of the sensor
            correct_ray = self.position_3d.matrix * ray

            # Shoot a ray towards the target
            target, point, normal = self.bge_object.rayCast(correct_ray, None,
                                                             self.laser_range)

            #logger.debug("\tTarget, point, normal: %s, %s, %s" %
            #               (target, point, normal))

            # Register when an intersection occurred
            if target:
                distance = self.bge_object.getDistanceTo(point)
                # Return the point to the reference of the sensor
                new_point = inverse * point

                #logger.debug("\t\tGOT INTERSECTION WITH RAY: [%.4f, %.4f, %.4f]" % (correct_ray[0], correct_ray[1], correct_ray[2]))
                #logger.debug("\t\tINTERSECTION AT: [%.4f, %.4f, %.4f] = %s" % (point[0], point[1], point[2], target))
            # If there was no intersection, store the default values
            else:
                distance = self.laser_range
                new_point = [0.0, 0.0, 0.0]

            # Save the information gathered
            self.local_data['point_list'][index] = new_point[:]
            self.local_data['range_list'][index] = distance
            index += 1
            self.change_arc()


    def change_arc(self):
        # Change the shape of the arc to show what the sensor detects
        # Display only for 1 layer scanner
        if (2, 65, 0) < blenderapi.version() <= (2, 66, 3):
            # see http://projects.blender.org/tracker/?func=detail&aid=34550
            return # not supported in 2.66 due to BGE bug #34550
        # TODO rework the LDMRS (3 layers) display [code in 1.0-beta2]
        if self.visible_arc and self._layers == 1:
            for mesh in self._ray_arc.meshes:
                for m_index in range(len(mesh.materials)):
                    # Skip the first vertex (located at the center of the sensor)
                    for v_index in range(1, mesh.getVertexArrayLength(m_index)):
                        vertex = mesh.getVertex(m_index, v_index)
                        point = self.local_data['point_list'][v_index-1]
                        if point == [0.0, 0.0, 0.0]:
                            # If there was no intersection, move the vertex
                            # to the laser range
                            point = self._ray_list[v_index-1] * self.laser_range
                        vertex.setXYZ(point)


class LaserScannerRotationZ(LaserScanner):
    """Used for Velodyne sensor"""
    def default_action(self):
        LaserScanner.default_action(self)
        self.applyRotationZ()
    def applyRotationZ(self, rz=.01745):
        # The second parameter specifies a "local" movement
        self.bge_object.applyRotation([0, 0, rz], True)

class RSSILaserScanner(LaserScanner):

    def __init__(self, obj, parent=None):
        LaserScanner.__init__(self, obj, parent)
        self.local_data['remission_list'] = []
        ray_object = blenderapi.objectdata(self._ray_arc.name)
        for vertex in ray_object.data.vertices:
            # Skip the first vertex.
            # It is the one located at the center of the sensor
            if vertex.index == 0:
                continue

            # Insert zeros in the remission list
            self.local_data['remission_list'].append(0.0) 
       
    def getRSSIValue(self, target):

        """
        IMPORTANT:
        To get the material property a workaround is needed.
        The material from the targets is KX_BlenderMaterial (and not
        KX_PolygonMaterial). So the properties are not accessible.
        Workaround:
        Get material name of the GameObject and then use the method
        bpymorse.get_material(name).
        Material name must be parsed because of the prefix 'MA' in Blender;
        before the name is used to get the material properties.
        """
        mat_name = target.getMaterialName()
        try: 
            mat_name = mat_name[2:]
            mat = bpymorse.get_material(mat_name)
            if mat:
                return mat.specular_intensity

        except:
            logger.error("Error: Could not parse material name %s. \
                    The leading 'MA' (prefix in Blender) is missing. \
                    Please check on the material name and the source file \
                    /src/morse/sensors/laserscanner.py the method \
                    'default_action' in the class LaserScannner_RSSI, \
                    where the name is parsed."%mat_name)
            return -1              

    def default_action(self):
        inverse = self.position_3d.matrix.inverted()

        index = 0
        for ray in self._ray_list:
            # Transform the ray to the current position and rotation
            #  of the sensor
            correct_ray = self.position_3d.matrix * ray

            # Shoot a ray towards the target
            """
            target, point, normal = self.bge_object.rayCast(correct_ray, None,
                                                             self.laser_range)
            would be possible, but longer way to get material name:
            target -> (list)meshes -> (list)materials -> (string)getMaterialName(id)
            
            target_poly is shorter
            """
            target, point, normal, target_poly = self.bge_object.rayCast(correct_ray, None,
                                                             self.laser_range, "", 1, 1, 1)

            #logger.debug("\tTarget, point, normal: %s, %s, %s" %
            #               (target, point, normal))

            # Register when an intersection occurred


            if target_poly:
                distance = self.bge_object.getDistanceTo(point)
                new_point = inverse * point

                rssi = self.getRSSIValue(target_poly)                        
                            
                # Return the point to the reference of the sensor


                #logger.debug("\t\tGOT INTERSECTION WITH RAY: [%.4f, %.4f, %.4f]" % (correct_ray[0], correct_ray[1], correct_ray[2]))
                #logger.debug("\t\tINTERSECTION AT: [%.4f, %.4f, %.4f] = %s" % (point[0], point[1], point[2], target))
            # If there was no intersection, store the default values
            else:
                distance = self.laser_range
                new_point = [0.0, 0.0, 0.0]
                rssi = 0

            # Save the information gathered
            self.local_data['point_list'][index] = new_point[:]
            self.local_data['range_list'][index] = distance
            self.local_data['remission_list'][index] = rssi
            index += 1
            LaserScanner.change_arc(self)


########NEW FILE########
__FILENAME__ = mocap_posture
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi
import morse.core.sensor
from morse.helpers.components import add_data

#logger.setLevel(logging.DEBUG)

class HumanPosture(morse.core.sensor.Sensor):
    """ 
    This sensor collects the positions of the bones in the human armature
    for the file ``$MORSE_ROOT/data/robots/mocap_human.blend``.

    It stores the position and orientation of the general armature
    object, as well as the local rotation of each individual bone. The
    rotation angles are given in radians. It exports the same interface than the
    :doc:`human posture sensor <../sensors/human_posture>`, but some
    joints are not reflected by the Kinect, and so they stay to their
    initial values.

    This sensor will only work for the ``mocap_human.blend`` model, as it
    uses a specific naming convention for each of the bones.

    You can also check to general documentation of the :doc:`human
    component <../others/human>`.

    .. image:: ../../../media/human_joints.png
      :align: center
      :width: 600
    """

    _name = "Human Posture (kinect version)"

    add_data('x', 0.0, "float",
             'global X position of the armature in the scene, in meter')
    add_data('y', 0.0, "float",
             'global Y position of the armature in the scene, in meter')
    add_data('z', 0.0, "float",
             'global Z position of the armature in the scene, in meter')
    add_data('yaw', 0.0, "float",
             'rotation angle with respect to the Z axis, in radian')
    add_data('pitch', 0.0, "float",
             'rotation angle with respect to the Z axis, in radian')
    add_data('roll', 0.0, "float",
             'rotation angle with respect to the Z axis, in radian')
    add_data('empty1', 0.0, "float")
    add_data('empty2', 0.0, "float")
    add_data('empty3', 0.0, "float")
    add_data('empty4', 0.0, "float")
    add_data('empty5', 0.0, "float")
    add_data('empty6', 0.0, "float")

    add_data('dof_12', 0.0, 'float',
             'rotation around the X axis for the torso, in radian')
    add_data('dof_13', 0.0, 'float',
             'rotation around the Y axis for the torso, in radian')
    add_data('dof_14', 0.0, 'float',
             'rotation around the Z axis for the torso, in radian')

    add_data('dof_15', 0.0, 'float',
             'rotation around the Z axis for the head, in radian')
    add_data('dof_16', 0.0, 'float',
             'rotation around the Y axis for the head, in radian')
    add_data('dof_17', 0.0, 'float',
             'rotation around the X axis for the head, in radian')

    add_data('dof_18', 0.0, 'float',
             'rotation around the X axis for the right shoulder, in radian')
    add_data('dof_19', 0.0, 'float',
             'rotation around the Y axis for the right shoulder, in radian')
    add_data('dof_20', 0.0, 'float',
             'rotation around the Z axis for the right shoulder, in radian')

    add_data('dof_21', 0.0, 'float',
             'elongation of the right arm, in meter (not computed)')

    add_data('dof_22', 0.0, 'float',
            'rotation around the Z axis for the right elbow, in radian')

    add_data('dof_23', 0.0, 'float', 'R_POINT (not computed)')

    add_data('dof_24', 0.0, 'float',
             'rotation around the X axis for the right wrist, in radian \
              (not computed)')
    add_data('dof_25', 0.0, 'float',
             'rotation around the Y axis for the right wrist, in radian \
              (not computed)')
    add_data('dof_26', 0.0, 'float',
             'rotation around the Z axis for the right write, in radian \
              (not computed')

    add_data('dof_27', 0.0, 'float',
            'rotation around the X axis for the left shoulder, in radian')
    add_data('dof_28', 0.0, 'float',
            'rotation around the Y axis for the left shoulder, in radian')
    add_data('dof_29', 0.0, 'float',
            'rotation around the Z axis for the left shoulder, in radian')

    add_data('dof_30', 0.0, 'float',
             'elongation of the left arm, in meter (not computed)')

    add_data('dof_31', 0.0, 'float',
             'rotation around the Z axis for the left elbow, in radian')

    add_data('dof_32', 0.0, 'float', 'L_POINT (not computed)')

    add_data('dof_33', 0.0, 'float', 
            'rotation around the X axis for the left wrist, in radian \
             (not computed)')
    add_data('dof_34', 0.0, 'float', 
            'rotation around the Y axis for the left wrist, in radian \
            (not computed)')
    add_data('dof_35', 0.0, 'float', 
            'rotation around the Z axis for the left wrist, in radian \
             (not computed)')

    add_data('dof_36', 0.0, 'float', 
            'rotation around the X axis for the right hip, in radian')
    add_data('dof_37', 0.0, 'float', 
            'rotation around the Y axis for the right hip, in radian')
    add_data('dof_38', 0.0, 'float', 
            'rotation around the Z axis for the right hip, in radian')

    add_data('dof_39', 0.0, 'float',
            'rotation around the Z axis for the right knee, in radian')

    add_data('dof_40', 0.0, 'float',
            'rotation around the X axis for the right ankle, in radian \
             (not computed)')
    add_data('dof_41', 0.0, 'float',
            'rotation around the Y axis for the right ankle, in radian \
             (not computed)')
    add_data('dof_42', 0.0, 'float',
            'rotation around the Z axis for the right ankle, in radian \
             (not compued)')

    add_data('dof_43', 0.0, 'float',
             'rotation around the X axis for the left hip, in radian')
    add_data('dof_44', 0.0, 'float',
             'rotation around the Y axis for the left hip, in radian')
    add_data('dof_45', 0.0, 'float',
             'rotation around the Z axis for the left hip, in radian')

    add_data('dof_46', 0.0, 'float',
             'rotation around the Z axis for the left knee, in radian')

    add_data('dof_47', 0.0, 'float',
             'rotation around the X axis for the left ankle, in radian \
              (not computed)')
    add_data('dof_48', 0.0, 'float',
             'rotation around the Y axis for the left ankle, in radian \
              (not computed)')
    add_data('dof_49', 0.0, 'float',
             'rotation around the Z axis for the left ankle, in radian \
              (not computed)')

    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            The second parameter should be the name of the object's parent. """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)

    def _read_pose(self, armature):

        for channel in armature.channels:
            if 'X_' not in channel.name:
                if channel.name == 'Chest':
                    self.local_data['dof_12'] = channel.joint_rotation[0]
                    self.local_data['dof_13'] = channel.joint_rotation[2]
                    self.local_data['dof_14'] = - channel.joint_rotation[1]
                if channel.name == 'Head':
                    self.local_data['dof_15'] = - channel.joint_rotation[0] #z axis
                    self.local_data['dof_16'] = channel.joint_rotation[2] #x axis
                    self.local_data['dof_17'] = channel.joint_rotation[1] #y axis

                if channel.name == 'UpArm.R':
                    self.local_data['dof_18'] = - channel.joint_rotation[0]
                    self.local_data['dof_19'] = channel.joint_rotation[2]
                if channel.name == 'ForeArm.R':
                    self.local_data['dof_20'] = -channel.joint_rotation[2]
                    self.local_data['dof_22'] = channel.joint_rotation[0]
                # Kinect does not provide rotations for the hands
                #if channel.name == 'Hand.R':
                #    self.local_data['dof_24'] = channel.joint_rotation[0]
                #    self.local_data['dof_25'] = channel.joint_rotation[1]
                #    self.local_data['dof_26'] = channel.joint_rotation[2]

                if channel.name == 'UpArm.L':
                    self.local_data['dof_27'] = - channel.joint_rotation[0]
                    self.local_data['dof_28'] = - channel.joint_rotation[2]
                if channel.name == 'ForeArm.L':
                    self.local_data['dof_29'] = -channel.joint_rotation[2]
                    self.local_data['dof_31'] = channel.joint_rotation[0]
                # Kinect does not provide rotations for the hands
                #if channel.name == 'Hand.L':
                #    self.local_data['dof_33'] = channel.joint_rotation[0]
                #    self.local_data['dof_34'] = channel.joint_rotation[1]
                #    self.local_data['dof_35'] = channel.joint_rotation[2]

                if channel.name == 'UpLeg.R' :
                    self.local_data['dof_36'] = - channel.joint_rotation[0]
                    self.local_data['dof_37'] = - channel.joint_rotation[2]
                    self.local_data['dof_38'] = - channel.joint_rotation[1]
                if channel.name == 'LoLeg.R':
                    self.local_data['dof_39'] = - channel.joint_rotation[2]
                # Kinect does not provide rotations for the feet
                #if channel.name == 'Foot.R':
                #    self.local_data['dof_40'] = channel.joint_rotation[0]
                #    self.local_data['dof_41'] = channel.joint_rotation[1]
                #    self.local_data['dof_42'] = channel.joint_rotation[2]

                if channel.name == 'UpLeg.L':
                    self.local_data['dof_43'] = - channel.joint_rotation[0]
                    self.local_data['dof_44'] = - channel.joint_rotation[2]
                    self.local_data['dof_45'] = - channel.joint_rotation[1]
                if channel.name == 'LoLeg.L':
                    self.local_data['dof_46'] = - channel.joint_rotation[2]
                # Kinect does not provide rotations for the feet
                #if channel.name == 'Foot.L':
                #    self.local_data['dof_47'] = channel.joint_rotation[0]
                #    self.local_data['dof_48'] = channel.joint_rotation[1]
                #    self.local_data['dof_49'] = channel.joint_rotation[2]



    def default_action(self):
        """ Extract the human posture """

        # Give the position of the Torso_Empty object as the position of
        # the human
        scene = blenderapi.scene()
        torso = scene.objects['Torso_Empty']
        self.local_data['x'] = torso.worldPosition[0]
        self.local_data['y'] = torso.worldPosition[1]
        self.local_data['z'] = torso.worldPosition[2]
        logger.debug("\tTorso_Empty position: (%.4f, %.4f, %.4f)" %
                     (torso.worldPosition[0], 
                      torso.worldPosition[1], 
                      torso.worldPosition[2]))

        # Pass also the rotation of the Torso_Empty
        self.local_data['yaw'] = torso.worldOrientation.to_euler().z
        self.local_data['pitch'] = torso.worldOrientation.to_euler().y
        self.local_data['roll'] = torso.worldOrientation.to_euler().x
        logger.debug("\tTorso_Empty orientation: (%.4f, %.4f, %.4f)" %
                       (self.local_data['roll'],
                        self.local_data['pitch'],
                        self.local_data['yaw']))

        self._read_pose(self.bge_object)

        logger.debug("LOCAL_DATA: %s" % self.local_data)

########NEW FILE########
__FILENAME__ = odometry
import logging; logger = logging.getLogger("morse." + __name__)
from morse.helpers.morse_math import normalise_angle
import morse.core.sensor
import copy
from morse.helpers.components import add_data, add_level

class Odometry(morse.core.sensor.Sensor):
    """
    This sensor produces relative displacement with respect to the position and
    rotation in the previous Blender tick. It can compute too the position of the
    robot with respect to its original position, and the associated speed.

    The angles for yaw, pitch and roll are given in radians.

    .. note::
      This sensor always provides perfect data.
      To obtain more realistic readings, it is recommended to add modifiers.
        
      - **Noise modifier**: Adds random Gaussian noise to the data
      - **Odometry Noise modifier**: Simulate scale factor error and gyroscope drift
    """

    _name = "Odometry"
    _short_desc = "An odometry sensor that returns raw, partially integrated or fully integrated displacement information."

    add_level("raw", "morse.sensors.odometry.RawOdometry", doc = "raw odometry: only dS is exported")
    add_level("differential", None, doc = "differential odometry, corresponding to standard 'robot level' odometry")
    add_level("integrated", "morse.sensors.odometry.IntegratedOdometry", doc = "integrated odometry: absolution position is exported", default=True)

    add_data('dS', 0.0, "float","curvilinear distance since last tick", level = "raw")
    add_data('dx', 0.0, "float","delta of X coordinate of the sensor", level = "differential")
    add_data('dy', 0.0, "float","delta of Y coordinate of the sensor", level = "differential")
    add_data('dz', 0.0, "float","delta of Z coordinate of the sensor", level = "differential")
    add_data('dyaw', 0.0, "float","delta of rotation angle with respect to the Z axis", level = "differential")
    add_data('dpitch', 0.0, "float","delta of rotation angle with respect to the Y axis", level = "differential")
    add_data('droll', 0.0, "float","delta of rotation angle with respect to the X axis", level = "differential")
    add_data('x', 0.0, "float","X coordinate of the sensor", level = "integrated")
    add_data('y', 0.0, "float","Y coordinate of the sensor", level = "integrated")
    add_data('z', 0.0, "float","Z coordinate of the sensor", level = "integrated")
    add_data('yaw', 0.0, "float","rotation angle with respect to the Z axis", level = "integrated")
    add_data('pitch', 0.0, "float","rotation angle with respect to the Y axis", level = "integrated")
    add_data('roll', 0.0, "float","rotation angle with respect to the X axis", level = "integrated")
    add_data('vx', 0.0, "float","linear velocity related to the X coordinate of the sensor", level = "integrated")
    add_data('vy', 0.0, "float","linear velocity related to the Y coordinate of the sensor", level = "integrated")
    add_data('vz', 0.0, "float","linear velocity related to the Z coordinate of the sensor", level = "integrated")
    add_data('wz', 0.0, "float","angular velocity related to the Z coordinate of the sensor", level = "integrated")
    add_data('wy', 0.0, "float","angular velocity related to the Y coordinate of the sensor", level = "integrated")
    add_data('wx', 0.0, "float","angular velocity related to the X coordinate of the sensor", level = "integrated")


    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        self.original_pos = copy.copy(self.position_3d)

        self.previous_pos = self.original_pos.transformation3d_with(
                                                            self.position_3d)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)


    def default_action(self):
        """ Compute the relative position and rotation of the robot

        The measurements are taken with respect to the previous position
        and orientation of the robot
        """
        # Compute the position of the sensor within the original frame
        current_pos = self.original_pos.transformation3d_with(self.position_3d)

        # Compute the difference in positions with the previous loop
        self.local_data['dx'] = current_pos.x - self.previous_pos.x
        self.local_data['dy'] = current_pos.y - self.previous_pos.y
        self.local_data['dz'] = current_pos.z - self.previous_pos.z

        # Compute the difference in orientation with the previous loop
        dyaw = current_pos.yaw - self.previous_pos.yaw
        dpitch = current_pos.pitch - self.previous_pos.pitch
        droll = current_pos.roll - self.previous_pos.roll
        self.local_data['dyaw'] = normalise_angle(dyaw)
        self.local_data['dpitch'] = normalise_angle(dpitch)
        self.local_data['droll'] = normalise_angle(droll)

        # Store the 'new' previous data
        self.previous_pos = current_pos


class RawOdometry(Odometry):

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        Odometry.__init__(self, obj, parent)

    def default_action(self):
        # Compute the position of the sensor within the original frame
        current_pos = self.original_pos.transformation3d_with(self.position_3d)

        # Compute the difference in positions with the previous loop
        self.local_data['dS'] = current_pos.distance(self.previous_pos)

        # Store the 'new' previous data
        self.previous_pos = current_pos

class IntegratedOdometry(Odometry):

    def __init__(self, obj, parent=None):
        # Call the constructor of the parent class
        Odometry.__init__(self, obj, parent)

    def default_action(self):
        # Compute the position of the sensor within the original frame
        current_pos = self.original_pos.transformation3d_with(self.position_3d)

        # Integrated version
        self.local_data['x'] = current_pos.x
        self.local_data['y'] = current_pos.y
        self.local_data['z'] = current_pos.z
        self.local_data['yaw'] = current_pos.yaw
        self.local_data['pitch'] = current_pos.pitch
        self.local_data['roll'] = current_pos.roll

        # speed in the sensor frame, related to the robot pose
        self.delta_pos = self.previous_pos.transformation3d_with(current_pos)
        self.local_data['vx'] = self.delta_pos.x * self.frequency
        self.local_data['vy'] = self.delta_pos.y * self.frequency
        self.local_data['vz'] = self.delta_pos.z * self.frequency
        self.local_data['wz'] = self.delta_pos.yaw * self.frequency
        self.local_data['wy'] = self.delta_pos.pitch * self.frequency
        self.local_data['wx'] = self.delta_pos.roll * self.frequency

        # Store the 'new' previous data
        self.previous_pos = current_pos


########NEW FILE########
__FILENAME__ = pose
import logging; logger = logging.getLogger("morse." + __name__)
import morse.core.sensor
from morse.helpers.components import add_data

class Pose(morse.core.sensor.Sensor):
    """ 
    This sensor returns the full pose of the sensor, i.e. both
    translation and rotation with respect to the Blender world frame.
    """
    _name = "Pose"

    add_data('x', 0.0, "float",
             'x coordinate of the sensor, in world coordinate, in meter')
    add_data('y', 0.0, "float",
             'y coordinate of the sensor, in world coordinate, in meter')
    add_data('z', 0.0, "float",
             'z coordinate of the sensor, in world coordinate, in meter')
    add_data('yaw', 0.0, "float",
             'rotation around the Z axis of the sensor, in radian')
    add_data('pitch', 0.0, "float",
             'rotation around the Y axis of the sensor, in radian')
    add_data('roll', 0.0, "float",
             'rotation around the X axis of the sensor, in radian')

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)


    def default_action(self):
        """ Get the x, y, z, yaw, pitch and roll of the blender object. """
        self.local_data['x'] = self.position_3d.x
        self.local_data['y'] = self.position_3d.y
        self.local_data['z'] = self.position_3d.z
        self.local_data['yaw'] = self.position_3d.yaw
        self.local_data['pitch'] = self.position_3d.pitch
        self.local_data['roll'] = self.position_3d.roll

########NEW FILE########
__FILENAME__ = proximity
import logging; logger = logging.getLogger("morse." + __name__)

from morse.core import blenderapi
import morse.core.sensor
from morse.core.services import service
from morse.helpers.components import add_data, add_property

class Proximity(morse.core.sensor.Sensor):
    """
    This sensor can be used to determine which other objects are within a
    certain radius of the sensor. It performs its test based only on distance.
    The type of tracked objects can be specified using the **Track** property.
    """

    _name = "Proximity Sensor"
    _short_desc = "Distance sensor to detect nearby objects."

    add_data('near_objects', {}, "dict", "A list of the tracked objects located "
            "within the given radius. The keys of the dictionary are the object "
            "names, and the values are the distances (in meters) from the "
            "sensor.")
    add_data('near_robots', {}, "dict", "deprecated. Points to near_objects for compatibility reasons.")

    add_property('_range', 100, 'Range', "float", "The distance, in meters "
            "beyond which this sensor is unable to locate other robots.")
    add_property('_tag', "Robot_Tag",  'Track',  "string",  "The type of "
            "tracked objects. This type is looked for as game property of scene "
            "objects. You must then add a new game property to the objects you "
            "want to be detected by the proximity sensor.")

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        logger.info('Component initialized, runs at %.2f Hz', self.frequency)

    @service
    def set_range(self, range):
        """
        The service expects a float range (in meter), and modify the range
        used to detect objects around the proximity sensor.

        :param range: detection range, in meters
        """
        self._range = float(range)

    @service
    def set_tracked_tag(self, tag):
        """
        The service allows to modify the kind of objects detected by the
        proximity sensor.

        :param tag: value of the *Track* property used to select detected
                    objects.
        """
        self._tag = tag

    def default_action(self):
        """ Create a list of tagged objects within a certain radius of the sensor. """

        self.local_data['near_objects'] = {}
        self.local_data['near_robots'] = self.local_data['near_objects']

        parent = self.robot_parent.bge_object

        # Get the tracked sources
        for obj in blenderapi.scene().objects:
            try:
                obj[self._tag]
                # Skip distance to self
                if parent != obj:
                    distance = self._measure_distance_to_object (parent, obj)
                    if distance <= self._range:
                        self.local_data['near_objects'][obj.name] = distance
            except KeyError:
                pass

    def _measure_distance_to_object(self, own_robot, target_object):
        """ Compute the distance between two objects

        Parameters are two blender objects
        """
        distance, globalVector, localVector = own_robot.getVectTo(target_object)
        logger.debug("Distance from robot {0} to object {1} = {2}".format(own_robot, target_object, distance))
        return distance

########NEW FILE########
__FILENAME__ = ptu_posture
import logging; logger = logging.getLogger("morse." + __name__)
import re

from morse.core import blenderapi
import morse.core.sensor
from morse.helpers.components import add_data

class PTUPosture(morse.core.sensor.Sensor):
    """
    Simple sensor that provides the current rotation angles of the *pan* and *tilt*
    segments of the :doc:`PTU actuator <../actuators/ptu>`.
    The angles returned are in radians in the range (-pi, pi).

    .. note::

        This sensor **must** be added as a child of the PTU
        you want to sense, like in the example below:

        .. code-block:: python

            robot = ATRV()

            ptu = PTU()
            robot.append(ptu)
            ptu.translate(z=0.9)

            ptu = PTUPosture('ptu_pose')
            ptu.append(ptu_pose)

    .. note:: The angles are given with respect to the orientation of the robot
    
    :sees: :doc:`PTU actuator <../actuators/ptu>`.
    """
    _name = "PTU Pose Sensor"
    _short_desc = "Returns the pan/tilt values of a pan-tilt unit"

    add_data('pan', 0.0, "float","pan value, in radians")
    add_data('tilt', 0.0, "float","tilt value, in radians")
 
    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)
        
        ptu = self._get_ptu(self.bge_object)
        if not ptu:
            logger.error("The PTU pose sensor has not been parented to a PTU! " + \
                    "This sensor must be a child of a PTU. Check you scene.")
            return

        self._ptu_obj = blenderapi.persistantstorage().componentDict[ptu.name]

        self.local_data['pan'] = 0.0
        self.local_data['tilt'] = 0.0
        logger.info('Component <%s> initialized, runs at %.2f Hz' % (self.bge_object.name, self.frequency))

    def _get_ptu(self, obj):
        """
        Retrieve the associated PTU actuator

        Need to carefully deal with possible renaming scheme from Blender,
        in the case of multiples PTU in the scene.
        """
        regexp_ = "^PanBase(\.[0-9]{3})?$"
        regexp = re.compile(regexp_)
        if len([c for c in obj.children if re.match(regexp, c.name)]) > 0:
            return obj
        elif not obj.parent:
            return None
        else:
            return self._get_ptu(obj.parent)


    def default_action(self):
        """ Read the rotation of the platine unit """
        # Find the actual PTU unit as my child
        if not self._ptu_obj:
            return

        # Update the postition of the base platforms
        current_pan, current_tilt = self._ptu_obj.get_pan_tilt()
        logger.debug("Platine: pan=%.4f, tilt=%.4f" % (current_pan, current_tilt))
        
        # Store the data acquired by this sensor that could be sent
        #  via a middleware.
        self.local_data['pan'] = float(current_pan)
        self.local_data['tilt'] = float(current_tilt)

########NEW FILE########
__FILENAME__ = search_and_rescue
# -*- coding: utf-8 -*-

import logging; logger = logging.getLogger("morse." + __name__)
######################################################
#
#    search_and_rescue.py        Blender 2.5x
#
#    Multiple sensor capable of detectin victims
#    and helping them, according to the requirements
#    and capabilities of the robot.
#    Used for the Rosace scenario
#
#
#    Gilberto Echeverria
#    16 / 06 / 2011
#
######################################################

import morse.core.sensor
from morse.core import blenderapi
from morse.core.exceptions import MorseRPCInvokationError
from morse.core.services import service
from morse.core.services import async_service
from morse.core import status
from collections import OrderedDict
from morse.helpers.components import add_data, add_property


class SearchAndRescue(morse.core.sensor.Sensor):
    """ 
    This is a multi functional component specific for Search and Rescue
    scenario, where the robot must be able to aid human victims. The
    sensor is capable of detecting any victim located within a cone in
    front of the robot, with a range delimited in the properties of the
    Blender object. The output of the sensor is a list of the robots and
    their positions in the simulated world. This sensor works only with
    the human victim object.

    Additionally, the sensor provides a number of services related to
    the capabilities of the robot to help the nearest victim:

        - Report on the condition of a victim
        - Report the capabilities of the robot
        - Heal a victim (if the robot has compatible capabilities with
          the requirements of the victim)

    In the test scenarios, human victims are shown in red.  When a robot
    approaches, if it has the adequate capabilities, it will be able to
    help the victims. When issued the command, the sensor will gradually
    change the colour of the victim to green, and its status to healthy.
    It will detect if a victim is in front of the robot. When instructed
    to heal the victim, it will change the Game Properties of the object
    to reduce its injured value.
    """
    _name = "Search And Rescue sensor"
    _short_desc = "High level sensor for search and rescue scenario"

    add_data('victim_dict', {}, "dict",
             'A list of entries for each victim detected inside the cone'
             ' of the sensor. Keys are victim name. The value is a'
             ' dictionnary containing the coordinate of the victim, its'
             ' requirements, and the severity of its injuries')

    add_property('_heal_range', 5.0, 'Heal_range', 'float',
                'maximum distance from which it is possible to heal a'
                ' victim. Even if the victim can be detected by the '
                'sensor, it cant be healed unless its distance from the '
                'robot is less than this value.')

    add_property('_abilities', "", 'Abilities', 'string',
                 'represents a list of numbers, separated by comas, that '
                 'represent the equipment capabilities of the robot. This '
                 'information should be used by the operator of the robot '
                 'to determine if it is capable of helping a victim or not.')

    # These properties are not used directly in the logic, but are used
    # in the builder to create the radar properly.
    # These value cannot be changed dynamically in bge.
    add_property('_angle', 60.0, 'Angle', 'float',
                 'Aperture angle of the radar capable of detecting the '
                 ' victims (in degree)')
    add_property('_distance', 10.0, 'Distance', 'float',
                 'Detection distance in meter. Victims further '
                 'way from the gripper than this distance will not be '
                 'detected')
    add_property('_freq', 3.0, 'Freq', 'float',
                 'change the delay required to heal a victim. This '
                 'number is expressed as the number of tics that are '
                 'ignored before taking action. A lower number will '
                 'produce a lower delay')

    def __init__(self, obj, parent=None):

        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        # Definition for number of tics required to heal a victim
        self._delay = 10

        # Flag to indicate when the component is trying to heal a victim
        self._healing = False
        self._heal_delay = self._delay
        self._capable_to_heal = False

        # Variables to store information about the victim nearest to the robot
        self._nearest_victim = None
        self._nearest_distance = 999999

        # Convert the 'Abilities' property from a string into a list of ints
        #obj['Abilities'] = obj['Abilities'].split(',')
        self._abilities = [int(x) for x in self._abilities.split(',')]

        self._detect_distance = 10.0

        logger.info("Component initialized, runs at %.2f Hz ", self.frequency)


    @async_service
    def heal(self):
        """
        Reduce the Severity value of the nearest victim.
        When the value reaches 0, change the Injured status of the victim to False.
        The service terminates when the victim is fully healed.
        """
        self._healing = True

    @service
    def get_robot_abilities(self):
        """
        Returns the list describing  the abilities with which the robot
        is equipped.
        It must match the requirements of the victim for the robot to be
        able to heal it.
        """
        return self._abilities

    @service
    def get_victim_requirements(self):
        """
        Returns the list describing the type of injuries sustained by the victim
        """
        if self._nearest_victim:
            return self._nearest_victim['Requirements']
        else:
            message = "No victim within range (%.2f m)" % self._detect_distance
            raise MorseRPCInvokationError(message)

    @service
    def get_victim_severity(self):
        """
        Returns the integer indicating the victim healing priority
        """
        if self._nearest_victim:
            return self._nearest_victim['Severity']
        else:
            message = "No victim within range (%.2f m)" % self._detect_distance
            raise MorseRPCInvokationError(message)

    def _heal_victim(self):
        """ Change the 'Severity' property of a nearby victim

        When the victim is fully healed, set its status as not Injured
        """

        victim = self._nearest_victim
        logger.debug("Healing victim %s at distance %f" %
                                    (victim.name, self._nearest_distance))
        # Check that the victim is whithing the valid range and that
        #  the robot is equiped to help the victim
        if self._nearest_distance < self._heal_range:
            # Check the abilities of the robot
            for ability in self._abilities:
                if ability in victim['Requirements']:
                    self._capable_to_heal = True
                    break

            # Quit if the robot has not the required capabilities
            if not self._capable_to_heal:
                self._healing = False
                message = "Not equipped of helping victim"
                self.completed(status.FAILED, message)
                return

            # Delay some time to heal
            self._heal_delay -= 1

            # When the delay has finished, change the victim status
            if self._heal_delay == 0:
                for ability in self._abilities:
                    # Remove the needs of the victim when compatible with the
                    #  abilities of the robot
                    if ability in victim['Requirements']:
                        victim['Requirements'].remove(ability)

                # Reset the healing flags
                self._healing = False
                self._heal_delay = self._delay

                # Mark the victim as healed
                if not victim['Requirements']:
                    victim['Severity'] = 0
                    victim.color = [0.5, 1.0, 0.5, 1.0]
                    message = "Victim '%s' healed" % victim.name
                else:
                    victim.color = [0.5, 0.5, 1.0, 1.0]
                    message = "Victim '%s' partially healed" % victim.name

                self.completed(status.SUCCESS, message)

        else:
            self._healing = False
            self._heal_delay = self._delay
            message = "No victim within range (%.2f m)" % self._heal_range
            self.completed(status.FAILED, message)


    def default_action(self):
        """ Look for nearby victims, and heal when instructed to """
        # Look for victims in the cone of the sensor
        contr = blenderapi.controller()
        radar = contr.sensors['Radar']

        # Clear the variables for the victims
        self.local_data['victim_dict'] = {}
        self._nearest_victim = None
        self._nearest_distance = 999999
        self._detect_distance = radar.distance

        if radar.positive:
            logger.debug('radar positive')
            for victim_obj in radar.hitObjectList:
                if victim_obj.name != self.robot_parent.name():
                    victim_position = victim_obj.worldPosition
                    # Fill the data structure for the victim
                    victim_coordinate = OrderedDict([
                                    ('x', victim_position[0]),
                                    ('y', victim_position[1]),
                                    ('z', victim_position[2])   ])
                    victim_d = OrderedDict([
                                  ('coordinate', victim_coordinate),
                                  ('requirements', victim_obj['Requirements']),
                                  ('severity', victim_obj['Severity'])    ])
                    self.local_data['victim_dict'][victim_obj.name] = victim_d

                    # Find the closest victim and its distance
                    new_distance = self.bge_object.getDistanceTo(victim_obj)
                    if new_distance < self._nearest_distance:
                        self._nearest_victim = victim_obj
                        self._nearest_distance = new_distance

            # When instructed to do so, help a victim
            if self._healing:
                self._heal_victim()
        else:
            if self._healing:
                self._healing = False
                message = "No victim within range (%.2f m)" % \
                                    self._detect_distance
                self.completed(status.FAILED, message)

########NEW FILE########
__FILENAME__ = semantic_camera
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core import blenderapi

import morse.sensors.camera
import morse.helpers.colors

from morse.helpers import passive_objects
from morse.helpers.components import add_data, add_property
from morse.helpers.transformation import Transformation3d

class SemanticCamera(morse.sensors.camera.Camera):
    """
    This sensor emulates a high level *abstract* camera that outputs the
    name and 6D pose of visible objects (*i.e.* objects in the field of
    view of the camera). It also outputs the *type* of the object if the ``Type``
    property is set (:python:`my_object.properties(Type="Bottle")` for
    instance).

    General usage
    -------------

    You need to *tag* the objects you want your camera to track by either
    adding a boolean property ``Object`` to your object:
    :python:`my_object.properties(Object=True)`, or by setting a *type* and
    using this type as the value of the ``tag`` property of the camera:

    .. code-block:: python

        object_to_track = PassiveObject(...)
        object_to_track.properties(Type="Bottle")

        ...

        semcam = SemanticCamera()
        semcam.properties(tag="Bottle")

        ...

    See the *Examples* section below for a complete working example.

    If the ``Label`` property is defined, it is used as exported
    name. Otherwise, the Blender object name is used.

    By default, the pose of the objects is provided in the **world** frame.
    When setting the ``relative`` property to ``True``
    (:python:`semcam.properties(relative=True)`), the pose is computed in the
    **camera** frame instead.

    Details of implementation
    -------------------------

    A test is made to identify which of these objects are inside of
    the view frustum of the camera. Finally, a single visibility test is
    performed by casting a ray from the center of the camera to the
    center of the object. If anything other than the test object is
    found first by the ray, the object is considered to be occluded by
    something else, even if it is only the center that is being blocked.
    This occulsion check can be deactivated (for slightly improved
    performances) by setting the sensor property ``noocclusion`` to ``True``.

    See also :doc:`../sensors/camera` for generic informations about MORSE cameras.

    .. example::
        from morse.builder import *

        # add a 'passive' object visible to the semantic cameras
        table = PassiveObject('props/objects','SmallTable')
        table.translate(x=3.5, y=-3, z=0)
        table.rotate(z=0.2)

        # by setting the 'Object' property to true, this object becomes
        # visible to the semantic cameras present in the simulation.
        # Note that you can set this property on any object (other robots, humans,...).
        table.properties(Type = "table", Label = "MY_FAVORITE_TABLE")

        # then, create a robot
        robot = Morsy()

        # creates a new instance of the sensor, that tracks all tables.
        # If you do not specify a particular 'tag', the camera tracks by default
        # all object with the properties 'type="Object"' or 'Object=True'.
        semcam = SemanticCamera()
        semcam.properties(tag = "table")

        # place the camera at the correct location
        semcam.translate(<x>, <y>, <z>)
        semcam.rotate(<rx>, <ry>, <rz>)

        robot.append(semcam)

        # define one or several communication interface, like 'socket'
        semcam.add_interface(<interface>)

        env = Environment('empty')

    :noautoexample:
    """

    _name = "Semantic camera"
    _short_desc = "A smart camera allowing to retrieve objects in its \
    field of view"

    add_data('visible_objects', [], 'list<objects>',
           "A list containing the different objects visible by the camera. \
            Each object is represented by a dictionary composed of: \n\
                - **name** (String): the name of the object \n\
                - **type** (String): the type of the object \n\
                - **position** (vec3<float>): the position of the \
                  object, in meter, in the blender frame       \n\
                - **orientation** (quaternion): the orientation of the \
                  object, in the blender frame")

    add_property('relative', False, 'relative', 'bool', 'Return object position'
                 ' relatively to the sensor frame.')
    add_property('noocclusion', False, 'noocclusion', 'bool', 'Do not check for'
                 ' objects possibly hiding each others (faster but less '
                 'realistic behaviour)')
    add_property('tag', 'Object',  'tag',  "string",  "The type of "
            "detected objects. This type is looked for as a game property of scene "
            "objects or as their 'Type' property. You must then add fix this "
            "property to the objects you want to be detected by the semantic "
            "camera.")

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.sensors.camera.Camera.__init__(self, obj, parent)

        # Locate the Blender camera object associated with this sensor
        main_obj = self.bge_object
        for obj in main_obj.children:
            if hasattr(obj, 'lens'):
                self.blender_cam = obj
                logger.info("Camera object: {0}".format(self.blender_cam))
                break
        if not self.blender_cam:
            logger.error("no camera object associated to the semantic camera. \
                         The semantic camera requires a standard Blender  \
                         camera in its children.")

        # TrackedObject is a dictionary containing the list of tracked objects
        # (->meshes with a class property set up) as keys
        #  and the bounding boxes of these objects as value.
        self.trackedObjects = {}
        for o in blenderapi.scene().objects:
            tagged = ('Type' in o and o['Type'] == self.tag) or (self.tag in o and bool(o[self.tag]))
                               
            if tagged:
                self.trackedObjects[o] = blenderapi.objectdata(o.name).bound_box
                logger.warning('    - %s' % o.name)

        if self.noocclusion:
            logger.info("Semantic camera running in 'no occlusion' mode (fast mode).")
        logger.info("Component initialized, runs at %.2f Hz ", self.frequency)


    def default_action(self):
        """ Do the actual semantic 'grab'.

        Iterate over all the tracked objects, and check if they are
        visible for the robot.  Visible objects must have a bounding box
        and be active for physical simulation (have the 'Actor' checkbox
        selected)
        """
        # Call the action of the parent class
        morse.sensors.camera.Camera.default_action(self)

        # Create dictionaries
        self.local_data['visible_objects'] = []
        for obj, bb in self.trackedObjects.items():
            if self._check_visible(obj, bb):
                # Create dictionary to contain object name, type,
                # description, position and orientation
                if self.relative:
                    t3d = Transformation3d(obj)
                    logger.debug("t3d(obj) = {t}".format(t=t3d))
                    logger.debug("t3d(cam) = {t}".format(t=self.position_3d))
                    transformation = self.position_3d.transformation3d_with(t3d)
                    logger.debug("transform = {t}".format(t=transformation))
                else:
                    transformation = Transformation3d(obj)
                obj_dict = {'name': obj.name,
                            'description': obj.get('Description', ''),
                            'type': obj.get('Type', ''),
                            'position': transformation.translation,
                            'orientation': transformation.rotation}
                self.local_data['visible_objects'].append(obj_dict)
                
        logger.debug("Visible objects: %s" % self.local_data['visible_objects'])


    def _check_visible(self, obj, bb):
        """ Check if an object lies inside of the camera frustum. 
        
        The behaviour of this method is impacted by the sensor's 
        property 'noocclusion': if true, only checks the object is in the
        frustum. Does not check it is actually visible (ie, not hidden
        away by another object).
        """
        # TrackedObjects was filled at initialization
        #  with the object's bounding boxes
        pos = obj.position
        bbox = [[bb_corner[i] + pos[i] for i in range(3)] for bb_corner in bb]

        if logger.isEnabledFor(logging.DEBUG):
            logger.debug("\n--- NEW TEST ---")
            logger.debug("OBJECT '{0}' AT {1}".format(obj, pos))
            logger.debug("CAMERA '{0}' AT {1}".format(
                                    self.blender_cam, self.blender_cam.position))
            logger.debug("BBOX: >{0}<".format(bbox))
            logger.debug("BBOX: {0}".format(bb))

        # Translate the bounding box to the current object position
        #  and check if it is in the frustum
        if self.blender_cam.boxInsideFrustum(bbox) != self.blender_cam.OUTSIDE:

            if not self.noocclusion:
                # Check that there are no other objects between the camera
                # and the selected object
                # NOTE: This is a very simple test. Hiding only the 'center'
                # of an object will make it invisible, even if the rest is
                # still seen from the camera
                closest_obj = self.bge_object.rayCastTo(obj)
                if closest_obj in [obj] + list(obj.children):
                    return True
            else:
                return True

        return False

########NEW FILE########
__FILENAME__ = stereo_unit
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import async_service
import morse.core.sensor
from morse.core import blenderapi
from functools import partial

class StereoUnit(morse.core.sensor.Sensor):
    """
    The purpose of this component is to link together one or more
    cameras, and provide them with the possibility to move together as a
    single unit. It will also provide the connection interface to use
    the information of the cameras attached to it. In the case of two
    cameras, it will provide the stereo information generated from the
    two camera images.

    Related components
    ------------------

    A stereo unit needs to be the parent of one or more :doc:`cameras
    <../sensors/video_camera>`. Otherwise, it does no useful function.

    The movement of the stereo unit is implemented by making it the child of a
    :doc:`Pan-Tilt unit <../actuators/ptu>` actuator.

    Here is an example of how to construct the whole stereo system to mount on top
    of a robot, using the Builder API. Note the order in which components are
    appended to each other, as this is important to get the desired functionality:

    .. code-block:: python

        from morse.builder import *

        # Add a robot
        atrv = ATRV()
        atrv.translate(z=0.1000)
        
        # A pan-tilt unit to be able to orient the cameras
        Platine = PTU()
        Platine.translate(x=0.2000, z=0.9000)
        atrv.append(Platine)
        
        # The STEREO UNIT, where the two cameras will be fixed
        Stereo = StereoUnit()
        Stereo.translate(z=0.0400)
        Platine.append(Stereo)
        
        # Left camera
        CameraL = VideoCamera()
        CameraL.translate(x=0.1000, y=0.2000, z=0.0700)
        Stereo.append(CameraL)
        CameraL.properties(capturing = True)
        CameraL.properties(cam_width = 320)
        CameraL.properties(cam_height = 240)
        CameraL.properties(cam_focal = 25.0000)
        
        # Right camera
        CameraR = VideoCamera()
        CameraR.translate(x=0.1000, y=-0.2000, z=0.0700)
        Stereo.append(CameraR)
        CameraR.properties(capturing = True)
        CameraR.properties(cam_width = 320)
        CameraR.properties(cam_height = 240)
        CameraR.properties(cam_focal = 25.0000)

    """

    _name = "Stereo Camera Unit"

    def __init__(self, obj, parent=None):
        """ Constructor method.
        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        self.num_cameras = 0
        self.camera_list = []
        # Create a list of the cameras attached to this component
        for child in obj.children:
            # Skip this object if it is not a component
            # It is most likely just a geometric shape object
            try:
                child['Component_Tag']
            except KeyError:
                continue

            camera_name = child.name
            # Store only the name of the camera All data from the camera
            # can be accessed later by using
            # blenderapi.persistantstorage().componentDict[camera_name],
            # which will return the instance of the camera object
            self.camera_list.append(camera_name)
            self.num_cameras += 1

        logger.info("Stereo Unit has %d cameras" % self.num_cameras)

        logger.info('Component initialized')

    def capture_completion(self, answer):
        self._expected_answer-= 1
        if self._expected_answer == 0:
            status, res = answer
            self.completed(status, res)

    def interrupt(self):
        for camera in self.camera_list:
            camera_instance = blenderapi.persistantstorage().componentDict[camera]
            camera_instance.interrupt()

    @async_service
    def capture(self, n):
        """
        The service takes an integer an argument and dispatch the call
        to all its individual cameras. The service ends when each camera
        has terminated its work.

        :param n: the number of call to each individual camera
        """
        self._expected_answer = self.num_cameras
        for camera in self.camera_list:
            camera_instance = blenderapi.persistantstorage().componentDict[camera]
            camera_instance.capture(partial(self.capture_completion), n)

    def default_action(self):
        """ Main function of this component. """
        pass

########NEW FILE########
__FILENAME__ = thermometer
import logging; logger = logging.getLogger("morse." + __name__)
import math
from sys import maxsize
from morse.core import blenderapi
import morse.core.sensor
from morse.helpers.components import add_data, add_property

class Thermometer(morse.core.sensor.Sensor):
    """
    This sensor emulates a Thermometer, measuring the temperature with respect
    to the distance to heat sources. It defines a default temperature throughout
    the scenario, which is affected by local fire sources. The temperature rises
    exponentially when the distance between the sensor and the heat source
    decreases. Its equation is given by:
    
    .. math::

     temperature = DefaultTemperature + \\Sigma_{s} FireTemperature(s) * \\exp ( - \\alpha * distance(s) )
     
    Each fire source must define a property named as the FireTag (default is 'Fire').
    If this property is an int or a float, its value is used as the source fire temperature. 
    """

    _name = "Thermometer Sensor"

    add_property('_tag', "Fire", "FireTag", "string",
                 "Tag indicating that an object is a fire source")
    add_property('_zero', 15.0, "DefaultTemperature", "float", 
                 "Default temperature: returned by the sensor when no source is detected")
    add_property('_fire', 200.0, "FireTemperature", "float",
                 "Temperature of fire sources. Can be overriden by objects using the FireTag property")
    add_property('_range', maxsize, "Range", "float",
                 "Maximum distance to which fire sources are detected")
    add_property('_alpha', .2, "Alpha", "float",
                 "Attenuation coefficient alpha")

    add_data('temperature', 0.0, "float", "Temperature in Celsius")

    def __init__(self, obj, parent=None):
        """ Constructor method.
            Receives the reference to the Blender object.
            The second parameter should be the name of the object's parent. """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        logger.info("Component initialized, runs at %.2f Hz ", self.frequency)

    def default_action(self):
        """ Compute the local temperature

        Temperature is measured dependent on the closest fire sources.
        """
        
        temp = float(self._zero)

        scene = blenderapi.scene()
        # Look for the fire sources marked so
        for obj in scene.objects:
            try:
                f = obj[self._tag]
                if type(f) == int or type(f) == float:
                    fire_intensity = float(f)
                else:
                    fire_intensity = self._fire
                    
                distance, gvect, lvect = self.bge_object.getVectTo(obj)
                if distance < self._range:
                    t = fire_intensity * math.exp(- self._alpha * distance)
                    temp += t
                    
            except KeyError as detail:
                logger.debug("Exception: " + str(detail))

        self.local_data['temperature'] = float(temp)

########NEW FILE########
__FILENAME__ = velocity
import logging; logger = logging.getLogger("morse." + __name__)

import morse.core.sensor
from morse.helpers.components import add_data
from math import degrees

class Velocity(morse.core.sensor.Sensor):
    """
    This sensor returns the linear and angular velocity of the sensor,
    both in robot frame and in world frame. Linear velocities are
    expressed in meter . sec ^ -1 while angular velocities are expressed
    in radian . sec ^ -1.

    The sensor expects that the associated robot has a physics controller.
    """

    _name = "Velocity"
    _short_descr = "A Velocity Sensor"

    add_data('linear_velocity', [0.0, 0.0, 0.0], "vec3<float>",
             'velocity in sensor x, y, z axes (in meter . sec ^ -1)')
    add_data('angular_velocity', [0.0, 0.0, 0.0], "vec3<float>",
             'rates in sensor x, y, z axes (in radian . sec ^ -1)')
    add_data('world_linear_velocity', [0.0, 0.0, 0.0], "vec3<float>",
             'velocity in world x, y, z axes (in meter . sec ^ -1)')

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.core.sensor.Sensor.__init__(self, obj, parent)

        # The robot needs a physics controller!
        # Since the sensor does not have physics
        if not bool(self.robot_parent.bge_object.getPhysicsId()):
            logger.error("The robot doesn't have a physics controller!")

        # make new references to the robot velocities and use those.
        self.robot_w = self.robot_parent.bge_object.localAngularVelocity
        self.robot_v = self.robot_parent.bge_object.localLinearVelocity
        self.robot_world_v = self.robot_parent.bge_object.worldLinearVelocity

        # get the quaternion which will rotate a vector from body to sensor frame
        self.rot_b2s = self.sensor_to_robot_position_3d().rotation.conjugated()
        logger.debug("body2sensor rotation RPY [% .3f % .3f % .3f]" %
                     tuple(degrees(a) for a in self.rot_b2s.to_euler()))

        logger.info("Component initialized, runs at %.2f Hz", self.frequency)


    def default_action(self):
        """ Get the linear and angular velocity of the blender object. """

        # Store the important data
        self.local_data['linear_velocity'] = self.rot_b2s * self.robot_v
        self.local_data['angular_velocity'] = self.rot_b2s * self.robot_w
        self.local_data['world_linear_velocity'] = self.robot_world_v.copy()

########NEW FILE########
__FILENAME__ = video_camera
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import async_service
from morse.core import status
import morse.core.blenderapi
from morse.core import mathutils
import morse.sensors.camera
from morse.helpers.components import add_data
import copy

BLENDER_HORIZONTAL_APERTURE = 32.0

class VideoCamera(morse.sensors.camera.Camera):
    """
    This sensor emulates a single video camera. It generates a series of
    RGBA images.  Images are encoded as binary char arrays, with 4 bytes
    per pixel.

    Camera calibration matrix
    -------------------------

    The camera configuration parameters implicitly define a geometric camera in
    blender units. Knowing that the **cam_focal** attribute is a value that
    represents the distance in Blender unit at which the largest image dimension is
    32.0 Blender units, the camera intrinsic calibration matrix is defined as

    +--------------+-------------+---------+
    | **alpha_u**  |      0      | **u_0** |
    +--------------+-------------+---------+
    |       0      | **alpha_v** | **v_0** |
    +--------------+-------------+---------+
    |       0      |      0      |    1    |
    +--------------+-------------+---------+

    where:

    - **alpha_u** == **alpha_v** = **cam_width** . **cam_focal** / 32 (we suppose
      here that **cam_width** > **cam_height**. If not, then use **cam_height** in
      the formula)
    - **u_0** = **cam_height** / 2
    - **v_0** = **cam_width** / 2

    See also :doc:`../sensors/camera` for generic informations about Morse cameras.
    """

    _name = "Video camera"
    _short_desc = "A camera capturing RGBA image"

    add_data('image', 'none', 'buffer',
           "The data captured by the camera, stored as a Python Buffer \
            class  object. The data is of size ``(cam_width * cam_height * 4)``\
            bytes. The image is stored as RGBA.")
    add_data('intrinsic_matrix', 'none', 'mat3<float>',
        "The intrinsic calibration matrix, stored as a 3x3 row major Matrix.")

    def __init__(self, obj, parent=None):
        """ Constructor method.

        Receives the reference to the Blender object.
        The second parameter should be the name of the object's parent.
        """
        logger.info('%s initialization' % obj.name)
        # Call the constructor of the parent class
        morse.sensors.camera.Camera.__init__(self, obj, parent)

        # Prepare the exportable data of this sensor
        self.local_data['image'] = ''

        # Prepare the intrinsic matrix for this camera.
        # Note that the matrix is stored in row major
        intrinsic = mathutils.Matrix.Identity(3)
        alpha_u = self.image_width  * \
                  self.image_focal / BLENDER_HORIZONTAL_APERTURE
        intrinsic[0][0] = alpha_u
        intrinsic[1][1] = alpha_u
        intrinsic[0][2] = self.image_width / 2.0
        intrinsic[1][2] = self.image_height / 2.0
        self.local_data['intrinsic_matrix'] = intrinsic

        self.capturing = False
        self._n = -1

        # Variable to indicate this is a camera
        self.camera_tag = True

        # Position of the robot where the last shot is taken
        self.robot_pose = copy.copy(self.robot_parent.position_3d)

        logger.info("Component initialized, runs at %.2f Hz ", self.frequency)

    def interrupt(self):
        self._n = 0
        morse.sensors.camera.Camera.interrupt(self)

    @async_service
    def capture(self, n):
        """
        Capture **n** images

        :param n: the number of images to take. A negative number means
                  take image indefinitely
        """
        self._n = n

    def default_action(self):
        """ Update the texture image. """

        # Grab an image from the texture
        if self.bge_object['capturing'] and (self._n != 0) :

            # Call the action of the parent class
            morse.sensors.camera.Camera.default_action(self)

            # NOTE: Blender returns the image as a binary string
            #  encoded as RGBA
            image_data = morse.core.blenderapi.cameras()[self.name()].source

            self.robot_pose = copy.copy(self.robot_parent.position_3d)

            # Fill in the exportable data
            self.local_data['image'] = image_data
            self.capturing = True

            if self._n > 0:
                self._n -= 1
                if self._n == 0:
                    self.completed(status.SUCCESS)
        else:
            self.capturing = False

########NEW FILE########
__FILENAME__ = communication_services
import logging; logger = logging.getLogger("morse." + __name__)
logger.setLevel(logging.DEBUG)
from morse.core.abstractobject import AbstractObject
from morse.core.exceptions import MorseRPCInvokationError
from morse.core.services import service
from morse.core import status, blenderapi
import morse.helpers.transformation 

def _robot_exists(robot):
    try:
        for obj, robot_instance in blenderapi.persistantstorage().robotDict.items():
            if obj.name == robot:
                return robot_instance
    except KeyError:
        try:
            for obj, robot_instance in blenderapi.persistantstorage().externalRobotDict.items():
                if obj.name == robot:
                    return robot_instance
        except KeyError:
            return None

class Communication(AbstractObject):
    def __init__(self):
        AbstractObject.__init__(self)

    def name(self):
        return "communication"

    @service
    def distance_and_view(self, robot1, robot2):
        """ Return the distance between the two robots, and a boolean which
        described if one can view the other. 
        """
        r1 = _robot_exists(robot1)
        r2 = _robot_exists(robot2)

        if not r1:
            raise MorseRPCInvokationError(robot1 + " does not exist in the simulation ")
        if not r2:
            raise MorseRPCInvokationError(robot2 + " does not exist in the simulation ")

        dist = r1.position_3d.distance(r2.position_3d)

        closest_obj = r1.bge_object.rayCastTo(r2.bge_object)

        return dist, closest_obj == r2.bge_object

    def action(self):
        pass


########NEW FILE########
__FILENAME__ = supervision_services
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import service
from morse.core import status, blenderapi, mathutils
from morse.blender.main import reset_objects as main_reset, close_all as main_close, quit as main_terminate
from morse.core.abstractobject import AbstractObject
from morse.core.exceptions import *
import json

def get_structured_children_of(blender_object):
    """ Returns a nested dictionary of the given objects children, recursively.
    The retun format is as follows:

    {blender_object.name: [children_dictionary, position, orientation]}

    where children_dictionary is another of the same format, but with the keys
    being the children of blender_object. This continues down the entire tree
    structure.

    :param KX_GameObject blender_object: The Blender object to return children
    for.
    """
    children = blender_object.children
    orientation = blender_object.worldOrientation.to_quaternion()
    position = blender_object.worldPosition
    structure = { blender_object.name: [{},
                                        (position.x, position.y, position.z),
                                        (orientation.x, orientation.y,
                                         orientation.z, orientation.w)
                                        ]
                }
    for c in children:
        structure[blender_object.name][0].update(
            get_structured_children_of(c) )
    return structure

def get_obj_by_name(name):
    """
    Return object in the scene associated to :param name:
    If it does not exists, throw a MorseRPCInvokationError
    """
    scene = blenderapi.scene()
    if name not in scene.objects:
        raise MorseRPCInvokationError(
                "Object '%s' does not appear in the scene." % name)
    return scene.objects[name]

class Supervision(AbstractObject):
    def __init__(self):
        AbstractObject.__init__(self)

    def name(self):
        return "simulation"

    @service
    def list_robots(self):
        """ Return a list of the robots in the current scenario

        Uses the list generated during the initialisation of the scenario
        """
        return [obj.name for obj in blenderapi.persistantstorage().robotDict.keys()]

    @service
    def reset_objects(self):
        """ Restore all simulation objects to their original position

        Upon receiving the request using sockets, call the
        'reset_objects' function located in morse/blender/main.py
        """
        contr = blenderapi.controller()
        main_reset(contr)
        return "Objects restored to initial position"

    @service
    def quit(self):
        """ Cleanly quit the simulation
        """
        contr = blenderapi.controller()
        main_close(contr)
        main_terminate(contr)

    @service
    def terminate(self):
        """ Terminate the simulation (no finalization done!)
        """
        contr = blenderapi.controller()
        main_terminate(contr)

    @service
    def activate(self, component_name):
        """ Enable the functionality of the component specified
        """
        try:
            blenderapi.persistantstorage().componentDict[component_name]._active = True
        except KeyError as detail:
            logger.warn("Component %s not found. Can't activate" % detail)
            raise MorseRPCTypeError("Component %s not found. Can't activate" % detail)

    @service
    def deactivate(self, component_name):
        """ Stop the specified component from calling its default_action method
        """
        try:
            blenderapi.persistantstorage().componentDict[component_name]._active = False
        except KeyError as detail:
            logger.warn("Component %s not found. Can't deactivate" % detail)
            raise MorseRPCTypeError("Component %s not found. Can't deactivate" % detail)

    @service
    def suspend_dynamics(self):
        """ Suspends physics for all object in the scene.
        """

        scene = blenderapi.scene()
        for object in scene.objects:
            object.suspendDynamics()

        return "Physics is suspended"

    @service
    def restore_dynamics(self):
        """ Resumes physics for all object in the scene.
        """

        scene = blenderapi.scene()
        for object in scene.objects:
            object.restoreDynamics()

        return "Physics is resumed"

    @service
    def details(self):
        """Returns a structure containing all possible details
        about the simulation currently running, including
        the list of robots, the list of services and datastreams,
        the list of middleware in use, etc.
        """

        simu = blenderapi.persistantstorage()
        details = {}

        # Retrieves the list of services and associated middlewares
        services = {}
        services_iface = {}
        for n, i in simu.morse_services.request_managers().items():
            services.update(i.services())
            for cmpt in i.services():
                services_iface.setdefault(cmpt, []).append(n)

        def cmptdetails(c):
            c = simu.componentDict[c.name]
            cmpt = {"type": type(c).__name__,}
            if c.name() in services:
                cmpt["services"] = services[c.name()]
                cmpt["service_interfaces"] = services_iface[c.name()]

            if c.name() in simu.datastreams:
                stream = simu.datastreams[c.name()]
                cmpt["stream"] = stream[0]
                cmpt["stream_interfaces"] = stream[1]

            return cmpt

        def robotdetails(r):
            robot = {"name": r.name(),
                    "type": type(r).__name__,
                    "components": {c.name:cmptdetails(c) for c in r.components},
                    }
            if r.name() in services:
                robot["services"] = services[r.name()]
                robot["services_interfaces"] = services_iface[r.name()]
            return robot

        for n, i in simu.datastreamDict.items():
            pass


        details['robots'] = [robotdetails(r) for n, r in simu.robotDict.items()]
        return details


    @service
    def set_log_level(self, component, level):
        """
        Allow to change the logger level of a specific component

        :param string component: the name of the logger you want to modify
        :param string level: the desired level of logging
        """

        my_logger = logging.getLogger('morse.' + component)
        try:
            my_logger.setLevel(level)
        except ValueError as exn:
            raise MorseRPCInvokationError(str(exn))


    @service
    def get_scene_objects(self):
        """ Returns a hierarchial dictonary structure of all objects in the scene
        along with their positions and orientations, formated as a Python string
        representation.
        The structure:
        {object_name: [dict_of_children, position_tuple, quaternion_tuple],
        object_name: [dict_of_children, position_tuple, quaternion_tuple],
        ...}
        """

        scene = blenderapi.scene()
        # Special Morse items to remove from the list
        remove_items = ['Scene_Script_Holder', 'CameraFP', '__default__cam__']
        top_levelers = [o for o in scene.objects
                        if o.parent is None and
                        not o.name in remove_items]

        objects = {}
        for obj in top_levelers:
            objects.update(get_structured_children_of(obj))

        return objects

    @service
    def set_object_visibility(self, object_name, visible, do_children):
        """ Set the visibility of an object in the simulation.

        Note: The object will still have physics and dynamics despite being invisible.

        :param string object_name: The name of the object to change visibility of.
        :param visible boolean: Make the object visible(True) or invisible(False)
        :param do_children boolean: If True then the visibility of all children of
        object_name is also set."""

        blender_object = get_obj_by_name(object_name)
        blender_object.setVisible(visible, do_children)
        return visible

    @service
    def set_object_dynamics(self, object_name, state):
        """ Enable or disable the dynamics for an individual object.

        Note: When turning on dynamics, the object will continue with the velocities
        it had when it was turned off.

        :param string object_name: The name of the object to change.
        :param state boolean: Turn on dynamics(True), or off (False)
        """

        blender_object = get_obj_by_name(object_name)
        if state:
            blender_object.restoreDynamics()
        else:
            blender_object.suspendDynamics()
        return state

    @service
    def set_camarafp_far_clip(self, far_clip):
        """ Set the CamaraFP (MORSE' environment camera) far clip distance

        :param far_clip: The camera's far clip distance.
        :type  far_clip: float
        """
        if far_clip > 0:
            blender_object = get_obj_by_name('CameraFP')
            blender_object.far = far_clip
            return far_clip
        return 0

    @service
    def set_camarafp_position(self, position):
        """ Set the CamaraFP (MORSE' environment camera) world position. [x, y, z]

        :param position: The camera's world position. [x, y, z].
        :type  position: list(float)
        """
        blender_object = get_obj_by_name('CameraFP')
        blender_object.worldPosition = position
        return position

    @service
    def set_camarafp_transform(self, transform):
        """ Set the CamaraFP (MORSE' environment camera) world space transform matrix.

        :param transform: The camera's world space transform matrix.
        :type  transform: 4x4 Matrix [[float]]
        """
        try:
            blender_object = get_obj_by_name('CameraFP')
            blender_object.worldTransform = mathutils.Matrix(transform)
            return transform
        except SystemError: # if the matrix is not 4x4 numpy raises a SystemError
            raise MorseRPCInvokationError( "The Matrix must be 4x4 [[float]]" )

    @service
    def set_camarafp_projection_matrix(self, projection_matrix):
        """ Set the CamaraFP (MORSE' environment camera) 4x4 projection matrix

        :param projection_matrix: The camera's 4x4 projection matrix.
        :type  projection_matrix: 4x4 Matrix [[float]]
        """
        try:
            blender_object = get_obj_by_name('CameraFP')
            blender_object.projection_matrix = mathutils.Matrix(projection_matrix)
            return projection_matrix
        except SystemError: # if the matrix is not 4x4 numpy raises a SystemError
            raise MorseRPCInvokationError( "The Matrix must be 4x4 [[float]]" )

    @service
    def get_camarafp_projection_matrix(self):
        """ Get the CamaraFP (MORSE' environment camera) 4x4 projection matrix
        """
        blender_object = get_obj_by_name('CameraFP')
        return [list(vec) for vec in blender_object.projection_matrix]

    def action(self):
        pass

########NEW FILE########
__FILENAME__ = time_services
import logging; logger = logging.getLogger("morse." + __name__)
from morse.core.services import service, async_service
from morse.core import status, blenderapi
from morse.core.abstractobject import AbstractObject
from morse.core.morse_time import time_isafter

class TimeServices(AbstractObject):
    def __init__(self):
        AbstractObject.__init__(self)
        self.time = blenderapi.persistantstorage().time
        self._alarm_time = None

    def name(self):
        return "time"

    @service
    def mode(self):
        """ Return the current time management mode """
        return self.time.name()

    @service
    def now(self):
        """ Return the simulator time, in seconds, since Epoch """
        return self.time.time

    @service
    def statistics(self):
        """
        Return various statistics associated to the specific time
        management mode
        """
        return self.time.statistics()

    @async_service
    def sleep(self, time):
        """
        Sleep  for time seconds

        :param: a float representing the time to wait (in second)
        """

        self._alarm_time = self.time.time + float(time)
        logger.debug('alarm registered for %f' % self._alarm_time)

    def action(self):
        if self._alarm_time and time_isafter(self.time.time, self._alarm_time):
            logger.debug('alarm fired at %f difference %f' % (self.time.time, self._alarm_time - self.time.time))
            self._alarm_time = None
            self.completed(status.SUCCESS)

########NEW FILE########
__FILENAME__ = exceptions

class MorseTestingError(Exception):
    """ General MORSE unittesting Error. """
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

########NEW FILE########
__FILENAME__ = ros
""" ROS-based MorseTestCase (unit-tests)

The main feature is to launch ROS core at start.
"""

from morse.testing.testing import MorseTestCase, testlogger

import os
import sys
import subprocess

try:
    import roslib
except ImportError as error:
    testlogger.error("Could not find ROS. source setup.[ba]sh ?")
    raise error

class RosTestCase(MorseTestCase):
    def setUpMw(self):
        try:
            self.roscore_process = subprocess.Popen(['roscore'])
        except OSError as ose:
            testlogger.error("Error while launching roscore ! Check you can run it from command-line\n")
            raise ose

    def tearDownMw(self):
        self.roscore_process.terminate()

########NEW FILE########
__FILENAME__ = testing
import logging
#testrunnerlogger = logging.getLogger("test.runner")
testlogger = logging.getLogger("morsetesting.general")

import sys, os
from abc import ABCMeta, abstractmethod
import unittest
import inspect
import tempfile
from time import sleep
import threading # Used to be able to timeout when waiting for Blender initialization
import subprocess
import signal

from morse.testing.exceptions import MorseTestingError
from morse.core.morse_time import TimeStrategies

BLENDER_INITIALIZATION_TIMEOUT = 15 # seconds

MODE_INDEX = 0
CURRENT_TIME_MODE = None
ALL_TIME_MODES = None
INITIALIZED_LOGGER = False

class MorseTestRunner(unittest.TextTestRunner):

        
    def setup_logging(self):
        global INITIALIZED_LOGGER
        logger = logging.getLogger('morsetesting')
        logger.setLevel(logging.DEBUG)

        ch = logging.StreamHandler()
        ch.setLevel(logging.DEBUG)

        formatter = logging.Formatter('[%(asctime)s (%(levelname)s)]   %(message)s')

        ch.setFormatter(formatter)

        logger.addHandler(ch)
        INITIALIZED_LOGGER = True

    def run(self, suite):
        global INITIALIZED_LOGGER
        if not INITIALIZED_LOGGER:
            self.setup_logging()
        return unittest.TextTestRunner.run(self, suite)

def follow(file):
    """ Really emulate tail -f

    See http://stackoverflow.com/questions/1475950/tail-f-in-python-with-no-time-sleep
    for a detailled discussion on the subject
    """
    while True:
        line = file.readline()
        if not line:
            sleep(0.1)    # Sleep briefly
            continue
        yield line

class MorseSwitchTimeMode(unittest.TestCase):
    def test_switch(self):
        global ALL_TIME_MODES
        global CURRENT_TIME_MODE
        global MODE_INDEX
        CURRENT_TIME_MODE = ALL_TIME_MODES[MODE_INDEX]
        MODE_INDEX += 1

class MorseTestCase(unittest.TestCase):

    # Make this an abstract class
    __metaclass__ = ABCMeta


    def setUpMw(self):
        """ This method can be overloaded by subclasses to define
        environment setup, before the launching of the Morse environment
        pass
        """
        pass

    def _checkMorseException(self):
        """ Check in the Morse output if some python error happens"""

        with open(self.logfile_name) as log:
            lines = follow(log)
            for line in lines:
                # Python Error Case
                if "[ERROR][MORSE]" in line:
                    testlogger.error(line.strip())
                    testlogger.error("Exception detected in Morse execution : "
                                     "see %s for details."
                                     " Exiting the current test !" % self.logfile_name)
                    os.kill(os.getpid(), signal.SIGINT)
                    return

                # End of simulation, exit the thread
                if "EXITING SIMULATION" in line:
                    return

    def setUp(self):
        
        testlogger.info("Starting test " + self.id() + " in " + TimeStrategies.human_repr(CURRENT_TIME_MODE))

        self.logfile_name = self.__class__.__name__ + ".log"
        # Wait for a second
        #  to wait for ports open in previous tests to be closed
        sleep(1)

        self.morse_initialized = False
        self.setUpMw()
        self.startmorse(self)
        self.t = threading.Thread(target=self._checkMorseException)
        self.t.start()

    def tearDownMw(self):
        """ This method can be overloaded by subclasses to clean up
        environment setup
        """
        pass
    
    def tearDown(self):
        self.stopmorse()
        self.tearDownMw()
        self.logfile.close() # force to flush
        self.t.join()

        
    @abstractmethod
    def setUpEnv(self):
        """ This method must be overloaded by subclasses to define a
        simulation environment.

        The code must follow the :doc:`Builder API <morse/dev/builder>`
        convention (without the import of the `morsebuilder` module which
        is automatically added).
        """
        pass

    def wait_initialization(self):
        """ Wait until Morse is initialized """

        testlogger.info("Waiting for MORSE to initialize... (timeout: %s sec)" % \
                        BLENDER_INITIALIZATION_TIMEOUT)
        with open(self.logfile_name) as log:
            lines = follow(log)
            for line in lines:
                if  ("[ERROR][MORSE]" in line) or ("INITIALIZATION ERROR" in line):
                    testlogger.error("Error during MORSE initialization! Check "
                                     "the log file.")
                    return
                if "SCENE INITIALIZED" in line:
                    self.morse_initialized = True
                    return

    def run(self, result=None):
        """ Overwrite unittest.TestCase::run

        Detect KeyBoardInterrupt exception , due to user or a SIGINIT In
        particular, it can happen if we detect an exception in the Morse
        execution. In this case, clean up correctly the environnement.
        """
       
        try:
            return unittest.TestCase.run(self, result)
        except KeyboardInterrupt as e:
            self.tearDownMw()
            if self.pid:
                os.kill(self.pid, signal.SIGKILL)
            if result:
                result.addError(self, sys.exc_info())

    def _extract_pid(self):
        """ Extract the pid from the log file.

        We can not simply rely on Popen.subprocess.pid because we need the PID of the
        Blender process itself, not the (Python) MORSE process.
        """

        with open(self.logfile_name) as log:
            for line in log:
                if "PID" in line:
                    words = line.split()
                    return int(words[-1])


    def startmorse(self, test_case):
        """ This starts MORSE in a new process, passing the script itself as parameter (to
        build the scene via the Builder API).
        """
        
        temp_builder_script = self.generate_builder_script(test_case)
        try:
            original_script_name = os.path.abspath(inspect.stack()[-1][1])

            try:
                prefix = os.environ['MORSE_ROOT']
            except KeyError:
                prefix=""

            if prefix == "":
                cmd = 'morse'
            else:
                cmd = prefix + "/bin/morse"

            self.logfile = open(self.logfile_name, 'w')
            self.morse_process = subprocess.Popen([cmd, 'run', temp_builder_script], stdout=self.logfile, stderr=subprocess.STDOUT)
        except OSError as ose:
            testlogger.error("Error while launching MORSE! Check you can run it from command-line\n" + \
                    " and if you use the $MORSE_ROOT env variable, check it points to a correct " + \
                    " place!")
            raise ose

        t = threading.Thread(target=self.wait_initialization)
        t.start()
        t.join(BLENDER_INITIALIZATION_TIMEOUT)
        
        if self.morse_initialized:
            self.pid = self._extract_pid()
            testlogger.info("MORSE successfully initialized with PID %s" % self.pid)
        else:
            self.morse_process.terminate()
            raise MorseTestingError("MORSE did not start successfully! Check %s "
                                    "for details." % self.logfile_name)
    
    def stopmorse(self):
        """ Cleanly stop MORSE
        """
        import socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            sock.connect(("localhost", 4000))
            sock.send(b"id1 simulation quit\n")
        except (socket.error, KeyboardInterrupt):
            sock.close()
            sock = None
            testlogger.info("MORSE crashed")

        if sock:
            sock.close()
            with open(self.logfile_name) as log:
                lines = follow(log)
                for line in lines:
                    if "EXITING SIMULATION" in line:
                        return

        if self.pid:
            os.kill(self.pid, signal.SIGKILL)
        testlogger.info("MORSE stopped")
    
    def generate_builder_script(self, test_case):
        
        tmp_name = ""
        # We need to generate a temp builder file in case of running
        # several test cases with different environment:
        # Blender must be restarted and called again with the right
        # environment.
        with tempfile.NamedTemporaryFile(delete = False) as tmp:
            tmp.write(b"from morse.builder import *\n")
            tmp.write(b"from morse.builder.actuators import *\n")
            tmp.write(b"from morse.builder.sensors import *\n")
            tmp.write(b"from morse.builder.blenderobjects import *\n")
            tmp.write(b"class MyEnv():\n")
            tmp.write(inspect.getsource(test_case.setUpEnv).encode())
            tmp.write(b"        env.set_time_strategy(")
            tmp.write(TimeStrategies.python_repr(CURRENT_TIME_MODE))
            tmp.write(b")\n")
            tmp.write(b"MyEnv().setUpEnv()\n")
            tmp.flush()
            tmp_name = tmp.name
        
        testlogger.info("Created a temporary builder file for test-case " +\
            test_case.__class__.__name__)
        return tmp_name


class MorseMoveTestCase(MorseTestCase):
    """ This subclass of MorseTestCase can be used to check for moving
    actuator, basically by testing a complete pose

    This class assumes lot of stuff to work properly:
        - the tested robot is called 'robot'
        - the pose sensor is called 'robot.pose'
        - if assertAlmostEqualPositionThenFix,  it assumes there is a
            - a 'robot.motion' actuator (basically what we test)
            - a 'robot.teleport' actuator (to move to a specific
              situation)
    """

    def assertAlmostEqualPosition(self, morse, tested_pos, precision):
        """ 
        Test against a position, presented as an array of 6 double (x,
        y, z, yaw, pitch, roll)
        """
        pose = morse.robot.pose.get()
        self.assertAlmostEqual(pose['x'], tested_pos[0], delta=precision)
        self.assertAlmostEqual(pose['y'], tested_pos[1], delta=precision)
        self.assertAlmostEqual(pose['z'], tested_pos[2], delta=precision)
        self.assertAlmostEqual(pose['yaw'], tested_pos[3], delta=precision)
        self.assertAlmostEqual(pose['pitch'], tested_pos[4], delta=precision)
        self.assertAlmostEqual(pose['roll'], tested_pos[5], delta=precision)

    def assertAlmostEqualPositionThenFix(self, morse, tested_pos, precision):
        """
        Test against a position, presented as an array of 6 double (x,
        y, z, yaw, pitch, roll). When done, move the robot to this
        specific position. It allows to reduce the cumulated error
        between the different part of the test
        """
        self.assertAlmostEqualPosition(morse, tested_pos, precision)

        morse.deactivate('robot.motion')
        morse.activate('robot.teleport')
        # +0.01  on z to be a bit higher than the ground
        morse.robot.teleport.publish(
                {'x': tested_pos[0],
                 'y': tested_pos[1],
                 'z': tested_pos[2] + 0.01, 
                 'yaw': tested_pos[3],
                 'pitch': tested_pos[4],
                 'roll': tested_pos[5]})
        morse.sleep(0.1)
        morse.deactivate('robot.teleport')
        morse.activate('robot.motion')
        morse.sleep(0.1)


class MorseBuilderFailureTestCase(MorseTestCase):
    """ This subclass of MorseTestCase can be used to test MORSE handles
    properly ill-constructed Builder scripts.

    It will *fail* if the Blender Game Engine get started.
    """

    # Make this an abstract class
    __metaclass__ = ABCMeta

    def wait_initialization(self):
        """ Wait until Morse is initialized """

        testlogger.info("Waiting for MORSE to parse the scene... (timeout: %s sec)" % \
                        BLENDER_INITIALIZATION_TIMEOUT)
        # we assume we will correctly detect Builder script issue, so wait_initialization
        # 'succeed'.
        self.morse_initialized = True

        with open(self.logfile_name) as log:
            lines = follow(log)
            for line in lines:
                if "Blender Game Engine Started" in line:
                    testlogger.error("Blender Game Engine started!"
                                     " This is not expected."
                                     " See %s for details." % self.logfile_name)
                    os.kill(os.getpid(), signal.SIGINT)
                    return
                elif "[ERROR][MORSE]" in line:
                    # use 'info' since we suppose to get this error
                    testlogger.info("MORSE initialization error: %s"%line.strip())
                    return

    def _checkMorseException(self):
        return


def main(*args, **kwargs):
    test_cases = args
    time_modes = kwargs.get('time_modes', [TimeStrategies.BestEffort, TimeStrategies.FixedSimulationStep])
    import sys
    if sys.argv[0].endswith('blender'):
        # If we arrive here from within MORSE, we have probably run
        # morse [exec|run] my_test.py
        # If this case, simply build the environment based on the
        # setUpEnv of the first test.
        for test_class in test_cases:
            test_class().setUpEnv()
            return
    import unittest
    suite = unittest.TestSuite()
    loader = unittest.TestLoader()
    global ALL_TIME_MODES
    ALL_TIME_MODES = time_modes

    tests = None
    switch = loader.loadTestsFromTestCase(MorseSwitchTimeMode)
    for test_class in test_cases:
        tests = loader.loadTestsFromTestCase(test_class)
    for time_mode in time_modes:
        suite.addTests(switch)
        suite.addTests(tests)
    sys.exit(not MorseTestRunner().run(suite).wasSuccessful())

########NEW FILE########
__FILENAME__ = armature_pose_testing
#! /usr/bin/env python
"""
This script tests the KUKA LWR arm, both the data and service api
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse, MorseServiceFailed

# Include this import to be able to use your test file as a regular
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

class ArmaturePoseTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """

        robot = ATRV('robot')

        kuka_lwr = KukaLWR('arm')
        robot.append(kuka_lwr)
        kuka_lwr.translate(z=0.9)
        kuka_lwr.add_service('socket')

        kuka_posture = ArmaturePose('arm_pose')
        kuka_lwr.append(kuka_posture)
        kuka_posture.add_stream('socket')
        kuka_posture.add_service('socket')

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_pose_services(self):

        precision = 0.02
        JOINTS = ['kuka_1', 'kuka_2', 'kuka_3', 'kuka_4', 'kuka_5', 'kuka_6', 'kuka_7']

        with Morse() as simu:
            self.assertEqual(simu.robot.arm.arm_pose.get_joints(), JOINTS)

            #res = simu.robot.arm.get_rotations()
            #for joint in joints:
            #    for i in range(3):
            #        self.assertAlmostEqual(res[joint][i], 0.0, delta=precision)

            #res = simu.robot.arm.get_rotation('kuka_5').result()
            #for i in range(3):
            #    self.assertAlmostEqual(res[i], 0.0, delta=precision)

            #res = simu.robot.arm.get_rotation('pipo')
            #self.assertEqual(type(res.exception(2)), MorseServiceFailed)

            res = simu.robot.arm.arm_pose.get_joints_length().result()
            self.assertAlmostEqual(res['kuka_1'], 0.31, delta=precision)
            self.assertAlmostEqual(res['kuka_2'], 0.20, delta=precision)
            self.assertAlmostEqual(res['kuka_3'], 0.20, delta=precision)
            self.assertAlmostEqual(res['kuka_4'], 0.20, delta=precision)
            self.assertAlmostEqual(res['kuka_5'], 0.19, delta=precision)
            self.assertAlmostEqual(res['kuka_6'], 0.08, delta=precision)
            self.assertAlmostEqual(res['kuka_7'], 0.13, delta=precision)

            # Move the arm now, and get the measure 
            angles = [1.57, 2.0, 1.0, -1.28, 1.1, -2.0, 1.0]
            simu.robot.arm.set_rotations(angles)
            simu.sleep(0.1)

            pose = simu.robot.arm.arm_pose.get_state().result()

            target = dict(zip(JOINTS, angles))
            
            for j, v in pose.items():
                self.assertAlmostEqual(v, target[j], delta=precision)

    def test_pose_stream(self):

        precision = 0.02
        JOINTS = ['kuka_1', 'kuka_2', 'kuka_3', 'kuka_4', 'kuka_5', 'kuka_6', 'kuka_7']

        with Morse() as simu:

            pose = simu.robot.arm.arm_pose.get()

            # 7 joints + timestamp
            self.assertEqual(len(pose), 7 + 1) 

            self.assertEqual(set(pose.keys()), set(JOINTS).union(set(['timestamp'])))

            for j, v in pose.items():
                if j != 'timestamp':
                    self.assertAlmostEqual(v, 0.0, delta=precision)

            simu.robot.arm.set_rotation("kuka_2", 1).result()
            simu.sleep(0.1)
            pose = simu.robot.arm.arm_pose.get()

            self.assertAlmostEqual(simu.robot.arm.arm_pose.get()["kuka_2"], 1.0, delta = precision)

            for j, v in pose.items():
                if j != "kuka_2" and j != 'timestamp':
                    self.assertAlmostEqual(v, 0.0, delta=precision)


            # Move the arm now, and get the measure 
            angles = [1.57, 2.0, 1.0, -1.28, 1.0, -2.0, 1.0]
            simu.robot.arm.set_rotations(angles)
            simu.sleep(0.1)

            target = dict(zip(JOINTS, angles))
            pose = simu.robot.arm.arm_pose.get()
            for j, v in pose.items():
                if j != 'timestamp':
                    self.assertAlmostEqual(v, target[j], delta=precision)


            angles = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
            simu.robot.arm.set_rotations(angles)
            simu.sleep(0.1)

            target = dict(zip(JOINTS, angles))
            pose = simu.robot.arm.arm_pose.get()
            for j, v in pose.items():
                if j != 'timestamp':
                    self.assertAlmostEqual(v, target[j], delta=precision)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(ArmaturePoseTest)

########NEW FILE########
__FILENAME__ = armature_testing
#! /usr/bin/env python
"""
This script tests the KUKA LWR arm, both the data and service api
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse, MorseServiceFailed

# Include this import to be able to use your test file as a regular
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

JOINTS = ['kuka_1', 'kuka_2', 'kuka_3', 'kuka_4', 'kuka_5', 'kuka_6', 'kuka_7']

class ArmatureTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """

        robot = FakeRobot()

        arm = KukaLWR()
        robot.append(arm)
        arm.add_stream('socket')
        arm.add_service('socket')

        pose = Pose()
        pose.add_stream('socket')
        pose.translate(z=1.3105)
        arm.append(pose)

        arm_pose = ArmaturePose()
        arm.append(arm_pose)
        arm_pose.add_stream('socket')

        motion = Teleport()
        robot.append(motion)
        motion.add_service('socket')

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def _check_state(self, simu, angles, precision = 0.050):

        pose = simu.robot.arm.arm_pose.get()
        target = dict(zip(JOINTS, angles))

        for j, v in pose.items():
            if j != 'timestamp':
                self.assertAlmostEqual(v, target[j], delta=precision)

    def _check_pose(self, simu, x, y, z, pitch, precision = 0.01):
            self.assertAlmostEqual(simu.robot.arm.pose.get()['x'], x, delta = precision)
            self.assertAlmostEqual(simu.robot.arm.pose.get()['y'], y, delta = precision)
            self.assertAlmostEqual(simu.robot.arm.pose.get()['z'], z, delta = precision)
            self.assertAlmostEqual(simu.robot.arm.pose.get()['pitch'], pitch, delta = precision)



    def test_object_attach(self):
        """ Checks that attached object are indeed attached at the right place.
        """
        precision = 0.02

        with Morse() as simu:

            self._check_pose(simu, 0., 0., 1.3105, 0.)
            simu.robot.motion.translate(1.0)
            simu.sleep(0.1)
            self._check_pose(simu, 1., 0., 1.3105, 0.)
            simu.robot.arm.set_rotation("kuka_2", math.radians(-90)).result()
            simu.sleep(0.1)
            self._check_pose(simu, 2., 0., 0.3105, math.radians(90))

    def test_immediate_api(self):
        """ Tests the services that have an immediate result
        (no speed limit taken into account)

        """
        # TODO: check translations!

        precision = 0.02

        with Morse() as simu:
            simu.robot.arm.set_rotation("kuka_2", 1).result() # basic rotation
            simu.sleep(0.1)
            self.assertAlmostEqual(simu.robot.arm.arm_pose.get()["kuka_2"], 1.0, delta = precision)

            simu.robot.arm.set_rotation("kuka_2", 4000).result() # rotation clamping
            simu.sleep(0.1)
            self.assertAlmostEqual(simu.robot.arm.arm_pose.get()["kuka_2"], 2.09, delta = precision)

            res = simu.robot.arm.set_rotation('pipo',0) # inexistant joint
            self.assertEqual(type(res.exception(1)), MorseServiceFailed)

            res = simu.robot.arm.set_translation('kuka_2',0) # non prismatic joint
            self.assertEqual(type(res.exception(1)), MorseServiceFailed)


            # note that set_rotations is tested in armature_pose_testing

    def test_motion_services(self):
        """ Tests the services that have take some time to move
        (joint speed limit taken into account)
        """
        # TODO: check translations!

        precision = 0.02
        with Morse() as simu:
            simu.robot.arm.rotate("kuka_2", 0.5).result() # basic rotation
            self.assertAlmostEqual(simu.robot.arm.arm_pose.get()["kuka_2"], 0.5, delta = precision)
            simu.robot.arm.rotate("kuka_2", 4000).result() # rotation clamping
            self.assertAlmostEqual(simu.robot.arm.arm_pose.get()["kuka_2"], 2.09, delta = precision)

            res = simu.robot.arm.rotate('pipo',0) # inexistant joint
            self.assertEqual(type(res.exception(1)), MorseServiceFailed)

            res = simu.robot.arm.translate('kuka_2',0) # non prismatic joint
            self.assertEqual(type(res.exception(1)), MorseServiceFailed)

            simu.robot.arm.set_rotation("kuka_2", 0).result() # back to origin
            act = simu.robot.arm.rotate("kuka_2", 1, 0.5)
            self.assertFalse(act.done())
            simu.sleep(1)
            self.assertFalse(act.done())
            self.assertAlmostEqual(simu.robot.arm.arm_pose.get()["kuka_2"], 0.5, delta = precision)
            simu.sleep(1.1)
            self.assertTrue(act.done())

    def test_trajectory(self):

        traj0 = {'points': [
                    {'position': [0.0, 1.57, 0.0, 0.0, 0.0, 0.0, 0.0],
                     'time_from_start': 1.0}
                    ]
                }

        traj1 = {'points': [
                    {'positions': [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                     'time_from_start': 1.0},
                    {'positions': [0.0, 1.57, 0.0, -1.57, 0.0, 1.57, 0.0],
                     'time_from_start': 4.0},
                    {'positions': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                     'time_from_start': 6.0}
                    ]
                }

        with Morse() as simu:

            act = simu.robot.arm.trajectory(traj0)
            self.assertEqual(type(act.exception(1)), MorseServiceFailed) # typo in trajectory ('position' instead of 'positions')
            self.assertIn('positions', str(act.exception()))

            act = simu.robot.arm.trajectory(traj1)
            simu.sleep(1)
            self._check_state(simu, [0.0, 1.0, 0,0,0,0,0])
            simu.sleep(3)
            self._check_state(simu, [0.0, 1.57, 0, -1.57, 0, 1.57, 0])
            simu.sleep(2)
            self._check_state(simu, [0.0] * 7)
            simu.sleep(1)
            self._check_state(simu, [0.0] * 7)

            # check 'starttime' parameter
            act = simu.robot.arm.set_rotations([0.0] * 7)
            traj2 = {'starttime': simu.time() + 1,
                    'points': [
                        {'positions': [0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        'time_from_start': 1.0}
                        ]
                    }

            act = simu.robot.arm.trajectory(traj2)
            simu.sleep(0.5)
            self._check_state(simu, [0.0] * 7)
            simu.sleep(0.5)
            simu.sleep(1)
            self._check_state(simu, [0.0, 1.0, 0,0,0,0,0])
            simu.sleep(1)
            self._check_state(simu, [0.0, 1.0, 0,0,0,0,0])

            # Check action cancellation
            act = simu.robot.arm.set_rotations([0.0] * 7)

            traj2['starttime'] = simu.time() + 1
            act = simu.robot.arm.trajectory(traj2)
            simu.sleep(0.5)
            act.cancel()
            simu.sleep(1)
            self._check_state(simu, [0.0] * 7)

    def test_ik_immediate(self):

        IK_TARGET = "ik_target.robot.arm.kuka_7"

        with Morse() as simu:
            self.assertEqual(simu.robot.arm.list_IK_targets(), [IK_TARGET])
            self._check_pose(simu, 0., 0., 1.3105, 0.)

            simu.robot.arm.place_IK_target(IK_TARGET, [0,0,2], None, False) # absolute location
            simu.sleep(0.1)
            self._check_pose(simu, 0., 0., 1.3105, 0.)

            simu.robot.arm.place_IK_target(IK_TARGET, [1,0,0.3105], None, False)
            simu.sleep(1) # with iterative IK solvers like iTaSC, the IK chain does not reach the end position immediately
            self._check_pose(simu, 0.778, 0., 0.363, 0.02)

            simu.robot.arm.place_IK_target(IK_TARGET, [1,0,0.3105], [math.pi/2, -math.pi/2, -math.pi], False) # arm should be horizontal
            simu.sleep(1) # with iterative IK solvers like iTaSC, the IK chain does not reach the end position immediately
            self._check_pose(simu, 1.0, 0., 0.3105, math.radians(90))

            # back to original position
            simu.robot.arm.place_IK_target(IK_TARGET, [0,0,2], [math.pi/2, 0., -math.pi], False) # absolute location
            simu.sleep(1.)
            self._check_pose(simu, 0., 0., 1.3105, 0.)

            simu.robot.arm.place_IK_target(IK_TARGET, [-1, 0, -1.6895], None) # relative position
            simu.sleep(1) # with iterative IK solvers like iTaSC, the IK chain does not reach the end position immediately
            self._check_pose(simu, -0.778, 0., 0.363, -0.02)

            simu.robot.arm.place_IK_target(IK_TARGET, [0.,0.,0.], [0., -math.pi/2, 0.]) # relative rotation
            simu.sleep(1) # with iterative IK solvers like iTaSC, the IK chain does not reach the end position immediately
            self._check_pose(simu, -1.0, 0., 0.3105, -math.radians(90))




    def test_ik_motion(self):

        IK_TARGET = "ik_target.robot.arm.kuka_7"

        with Morse() as simu:
            self.assertEqual(simu.robot.arm.list_IK_targets(), [IK_TARGET])
            self._check_pose(simu, 0., 0., 1.3105, 0.)

            simu.robot.arm.move_IK_target(IK_TARGET, [0,0,2], None, False).result() # absolute location
            self._check_pose(simu, 0., 0., 1.3105, 0.)

            simu.robot.arm.move_IK_target(IK_TARGET, [1,0,0.3105], None, False).result()
            self._check_pose(simu, 0.778, 0., 0.363, 0.02)

            simu.robot.arm.move_IK_target(IK_TARGET, [1,0,0.3105], [math.pi/2, -math.pi/2, -math.pi], False).result() # arm should be horizontal
            self._check_pose(simu, 1.0, 0., 0.3105, math.radians(90))

            # back to original position
            simu.robot.arm.move_IK_target(IK_TARGET, [0,0,2], [math.pi/2, 0., -math.pi], False).result() # absolute location
            self._check_pose(simu, 0., 0., 1.3105, 0.)

            simu.robot.arm.move_IK_target(IK_TARGET, [-1, 0, -1.6895], None).result() # relative position
            self._check_pose(simu, -0.778, 0., 0.363, -0.02)

            simu.robot.arm.move_IK_target(IK_TARGET, [0.,0.,0.], [0., -math.pi/2, 0.]).result() # relative rotation
            self._check_pose(simu, -1.0, 0., 0.3105, -math.radians(90))

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(ArmatureTest)

########NEW FILE########
__FILENAME__ = base_testing
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
from morse.testing.testing import MorseTestCase

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

class BaseTest(MorseTestCase):

    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        # Adding 4 robots
        # no name provided, use the name of the associated variable
        jido = Jido()

        # use explicitly name provided
        robot2 = ATRV('mana')

        # setup the name using explicitly robot3.name
        robot3 = ATRV()
        robot3.name = 'dala'

        # no name provided, use variable name, old school style
        atrv = ATRV()
        
        env = Environment('empty', fastmode = True)

    def test_list_robots(self):
        """ Tests the simulator can return the list of robots
        
        This test is guaranteed to be started only when the simulator
        is ready.
        """
        
        # Initialize a socket connection to the simulator
        import socket
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("localhost", 4000))
        sockf = s.makefile()
        
        # Queries for the list of robots
        s.send(b"id1 simulation list_robots\n")
        
        result = sockf.readline()
        id, success, robots = result.strip().split(' ', 2)
        self.assertEquals(success, "SUCCESS")
        
        import ast
        robotsset = set(ast.literal_eval(robots))
        self.assertEquals(robotsset, {'jido', 'mana', 'dala', 'atrv'})
        sockf.close()
        s.close()

    def test_socket_request_parser_resilience(self):
        """ Tests that the socket request parser is resilient to
        useless whitespaces.
        
        """
        
        # Initialize a socket connection to the simulator
        import socket
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("localhost", 4000))
        sockf = s.makefile()
        
        queries = [b"id1 simulation list_robots\n",
                   b"id1  simulation list_robots\n",
                   b"id1\tsimulation\tlist_robots\n",
                   b"id1 \t simulation \t list_robots\n",
                   b"   id1 simulation list_robots  \n"]

        for q in queries:
            s.send(q)
            result = sockf.readline()
            id, success, robots = result.strip().split(' ', 2)
            self.assertEquals(success, "SUCCESS")

        sockf.close()
        s.close()


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(BaseTest)

########NEW FILE########
__FILENAME__ = battery_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse

def send_pose(s, x, y):
    s.publish({'x' : x, 'y' : y, 'z' : 0.0, 'yaw' : 0.0, 'pitch' : 0.0, 'roll' : 0.0})

class BatteryTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = ATRV()

        battery = Battery()
        battery.add_stream('socket')
        battery.properties(DischargingRate = 10.0)
        robot.append(battery)

        teleport = Teleport()
        teleport.add_stream('socket')
        robot.append(teleport)

        charging_zone = Zone(type = 'Charging')
        charging_zone.size = [5.0, 5.0, 5.0]
        charging_zone.translate(x = 10.0, z = 2.0)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_read_battery(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            bat_stream = morse.robot.battery
            teleport_stream = morse.robot.teleport

            bat = bat_stream.get()
            cur_bat = bat['charge']
            morse.sleep(2.0)

            bat = bat_stream.get()
            # Can't be really precise as we don't have exact timestamp
            # about when we get data
            self.assertAlmostEqual(bat['charge'] - cur_bat, -20.0, delta=0.5)
            cut_bat = bat['charge']

            # Now the battery must be empty
            morse.sleep(10.0)
            bat = bat_stream.get()
            self.assertAlmostEqual(bat['charge'], 0.0, delta=0.001)

            # Teleport in the charging zone and check the battery charge
            # grows up
            send_pose(teleport_stream, 7.0, 0.0)
            morse.sleep(2.0)
            bat = bat_stream.get()
            self.assertAlmostEqual(bat['charge'], 20.0, delta=0.5)

            # Teleport out of the charging zone, the battery charge must
            # decrease
            send_pose(teleport_stream, 2.0, 0.0)
            morse.sleep(2.5)
            bat = bat_stream.get()
            self.assertAlmostEqual(bat['charge'], 0.0, delta=0.001)



########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(BatteryTest)


########NEW FILE########
__FILENAME__ = builder_wheeled_robot
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
from morse.testing.testing import MorseTestCase

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

from pymorse import Morse

class BuilderWheeledRobotTest(MorseTestCase):

    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = SegwayRMP400()
        p1 = Pose()
        p1.translate(x=1.0)
        robot.append(p1)

        p2 = Pose()
        robot.append(p2)
        p2.translate(x=2.0)

        robot.add_default_interface('socket')

        env = Environment('empty', fastmode = True)

    def test_correct_position(self):
        """ Tests the simulator can return the list of robots
        
        This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as morse:
            p1 = morse.robot.p1
            p2 = morse.robot.p2

            pose1 = p1.get()
            self.assertAlmostEquals(pose1['x'], 1.0, delta=0.03)
            self.assertAlmostEquals(pose1['y'], 0.0, delta=0.03)
            self.assertAlmostEquals(pose1['yaw'], 0.0, delta=0.03)

            pose2 = p2.get()
            self.assertAlmostEquals(pose2['x'], 2.0, delta=0.03)
            self.assertAlmostEquals(pose2['y'], 0.0, delta=0.03)
            self.assertAlmostEquals(pose2['yaw'], 0.0, delta=0.03)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(BuilderWheeledRobotTest)

########NEW FILE########
__FILENAME__ = collision_testing
#! /usr/bin/env python
"""
This script tests the Collision sensor.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse

def send_speed(s, sim, v=0, w=0, t=0):
    s.publish({'v': v, 'w': w})
    sim.sleep(t)
    s.publish({'v': 0.0, 'w': 0.0})

class CollisionTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API. """

        dala = ATRV()
        dala.properties(obstacle=1)

        robot = ATRV()

        motion = MotionVW()
        motion.add_stream('socket')
        robot.append(motion)

        collision = Collision()
        collision.properties(collision_property="obstacle")
        collision.add_stream('socket')
        collision.translate(x = 0.7, z = 0.2)
        robot.append(collision)
        robot.translate(x = -3.0)

        env = Environment('empty', fastmode = True)

    def test_collision(self):
        with Morse() as sim:

            collision = sim.robot.collision.get(timeout=0.1)
            self.assertEqual(collision, None)

            send_speed(sim.robot.motion, sim, 1.0, 0.0, 1.0)

            collision = sim.robot.collision.get(timeout=0.1)
            self.assertNotEqual(collision, None)
            self.assertEqual(collision['objects'], "dala")

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(CollisionTest)

########NEW FILE########
__FILENAME__ = communication_service_testing
#! /usr/bin/env python

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse, MorseServiceFailed

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass


class Communication_Service_Testing(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        mana = ATRV()

        minnie = ATRV()
        minnie.translate(x = 10.0)

        munu = ATRV()
        munu.translate(x = -10.0)

        env = Environment('indoors-1/boxes', fastmode=True)
        env.add_service('socket')


    def test_semantic_camera(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as morse:
            # not enough argument
            with self.assertRaises(MorseServiceFailed):
                res = morse.rpc('communication', 'distance_and_view')

            # unknown robot does not exit
            with self.assertRaises(MorseServiceFailed):
                res = morse.rpc('communication', 'distance_and_view', 'mana', 'unknow_robot')
                
            res = morse.rpc('communication', 'distance_and_view', 'mana', 'minnie')
            self.assertAlmostEquals(res[0], 10.0, delta=0.01)
            self.assertTrue(res[1])

            res = morse.rpc('communication', 'distance_and_view', 'mana', 'munu')
            self.assertAlmostEquals(res[0], 10.0, delta=0.01)
            self.assertFalse(res[1])

            res = morse.rpc('communication', 'distance_and_view', 'minnie', 'munu')
            self.assertAlmostEquals(res[0], 20.0, delta=0.01)
            self.assertFalse(res[1])

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Communication_Service_Testing)

########NEW FILE########
__FILENAME__ = depth_camera_testing
#! /usr/bin/env python
"""
This script tests the Depth camera in MORSE.
"""

import sys
import math
import struct
import base64
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

class DepthCameraTest(MorseTestCase):

    def setUpEnv(self):
        """ Defines the test scenario """

        robot = ATRV()

        motion = MotionVW()
        robot.append(motion)
        motion.add_stream('socket')

        camera = DepthCamera()
        camera.translate(z = 1)
        camera.frequency(3)
        robot.append(camera)
        camera.add_stream('socket')

        env = Environment('indoors-1/boxes')
        # No fastmode here, no MaterialIndex in WIREFRAME mode: AttributeError:
        # 'KX_PolygonMaterial' object has no attribute 'getMaterialIndex'

    def test_depth_camera(self):
        """ Assert that for every points : near <= z <= far """

        with Morse() as morse:
            # turn around
            morse.robot.motion.publish({'v': 1, 'w': 1})

            for step in range(5):
                msg  = morse.robot.camera.get()
                data = base64.b64decode( msg['points'] )

                # assert that : near <= z <= far
                for i in range(0, len(data) - 12, 12):
                    xyz = struct.unpack('fff', data[i:i+12])
                    self.assertTrue(xyz[2] >= 1 and xyz[2] <= 20)

                morse.sleep(0.2) # wait for turning

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(DepthCameraTest)

########NEW FILE########
__FILENAME__ = destination_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import os
import sys
import math
from pymorse import Morse

def send_goal(s, x, y, z):
    s.publish({'x' : x, 'y' : y, 'z' : z})

class DestinationTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = RMax('robot')
        robot.translate(0.0, 0.0, 20.0)
        
        pose = Pose()
        pose.add_stream('socket')
        robot.append(pose)

        destination = Destination('destination')
        robot.append(destination)
        destination.add_stream('socket')
        destination.properties(Speed=2.0, Tolerance=0.3)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test(self):
        with Morse() as morse:
            pose_stream = morse.robot.pose

            pose = pose_stream.get()
            precision = 0.02
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['y'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['z'], 20.0, delta=0.1)

            dest_client = morse.robot.destination
            send_goal(dest_client, 10.0, 0.0, 20.0)

            morse.sleep(3.0)
            # Only x has changed. Check that speed is respected

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], 3.0 * 2.0, delta=0.1)
            self.assertAlmostEqual(pose['y'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['z'], 20.0, delta=0.1)

            morse.sleep(2.0)
            # Only x has changed
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], 9.7, delta=0.1)
            self.assertAlmostEqual(pose['y'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['z'], 20.0, delta=0.1)

            x = pose['x']
            send_goal(dest_client, x, 10.0, 20.0)
            morse.sleep(5.0)

            # Only Y has changed
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], x, delta=0.1)
            self.assertAlmostEqual(pose['y'], 9.7, delta=0.1)
            self.assertAlmostEqual(pose['z'], 20.0, delta=0.1)


            x = pose['x']
            y = pose['y']
            z = pose['z']

            send_goal(dest_client, x, y, 30.0)
            morse.sleep(5.0)

            # Only Z has changed
            # XXX precision is not really good
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], x, delta=precision)
            self.assertAlmostEqual(pose['y'], y, delta=precision)
            self.assertAlmostEqual(pose['z'], 30.0, delta=0.3)

            send_goal(dest_client, 0, 0, 20)
            morse.sleep(10.0)
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertTrue(math.fabs(pose['x']) < 0.3)
            self.assertTrue(math.fabs(pose['y']) < 0.3)
            self.assertTrue(math.fabs(pose['z'] - 20) < 0.3)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(DestinationTest)

########NEW FILE########
__FILENAME__ = friction_testing
#! /usr/bin/env python
"""
This script tests the Robot's 'friction' property.

http://www.blender.org/documentation/blender_python_api_2_68a_release/bpy.types.MaterialPhysics.html#bpy.types.MaterialPhysics.friction

"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
    from morse.builder.actuators import Light
except ImportError:
    pass

import sys
from pymorse import Morse

def send_speed(s, simu, v=0, w=0, t=0):
    s.publish({'v': v, 'w': w})
    simu.sleep(t)
    s.publish({'v': 0.0, 'w': 0.0})

class FrictionTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API. """

        robot1 = ATRV()

        pose = Pose()
        pose.add_stream('socket')
        robot1.append(pose)

        motion = MotionVW()
        motion.add_stream('socket')
        motion.properties(ControlType='Velocity')
        robot1.append(motion)

        robot1.translate(y=-1)
        robot1.set_friction(0)

        robot2 = ATRV()

        pose = Pose()
        pose.add_stream('socket')
        robot2.append(pose)

        motion = MotionVW()
        motion.add_stream('socket')
        motion.properties(ControlType='Velocity')
        robot2.append(motion)

        robot2.translate(y=+1)
        robot2.set_friction(5)

        env = Environment('empty', fastmode = True)

    def test_friction(self):
        with Morse() as simu:

            precision=0.1

            # Read the start position, it must be (0.0, 0.0, 0.0)
            for pose_stream in [simu.robot1.pose, simu.robot2.pose]:
                pose = pose_stream.get()
                self.assertAlmostEqual(pose['x'], 0.0, delta=precision)

            # Read the start position, it must be (0.0, 0.0, 0.0)
            for vw_stream in [simu.robot1.motion, simu.robot2.motion]:
                send_speed(vw_stream, simu, 1.0, 0.0, 2.0)

            pose = simu.robot1.pose.get() # friction = 0 / 100
            self.assertAlmostEqual(pose['x'], 2.0, delta=precision)

            pose = simu.robot2.pose.get() # friction = 5 / 100
            self.assertAlmostEqual(pose['x'], 1.4, delta=precision)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(FrictionTest)

########NEW FILE########
__FILENAME__ = gps_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse


class GPSTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = ATRV()
        robot.translate(10.0, 8.0, 0.0)
        
        gps = GPS()
        gps.add_stream('socket')
        robot.append(gps)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_read_gps(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            gps_stream = morse.robot.gps

            pos = gps_stream.get()

            precision = 0.02
            self.assertAlmostEqual(pos['x'], 10.0, delta=precision)
            self.assertAlmostEqual(pos['y'], 8.0, delta=precision)
            # Z = 0.1 : pose of the ATRV's center relative to the world
            self.assertAlmostEqual(pos['z'], 0.1, delta=precision)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(GPSTest)

########NEW FILE########
__FILENAME__ = gripper_testing
#! /usr/bin/env python
"""
This script tests the KUKA LWR arm, both the data and service api
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_pose(s, morse, x, y, yaw):
    s.publish({'x' : x, 'y' : y, 'z' : 0.0, \
               'yaw' : yaw, 'pitch' : 0.0, 'roll' : 0.0})
    morse.sleep(0.1)

class gripperTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """

        robot = ATRV('robot')

        arm = KukaLWR()
        robot.append(arm)
        arm.translate(x=0.5, z=0.9)
        arm.add_stream('socket')
        arm.add_service('socket')

        gripper = Gripper('gripper')
        gripper.translate(z=1.28)
        arm.append(gripper)
        gripper.properties(Angle = 180.0, Distance=2.0)
        gripper.add_service('socket')

        teleport = Teleport()
        robot.append(teleport)
        teleport.add_stream('socket')

        tape1 = PassiveObject(prefix='BlackVideotape')
        tape1.properties(Object = True, Graspable = True, Label = "BlackTape")
        tape1.translate(x=5, y=5, z=0)

        tape2 = PassiveObject(prefix='WhiteVideotape')
        tape2.properties(Object = True, Graspable = True, Label = "WhiteTapee")
        tape2.translate(x=5, y=-5, z=0)

        env = Environment('empty', fastmode=True)
        env.add_service('socket')


    def test_gripper(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as morse:
            # kuka controller socket
            kuka_client = morse.robot.arm
            teleport_stream = morse.robot.teleport

            kuka_client.set_rotation('kuka_2', -1.57)
            morse.sleep(0.1)

            obj = morse.robot.arm.gripper.grab().result()
            self.assertEqual(obj, None)

            obj = morse.robot.arm.gripper.release().result()
            self.assertEqual(obj, None)

            send_pose(teleport_stream, morse, 3.0, 5, 0.0)
            morse.sleep(0.1)

            obj = morse.robot.arm.gripper.grab().result()
            self.assertEqual(obj, 'tape1')

            send_pose(teleport_stream, morse, 3.0, -5.0, 0.0)
            obj = morse.robot.arm.gripper.grab().result()
            self.assertEqual(obj, 'tape1')

            send_pose(teleport_stream, morse, 3.0, 8.0, 0.0)
            obj = morse.robot.arm.gripper.release().result()
            self.assertEqual(obj, True)

            send_pose(teleport_stream, morse, 3.0, -5.0, 0.0)
            obj = morse.robot.arm.gripper.grab().result()
            self.assertEqual(obj, 'tape2')

            obj = morse.robot.arm.gripper.release().result()
            self.assertEqual(obj, True)

            send_pose(teleport_stream, morse, 3.0, 8.0, 0.0)
            obj = morse.robot.arm.gripper.grab().result()
            self.assertEqual(obj, 'tape1')


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(gripperTest)

########NEW FILE########
__FILENAME__ = gyroscope_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse


class GyroTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = RMax('robot')
        robot.translate(0.0, 0.0, 40.0)
        robot.rotate(math.pi/16, math.pi/8, math.pi/2)
        
        gyro = Gyroscope()
        gyro.add_stream('socket')
        robot.append(gyro)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_read_gyro(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            gyro_stream = morse.robot.gyro

            angles = gyro_stream.get()
            precision = 0.02
            self.assertAlmostEqual(angles['yaw'], math.pi/2, delta=precision)
            self.assertAlmostEqual(angles['pitch'], math.pi/8, delta=precision)
            self.assertAlmostEqual(angles['roll'], math.pi/16, delta=precision)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(GyroTest)

########NEW FILE########
__FILENAME__ = imu_noise_testing
#! /usr/bin/env python
"""
This script tests the several Noise modifiers
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import os
import sys
from pymorse import Morse


class NoiseTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = ATRV()
                
        imu = IMU()
        robot.append(imu)
        imu_noised = IMU()
        imu_noised.alter('Noise', gyro_std=1, accel_std=1)
        robot.append(imu_noised)
        
        robot.add_default_interface('socket')
        env = Environment('empty', fastmode = True)
        env.add_interface('socket')
        
    def test_noised_imu(self):
        """ Test if the IMU data is noised
        """
        with Morse() as morse:
            d = morse.robot.imu.get()
            dn = morse.robot.imu_noised.get()
            for i in ['angular_velocity', 'linear_acceleration']:
                for j in range(0,3):
                    self.assertNotAlmostEqual(d[i][j], dn[i][j], delta=.001)
              
########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(NoiseTest)

########NEW FILE########
__FILENAME__ = levels
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

class LevelsTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = ATRV()

        odo = Odometry() # odometry level default to 'differential'
        robot.append(odo)
        odo.add_stream('socket')

        diff_odo = Odometry()
        diff_odo.level("differential")
        robot.append(diff_odo)
        diff_odo.add_stream('socket')


        raw_odo = Odometry()
        raw_odo.level("raw")
        robot.append(raw_odo)
        raw_odo.add_stream('socket')

        integ_odo = Odometry()
        integ_odo.level("integrated")
        robot.append(integ_odo)
        integ_odo.add_stream("socket")

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_levels(self):

        with Morse() as morse:

            odo = morse.robot.odo.get()
            diff_odo = morse.robot.diff_odo.get()
            raw_odo = morse.robot.raw_odo.get()
            integ_odo = morse.robot.integ_odo.get()

            self.assertEquals(set(['timestamp', 'dS']), set(raw_odo.keys()))
            self.assertEquals(set(['timestamp',
                                   'x', 'y', 'z', 'yaw', 'pitch', 'roll',
                                   'vx', 'vy', 'vz', 'wz', 'wy', 'wx']),
                              set(integ_odo.keys()))
            self.assertEquals(set(['timestamp', 'dx', 'dy', 'dz', 'dyaw', 'dpitch', 'droll']),
                              set(diff_odo.keys()))
            self.assertEquals(set(integ_odo.keys()), set(odo.keys()))


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(LevelsTest)

########NEW FILE########
__FILENAME__ = light_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
    from morse.builder.actuators import Light
except ImportError:
    pass

import sys
import base64
from pymorse import Morse

class LightTest(MorseTestCase):

    def setUpEnv(self):
        atrv = ATRV()

        cam = VideoCamera()
        cam.properties(capturing = True, cam_width = 320, cam_height = 240, \
                       cam_focal = 25.0000, Vertical_Flip = True)
        cam.translate(x=0.2, z=0.9)
        atrv.append(cam)
        cam.add_stream('socket')

        light = Light('light')
        light.translate(x=0.2, z=1.1)
        light.properties(Distance = 50.0)
        atrv.append(light)
        light.add_stream('socket')

        block  = PassiveObject('environments/indoors-1/boxes', 'GreenBox')
        block.translate(x=2, y=0, z=1)

        env = Environment('empty')

    def test_light(self):
        with Morse() as morse:
            cam_stream = morse.atrv.cam
            light_stream = morse.atrv.light

            light_stream.publish({"emit": False})

            morse.sleep(1.0)

            # Light is shutdown. There is no light source on the scene,
            # so camera can't distinguish color
            res = []

            # search the green block in the image
            cam = cam_stream.get()
            img = base64.b64decode( cam['image'] )
            for i in range(0, 320*240*4, 4):
                # Value computed with gimp help ...
                if (img[i] < 5 and img[i+1] > 110 and img[i+2] < 5):
                    res.append(i)

            self.assertEqual(len(res), 0)

            # Now, illuminate the scene
            light_stream.publish({"emit": True})

            morse.sleep(2.0)
            cam = cam_stream.get()
            img = base64.b64decode( cam['image'] )
            # search the green block in the image
            for i in range(0, 320*240*4, 4):
                # Value computed with gimp help ...
                if (img[i] < 5 and img[i+1] > 110 and img[i+2] < 5):
                    res.append(i)

            self.assertTrue(len(res) > 10000)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(LightTest)

########NEW FILE########
__FILENAME__ = multiple_ptu_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
import math
from pymorse import Morse

def send_angles(s, pan, tilt):
    s.publish({'pan' : pan, 'tilt' : tilt})

class MultiplePTUTest(MorseTestCase):
    """
    Non regression test for #536

    PTU related component are really tested in ptu_testing.py
    """

    def setUpEnv(self):

        ptu_x = 0.2020
        ptu_z = 1.4400

        robot = ATRV()

        ptu0 = PTU()
        ptu0.add_stream('socket')
        ptu0.translate(x=ptu_x, z=ptu_z)
        ptu0.add_service('socket')
        robot.append(ptu0)

        posture0 = PTUPosture()
        posture0.add_stream('socket')
        ptu0.append(posture0)

        ptu1 = PTU()
        ptu1.add_stream('socket')
        ptu1.translate(x = 2 * ptu_x, z = 2 * ptu_z)
        ptu1.add_service('socket')
        robot.append(ptu1)

        posture1 = PTUPosture()
        posture1.add_stream('socket')
        ptu1.append(posture1)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_datastream(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            posture_stream0 = morse.robot.ptu0.posture0
            ptu_stream0 = morse.robot.ptu0
            posture_stream1 = morse.robot.ptu1.posture1
            ptu_stream1 = morse.robot.ptu1

            precision = 0.02
            moving_precision = 0.1

            posture0 = posture_stream0.get()
            posture1 = posture_stream1.get()

            self.assertAlmostEqual(posture0['pan'], 0.0, delta=precision)
            self.assertAlmostEqual(posture0['tilt'], 0.0, delta=precision)
            self.assertAlmostEqual(posture1['pan'], 0.0, delta=precision)
            self.assertAlmostEqual(posture1['tilt'], 0.0, delta=precision)

            send_angles(ptu_stream0, 1.0, 0.0)
            send_angles(ptu_stream1, -1.0, 0.0)
            morse.sleep(1.0)

            posture0 = posture_stream0.get()
            posture1 = posture_stream1.get()

            self.assertAlmostEqual(posture0['pan'], 1.0, delta=moving_precision)
            self.assertAlmostEqual(posture0['tilt'], 0.0, delta=moving_precision)
            self.assertAlmostEqual(posture1['pan'], -1.0, delta=moving_precision)
            self.assertAlmostEqual(posture1['tilt'], 0.0, delta=moving_precision)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(MultiplePTUTest)

########NEW FILE########
__FILENAME__ = ned_testing
#! /usr/bin/env python
"""
This script tests the NED modifier.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import os
import sys
from pymorse import Morse


class NedTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = RMax('robot')
        robot.translate(42.0, -10, 40)

        teleport = Teleport()
        robot.append(teleport)

        pose = Pose()
        robot.append(pose)
        pose.add_stream('socket')

        pose2 = Pose()
        pose2.alter('NED')
        robot.append(pose2)
        pose2.add_stream('socket')


        env = Environment('empty', fastmode = True)
        env.add_service('socket')


    def test_ned_pose(self):
        """ Test if the NED conversion is correctly done
        """

        with Morse() as morse:
            pose_stream = morse.robot.pose
            pose_ned_stream = morse.robot.pose2

            pose = pose_stream.get()
            pose_ned = pose_ned_stream.get()

            self.assertAlmostEqual(pose['x'], 42.0, delta=0.01)
            self.assertAlmostEqual(pose['y'], -10.0, delta=0.01)
            self.assertAlmostEqual(pose['z'], 40.0, delta=0.1)

            self.assertAlmostEqual(pose['x'], pose_ned['y'])
            self.assertAlmostEqual(pose['y'], pose_ned['x'])
            self.assertAlmostEqual(pose['z'], -pose_ned['z'])

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(NedTest)

########NEW FILE########
__FILENAME__ = odometry_testing
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

class OdometryTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = ATRV()
        robot.translate(x = 5.0, y = 2.0)
        robot.rotate(z = math.pi / 2)

        pose = Pose()
        robot.append(pose)
        pose.add_stream('socket')

        motion = MotionVW('motion')
        robot.append(motion)
        motion.add_stream('socket')

        odo = Odometry()
        robot.append(odo)
        odo.level('differential')
        odo.add_stream('socket')

        raw_odo = Odometry()
        raw_odo.level("raw")
        robot.append(raw_odo)
        raw_odo.add_stream('socket')

        integ_odo = Odometry()
        robot.append(integ_odo)
        integ_odo.add_stream("socket")

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def clear_datas(self, x, y, yaw):
        self.x = x
        self.y = y
        self.yaw = yaw

    def record_datas(self, record):
        dx = record['dx']
        dy = record['dy']

        self.yaw += record['dyaw']
        
        # normalise angle
        while (self.yaw > math.pi):
            self.yaw+= -2 * math.pi
        while (self.yaw < -math.pi):
            self.yaw+= 2 * math.pi

        self.x += dx
        self.y += dy

    def odometry_test_helper(self, morse, v, w, t):
        self.odo_stream.subscribe(self.record_datas)
        self.motion.publish({'v':v, 'w':w})
        morse.sleep(t)
        self.odo_stream.unsubscribe(self.record_datas)

    
    def verify(self, expected_x, expected_y, expected_yaw):
        # Numerical integration is maybe not really good, so test with a
        # precision of 0.16
        precision = 0.16

        pose = self.pose_stream.get()
        integ_odo = self.integ_odo_stream.get()
        self.assertAlmostEqual(self.x, expected_x, delta=precision)
        self.assertAlmostEqual(self.y, expected_y, delta=precision)
        self.assertAlmostEqual(self.yaw, expected_yaw, delta=precision)
        self.assertAlmostEqual(pose['x'], 5.0 - expected_y, delta=precision)
        self.assertAlmostEqual(pose['y'], 2.0 + expected_x, delta=precision)
        self.assertAlmostEqual(pose['yaw'], expected_yaw + math.pi/2, delta=precision)
        self.assertAlmostEqual(integ_odo['x'], expected_x, delta=precision)
        self.assertAlmostEqual(integ_odo['y'], expected_y, delta=precision)
        self.assertAlmostEqual(integ_odo['yaw'], expected_yaw, delta=precision)
        self.clear_datas(expected_x, expected_y, expected_yaw)

    def test_odometry(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """

        with Morse() as morse:
            # Read the start position, it must be (0.0, 0.0, 0.0)
            self.pose_stream = morse.robot.pose
            self.odo_stream = morse.robot.odo
            self.integ_odo_stream = morse.robot.integ_odo
            self.motion = morse.robot.motion

            self.clear_datas(0.0, 0.0, 0.0)

            self.odometry_test_helper(morse, 1.0, 0.0, 2.0)
            self.verify(2.0, 0.0, 0.0)

            self.odometry_test_helper(morse, -1.0, 0.0, 2.0)
            self.verify(0.0, 0.0, 0.0)

            self.odometry_test_helper(morse, 1.0, -math.pi/4.0, 2.0)
            self.verify(4.0 / math.pi, -4.0/math.pi, -math.pi/2.0)

            self.odometry_test_helper(morse, 0.5, -math.pi/8.0, 12.0)
            self.verify(0.0, 0.0, 0.0)

            # XXX fail Y with 0.11 delta
            #self.odometry_test_helper(morse, -2.0, math.pi/2.0, 3.0)
            #self.verify(4.0 / math.pi, -4.0/math.pi, -math.pi/2.0)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(OdometryTest)

########NEW FILE########
__FILENAME__ = orientation_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
import math
from pymorse import Morse

def send_angles(s, yaw, pitch, roll):
    s.publish({'yaw' : yaw, 'pitch' : pitch, 'roll' : roll})

class OrientationTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = RMax('robot')
        robot.translate(10.0, 8.0, 20.0)
        
        gyro = Gyroscope()
        gyro.add_stream('socket')
        robot.append(gyro)

        orientation = Orientation('orientation')
        orientation.add_stream('socket')
        robot.append(orientation)

        pose = Pose()
        pose.add_stream('socket')
        robot.append(pose)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_orientation(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            gyro_stream = morse.robot.gyro
            pose_stream = morse.robot.pose

            orientation_stream = morse.robot.orientation

            precision = 0.12

            angles = gyro_stream.get()
            pose = pose_stream.get()
            self.assertAlmostEqual(angles['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], 10.0, delta=precision)
            self.assertAlmostEqual(pose['y'], 8.0, delta=precision)
            self.assertAlmostEqual(pose['z'], 20.0, delta=precision)

            # Position does not change, only yaw is modified
            send_angles(orientation_stream, math.pi/2, 0.0, 0.0)
            morse.sleep(0.1)

            
            pose = pose_stream.get()
            angles = gyro_stream.get()
            self.assertAlmostEqual(angles['yaw'], math.pi/2, delta=precision)
            self.assertAlmostEqual(angles['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['yaw'], math.pi/2, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], 10.0, delta=precision)
            self.assertAlmostEqual(pose['y'], 8.0, delta=precision)
            self.assertAlmostEqual(pose['z'], 20.0, delta=precision)

            # Complete orientation settings
            send_angles(orientation_stream, -math.pi/2, math.pi/8, 0.89)
            morse.sleep(0.1)

            pose = pose_stream.get()
            angles = gyro_stream.get()
            self.assertAlmostEqual(angles['yaw'], -math.pi/2, delta=precision)
            self.assertAlmostEqual(angles['pitch'], math.pi/8, delta=precision)
            self.assertAlmostEqual(angles['roll'], 0.89, delta=precision)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2, delta=precision)
            self.assertAlmostEqual(pose['pitch'], math.pi/8, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.89, delta=precision)
            self.assertAlmostEqual(pose['x'], 10.0, delta=precision)
            self.assertAlmostEqual(pose['y'], 8.0, delta=precision)
            self.assertAlmostEqual(pose['z'], 20.0, delta=precision)



########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(OrientationTest)

########NEW FILE########
__FILENAME__ = pose_noise_testing
#! /usr/bin/env python
"""
This script tests the several Noise modifiers
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import os
import sys
from pymorse import Morse


class NoiseTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = ATRV()
        
        motion = MotionVW()
        robot.append(motion)
        
        pose = Pose()
        robot.append(pose)
        pose_noised = Pose()
        pose_noised.alter('Noise', pos_std=1, rot_std=1)
        robot.append(pose_noised)
        
        gps = GPS()
        robot.append(gps)
        gps_noised = GPS()
        gps_noised.alter('Noise', pos_std=1)
        robot.append(gps_noised)
        
        gyroscope = Gyroscope()
        robot.append(gyroscope)
        gyroscope_noised = Gyroscope()
        gyroscope_noised.alter('Noise', rot_std=1)
        robot.append(gyroscope_noised)
        
        odometry = Odometry()
        robot.append(odometry)
        odometry.level('integrated')
        odometry_noised = Odometry()
        odometry_noised.alter('Noise', pos_std=1, rot_std=1)
        robot.append(odometry_noised)
        odometry_noised.level('integrated')
        
        robot.add_default_interface('socket')
        env = Environment('empty', fastmode = True)
        env.add_interface('socket')
        
    def test_noised_pose(self):
        """ Test if the Pose data is noised
        """
        with Morse() as morse:
            d = morse.robot.pose.get()
            dn = morse.robot.pose_noised.get()
            for i in ['x', 'y', 'z', 'roll', 'pitch', 'yaw']:
                self.assertNotAlmostEqual(d[i], dn[i], delta=.001)

    def test_noised_gyro(self):
        """ Test if the Gyroscope data is noised
        """
        with Morse() as morse:
            d = morse.robot.gyroscope.get()
            dn = morse.robot.gyroscope_noised.get()
            for i in ['roll', 'pitch', 'yaw']:
                self.assertNotAlmostEqual(d[i], dn[i], delta=.001)

    def test_noised_gps(self):
        """ Test if the GPS data is noised
        """
        with Morse() as morse:
            d = morse.robot.gps.get()
            dn = morse.robot.gps_noised.get()
            for i in ['x', 'y', 'z']:
                self.assertNotAlmostEqual(d[i], dn[i], delta=.001)
                          
    def test_noised_odometry(self):
        """ Test if the odometry data is noised
        """
        with Morse() as morse:
            morse.robot.motion.publish({'v': 1, 'w':.5})
            morse.sleep(1)
            d = morse.robot.odometry.get()
            dn = morse.robot.odometry_noised.get()
            for i in ['x', 'y', 'z', 'yaw', 'pitch', 'roll']:
                #, 'vx', 'vy', 'vz', 'wz', 'wy', 'wz']:
                self.assertNotAlmostEqual(d[i], dn[i], delta=.001)

    
########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(NoiseTest)

########NEW FILE########
__FILENAME__ = pose_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse


class PoseTest(MorseTestCase):

    def setUpEnv(self):
        
        print("Adding a robot...")
        robot = ATRV()
        
        pose = Pose()
        pose.add_stream('socket')
        pose.translate(z=-0.10) # atrv sensor is at 10cm on the groud
        robot.append(pose)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_base_service_connection(self):
        """ Simply tests if the simulator is reachable by its socket interface.
        """

        morse = Morse()
        morse.close()

    def test_get_pose_streams_service(self):
        """ Tests if we can retrieve the list of published data streams.
        """
        morse = Morse()
        self.assertEquals(set(morse.streams()), set(["robot.pose"]))
        morse.close()

    def test_read_pose(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            pose_stream = morse.robot.pose

            pose = pose_stream.get()

            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, 2)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(PoseTest)

########NEW FILE########
__FILENAME__ = proximity_testing
#! /usr/bin/env python
"""
This script tests the proximity sensor in MORSE.
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_dest(s, morse, x, y, yaw):
    s.publish({'x' : x, 'y' : y, 'z' : 0, 'yaw' : yaw, 'pitch' : 0.0, 'roll' : 0.0})
    morse.sleep(0.1)

class ProximityTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = ATRV()

        proximity = Proximity()
        proximity.translate(z=0.5)
        proximity.properties(Track = "Catch_me")
        proximity.properties(Range = 2.0)
        robot.append(proximity)
        proximity.add_stream('socket')
        proximity.add_service('socket')

        pose = Pose()
        robot.append(pose)
        pose.add_stream('socket')

        motion = Teleport()
        robot.append(motion)
        motion.add_stream('socket')

        target1 = ATRV("Target1")
        target1.properties(Catch_me = True)
        target1.translate(x=10.0, y = 1.0)

        target2 = ATRV("Target2")
        target2.properties(Catch_me2 = True)
        target2.translate(x=10.0, y = -1.0)

        target3 = ATRV("Target3")
        target3.properties(Catch_me = True)
        target3.translate(x=-4.0, y = 0.0)

        env = Environment('empty', fastmode = True)
        env.set_camera_location( (9.952, -14.955, 12.48) )
        env.set_camera_rotation( (0.867, 0, 0.428) )
        env.add_service('socket')

    def test_proximity(self):
        with Morse() as morse:
        
            prox_stream = morse.robot.proximity
            teleport_client = morse.robot.motion

            prox = prox_stream.get()
            self.assertEqual(len(prox['near_objects']), 0)

            # still emtpy
            send_dest(teleport_client, morse, 8.0, 0.0, 0.0)
            prox = prox_stream.get()
            self.assertEqual(len(prox['near_objects']), 0)

            # one more meter, must find target1. target2 is at equal
            # distance but don't have the good tag
            send_dest(teleport_client, morse, 9.0, 0.0, 0.0)
            prox = prox_stream.get()
            self.assertEqual(len(prox['near_objects']), 1)
            self.assertTrue('Target1' in prox['near_objects'])

            # Don't care about the direction, only check the distance
            send_dest(teleport_client, morse, -2.8, 0.0, 0.0)
            prox = prox_stream.get()
            self.assertEqual(len(prox['near_objects']), 1)
            self.assertTrue('Target3' in prox['near_objects'])

            # Call the set_range service and check if we can catch the
            # two objects
            prox_stream.set_range(20.0)
            morse.sleep(0.1)
            prox = prox_stream.get()
            self.assertEqual(len(prox['near_objects']), 2)
            self.assertTrue('Target1' in prox['near_objects'])
            self.assertTrue('Target3' in prox['near_objects'])

            # Call the set_tracked_tag service and check if we catch
            # target2
            prox_stream.set_tracked_tag('Catch_me2')
            morse.sleep(0.1)
            prox = prox_stream.get()
            self.assertEqual(len(prox['near_objects']), 1)
            self.assertTrue('Target2' in prox['near_objects'])


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(ProximityTest)

########NEW FILE########
__FILENAME__ = ptu_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
import math
from pymorse import Morse

def send_angles(s, pan, tilt):
    s.publish({'pan' : pan, 'tilt' : tilt})

class PTUTest(MorseTestCase):

    def setUpEnv(self):

        ptu_x = 0.2020
        ptu_z = 1.4400

        robot = ATRV()

        ptu = PTU()
        ptu.add_stream('socket')
        ptu.translate(x=ptu_x, z=ptu_z)
        ptu.add_service('socket')
        ptu.properties(Speed = 0.5)
        robot.append(ptu)

        posture = PTUPosture()
        posture.add_stream('socket')
        ptu.append(posture)

        gyro = Gyroscope()
        gyro.add_stream('socket')
        ptu.append(gyro)
        
        chair = PassiveObject(prefix='RollingChair')
        chair.translate(x=ptu_x, y=3, z=0.01)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_datastream(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            gyro_stream = morse.robot.ptu.gyro
            posture_stream = morse.robot.ptu.posture
            ptu_stream = morse.robot.ptu

            angles = gyro_stream.get()
            posture = posture_stream.get()

            precision = 0.02
            moving_precision = 0.1

            self.assertAlmostEqual(posture['pan'], 0.0, delta=precision)
            self.assertAlmostEqual(posture['tilt'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['pitch'], 0.0, delta=precision)

            send_angles(ptu_stream, 1.0, 0.0)
            morse.sleep(1.0)

            # here at speed of 0.5 rad / sec, we must be at the middle
            # of the trip, check it :)
            angles = gyro_stream.get()
            posture = posture_stream.get()
            self.assertAlmostEqual(posture['pan'], 0.5, delta=moving_precision)
            self.assertAlmostEqual(posture['tilt'], 0.0, delta=moving_precision)
            self.assertAlmostEqual(angles['yaw'], 0.5, delta=moving_precision)
            self.assertAlmostEqual(angles['pitch'], 0.0, delta=moving_precision)

            morse.sleep(1.0)
            # now we must have achieve ptu rotation
            angles = gyro_stream.get()
            posture = posture_stream.get()

            self.assertAlmostEqual(posture['pan'], 1.0, delta=precision)
            self.assertAlmostEqual(posture['tilt'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['yaw'], 1.0, delta=precision)
            self.assertAlmostEqual(angles['pitch'], 0.0, delta=precision)

            send_angles(ptu_stream, 1.0, -1.0)
            morse.sleep(2.0)
            angles = gyro_stream.get()
            posture = posture_stream.get()

            self.assertAlmostEqual(posture['pan'], 1.0, delta=precision)
            self.assertAlmostEqual(posture['tilt'], -1.0, delta=precision)
            self.assertAlmostEqual(angles['yaw'], 1.0, delta=precision)
            self.assertAlmostEqual(angles['pitch'], -1.0, delta=precision)

            send_angles(ptu_stream, 0.0, 0.0)
            morse.sleep(2.0)
            angles = gyro_stream.get()
            posture = posture_stream.get()

            self.assertAlmostEqual(posture['pan'], 0.0, delta=precision)
            self.assertAlmostEqual(posture['tilt'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['pitch'], 0.0, delta=precision)

    def test_set_service(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            gyro_stream = morse.robot.ptu.gyro
            posture_stream = morse.robot.ptu.posture
            ptu_stream = morse.robot.ptu

            angles = gyro_stream.get()
            posture = posture_stream.get()

            precision = 0.02
            moving_precision = 0.1

            self.assertAlmostEqual(posture['pan'], 0.0, delta=precision)
            self.assertAlmostEqual(posture['tilt'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(angles['pitch'], 0.0, delta=precision)

            res = morse.rpc('robot.ptu', 'get_pan_tilt')
            self.assertAlmostEqual(res[0], 0.0, delta=precision)
            self.assertAlmostEqual(res[1], 0.0, delta=precision)

            morse.rpc('robot.ptu', 'set_pan_tilt', 1.0, 0.0)

            angles = gyro_stream.get()
            posture = posture_stream.get()
            self.assertAlmostEqual(posture['pan'], 1.0, delta=moving_precision)
            self.assertAlmostEqual(posture['tilt'], 0.0, delta=moving_precision)
            self.assertAlmostEqual(angles['yaw'], 1.0, delta=moving_precision)
            self.assertAlmostEqual(angles['pitch'], 0.0, delta=moving_precision)

            res = morse.rpc('robot.ptu', 'get_pan_tilt')
            self.assertAlmostEqual(res[0], 1.0, delta=precision)
            self.assertAlmostEqual(res[1], 0.0, delta=precision)

    def test_lookat(self):
        """ Test if the PTU can successfully orient itself towards an
        absolute x,y,z position and towards a given object.
        """

        with Morse() as morse:

            #TODO: Stupid duplication of SetUpEnv values. Could not find a way
            #to share the value. Class variables does not seem to work here.
            ptu_x = 0.2020
            ptu_z = 1.4400 + .1 # 0.1 -> height of ATRV center

            precision = 0.02

            res = morse.rpc('robot.ptu', 'look_at_point', 1 ,0 ,ptu_z)
            res = morse.rpc('robot.ptu', 'get_pan_tilt')
            self.assertAlmostEqual(res[0], 0.0, delta=precision)
            self.assertAlmostEqual(res[1], 0.0, delta=precision)



            res = morse.rpc('robot.ptu', 'look_at_point', -1 ,0 ,ptu_z)
            res = morse.rpc('robot.ptu', 'get_pan_tilt')
#            self.assertAlmostEqual(res[0], math.radians(180.0), delta=precision)
            self.assertAlmostEqual(res[1], 0.0, delta=precision)



            res = morse.rpc('robot.ptu', 'look_at_point', ptu_x,1,ptu_z)
            res = morse.rpc('robot.ptu', 'get_pan_tilt')
            self.assertAlmostEqual(res[0], math.radians(90), delta=precision)
            self.assertAlmostEqual(res[1], 0.0, delta=precision)



            res = morse.rpc('robot.ptu', 'look_at_point', ptu_x, -1, ptu_z)
            res = morse.rpc('robot.ptu', 'get_pan_tilt')
            self.assertAlmostEqual(res[0], math.radians(-90), delta=precision)
            self.assertAlmostEqual(res[1], 0.0, delta=precision)

            
            
            res = morse.rpc('robot.ptu', 'look_at_point', ptu_x,0,10)
            res = morse.rpc('robot.ptu', 'get_pan_tilt')
            self.assertAlmostEqual(res[1], math.radians(-90), delta=precision)
            # Reset position
            morse.rpc('robot.ptu', 'set_pan_tilt', 0.0, 0.0)

            res = morse.rpc('robot.ptu', 'look_at_object', 'chair')
            res = morse.rpc('robot.ptu', 'get_pan_tilt')
            self.assertAlmostEqual(res[0], math.radians(90), delta=precision)
            self.assertAlmostEqual(res[1], 0.466, delta=precision)



########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(PTUTest)

########NEW FILE########
__FILENAME__ = renaming_testing
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
from morse.testing.testing import MorseTestCase

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

from pymorse import Morse

class RenamingTest(MorseTestCase):

    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        class MyMorsy(Morsy):
            def __init__(self, name = None):
                Morsy.__init__(self, name)
                self.arm = KukaLWR()
                self.append(self.arm)
                self.pose = Pose()
                self.arm.append(self.pose)
        
        morsy = Morsy()
        arm = KukaLWR()
        arm.name = 'my_kuka'
        morsy.append(arm)
        pose = Pose('my_pose')
        arm.append(pose)

        robot2 = Morsy('mana')
        arm = KukaLWR()
        robot2.append(arm)
        pose = Pose()
        pose.name = 'my_pose2'
        arm.append(pose)

        robot3 = Morsy()
        robot3.name = 'dala'
        arm = KukaLWR('my_kuka')
        robot3.append(arm)
        pose = Pose()
        arm.append(pose)

        # class based
        robot4 = MyMorsy()
        robot5 = MyMorsy('foo')
        robot6 = MyMorsy()
        robot6.name = 'bar'

        # looping
        for i in range(10):
            m = Morsy()
            arm = KukaLWR()
            m.append(arm)
            pose = Pose()
            arm.append(pose)
            AbstractComponent.close_context()

        env = Environment('empty', fastmode = True)
        env.create()

    def test_renaming(self):
        """ Tests the simulator can return the list of robots
        
        This test is guaranteed to be started only when the simulator
        is ready.
        """

        with Morse() as morse:
            p1 = morse.morsy.my_kuka.my_pose
            p2 = morse.mana.arm.my_pose2
            p3 = morse.dala.my_kuka.pose
            p4 = morse.robot4.arm.pose
            p5 = morse.foo.arm.pose
            p6 = morse.bar.arm.pose
            p7 = morse.m.arm.pose
            p8 = morse.m_001.arm.pose
            p9 = morse.m_002.arm.pose
            p10 = morse.m_003.arm.pose
            # ...


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(RenamingTest)

########NEW FILE########
__FILENAME__ = rotorcraft_waypoint_testing
#! /usr/bin/env python
"""
This script tests the waypoints actuator, both the data and service api
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

class RotorcraftWaypoints_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = Quadrotor('robot')
        robot.translate(x = -1.24, y=1.70, z=1.81)

        pose = Pose()
        robot.append(pose)
        pose.add_stream('socket')

        motion = RotorcraftWaypoint('motion')
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')

        wp_target = Sphere('wp_target')

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_waypoint_controller(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as morse:
        
            pose_stream = morse.robot.pose
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], -1.24, delta=0.05)
            self.assertAlmostEqual(pose['y'], 1.70, delta=0.05)
            self.assertAlmostEqual(pose['z'], 1.81, delta=0.05)
            self.assertAlmostEqual(pose['yaw'], 0, delta=0.05)


            wp_client = morse.robot.motion
            wp_client.publish({'x' : 10.0, 'y': 5.0, 'z': 10.0,
                                'tolerance' : 0.5, 'yaw' : 1.0})
            morse.sleep(10)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 10.0, delta=0.5)
            self.assertAlmostEqual(pose['y'], 5.0, delta=0.5)
            self.assertAlmostEqual(pose['z'], 10.0, delta=0.5)
            self.assertAlmostEqual(pose['yaw'], 1.0, delta=0.05)


    def test_waypoint_service_controller(self):
        with Morse() as morse:

            pose_stream = morse.robot.pose
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], -1.24, delta=0.05)
            self.assertAlmostEqual(pose['y'], 1.70, delta=0.05)
            self.assertAlmostEqual(pose['z'], 1.81, delta=0.05)
            self.assertAlmostEqual(pose['yaw'], 0, delta=0.05)

            morse.rpc('robot.motion', 'goto', 10.0, 5.0, 10.0, 1.0, 0.5)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 10.0, delta=0.5)
            self.assertAlmostEqual(pose['y'], 5.0, delta=0.5)
            self.assertAlmostEqual(pose['z'], 10.0, delta=0.5)
            self.assertAlmostEqual(pose['yaw'], 1.0, delta=0.05)



########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(RotorcraftWaypoints_Test)

########NEW FILE########
__FILENAME__ = search_and_rescue_testing
#! /usr/bin/env python
from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
import math
from pymorse import Morse, MorseServiceFailed

def send_dest(s, morse, x, y, yaw):
    s.publish({'x' : x, 'y' : y, 'z' : 0, \
                       'yaw' : yaw, 'pitch' : 0.0, 'roll' : 0.0})
    morse.sleep(0.1)

class SearchAndRescueTest(MorseTestCase):

    def setUpEnv(self):
        robot = ATRV()
        robot.translate(z=0.2)

        victim_detector = SearchAndRescue()
        robot.append(victim_detector)
        victim_detector.add_stream('socket')
        victim_detector.add_service('socket')
        victim_detector.properties( Heal_range=1.0, Abilities="1,2,3,4,5",
                                    Angle = 90.0, Distance = 2.0)

        motion = Teleport()
        robot.append(motion)
        motion.add_stream('socket')

        env = Environment('empty', fastmode = True)
        env.properties(Temperature='25.0')
        env.add_service('socket')

        victim = Victim()
        victim.translate(x=10.0, y=0.0)

    def test_victim_interface(self):
        with Morse() as morse:
            victim_stream = morse.robot.victim_detector
            teleport_client = morse.robot.motion

            abilities = morse.rpc('robot.victim_detector', 'get_robot_abilities')
            self.assertEqual(abilities, [1, 2, 3, 4, 5])

            victim_status = victim_stream.get()
            self.assertTrue(len(victim_status['victim_dict']) == 0)

            # Move closer of the victim but not close enough to heal it
            send_dest(teleport_client, morse, 8.0, 0.0, 0.0)

            victim_status = victim_stream.get()
            victim_dict = victim_status['victim_dict']
            self.assertEqual(len(victim_dict), 1)
            self.assertEqual(victim_dict['Victim']['requirements'], [1, 2, 3])
            self.assertEqual(victim_dict['Victim']['severity'], 10)

            severity = morse.rpc('robot.victim_detector', 'get_victim_severity')
            self.assertEqual(severity, 10.0)

            requirements = morse.rpc('robot.victim_detector', 'get_victim_requirements')
            self.assertEqual(requirements, [1, 2, 3])

            with self.assertRaises(MorseServiceFailed):
                morse.rpc('robot.victim_detector', 'heal')

            # The victim is not detected if not in the field of view of
            # the radar
            send_dest(teleport_client, morse, 8.0, 0.0, math.pi)
            victim_status = victim_stream.get()
            victim_dict = victim_status['victim_dict']
            self.assertTrue(len(victim_dict) == 0)

            with self.assertRaises(MorseServiceFailed):
                morse.rpc('robot.victim_detector', 'get_victim_severity')

            with self.assertRaises(MorseServiceFailed):
                morse.rpc('robot.victim_detector', 'get_victim_requirements')

            with self.assertRaises(MorseServiceFailed):
                morse.rpc('robot.victim_detector', 'heal')

            # Move close enough to be able to heal it
            send_dest(teleport_client, morse, 9.2, 0.0, 0.0)

            victim_status = victim_stream.get()
            victim_dict = victim_status['victim_dict']
            self.assertEqual(len(victim_dict), 1)
            self.assertEqual(victim_dict['Victim']['requirements'], [1, 2, 3])
            self.assertEqual(victim_dict['Victim']['severity'], 10)

            severity = morse.rpc('robot.victim_detector', 'get_victim_severity')
            self.assertEqual(severity, 10.0)

            requirements = morse.rpc('robot.victim_detector', 'get_victim_requirements')
            self.assertEqual(requirements, [1, 2, 3])

            morse.rpc('robot.victim_detector', 'heal')

            morse.sleep(0.2)
            victim_status = victim_stream.get()
            victim_dict = victim_status['victim_dict']
            self.assertTrue(len(victim_dict) == 1)
            self.assertEqual(victim_dict['Victim']['requirements'], [])
            self.assertEqual(victim_dict['Victim']['severity'], 0)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(SearchAndRescueTest)

########NEW FILE########
__FILENAME__ = semantic_camera_relative_testing
#! /usr/bin/env python
"""
This script tests the Semantic Camera sensor and its 'relative' property in MORSE.
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_dest(s, morse, x, y, yaw):
    s.publish({'x' : x, 'y' : y, 'z' : 0, \
                       'yaw' : yaw, 'pitch' : 0.0, 'roll' : 0.0})
    morse.sleep(0.5)

class Semantic_Camera_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = ATRV()
        
        camera = SemanticCamera()
        camera.properties(relative=True)
        robot.append(camera)
        camera.translate(x=0.3, z=0.762)
        #camera.rotate(x=math.pi/2.0)
        camera.add_stream('socket')

        motion = Teleport()
        robot.append(motion)
        motion.add_stream('socket')

        env = Environment('indoors-1/boxes')
        env.add_service('socket')


    def test_semantic_camera(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as morse:
            semantic_stream = morse.robot.camera
            teleport_client = morse.robot.motion

            o = semantic_stream.get()
            objects= o['visible_objects']
            self.assertEqual(objects, [])

            # Change the orientation of the robot using the v_w socket
            send_dest(teleport_client, morse, -5.0, 0.0, math.pi)

            # Second test for the sensor, with objects in front
            o = semantic_stream.get()
            objects= o['visible_objects']
            self.assertEqual(len(objects), 1)
            self.assertEqual(objects[0]['name'],'RedBox')
            # RedBox in camera frame:
            position = [0, -0.2, 2.2]
            quaternion = {'x':0.5, 'y':0.5, 'z':-0.5, 'w':0.5}
            # quaternion is equal to euler (pi, pi, 0) in XYZ mode
            for i in [0,1,2]:
                self.assertAlmostEqual(objects[0]['position'][i], position[i], delta=0.1)
            for i in ['x', 'y', 'z', 'w']:
                self.assertAlmostEqual(objects[0]['orientation'][i], quaternion[i], delta=.1)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Semantic_Camera_Test)

########NEW FILE########
__FILENAME__ = semantic_camera_tag_testing
#! /usr/bin/env python
"""
This script tests the Semantic Camera sensor and its 'tag' property in MORSE.
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_dest(s, morse, x, y, yaw):
    s.publish({'x' : x, 'y' : y, 'z' : 0, \
                       'yaw' : yaw, 'pitch' : 0.0, 'roll' : 0.0})
    morse.sleep(0.5)

class Semantic_Camera_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = ATRV()
        camera = SemanticCamera()
        camera.properties(tag="Box")
        robot.append(camera)
        camera.translate(x=0.3, z=0.762)
        camera.add_stream('socket')

        motion = Teleport()
        robot.append(motion)
        motion.add_stream('socket')

        env = Environment('indoors-1/boxes')
        env.add_service('socket')
        box = bpymorse.get_object('RedBox')
        bpymorse.properties(box, Type="Box")

    def test_semantic_camera(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as morse:
            semantic_stream = morse.robot.camera
            teleport_client = morse.robot.motion

            o = semantic_stream.get()
            objects= o['visible_objects']
            self.assertEqual(objects, [])

            # Change the orientation of the robot using the v_w socket
            send_dest(teleport_client, morse, 0.0, 0.0, 5.0/4.0 * math.pi)

            # Second test for the sensor, with BlueBox in front
            o = semantic_stream.get()
            objects= o['visible_objects']
            self.assertEqual(objects, [])

            send_dest(teleport_client, morse, -5.0, 0.0, math.pi)

            # Third test for the sensor, with RedBox in front
            o = semantic_stream.get()
            objects= o['visible_objects']
            self.assertEqual(len(objects), 1)
            self.assertEqual(objects[0]['name'],'RedBox')
            self.assertAlmostEqual(objects[0]['position'][0], -7.48, delta=0.1)
            self.assertAlmostEqual(objects[0]['position'][1], 0.0, delta=0.1)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Semantic_Camera_Test)

########NEW FILE########
__FILENAME__ = semantic_camera_testing
#! /usr/bin/env python
"""
This script tests the Semantic Camera sensor in MORSE.
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_dest(s, morse, x, y, yaw):
    s.publish({'x' : x, 'y' : y, 'z' : 0, \
                       'yaw' : yaw, 'pitch' : 0.0, 'roll' : 0.0})
    morse.sleep(0.5)

class Semantic_Camera_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = ATRV()
        camera = SemanticCamera()
        robot.append(camera)
        camera.translate(x=0.3, z=0.762)
        camera.add_stream('socket')

        motion = Teleport()
        robot.append(motion)
        motion.add_stream('socket')

        env = Environment('indoors-1/boxes')
        env.add_service('socket')


    def test_semantic_camera(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as morse:
            semantic_stream = morse.robot.camera
            teleport_client = morse.robot.motion

            o = semantic_stream.get()
            objects= o['visible_objects']
            self.assertEqual(objects, [])

            # Change the orientation of the robot using the v_w socket
            send_dest(teleport_client, morse, 0.0, 0.0, 5.0/4.0 * math.pi)

            # Second test for the sensor, with objects in front
            o = semantic_stream.get()
            objects= o['visible_objects']
            self.assertEqual(len(objects), 1)
            self.assertEqual(objects[0]['name'],'BlueBox')
            self.assertAlmostEqual(objects[0]['position'][0], -3.48, delta=0.1)
            self.assertAlmostEqual(objects[0]['position'][1], -3.0, delta=0.1)

            send_dest(teleport_client, morse, -5.0, 0.0, math.pi)

            o = semantic_stream.get()
            objects= o['visible_objects']
            self.assertEqual(len(objects), 1)
            self.assertEqual(objects[0]['name'],'RedBox')
            self.assertAlmostEqual(objects[0]['position'][0], -7.48, delta=0.1)
            self.assertAlmostEqual(objects[0]['position'][1], 0.0, delta=0.1)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Semantic_Camera_Test)

########NEW FILE########
__FILENAME__ = sick_testing
#! /usr/bin/env python
"""
This script tests the SICK laser range sensor in MORSE.
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

class Sick_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = ATRV()
        robot.rotate(z = math.pi)
        robot.translate(x = -4.5)

        sick = Sick('Sick')
        sick.translate(z=0.9)
        sick.properties(laser_range = 10.0, Visible_arc = False)
        sick.create_laser_arc()
        robot.append(sick)
        sick.add_stream('socket')

        env = Environment('indoors-1/boxes', fastmode = True)
        env.add_service('socket')


    def test_sick(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as morse:
        
            # Read the data from the sick sensor
            self.sick_stream = morse.robot.Sick

            sick = self.sick_stream.get()

            # On the right of the sensor, nothing to hit. So position is
            # (0.0, 0.0, 0.0) and distance == laser_range
            for index in range(105, 180):
                ray = sick['point_list'][index]
                self.assertAlmostEqual(ray[0], 0.0)
                self.assertAlmostEqual(ray[1], 0.0)
                self.assertAlmostEqual(ray[2], 0.0)
                length = sick['range_list'][index]
                self.assertAlmostEqual(length, 10.0)

            # In the center of the sensor, we hit the red block (situed
            # near (-7, 0)).
            # Distance to hit is near 2.5
            for index in range(80, 100):
                length = sick['range_list'][index]
                self.assertAlmostEqual(length, 2.5, delta=0.05)

            # Check some specific point. Hit 90 is the ray corresponding
            # to angle math.pi/2 (in front of the robot). y is computed
            # by trigonometry.
            ray = sick['point_list'][90]
            self.assertAlmostEqual(ray[0], 2.5, delta=0.05)
            self.assertAlmostEqual(ray[1], 0.0, delta=0.05)
            self.assertAlmostEqual(ray[2], 0.0, delta=0.05)

            ray = sick['point_list'][85]
            self.assertAlmostEqual(ray[0], 2.5, delta=0.05)
            self.assertAlmostEqual(ray[1], -2.5 * math.tan(math.radians(5)),
                                   delta=0.05)
            self.assertAlmostEqual(ray[2], 0.0, delta=0.05)

            ray = sick['point_list'][95]
            self.assertAlmostEqual(ray[0], 2.5, delta=0.05)
            self.assertAlmostEqual(ray[1], -2.5 * math.tan(math.radians(-5)),
                                   delta=0.05)
            self.assertAlmostEqual(ray[2], 0.0, delta=0.05)


            # Then, there is a full empty sector
            for index in range(105, 150):
                ray = sick['point_list'][index]
                self.assertAlmostEqual(ray[0], 0.0)
                self.assertAlmostEqual(ray[1], 0.0)
                self.assertAlmostEqual(ray[2], 0.0)
                length = sick['range_list'][index]
                self.assertAlmostEqual(length, 10.0)

            # The last ray hit the green block
            # Distance and real position are a bit complicated to
            # compute manually, so don't check real precision. Just
            # verify that the distance is near 5.8
            #print([i for i,r in enumerate(sick['range_list']) if 5<r<6])
            for index in range(16, 22):
                length = sick['range_list'][index]
                self.assertAlmostEqual(length, 5.8, delta=0.15)



########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Sick_Test)

########NEW FILE########
__FILENAME__ = stabilized_quadrirotor_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse

def send_ctrl(s, theta, phi, psi, h):
    s.publish({'theta_c' : theta, 'phi_c' : phi , 'psi_c' : psi, 'h_c' : h})


class StabilizedQuadrirotorTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = QUAD2012('robot')
        
        pose = Pose()
        pose.add_stream('socket')
        robot.append(pose)

        motion = StabilizedQuadrotor('motion')
        robot.append(motion)
        motion.add_stream('socket')

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_theta_c_control(self):
        with Morse() as morse:
            pose_stream = morse.robot.pose
            cmd_client = morse.robot.motion

            pose = pose_stream.get()

            send_ctrl(cmd_client, 0.0, 0.0, 0.0, 10.0)
            morse.sleep(3.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose['z'], 10.0, delta = 0.2)

            # theta_c permits to control the acceleration on x
            send_ctrl(cmd_client, 0.1, 0.0, 0.0, 10.0)
            morse.sleep(1.0)
            pose1 = pose_stream.get()
            dx1 = 0.4
            self.assertAlmostEqual(pose1['x'], dx1, delta=0.2)
            self.assertAlmostEqual(pose1['y'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose1['z'], 10.0, delta=0.2)
            self.assertAlmostEqual(pose1['yaw'], 0.0, delta=0.02)
            self.assertAlmostEqual(pose1['pitch'], 0.1, delta=0.1)
            self.assertAlmostEqual(pose1['roll'], 0.0, delta=0.0)
            
            # acceleration is constant as long ass we waintain theta_c
            morse.sleep(1.0)
            pose2 = pose_stream.get()
            dx2 = 1.4
            self.assertAlmostEqual(pose2['x'], dx1 + dx2, delta=0.2)
            self.assertAlmostEqual(pose2['y'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose2['z'], 10.0, delta=0.2)
            self.assertAlmostEqual(pose2['yaw'], 0.0, delta=0.02)
            self.assertAlmostEqual(pose2['pitch'], 0.1, delta=0.1)
            self.assertAlmostEqual(pose2['roll'], 0.0, delta=0.0)

            # if we setup theta_c to 0, acceleration on x is now null,
            # so v_x is constant (no friction)
            send_ctrl(cmd_client, 0.0, 0.0, 0.0, 10.0)
            morse.sleep(1.0)
            pose3 = pose_stream.get()
            dx3 = 2.2
            self.assertAlmostEqual(pose3['x'], dx1 + dx2 + dx3 , delta=0.2)
            self.assertAlmostEqual(pose3['y'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose3['z'], 10.0, delta=0.2)
            self.assertAlmostEqual(pose3['yaw'], 0.0, delta=0.02)
            self.assertAlmostEqual(pose3['pitch'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose3['roll'], 0.0, delta=0.0)

            morse.sleep(1.0)
            pose4 = pose_stream.get()
            self.assertAlmostEqual(pose4['x'], dx1 + dx2 + 2 * dx3, delta=0.2)
            self.assertAlmostEqual(pose4['y'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose4['z'], 10.0, delta=0.2)
            self.assertAlmostEqual(pose4['yaw'], 0.0, delta=0.02)
            self.assertAlmostEqual(pose4['pitch'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose4['roll'], 0.0, delta=0.0)

            # adding a negative value to theta_c gives a negative
            # acceleration on x, leading to some stabilization at some
            # point t
            send_ctrl(cmd_client, -0.1, 0.0, 0.0, 10.0)
            last_x = 0.0
            pose = pose_stream.get()
            cur_x = pose['x']
            while cur_x - last_x  > 0.005:
                morse.sleep(0.01)
                last_x = cur_x
                pose = pose_stream.get()
                cur_x = pose['x']
            send_ctrl(cmd_client, 0.0, 0.0, 0.0, 10.0)

            morse.sleep(0.2)
            pose = pose_stream.get()
            morse.sleep(1.0)
            pose1 = pose_stream.get()
            self.assertAlmostEqual(pose['x'] - pose1['x'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose['y'] - pose1['y'], 0.0, delta=0.05)
            self.assertAlmostEqual(pose['z'] - pose1['z'], 0.0, delta=0.05)
            self.assertAlmostEqual(pose['yaw'] - pose1['yaw'], 0.0, delta=0.05)
            self.assertAlmostEqual(pose['pitch'] - pose1['pitch'], 0.0, delta=0.05)
            self.assertAlmostEqual(pose['roll'] - pose1['roll'], 0.0, delta=0.05)

    def test_phi_c_control(self):
        with Morse() as morse:
            pose_stream = morse.robot.pose
            cmd_client = morse.robot.motion

            pose = pose_stream.get()

            send_ctrl(cmd_client, 0.0, 0.0, 0.0, 10.0)
            morse.sleep(3.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose['z'], 10.0, delta = 0.2)

            # phi_c permits to control the acceleration on y
            send_ctrl(cmd_client, 0.0, 0.1, 0.0, 10.0)
            morse.sleep(1.0)
            pose1 = pose_stream.get()
            dy1 = -0.4
            self.assertAlmostEqual(pose1['y'], dy1, delta=0.2)
            self.assertAlmostEqual(pose1['x'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose1['z'], 10.0, delta=0.2)
            self.assertAlmostEqual(pose1['yaw'], 0.0, delta=0.02)
            self.assertAlmostEqual(pose1['roll'], 0.1, delta=0.1)
            self.assertAlmostEqual(pose1['pitch'], 0.0, delta=0.0)
            
            # acceleration is constant as long ass we waintain theta_c
            morse.sleep(1.0)
            pose2 = pose_stream.get()
            dy2 = -1.4
            self.assertAlmostEqual(pose2['y'], dy1 + dy2, delta=0.2)
            self.assertAlmostEqual(pose2['x'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose2['z'], 10.0, delta=0.2)
            self.assertAlmostEqual(pose2['yaw'], 0.0, delta=0.02)
            self.assertAlmostEqual(pose2['roll'], 0.1, delta=0.1)
            self.assertAlmostEqual(pose2['pitch'], 0.0, delta=0.0)

            # if we setup phi_c to 0, acceleration on y is now null,
            # so v_y is constant (no friction)
            send_ctrl(cmd_client, 0.0, 0.0, 0.0, 10.0)
            morse.sleep(1.0)
            pose3 = pose_stream.get()
            dy3 = -2.2
            self.assertAlmostEqual(pose3['y'], dy1 + dy2 + dy3 , delta=0.2)
            self.assertAlmostEqual(pose3['x'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose3['z'], 10.0, delta=0.2)
            self.assertAlmostEqual(pose3['yaw'], 0.0, delta=0.02)
            self.assertAlmostEqual(pose3['pitch'], 0.0, delta=0.0)
            self.assertAlmostEqual(pose3['roll'], 0.0, delta=0.1)

            morse.sleep(1.0)
            pose4 = pose_stream.get()
            self.assertAlmostEqual(pose4['y'], dy1 + dy2 + 2 * dy3, delta=0.2)
            self.assertAlmostEqual(pose4['x'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose4['z'], 10.0, delta=0.2)
            self.assertAlmostEqual(pose4['yaw'], 0.0, delta=0.0)
            self.assertAlmostEqual(pose4['pitch'], 0.0, delta=0.0)
            self.assertAlmostEqual(pose4['roll'], 0.0, delta=0.1)

            # adding a negative value to theta_c gives a negative
            # acceleration on x, leading to some stabilization at some
            # point t
            send_ctrl(cmd_client, 0.0, -0.1, 0.0, 10.0)
            last_y = 0.0
            pose = pose_stream.get()
            cur_y = pose['y']
            while cur_y - last_y  < -0.005:
                morse.sleep(0.01)
                last_y = cur_y
                pose = pose_stream.get()
                cur_y = pose['y']
            send_ctrl(cmd_client, 0.0, 0.0, 0.0, 10.0)

            morse.sleep(0.2)
            pose = pose_stream.get()
            morse.sleep(1.0)
            pose1 = pose_stream.get()
            self.assertAlmostEqual(pose['x'] - pose1['x'], 0.0, delta=0.05)
            self.assertAlmostEqual(pose['y'] - pose1['y'], 0.0, delta=0.2)
            self.assertAlmostEqual(pose['z'] - pose1['z'], 0.0, delta=0.05)
            self.assertAlmostEqual(pose['yaw'] - pose1['yaw'], 0.0, delta=0.05)
            self.assertAlmostEqual(pose['pitch'] - pose1['pitch'], 0.0, delta=0.05)
            self.assertAlmostEqual(pose['roll'] - pose1['roll'], 0.0, delta=0.05)


    def test_psi_c_control(self):
        with Morse() as morse:
            pose_stream = morse.robot.pose
            cmd_client = morse.robot.motion

            pose = pose_stream.get()

            z = 12.0
            send_ctrl(cmd_client, 0.0, 0.0, 0.0, z)
            morse.sleep(3.0)
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['z'], z, delta = 0.2)

            # psi correspond to a delta yaw cmd
            send_ctrl(cmd_client, 0.0, 0.0, 0.1, z)
            morse.sleep(1.0)
            pose = pose_stream.get()
            delta_yaw = -0.69
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['z'], z, delta=0.2)
            self.assertAlmostEqual(pose['yaw'], delta_yaw, delta=0.1)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.1)

            morse.sleep(1.0)
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['z'], z, delta=0.2)
            self.assertAlmostEqual(pose['yaw'], 2 * delta_yaw, delta=0.1)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.1)

            send_ctrl(cmd_client, 0.0, 0.0, 0.0, z)
            morse.sleep(1.0)
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['z'], z, delta=0.2)
            self.assertAlmostEqual(pose['yaw'], 2 * delta_yaw, delta=0.2)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.1)

            send_ctrl(cmd_client, 0.0, 0.0, -0.1, z)
            morse.sleep(1.0)
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['z'], z, delta=0.2)
            self.assertAlmostEqual(pose['yaw'], delta_yaw, delta=0.2)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.1)



########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(StabilizedQuadrirotorTest)

########NEW FILE########
__FILENAME__ = steer_force_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import os
import sys
from pymorse import Morse

def send_force(s, steer, force, brake):
    s.publish({'steer' : steer, 'force' : force, 'brake' : brake})


class SteerForceTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = Hummer('robot')
        
        pose = Pose()
        pose.add_stream('socket')
        robot.append(pose)

        steer_force = SteerForce()
        robot.append(steer_force)
        steer_force.add_stream('socket')

        env = Environment('land-1/rosace_1', fastmode = True)
        env.set_physics_step_sub(1)
        env.set_camera_location([50.0, -20.0, 50.0])

    def test(self):
        with Morse() as morse:
            pose_stream = morse.robot.pose

            pose = pose_stream.get()
            # It is not really precise to control the robot in this way
            # in open loop. So it is a highly qualitative test.

            x = pose['x']
            y = pose['y']

            # destination socket
            steer_client = morse.robot.steer_force

            send_force(steer_client, 0.0, -20.0, 0.0)
            morse.sleep(3.0)
            send_force(steer_client, 0.0, 0.0, 10.0)
            morse.sleep(1.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], x + 8.0, delta = 1.0)
            self.assertAlmostEqual(pose['y'], y, delta = 1.0)

            # Doubling the force 
            send_force(steer_client, 0.0, -40.0, 0.0)
            morse.sleep(3.0)
            send_force(steer_client, 0.0, 0.0, 10.0)
            morse.sleep(2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], x + 26.5, delta = 1.0)
            self.assertAlmostEqual(pose['y'], y, delta = 1.5)

            # Backward move
            send_force(steer_client, 0.0, 10.0, 0.0)
            morse.sleep(11.0)
            send_force(steer_client, 0.0, 0.0, 10.0)
            morse.sleep(2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], x, delta = 1.5)
            self.assertAlmostEqual(pose['y'], y, delta = 1.0)

            # Turning
            send_force(steer_client, -1.0, -10.0, 0.0)
            morse.sleep(10)
            send_force(steer_client, 0.0, 0.0, 10.0)
            morse.sleep(2.0)
            pose = pose_stream.get()

            self.assertAlmostEqual(pose['yaw'], 2.25, delta = 0.2)
            self.assertAlmostEqual(pose['x'], x - 3.5, delta = 1.0)
            self.assertAlmostEqual(pose['y'], x - 6.0, delta = 1.0)



########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(SteerForceTest)

########NEW FILE########
__FILENAME__ = teleport_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import os
import sys
import math
import random
from pymorse import Morse

def send_pose(s, x, y, z, yaw, pitch, roll):
    s.publish({'x' : x, 'y' : y, 'z' : z, 'yaw' : yaw, 'pitch' : pitch, 'roll' : roll})


class TeleportTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = RMax('robot')
        robot.translate(10.0, 8.0, 20.0)
        
        pose = Pose()
        pose.add_stream('socket')
        robot.append(pose)

        teleport = Teleport('teleport')
        teleport.add_stream('socket')
        robot.append(teleport)


        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def _test_one_pose(self, morse, x, y, z, yaw, pitch, roll):
        send_pose(self.teleport_stream, x, y, z, yaw, pitch, roll)
        morse.sleep(0.2)

        pose = self.pose_stream.get()
        self.assertAlmostEqual(pose['yaw'], yaw, delta=self.precision)
        self.assertAlmostEqual(pose['pitch'], pitch, delta=self.precision)
        self.assertAlmostEqual(pose['roll'], roll, delta=self.precision)
        self.assertAlmostEqual(pose['x'], x, delta=self.precision)
        self.assertAlmostEqual(pose['y'], y, delta=self.precision)
        self.assertAlmostEqual(pose['z'], z, delta=self.precision)

    def test_teleport(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            self.pose_stream = morse.robot.pose
            self.teleport_stream = morse.robot.teleport

            self.precision = 0.15

            pose = self.pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=self.precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=self.precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=self.precision)
            self.assertAlmostEqual(pose['x'], 10.0, delta=self.precision)
            self.assertAlmostEqual(pose['y'], 8.0, delta=self.precision)
            self.assertAlmostEqual(pose['z'], 20.0, delta=self.precision)

            # Test only one rotation each time, otherwise, it a bit more
            # complex to check that it does the good transformation
            # (without a matrix transformation library)
            for i in range(0, 5):
                self._test_one_pose(morse,
                                    random.uniform(-30.0, 30.0),
                                    random.uniform(-30.0, 30.0),
                                    random.uniform(10.0, 50.0),
                                    random.uniform(-math.pi, math.pi),
                                    0, 0)
                self._test_one_pose(morse,
                                    random.uniform(-30.0, 30.0),
                                    random.uniform(-30.0, 30.0),
                                    random.uniform(10.0, 50.0),
                                    0,
                                    random.uniform(-math.pi, math.pi),
                                    0)
                self._test_one_pose(morse,
                                    random.uniform(-30.0, 30.0),
                                    random.uniform(-30.0, 30.0),
                                    random.uniform(10.0, 50.0),
                                    0, 0,
                                    random.uniform(-math.pi, math.pi))



########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(TeleportTest)

########NEW FILE########
__FILENAME__ = thermometer_testing
#! /usr/bin/env python
from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse

def send_dest(s, morse, x, y, yaw):
    s.publish({'x' : x, 'y' : y, 'z' : 0, 'yaw' : yaw, 'pitch' : 0.0, 'roll' : 0.0})
    morse.sleep(0.1)

class ThermometerTest(MorseTestCase):

    def setUpEnv(self):
        robot = ATRV()
        robot.translate(z=0.2)

        thermometer = Thermometer()
        robot.append(thermometer)
        thermometer.properties(DefaultTemperature='25.0')
        thermometer.add_interface('socket')

        motion = Teleport()
        robot.append(motion)
        motion.add_interface('socket')

        env = Environment('land-1/rosace_1', fastmode = True)
        env.add_service('socket')

    def test_temperature(self):
        with Morse() as morse:
            temp_stream = morse.robot.thermometer
            teleport_client = morse.robot.motion

            o = temp_stream.get()
            self.assertAlmostEqual(o['temperature'], 25.0, delta=0.01)


            send_dest(teleport_client, morse, 40.0, 0.0, 0.0)

            # We are nearer of the fire so the temperature is expected
            # to be hotter.
            o = temp_stream.get()
            temp = o['temperature']
            self.assertGreater(temp, 28.0)

            # It must be hotter and hotter ... 
            morse.sleep(5.0)
            o = temp_stream.get()
            self.assertGreater(o['temperature'], temp)
            temp = o['temperature']

            morse.sleep(5.0)
            o = temp_stream.get()
            self.assertGreater(o['temperature'], temp)
            temp = o['temperature']





########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(ThermometerTest)

########NEW FILE########
__FILENAME__ = utm_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse


class UTMModifierTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = ATRV()
        robot.translate(10.0, 8.0, 0.0)
        
        gps = GPS()
        gps.add_stream('socket')
        robot.append(gps)

        gps_mod = GPS()
        gps_mod.add_stream('socket')
        gps_mod.alter('UTM', z_offset=421)
        robot.append(gps_mod)

        env = Environment('empty', fastmode = True)
        env.add_service('socket')
        # Need to put float greater than 10000 in string
        env.properties(UTMXOffset='123456789.0', UTMYOffset=-4242.0)


    def test_read_gps(self):
        """ Test if we can connect to the pose data stream, and read from it.
        """

        with Morse() as morse:
            gps_stream = morse.robot.gps
            gps_mod_stream = morse.robot.gps_mod

            pos = gps_stream.get()
            pos_mod = gps_mod_stream.get()

            precision = 0.02
            self.assertAlmostEqual(pos['x'], 10.0, delta=precision)
            self.assertAlmostEqual(pos['y'], 8.0, delta=precision)
            # Z = 0.1 : pose of the ATRV's center relative to the world
            self.assertAlmostEqual(pos['z'], 0.1, delta=precision)

            self.assertAlmostEqual(pos_mod['x'], 10.0 + 123456789.0, delta=precision)
            self.assertAlmostEqual(pos_mod['y'], 8.0 + -4242.0, delta=precision)
            self.assertAlmostEqual(pos_mod['z'], 421.1, delta=precision)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(UTMModifierTest)

########NEW FILE########
__FILENAME__ = velocity_testing
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_speed(s, v, w):
    s.publish({'v' : v, 'w' : w})

class Velocity_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = ATRV()

        motion = MotionVW()
        motion.properties(ControlType = 'Velocity')
        robot.append(motion)
        motion.add_stream('socket')

        vel = Velocity()
        robot.append(vel)
        vel.add_stream('socket')

        teleport = Teleport()
        robot.append(teleport)
        teleport.add_stream('socket')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def expect_value(self, linear_velocity,
                           angular_velocity,
                           world_linear_velocity):

        precision=0.1

        means = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

        # compute the mean on number_iteration (here 60, so normally
        # something like 1 sec). As it is a physical controller, there
        # is no guarantee that at each instant, we have exactly the
        # expected speed, but, in mean, we must have the requested
        # value.
        number_iteration = 60
        for i in range(0, number_iteration):
            vel = self.vel_stream.get()
            for j in range(3):
                means[j] += vel['linear_velocity'][j]
            for j in range(3):
                means[j+3] += vel['angular_velocity'][j]
            for j in range(3):
                means[j+6] += vel['world_linear_velocity'][j]

        for i in range(9):
            means[i] = means[i] / number_iteration

        expected = linear_velocity + angular_velocity + world_linear_velocity

        for i in range(9):
            self.assertAlmostEqual(means[i], expected[i], delta=precision)

    def test_vw_controller(self):
        with Morse() as simu:

            self.vel_stream = simu.robot.vel
            v_w = simu.robot.motion

            simu.deactivate('robot.teleport')

            # wait a few sec that physics stop its fun
            simu.sleep(0.5)
            self.expect_value([0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0])

            send_speed(v_w, 1.0, 0.0)
            simu.sleep(0.5)
            self.expect_value([1.0, 0.0, 0.0], [0.0, 0.0, 0.0], [1.0, 0.0, 0.0])

            send_speed(v_w, 0.0, 0.0)
            simu.sleep(0.5)
            self.expect_value([0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0])

            send_speed(v_w, 0.0, math.pi / 4.0)
            simu.sleep(0.5)
            self.expect_value([0.0, 0.0, 0.0], [0.0, 0.0, math.pi / 4.0], [0.0, 0.0, 0.0])

            send_speed(v_w, 0.0, 0.0)
            simu.sleep(0.1)

            simu.deactivate('robot.motion')
            simu.activate('robot.teleport')
            simu.robot.teleport.publish({'x' : 1.0, 'y' : 0.0, 'z': 0.0,
                                         'yaw': math.pi/2, 'pitch': 0.0,
                                         'roll': 0.0})
            simu.sleep(0.1)
            simu.deactivate('robot.teleport')
            simu.activate('robot.motion')
            simu.sleep(0.1)

            send_speed(v_w, 1.0, 0.0)
            simu.sleep(0.5)
            self.expect_value([1.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0])





########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Velocity_Test)


########NEW FILE########
__FILENAME__ = video_camera_testing
#! /usr/bin/env python
# -*- coding: utf-8 -*-
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import os
import sys
import time
import base64
import struct
import zlib
from pymorse import Morse

IMAGE_WIDTH=320
IMAGE_HEIGHT=240
DEBUG_PGM=False # turn this to True to save difference images

def send_angles(orientation_stream, yaw, pitch, roll):
    orientation_stream.publish({'yaw' : yaw, 'pitch' : pitch, 'roll' : roll})

# a,b in radians.  d in digits of accuracy (ugh!) on the unit circle.
def are_angles_almost_equal(a, b, delta):
    return abs(math.cos(a) - math.cos(b)) <= delta and \
           abs(math.sin(a) - math.sin(b)) <= delta

def wait_yaw(gyroscope_stream, morse, timeout, yaw, precision):
    print("time::now %f" % morse.time())
    timeout_t = morse.time() + timeout
    print("wait_yaw %f %f" % (morse.time(), timeout_t))
    while morse.time() < timeout_t:
        print("%f %f" % (morse.time(), timeout_t))
        angles = gyroscope_stream.get()
        if are_angles_almost_equal(angles['yaw'], yaw, precision):
            return True
        morse.sleep(.1)

    return False

def rotate_robot_and_wait(orientation_stream, gyroscope_stream, morse, \
                          yaw, timeout, precision):
    send_angles(orientation_stream, yaw, 0.0, 0.0)
    # wait for the robot to be at the desired Z angle (yaw)
    return wait_yaw(gyroscope_stream, morse, timeout, yaw, precision)

def flush_camera(camera_stream, morse, timeout):
    timeout_t = morse.time() + timeout
    print("flush_camera %f" % timeout_t)
    while morse.time() < timeout_t:
        print("%f %f" % (morse.time(), timeout_t))
        # get a new image from the camera stream
        camera_stream.get()
        morse.sleep(.1)

def rgba2gray8u(image_rgba_base64):
    # Grayscale model used for HDTV developed by the ATSC (Wikipedia)
    image = base64.b64decode( image_rgba_base64 )
    return [ int(0.2126 * image[index] +
                 0.7152 * image[index + 1] +
                 0.0722 * image[index + 2] )
             for index in range(0, len(image), 4) ]

def load_image(filepath, size):
    image = []
    with open(filepath, 'rb') as f:
        # Read binary image (Bytes)
        image = struct.unpack('%iB'%size, zlib.decompress(f.read()))

    return image

def save_image(filepath, image8u):
    with open(filepath, 'wb') as f:
        # Write binary image (Bytes)
        f.write(zlib.compress(struct.pack('%iB'%len(image8u), *image8u)))

def save_pgm_ascii(filepath, image8u, width, height):
    assert(len(image8u) == width * height)
    with open(filepath, 'w') as f:
        # Write PGM P2 image (ASCII)
        f.write('P2\n%i %i\n255\n'%(width, height))
        f.write(' '.join(['%i'%px for px in image8u]))

# http://stackoverflow.com/questions/7368739/numpy-and-16-bit-pgm
def read_pgm_ascii(filepath):
    with open(filepath, 'r') as f:
        buff = f.read()
    try:
        import re
        header, width, height, maxval = re.search(
            "(^P2\s(?:\s*#.*[\r\n])*"
            "(\d+)\s(?:\s*#.*[\r\n])*"
            "(\d+)\s(?:\s*#.*[\r\n])*"
            "(\d+)\s(?:\s*#.*[\r\n]\s)*)", buff).groups()
    except AttributeError:
        raise ValueError("Not PGM P2 file: '%s'" % filepath)
    image8u = [int(px) for px in buff[len(header):].split()]
    assert(len(image8u) == int(width) * int(height))
    assert(max(image8u) <= int(maxval))
    return image8u

def capture8u(cam_stream, image_path=None):
    # get new RGBA image
    capture = cam_stream.get()
    # convert it to grayscale
    image8u = rgba2gray8u( capture['image'] )
    # or if we use Video8uPublisher
    # image8u = base64.b64decode( capture['image'] )
    # save the image (for debug)
    if image_path:
        save_pgm_ascii(image_path, image8u, IMAGE_WIDTH, IMAGE_HEIGHT)

    return image8u

def diff_image(imageA, imageB, debug=None):
    assert(len(imageA) == len(imageB))
    diff = [abs(pxA - pxB) for pxA, pxB in zip(imageA, imageB)]
    # returns sum(abs( imageA - imageB )) pixel per pixel
    sum_diff = sum(diff)
    if debug:
        pgm_path = '%s.%i.%s.pgm'%(os.path.abspath(__file__), \
                                   int(time.time()*1000), debug)
        save_pgm_ascii(pgm_path, diff, IMAGE_WIDTH, IMAGE_HEIGHT)
        print("debug: %8i -> %5.3f %% %s"% \
              (sum_diff, sum_diff/(len(diff)*2.55), pgm_path))

    return sum_diff

def normalize_radians(angle):
    two_pi = 2 * math.pi
    # First, normalize angle between 0 and 2*PI
    new_angle = angle % two_pi
    # Then, between -PI and PI
    if new_angle > math.pi:
        new_angle = new_angle - two_pi

    return new_angle

class CameraTest(MorseTestCase):

    def setUpEnv(self):

        atrv = ATRV('atrv')
        atrv.rotate(0.0, 0.0, math.pi)

        camera = VideoCamera('camera')
        camera.properties(capturing = True)
        camera.properties(cam_width = 320)
        camera.properties(cam_height = 240)
        camera.properties(cam_focal = 25.0000)
        camera.properties(Vertical_Flip = True)
        camera.translate(x=0.2, z=0.9)
        atrv.append(camera)
        camera.add_stream('socket')

        orientation = Orientation('orientation')
        orientation.add_stream('socket')
        atrv.append(orientation)

        gyroscope = Gyroscope('gyroscope')
        gyroscope.add_stream('socket')
        atrv.append(gyroscope)

        env = Environment('indoors-1/boxes')
        # Shadow may vary depending on the GPU, MULTITEXTURE mode = no shadow.
        # We can't use SOLID viewport or SINGLETEXTURE mode since they do not
        # provide image in bge.texture
        env.set_material_mode('MULTITEXTURE')
        camera.profile()

    def assert_image_file_diff_less(self, filepath, image8u, delta):
        image_from_file = read_pgm_ascii(filepath)
        self.assert_images_diff_less(image8u, image_from_file, delta)

    def assert_images_diff_less(self, imageA, imageB, delta):
        debug = "less" if DEBUG_PGM else None
        diff = diff_image(imageA, imageB, debug=debug)
        # Diff max is: width * height * 255
        # delta in percent (of the maximum difference)
        self.assertLess(diff, delta * 2.55 * len(imageA))

    def assert_images_diff_greater(self, imageA, imageB, delta):
        debug = "greater" if DEBUG_PGM else None
        diff = diff_image(imageA, imageB, debug=debug)
        # Diff max is: width * height * 255
        # delta in percent (of the maximum difference)
        self.assertGreater(diff, delta * 2.55 * len(imageA))

    def assert_orientation(self, gyroscope_stream, yaw, pitch, roll, precision):
        angles = gyroscope_stream.get()
        self.assertAnglesAlmostEqual(angles['yaw'], yaw, precision)
        self.assertAnglesAlmostEqual(angles['pitch'], pitch, precision)
        self.assertAnglesAlmostEqual(angles['roll'], roll, precision)

    # a,b in radians.  d in digits of accuracy (ugh!) on the unit circle.
    # http://astrometry.net/svn/trunk/projects/ephemeris/py/test_celestial_mechanics.py
    def assertAnglesAlmostEqual(self, a, b, delta=0.0):
        self.assertAlmostEqual(math.cos(a), math.cos(b), delta=delta)
        self.assertAlmostEqual(math.sin(a), math.sin(b), delta=delta)

    def test_camera(self):
        """ Test if we can connect to the pose data stream, and read from it.

            The test has been constructed in the following way
                - put the robot in a specific position and takes an
                  image
                - using an editor image, look for the rgb value of some
                  specific zone, and setup some threshold
                - retrieve the threshold in the scene and tests it is
                  mostly invariant

            It will allow to detect that :
                - the camera is broken and don't have a real image
                - blender has changed the way they transmit the image
                - blender changes the orientation of their image
                - possibly other bugs
        """

        with Morse() as morse:
            camera_stream = morse.atrv.camera
            orientation_stream = morse.atrv.orientation
            gyroscope_stream = morse.atrv.gyroscope

            imageA_path = '%s.A.pgm'%os.path.abspath(__file__)
            imageB_path = '%s.B.pgm'%os.path.abspath(__file__)

            precision = 0.01
            # assert robot orienation is correct
            self.assert_orientation(gyroscope_stream, math.pi, 0.0, 0.0, \
                                    precision)

            # get a new image from the camera in gray
            imageA = capture8u(camera_stream)#, imageA_path)
            #assert that the camera image differ < .1 percent from the expected
            self.assert_image_file_diff_less(imageA_path, imageA, 0.1)

            # command the robot to rotate and wait that he does for 5 seconds max
            in_time = rotate_robot_and_wait(orientation_stream, \
                                            gyroscope_stream, morse, 2.70, 5, precision)
            # XXX robot might have not graphically turned yet! happens randomly!
            # gyroscope can give its new orientation while the physics didnt update yet.
            if DEBUG_PGM:
                print("debug: rotate in time: %s (False = timeout)"%str(in_time))
            # "flush" the camera stream for 1 second
            flush_camera(camera_stream, morse, 1.0)

            # assert robot orienation is correct
            self.assert_orientation(gyroscope_stream, 2.70, 0.0, 0.0, precision)

            # get a new image from the camera in gray
            imageB = capture8u(camera_stream)#, imageB_path)
            #assert that the camera image differ < .1 percent from the expected
            self.assert_image_file_diff_less(imageB_path, imageB, 0.2)

            #assert that the second image differ > 4 percent from the first
            self.assert_images_diff_greater(imageA, imageB, 4)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(CameraTest)

########NEW FILE########
__FILENAME__ = vw_testing
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
import math
from morse.testing.testing import MorseMoveTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_speed(s, morse, v, w, t):
    s.publish({'v' : v, 'w' : w})
    morse.sleep(t)
    s.publish({'v' : 0.0, 'w' : 0.0})

def send_service_speed(s, morse, v, w, t):
    s.set_speed(v, w)
    morse.sleep(t)
    s.stop()

class VW_Test(MorseMoveTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = ATRV()

        pose = Pose()
        robot.append(pose)
        pose.add_stream('socket')

        motion = MotionVW()
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')

        teleport = Teleport()
        robot.append(teleport)
        teleport.add_stream('socket')
        
        env = Environment('empty', fastmode = True)
        env.show_framerate(True)
        env.add_service('socket')

    def test_vw_controller(self):
        with Morse() as simu:

            simu.deactivate('robot.teleport')

            precision = 0.12
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            self.assertAlmostEqualPositionThenFix(simu, [0.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            v_w = simu.robot.motion

            send_speed(v_w, simu, 1.0, 0.0, 2.0)
            self.assertAlmostEqualPositionThenFix(simu, [2.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_speed(v_w, simu, -1.0, 0.0, 2.0)
            self.assertAlmostEqualPositionThenFix(simu, [0.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_speed(v_w, simu, 1.0, -math.pi/4.0, 2.0)
            self.assertAlmostEqualPositionThenFix(simu, [4.0 / math.pi, -4.0 / math.pi, 0.10,
                                 -math.pi / 2.0, 0.0, 0.0], precision)

            send_speed(v_w, simu, 0.5, -math.pi/8.0, 12.0)
            self.assertAlmostEqualPositionThenFix(simu, [0.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_speed(v_w, simu, -2.0, math.pi/2.0, 3.0)
            self.assertAlmostEqualPositionThenFix(simu, [4.0 / math.pi, -4.0 / math.pi, 0.10,
                                 -math.pi / 2.0, 0.0, 0.0], precision*2)

    def test_vw_service_controller(self):
        with Morse() as simu:
            precision = 0.10
            simu.deactivate('robot.teleport')
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            self.assertAlmostEqualPositionThenFix(simu, [0.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            v_w = simu.robot.motion

            send_service_speed(v_w, simu, 1.0, 0.0, 2.0)
            self.assertAlmostEqualPositionThenFix(simu, [2.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_service_speed(v_w, simu, -1.0, 0.0, 2.0)
            self.assertAlmostEqualPositionThenFix(simu, [0.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_service_speed(v_w, simu, 1.0, -math.pi/4.0, 2.0)
            self.assertAlmostEqualPositionThenFix(simu, [4.0 / math.pi, -4.0 / math.pi, 0.10,
                                 -math.pi / 2.0, 0.0, 0.0], precision)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(VW_Test)

########NEW FILE########
__FILENAME__ = waypoint_testing
#! /usr/bin/env python
"""
This script tests the waypoints actuator, both the data and service api
"""
import logging

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse, MorseServicePreempted

logger = logging.getLogger("morsetesting.general")
# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

class Waypoints_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = ATRV("robot")

        pose = Pose('pose')
        pose.translate(z=-0.10) # atrv body
        robot.append(pose)
        pose.add_stream('socket')

        motion = Waypoint('motion')
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')

        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_waypoint_datastream(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        with Morse() as simu:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = simu.robot.pose
            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.02)

            # waypoint controller
            motion = simu.robot.motion
            motion.publish({'x' : 4.0, 'y': 2.0, 'z': 0.0, 
                            'tolerance' : 0.5, 
                            'speed' : 1.0})
            simu.sleep(10)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 4.0, delta=0.5)
            self.assertAlmostEqual(pose['y'], 2.0, delta=0.5)


            # test tolerance parameter
            motion.publish({'x' : 0.0, 'y': 0.0, 'z': 0.0, 
                            'tolerance' : 1.0, 
                            'speed' : 1.0})
            simu.sleep(10)
            pose = pose_stream.get()
            distance_goal = math.sqrt( pose['x'] * pose['x'] + pose['y'] * pose['y'])
            self.assertLess(distance_goal, 1.0)
            self.assertGreater(distance_goal, 0.5)

    def test_waypoint_services(self):

        with Morse() as simu:
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = simu.robot.pose
            pose = pose_stream.get()

            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.02)

            logger.info("Moving 2m ahead...")

            simu.robot.motion.goto(2.0, 0.0, 0.0, 0.1, 1.0).result() # wait for completion

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=0.1)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.1)
            logger.info("Ok.")

            action = simu.robot.motion.goto(4.0, 0.0, 0.0, 0.1, 1.0) # do not wait for completion
            logger.info("Moving for 1 sec...")
            simu.sleep(1)

            pose = pose_stream.get() #should have done 1m
            self.assertAlmostEqual(pose['x'], 3.0, delta=0.15)
            logger.info("Ok, reached correct position")

            self.assertTrue(action.running())
            self.assertFalse(action.done())

            logger.info("Cancelling motion and waiting for 0.5 sec...")
            action.cancel()
            simu.sleep(0.1)

            self.assertFalse(action.running())
            self.assertTrue(action.done())

            with self.assertRaises(MorseServicePreempted):
                action.result()

            simu.sleep(0.5)
            pose = pose_stream.get() #should not have moved
            self.assertAlmostEqual(pose['x'], 3.0, delta=0.15)
            logger.info("Ok, did not move")

            logger.info("Moving again, waiting for 2 sec, and ensuring the action terminate")
            action = simu.robot.motion.goto(4.0, 0.0, 0.0, 0.1, 1.0) # do not wait for completion
            simu.sleep(2)
            self.assertTrue(action.done())
            self.assertFalse(action.running())

            # Stop will stop the robot, but do not erase current goal
            action = simu.robot.motion.goto(6.0, 0.0, 0.0, 0.1, 1.0) # do not wait for completion
            logger.info("Moving for 1 sec...")
            simu.sleep(1)

            self.assertFalse(action.done())
            self.assertTrue(action.running())

            status = simu.robot.motion.get_status().result()
            self.assertEqual(status, "Transit")

            simu.robot.motion.stop().result()

            # Stop does not change the fact that the goto is pending,
            # but stop the move
            self.assertFalse(action.done())
            self.assertTrue(action.running())

            status = simu.robot.motion.get_status().result()
            self.assertEqual(status, "Stop")

            simu.sleep(0.2)

            pose = pose_stream.get() 
            _x = pose['x']
            self.assertAlmostEqual(pose['x'], 5.2, delta=0.20)

            simu.sleep(0.5)
            pose = pose_stream.get() #should not have moved
            self.assertAlmostEqual(pose['x'], _x, delta=0.03)
            logger.info("Ok, did not move")

            # now resume the move

            simu.robot.motion.resume().result()

            simu.sleep(0.5)

            # must move now
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 5.7, delta=0.20)
            status = simu.robot.motion.get_status().result()
            self.assertEqual(status, "Transit")

            # wait for the end of the move
            simu.sleep(1.5)
            self.assertTrue(action.done())
            self.assertFalse(action.running())

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 6.0, delta=0.15)
            status = simu.robot.motion.get_status().result()
            self.assertEqual(status, "Arrived")


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Waypoints_Test)

########NEW FILE########
__FILENAME__ = xyw_testing
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
import math
from morse.testing.testing import MorseMoveTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_speed(s, morse, x, y, w, t):
    s.publish({'x' : x, 'y' : y, 'w' : w})
    morse.sleep(t)
    s.publish({'x' : 0.0, 'y' : 0.0, 'w' : 0.0})

class XYW_Test(MorseMoveTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = ATRV()

        pose = Pose()
        robot.append(pose)
        pose.add_stream('socket')

        motion = MotionXYW('motion')
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')

        teleport = Teleport()
        robot.append(teleport)
        teleport.add_stream('socket')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_xyw_controller(self):
        with Morse() as morse:

            morse.deactivate('robot.teleport')
            xyw = morse.robot.motion

            precision = 0.12

            # Read the start position, it must be (0.0, 0.0, 0.0)
            self.assertAlmostEqualPositionThenFix(morse, [0.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_speed(xyw, morse, 1.0, 0.0, 0.0, 2.0)
            self.assertAlmostEqualPositionThenFix(morse, [2.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_speed(xyw, morse, 0.0, -1.0, 0.0, 2.0)
            self.assertAlmostEqualPositionThenFix(morse, [2.0, -2.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_speed(xyw, morse, -1.0, 1.0, 0.0, 2.0)
            self.assertAlmostEqualPositionThenFix(morse, [0.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_speed(xyw, morse, 1.0, 0.0, -math.pi/4.0, 2.0)
            self.assertAlmostEqualPositionThenFix(morse, [4.0 / math.pi, -4.0 / math.pi, 0.10,
                                 -math.pi / 2.0, 0.0, 0.0], precision)


            send_speed(xyw, morse, 0.5, 0.0, -math.pi/8.0, 12.0)
            self.assertAlmostEqualPositionThenFix(morse, [0.0, 0.0, 0.10, 0.0, 0.0, 0.0], precision)

            send_speed(xyw, morse, -2.0, 0.0, math.pi/2.0, 3.0)
            self.assertAlmostEqualPositionThenFix(morse, [4.0 / math.pi, -4.0 / math.pi, 0.10,
                                 -math.pi / 2.0, 0.0, 0.0], precision*2)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(XYW_Test)

########NEW FILE########
__FILENAME__ = invalid_builder_syntax
#! /usr/bin/env python
"""
This script tests how MORSE handles invalid Builder scripts.
"""

import sys
import math
from time import sleep
from morse.testing.testing import MorseBuilderFailureTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] <script>.py
try:
    from morse.builder import *
except ImportError:
    pass

class InvalidName_Test(MorseBuilderFailureTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = Morsy()
        robot.name = "toto.toto"

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_builder_script(self):
        pass # we only test the parsing of the script


class NoEnvironment_Test(MorseBuilderFailureTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = Morsy()

        env = Environment('i_do_not_exist', fastmode = True)
        env.add_service('socket')

    def test_builder_script(self):
        pass # we only test the parsing of the script

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(InvalidName_Test, NoEnvironment_Test)

########NEW FILE########
__FILENAME__ = actions
#! /usr/bin/env python
"""
This script tests ROS actions within MORSE.
"""

from morse.testing.ros import RosTestCase

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

import os
import sys
import time

import rospy
import actionlib
import nav_msgs.msg # do not conflict with morse builder

from morse.middleware.ros.helpers import ros_add_to_syspath
ros_add_to_syspath("move_base_msgs")
from move_base_msgs.msg import *

from geometry_msgs.msg import *

class RosActionsTest(RosTestCase):

    def setUpEnv(self):
        # Identical to ROS service testing
        
        print("Adding a robot...")
        robot = ATRV()

        odometry = Odometry()
        robot.append(odometry)
        odometry.add_stream('ros')

        waypoint = Waypoint()
        robot.append(waypoint)
        
        waypoint.add_service('ros')
        
        waypoint.configure_overlay('ros', 'morse.middleware.ros.overlays.waypoints.WayPoint')
        
        env = Environment('empty', fastmode = True)
        env.add_service('ros')

    def test_no_action(self):
            rospy.init_node('move_base_client')
            client = actionlib.SimpleActionClient('phantom_action', MoveBaseAction)
            self.assertFalse(client.wait_for_server(rospy.Duration(5)))

    def test_move_base(self):

            rospy.loginfo("Starting ROS test case for actions.")
            rospy.init_node('move_base_client')
            client = actionlib.SimpleActionClient('robot/waypoint/move_base', MoveBaseAction)
            self.assertTrue(client.wait_for_server(rospy.Duration(5)))

            goal = MoveBaseGoal(PoseStamped(pose = Pose(Point(0.1,3.0,0.0), Quaternion(0.0,0.0,0.0,1.0))))

            print("Sending a first goal to the robot...(timeout=5sec)")
            status = client.send_goal_and_wait(goal, rospy.Duration(5))

            print("Got this status: " + str(status))
            self.assertEqual(status, actionlib.GoalStatus.SUCCEEDED)

    def get_pose(self):
        msg = rospy.client.wait_for_message('/robot/odometry', nav_msgs.msg.Odometry, timeout = 10)
        return (msg.pose.pose.position.x, msg.pose.pose.position.y)

    def check_not_moving(self):
        pos1 = self.get_pose()
        time.sleep(0.5)
        pos2 = self.get_pose()
        self.assertAlmostEqual(pos1[0], pos2[0], delta=0.05)
        self.assertAlmostEqual(pos1[1], pos2[1], delta=0.05)

    def cb_preempted(self, status, res):
        self.cb_fired = True
        self.assertEqual(status, actionlib.GoalStatus.PREEMPTED)

    def cb_succeeded(self, status, res):
        self.cb_fired = True
        self.assertEqual(status, actionlib.GoalStatus.SUCCEEDED)


    def test_move_advanced(self):
            
        rospy.loginfo("Starting ROS test case for actions (advanced behaviour).")
        rospy.init_node('move_base_client')
        client = actionlib.SimpleActionClient('robot/waypoint/move_base', MoveBaseAction)
        client2 = actionlib.SimpleActionClient('robot/waypoint/move_base', MoveBaseAction)
        self.assertTrue(client.wait_for_server(rospy.Duration(5)))
        self.assertTrue(client2.wait_for_server(rospy.Duration(5)))

        self.assertIsNotNone(self.get_pose())

        goal1 = MoveBaseGoal(PoseStamped(pose = Pose(Point(0.1,10.0,0.0), Quaternion(0.0,0.0,0.0,1.0))))
        goal2 = MoveBaseGoal(PoseStamped(pose = Pose(Point(0.1,2.0,0.0), Quaternion(0.0,0.0,0.0,1.0))))


        # send goal with not enough time to complete -> should get a preemption and the robot actually stopping
        status = client.send_goal_and_wait(goal1, rospy.Duration(1))
        self.assertEqual(status, actionlib.GoalStatus.PREEMPTED)
        self.check_not_moving()
        ######

        # sending again the goal, and ask for cancellation
        self.cb_fired = False
        client.send_goal(goal1, done_cb = self.cb_preempted)
        time.sleep(1)
        client.cancel_goal()
        self.check_not_moving()
        self.assertTrue(self.cb_fired)
        ######

        # sending again the goal, this time, interrupted by another one
        self.cb_fired = False
        client.send_goal(goal1, done_cb = self.cb_preempted)
        time.sleep(1)
        client2.send_goal(goal2, done_cb = self.cb_succeeded)
        time.sleep(0.5)
        self.assertTrue(self.cb_fired)
        self.cb_fired = False
        time.sleep(5)
        self.assertTrue(self.cb_fired)
        ######




########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(RosActionsTest)

########NEW FILE########
__FILENAME__ = depth_camera
#! /usr/bin/env python
"""
This script tests the Depth camera with ROS in MORSE.
"""

import sys
import time
import math
import struct
from morse.testing.ros import RosTestCase
from morse.testing.testing import testlogger

import roslib
import rospy
from geometry_msgs.msg import Twist
from sensor_msgs.msg import PointCloud2

# Include this import to be able to use your test file as a regular
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def pub_vw(topic, v, w):
    pub = rospy.Publisher(topic, Twist)
    msg = Twist()
    msg.linear.x = v
    msg.angular.z = w
    # wait 1 second for publisher
    rospy.sleep(1.0)
    pub.publish(msg)

class DepthCameraRosTest(RosTestCase):

    def setUpEnv(self):
        """ Defines the test scenario """

        robot = ATRV()

        motion = MotionVW()
        robot.append(motion)
        motion.add_stream('ros')

        camera = DepthCamera()
        camera.translate(z = 1)
        camera.frequency(3)
        robot.append(camera)
        camera.add_stream('ros')

        env = Environment('indoors-1/boxes')
        # No fastmode here, no MaterialIndex in WIREFRAME mode: AttributeError:
        # 'KX_PolygonMaterial' object has no attribute 'getMaterialIndex'

    def test_depth_camera(self):
        rospy.init_node('morse_ros_depth_testing', log_level=rospy.DEBUG)

        motion_topic = '/robot/motion'
        camera_topic = '/robot/camera'

        pub_vw(motion_topic, 1, 1)

        for step in range(5):
            msg = rospy.wait_for_message(camera_topic, PointCloud2, 10)

            # assert that : near <= z <= far
            for i in range(0, len(msg.data) - 12, 12):
                xyz = struct.unpack('fff', msg.data[i:i+12])
                self.assertTrue(1 <= xyz[2] <= 20)

            time.sleep(0.2) # wait for turning

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(DepthCameraRosTest, time_modes = [TimeStrategies.BestEffort])

########NEW FILE########
__FILENAME__ = sick
#! /usr/bin/env python
"""
This script tests the Sick laser scanner with ROS in MORSE.
"""

import sys
import time
import math
import struct
from morse.testing.ros import RosTestCase
from morse.testing.testing import testlogger

import roslib
import rospy
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan

# Include this import to be able to use your test file as a regular
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def pub_vw(topic, v, w):
    pub = rospy.Publisher(topic, Twist)
    msg = Twist()
    msg.linear.x = v
    msg.angular.z = w
    # wait 1 second for publisher
    rospy.sleep(1.0)
    pub.publish(msg)

class SickLaserRosTest(RosTestCase):

    def setUpEnv(self):
        """ Defines the test scenario """

        robot = ATRV()

        motion = MotionVW()
        robot.append(motion)
        motion.add_stream('ros')

        sick = Sick()
        sick.translate(x = 0.18, z = 0.94)
        robot.append(sick)
        # sick.properties(scan_window = 270, resolution = .25)
        sick.properties(scan_window = 180, resolution = 1)
        sick.add_stream('ros')
        # test does not call sick.__del__() so create laser arc manually
        sick.create_laser_arc()

        env = Environment('indoors-1/boxes', fastmode=True)

    def test_sick_laser(self):
        rospy.init_node('morse_ros_laser_testing', log_level=rospy.DEBUG)

        motion_topic = '/robot/motion'
        laser_topic  = '/robot/sick'

        pub_vw(motion_topic, 1, 1)

        old = []
        for step in range(5):
            msg = rospy.wait_for_message(laser_topic, LaserScan, 10)

            self.assertEqual(len(msg.ranges), 181) # 180 + center ray
            self.assertTrue (msg.ranges != old)
            old = msg.ranges
            # assert that : near <= distance <= far
            for distance in msg.ranges:
                self.assertTrue(0.1 <= distance <= 30)

            time.sleep(0.2) # wait for turning

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(SickLaserRosTest, time_modes = [TimeStrategies.BestEffort])

########NEW FILE########
__FILENAME__ = topics
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
import math
from morse.testing.ros import RosTestCase
from morse.testing.testing import testlogger

import rospy
import std_msgs
import nav_msgs.msg # do not conflict with morse builder
from geometry_msgs.msg import Twist
from time import sleep

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_speed(s, v, w, t):
    msg = Twist()
    msg.linear.x = v
    msg.angular.z = w
    s.publish(msg)
    sleep(t)
    msg.linear.x = 0.0
    msg.angular.z = 0.0
    s.publish(msg)

class DataStreamTest(RosTestCase):

    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = ATRV()

        odometry = Odometry()
        robot.append(odometry)
        odometry.add_stream('ros')

        motion = MotionVW()
        robot.append(motion)
        motion.add_stream('ros')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def pose_callback(self, data):
        self.pos = data

    def test_vw_controller(self):
        # XXX 
        # test the orientation part, but the easy way is to use numpy or
        # tf, and don't want to add too much dependency for test

        rospy.init_node('morse_ros_data_stream_test')
        rospy.Subscriber('/robot/odometry', nav_msgs.msg.Odometry, self.pose_callback)

        msg = rospy.client.wait_for_message('/robot/odometry', nav_msgs.msg.Odometry, timeout = 10)
        self.assertTrue(msg is not None)

        cmd_stream = rospy.Publisher('/robot/motion', Twist)
       
        self.assertTrue(hasattr(self, "pos"))
        precision=0.15

        self.assertAlmostEqual(self.pos.pose.pose.position.x, 0.0, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.y, 0.0, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.z, 0.0, delta=precision)
 
        # sleep to make sure that the other peer can read it ...
        sleep(1)

        send_speed(cmd_stream, 1.0, 0.0, 2.0)
        sleep(1)

        self.assertAlmostEqual(self.pos.pose.pose.position.x, 2.0, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.y, 0.0, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.z, 0.0, delta=precision)

        send_speed(cmd_stream, -1.0, 0.0, 2.0)

        self.assertAlmostEqual(self.pos.pose.pose.position.x, 0.0, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.y, 0.0, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.z, 0.0, delta=precision)

        # sleep to make sure that the other peer can read it ...
        sleep(1)

        send_speed(cmd_stream, 1.0, -math.pi/4.0, 2.0)
        sleep(1)

        self.assertAlmostEqual(self.pos.pose.pose.position.x, 4.0 / math.pi, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.y, -4.0 / math.pi, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.z, 0.0, delta=precision)

        # sleep to make sure that the other peer can read it ...
        sleep(1)

        send_speed(cmd_stream, 0.5, -math.pi/8.0, 12.0)
        sleep(1)

        self.assertAlmostEqual(self.pos.pose.pose.position.x, 0.0, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.y, 0.0, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.z, 0.0, delta=precision)

        send_speed(cmd_stream, -2.0, math.pi/2.0, 3.0)

        self.assertAlmostEqual(self.pos.pose.pose.position.x, 4.0 / math.pi, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.y, -4.0 / math.pi, delta=precision)
        self.assertAlmostEqual(self.pos.pose.pose.position.z, 0.0, delta=precision)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(DataStreamTest, time_modes = [TimeStrategies.BestEffort])

########NEW FILE########
__FILENAME__ = video_camera
#! /usr/bin/env python
"""
This script tests the Video camera with ROS in MORSE.
"""

import sys
import time
import math
import struct
from morse.testing.ros import RosTestCase
from morse.testing.testing import testlogger

import roslib
import rospy
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Image, CameraInfo

# Include this import to be able to use your test file as a regular
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def pub_vw(topic, v, w):
    pub = rospy.Publisher(topic, Twist)
    msg = Twist()
    msg.linear.x = v
    msg.angular.z = w
    # wait 1 second for publisher
    rospy.sleep(1.0)
    pub.publish(msg)

class VideoCameraRosTest(RosTestCase):

    def setUpEnv(self):
        """ Defines the test scenario """

        robot = ATRV()

        motion = MotionVW()
        robot.append(motion)
        motion.add_stream('ros')

        camera = VideoCamera()
        camera.properties(cam_width=128, cam_height=128, capturing=True, Vertical_Flip=True)
        camera.translate(z = 1)
        camera.frequency(3)
        robot.append(camera)
        camera.add_stream('ros')

        env = Environment('indoors-1/boxes')
        # No fastmode here, no MaterialIndex in WIREFRAME mode: AttributeError:
        # 'KX_PolygonMaterial' object has no attribute 'getMaterialIndex'

    def test_video_camera(self):
        rospy.init_node('morse_ros_video_testing', log_level=rospy.DEBUG)

        motion_topic = '/robot/motion'
        camera_topic = '/robot/camera/image'
        camnfo_topic = '/robot/camera/camera_info'

        pub_vw(motion_topic, 1, 1)

        old = []
        for step in range(2):
            msg = rospy.wait_for_message(camnfo_topic, CameraInfo, 10)
            camera_info_frame = msg.header.frame_id
            # might want to add more CameraInfo test here

            msg = rospy.wait_for_message(camera_topic, Image, 10)

            self.assertEqual(msg.header.frame_id, camera_info_frame)

            self.assertEqual(len(msg.data), 128*128*4) # RGBA
            self.assertTrue (msg.data != old)
            old = msg.data

            time.sleep(0.2) # wait for turning

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(VideoCameraRosTest, time_modes = [TimeStrategies.BestEffort])

########NEW FILE########
__FILENAME__ = yarp_datastream_testing
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
import math
import subprocess
import yarp
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_speed_(s, v, w):
    b = s.prepare()
    b.clear()
    b.addDouble(v)
    b.addDouble(w)
    s.write(True)

def send_speed(s, morse, v, w, t):
    send_speed_(s, v, w)
    morse.sleep(t)
    send_speed_(s, 0.0, 0.0)

class YARP_MW_Test(MorseTestCase):

    def setUpMw(self):
        print("Launching yarpserver3")
        try:
            self.yarp_process = subprocess.Popen(['yarpserver3'])
        except OSError as ose:
            testlogger.error("Error while launching yarpserver3 ! Check you can run it from command-line\n")
            raise ose

    def tearDownMw(self):
        self.yarp_process.terminate()

    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = ATRV()

        pose = Pose()
        pose.translate(z=-0.10)
        robot.append(pose)
        pose.add_stream('yarp')

        motion = MotionVW()
        robot.append(motion)
        motion.add_stream('yarp')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_vw_controller(self):
        """ This test is guaranteed to be started only when the simulator
        is ready.
        """
        pass

        yarp.Network.init()

        pose_stream = yarp.BufferedPortBottle()
        pose_stream.open("/morse/test/pose/in")
        yarp.Network.connect("/morse/robot/pose/out", "/morse/test/pose/in")

        cmd_stream = yarp.BufferedPortBottle()
        cmd_stream.open("/morse/test/vw/out")
        yarp.Network.connect("/morse/test/vw/out", "/morse/robot/motion/in")
        
        with Morse() as morse:
            # Read the start position, it must be (0.0, 0.0, 0.0)

            precision = 0.20
            pose = pose_stream.read()
            for i in range(1, 7):
                self.assertAlmostEqual(pose.get(i).asDouble(), 0.0, delta = precision)


            send_speed(cmd_stream, morse, 1.0, 0.0, 2.0)

            pose = pose_stream.read()
            self.assertAlmostEqual(pose.get(1).asDouble(), 2.0, delta = precision)
            self.assertAlmostEqual(pose.get(2).asDouble(), 0.0, delta = precision)
            self.assertAlmostEqual(pose.get(3).asDouble(), 0.0, delta = precision)
            self.assertAlmostEqual(pose.get(4).asDouble(), 0.0, delta = precision)
            self.assertAlmostEqual(pose.get(5).asDouble(), 0.0, delta = precision)
            self.assertAlmostEqual(pose.get(6).asDouble(), 0.0, delta = precision)

            send_speed(cmd_stream, morse, -1.0, 0.0, 2.0)

            pose = pose_stream.read()
            for i in range(1, 7):
                self.assertAlmostEqual(pose.get(i).asDouble(), 0.0, delta = precision)

            send_speed(cmd_stream, morse, 1.0, -math.pi/4.0, 2.0)
            pose = pose_stream.read()
            self.assertAlmostEqual(pose.get(1).asDouble(), 4.0 / math.pi, delta = precision)
            self.assertAlmostEqual(pose.get(2).asDouble(), -4.0 / math.pi , delta = precision)
            self.assertAlmostEqual(pose.get(3).asDouble(), 0.0, delta = precision)
            self.assertAlmostEqual(pose.get(4).asDouble(), -math.pi/2.0, delta = precision)
            self.assertAlmostEqual(pose.get(5).asDouble(), 0.0, delta = precision)
            self.assertAlmostEqual(pose.get(6).asDouble(), 0.0, delta = precision)

            send_speed(cmd_stream, morse, 0.5, -math.pi/8.0, 12.0)
            pose = pose_stream.read()
            for i in range(1, 7):
                self.assertAlmostEqual(pose.get(i).asDouble(), 0.0, delta = precision)

            send_speed(cmd_stream, morse, -2.0, math.pi/2.0, 3.0)
            pose = pose_stream.read()
            self.assertAlmostEqual(pose.get(1).asDouble(), 4.0 / math.pi, delta = precision)
            self.assertAlmostEqual(pose.get(2).asDouble(), -4.0 / math.pi , delta = precision)
            self.assertAlmostEqual(pose.get(3).asDouble(), 0.0, delta = precision)
            self.assertAlmostEqual(pose.get(4).asDouble(), -math.pi/2.0, delta = precision)
            self.assertAlmostEqual(pose.get(5).asDouble(), 0.0, delta = precision)
            self.assertAlmostEqual(pose.get(6).asDouble(), 0.0, delta = precision)

        yarp.Network.fini()

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(YARP_MW_Test)

########NEW FILE########
__FILENAME__ = human_pose
#! /usr/bin/env python
"""
This script tests the human model with a pose sensor.
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] <your test>.py
try:
    from morse.builder import *
except ImportError:
    pass

class HumanPoseTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """

        human = Human()

        pose = Pose()
        human.append(pose)
        pose.add_stream('socket')

        motion = Waypoint()
        human.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_pose(self):
        """ Tests we can load the human model, attach a pose sensor, and
        get back the pose.
        """
        with Morse() as morse:

            #Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.human.pose
            morse.sleep(1)
            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.1)

    def _test_movement(self):
        """ Tests the human can accept an actuator, and that it
        work as expected to move around the human.

        Currently disabled (the waypoint actuator can not move yet the human)
        """
        with Morse() as morse:

            #Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.human.pose

            # waypoint controller socket
            v_w_client = morse.human.motion

            v_w_client.publish({'x' : 2.0, 'y': 3.0, 'z': 0.0,
                                'tolerance' : 0.3,
                                'speed' : 1.0})

            morse.sleep(5)
            pose = pose_stream.get()

            self.assertAlmostEqual(pose['x'], 2.0, delta=0.5)
            self.assertAlmostEqual(pose['y'], 3.0, delta=0.5)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(HumanPoseTest)

########NEW FILE########
__FILENAME__ = human_service
#! /usr/bin/env python
"""
This script tests the human model with a pose sensor.
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] <your test>.py
try:
    from morse.builder import *
except ImportError:
    pass

class HumanServiceTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """

        human = Human()
        human.add_service('socket')

        pose = Pose()
        human.append(pose)
        pose.add_stream('socket')

        env = Environment('empty', fastmode = True)


    def test_movement(self):
        """ Tests the human can accept an actuator, and that it
        work as expected to move around the human.

        Currently disabled (the waypoint actuator can not move yet the human)
        """
        with Morse() as morse:

            precision = 0.05

            #Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.human.pose

            pose = pose_stream.get()

            self.assertAlmostEquals(pose['x'], 0.0, delta=precision)
            self.assertAlmostEquals(pose['y'], 0.0, delta=precision)

            morse.human.move(1.0, 0.0)
            morse.sleep(0.1)

            pose = pose_stream.get()

            self.assertAlmostEquals(pose['x'], 1.0, delta=precision)
            self.assertAlmostEquals(pose['y'], 0.0, delta=precision)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(HumanServiceTest)

########NEW FILE########
__FILENAME__ = multiple_human
#! /usr/bin/env python
"""
This script tests the human model with a pose sensor.
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] <your test>.py
try:
    from morse.builder import *
except ImportError:
    pass

class MultipleHumanTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        human1 = Human()
        human1.append(Pose("pose"))
        human1.disable_keyboard_control()
        human1.use_world_camera()
        human1.translate(x = 5.0)
        human1.add_default_interface('socket')

        human2 = Human()
        human2.append(Pose("pose"))
        human2.disable_keyboard_control()
        human2.use_world_camera()
        human2.translate(x = -5.0)
        human2.add_default_interface('socket')

        human3 = Human()
        human3.append(Pose("pose"))
        human3.add_default_interface('socket')

        env = Environment('empty', fastmode = True)

    def test_pose(self):
        with Morse() as morse:
            p1 = morse.human1.pose.get()
            p2 = morse.human2.pose.get()
            p3 = morse.human3.pose.get()

            self.assertAlmostEquals(p1['x'], 5.0, delta=0.01)
            self.assertAlmostEquals(p2['x'], -5.0, delta=0.01)
            self.assertAlmostEquals(p3['x'], 0.0, delta=0.01)
            self.assertAlmostEquals(p1['y'], 0.0, delta=0.01)
            self.assertAlmostEquals(p2['y'], 0.0, delta=0.01)
            self.assertAlmostEquals(p3['y'], 0.0, delta=0.01)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(MultipleHumanTest)

########NEW FILE########
__FILENAME__ = pionner3dx_testing
#! /usr/bin/env python
"""
This script tests the Segway RMP400 robot with differential drive actuator
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def gradual_speed(s, morse, v, w, t):
    """ Start and finish applying only half of the desired speed """
    tic = t/20.0
    s.publish({'v' : v/4, 'w' : w/4})
    morse.sleep(tic*2)
    s.publish({'v' : v/2, 'w' : w/2})
    morse.sleep(tic*1)
    s.publish({'v' : v, 'w' : w})
    morse.sleep(tic*18)
    s.publish({'v' : v/2, 'w' : w/2})
    morse.sleep(tic*2)
    s.publish({'v' : v/4, 'w' : w/4})
    morse.sleep(tic*2)
    s.publish({'v' : 0.0, 'w' : 0.0})


def send_speed(s, morse, v, w, t):
    #s.publish({'v' : v, 'w' : w})
    #morse.sleep(t)
    #s.publish({'v' : 0.0, 'w' : 0.0})
    gradual_speed(s, morse, v, w, t)
    morse.sleep(1)

def send_service_speed(s, morse, v, w, t):
    s.set_speed(v, w)
    morse.sleep(t)
    s.stop()
    morse.sleep(1)

class Pioneer3DXTest(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        robot = Pioneer3DX()

        pose = Pose()
        robot.append(pose)
        pose.translate(z=-0.15)
        pose.add_stream('socket')

        motion = MotionVWDiff()
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_vw_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.robot.pose
            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.05)

            morse.sleep(1)

            # Check that it does not dance :)
            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.05)

            v_w = morse.robot.motion

            send_speed(v_w, morse, 1.0, 0.0, 2.0)

            precision = 0.30

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=precision)
            self.assertAlmostEqual(pose['y'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['z'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)

            send_speed(v_w, morse, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=precision)

            send_speed(v_w, morse, 1.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=precision)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=precision)
            self.assertAlmostEqual(pose['z'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)


    # Desactive this test for now. With no control on acceleration, the
    # result of service calling is often relatively too fuzzy to make a
    # repeatable test
    def _test_vw_service_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.robot.pose
            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.05)

            v_w = morse.robot.motion

            precision = 0.40
            send_service_speed(v_w, morse, 1.0, 0.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=precision)
            self.assertAlmostEqual(pose['y'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['z'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)

            send_service_speed(v_w, morse, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=precision)

            send_service_speed(v_w, morse, 1.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=precision)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=precision)
            self.assertAlmostEqual(pose['z'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Pioneer3DXTest)

########NEW FILE########
__FILENAME__ = head_sockets
#! /usr/bin/env python
"""
This script tests the PR2 torso armature joint
"""

from morse.testing.testing import MorseTestCase
import logging; logger = logging.getLogger("morsetesting.general")

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

import sys
import time

from pymorse import Morse

def getjoint(name):
    
    with Morse() as simu:
        joints = simu.pr2.posture.get()

        return joints[name]

class PR2TorsoTest(MorseTestCase):

    def setUpEnv(self):
        from morse.builder.robots import BasePR2
        pr2 = BasePR2()
        pr2.add_stream('socket')

        env = Environment('empty', fastmode=True)
        env.set_camera_rotation([1.0470, 0, 0.7854])

    def test_head_pan(self):
        

        joint = "head_pan"

        self.assertAlmostEquals(getjoint(joint), 0.0, 3)

        with Morse() as simu:

            logger.info("Paning the head 1")
            action = simu.pr2.head.rotate(joint, 1, 1).result() # speed = 1 rad/s
            self.assertAlmostEquals(getjoint(joint), 1, 1)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(PR2TorsoTest)

########NEW FILE########
__FILENAME__ = jointstate_ros
#! /usr/bin/env python
"""
This script tests ROS services within MORSE.
"""

from morse.testing.ros import RosTestCase

# Include this import to be able to use your test file as a regular
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

import os
import sys

import rospy
import time
from sensor_msgs.msg import JointState

class PR2JointStateTest(RosTestCase):

    # from the output of "rostopic echo /joint_states" on the PR2
    pr2_joints_list = ['fl_caster_rotation_joint', 'fl_caster_l_wheel_joint', 'fl_caster_r_wheel_joint', 'fr_caster_rotation_joint', 'fr_caster_l_wheel_joint', 'fr_caster_r_wheel_joint', 'bl_caster_rotation_joint', 'bl_caster_l_wheel_joint', 'bl_caster_r_wheel_joint', 'br_caster_rotation_joint', 'br_caster_l_wheel_joint', 'br_caster_r_wheel_joint', 'torso_lift_joint', 'torso_lift_motor_screw_joint', 'head_pan_joint', 'head_tilt_joint', 'laser_tilt_mount_joint', 'r_upper_arm_roll_joint', 'r_shoulder_pan_joint', 'r_shoulder_lift_joint', 'r_forearm_roll_joint', 'r_elbow_flex_joint', 'r_wrist_flex_joint', 'r_wrist_roll_joint', 'r_gripper_joint', 'r_gripper_l_finger_joint', 'r_gripper_r_finger_joint', 'r_gripper_r_finger_tip_joint', 'r_gripper_l_finger_tip_joint', 'r_gripper_motor_screw_joint', 'r_gripper_motor_slider_joint', 'l_upper_arm_roll_joint', 'l_shoulder_pan_joint', 'l_shoulder_lift_joint', 'l_forearm_roll_joint', 'l_elbow_flex_joint', 'l_wrist_flex_joint', 'l_wrist_roll_joint', 'l_gripper_joint', 'l_gripper_l_finger_joint', 'l_gripper_r_finger_joint', 'l_gripper_r_finger_tip_joint', 'l_gripper_l_finger_tip_joint', 'l_gripper_motor_screw_joint', 'l_gripper_motor_slider_joint']

    def setUpEnv(self):
        print("Adding a PR2 robot...")
        pr2 = BasePR2()
        pr2.add_interface("ros")

        env = Environment('empty', fastmode = True)
        env.set_camera_rotation([1.0470, 0, 0.7854])


    def test_base_jointstates(self):
        rospy.loginfo("Creating listener node to check if posture of PR2 is published.")
        rospy.init_node('pr2_jointstate_listener', log_level = rospy.DEBUG, disable_signals=True)
        rospy.loginfo("Subscribing to pr2_posture topic.")
        jointstate_msg = rospy.client.wait_for_message("joint_states", JointState)
        name_len = len(jointstate_msg.name)
        pos_len = len(jointstate_msg.position)
        rospy.loginfo("Checking if number of jointstate names equals number of jointstate positions.")
        self.assertEqual(pos_len, name_len, 'Found %s jointstate names but %s jointstate positions. Please check the configuration of your pr2_posture sensor and middleware!'%(name_len, pos_len))
        rospy.loginfo("Checking is every jointstate is present.")
        self.assertEqual(set(self.pr2_joints_list), set(jointstate_msg.name), 'Could not find all joints of the PR2. Please check if you named the joints correctly in your pr2_posture sensor and middleware!' )

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(PR2JointStateTest)

########NEW FILE########
__FILENAME__ = jointstate_sockets
#! /usr/bin/env python
"""
This script tests the PR2 torso armature joint
"""

from morse.testing.testing import MorseTestCase

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

import sys
from pymorse import Morse

# from the output of "rostopic echo /joint_states" on the PR2
PR2_JOINTS = {'fl_caster_rotation_joint', 'fl_caster_l_wheel_joint', 'fl_caster_r_wheel_joint', 'fr_caster_rotation_joint', 'fr_caster_l_wheel_joint', 'fr_caster_r_wheel_joint', 'bl_caster_rotation_joint', 'bl_caster_l_wheel_joint', 'bl_caster_r_wheel_joint', 'br_caster_rotation_joint', 'br_caster_l_wheel_joint', 'br_caster_r_wheel_joint', 'torso_lift_joint', 'torso_lift_motor_screw_joint', 'head_pan_joint', 'head_tilt_joint', 'laser_tilt_mount_joint', 'r_upper_arm_roll_joint', 'r_shoulder_pan_joint', 'r_shoulder_lift_joint', 'r_forearm_roll_joint', 'r_elbow_flex_joint', 'r_wrist_flex_joint', 'r_wrist_roll_joint', 'r_gripper_joint', 'r_gripper_l_finger_joint', 'r_gripper_r_finger_joint', 'r_gripper_r_finger_tip_joint', 'r_gripper_l_finger_tip_joint', 'r_gripper_motor_screw_joint', 'r_gripper_motor_slider_joint', 'l_upper_arm_roll_joint', 'l_shoulder_pan_joint', 'l_shoulder_lift_joint', 'l_forearm_roll_joint', 'l_elbow_flex_joint', 'l_wrist_flex_joint', 'l_wrist_roll_joint', 'l_gripper_joint', 'l_gripper_l_finger_joint', 'l_gripper_r_finger_joint', 'l_gripper_r_finger_tip_joint', 'l_gripper_l_finger_tip_joint', 'l_gripper_motor_screw_joint', 'l_gripper_motor_slider_joint'}


class PR2TorsoTest(MorseTestCase):

    def setUpEnv(self):
        from morse.builder.robots import BasePR2
        pr2 = BasePR2()
        pr2.add_interface("socket")

        env = Environment('empty', fastmode=True)
        env.set_camera_rotation([1.0470, 0, 0.7854])

    def test_joints(self):

        with Morse() as simu:
            joints = simu.pr2.joint_state.get()

            self.assertEqual(len(set(joints.keys())), len(joints.keys()),
                             'Some joints are duplicated!' )
            self.assertEqual(set(joints.keys()), PR2_JOINTS | {'timestamp'}, 
                    'Could not find all joints of the PR2. Please check if you'
                    'named the joints correctly in your pr2_posture sensor and'
                    'middleware!' )

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(PR2TorsoTest)

########NEW FILE########
__FILENAME__ = torso_ros
#! /usr/bin/env python
"""
This script tests the PR2 torso armature joint
"""

from morse.testing.ros import RosTestCase

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

import sys

import rospy
from pr2_controllers_msgs.msg import *
import time

def getjoint(self, name):
    
    import rospy
    from sensor_msgs.msg import JointState
    
    data = rospy.wait_for_message("/pr2/joint_states", JointState)
    idx = data.name.index(name)
    return data.position[idx]

class PR2TorsoTest(RosTestCase):

    def setUpEnv(self):
        print("Adding a PR2 robot...")
        pr2 = BasePR2()
        pr2.add_interface('ros')

        env = Environment('empty', fastmode=True)
        env.set_camera_rotation([1.0470, 0, 0.7854])

    def test_controller(self):
        
        from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint

        topic = "/pr2/torso_controller/command"

        rospy.init_node('test_pr2_torso_controller', log_level = rospy.DEBUG, disable_signals=True)

        rospy.loginfo("Preparing to publish on %s" % topic)
        ctl = rospy.Publisher(topic, JointTrajectory)

        self.assertEquals(getjoint("torso_lift_joint"), 0.0)

        duration = 0.1

        traj = JointTrajectory()
        traj.joint_name = "torso_lift_joint"

        initialpoint = JointTrajectoryPoint()
        initialpoint.positions = 0.0
        initialpoint.velocities = 0.0
        initialpoint.time_from_start = rospy.Duration(0.0)

        finalpoint = JointTrajectoryPoint()
        finalpoint.positions = 0.195
        finalpoint.velocities = 0.0
        finalpoint.time_from_start = rospy.Duration(duration)

        # First, move up 
        traj.points = [initialpoint, finalpoint]

        ctl.publish(traj)
        time.sleep(duration + 0.1)
        self.assertEquals(getjoint("torso_lift_joint"), 0.195)

        # Go back to initial position
        finalpoint.time_from_start = rospy.Duration(0.0)
        initialpoint.time_from_start = rospy.Duration(duration)
        traj.points = [finalpoint, initialpoint]

        ctl.publish(traj)
        time.sleep(duration + 0.1)
        self.assertEquals(getjoint("torso_lift_joint"), 0.0)

    def test_action(self):

        from pr2_controllers_msgs.msg import SingleJointPositionAction, SingleJointPositionGoal

        rospy.loginfo("Trying to move PR2 torso at action level.")
        rospy.init_node('test_pr2_torso_action', log_level = rospy.DEBUG, disable_signals=True)
        client = actionlib.SimpleActionClient('torso_controller/position_joint_action', SingleJointPositionAction)
        self.assertTrue(client.wait_for_server(rospy.Duration(5)))

        self.assertEquals(getjoint("torso_lift_joint"), 0.0)

        up = SingleJointPositionGoal
        up.position = 0.195
        up.min_duration = rospy.Duration(2.0)
        up.max_velocity = 1.0

        print("Sending a 'up' goal to the torso...(timeout=5sec)")
        status = client.send_goal_and_wait(up, rospy.Duration(5))

        print("Got this status: " + str(status))
        self.assertEqual(status, actionlib.GoalStatus.SUCCEEDED)

        self.assertEquals(getjoint("torso_lift_joint"), 0.195)

        down = SingleJointPositionGoal
        down.position = 0.0
        down.min_duration = rospy.Duration(2.0)
        down.max_velocity = 1.0

        print("Sending a 'down' goal to the torso...(timeout=5sec)")
        status = client.send_goal_and_wait(down, rospy.Duration(5))

        print("Got this status: " + str(status))
        self.assertEqual(status, actionlib.GoalStatus.SUCCEEDED)

        self.assertEquals(getjoint("torso_lift_joint"), 0.0)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(PR2TorsoTest)

########NEW FILE########
__FILENAME__ = torso_sockets
#! /usr/bin/env python
"""
This script tests the PR2 torso armature joint
"""

from morse.testing.testing import MorseTestCase
import logging; logger = logging.getLogger("morsetesting.general")

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

import sys

from pymorse import Morse

def getjoint(simu, name):
    joints = simu.pr2.joint_state.get()
    return joints[name]

class PR2TorsoTest(MorseTestCase):

    def setUpEnv(self):
        from morse.builder.robots import BasePR2
        pr2 = BasePR2()
        pr2.add_interface('socket')

        env = Environment('empty', fastmode=True)
        env.set_camera_rotation([1.0470, 0, 0.7854])

    def test_torso_translate(self):
        

        joint = "torso_lift_joint"

        with Morse() as simu:
            
            self.assertAlmostEquals(getjoint(simu, joint), 0.0, 3)

            logger.info("Moving up torso to 0.2m...")
            action = simu.pr2.torso.translate(joint, 0.2, 0.1) # speed = 0.1 m/s

            simu.sleep(1)
            logger.info("Should be now at 0.1m...")
            self.assertAlmostEquals(getjoint(simu, joint), 0.1, 1)

            simu.sleep(1)
            logger.info("Should be now at 0.2m...")
            self.assertAlmostEquals(getjoint(simu, joint), 0.2, 1)

            # Check we do not move anymore
            logger.info("Should not move anymore...")
            simu.sleep(0.5)
            self.assertFalse(action.running())
            self.assertAlmostEquals(getjoint(simu, joint), 0.2, 1)

            # Test limits
            #TODO: currently no way to stop the action when blocking on a joint limit since we can not retreive them from Python (blender 2.64)
            #logger.info("Let's go as high as possible to check my limits...")
            #action = simu.pr2.torso.translate(joint, [0, 1, 0], 0.2) # speed = 0.2 m/s
            #simu.sleep(2)
            #self.assertFalse(action.running())
            #self.assertAlmostEquals(getjoint(simu, joint), 0.3, 1)

            # Go back to initial position
            logger.info("Let's go back down...")
            action = simu.pr2.torso.translate(joint, 0, 0.2) # speed = 0.2 m/s
            simu.sleep(1.6)
            self.assertFalse(action.running())
            self.assertAlmostEquals(getjoint(simu, joint), 0.0, 1)

            ## Testing set_translation
            logger.info("Moving up torso to 0.2m...")
            simu.pr2.torso.set_translation(joint, 0.2)
            logger.info("Should be now at 0.2m...")
            simu.sleep(.1)
            self.assertAlmostEquals(getjoint(simu, joint), 0.2, 3)

            # Test limits
            logger.info("Let's go as high as possible to check my limits...")
            simu.pr2.torso.set_translation(joint, 1)
            simu.sleep(.1)
            self.assertAlmostEquals(getjoint(simu, joint), 0.31, 3)
            simu.pr2.torso.set_translation(joint, -1)
            simu.sleep(.1)
            self.assertAlmostEquals(getjoint(simu, joint), 0.0, 3)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(PR2TorsoTest)

########NEW FILE########
__FILENAME__ = tuck_arms_ros
#!/usr/bin/env python
#
# Test PR2 arm tucking in MORSE.
#
# Based on pr2_tuck_arms:
#
# Copyright (c) 2009, Willow Garage, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the Willow Garage nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Author: Wim Meeussen
# Modified by Jonathan Bohren to be an action and for untucking


from morse.testing.ros import RosTestCase

import sys
import time
import math

import rospy

from morse.middleware.ros.helpers import ros_add_to_syspath
ros_add_to_syspath("pr2_controllers_msgs")
from pr2_controllers_msgs.msg import *

from trajectory_msgs.msg import *
import actionlib

# Joint names
joint_names = ["shoulder_pan", 
               "shoulder_lift",
               "upper_arm_roll",
               "elbow_flex", 
               "forearm_roll",
               "wrist_flex", 
               "wrist_roll" ]


l_arm_tucked = [0.06024, 1.248526, 1.789070, -1.683386, -1.7343417, -0.0962141, -0.0864407]
r_arm_tucked = [-0.023593, 1.1072800, -1.5566882, -2.124408, -1.4175, -1.8417, 0.21436]
l_arm_untucked = [ 0.4,  1.0,   0.0,  -2.05,  0.0,  -0.1,  0.0]
r_arm_untucked = [-0.4,  1.0,   0.0,  -2.05,  0.0,  -0.1,  0.0]
r_arm_approach = [0.039, 1.1072, 0.0, -2.067, -1.231, -1.998, 0.369]
r_arm_up_traj = [[-0.4,  0.0,   0.0,  -2.05,  0.0,  -0.1,  0.0]]

# Tuck trajectory
l_arm_tuck_traj = [l_arm_tucked]
r_arm_tuck_traj = [r_arm_approach,
                   r_arm_tucked]

# Untuck trajctory
l_arm_untuck_traj = [l_arm_untucked]
r_arm_untuck_traj = [r_arm_approach,
                     r_arm_untucked]

# clear trajectory
l_arm_clear_traj = [l_arm_untucked]
r_arm_clear_traj = [r_arm_untucked]

class PR2TuckTest(RosTestCase):

  def setUpEnv(self):
        print("Adding a PR2 robot...")
        pr2 = BasePR2()
        pr2.add_interface('ros')

        env = Environment('empty', fastmode=True)
        env.set_camera_rotation([1.0470, 0, 0.7854])

  def test_tuck(self):

    rospy.init_node('test_pr2_tuck', log_level = rospy.DEBUG, disable_signals=True)

    # arm state: -1 unknown, 0 tucked, 1 untucked
    self.l_arm_state = -1
    self.r_arm_state = -1
    self.success = True

    # Get controller name and start joint trajectory action clients
    self.move_duration = 2.5
    r_action_name = 'r_arm_controller/joint_trajectory_action'
    l_action_name = 'l_arm_controller/joint_trajectory_action'

    self.left_joint_client = actionlib.SimpleActionClient(l_action_name, JointTrajectoryAction)
    self.right_joint_client = actionlib.SimpleActionClient(r_action_name, JointTrajectoryAction)

    # Connect to controller state
    rospy.Subscriber('l_arm_controller/state', JointTrajectoryControllerState ,self.stateCb)
    rospy.Subscriber('r_arm_controller/state', JointTrajectoryControllerState ,self.stateCb)


    self.assertTrue(self.left_joint_client.wait_for_server(rospy.Duration(5)))
    self.assertTrue(self.right_joint_client.wait_for_server(rospy.Duration(5)))



    self.assertEqual(self.l_arm_state, -1)
    self.assertEqual(self.r_arm_state, -1)

    self.tuckL()
    self.assertEqual(self.l_arm_state, 0)
    self.assertEqual(self.r_arm_state, 1)

    self.tuckR()
    self.assertEqual(self.l_arm_state, 0)
    self.assertEqual(self.r_arm_state, 0)

    self.untuckL()
    self.assertEqual(self.l_arm_state, 1)
    self.assertEqual(self.r_arm_state, -1)

    self.untuckR()
    self.assertEqual(self.l_arm_state, 1)
    self.assertEqual(self.r_arm_state, 1)

  # clears r arm and l arm
  def tuckL(self):
    if self.l_arm_state != 0:
      self.go('r', r_arm_up_traj)
      if self.l_arm_state != 1:
        self.go('l', l_arm_clear_traj)
      self.go('l', l_arm_tuck_traj)
      self.go('r', r_arm_clear_traj)
    
  # clears r arm
  def untuckL(self):
    if self.l_arm_state != 1:
      self.go('r', r_arm_up_traj)
      if self.l_arm_state == 0:
        self.go('l', l_arm_untuck_traj)
      elif self.l_arm_state == -1:
        self.go('l', l_arm_clear_traj)

  # assumes l tucked or cleared
  def tuckR(self):
    if self.r_arm_state != 0:
      self.go('r', r_arm_tuck_traj)

  # assumes l tucked or cleared
  def untuckR(self):
    if self.r_arm_state == 0:
      self.go('r', r_arm_untuck_traj)
    elif self.r_arm_state == -1:
      self.go('r', r_arm_clear_traj)

  def go(self, side, positions, wait = True):
    goal = JointTrajectoryGoal()
    goal.trajectory.joint_names = [side+"_"+name+"_joint" for name in joint_names]
    goal.trajectory.points = []
    for p, count in zip(positions, range(0,len(positions)+1)):
      goal.trajectory.points.append(JointTrajectoryPoint( positions = p,
                                                          velocities = [],
                                                          accelerations = [],
                                                          time_from_start = rospy.Duration((count+1) * self.move_duration)))
    goal.trajectory.header.stamp = rospy.get_rostime() + rospy.Duration(0.01)
    if wait:
      if not {'l': self.left_joint_client, 'r': self.right_joint_client}[side].send_goal_and_wait(goal, rospy.Duration(30.0), rospy.Duration(5.0)):
        self.success = False
    else:
      {'l': self.left_joint_client, 'r': self.right_joint_client}[side].send_goal(goal)


  # Returns angle between -pi and + pi
  def angleWrap(self, angle):
    while angle > math.pi:
      angle -= math.pi*2.0
    while angle < -math.pi:
      angle += math.pi*2.0
    return angle

  def stateCb(self, msg):
    l_sum_tucked = 0
    l_sum_untucked = 0
    r_sum_tucked = 0
    r_sum_untucked = 0
    for name_state, name_desi, value_state, value_l_tucked, value_l_untucked, value_r_tucked, value_r_untucked in zip(msg.joint_names, joint_names, msg.actual.positions , l_arm_tucked, l_arm_untucked, r_arm_tucked, r_arm_untucked):
      value_state = self.angleWrap(value_state)

      if 'l_'+name_desi+'_joint' == name_state:
        self.l_received = True
        l_sum_tucked = l_sum_tucked + math.fabs(value_state - value_l_tucked)
        l_sum_untucked = l_sum_untucked + math.fabs(value_state - value_l_untucked)
      if 'r_'+name_desi+'_joint' == name_state:
        self.r_received = True
        r_sum_tucked = r_sum_tucked + math.fabs(value_state - value_r_tucked)
        r_sum_untucked = r_sum_untucked + math.fabs(value_state - value_r_untucked)

    if l_sum_tucked > 0 and l_sum_tucked < 0.1:
      self.l_arm_state = 0
    elif l_sum_untucked > 0 and l_sum_untucked < 0.3:
      self.l_arm_state = 1
    elif l_sum_tucked >= 0.1 and l_sum_untucked >= 0.3:
      self.l_arm_state = -1    

    if r_sum_tucked > 0 and r_sum_tucked < 0.1:
      self.r_arm_state = 0
    elif r_sum_untucked > 0 and r_sum_untucked < 0.3:
      self.r_arm_state = 1
    elif r_sum_tucked >= 0.1 and r_sum_untucked >= 0.3:
      self.r_arm_state = -1    


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(PR2TuckTest)

########NEW FILE########
__FILENAME__ = rmax_velocity
#! /usr/bin/env python
"""
This script tests some of the base functionalities of MORSE.
"""

import sys
import math
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_speed(s, morse, v, w, t):
    s.publish({'v' : v, 'w' : w})
    morse.sleep(t)
    s.publish({'v' : 0.0, 'w' : 0.0})


class RMaxVelocity_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """

        robot = RMax()
        robot.translate(z = 10.0)

        pose = Pose()
        robot.append(pose)
        pose.add_stream('socket')

        motion = MotionVW()
        motion.properties(ControlType = 'Velocity')
        robot.append(motion)
        motion.add_stream('socket')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_vw_controller(self):
        with Morse() as simu:

            Z = 10.0

            precision=0.10
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = simu.robot.pose
            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp' and key != 'z':
                    self.assertAlmostEqual(coord, 0.0, delta=precision)


            v_w = simu.robot.motion

            send_speed(v_w, simu, 1.0, 0.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=precision)
            self.assertAlmostEqual(pose['y'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['z'], Z, delta=precision)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)

            send_speed(v_w, simu, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp' and key != 'z':
                    self.assertAlmostEqual(coord, 0.0, delta=precision)

            send_speed(v_w, simu, 1.0, -math.pi/4.0, 2.0)
            pose = pose_stream.get()

            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=precision)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=precision)
            self.assertAlmostEqual(pose['z'], Z, delta=precision)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)

            send_speed(v_w, simu, 0.5, -math.pi/8.0, 12.0)

            pose = pose_stream.get()
            for key, coord in pose.items():
                if key != 'timestamp' and key != 'z':
                    self.assertAlmostEqual(coord, 0.0, delta=precision)

            send_speed(v_w, simu, -2.0, math.pi/2.0, 3.0)
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.1)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.1)
            self.assertAlmostEqual(pose['z'], Z, delta=0.1)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.1)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.1)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.1)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(RMaxVelocity_Test)

########NEW FILE########
__FILENAME__ = reverse_vw
#! /usr/bin/env python
"""
This script tests the Segway RMP400 robot with differential drive actuator
"""

import sys
import socket
import json
import math
from time import sleep
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_speed(s, v, w, t):
    s.send(json.dumps({'v' : v, 'w' : w}).encode())
    sleep(t)
    s.send(json.dumps({'v' : 0.0, 'w' : 0.0}).encode())
    sleep(1)

def send_service_speed(s, v, w, t):
    s.rpc('MotionVWDiff', 'set_speed', v, w)
    sleep(t)
    s.rpc('MotionVWDiff', 'stop')
    sleep(1)

class Differential_VW_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = SegwayRMP400()
        robot.translate(z=0.1)
        robot.unparent_wheels()

        pose = Pose('Pose')
        robot.append(pose)
        pose.add_stream('socket')
        pose.add_stream('text')

        motion = MotionVWDiff('MotionVWDiff')
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_vw_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.stream('Pose')
            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.20, delta=0.03)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.03)

            # v_w socket
            port = morse.get_stream_port('MotionVWDiff')
            v_w_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            v_w_client.connect(('localhost', port))

            send_speed(v_w_client, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], -2.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.2, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_speed(v_w_client, 1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.20, delta=0.15)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)

            """
            send_speed(v_w_client, 0.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.10, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_speed(v_w_client, 0.0, math.pi/4.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.15)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)
            """


            send_speed(v_w_client, -1.0, math.pi/4.0, 2.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.2, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], math.pi/2.0, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)

            send_speed(v_w_client, -0.5, math.pi/8.0, 12.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.20, delta=0.15)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.20)

            send_speed(v_w_client, 2.0, -math.pi/2.0, 3.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.2, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)

    def X_test_vw_service_controller(self):
    #def test_vw_service_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.stream('Pose')
            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.20, delta=0.02)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.02)

            send_service_speed(morse, 1.0, 0.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.2, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_service_speed(morse, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.15)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)

            send_service_speed(morse, 1.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            print ("POSE RECEIVED: %s" % pose)
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.15)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.2, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Differential_VW_Test)

########NEW FILE########
__FILENAME__ = rotated_segway
#! /usr/bin/env python
"""
This script tests the Segway RMP400 robot with differential drive actuator
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def gradual_speed(s, morse, v, w, t):
    """ Start and finish applying only half of the desired speed """
    tic = t/20.0
    s.publish({'v' : v/4, 'w' : w/4})
    morse.sleep(tic*2)
    s.publish({'v' : v/2, 'w' : w/2})
    morse.sleep(tic*1)
    s.publish({'v' : v, 'w' : w})
    morse.sleep(tic*18)
    s.publish({'v' : v/2, 'w' : w/2})
    morse.sleep(tic*2)
    s.publish({'v' : v/4, 'w' : w/4})
    morse.sleep(tic*2)
    s.publish({'v' : 0.0, 'w' : 0.0})


def send_speed(s, morse, v, w, t):
    #s.publish({'v' : v, 'w' : w})
    #morse.sleep(t)
    #s.publish({'v' : 0.0, 'w' : 0.0})
    gradual_speed(s, morse, v, w, t)
    morse.sleep(1)

def send_service_speed(s, morse, v, w, t):
    s.set_speed(v, w)
    morse.sleep(t)
    s.stop()
    morse.sleep(1)

class Rotated_Segway_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = SegwayRMP400()
        robot.translate(z=0.1)
        robot.rotate(z=math.pi/2)

        pose = Pose()
        robot.append(pose)
        pose.translate(z=-0.1)
        pose.add_stream('socket')

        motion = MotionVWDiff()
        robot.append(motion)
        motion.add_stream('socket')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_vw_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.robot.pose
            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.03)
                elif key == 'yaw':
                    self.assertAlmostEqual(coord, math.pi/2, delta=0.03)
                elif key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.03)

            v_w = morse.robot.motion

            send_speed(v_w, morse, 1.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.75, delta=0.15)
            self.assertAlmostEqual(pose['y'], 1.75, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], 0.75, delta=0.15)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Rotated_Segway_Test)

########NEW FILE########
__FILENAME__ = segway_vw
#! /usr/bin/env python
"""
This script tests the Segway RMP400 robot with differential drive actuator
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def gradual_speed(s, morse, v, w, t):
    """ Start and finish applying only half of the desired speed """
    tic = t/20.0
    s.publish({'v' : v/4, 'w' : w/4})
    morse.sleep(tic*2)
    s.publish({'v' : v/2, 'w' : w/2})
    morse.sleep(tic*1)
    s.publish({'v' : v, 'w' : w})
    morse.sleep(tic*18)
    s.publish({'v' : v/2, 'w' : w/2})
    morse.sleep(tic*2)
    s.publish({'v' : v/4, 'w' : w/4})
    morse.sleep(tic*2)
    s.publish({'v' : 0.0, 'w' : 0.0})


def send_speed(s, morse, v, w, t):
    #s.publish({'v' : v, 'w' : w})
    #morse.sleep(t)
    #s.publish({'v' : 0.0, 'w' : 0.0})
    gradual_speed(s, morse, v, w, t)
    morse.sleep(1)

def send_service_speed(s, morse, v, w, t):
    s.set_speed(v, w)
    morse.sleep(t)
    s.stop()
    morse.sleep(1)

class Differential_VW_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = SegwayRMP400()
        robot.translate(z=0.1)

        pose = Pose()
        robot.append(pose)
        pose.translate(z=-0.1)
        pose.add_stream('socket')
        pose.add_stream('text')

        motion = MotionVWDiff()
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_vw_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.robot.pose
            pose = pose_stream.get()
            for key,coord in pose.items():
                    if key == 'z':
                        self.assertAlmostEqual(coord, 0.10, delta=0.03)
                    elif key != 'timestamp':
                        self.assertAlmostEqual(coord, 0.0, delta=0.03)

            v_w = morse.robot.motion

            send_speed(v_w, morse, 1.0, 0.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_speed(v_w, morse, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.15)
                elif key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)

            """
            send_speed(v_w, morse, 0.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.10, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_speed(v_w, morse, 0.0, math.pi/4.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.15)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)
            """


            send_speed(v_w, morse, 1.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)

            send_speed(v_w, morse, 0.5, -math.pi/8.0, 12.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.15)
                elif key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.20)

            """
            # The robot slips too much to expect a precise position.
            # However, the behaviour seems reasonnable considering its
            # real-life behaviour. 

            send_speed(v_w, morse, -2.0, math.pi/2.0, 3.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)
            """

    def test_vw_service_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.robot.pose
            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.02)
                elif key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.02)

            v_w = morse.robot.motion

            send_service_speed(v_w, morse, 1.0, 0.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_service_speed(v_w, morse, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.15)
                elif key != 'timestamp':
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)

            send_service_speed(v_w, morse, 1.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.2)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.2)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Differential_VW_Test)

########NEW FILE########
__FILENAME__ = spiral
#! /usr/bin/env python
"""
This script tests the Segway RMP400 robot with differential drive actuator
"""

import sys
import socket
import json
import math
from time import sleep
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def gradual_speed(s, v, w, t):
    """ Start and finish applying only half of the desired speed """
    tic = t/20.0
    s.send(json.dumps({'v' : v/4, 'w' : w/4}).encode())
    sleep(tic*2)
    s.send(json.dumps({'v' : v/2, 'w' : w/2}).encode())
    sleep(tic*1)
    s.send(json.dumps({'v' : v, 'w' : w}).encode())
    sleep(tic*18)
    s.send(json.dumps({'v' : v/2, 'w' : w/2}).encode())
    sleep(tic*2)
    s.send(json.dumps({'v' : v/4, 'w' : w/4}).encode())
    sleep(tic*2)
    s.send(json.dumps({'v' : 0.0, 'w' : 0.0}).encode())

def send_speed(s, v, w, t):
    #s.send(json.dumps({'v' : v, 'w' : w}).encode())
    #sleep(t)
    #s.send(json.dumps({'v' : 0.0, 'w' : 0.0}).encode())
    gradual_speed(s, v, w, t)
    sleep(1)

def send_service_speed(s, v, w, t):
    s.rpc('MotionVWDiff', 'set_speed', v, w)
    sleep(t)
    s.rpc('MotionVWDiff', 'stop')
    sleep(1)

class Differential_VW_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = SegwayRMP400()
        robot.properties(FixTurningSpeed=1.3)
        robot.translate(z=0.1)
        robot.unparent_wheels()

        pose = Pose('Pose')
        robot.append(pose)
        pose.add_stream('socket')
        pose.add_stream('text')

        motion = MotionVWDiff('MotionVWDiff')
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_vw_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.stream('Pose')
            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.20, delta=0.03)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.03)

            # v_w socket
            port = morse.get_stream_port('MotionVWDiff')
            v_w_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            v_w_client.connect(('localhost', port))

            #send_speed(v_w_client, 0.0, -math.pi/4.0, 2.0)

            #pose = pose_stream.get()
            ## for non-null w, we have r = v /  w
            #self.assertAlmostEqual(pose['x'], 0.0, delta=0.15)
            #self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            #self.assertAlmostEqual(pose['z'], 0.10, delta=0.15)
            #self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.15)
            #self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            #self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            #send_speed(v_w_client, 0.0, math.pi/4.0, 2.0)

            #pose = pose_stream.get()
            #for key,coord in pose.items():
            #    if key == 'z':
            #        self.assertAlmostEqual(coord, 0.10, delta=0.15)
            #    else:
            #        self.assertAlmostEqual(coord, 0.0, delta=0.15)

            # PART ONE

            send_speed(v_w_client, 0.5, -math.pi/8.0, 4.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.2, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)

            # PART TWO
           
            send_speed(v_w_client, 0.5, -math.pi/16.0, 8.0)

            """
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -8.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], -math.pi, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)
            """

            send_speed(v_w_client, 0.5, -math.pi/32.0, 16.0)

            """
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], math.pi/2.0, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)
            """

    def X_test_vw_service_controller(self):
    #def test_vw_service_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.stream('Pose')
            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.20, delta=0.02)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.02)

            send_service_speed(morse, 1.0, 0.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_service_speed(morse, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.15)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)

            send_service_speed(morse, 1.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            print ("POSE RECEIVED: %s" % pose)
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.15)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Differential_VW_Test)

########NEW FILE########
__FILENAME__ = spiral_dala
#! /usr/bin/env python
"""
This script tests the Dala robot with a v, omega actuator doing a spiral motion
"""

import sys
import socket
import json
import math
from time import sleep
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def send_speed(s, v, w, t):
    s.send(json.dumps({'v' : v, 'w' : w}).encode())
    sleep(t)
    s.send(json.dumps({'v' : 0.0, 'w' : 0.0}).encode())
    sleep(1)

def send_service_speed(s, v, w, t):
    s.rpc('MotionVW', 'set_speed', v, w)
    sleep(t)
    s.rpc('MotionVW', 'stop')
    sleep(1)

class Spiral_Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """
        
        robot = ATRV()
        robot.translate(z=0.1)

        pose = Pose('Pose')
        robot.append(pose)
        pose.add_stream('socket')
        pose.add_stream('text')

        motion = MotionVW('MotionVW')
        robot.append(motion)
        motion.add_stream('socket')
        motion.add_service('socket')
        
        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_vw_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.stream('Pose')
            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.1, delta=0.03)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.03)

            # v_w socket
            port = morse.get_stream_port('MotionVW')
            v_w_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            v_w_client.connect(('localhost', port))

            send_speed(v_w_client, 0.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.1, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_speed(v_w_client, 0.0, math.pi/4.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.1, delta=0.15)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)

            # PART ONE

            send_speed(v_w_client, 0.5, -math.pi/8.0, 4.0)

            pose = pose_stream.get()
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)

            # PART TWO
           
            send_speed(v_w_client, 0.5, -math.pi/16.0, 8.0)

            """
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 0.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -8.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], -math.pi, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)
            """

            send_speed(v_w_client, 0.5, -math.pi/32.0, 16.0)

            """
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.20)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['yaw'], math.pi/2.0, delta=0.20)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.20)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.20)
            """

    def X_test_vw_service_controller(self):
    #def test_vw_service_controller(self):
        with Morse() as morse:
        
            # Read the start position, it must be (0.0, 0.0, 0.0)
            pose_stream = morse.stream('Pose')
            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.02)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.02)

            send_service_speed(morse, 1.0, 0.0, 2.0)

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['x'], 2.0, delta=0.15)
            self.assertAlmostEqual(pose['y'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

            send_service_speed(morse, -1.0, 0.0, 2.0)

            pose = pose_stream.get()
            for key,coord in pose.items():
                if key == 'z':
                    self.assertAlmostEqual(coord, 0.10, delta=0.15)
                else:
                    self.assertAlmostEqual(coord, 0.0, delta=0.15)

            send_service_speed(morse, 1.0, -math.pi/4.0, 2.0)

            pose = pose_stream.get()
            print ("POSE RECEIVED: %s" % pose)
            # for non-null w, we have r = v /  w
            self.assertAlmostEqual(pose['x'], 4.0/ math.pi , delta=0.15)
            self.assertAlmostEqual(pose['y'], -4.0/ math.pi , delta=0.15)
            self.assertAlmostEqual(pose['z'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['yaw'], -math.pi/2.0, delta=0.15)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=0.15)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=0.15)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(Spiral_Test)

########NEW FILE########
__FILENAME__ = two_segways
#! /usr/bin/env python
"""
This script tests the Segway RMP400 robot with differential drive actuator
"""

import sys
from morse.testing.testing import MorseTestCase
from pymorse import Morse

# Include this import to be able to use your test file as a regular 
# builder script, ie, usable with: 'morse [run|exec] base_testing.py
try:
    from morse.builder import *
except ImportError:
    pass

def set_speed(s, morse, v, w, t):
    s.set_speed(v, w)
    morse.sleep(t)
    s.stop()
    morse.sleep(1)

class TwoRMP400Test(MorseTestCase):
    def setUpEnv(self):
        """ Defines the test scenario, using the Builder API.
        """

        robot1 = SegwayRMP400()
        pose1 = Pose()
        robot1.append(pose1)
        pose1.translate(z=-0.1)
        motion1 = MotionVWDiff()
        robot1.append(motion1)
        robot1.add_default_interface('socket')


        robot2 = SegwayRMP400()
        robot2.translate(y=1.0)
        pose2 = Pose()
        robot2.append(pose2)
        pose2.translate(z=-0.1)
        motion2 = MotionVWDiff()
        robot2.append(motion2)
        robot2.add_default_interface('socket')

        env = Environment('empty', fastmode = True)
        env.add_service('socket')

    def test_motion(self):
        """ Tests that 2 Segway RMP400 in the same scene move
        as expected (as if they were alone).
        This tests the particular wheel parenting mechanism used on
        this robot when several instance are present.
        """
        with Morse() as morse:

            pose1_stream = morse.robot1.pose1
            pose2_stream = morse.robot2.pose2

            pose1_x = pose1_stream.get()['x']
            self.assertAlmostEqual(pose1_x, 0.0, delta=0.03)

            pose2_x = pose2_stream.get()['x']
            self.assertAlmostEqual(pose2_x, 0.0, delta=0.03)

            set_speed(morse.robot1.motion1, morse, 1.0, 0.0, 2.0)
            set_speed(morse.robot2.motion2, morse, 1.0, 0.0, 2.0)

            pose1_x = pose1_stream.get()['x']
            self.assertAlmostEqual(pose1_x, 2.0, delta=0.10)

            pose2_x = pose2_stream.get()['x']
            self.assertAlmostEqual(pose2_x, 2.0, delta=0.10)

########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(TwoRMP400Test)

########NEW FILE########
__FILENAME__ = submarine_testing
#! /usr/bin/env python
"""
This script tests the 'data stream' oriented feature of the socket interface.
"""

from morse.testing.testing import MorseTestCase

try:
    # Include this import to be able to use your test file as a regular 
    # builder script, ie, usable with: 'morse [run|exec] <your test>.py
    from morse.builder import *
except ImportError:
    pass

import os
import sys
import math
from pymorse import Morse

def send_goal(s, x, y, z):
    s.publish({'x' : x, 'y' : y, 'z' : z})

class DestinationTest(MorseTestCase):

    def setUpEnv(self):
        
        robot = Submarine()
        robot.translate(0.0, 200.0, -20.0)
        
        pose = Pose()
        pose.add_stream('socket')
        robot.append(pose)

        destination = Destination('destination')
        robot.append(destination)
        destination.add_stream('socket')
        destination.properties(Speed=2.0, Tolerance=0.3)

        env = Environment('water-1/deep_water', fastmode = True)
        
        water = bpymorse.get_object('Water')
        water.scale = [600.0, 600.0, 0.0]
        env.set_camera_clip(clip_end=1000)
        env.set_camera_location([60,150,150])
        env.set_camera_rotation([.2,0,0])

    def test(self):
        with Morse() as morse:
            pose_stream = morse.robot.pose

            pose = pose_stream.get()
            precision = 0.02
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['y'], 200.0, delta=precision)
            self.assertAlmostEqual(pose['z'], -20.0, delta=0.1)

            dest_client = morse.robot.destination
            send_goal(dest_client, 10.0, 200.0, -20.0)

            morse.sleep(3.0)
            # Only x has changed. Check that speed is respected

            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], 3.0 * 2.0, delta=0.1)
            self.assertAlmostEqual(pose['y'], 200.0, delta=precision)
            self.assertAlmostEqual(pose['z'], -20.0, delta=0.1)

            morse.sleep(2.0)
            # Only x has changed
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], 9.7, delta=0.1)
            self.assertAlmostEqual(pose['y'], 200.0, delta=precision)
            self.assertAlmostEqual(pose['z'], -20.0, delta=0.1)

            x = pose['x']
            send_goal(dest_client, x, 210.0, -20.0)
            morse.sleep(5.0)

            # Only Y has changed
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], x, delta=0.1)
            self.assertAlmostEqual(pose['y'], 209.7, delta=0.1)
            self.assertAlmostEqual(pose['z'], -20.0, delta=0.1)


            x = pose['x']
            y = pose['y']
            z = pose['z']

            send_goal(dest_client, x, y, -30.0)
            morse.sleep(5.0)

            # Only Z has changed
            # XXX precision is not really good
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['x'], x, delta=precision)
            self.assertAlmostEqual(pose['y'], y, delta=precision)
            self.assertAlmostEqual(pose['z'], -30.0, delta=0.3)

            send_goal(dest_client, 0, 200, -20)
            morse.sleep(10.0)
            pose = pose_stream.get()
            self.assertAlmostEqual(pose['yaw'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['pitch'], 0.0, delta=precision)
            self.assertAlmostEqual(pose['roll'], 0.0, delta=precision)
            self.assertTrue(math.fabs(pose['x']) < 0.3)
            self.assertTrue(math.fabs(pose['y'] -200) < 0.3)
            self.assertTrue(math.fabs(pose['z'] + 20) < 0.3)


########################## Run these tests ##########################
if __name__ == "__main__":
    from morse.testing.testing import main
    main(DestinationTest)

########NEW FILE########
__FILENAME__ = components_exhibit
import os
import sys
import pkgutil
import inspect
import subprocess

try:
    import bpy # Blender
except ImportError:
    print("Could not import bpy, run with Blender\n"
          "blender -P components_exhibit.py")
    sys.exit(-1)
from mathutils import Euler

def ext_exec(cmd, python=None):
    if not python:
        python = 'python%i.%i'%(sys.version_info.major, sys.version_info.minor)
    return subprocess.getoutput('%s -c"%s"' % (python, cmd) )

def fix_python_path(python=None):
    pythonpath = ext_exec("import os,sys;print(os.pathsep.join(sys.path))")
    sys.path.extend(pythonpath.split(os.pathsep))

fix_python_path()
try:
    import morse # MORSE
except ImportError:
    raise ImportError("Could not import morse, set your PYTHONPATH\n"
        'export PYTHONPATH="/usr/local/lib/python3.3/site-packages/:$PYTHONPATH"')
from morse.builder import *

#
# helpers
#

def get_classes_from_module(module_name):
    __import__(module_name)
    # Predicate to make sure the classes only come from the module in question
    def predicate(member):
        return inspect.isclass(member) and member.__module__.startswith(module_name)
    # fetch all members of module name matching 'pred'
    return inspect.getmembers(sys.modules[module_name], predicate)

def get_submodules(module_name):
    """ Get a list of submodules from a module name.
    Not recursive, don't return nor look in subpackages """
    __import__(module_name)
    module = sys.modules[module_name]
    module_path = getattr(module, '__path__')
    return [name for _, name, ispkg in pkgutil.iter_modules(module_path) if not ispkg]

def get_subclasses(module_name, skip_submodules=[]):
    subclasses = []
    submodules = get_submodules(module_name)
    for submodule_name in submodules:
        if submodule_name in skip_submodules:
            pass
        submodule = "%s.%s"%(module_name, submodule_name)
        try:
            submodule_classes = get_classes_from_module(submodule)
            for _, klass in submodule_classes:
                subclasses.append(klass)
        except Exception:
            # can not import some resources
            pass
    return subclasses

modules = [
    "morse.builder.sensors",
    "morse.builder.actuators",
    "morse.builder.robots",
]

specific_camera_pose_per_component = {
    # Robots
    'BasePR2': (.36, -2.25, 1.77),
    'Morsy': (3.84, -3.12, 2.12, 1.32, 0.0, 0.86),
    'SegwayRMP400': (.36, -2.25, 1.77),
    'ATRV': (.36, -2.25, 1.77),
    'Human': (4, 0, 2.8), # 65,0,90
    'Hummer': (.36, -2.25, 1.77),
    'Jido': (.36, -2.25, 1.77),
    'B21': (.36, -2.25, 1.77),
    'RMax': (.36, -2.25, 1.77),
    'Submarine': (.36, -2.25, 1.77),
    'Vicitm': (.36, -2.25, 1.77),
    'NavPR2': (.36, -2.25, 1.77),
    'QUAD2012': (.36, -1.25, .77),
    'Quadrotor': (.36, -1.25, .77),
    'Pioneer3DX': (.36, -1.25, .77),
    # Sensors
    'Accelerometer': (.36, -1.25, .77),
    'Battery': (.36, -1.25, .77),
    'DepthCamera': (.36, -1.25, .77),
    'GPS': (.36, -1.25, .77),
    'Gyroscope': (.36, -1.25, .77),
    'Hokuyo': (.36, -1.25, .77),
    'IMU': (.36, -1.25, .77),
    'Infrared': (.36, -1.25, .77),
    'Kinect': (.36, -1.25, .77),
    'Odometry': (.36, -1.25, .77),
    'Pose': (.36, -1.25, .77),
    'Proximity': (.36, -1.25, .77),
    'SearchAndRescue': (.36, -1.25, .77),
    'SemanticCamera': (.36, -1.25, .77),
    'Sick': (.36, -1.25, .77),
    'SickLDMRS': (.36, -1.25, .77),
    'StereoUnit': (.36, -1.25, .77),
    'Thermometer': (.36, -1.25, .77),
    'VideoCamera': (.36, -1.25, .77),
    'Velodyne': (.36, -1.25, .77),
    # Actuators
    'PTU': (.36, -1.25, .77),
    'PA10': (.36, -2.25, 1.77),
    'KukaLWR': (.36, -2.25, 1.77),
    'Gripper': (.36, -1.25, .77),
}

def pose_camera(location = (.36, -1.25, .77), rotation = (1.1, 0, 0.25)):
    if len(location) == 6:
        rotation = location[3:]
        location = location[:3]
    scene = bpy.context.scene
    scene.camera.rotation_euler = Euler(rotation, 'XYZ')
    scene.camera.location = location

def setup_scene():
    scene = bpy.context.scene
    if 'Cube' in bpy.data.objects:
        bpymorse.delete('Cube')
    # Set the scene's camera
    scene.camera = bpy.data.objects['Camera']
    # Set the scene's output file format
    scene.render.image_settings.file_format = 'PNG'
    # RGBA, Images are saved with RGB and Alpha data (if supported).
    scene.render.image_settings.color_mode = 'RGBA'
    if bpy.app.version < (2, 66, 0):
        # Premultiplied, Transparent RGB pixels are multiplied by the alpha channel.
        scene.render.alpha_mode = 'PREMUL'
    else:
        # Transparent, World background is transparent with premultiplied alpha.
        scene.render.alpha_mode = 'TRANSPARENT'
    # Move the default Lamp
    bpy.data.objects['Lamp'].location = (-2, 3, 6)
    if len(bpy.data.lamps) < 3:
        # Add new lamp point
        bpy.ops.object.lamp_add(type='POINT', location=(5, 2, 1))
        bpy.data.lamps[-1].energy = 0.6
        bpy.ops.object.lamp_add(type='POINT', location=(-4, 3, 4))
        bpy.data.lamps[-1].energy = 0.4
    # Move the default Camera
    pose_camera()

def render_component(klass, save_path):
    scene = bpy.context.scene
    class_name = klass.__name__
    if class_name in specific_camera_pose_per_component:
        pose_camera(specific_camera_pose_per_component[class_name])
    else:
        print("#### class not in dict: %s"%str(class_name))
        pose_camera()
    origin_objects = [obj.name for obj in bpy.data.objects]
    try:
        # load class
        component = klass()
        # Refresh the view
        bpy.ops.wm.redraw_timer(type='DRAW_WIN_SWAP', iterations=1)
        # Render the scene
        scene.render.filepath = os.path.join(save_path, klass.__name__ + ".png")
        bpy.ops.render.render(write_still=True)
    except Exception as e:
        print("[ERROR] Could not load %s.\nSet MORSE_ROOT to the prefix " \
              "used to install MORSE.\n%s"% (str(klass), str(e) ) )
    finally:
        # Remove the inserted objects
        bpymorse.delete([obj for obj in bpy.data.objects \
                         if obj.name not in origin_objects])

def main():
    """ Generate "studio" image of MORSE components

    HOWTO

    export PYTHONPATH="/usr/local/lib/python3.3/site-packages/:$PYTHONPATH"
    blender -P components_exhibit.py

    Et voila!
    """
    print ("==== PHOTO STUDIO FOR MORSE COMPONENTS ====\n\n")
    save_path = "//morse_renders"
    scene = bpy.context.scene
    print('Using Scene[%s]'%scene.name)
    setup_scene()

    # browse morse components modules
    for module in modules:
        print("browse %s classes"%module)
        for _, klass in get_classes_from_module(module):
            print("process %s"%str(klass))
            if issubclass(klass, AbstractComponent):
                try:
                    render_component(klass, save_path)
                except Exception as e:
                    print("[ERROR] Could not render %s : %s"%(str(klass), str(e)))
            else:
                print("[ERROR] Not a Component : %s"%str(klass))

            print("\n\n")

    print ("DONE!")


if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = hybrid_node
import json
import socket
import logging
import asynchat
import asyncore
import threading
# Double-ended queue, thread-safe append/pop.
from collections import deque
# initialize the logger
logger = logging.getLogger(__name__)
handler = logging.StreamHandler()
handler.setFormatter( logging.Formatter('[%(asctime)s][%(name)s][%(levelname)s] %(message)s') )
logger.addHandler( handler )
logger.setLevel(logging.INFO)
from lxml import etree

MSG_SEPARATOR=b"\n"

#
# XXX StreamJSON should be extern
#

class StreamB(asynchat.async_chat):
    """ Asynchrone I/O stream handler (raw bytes)

    To start the handler, just run :meth asyncore.loop: in a new thread::

    threading.Thread( target = asyncore.loop, kwargs = {'timeout': .1} ).start()

    where timeout is used with select.select / select.poll.poll.
    """

    use_encoding = 0 # Python2 compat.

    def __init__(self, host='localhost', port='1234', maxlen=100, sock=None):
        self.error = False
        if not sock:
            sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
            sock.connect( (host, port) )
        self._in_buffer  = b""
        self._in_queue   = deque([], maxlen)
        self._callbacks  = []
        self._cv_new_msg = threading.Condition()
        # init asynchat after connect and setting all locals avoids EBADF
        # and others undesirable effects of the asyncore.loop thread.
        asynchat.async_chat.__init__(self, sock=sock)
        self.set_terminator(MSG_SEPARATOR)

    def is_up(self):
        """
        self.connecting has been introduced lately in several branches
        of python (see issue #10340 of Python). In particular, it is not
        present in the python 3.2.3 interpreter delivered in Ubuntu 12.04.
        On this platform, just test of self.connected. There is still
        possibly a little race  but it mitigate the issue.
        """
        if hasattr(self, 'connecting'):
            return self.connecting or self.connected
        else:
            return self.connected

    def subscribe(self, callback):
        self._callbacks.append(callback)

    def unsubscribe(self, callback):
        self._callbacks.remove(callback)

    def handle_error(self):
        self.error = True
        self.handle_close()

    #### IN ####
    def collect_incoming_data(self, data):
        """Buffer the data"""
        self._in_buffer += data

    def found_terminator(self):
        self.handle_msg(self._in_buffer)
        self._in_buffer = b""

    def handle_msg(self, msg):
        """ append new raw :param msg: in the input queue

        and call subscribed callback methods if any
        """
        with self._cv_new_msg:
            self._in_queue.append(msg)
            self._cv_new_msg.notify_all()
        # handle callback(s)
        decoded_msg = None
        for callback in self._callbacks:
            if not decoded_msg:
                decoded_msg = self.decode( msg )
            callback( decoded_msg )

    def _msg_available(self):
        return bool(self._in_queue)

    def _get_last_msg(self):
        return self.decode( self._in_queue[-1] )

    # TODO implement last n msg decode and msg_queue with hash(msg) -> decoded msg
    def last(self, n=1):
        """ get the last message recieved

        :returns: decoded message or None if no message available
        """
        with self._cv_new_msg:
            if self._msg_available():
                return self._get_last_msg()
        logger.debug("last: no message in queue")
        return None

    def get(self, timeout=None):
        """ wait :param timeout: for a new messge

        When the timeout argument is present and not None, it should be a
        floating point number specifying a timeout for the operation in seconds
        (or fractions thereof).

        :returns: decoded message or None in case of timeout
        """
        with self._cv_new_msg:
            if self._cv_new_msg.wait(timeout):
                return self._get_last_msg()
        logger.debug("get: timed out")
        return None

    #### OUT ####
    def publish(self, msg):
        """ encode :param msg: and append the resulting bytes to the output queue """
        self.push(self.encode( msg ))

    #### patch code from asynchat, ``del deque[0]`` is not safe #####
    def initiate_send(self):
        while self.producer_fifo and self.connected:
            first = self.producer_fifo.popleft()
            # handle empty string/buffer or None entry
            if not first:
                if first is None:
                    self.handle_close()
                    return

            # handle classic producer behavior
            obs = self.ac_out_buffer_size
            try:
                data = first[:obs]
            except TypeError:
                data = first.more()
                if data:
                    self.producer_fifo.extendleft([first, data])
                continue

            if isinstance(data, str) and self.use_encoding:
                data = bytes(data, self.encoding)

            # send the data
            try:
                num_sent = self.send(data)
            except socket.error:
                self.handle_error()
                return

            if num_sent:
                if num_sent < len(data) or obs < len(first):
                    self.producer_fifo.appendleft(first[num_sent:])
            # we tried to send some actual data
            return

    #### CODEC ####
    def decode(self, msg_bytes):
        """ returns message as is (raw bytes) """
        return msg_bytes

    def encode(self, msg_bytes):
        """ returns message as is (raw bytes) plus the MSG_SEPARATOR """
        return msg_bytes + MSG_SEPARATOR


class Stream(StreamB):
    """ String Stream """
    def __init__(self, host='localhost', port='1234', maxlen=100, sock=None):
        StreamB.__init__(self, host, port, maxlen, sock)

    #### CODEC ####
    def decode(self, msg_bytes):
        """ decode bytes to string """
        return msg_bytes.decode()

    def encode(self, msg_str):
        """ encode string to bytes """
        return StreamB.encode(self, msg_str.encode())


class StreamJSON(Stream):
    """ JSON Stream """
    def __init__(self, host='localhost', port='1234', maxlen=100, sock=None):
        Stream.__init__(self, host, port, maxlen, sock)

    def decode(self, msg_bytes):
        """ decode bytes to json object """
        return json.loads(Stream.decode(self, msg_bytes))

    def encode(self, msg_obj):
        """ encode object to json string and then bytes """
        return Stream.encode(self, json.dumps(msg_obj))


#
# Real stuff starts here
#


robot_picoweb = {
    'mana'  : 'http://140.93.16.55:8080',
    'minnie': 'http://140.93.16.57:8080',
    #'mana'  : 'http://mana-superbase:8080',
    #'minnie': 'http://minnie-base:8080',
    #'target': 'http://chrome-dreams:8080/GPS?get=MEPos',
}

class Picoweb(object):
    def __init__(self, picoweb = "http://mana-superbase:8080"):
        self.picoweb = picoweb
        self.result = {
            'x': 0.0,
            'y': 0.0,
            'z': 0.0,
            'yaw':   0.0,
            'pitch': 0.0,
            'roll':  0.0,
        }
    def update(self):
        # get XML file from the robot's picoweb http server
        pom = etree.parse("%s/pom?get=Pos"%self.picoweb)
        # get the robot position in XML
        euler = pom.xpath("/pom/Pos/data/pomPos/mainToOrigin/euler").pop()
        def getf(key):
            return float(euler.xpath(key).pop().text)
        for key in self.result.keys():
            self.result[key] = getf(key)
        # return [(location), (rotation)] in XYZ, XYZ Euler
        return [ (self.result['x'], self.result['y'], self.result['z']), \
                 (self.result['roll'], self.result['pitch'], self.result['yaw']) ]

class HybridNode(object):
    """ Class definition for synchronisation of real robots with the MORSE simulator

    This component allows hybrid simulation, where the position of real robots
    is reflected in the simulator. Implemented using the socket multinode
    mechanism. The real robots are considered to be running in a node called
    "REAL", which reports the new positions to the multinode_server.
    """

    out_data = {}

    def __init__(self, host='localhost', port=65000):
        """ Create the socket that will be used to commmunicate to the server. """
        self.node_stream = None
        logger.debug("Connecting to %s:%d" % (host, port) )
        try:
            self.node_stream = StreamJSON(host, port)
            self.async_thread = threading.Thread( target = asyncore.loop, kwargs = {'timeout': .1} )
            self.async_thread.start()
            if self.node_stream.connected:
                logger.info("Connected to %s:%s" % (host, port) )
        except Exception as e:
            logger.info("Multi-node simulation not available!")
            logger.warning("Unable to connect to %s:%s"%(host, port) )
            logger.info(str(e))
        self.robots = {name: Picoweb(robot_picoweb[name]) for name in robot_picoweb.keys()}

    def _exchange_data(self):
        """ Send and receive pickled data through a socket """
        # Use the existing socket connection
        self.node_stream.publish(['hybrid', self.out_data])
        # Wait 1ms for incomming data or return the last one recieved
        return self.node_stream.get(timeout=.001) or self.node_stream.last()

    def synchronize(self):
        if not self.node_stream:
            logger.debug("not self.node_stream")
            return
        if not self.node_stream.connected:
            logger.debug("not self.node_stream.connected")
            return

        # Get the coordinates of local robots
        for robot,picow in self.robots.items():
            try:
                self.out_data[robot] = picow.update()
                logger.info(repr(self.out_data))
            except Exception as e:
                logger.error(str(e))

        # Send the encoded dictionary through a socket
        #  and receive a reply with any changes in the other nodes
        in_data = self._exchange_data()
        logger.debug("Received: %s" % repr(in_data))

    def __del__(self):
        """ Close the communication socket. """
        self.node_stream.close()
        # asyncore.close_all() # make sure all connection are closed
        self.async_thread.join(timeout=1)


def main(argv):
    if '-d' in argv[1:]:
        logger.setLevel(logging.DEBUG)

    logger.debug("Hybrid node started...")
    hn = HybridNode()

    try:
        while 1:
            hn.synchronize()
    except KeyboardInterrupt:
        logger.info("Quit (Ctrl+C)")
    finally:
        del hn
        logger.info("Closing all connections")
        asyncore.close_all()

    logger.info("Bye!")
    return 0

if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))

########NEW FILE########
__FILENAME__ = io_export_morse
#--- ### Header
bl_info = {
    "name": "MORSE scene as Python API (.py)",
    "author": "Gilberto Echeverria",
    "version": (1, 0, 0),
    "blender": (2, 5, 9),
    "api": 36147,
    "location": "File>Import-Export",
    "category": "Import-Export",
    "description": "Save a MORSE scene as a Python description",
    "warning": "",
    "wiki_url": "",
    "tracker_url": "https://softs.laas.fr/bugzilla/"
}

import os
import bpy
import json
import re
from morse.builder.data import *
from bpy.utils import register_module, unregister_module

"""
Morse API to save scene files

To test this module you can open this file inside a Text panel in Blender,
then run the script.
This will generate a python file in the same directory where Blender was first executed.
"""

morse_types = {
    "robots": "Robot",
    "sensors": "Sensor",
    "actuators": "Actuator",
    "middleware": "Middleware",
    "modifiers": "Modifier",
}

def save_translation(obj, obj_name):
    # Set its position
    position_string = ''
    text_buffer = ''
    component_position = obj.location
    if component_position[0] != 0:
        position_string += 'x=%.4f' % component_position[0]
    if component_position[1] != 0:
        if position_string != '':
            position_string += ', '
        position_string += 'y=%.4f' % component_position[1]
    if component_position[2] != 0:
        if position_string != '':
            position_string += ', '
        position_string += 'z=%.4f' % component_position[2]
    # Register a translation only if necessary
    if position_string != '':
        text_buffer += "%s.translate(%s)\n" % (obj_name, position_string)

    return (text_buffer)


def save_rotation(obj, obj_name):
    # Set its rotation
    rotation_string = ''
    text_buffer = ''
    component_rotation = obj.rotation_euler
    if component_rotation[0] != 0:
        rotation_string += 'x=%.4f' % component_rotation[0]
    if component_rotation[1] != 0:
        if rotation_string != '':
            rotation_string += ', '
        rotation_string += 'y=%.4f' % component_rotation[1]
    if component_rotation[2] != 0:
        if rotation_string != '':
            rotation_string += ', '
        rotation_string += 'z=%.4f' % component_rotation[2]
    # Register a translation only if necessary
    if rotation_string != '':
        text_buffer += "%s.rotate(%s)\n" % (obj_name, rotation_string)

    return (text_buffer)


def save_properties(obj, obj_name):
    text_buffer = ''
    # Store the properties of the component
    for key,prop in obj.game.properties.items():
        if key not in ['Robot_Tag', 'Component_Tag', 'Middleware_Tag', 'Modifier_Tag', 'Class', 'Path']:
            if prop.value != '':
                if prop.type == 'STRING':
                    text_buffer += "%s.properties(%s = '%s')\n" % (obj_name, key, prop.value)
                elif prop.type == 'FLOAT' or prop.type == 'TIMER':
                    text_buffer += "%s.properties(%s = %.4f)\n" % (obj_name, key, prop.value)
                else:
                    text_buffer += "%s.properties(%s = %s)\n" % (obj_name, key, prop.value)

    return (text_buffer)


def scan_scene (file_out):
    """ Read all the MORSE components from a Blender file

    Create lists of robots and components to save them as a text file
    """
    file_out.write("from morse.builder import *\n\n")

    robot_text = ''
    component_text = ''

    for obj in bpy.data.objects:
        try:
            component_path = obj.game.properties['Path'].value
        # Exit if the object is not a MORSE component
        except KeyError as detail:
            continue

        # Ignore middleware and modifier empties.
        # These will be added dinamically by the builder
        if 'middleware' in component_path or 'modifiers' in component_path:
            continue

        # Read what type of component this is,
        #  from the source of its python file
        path_elements = component_path.split('/')
        component_type = path_elements[-2]
        component_name = path_elements[-1]

        builder_type = morse_types[component_type]

        # Swap dots for underscores in object names
        obj_name = re.sub('\.', '_', obj.name)
        # Create the object instance
        if component_type == 'robots':
            robot_text += "%s = %s('%s')\n" % (obj_name, builder_type, component_name)
            robot_text += save_translation(obj, obj_name)
            robot_text += save_rotation(obj, obj_name)
            robot_text += save_properties(obj, obj_name)
            robot_text += "\n"

        # Assign component to the parent
        if component_type == 'sensors' or component_type == 'actuators':
            component_text += "%s = %s('%s')\n" % (obj_name, builder_type, component_name)
            component_text += save_translation(obj, obj_name)
            component_text += save_rotation(obj, obj_name)
            parent_name = re.sub('\.', '_', obj.parent.name)
            component_text += "%s.append(%s)\n" % (parent_name, obj_name)
            component_text += save_properties(obj, obj_name)
            component_text += "\n"

    # Write the buffers to the text file
    file_out.write("# Robots\n")
    file_out.write(robot_text)
    file_out.write("# Components\n")
    file_out.write(component_text)


def scan_config(file_out):
    """ Parse the contents of 'component_config.py'
    
    Produce a configuration file that 'morsebuilder' can use to
    configure the robot/middleware bindings in a scene. 
    """
    import component_config
    file_out.write("# Scene configuration\n")
    for key,value in component_config.component_datastream.items():
        component = re.sub('\.', '_', key)
        # If the 'value' variable contains only strings, use that string
        #  as the name of the middleware.
        # This is done for backwards compatibility with the previous
        #  syntax that allowed only one middleware per component
        if isinstance (value[0], str):
            mw = value[0]
            mw = mw.lower()
            file_out.write("%s.add_stream('%s', %s)\n" % (component, mw, value))
        # If using the new syntax that allows more than one middleware
        #  per component
        else:
            for item in value:
                mw = item[0]
                mw = mw.lower()
                file_out.write("%s.add_stream('%s', %s)\n" % (component, mw, item))

    try:
        component_config.component_service
        file_out.write("\n")
        for key,value in component_config.component_service.items():
            component = re.sub('\.', '_', key)
            mw = re.search('(\w+)_request_manager', value[0])
            file_out.write("%s.configure_service('%s')\n" % (component, mw.group(1)))
    except AttributeError as detail:
        print ("\tNo services configured")

    try:
        component_config.component_modifier
        file_out.write("\n")
        for key,value in component_config.component_modifier.items():
            component = re.sub('\.', '_', key)
            mod = value[0]
            file_out.write("%s.configure_modifier(%s)\n" % (component, mod))
    except AttributeError as detail:
        print ("\tNo modifiers configured")

def get_environment():
    try:
        ssh = bpy.data.objects['Scene_Script_Holder']
        environment_file = ssh.game.properties['environment_file'].value
    except KeyError as detail:
        environment_file = 'indoors-1/indoor-1'
        print ("No environment file specified in 'Scene_Script_Holder'\nUsing '%s' as default" % environment_file)

    return environment_file


def save_scene():
    print ("\nRunning from %s" % bpy.data.filepath)
    filename = bpy.path.display_name_from_filepath(bpy.data.filepath) + ".py"
    file_out = open(filename, "w")
    print ("Saving scene robot configuration to file '%s'" % filename)
    scan_scene(file_out)
    scan_config(file_out)
    env_name = get_environment()
    file_out.write("\nenv = Environment('%s')" % env_name)
    file_out.write("\nenv.create()")
    file_out.close()
    print ("Configuration saved")


#--- ### Operator
class MorseExporter(bpy.types.Operator):
    ''' Convert a MORSE scene configuration to a python script '''
    bl_idname = "export_scene.morse"
    bl_label = "Save MORSE scene"
    bl_description = "Convert a MORSE scene configuration to a python script"

    #--- Blender interface methods
    #@classmethod
    #def poll(cls,context):
        #return (context.mode == 'OBJECT')

    def execute(self,context):
        save_scene()
        return ('FINISHED')


def menu_draw(self, context):
    self.layout.operator_context = 'INVOKE_REGION_WIN'
    self.layout.operator(MorseExporter.bl_idname, "Save MORSE scene (.py)")

#--- ### Register
def register():
    register_module(__name__)
    bpy.types.INFO_MT_file_export.prepend(menu_draw)
def unregister():
    bpy.types.INFO_MT_file_export.remove(menu_draw)
    unregister_module(__name__)

#--- ### Main code
if __name__ == '__main__':
    register()
    #save_scene()

########NEW FILE########
__FILENAME__ = morse_gui
bl_info = {
    "name": "MORSE GUI",
    "author": "Pierrick Koch",
    "version": (1, 0, 0),
    "blender": (2, 5, 9),
    "api": 36147,
    "location": "Properties>Scene",
    "category": "Import-Export",
    "description": "Graphical User Interface for MORSE",
    "warning": "",
    "wiki_url": "",
    "tracker_url": "https://softs.laas.fr/bugzilla/"
}

import os
import bpy
from morse.builder import *

"""
MORSE GUI to import components

To test this module you can open this file inside a Text panel in Blender,
then run the script.
This will generate a GUI in the Properties View in the Scene tab.
"""

data = {}

def init():
    # initialize the component list, scan component directory
    path = MORSE_COMPONENTS
    for category in os.listdir(path):
        pathc = os.path.join(path, category)
        if os.path.isdir(pathc):
            data[category] = list_components(pathc)
            if len(data[category]) > 0:
                init_prop(category, data[category])

def list_components(path, subdir=''):
    components = []
    for blend in os.listdir(path):
        pathb = os.path.join(path, blend)
        if os.path.isfile(pathb) and blend.endswith('.blend'):
            components.append(subdir + blend[:-6])
        # go to 2nd level (for scenes)
        elif os.path.isdir(pathb):
            components.extend(list_components(pathb, subdir='%s%s/'%(subdir, blend)))
    return components

def init_prop(category, components):
    objects = []
    for index, name in enumerate(components):
        objects.append((str(index), name, category))

    enum = bpy.props.EnumProperty(name=category, description="Choose %s"%category, items=objects, default='0')
    setattr(bpy.types.Scene, 'enum_%s'%category, enum)

class MorsePanel(bpy.types.Panel):
    bl_label = "MORSE Panel"
    bl_idname = "OBJECT_PT_MORSE"
    bl_space_type = "PROPERTIES"
    bl_region_type = "WINDOW"
    bl_context = "scene"

    def draw(self, context):
        layout = self.layout
        scene = context.scene
        
        for category in data:
            if len(data[category]) > 0:
                row = layout.row()
                row.prop(scene, 'enum_%s'%category)
                row = layout.row()
                btn = row.operator('bpt.add', text="Add MORSE %s"%category)
                btn.category = category

class MorseOperator(bpy.types.Operator):
    bl_idname = "bpt.add"
    bl_label = "Add MORSE Component"
    
    category = bpy.props.StringProperty()

    def execute(self, context):
        # get the index of the selected element
        select = getattr(bpy.context.scene, 'enum_%s'%self.category)
        # get the enum list of the current category
        enum = getattr(bpy.types.Scene, 'enum_%s'%self.category)
        # get the component name
        component = enum[1]['items'][int(select)][1]
        # import the MORSE component
        Component(self.category, component)

        return{"FINISHED"}

def register():
    init() # initialize the component list, scan component directory
    bpy.utils.register_class(MorseOperator)
    bpy.utils.register_class(MorsePanel)

def unregister():
    bpy.utils.unregister_class(MorseOperator)
    bpy.utils.unregister_class(MorsePanel)

if __name__ == "__main__":
    register()


########NEW FILE########
__FILENAME__ = simple_example
#! /usr/bin/env python
""" Human control with keyboard through sockets

this example is meant to show how to use services with sockets.
After the connection with the socket, we just send a message well formed.
You can control the human with the numpad : 8 and 5 for forward and backward,
and 4 and 6 for left and right.

"""

import sys
import socket
import tty, termios

HOST = '127.0.0.1'
PORT = 4000

def getchar():
    """ Returns a single character from standard input """

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch


def _connect_port(port):
    """ Establish the connection with the given MORSE port"""
    sock = None

    for res in socket.getaddrinfo(HOST, port, socket.AF_UNSPEC, socket.SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        try:
            sock = socket.socket(af, socktype, proto)
        except socket.error:
            sock = None
            continue
        try:
            sock.connect(sa)
        except socket.error:
            sock.close()
            sock = None
            continue
        break

    return sock

def main():
    sock = _connect_port(PORT)
    if not sock:
        sys.exit(1)

    print("sock connected")
    print("Please press q to quit and use 8456 to move")
    esc = 0
    _id = 0

    while not esc:
        c = getchar()
        speed = 0
        rot = 0
        if (c == "8"):
            speed = 0.1
        elif (c == "5"):
            speed = -0.1
        elif (c == "4"):
            rot = 0.1
        elif (c == "6"):
            rot = -0.1
        if (speed != 0 or rot != 0):
            data_out = "id%d human move [%f, %f]\n" % (_id, speed, rot)
            sent = sock.send(data_out)
            print ("SENT DATA (%d bytes): %s" % (sent, data_out))
            _id = _id + 1

        if c == "q":
            esc = 1

    sock.close()
    print("\nBye bye!")

main()

########NEW FILE########
__FILENAME__ = blend_dtm
""" Generate DTM in Blender

Using the Displace and Decimate modifiers to generate a terrain 3D model from
(geo)images (png, tif, geotif, etc)

usage: blender -b -P blend_dtm.py -- dsm.tif image.jpg 1
"""
import os
import sys
import json
import subprocess
import bpy # Blender Python API

TERRAIN_RESOLUTION=0.50 # in meter

def new_texture():
    bpy.ops.texture.new()
    return bpy.data.textures[-1]

def new_material():
    bpy.ops.material.new()
    return bpy.data.materials[-1]

def open_image(filepath):
    bpy.ops.image.open(filepath=filepath)
    return bpy.data.images[-1]

def new_image_texture(material, image, name='img'):
    """ Create a new texture from an image (which we open)

    we need a material here, to set the texture active
    otherwise we can't change its type (to image in this case)
    """
    material.active_texture = new_texture()
    material.active_texture.name = name
    material.active_texture.type = 'IMAGE'
    material.active_texture.image = image
    return material.active_texture

def new_grid(name='Grid', x_subdivisions=10, y_subdivisions=10, radius=1, scale=(1,1,1)):
    bpy.ops.object.select_all(action='DESELECT')
    bpy.ops.mesh.primitive_grid_add(x_subdivisions=x_subdivisions, \
        y_subdivisions=y_subdivisions, radius=radius)
    bpy.context.object.scale = scale
    bpy.context.object.name = name
    return bpy.context.object

def select_only(obj):
    bpy.ops.object.select_all(action='DESELECT')
    obj.select = True
    bpy.context.scene.objects.active = obj

def subdivide(obj, number_cuts=1):
    select_only(obj)
    bpy.ops.object.mode_set(mode='EDIT')
    bpy.ops.mesh.subdivide(number_cuts=number_cuts)
    bpy.ops.object.mode_set(mode='OBJECT')
    return obj

def new_cube(name='Cube', scale=(1,1,1)):
    bpy.ops.object.select_all(action='DESELECT')
    bpy.ops.mesh.primitive_cube_add()
    bpy.context.object.scale = scale
    bpy.context.object.name = name
    return bpy.context.object

def set_viewport(viewport_shade='WIREFRAME', clip_end=1000):
    """ Set the default view mode

    :param viewport_shade: enum in ['BOUNDBOX', 'WIREFRAME', 'SOLID', 'TEXTURED'], default 'WIREFRAME'
    """
    for area in bpy.context.window.screen.areas:
        if area.type == 'VIEW_3D':
            for space in area.spaces:
                if space.type == 'VIEW_3D':
                    space.viewport_shade = viewport_shade
                    space.clip_end = clip_end
                    space.grid_scale = 10
                    space.grid_lines = 50

def save(filepath=None, check_existing=False, compress=True):
    """ Save .blend file

    :param filepath: File Path
    :type  filepath: string, (optional, default: current file)
    :param check_existing: Check and warn on overwriting existing files
    :type  check_existing: boolean, (optional, default: False)
    :param compress: Compress, Write compressed .blend file
    :type  compress: boolean, (optional, default: True)
    """
    if not filepath:
        filepath = bpy.data.filepath
    bpy.ops.wm.save_mainfile(filepath=filepath, check_existing=check_existing,
            compress=compress)

def setup():
    """ Setup the scene """
    # Delete the default objects
    bpy.ops.object.select_all(action='SELECT')
    bpy.ops.object.delete()
    # Add light (sun)
    bpy.ops.object.lamp_add(type='SUN', location=(0, 0, 300))
    # Set Game mode
    bpy.context.scene.render.engine = 'BLENDER_GAME'
    # make sure OpenGL shading language shaders (GLSL) is the
    # material mode to use for rendering
    bpy.context.scene.game_settings.material_mode = 'GLSL'
    # Set the unit system to use for button display (in edit mode) to metric
    bpy.context.scene.unit_settings.system = 'METRIC'
    # Select the type of Framing to Extend,
    # Show the entire viewport in the display window,
    # viewing more horizontally or vertically.
    bpy.context.scene.game_settings.frame_type = 'EXTEND'
    # see the texture in realtime (in the 3D viewport)
    set_viewport('TEXTURED', 10000)
    # Set the color at the horizon to dark azure
    bpy.context.scene.world.horizon_color = (0.05, 0.22, 0.4)
    # Display framerate and profile information of the simulation
    bpy.context.scene.game_settings.show_framerate_profile = True

def usage():
    sys.stderr.write('usage: blender -b -P blend_dtm.py -- dsm.tif image.jpg [terrain_resolution]\n')

def ext_exec(cmd, python=None):
    if not python:
        python = 'python%i.%i'%(sys.version_info.major, sys.version_info.minor)
    return subprocess.getoutput('%s -c"%s"' % (python, cmd) )

def fix_python_path(python=None):
    pythonpath = ext_exec("import os,sys;print(os.pathsep.join(sys.path))")
    sys.path.extend(pythonpath.split(os.pathsep))

def get_gdalinfo(filepath):
    """ Get the GeoTransform from the :param:filepath DEM using gdal

    In a north up image, padfTransform[1] is the pixel width,
    and padfTransform[5] is the pixel height. The upper left corner of the
    upper left pixel is at position (padfTransform[0],padfTransform[3]).

    The default transform is (0,1,0,0,0,1)
    """
    # Run externally since `gdal.Open` crashes Blender :-/
    meta = ext_exec("import json,gdal,gdalconst;"
        "g=gdal.Open('%s',gdalconst.GA_ReadOnly);"
        "print(json.dumps({'transform':g.GetGeoTransform(),"
            "'minmax':g.GetRasterBand(1).ComputeRasterMinMax(),"
            "'meta':g.GetMetadata()}))"%filepath)
    return json.loads(meta) # {'transform':(0,1,0,0,0,1)}

def main(argv=[]):
    args = []
    if '--' in argv:
        args = argv[argv.index('--')+1:]

    if len(args) < 2:
        usage()
        return 1

    if len(args) > 2:
        terrain_resolution = float(args[2])
    else:
        terrain_resolution = TERRAIN_RESOLUTION

    image_dem = open_image(args[0])
    image_img = open_image(args[1])
    if image_dem.size[:] != image_img.size[:]:
        print('[WARN] The size of the 2 image differ')

    fix_python_path()
    gdalinfo = get_gdalinfo(args[0])
    geot = gdalinfo['transform']
    meta = gdalinfo['meta']
    xsize = image_dem.size[0] * abs(geot[1]) # in meters
    ysize = image_dem.size[1] * abs(geot[5]) # in meters

    translation = [0.0, 0.0, 0.0]
    if 'CUSTOM_X_ORIGIN' in meta and 'CUSTOM_Y_ORIGIN' in meta:
        custom_x_origin = float(meta['CUSTOM_X_ORIGIN'])
        custom_y_origin = float(meta['CUSTOM_Y_ORIGIN'])
        print("[gdal] got custom (%f, %f)"%(custom_x_origin, custom_y_origin))
        center_x_utm = geot[0] + image_dem.size[0] * geot[1] / 2
        center_y_utm = geot[3] + image_dem.size[1] * geot[5] / 2
        translation = [ center_x_utm - custom_x_origin,
                        center_y_utm - custom_y_origin, 0.0 ]
    if gdalinfo['minmax']:
        translation[2] = - round(gdalinfo['minmax'][0] + 1)
    setup()

    #########################################################################
    # Add our ground object
    ground = new_grid('Ground', xsize/terrain_resolution, \
        ysize/terrain_resolution, 1, (xsize/2.0, ysize/2.0, 1))

    #########################################################################
    # Add material
    ground.active_material = new_material()
    ground.active_material.specular_intensity = 0
    ground.active_material.name = 'Ground'
    material = ground.active_material

    #########################################################################
    # Add texture
    texture_img = new_image_texture(material, image_img, 'img')

    material.active_texture_index += 1

    image_dem.colorspace_settings.name = 'Linear'
    texture_dem = new_image_texture(material, image_dem, 'dem')
    # do not show on the material (use only later for the terrain modifier)
    material.use_textures[material.active_texture_index] = False

    #bpy.ops.object.shade_smooth()
    # displace from image_dem (gdal)
    add_displace_modifier(ground, texture_dem, apply=True)
    # unlink dem after apply (reduce size)
    material.texture_slots.clear(1)
    image_dem.user_clear()
    bpy.data.images.remove(image_dem)
    texture_dem.user_clear()
    bpy.data.textures.remove(texture_dem)
    #add_decimate_modifier(ground)
    #add_water_cube((xsize+1, ysize+1, max(image_dem.pixels)/2))

    # move to: custom origin - center (utm from gdalinfo)
    ground.location = translation

    bpy.ops.file.pack_all() # bpy.ops.image.pack(as_png=True)
    save('/tmp/dtm.blend')
    # bpy.ops.view3d.view_selected(use_all_regions=True) # XXX no poll()
    print("\n----\nsaved in /tmp/dtm.blend\n----\n")
    return 0

def add_water_cube(scale=(1,1,1)):
    """ Add cube 'water' to hide the bottom

    (save memory, don't render many vertices)
    """
    cube = new_cube('Water', scale)
    cube.active_material = new_material()
    cube.active_material.name = 'Water'
    cube.active_material.use_shadeless = True
    cube.active_material.diffuse_color = (0.3, 0.4, 0.8)
    return cube

def add_displace_modifier(obj, texture, strength=1, direction='Z', apply=False):
    """ Add displace modifier

    http://wiki.blender.org/index.php/Doc:2.6/Manual/Modifiers/Deform/Displace
    """
    select_only(obj)
    bpy.ops.object.modifier_add(type='DISPLACE')
    modifier = bpy.context.object.modifiers[-1]
    modifier.texture = texture
    modifier.strength = strength
    modifier.direction = direction
    if apply:
        bpy.ops.object.modifier_apply(modifier=modifier.name)
    return modifier

def add_decimate_modifier(obj, ratio=0.5, apply=False, show_viewport=False):
    """ Add displace modifier

    http://wiki.blender.org/index.php/Doc:2.6/Manual/Modifiers/Generate/Decimate
    """
    select_only(obj)
    bpy.ops.object.modifier_add(type='DECIMATE')
    modifier = bpy.context.object.modifiers[-1]
    modifier.show_viewport = show_viewport # no preview : faster
    modifier.ratio = ratio
    if apply:
        bpy.ops.object.modifier_apply(modifier=modifier.name)
    return modifier

def add_hillshade(demfile, material):
    """ Add hillshade """
    hillshade_png = '%s.hillshade.png'%demfile
    if not os.path.isfile(hillshade_png):
        subprocess.getstatusoutput("gdaldem hillshade %s %s -of png"%(demfile, hillshade_png))
    image_hsh = open_image(hillshade_png)
    material.active_texture_index += 1
    texture_hsh = new_image_texture(material, image_hsh, 'hsh')
    texture_hsh.use_normal_map = True
    texture_slot_hsh = material.texture_slots[material.active_texture_index]
    texture_slot_hsh.use_map_color_diffuse = False
    texture_slot_hsh.use_map_normal = True
    texture_slot_hsh.normal_factor = -0.5

if __name__ == '__main__':
    main(sys.argv)

########NEW FILE########
__FILENAME__ = wiimote_human_client
#! /usr/bin/env python

""" Human control with wiimote

You can take control of the human in morse using a wiiMote through this code. 
To do that, we use cwiid library to handle the wiiMot communication and 
sockets and request mecanisms to comminicate with morse.
That being said, the manipulation of the wiiMote isn't really intuitive 
neither precise, and so, the control is a bit hard.

"""

import time
import socket

import cwiid

from math import fabs


id_ = 0

HOST = '127.0.0.1'
PORT = 4000 
s = None

toggled = False
grasped = False

tabOfExistentButtons = [cwiid.BTN_PLUS, cwiid.BTN_UP, cwiid.BTN_DOWN,
    cwiid.BTN_RIGHT, cwiid.BTN_LEFT, cwiid.BTN_HOME, cwiid.BTN_MINUS,
    cwiid.BTN_A, cwiid.BTN_B, cwiid.BTN_1, cwiid.BTN_2]


def _connect_port(port):
    """ Establish the connection with the given MORSE port"""
    local_socket = None

    for res in socket.getaddrinfo(HOST, port, socket.AF_UNSPEC, socket.SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        try:
            local_socket = socket.socket(af, socktype, proto)
        except socket.error as msg:
            local_socket = None
            continue
        try:
            local_socket.connect(sa)
        except socket.error as msg:
            local_socket.close()
            local_socket = None
            continue
        break

    return local_socket


def main():
    """ Main function containing a loop for getting wiimote's inputs. """
    global s
    global toggled
    
    print ("Please, put the Wiimote on discoverable mode (press 1+2)")
    wiimote = cwiid.Wiimote()
    print ("Wiimote detected")
    
    s = _connect_port(PORT)
    if not s:
        sys.exit(1)

    print ("Socket connected")

    wiimote.led = cwiid.LED1_ON 
    wiimote.enable(cwiid.FLAG_MESG_IFC)
    wm_cal = wiimote.get_acc_cal(cwiid.EXT_NONE)
    esc = 0
    


    tabOfExistentButtons.sort()
    tabOfExistentButtons.reverse()
    
    while not esc :
        wiimote.rpt_mode = cwiid.RPT_BTN
        time.sleep(0.05)
        wiimote.enable(cwiid.FLAG_NONBLOCK)
        msg = wiimote.get_mesg()
        wiimote.disable(cwiid.FLAG_NONBLOCK)
        
        if msg is not None :
            if msg[0][0] == cwiid.MESG_BTN :
                button = msg[0][1]
                t = detect_button(button)
                for i in t: 
                    buttonPress(i)
                buttonPressAllTab(t)
                
                if button == cwiid.BTN_1 + cwiid.BTN_2 :
                    esc = 1
        else :
            buttonPressAllTab(None)

        wiimote.rpt_mode = cwiid.RPT_ACC
        msg1 = wiimote.get_mesg()
        if msg1 is not None :
            if msg1[0][0] == cwiid.MESG_ACC :
                acceleration(msg1[0][1],wm_cal)
                
    s.close()
    wiimote.led = 0
    wiimote.close()
    
    print ("Wiimote connection and socket connection closed succefully")
    print ("Bye bye!")
        
        
def acceleration(mesg,wm_cal):
    """ Handle the gyroscope on the wiimote """
    global id_
    
    acc_adjust = 0.5
    seuil = 0.05
    
    tilt =((mesg[cwiid.Y]*1.0 - wm_cal[0][cwiid.Y]*1.0) * acc_adjust  / 
    wm_cal[0][cwiid.Y]*1.0)
    roll = (-(mesg[cwiid.X]*1.0 - wm_cal[0][cwiid.X]*1.0) * acc_adjust / 
    wm_cal[0][cwiid.X]*1.0)
                     
    if fabs(roll) < seuil :
        roll = 0.0
    if fabs(tilt) < seuil :
        seuil = 0.0
        
    msg = "id%s Human move [%s, %s]\n" % (str(id_), str(tilt), str(roll))
    s.send(msg)
    id_ = id_ + 1
   
   
def buttonPress(button) :
    """ Handle the button pressed on the wiimote """
    headIncrement = 0.1
    handIncrement = 0.1

    if button == cwiid.BTN_DOWN :
        head_move(0.0,headIncrement)
        
    elif button == cwiid.BTN_LEFT :
        head_move(headIncrement,0.0)
        
    elif button == cwiid.BTN_MINUS :
        hand_move(-handIncrement)
        
    elif button == cwiid.BTN_PLUS :
        hand_move(handIncrement)
        
    elif button == cwiid.BTN_RIGHT :
        head_move(-headIncrement,0.0)
        
    elif button == cwiid.BTN_UP :
        head_move(0.0,-headIncrement)
       
def buttonPressAllTab(t) :
    """ Handle the button that can remain pressed and than released """
    global toggled
    global grasped
    
    ################ manipulation option ##############
    if t == None :
        if toggled :
            toggle_manip()
            toggled = False
    else :
        if cwiid.BTN_B in t and not toggled :
            toggle_manip()
            toggled = True
        elif cwiid.BTN_B not in t and toggled :
            toggle_manip()
            toggled = False
            
    ################ grasp option ##############
    if t == None :
        if grasped :
            grasp(False)
            grasped = False
    else :
        if cwiid.BTN_A in t and not grasped :
            grasp(True)
            grasped = True
        elif cwiid.BTN_A not in t and grasped :
            grasp(False)
            grasped = False
                

def detect_button(button):
    """ Compute the different buttons pressed on the wiimote.
    return a tab with those buttons
    """
    t= []
    for b in tabOfExistentButtons :
        if button // b == 1 :
            t.append(b)
            button = button % b
    return t
    

def head_move(pan,tilt):
    """ Sending socket messages """
    global id_
    
    msg = "id%s Human move_head [%s, %s]\n" % (str(id_), str(pan), str(tilt))
    s.send(msg)
    id_ = id_ + 1

def hand_move(diff):
    """ Sending socket messages """
    global id_
    
    msg = "id%s Human move_hand [%s, 0.0]\n" % (str(id_), str(diff))
    # The second argument should be removed, however,
    # the socket have a probleme with a single argument.
    s.send(msg)
    id_ = id_ + 1

def toggle_manip():
    """ Sending socket messages """
    global id_
    
    msg = "id%s Human toggle_manipulation []\n" % (str(id_))
    s.send(msg)
    id_ = id_ + 1

def grasp(seq):
    """ Sending socket messages """
    global id_
    
    msg = "id%s Human grasp [%i]\n" % (str(id_), seq)
    s.send(msg)
    id_ = id_ + 1

main()

########NEW FILE########
__FILENAME__ = wii_kinect_human_client
#! /usr/bin/env python

""" Human control with wiimote

You can take control of the mocap_human in morse using a wiiMote through this code.
To do that, we use cwiid library to handle the wiiMote communication and
sockets and request mecanisms to comminicate with MORSE.
That being said, the manipulation of the wiiMote isn't really intuitive
neither precise, and so, the control is a bit hard.

"""

import time
import socket

import cwiid

from math import fabs


id_ = 0

HOST = '127.0.0.1'
PORT = 4000
s = None

toggled = False
grasped = False

tabOfExistentButtons = [cwiid.BTN_PLUS, cwiid.BTN_UP, cwiid.BTN_DOWN,
    cwiid.BTN_RIGHT, cwiid.BTN_LEFT, cwiid.BTN_HOME, cwiid.BTN_MINUS,
    cwiid.BTN_A, cwiid.BTN_B, cwiid.BTN_1, cwiid.BTN_2]


def _connect_port(port):
    """ Establish the connection with the given MORSE port"""
    local_socket = None

    for res in socket.getaddrinfo(HOST, port, socket.AF_UNSPEC, socket.SOCK_STREAM):
        af, socktype, proto, canonname, sa = res
        try:
            local_socket = socket.socket(af, socktype, proto)
        except socket.error as msg:
            local_socket = None
            continue
        try:
            local_socket.connect(sa)
        except socket.error as msg:
            local_socket.close()
            local_socket = None
            continue
        break

    return local_socket


def main():
    """ Main function containing a loop for getting wiimote's inputs. """
    global s
    global toggled

    print ("Please, put the Wiimote on discoverable mode (press 1+2)")
    wiimote = cwiid.Wiimote()
    print ("Wiimote detected")

    s = _connect_port(PORT)
    if not s:
        sys.exit(1)

    print ("Socket connected")

    wiimote.led = cwiid.LED1_ON
    wiimote.enable(cwiid.FLAG_MESG_IFC)
    wm_cal = wiimote.get_acc_cal(cwiid.EXT_NONE)
    esc = 0

    tabOfExistentButtons.sort()
    tabOfExistentButtons.reverse()

    while not esc :
        wiimote.rpt_mode = cwiid.RPT_BTN
        time.sleep(0.05)
        wiimote.enable(cwiid.FLAG_NONBLOCK)
        msg = wiimote.get_mesg()
        wiimote.disable(cwiid.FLAG_NONBLOCK)

        if msg is not None :
            if msg[0][0] == cwiid.MESG_BTN :
                button = msg[0][1]
                t = detect_button(button)
                for i in t:
                    buttonPress(i)
                buttonPressAllTab(t)

                if button == cwiid.BTN_1 + cwiid.BTN_2 :
                    esc = 1
        else :
            buttonPressAllTab(None)

        """
        # This seems to be the part where we treat the accelerometers
        # Don't want to use it for the moment
        wiimote.rpt_mode = cwiid.RPT_ACC
        msg1 = wiimote.get_mesg()
        if msg1 is not None :
            if msg1[0][0] == cwiid.MESG_ACC :
                acceleration(msg1[0][1],wm_cal)
        """

    s.close()
    wiimote.led = 0
    wiimote.close()

    print ("Wiimote connection and socket connection closed succefully")
    print ("Bye bye!")


def acceleration(mesg,wm_cal):
    """ Handle the gyroscope on the wiimote """
    global id_

    acc_adjust = 0.5
    seuil = 0.05

    tilt =((mesg[cwiid.Y]*1.0 - wm_cal[0][cwiid.Y]*1.0) * acc_adjust  /
    wm_cal[0][cwiid.Y]*1.0)
    roll = (-(mesg[cwiid.X]*1.0 - wm_cal[0][cwiid.X]*1.0) * acc_adjust /
    wm_cal[0][cwiid.X]*1.0)

    if fabs(roll) < seuil :
        roll = 0.0
    if fabs(tilt) < seuil :
        seuil = 0.0

    msg = "id%s mocap_human move [%s, %s]\n" % (str(id_), str(tilt), str(roll))
    s.send(msg)
    id_ = id_ + 1


def buttonPress(button) :
    """ Handle the button pressed on the wiimote """
    global grasped
    global toggled

    headIncrement = 0.1
    handIncrement = 0.1

    """
    if button == cwiid.BTN_UP :
        move_man(0.1, 0)
        #head_move(0.0,-headIncrement)

    elif button == cwiid.BTN_DOWN :
        #head_move(0.0,headIncrement)
        move_man(-0.1, 0)

    elif button == cwiid.BTN_LEFT :
        #head_move(headIncrement,0.0)
        move_man(0, 0.1)

    elif button == cwiid.BTN_RIGHT :
        #head_move(-headIncrement,0.0)
        move_man(0, -0.1)

    # Toggling of grasp mode
    elif button == cwiid.BTN_B and not grasped :
        grasp("t")
        grasped = True
    elif button == cwiid.BTN_B and grasped :
        grasp("f")
        grasped = False

    # Toggle view to right hand
    elif cwiid.BTN_A and not toggled :
        toggle_manip()
        toggled = True
    elif cwiid.BTN_A and toggled :
        toggle_manip()
        toggled = False
    """

    """
    elif button == cwiid.BTN_MINUS :
        hand_move(-handIncrement)

    elif button == cwiid.BTN_PLUS :
        hand_move(handIncrement)
    """


def buttonPressAllTab(t) :
    """ Handle the button that can remain pressed and then released """
    global toggled
    global grasped

    move_speed = 0.05
    rotate_speed = 0.05

    if t == None :
        return

    ################ movement option ##############
    if cwiid.BTN_UP in t:
        move_man(move_speed, 0)
        #head_move(0.0,-headIncrement)

    if cwiid.BTN_DOWN in t:
        #head_move(0.0,headIncrement)
        move_man(-move_speed, 0)

    if cwiid.BTN_LEFT in t:
        #head_move(headIncrement,0.0)
        move_man(0, rotate_speed)

    if cwiid.BTN_RIGHT in t:
        #head_move(-headIncrement,0.0)
        move_man(0, -rotate_speed)


    ################ manipulation option ##############
    #if cwiid.BTN_A in t and not toggled :
    #    toggle_manip()
    #    toggled = True
    #elif cwiid.BTN_A not in t and toggled :
    #    toggle_manip()
    #    toggled = False

    ################ manipulation option ##############
    if cwiid.BTN_A in t:
        switch_cameras()

    ################ grasp option ##############
    if cwiid.BTN_B in t and not grasped :
        grasp(True)
        grasped = True
    elif cwiid.BTN_B not in t and grasped :
        grasp(False)
        grasped = False


def detect_button(button):
    """ Compute the different buttons pressed on the wiimote.
    return a tab with those buttons
    """
    t= []
    for b in tabOfExistentButtons :
        if button // b == 1 :
            t.append(b)
            button = button % b
    return t


def head_move(pan,tilt):
    """ Sending socket messages """
    global id_

    msg = "id%s mocap_human move_head [%s, %s]\n" % (str(id_), str(pan), str(tilt))
    s.send(msg)
    id_ = id_ + 1

def hand_move(diff):
    """ Sending socket messages """
    global id_

    msg = "id%s mocap_human move_hand [%s, 0.0]\n" % (str(id_), str(diff))
    # The second argument should be removed, however,
    # the socket have a probleme with a single argument.
    s.send(msg)
    id_ = id_ + 1

def move_man(v, w):
    """ Give forward movement or rotation instructions to the mocap_human robot """
    global id_

    msg = "id%s mocap_human move [%s, %s]\n" % (str(id_), str(v), str(w))
    s.send(msg)
    print("Socket move_man sent")
    id_ = id_ + 1

def toggle_manip():
    """ Sending socket messages """
    global id_

    msg = "id%s mocap_human toggle_manipulation []\n" % (str(id_))
    s.send(msg)
    id_ = id_ + 1

def switch_cameras():
    """ Sending socket messages """
    global id_

    msg = "id%s mocap_human switch_cameras []\n" % (str(id_))
    s.send(msg)
    print("Socket move camera sent")
    id_ = id_ + 1

def grasp(seq):
    """ Sending socket messages """
    global id_

    msg = "id%s mocap_human grasp [%i]\n" % (str(id_), seq)
    s.send(msg)
    print("Socket grasp sent")
    id_ = id_ + 1

main()

########NEW FILE########
