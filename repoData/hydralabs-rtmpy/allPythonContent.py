__FILENAME__ = conf
# -*- coding: utf-8 -*-

# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os, time
from shutil import copyfile

from docutils.core import publish_parts

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
sys.path.append(os.path.abspath('.'))
sys.path.append(os.path.abspath('html'))

def rst2html( input, output ):
    """
    Create html file from rst file.

    :param input: Path to rst source file
    :type: `str`
    :param output: Path to html output file
    :type: `str`
    """
    file = os.path.abspath(input)
    rst = open(file, 'r').read()
    html = publish_parts(rst, writer_name='html')
    body = html['html_body']

    tmp = open(output, 'w')
    tmp.write(body)
    tmp.close()

    return body

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
#
# Grab sphinxcontrib.epydoc from http://packages.python.org/sphinxcontrib-epydoc
extensions = ['sphinx.ext.intersphinx', 'sphinxcontrib.epydoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['html']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'


# create content template for the homepage
readme = rst2html('../README.txt', 'html/intro.html')
readme = copyfile('../CHANGES.txt', 'changelog.rst')

# General information about the project.
project = 'RTMPy'
url = 'http://rtmpy.org'
description = 'RTMP for Python'
copyright = "Copyright &#169; 2007-%s The <a href='%s'>%s</a> Project. All rights reserved." % (
            time.strftime('%Y'), url, project)

# We look for the __init__.py file in the current RTMPy source tree
# and replace the values accordingly.
from rtmpy import __version__

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.

# The short X.Y version.
version = str(__version__)

# The full version, including alpha/beta/rc tags.
release = version[:3]

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['build', 'tutorials/examples']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
#pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# A dictionary mapping URIs to a list of regular expression.
#
# Each key of this dictionary is a base url of an epydoc-generated
# documentation. Each value is a list of regular expressions, the reference
# target must match (see re.match()) to be cross-referenced with the base url.
epydoc_mapping = {
   'http://api.pyamf.org/0.6/': [r'pyamf\.'],
   'http://api.rtmpy.org/': [r'rtmpy\.'],
}

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
# Note: you can download the 'beam' theme from:
# http://github.com/collab-project/sphinx-themes
# and place it in a 'themes' directory relative to this config file.
html_theme = 'beam'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = '%s - %s' % (project, description)

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['html/static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
html_additional_pages = {
    'index': 'defindex.html',
    'tutorials/index': 'tutorials.html',
}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'RTMPydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'RTMPy.tex', html_title,
   copyright, 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'rtmpy', html_title,
     [copyright], 1)
]


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = basic
from twisted.internet import reactor
from rtmpy.client import ClientFactory

reactor.connectTCP('localhost', 1935, ClientFactory())
reactor.run()
########NEW FILE########
__FILENAME__ = server
from rtmpy import server

from twisted.internet import reactor


class LiveApplication(server.Application):
    """
    The simplest application possible.
    """


app = LiveApplication()

reactor.listenTCP(1935, server.ServerFactory({
    'live': app,
    'oflaDemo': app # provides default support for the red5 publisher swf
}))

reactor.run()

########NEW FILE########
__FILENAME__ = build_ext
build_ext = "this setuptools bug has been around for a *very* long time ..."

########NEW FILE########
__FILENAME__ = client
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
RTMP client implementation.

@since: 0.1.0
"""

from twisted.internet import protocol as twisted_protocol

from rtmpy import protocol, versions
from rtmpy.protocol import handshake


class ClientProtocol(protocol.BaseProtocol):
    """
    Client RTMP Protocol.
    """

    version = versions.FLASH_MIN_H264
    protocolVersion = protocol.RTMP_PROTOCOL_VERSION

    def connectionMade(self):
        """
        Called when a connection has been made to this protocol instance. Used
        to do general setup and protocol initialisation.
        """
        rtmp.BaseProtocol.connectionMade(self)

        self.negotiator = self.factory.getHandshakeNegotiator(self, self.protocolVersion)

        self.negotiator.start(0, self.version)

    def connectionLost(self, *args):
        print args


class ClientFactory(twisted_protocol.ClientFactory):
    """
    RTMP client protocol factory.
    """

    protocol = ClientProtocol

    def getHandshakeNegotiator(self, protocol, version):
        """
        Returns an implementation of L{handshake.IHandshakeNegotiator} based on
        the version supplied.

        @param protocol: The client protocol instance.
        @type protocol: L{ClientProtocol}
        @param version: The RTMP version request.
        @type version: C{int}
        """
        imp = handshake.get_implementation(version)

        return imp.ClientNegotiator(imp.HandshakeObserver(protocol))

########NEW FILE########
__FILENAME__ = core
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Core primitives and logic for all things RTMP.
"""

import collections

from twisted.python import log

from rtmpy import rpc, status



class StreamManager(object):
    """
    Handles all stream based operations.

    Stream ID 0 is special, it is considered as the C{NetConnection} stream.

    @ivar streams: A C{dict} of id -> stream instances.
    @ivar _deletedStreamIds: A collection of stream ids that been deleted and
        can be reused.
    """

    CONTROL_STREAM_ID = 0

    def __init__(self):
        """
        Initialises a stream manager.

        @param nc: The NetConnection stream.
        """
        self._deletedStreamIds = collections.deque()
        self.streams = {
            self.CONTROL_STREAM_ID: self.getControlStream()
        }


    def getControlStream(self):
        """
        Get the control stream for this manager. The control stream equivalent
        to the C{NetConnection} in Flash lingo.

        Must be implemented by subclasses.
        """
        raise NotImplementedError


    def buildStream(self, streamId):
        """
        Returns a new stream object to be associated with C{streamId}.

        Must be overridden by subclasses.

        @param streamId: The id of the stream to create.
        @todo: Think about specifying the interface that the returned stream
            must adhere to.
        """
        raise NotImplementedError


    def getStream(self, streamId):
        """
        Returns the stream related to C{streamId}.

        @param streamId: The id of the stream to get.
        """
        s = self.streams.get(streamId, None)

        if s is None:
            # the peer needs to call 'createStream' to make new streams.
            raise KeyError('Unknown stream %r' % (streamId,))

        return s


    def getNextAvailableStreamId(self):
        """
        Return the next available stream id.
        """
        try:
            return self._deletedStreamIds.popleft()
        except IndexError:
            return len(self.streams)


    @rpc.expose
    def deleteStream(self, streamId):
        """
        Deletes an existing stream.

        @param streamId: The id of the stream to delete.
        @type streamId: C{int}
        """
        if streamId == self.CONTROL_STREAM_ID:
            log.msg('Attempted to delete RTMP control stream')

            return

        stream = self.streams.pop(streamId, None)

        if stream is None:
            log.msg('Attempted to delete non-existant RTMP stream %r' % (streamId,))

            return

        self._deletedStreamIds.append(streamId)
        stream.closeStream()


    @rpc.expose
    def createStream(self):
        """
        Creates a new stream assigns it a free id.

        @see: L{buildStream}
        """
        streamId = self.getNextAvailableStreamId()

        self.streams[streamId] = self.buildStream(streamId)

        return streamId


    def closeAllStreams(self):
        """
        Closes all active streams and deletes them from this manager.
        """
        streams = self.streams.copy()

        # can't close the NetConnection stream.
        control_stream = streams.pop(self.CONTROL_STREAM_ID)

        for streamId, stream in streams.items():
            try:
                self.deleteStream(streamId)
            except:
                log.err()

        try:
            control_stream.closeStream()
        except:
            log.err()

        self.streams = {
            self.CONTROL_STREAM_ID: control_stream
        }



class BaseStream(rpc.AbstractCallHandler):
    """
    """


    def __init__(self, streamId):
        super(rpc.AbstractCallHandler, self).__init__()

        self.streamId = streamId
        self.timestamp = 0


    def sendStatus(self, code, description='', command=None, **kwargs):
        """
        Informs the peer of a change of status.

        @param code: A L{status.IStatus} instance.
        @param command: The command object part of the L{message.Invoke}
            message. Not quite sure what this achieves right now. Defaults to
            L{None}.
        """
        if status.IStatus.providedBy(code):
            s = code
        else:
            s = status.status(code, description, **kwargs)

        self.call('onStatus', s, command=command)


    def setTimestamp(self, timestamp, relative=True):
        """
        Sets the timestamp for this stream. The timestamp is measured in
        milliseconds since an arbitrary epoch. This could be since the stream
        started sending or receiving audio/video etc.

        @param relative: Whether the supplied timestamp is relative to the
            previous.
        """
        if relative:
            self.timestamp += timestamp

            return

        self.timestamp = timestamp


    def onInvoke(self, name, callId, args, timestamp):
        """
        Part of the L{message.IMessageListener} interface, responds to RTMP
        invoke messages.

        @param name: The name of the method call.
        @param callId: Used for handling state.
        @param args: A tuple of arguments supplied with the RPC call.
        @param timestamp: A timestamp when the RPC call was made.
        @return: Returns a L{defer.Deferred} that will hold the result of the
           RPC call. A return value is not part of the interface but helps
           greatly with testing.
        """
        command = None

        if len(args) > 0 and args[0] is None:
            command = args[0]
            args = args[1:]

        if self.isCallActive(callId):
            return self.handleResponse(name, callId, args, command=command)

        return self.callReceived(name, callId, *args)


    def onNotify(self, name, args, timestamp):
        """
        Part of the L{message.IMessageListener} interface, responds to RTMP
        notify messages.

        We simply put the notify through as an anonymous invoke call.

        @param name: The name of the method call.
        @param args: A tuple of arguments supplied with the RPC call.
        @param timestamp: A timestamp when the RPC call was made.
        @return: Returns a L{defer.Deferred} that will hold the result of the
           RPC call. A return value is not part of the interface but helps
           greatly with testing.
        """
        self.callReceived(name, rpc.NO_RESULT, *args)



class NetConnection(StreamManager, BaseStream):
    """
    This is the base class for all concrete NetConnection implementations (e.g.
    one for server and another for client).

    This class is akin to the Flash/FMS NetConnection class and provides the
    same interface.

    @ivar client: The client object that is linked to this NetConnection.
    """

    def __init__(self, protocol):
        self.protocol = protocol
        self.client = None

        BaseStream.__init__(self, 0)
        StreamManager.__init__(self)


    def getControlStream(self):
        """
        Needed by L{StreamManager}.

        @see: L{StreamManager.getControlStream}
        """
        return self.protocol


class NetStream(BaseStream):
    """
    A stream within an RTMP connection. A stream can either send or receive
    video/audio, or in the Flash vernacular - publish or subscribe.

    Not sure about data just yet.

    @ivar nc: The controlling L{NetConnection} instance. A stream cannot exist
        without this.
    """

    def __init__(self, nc, streamId):
        BaseStream.__init__(self, streamId)

        self.nc = nc


    @property
    def client(self):
        return self.nc.client


    def sendMessage(self, msg, whenDone=None):
        """
        Sends an RTMP message to the peer. This a low level method and is not
        part of any public api. If its use is necessary then this is a bug.

        @param msg: The RTMP message to be sent by this stream.
        @type: L{message.Message}
        """
        self.nc.sendMessage(msg, stream=self, whenDone=whenDone)


    @rpc.expose
    def closeStream(self):
        """
        Called to close this stream.
        """

########NEW FILE########
__FILENAME__ = exc
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
RTMPy exception types.
"""

from rtmpy.status import codes
from rtmpy.util import add_to_class


__all__ = ['codeByClass', 'classByCode']


#: A collection of known exception classes and their related status codes
CLASS_CODES = {}



@add_to_class
def register(locals, code):
    locals['__status_code__'] = code



class BaseError(Exception):
    """
    Base exception class from which all others must be subclassed.
    """



class NetConnectionError(BaseError):
    """
    Base error class for all NetConnection errors.
    """



class CallFailed(NetConnectionError):
    """
    Raised when invoked methods from the peer fails for some reason.
    """

    register(codes.NC_CALL_FAILED)



class ConnectError(NetConnectionError):
    """
    Base error class for all connection related errors.
    """



class ConnectFailed(ConnectError):
    """
    Raised as a basic error for when connection fails and there is no other
    specific type of error.
    """

    register(codes.NC_CONNECT_FAILED)



class ConnectRejected(ConnectError):
    """
    Raised when the peers connection attempt is rejected by the application.
    """

    register(codes.NC_CONNECT_REJECTED)



class InvalidApplication(NetConnectionError):
    """
    Raised when the peer attempts to connect to an invalid or unknown
    application.
    """

    register(codes.NC_CONNECT_INVALID_APPLICATION)



class StreamError(BaseError):
    """
    Base NetStream errors.
    """

    register(codes.NS_FAILED)



class PublishError(StreamError):
    """
    Base error for all NetStream publishing errors.
    """



class BadNameError(PublishError):
    """
    Raised when a peer attempts to publish a stream with the same name as an
    already published stream.
    """

    register(codes.NS_PUBLISH_BADNAME)



class PlayError(BaseError):
    """
    Base error for all NetStream playing errors.
    """



class StreamNotFound(PlayError):
    """
    Raised when the corresponding stream could not be found for a play request.
    """

    register(codes.NS_PLAY_STREAMNOTFOUND)



def codeByClass(cls):
    """
    """
    global CLASS_CODES

    return CLASS_CODES.get(getattr(cls, '__name__', None), None)



def classByCode(code):
    """
    """
    global CLASS_CODES

    return CLASS_CODES.get(code, None)



for k, v in globals().items():
    try:
        if not issubclass(v, BaseError):
            continue
    except TypeError:
        continue

    __all__.append(k)

    if not hasattr(v, '__status_code__'):
        continue

    code = v.__status_code__

    CLASS_CODES[code] = v
    CLASS_CODES[v.__name__] = code

del k, v

########NEW FILE########
__FILENAME__ = message
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
RTMP message implementations.
"""

from zope.interface import Interface, implements
import pyamf

from rtmpy.util import add_to_class


#: Changes the frame size for the RTMP stream
FRAME_SIZE = 0x01
#: Abort
ABORT = 0x02
#: Send every x bytes read by both sides
BYTES_READ = 0x03
#: A stream control message, has subtypes
CONTROL = 0x04
#: The servers downstream bandwidth
DOWNSTREAM_BANDWIDTH = 0x05
#: The clients upstream bandwidth
UPSTREAM_BANDWIDTH = 0x06
#: Packet containing audio
# 0x07 anyone?
AUDIO_DATA = 0x08
#: Packet containing video data
VIDEO_DATA = 0x09
# 0x0a - 0x0e is unknown
#: Shared object with variable length
FLEX_SHARED_OBJECT = 0x10
#: Shared message with variable length
FLEX_MESSAGE = 0x11
#: An invoke which does not expect a reply
NOTIFY = 0x12
#: Has subtypes
SHARED_OBJECT = 0x13
#: Like remoting call, used for stream actions too
INVOKE = 0x14
# 0x15 anyone?
#: FLV data
FLV_DATA = 0x16


@add_to_class
def set_type(locals, type):
    """
    Assigns the message type to the locals of the defined class.
    """
    locals['__data_type__'] = type



class BaseError(Exception):
    """
    Base error class for all things C{message}.
    """



class DecodeError(BaseError):
    """
    Base error class for decoding RTMP messages.
    """



class TrailingDataError(DecodeError):
    """
    Raised if decoding a message does not consume the whole buffer.
    """



class EncodeError(BaseError):
    """
    Base error class for encoding RTMP messages.
    """



class UnknownType(BaseError):
    """
    Raised if an unknown message type is found.
    """



class IMessage(Interface):
    """
    An RTMP message in all its forms.

    @see: U{RTMP datatypes on OSFlash<http://osflash.org/documentation/
        rtmp#rtmp_datatypes>}
    """


    def encode(buffer):
        """
        Encodes the event instance to C{stream}.

        @type buffer: L{pyamf.util.BufferedByteStream}
        """


    def decode(buffer):
        """
        Decodes the event instance from C{stream}.

        @type buffer: L{pyamf.util.BufferedByteStream}
        """


    def dispatch(listener, timestamp):
        """
        Dispatch the event to the listener. Calls the correct method with the
        correct args according to L{IEventListener}.

        @param listener: Receives the event dispatch request.
        @type listener: L{IEventListener}
        @param timestamp: The timestamp that this message was dispatched.
        """



class IMessageListener(Interface):
    """
    Receives dispatched messages.
    """


    def onInvoke(invoke, timestamp):
        """
        Called when an invoke event have been received.

        @param invoke: The object representing the call request. See
            L{rtmpy.rtmp.event.Invoke} for an example implementation.
        @param timestamp: The timestamp that this message was dispatched.
        """


    def onNotify(notify, timestamp):
        """
        Similar to L{onInvoke} but no response is expected and will be ignored.

        @param notify: The object representing the notify request.
        @param timestamp: The timestamp that this message was dispatched.
        """


    def onAudioData(data, timestamp):
        """
        Called when audio data is received.

        @param data: The audio bytes received.
        @param timestamp: The timestamp that this message was dispatched.
        """


    def onVideoData(data, timestamp):
        """
        Called when video data is received.

        @param data: The video bytes received.
        @param timestamp: The timestamp that this message was dispatched.
        """

    # These methods should only be called on the RTMP command stream.

    def onFrameSize(size, timestamp):
        """
        Called when the RTMP frame size has changed.

        @param size: The new size of any subsequent RTMP frames in the stream.
        @param timestamp: The timestamp that this message was dispatched.
        """


    def onBytesRead(bytes, timestamp):
        """
        Called when the peer reports the number of raw bytes read from the
        stream. This is a kind of 'keep-alive' packet.

        @param bytes: The number of bytes read.
        @type bytes: C{int}
        @param timestamp: The timestamp that this message was dispatched.
        """


    def onControlMessage(message, timestamp):
        """
        Called when a control message is received by the peer.

        This could probably be split out into constituent parts once we
        understand what the various messages actually mean.

        @param message: The received message.
        @type message: L{rtmpy.rtmp.event.ControlMessage}
        @param timestamp: The timestamp that this message was dispatched.
        """


    def onDownstreamBandwidth(bandwidth, timestamp):
        """
        Called when the connected endpoint reports its downstream bandwidth
        limit.

        @param bandwidth: The amount of bandwidth available (appears to be
            measured in Kbps).
        @type bandwidth: C{int}
        @param timestamp: The timestamp that this message was dispatched.
        """


    def onUpstreamBandwidth(bandwidth, extra, timestamp):
        """
        Called when the connected endpoint reports its upstream bandwidth
        limit.

        @param bandwidth: The amount of bandwidth available (it appears to be
            measured in Kbps).
        @type bandwidth: C{int}
        @param extra: Not quite sure what this represents atm.
        @type extra: C{int}
        @param timestamp: The timestamp that this message was dispatched.
        """



class IMessageSender(Interface):
    """
    Indicates the ability to send a message.
    """


    def sendMessage(msg):
        """
        Sends a message to the receiving endpoint.

        @param msg: The message to send.
        @type msg: L{IMessage}
        @return: C{None}
        """



class Message(object):
    """
    An abstract class that all message types extend.
    """

    implements(IMessage)


    def encode(self, buf):
        """
        Called to encode the event to C{buf}.

        @type buf: L{pyamf.util.BufferedByteStream}
        """
        raise NotImplementedError


    def decode(self, buf):
        """
        Called to decode the event from C{buf}.

        @type buf: L{pyamf.util.BufferedByteStream}
        """
        raise NotImplementedError


    def dispatch(self, listener, timestamp):
        """
        Called to dispatch the event into listener.

        @type listener: L{IEventListener}
        """
        raise NotImplementedError


    def __repr__(self):
        t = self.__class__
        keys = self.__dict__.keys()
        keys = sorted(keys)

        s = '<%s.%s '

        for k in keys:
            s += '%s=%r ' % (k, self.__dict__[k])

        s += 'at 0x%x>'

        return s % (t.__module__, t.__name__, id(self))



class FrameSize(Message):
    """
    A frame size message. This determines the maximum number of bytes for the
    frame body in the RTMP stream.

    @ivar size: Number of bytes for RTMP frame bodies.
    @type size: C{int}
    """

    set_type(FRAME_SIZE)


    def __init__(self, size=None):
        self.size = size


    def decode(self, buf):
        """
        Decode a frame size message.
        """
        self.size = buf.read_ulong()


    def encode(self, buf):
        """
        Encode a frame size message.
        """
        if self.size is None:
            raise EncodeError('Frame size not set')

        try:
            buf.write_ulong(self.size)
        except TypeError:
            raise EncodeError('Frame size wrong type '
                '(expected int, got %r)' % (type(self.size),))


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        listener.onFrameSize(self.size, timestamp)



class Abort(Message):
    """
    An abort message. When reading a part of a chunked RTMP message, called to
    abort the reading.
    """

    set_type(ABORT)


    def __init__(self, channelId=None):
        self.channelId = channelId


    def decode(self, buf):
        """
        Decode a frame size message.
        """
        self.channelId = buf.read_ulong()


    def encode(self, buf):
        """
        Encode a frame size message.
        """
        if self.channelId is None:
            raise EncodeError('Frame size not set')

        try:
            buf.write_ulong(self.channelId)
        except TypeError:
            raise EncodeError('Channel ID wrong type (expected int, got %r)' % (
                type(self.channelId),))


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        listener.onAbort(self.channelId, timestamp)



class BytesRead(Message):
    """
    A bytes read message.

    @param bytes: The number of bytes read.
    @type bytes: C{int}
    """

    set_type(BYTES_READ)

    FOUR_GB_THRESHOLD = 0xee800000


    def __init__(self, bytes=None):
        self.bytes = bytes


    def decode(self, buf):
        """
        Decode a bytes read message.
        """
        self.bytes = buf.read_ulong()


    def encode(self, buf):
        """
        Encode a bytes read message.
        """
        if self.bytes is None:
            raise EncodeError('Bytes read not set')

        try:
            buf.write_ulong(self.bytes % self.FOUR_GB_THRESHOLD)
        except TypeError:
            raise EncodeError('Bytes read wrong type '
                '(expected int, got %r)' % (type(self.bytes),))


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        listener.onBytesRead(self.bytes, timestamp)



class ControlMessage(Message):
    """
    A control message. Akin to Red5's Ping event.
    """

    set_type(CONTROL)

    UNDEFINED = -1
    PING = 6
    PONG = 7


    def __init__(self, type=None, value1=0, value2=None, value3=None):
        self.type = type
        self.value1 = value1
        self.value2 = value2
        self.value3 = value3


    def decode(self, buf):
        """
        Decode a control message.
        """
        self.type = buf.read_short()
        self.value1 = buf.read_long()

        try:
            self.value2 = buf.read_long()
            self.value3 = buf.read_long()
        except IOError:
            pass


    def encode(self, buf):
        """
        Encode a control message.
        """
        if self.type is None:
            raise EncodeError('Type not set')

        try:
            buf.write_short(self.type)
        except TypeError:
            raise EncodeError('TypeError encoding type '
                '(expected int, got %r)' % (type(self.type),))

        try:
            buf.write_long(self.value1)
        except TypeError:
            raise EncodeError('TypeError encoding value1 '
                '(expected int, got %r)' % (type(self.value1),))

        if self.value2 is not None:
            try:
                buf.write_long(self.value2)
            except TypeError:
                raise EncodeError('TypeError encoding value2 '
                    '(expected int, got %r)' % (type(self.value2),))

        if self.value3 is not None:
            try:
                buf.write_long(self.value3)
            except TypeError:
                raise EncodeError('TypeError encoding value3 '
                    '(expected int, got %r)' % (type(self.value3),))


    def dispatch(self, listener, timestamp):
        """
        Dispatches the event to the listener.
        """
        return listener.onControlMessage(self, timestamp)



class DownstreamBandwidth(Message):
    """
    A downstream bandwidth message.
    """

    set_type(DOWNSTREAM_BANDWIDTH)


    def __init__(self, bandwidth=None):
        self.bandwidth = bandwidth


    def decode(self, buf):
        """
        Decode a downstream bandwidth message.
        """
        self.bandwidth = buf.read_ulong()


    def encode(self, buf):
        """
        Encode a downstream bandwidth message.
        """
        if self.bandwidth is None:
            raise EncodeError('Downstream bandwidth not set')

        try:
            buf.write_ulong(self.bandwidth)
        except TypeError:
            raise EncodeError('TypeError for downstream bandwidth '
                '(expected int, got %r)' % (type(self.bandwidth),))


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        return listener.onDownstreamBandwidth(self.bandwidth, timestamp)



class UpstreamBandwidth(Message):
    """
    An upstream bandwidth message.

    @param bandwidth: The upstream bandwidth available.
    @type bandwidth: C{int}
    @param extra: Not sure what this is supposed to represent at the moment.
    """

    set_type(UPSTREAM_BANDWIDTH)


    def __init__(self, bandwidth=None, extra=None):
        self.bandwidth = bandwidth
        self.extra = extra


    def decode(self, buf):
        """
        Decode an upstream bandwidth message.
        """
        self.bandwidth = buf.read_ulong()
        self.extra = buf.read_uchar()


    def encode(self, buf):
        """
        Encode an upstream bandwidth message.
        """
        if self.bandwidth is None:
            raise EncodeError('Upstream bandwidth not set')

        if self.extra is None:
            raise EncodeError('Extra not set')

        try:
            buf.write_ulong(self.bandwidth)
        except TypeError:
            raise EncodeError('TypeError: Upstream bandwidth '
                '(expected int, got %r)' % (type(self.bandwidth),))

        try:
            buf.write_uchar(self.extra)
        except TypeError:
            raise EncodeError('TypeError: extra '
                '(expected int, got %r)' % (type(self.extra),))


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        return listener.onUpstreamBandwidth(
            self.bandwidth, self.extra, timestamp)



class Notify(Message):
    """
    A notification message.

    @param name: The method name to call.
    @type name: C{str}
    @param args: A list of method arguments.
    """

    set_type(NOTIFY)


    def __init__(self, name=None, *args):
        self.name = name
        self.argv = list(args)


    def decode(self, buf):
        """
        Decode a notification message.
        """
        decoder = pyamf.get_decoder(pyamf.AMF0, stream=buf)

        self.name = decoder.next()
        self.argv = [x for x in decoder]


    def encode(self, buf):
        """
        Encode a notification message.
        """
        args = [self.name] + self.argv

        encoder = pyamf.get_encoder(pyamf.AMF0, buf)

        for a in args:
            encoder.writeElement(a)


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        return listener.onNotify(self.name, self.argv, timestamp)



class Invoke(Message):
    """
    Similar to L{Notify} but a reply is expected.
    """

    set_type(INVOKE)

    encoding = pyamf.AMF0


    def __init__(self, name=None, id=None, *args):
        self.name = name
        self.id = id
        self.argv = list(args)


    def decode(self, buf):
        """
        Decode a notification message.
        """
        decoder = pyamf.get_decoder(self.encoding, stream=buf)

        self.name = decoder.next()
        self.id = decoder.next()
        self.argv = list(decoder)


    def encode(self, buf):
        """
        Encode a notification message.
        """
        args = [self.name, self.id] + self.argv

        encoder = pyamf.get_encoder(self.encoding, buf)

        for a in args:
            encoder.writeElement(a)


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        listener.onInvoke(self.name, self.id, self.argv, timestamp)



class FlexMessage(Invoke):
    """
    The name is crap .. but basically its an Invoke but using amf3 to do the
    encoding/decoding.
    """

    set_type(FLEX_MESSAGE)

    encoding = pyamf.AMF3

    def decode(self, buf):
        if buf.peek(1) == '\x00':
            buf.seek(1, 1)
            self.encoding = pyamf.AMF0

        return Invoke.decode(self, buf)



class StreamingMessage(Message):
    """
    An message containing streaming data.

    @param data: The streaming data.
    @type data: C{str}
    """


    def __init__(self, data=None):
        self.data = data


    def decode(self, buf):
        """
        Decode a streaming message.
        """
        try:
            self.data = buf.read()
        except IOError:
            self.data = ''


    def encode(self, buf):
        """
        Encode a streaming message.
        """
        if self.data is None:
            raise EncodeError('No data set')

        try:
            buf.write(self.data)
        except TypeError:
            raise EncodeError('TypeError: data (expected str, got %r)' % (
                type(self.data),))



class AudioData(StreamingMessage):
    """
    A message containing audio data.
    """

    set_type(AUDIO_DATA)


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        listener.onAudioData(self.data, timestamp)



class VideoData(StreamingMessage):
    """
    A message containing video data.
    """

    set_type(VIDEO_DATA)


    def dispatch(self, listener, timestamp):
        """
        Dispatches the message to the listener.
        """
        return listener.onVideoData(self.data, timestamp)



#: Map event types to event classes
TYPE_MAP = {}

for k, v in globals().items():
    try:
        if not IMessage.implementedBy(v):
            continue
    except TypeError:
        continue

    t = getattr(v, '__data_type__', None)

    if not t:
        continue

    TYPE_MAP[t] = v
    TYPE_MAP[v] = t

del k, v



def classByType(datatype):
    """
    A helper method that returns the mapped event class to the supplied
    datatype.

    @param datatype: The event type
    @type datatype: C{int}
    @return: The event class that is mapped to C{datatype}.
    @rtype: C{class} implementing L{interfaces.IMessage} for the given event
        type.
    @raise UnknownEventType: Unknown event type for C{datatype}.
    """
    try:
        return TYPE_MAP[datatype]
    except KeyError:
        raise UnknownType('Unknown event type %r' % (datatype,))



def typeByClass(obj):
    """
    Returns the message type based on C{obj}. C{obj} can be an instance of a
    class or a class object.

    If no message type is linked to C{obj}, B{-1} is returned.
    """
    try:
        return TYPE_MAP[obj]
    except KeyError:
        pass

    cls = getattr(obj, '__class__', None)

    if cls is None:
        return -1

    try:
        return TYPE_MAP[cls]
    except KeyError:
        pass

    return -1

########NEW FILE########
__FILENAME__ = handshake
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
RTMP handshake support.

RTMP handshaking is similar (at least conceptually) to syn/ack handshaking. We
extend this concept. Each 'packet' (syn or ack) consists of a payload of data
which is represented by L{Packet}. It is up to the negotiators (which
generate/decode the packets) to determine if the packets are valid.

@since: 0.1
"""


from zope.interface import implements, Interface, Attribute
from pyamf.util import BufferedByteStream

from rtmpy.protocol import version
from rtmpy import util


HANDSHAKE_LENGTH = 1536



class IProtocolImplementation(Interface):
    """
    Provides a handshake implementation for a specific protocol version of RTMP.
    """

    ClientNegotiator = Attribute(
        'Implements IHandshakeNegotiator for client handshakes')
    ServerNegotiator = Attribute(
        'Implements IHandshakeNegotiator for server handshakes')



class IHandshakeObserver(Interface):
    """
    Observes handshake events.
    """

    def handshakeSuccess(data):
        """
        Handshaking was successful. C{data} will contain any unconsumed bytes
        from the handshaking process.
        """



class IHandshakeNegotiator(Interface):
    """
    Negotiates handshakes.
    """

    observer = Attribute("An L{IHandshakeObserver} that listens for events "
        "from this negotiator")
    transport = Attribute("Provides ITransport")


    def start(uptime=None, version=None):
        """
        Called to start the handshaking process. You can supply the uptime and
        version, otherwise they will be worked out automatically. The version
        specifically will be set to enable H.264 streaming.
        """


    def dataReceived(data):
        """
        Called when handshaking data has been received.
        """


    def buildSynPayload():
        """
        Builds the handshake payload for the negotiators syn payload (the first
        packet sent).
        """


    def buildAckPayload():
        """
        Builds the handshake payload for the negotiators ack payload (the second
        packet sent).
        """



class HandshakeError(Exception):
    """
    Generic class for handshaking related errors.
    """



class VerificationError(HandshakeError):
    """
    Raised if the handshake verification failed.
    """



class Packet(object):
    """
    A handshake packet.

    @ivar uptime: The uptime of the system in milliseconds. This value seems
        fairly arbitrary at this point. First 4 bytes of the packet.
    @type uptime: 32bit unsigned int.
    @ivar version: The version of the peer. For non-digested handshaking this
        will be 0. The second 4 bytes of the packet.
    @type version: 32bit unsigned int.
    @ivar payload: A blob of data which makes up the rest of the packet. This
        must be C{HANDSHAKE_LENGTH} - 8 bytes in length.
    @type payload: C{str}
    """

    def __init__(self, uptime=0, version=0):
        self.uptime = uptime
        self.version = version

        self.payload = None


    def encode(self, buffer):
        """
        Encodes this packet to a stream.
        """
        buffer.write_ulong(self.uptime)
        buffer.write_ulong(self.version)

        buffer.write(self.payload)


    def decode(self, buffer):
        """
        Decodes this packet from a stream.
        """
        self.uptime = buffer.read_ulong()
        self.version = buffer.read_ulong()

        self.payload = buffer.read(HANDSHAKE_LENGTH - 8)



class BaseNegotiator(object):
    """
    Base functionality for negotiating an RTMP handshake.

    @ivar observer: An observer for handshake negotiations.
    @type observer: L{IHandshakeObserver}
    @ivar buffer: Any data that has not yet been consumed.
    @type buffer: L{BufferedByteStream}
    @ivar started: Determines whether negotiations have already begun.
    @type started: C{bool}
    @ivar my_syn: The initial handshake packet that will be sent by this
        negotiator.
    @type my_syn: L{Packet}
    @ivar my_ack: The handshake packet that will be sent after the peer has sent
        its syn.
    @ivar peer_syn: The initial L{Packet} received from the peer.
    @ivar peer_ack: The L{Packet} received in acknowledgement of my syn.
    @ivar peer_version: The handshake version that the peer understands.
    """

    implements(IHandshakeNegotiator)


    def __init__(self, observer, transport):
        self.observer = observer
        self.transport = transport
        self.started = False


    def start(self, uptime=None, version=None):
        """
        Called to start the handshaking negotiations.
        """
        if self.started:
            raise HandshakeError('Handshake negotiator cannot be restarted')

        self.started = True
        self.buffer = BufferedByteStream()

        self.peer_version = None

        self.my_syn = Packet(uptime, version)
        self.my_ack = None

        self.peer_syn = None
        self.peer_ack = None

        self.buildSynPayload(self.my_syn)

        self._writePacket(self.my_syn)


    def getPeerPacket(self):
        """
        Attempts to decode a L{Packet} from the buffer. If there is not enough
        data in the buffer then C{None} is returned.
        """
        if self.buffer.remaining() < HANDSHAKE_LENGTH:
            # we're expecting more data
            return

        packet = Packet()

        packet.decode(self.buffer)

        return packet


    def _writePacket(self, packet, stream=None):
        stream = stream or BufferedByteStream()

        packet.encode(stream)

        self.transport.write(stream.getvalue())


    def dataReceived(self, data):
        """
        Called when handshake data has been received. If an error occurs
        whilst negotiating the handshake then C{self.observer.handshakeFailure}
        will be called, citing the reason.

        3 stages of data are received. The handshake version, the syn packet and
        then the ack packet.
        """
        if not self.started:
            raise HandshakeError('Data was received, but negotiator was '
                'not started')

        self.buffer.append(data)

        self._process()


    def _process(self):
        if not self.peer_syn:
            self.peer_syn = self.getPeerPacket()

            if not self.peer_syn:
                return

            self.buffer.consume()

            self.synReceived()

        if not self.peer_ack:
            self.peer_ack = self.getPeerPacket()

            if not self.peer_ack:
                return

            self.buffer.consume()

            self.ackReceived()

        # if we get here then a successful handshake has been negotiated.
        # inform the observer accordingly
        self.observer.handshakeSuccess(self.buffer.getvalue())


    def writeAck(self):
        """
        Writes L{self.my_ack} to the observer.
        """
        self._writePacket(self.my_ack)


    def buildSynPayload(self, packet):
        """
        Called to build the syn packet, based on the state of the negotiations.
        """
        raise NotImplementedError


    def buildAckPayload(self, packet):
        """
        Called to build the ack packet, based on the state of the negotiations.
        """
        raise NotImplementedError


    def synReceived(self):
        """
        Called when the peers syn packet has been received. Use this function to
        do any validation/verification.
        """


    def ackReceived(self):
        """
        Called when the peers ack packet has been received. Use this function to
        do any validation/verification.
        """



class ClientNegotiator(BaseNegotiator):
    """
    Negotiator for client initiating handshakes.
    """


    def synReceived(self):
        """
        Called when the peers syn packet has been received. Use this function to
        do any validation/verification.

        We're waiting for the ack packet to be received before we do anything.
        """


    def ackReceived(self):
        """
        Called when the peers ack packet has been received. Use this function to
        do any validation/verification.

        If validation succeeds then the ack is sent.
        """
        if self.buffer.remaining():
            raise HandshakeError('Unexpected trailing data after peer ack')

        if self.peer_ack.uptime != self.my_syn.uptime:
            raise VerificationError('Received uptime is not the same')

        if self.peer_ack.payload != self.my_syn.payload:
            raise VerificationError('Received payload is not the same')

        self.my_ack = Packet(self.peer_syn.uptime, self.my_syn.version)

        self.buildAckPayload(self.my_ack)

        self.writeAck()



class ServerNegotiator(BaseNegotiator):
    """
    Negotiator for server handshakes.
    """

    def buildSynPayload(self, packet):
        """
        Called to build the syn packet, based on the state of the negotiations.

        C{RTMP} payloads are just random.
        """
        packet.payload = _generate_payload()

    def buildAckPayload(self, packet):
        """
        Called to build the ack packet, based on the state of the negotiations.

        C{RTMP} payloads are just random.
        """
        packet.payload = _generate_payload()


    def synReceived(self):
        """
        Called when the client sends its syn packet.

        Builds and writes the ack packet.
        """
        self.my_ack = Packet(self.peer_syn.uptime, self.my_syn.uptime)

        self.buildAckPayload(self.my_ack)
        self.writeAck()


    def ackReceived(self):
        """
        Called when the clients ack packet has been received.
        """
        if self.my_syn.uptime != self.peer_ack.uptime:
            raise VerificationError('Received uptime is not the same')

        if self.my_syn.payload != self.peer_ack.payload:
            raise VerificationError('Received payload does not match')



def get_implementation(protocol):
    """
    Returns the implementation suitable for handling RTMP handshakes for the
    version specified. Will raise L{HandshakeError} if an invalid version is
    found.

    @param protocol: The C{int} version of the protocol.
    """
    protocol_mod = 'rtmpy.protocol.%s' % (version.get(protocol),)
    full_mod_path = protocol_mod + '.handshake'

    try:
        mod = __import__(full_mod_path, globals(), locals(), [protocol_mod])
    except ImportError:
        raise HandshakeError('Unknown handshake version %r' % (protocol,))

    return mod



def _generate_payload():
    return util.generateBytes(HANDSHAKE_LENGTH - 8)

########NEW FILE########
__FILENAME__ = interfaces
from zope.interface import Interface, Attribute, implements



class IChannelMeta(Interface):
    """
    Contains meta data related to a channel.
    """

    channelId = Attribute("An C{int} representing the linked channel.")
    timestamp = Attribute("The relative time value for the associated message.")
    datatype = Attribute("The datatype for the corresponding channel.")
    bodyLength = Attribute("The length of the channel body.")
    streamId = Attribute("An C{int} representing the linked stream.")



class IMessageDispatcher(Interface):
    """
    """

    def dispatchMessage(stream, datatype, timestamp, data):
        """
        Called when an RTMP message has been completely received.

        @param stream: The L{Stream} to receive this mesage.
        @param datatype: The RTMP datatype for the message.
        @param timestamp: The absolute timestamp this message was received.
        @param data: The raw data for the message.
        """


    def bytesInterval(bytes):
        """
        Called when a specified number of bytes has been read from the stream.
        The RTMP protocol demands that we send an acknowledge message to the
        peer. If we don't do this, Flash will stop streaming video/audio.

        @param bytes: The number of bytes read when this interval was fired.
        """



class IStreamManager(Interface):
    """
    """

########NEW FILE########
__FILENAME__ = codec
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
RTMP codecs. Encoders and decoders for RTMP streams.

This module purposefully does not have third party dependencies (save for PyAMF,
which does all the byte packing).

The Encoder/Decoder is not thread safe.

@see: U{RTMP<http://dev.rtmpy.org/wiki/RTMP>}
@todo: Provide a way to introspect the 'state' of the codec to allow admin type
   facilities. To be worked out in the future.
"""

import collections

from pyamf.util import BufferedByteStream

from rtmpy.protocol.rtmp import header
from rtmpy import message



__all__ = [
    'Encoder',
    'Decoder',
    'DecodeError',
    'EncodeError',
    'StreamingChannel'
]



#: The default number of bytes per RTMP frame (excluding header)
FRAME_SIZE = 128
#: Maximum number of channels that can be active per RTMP connection
MAX_CHANNELS = 0xffff + 64 - 2
#: An RTMP channel with an id of 0 is special as it is considered the control
#  stream. It cannot be deleted and is integral to the RTMP protocol.
COMMAND_CHANNEL_ID = 0



class BaseError(Exception):
    """
    Base error class for all things C{codec}.
    """



class DecodeError(BaseError):
    """
    Raised if there is an error decoding an RTMP byte stream.
    """



class EncodeError(BaseError):
    """
    Raised if there is an error encoding an RTMP byte stream.
    """



class BaseChannel(object):
    """
    Marshals data in and out of RTMP frames.

    @ivar channelId: The id that this channel has been assigned (duh?!)
    @type channelId: C{int}
    @ivar header: The calculated header for this channel. RTMP can send
        relative headers, which will be merged with the previous headers to
        calculate the absolute values for the header.
    @type header: L{header.Header} or C{None}
    @ivar stream: The byte container which frames are marshalled.
    @type stream: L{BufferedByteStream}
    @ivar frameSize: The maximum number of bytes of an RTMP frame.
    @type frameSize: C{int}
    @ivar frameRemaining: The amount of data that needs to be received before
        a frame can be considered complete.
    @type frameRemaining: C{int}
    @ivar bytes: The total number of bytes that this channel has read/written
        since the last reset.
    @type bytes: C{int}
    """


    def __init__(self, channelId, stream, frameSize):
        self.channelId = channelId
        self.stream = stream
        self.frameSize = frameSize
        self.bytes = 0
        self.timestamp = 0
        self._lastDelta = 0

        self.header = None


    def reset(self):
        self.bytes = 0
        self._bodyRemaining = -1
        self.frameRemaining = self.frameSize


    def complete(self):
        """
        Whether this channel has completed its content length requirements.
        """
        return self._bodyRemaining == 0


    def setHeader(self, new):
        """
        Applies a new header to this channel. If this channel already has a
        header, then the new values are merged with the existing.

        @param new: The header to apply to this channel.
        @type new: L{header.Header}
        @return: The previous header, if there is one.
        @rtype: L{header.Header} or C{None}
        """
        old = self.header

        if self.header is None:
            self.header = new
        else:
            self.header = header.merge(self.header, new)

        if new.timestamp == -1:
            # receiving a new message and no timestamp has been supplied means
            # we use the last known
            if self.bytes == 0:
                self.setTimestamp(self._lastDelta, True)
        else:
            if not new.continuation:
                self.setTimestamp(new.timestamp, not new.full)

        self._bodyRemaining = self.header.bodyLength - self.bytes

        return old


    def marshallFrame(self, size):
        """
        Marshalls an RTMP frame from the C{stream}.

        Must be implemented by subclasses.

        @param size: The number of bytes to be marshalled.
        """
        raise NotImplementedError


    def marshallOneFrame(self):
        """
        Marshalls one RTMP frame and adjusts internal counters accordingly.
        Calls C{marshallFrame} which subclasses must implement.
        """
        frameSize = self.frameSize
        l = min(self.frameRemaining, frameSize, self._bodyRemaining)

        ret = self.marshallFrame(l)

        self.bytes += l
        self._bodyRemaining -= l

        while l >= frameSize:
            l -= frameSize

        self.frameRemaining -= l

        return ret


    def setFrameSize(self, size):
        """
        Sets the size of the RTMP frame for this channel.

        @param size: The new size of the RTMP frame.
        @type size: C{int}
        """
        if self.frameRemaining >= self.frameSize:
            self.frameRemaining = size

        self.frameSize = size


    def setTimestamp(self, timestamp, relative=True):
        """
        Sets the timestamp for this stream. The timestamp is measured in
        milliseconds since an arbitrary epoch. This could be since the stream
        started sending or receiving audio/video etc.

        @param relative: Whether the supplied timestamp is relative to the
            previous.
        """
        if relative:
            self._lastDelta = timestamp
            self.timestamp += timestamp
        else:
            if self.timestamp == 0:
                self._lastDelta = timestamp

            self.timestamp = timestamp


    def __repr__(self):
        s = []
        attrs = ['channelId', 'frameRemaining', 'bytes']

        if self.header is None:
            s.append('header=None')
        else:
            s.append('channelId=%r' % (self.channelId,))
            s.append('datatype=%r' % (self.header.datatype,))

        for a in attrs:
            if not hasattr(self, a):
                continue

            s.append('%s=%r' % (a, getattr(self, a)))

        return '<%s.%s %s at 0x%x>' % (
            self.__class__.__module__,
            self.__class__.__name__,
            ' '.join(s),
            id(self)
        )



class ConsumingChannel(BaseChannel):
    """
    Reads RTMP frames.
    """


    def marshallFrame(self, size):
        """
        Reads an RTMP frame from the stream and returns the content of the body.

        If there is not enough data to fulfill the frame requirements then
        C{IOError} will be raised.
        """
        return self.stream.read(size)



class ProducingChannel(BaseChannel):
    """
    Writes RTMP frames.

    @ivar buffer: Any data waiting to be written to the underlying stream.
    @type buffer: L{BufferedByteStream}
    @ivar acquired: Whether this channel is acquired. See L{ChannelMuxer.
        acquireChannel}
    """


    def __init__(self, channelId, stream, frameSize):
        BaseChannel.__init__(self, channelId, stream, frameSize)

        self.buffer = BufferedByteStream()
        self.acquired = False
        self.callback = None


    def setCallback(self, cb):
        """
        Sets the callback that will be fired once this channel has been completely
        encoded.
        """
        self.callback = cb


    def reset(self):
        """
        Called when the channel has completed writing the buffer.
        """
        BaseChannel.reset(self)

        self.buffer.seek(0)
        self.buffer.truncate()
        self.header = None


    def append(self, data):
        """
        Appends data to the buffer in preparation of encoding in RTMP.
        """
        self.buffer.append(data)


    def marshallFrame(self, size):
        """
        Writes a section of the buffer as part of the RTMP frame.
        """
        self.stream.write(self.buffer.read(size))



class Codec(object):
    """
    Generic channels and frame operations.

    @ivar stream: The underlying buffer containing the raw bytes.
    @type stream: L{BufferedByteStream}
    @ivar channels: A L{dict} of L{BaseChannel} objects that are handling data.
    @ivar frameSize: The maximum size for an individual frame. Read-only, use
        L{setFrameSize} instead.
    """


    def __init__(self, stream=None):
        self.stream = stream or BufferedByteStream()

        self.channels = {}
        self.frameSize = FRAME_SIZE
        self.bytes = 0


    def setFrameSize(self, size):
        """
        Set the size of the next frame to be handled.
        """
        self.frameSize = size

        for channel in self.channels.values():
            channel.setFrameSize(size)


    def buildChannel(self, channelId):
        """
        Called to build a channel suitable for use with this codec.

        Must be implemented by subclasses.
        """
        raise NotImplementedError


    def getChannel(self, channelId):
        """
        Returns a channel based on channelId. If the channel doesn't exist,
        then one is created.

        @param channelId: Index for the channel to retrieve.
        @type channelId: C{int}
        @rtype: L{Channel}
        """
        channel = self.channels.get(channelId, None)

        if channel is not None:
            return channel

        if channelId > MAX_CHANNELS:
            raise IndexError('Attempted to get channelId %d which is > %d' % (
                channelId, MAX_CHANNELS))

        channel = self.buildChannel(channelId)
        self.channels[channelId] = channel

        channel.reset()

        return channel



class FrameReader(Codec):
    """
    A generator object that decodes RTMP frames from a data stream. Feed it data
    via L{send} and then iteratively call L{next}.

    A frame consists of a header and then a chunk of data. Each header will
    contain the channel that the frame is destined for. RTMP allows multiple
    channels to be interleaved together.
    """


    _currentChannel = None


    def buildChannel(self, channelId):
        """
        Builds a channel object that is capable of marshalling frames from the
        stream.
        """
        return ConsumingChannel(channelId, self.stream, self.frameSize)


    def readHeader(self):
        """
        Reads an RTMP header from the stream.

        @rtype: L{header.Header}
        """
        orig_pos = self.stream.tell()

        try:
            return header.decode(self.stream)
        except IOError:
            raise
        except Exception:
            # something went wrong, lets dump out the state of the decoder so
            # we might have a chance to debug what's going on
            boom_pos = self.stream.tell()

            self.stream.seek(orig_pos)

            # yes, print, bog off :P
            print 'Attempted to decode header for %r' % (self._currentChannel,)
            print 'Stream bytes was: %r' % (
                self.stream.read(boom_pos - orig_pos + 1),)

            print 'Channel state: %r' % (self.channels,)

            raise


    def send(self, data):
        """
        Adds more data to the stream for the reader to consume.
        """
        self.stream.append(data)


    def readFrame(self):
        """
        Called to pull the next RTMP frame out of the stream. A tuple containing
        three items is returned::

         * the raw bytes for the frame
         * whether the channel is considered complete (i.e. all the data has been
           received)
         * An L{IChannelMeta} instance.

        If an attempt to read from the stream comes to a natural end then
        C{StopIteration} is raised, otherwise C{IOError}.
        """
        pos = self.stream.tell()
        channel = self._currentChannel

        if channel is None:
            try:
                h = self.readHeader()
            except IOError:
                self.stream.seek(pos, 0)

                raise

            new_pos = self.stream.tell()
            self.bytes += new_pos - pos
            pos = new_pos

            channel = self._currentChannel = self.getChannel(h.channelId)

            channel.setHeader(h)

        try:
            bytes = channel.marshallOneFrame()
        except IOError:
            self.stream.seek(pos, 0)

            raise
        else:
            self._currentChannel = None

        self.bytes += self.stream.tell() - pos
        complete = channel.complete()
        h = channel.header

        if complete:
            h.timestamp = channel.timestamp

            channel.reset()

        return bytes, complete, h


    def abort(self, channelId):
        """
        """
        channel = self.getChannel(channelId)

        channel.reset()


    def __iter__(self):
        return self



class ChannelDemuxer(FrameReader):
    """
    The next layer up from reading raw RTMP frames. Reassembles the interleaved
    channel data and dispatches the raw channel data when it is complete.

    There are two generic categories of channels in RTMP; streaming and
    non-streaming. Audio/Video data is considered streamable data, everything
    else is not. This means that the raw data is buffered until the channel is
    complete.

    @ivar bucket: Buffers any incomplete channel data.
    @type bucket: channel -> buffered data.
    """


    def __init__(self, stream=None):
        FrameReader.__init__(self, stream=stream)

        self.bucket = {}


    def readFrame(self):
        """
        Read an RTMP frame and buffer the data (if necessary) until the channel
        is considered complete.

        Return a tuple containing:

        * the raw bytes for the channel
        * The associated L{IChannelMeta} instance

        C{None, None} will be returned if a frame was read, but no channel was
        complete.
        """
        data, complete, meta = FrameReader.readFrame(self)

        if complete:
            data = self.bucket.pop(meta.channelId, '') + data

            return data, meta

        channelId = meta.channelId

        self.bucket[channelId] = self.bucket.get(channelId, '') + data

        # nothing was available
        return None, None



class Decoder(ChannelDemuxer):
    """
    Dispatches decoded RTMP messages to a C{dispatcher}.

    At this layer, a message is a datatype, a timestamp and a blob of data. It
    is up to the dispatcher to decide how to handle the decoding of the data.

    @ivar dispatcher: Receives dispatched messages generated by the decoder.
    @type dispatcher: Provides L{interfaces.IMessageDispatcher}
    @ivar stream_factory: Builds stream listener objects.
    @type stream_factory: L{interfaces.IStreamManager}
    """


    channel_class = ConsumingChannel


    def __init__(self, dispatcher, stream_factory, stream=None,
                 bytesInterval=0):
        ChannelDemuxer.__init__(self, stream=stream)

        self.dispatcher = dispatcher
        self.stream_factory = stream_factory

        self.setBytesInterval(bytesInterval)


    def setBytesInterval(self, bytesInterval):
        """
        Sets the interval at which the decoder must inform the dispatcher that
        a threshold of decoded bytes has been reached.
        """
        self.bytesInterval = bytesInterval
        self._nextInterval = self.bytes + self.bytesInterval


    def next(self):
        """
        Iterates over the RTMP stream and dispatches decoded messages to the
        C{dispatcher}.

        This function does not return anything. Call it iteratively to pump RTMP
        messages out of the stream.

        If C{IOError} is raised, something went wrong decoding the stream,
        otherwise C{StopIteration} will be raised if the end of the stream is
        reached.
        """
        try:
            data, meta = ChannelDemuxer.readFrame(self)
        except IOError:
            self.stream.consume()

            raise StopIteration

        if self.bytesInterval and self.bytes >= self._nextInterval:
            self.dispatcher.bytesInterval(self.bytes)
            self._nextInterval += self.bytesInterval

        if data is None:
            return

        stream = self.stream_factory.getStream(meta.streamId)

        self.dispatcher.dispatchMessage(
            stream, meta.datatype, meta.timestamp, data)


    __next__ = next


class ChannelMuxer(Codec):
    """
    Manages RTMP channels and marshalls the data so that the channels can be
    interleaved.

    @ivar releasedChannels: A list of channel ids that have been released.
    @type releasedChannels: C{collections.deque}
    @ivar channelsInUse: Number of RTMP channels currently in use.
    @ivar activeChannels: A list of L{BaseChannel} objects that are active (and
        therefore unavailable)
    @ivar nextHeaders: A collection of L{header.Header}s to be applied to the
        channel the next time it is asked to marshall a frame.
    @ivar timestamps: A collection of last known timestamps for a given channel.
        If the timestamp differs then the relative value is written assuming
        that the streamId hasn't changed.
    @ivar callbacks: A collection of channel->callback (if any).
    """


    def __init__(self, stream=None):
        Codec.__init__(self, stream=stream)

        self.pending = []

        self.releasedChannels = collections.deque()
        self.activeChannels = {}
        self.channelsInUse = 0

        self.nextHeaders = {}
        self.timestamps = {}


    def buildChannel(self, channelId):
        """
        Returns a channel that is capable of receiving data and marshalling RTMP
        frames to the stream.
        """
        return ProducingChannel(channelId, self.stream, self.frameSize)


    def acquireChannel(self):
        """
        Aquires and returns the next available L{Channel} or C{None}.

        In this context, aquire means to make the channel unavailable until the
        corresponding L{releaseChannel} call is made.

        There is no control over which channel you are going to be returned.

        @rtype: L{Channel} or C{None}
        """
        try:
            channelId = self.releasedChannels.popleft()
        except IndexError:
            channelId = self.channelsInUse + 1

            if channelId > MAX_CHANNELS:
                return None

        self.channelsInUse += 1

        c = self.getChannel(channelId)
        c.acquired = True

        return c


    def releaseChannel(self, channelId):
        """
        Releases the channel such that a call to C{acquireChannel} will
        eventually return it.

        @param channelId: The id of the channel being released.
        """
        c = self.getChannel(channelId)

        if c.acquired is False:
            raise EncodeError('Attempted to release an inactive channel '
                '(channelId=%r)' % (channelId,))

        c.acquired = False
        self.releasedChannels.appendleft(channelId)
        self.channelsInUse -= 1


    def writeHeader(self, channel):
        """
        Encodes the next header for C{channel}.
        """
        h = self.nextHeaders.pop(channel, None)

        if h is not None:
            h = channel.setHeader(h)
        else:
            h = channel.header

        header.encode(self.stream, channel.header, h)


    def flush(self):
        """
        Flushes the internal buffer.
        """
        raise NotImplemented


    def _encodeOneFrame(self, channel):
        self.writeHeader(channel)
        channel.marshallOneFrame()

        c = channel.complete()

        if c is True and channel.callback is not None:
            try:
                channel.callback()
            except:
                pass

        return c


    def send(self, data, datatype, streamId, timestamp, whenDone=None):
        """
        Queues an RTMP message to be encoded. Call C{next} to do the encoding.

        @param data: The raw data that will be marshalled into RTMP frames and
            sent to the peer.
        @type data: C{str}
        @param datatype: The type of data. See C{message} for a list of known
            RTMP types.
        @type datatype: C{int}
        @param streamId: The C{NetStream} id that this message is intended for.
        @type streamId: C{int}
        @param timestamp: The current timestamp for the stream that this message
            was sent.
        @type timestamp: C{int}
        """
        if is_command_type(datatype):
            # we have to special case command types because a channel only be
            # busy with one message at a time. Command messages are always
            # written right away
            channel = self.getChannel(COMMAND_CHANNEL_ID)
        else:
            channel = self.acquireChannel()

            if not channel:
                self.pending.append((data, datatype, streamId, timestamp, whenDone))

                return

        h = header.Header(
            channel.channelId,
            timestamp - channel.timestamp,
            datatype,
            len(data),
            streamId)

        if whenDone is not None:
            channel.setCallback(whenDone)

        channel.append(data)
        self.nextHeaders[channel] = h

        if channel.channelId == COMMAND_CHANNEL_ID:
            while not self._encodeOneFrame(channel):
                pass

            channel.reset()
            self.flush()

            return

        self.activeChannels[channel] = channel.channelId


    def next(self):
        """
        Encodes one RTMP frame from all the active channels.
        """
        while self.pending and self.channelsInUse <= MAX_CHANNELS:
            self.send(*self.pending.pop(0))

        if not bool(self.activeChannels):
            raise StopIteration

        to_release = []

        for channel in self.activeChannels:
            if self._encodeOneFrame(channel):
                channel.reset()
                to_release.append(channel)

        for channel in to_release:
            self.releaseChannel(channel.channelId)
            del self.activeChannels[channel]



class Encoder(ChannelMuxer):
    """
    Encodes RTMP streams.

    Send RTMP encoded messages via L{send} and then call L{next} iteratively to
    get an RTMP stream.

    To think about::
        - Stale messages; A timestamp less than the last known timestamp.

    @ivar pending: An fifo queue of messages that are waiting to be assigned a
        channel.
    @ivar output: A C{write}able object that will receive the final encoded RTMP
        stream. The instance only needs to implement C{write} and accept 1 param
        (the data).
    """


    def __init__(self, output, stream=None):
        ChannelMuxer.__init__(self, stream=stream)

        self.output = output


    def next(self):
        """
        Called iteratively to produce an RTMP encoded stream.
        """
        ChannelMuxer.next(self)

        self.flush()


    def flush(self):
        """
        Flushes the internal buffer to C{output}.
        """
        s = self.stream.getvalue()

        self.output.write(s)
        self.stream.consume()

        self.bytes += len(s)

    @property
    def active(self):
        return bool(self.activeChannels)

    def __iter__(self):
        return self


    __next__ = next



class StreamingChannel(object):
    """
    """


    def __init__(self, encoder, streamId, output):
        self.encoder = encoder

        self.channel = self.encoder.acquireChannel()

        if self.channel is None:
            # todo: make this better
            raise RuntimeError('No streaming channel available')


        self.type = None
        self.streamId = streamId
        self.output = output
        self.stream = BufferedByteStream()

        self._lastHeader = None
        self._oldStream = self.channel.stream
        self.channel.stream = self.stream

        h = header.Header(self.channel.channelId)

        # encode a continuation header for speed
        header.encode(self.stream, h, h)

        self._continuationHeader = self.stream.getvalue()
        self.stream.consume()


    def __del__(self):
        try:
            self.channel.stream = self._oldStream
        except:
            pass


    def setType(self, type):
        self.type = type


    def sendData(self, data, timestamp):
        c = self.channel

        if timestamp < c.timestamp:
            relTimestamp = timestamp
        else:
            relTimestamp = timestamp - c.timestamp

        h = header.Header(c.channelId, relTimestamp, self.type, len(data), self.streamId)

        if self._lastHeader is None:
            h.full = True

        c.setHeader(h)
        c.append(data)

        header.encode(self.stream, h, self._lastHeader)
        self._lastHeader = h

        c.marshallOneFrame()

        while not c.complete():
            self.stream.write(self._continuationHeader)
            c.marshallOneFrame()

        c.reset()
        s = self.stream.getvalue()
        self.output.write(s)
        self.encoder.bytes += len(s)

        self.stream.consume()



def is_command_type(datatype):
    """
    Determines if the data type supplied is a command type. This means that the
    related RTMP message must be marshalled on channel id = 2.
    """
    return datatype <= message.UPSTREAM_BANDWIDTH

########NEW FILE########
__FILENAME__ = handshake
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Handshaking specific to C{RTMP}.
"""

from rtmpy.protocol import handshake, version
from rtmpy import util

__all__ = [
    'ClientNegotiator',
    'ServerNegotiator',
]


class RandomPayloadNegotiator(object):
    """
    Generate a random payload for the syn/ack packets.
    """


    protocolVersion = version.RTMP

    def buildSynPayload(self, packet):
        """
        Called to build the syn packet, based on the state of the negotiations.

        C{RTMP} payloads are just random.
        """
        packet.payload = _generate_payload()

    def buildAckPayload(self, packet):
        """
        Called to build the ack packet, based on the state of the negotiations.

        C{RTMP} payloads are just random.
        """
        packet.payload = _generate_payload()


class ClientNegotiator(RandomPayloadNegotiator, handshake.ClientNegotiator):
    """
    A client negotiator for RTMP specific handshaking.
    """


class ServerNegotiator(RandomPayloadNegotiator, handshake.ServerNegotiator):
    """
    A server negotiator for RTMP specific handshaking.
    """


def _generate_payload():
    return util.generateBytes(handshake.HANDSHAKE_LENGTH - 8)

########NEW FILE########
__FILENAME__ = header
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Utility/helper functions for encoding and decoding RTMP headers.

@see: U{RTMP Packet Structure on OSFlash<http://osflash.org/documentation/rtmp
    #rtmp_packet_structure>}
"""

__all__ = [
    'Header',
    'encode',
    'decode',
    'merge'
]


class HeaderError(Exception):
    """
    Raised if a header related operation failed.
    """


class Header(object):
    """
    An RTMP Header. Holds contextual information for an RTMP Channel.
    """

    __slots__ = ('streamId', 'datatype', 'timestamp', 'bodyLength',
        'channelId', 'full', 'continuation')

    def __init__(self, channelId, timestamp=-1, datatype=-1,
                 bodyLength=-1, streamId=-1, full=False, continuation=False):
        self.channelId = channelId
        self.timestamp = timestamp
        self.datatype = datatype
        self.bodyLength = bodyLength
        self.streamId = streamId
        self.full = full
        self.continuation = continuation

    def __repr__(self):
        attrs = []

        for k in self.__slots__:
            v = getattr(self, k, None)

            if v == -1:
                v = None

            attrs.append('%s=%r' % (k, v))

        return '<%s.%s %s at 0x%x>' % (
            self.__class__.__module__,
            self.__class__.__name__,
            ' '.join(attrs),
            id(self))


def encode(stream, header, previous=None):
    """
    Encodes a RTMP header to C{stream}.

    We expect the stream to already be in network endian mode.

    The channel id can be encoded in up to 3 bytes. The first byte is special as
    it contains the size of the rest of the header as described in
    L{getHeaderSize}.

    0 >= channelId > 64: channelId
    64 >= channelId > 320: 0, channelId - 64
    320 >= channelId > 0xffff + 64: 1, channelId - 64 (written as 2 byte int)

    @param stream: The stream to write the encoded header.
    @type stream: L{util.BufferedByteStream}
    @param header: The L{Header} to encode.
    @param previous: The previous header (if any).
    """
    if previous is None:
        mask = 0
    else:
        if header.continuation:
            mask = 0xc0
        else:
            mask = get_size_mask(header, previous)

    channelId = header.channelId + 2

    if channelId < 64:
        stream.write_uchar(mask | channelId)
    elif channelId < 320:
        stream.write_uchar(mask)
        stream.write_uchar(channelId - 64)
    else:
        channelId -= 64

        stream.write_uchar(mask + 1)
        stream.write_uchar(channelId & 0xff)
        stream.write_uchar(channelId >> 0x08)

    if mask == 0xc0:
        return

    if mask <= 0x80:
        if header.timestamp >= 0xffffff:
            stream.write_24bit_uint(0xffffff)
        else:
            stream.write_24bit_uint(header.timestamp)

    if mask <= 0x40:
        stream.write_24bit_uint(header.bodyLength)
        stream.write_uchar(header.datatype)

    if mask == 0:
        stream.endian = '<'
        stream.write_ulong(header.streamId)
        stream.endian = '!'

    if mask <= 0x80:
        if header.timestamp >= 0xffffff:
            stream.write_ulong(header.timestamp)


def decode(stream):
    """
    Reads a header from the incoming stream.

    A header can be of varying lengths and the properties that get updated
    depend on the length.

    @param stream: The byte stream to read the header from.
    @type stream: C{pyamf.util.BufferedByteStream}
    @return: The read header from the stream.
    @rtype: L{Header}
    """
    # read the size and channelId
    channelId = stream.read_uchar()
    bits = channelId >> 6
    channelId &= 0x3f

    if channelId == 0:
        channelId = stream.read_uchar() + 64

    if channelId == 1:
        channelId = stream.read_uchar() + 64 + (stream.read_uchar() << 8)

    header = Header(channelId - 2)

    if bits == 3:
        header.continuation = True

        return header

    header.timestamp = stream.read_24bit_uint()

    if bits < 2:
        header.bodyLength = stream.read_24bit_uint()
        header.datatype = stream.read_uchar()

    if bits < 1:
        # streamId is little endian
        stream.endian = '<'
        header.streamId = stream.read_ulong()
        stream.endian = '!'

        header.full = True

    if header.timestamp == 0xffffff:
        header.timestamp = stream.read_ulong()

    return header


def merge(old, new):
    """
    Merge the values of C{new} and C{old} together, returning the result.

    @type old: L{Header}
    @type new: L{Header}
    @rtype: L{Header}
    """
    if old.channelId != new.channelId:
        raise HeaderError('channelId mismatch on merge old=%r, new=%r' % (
            old.channelId, new.channelId))

    # what to do about full/continuation flags?
    merged = Header(new.channelId)

    if new.streamId != -1:
        merged.streamId = new.streamId
    else:
        merged.streamId = old.streamId

    if new.bodyLength != -1:
        merged.bodyLength = new.bodyLength
    else:
        merged.bodyLength = old.bodyLength

    if new.datatype != -1:
        merged.datatype = new.datatype
    else:
        merged.datatype = old.datatype

    if new.timestamp != -1:
        merged.timestamp = new.timestamp
    else:
        merged.timestamp = old.timestamp

    return merged


def get_size_mask(old, new):
    """
    Returns the number of bytes needed to de/encode the header based on the
    differences between the two.

    Both headers must be from the same channel.

    @type old: L{Header}
    @type new: L{Header}
    """
    if old is new:
        return 0xc0

    if old.channelId != new.channelId:
        raise HeaderError('channelId mismatch on diff old=%r, new=%r' % (
            old, new))

    if old.streamId != new.streamId:
        return 0 # full header

    if old.datatype == new.datatype and old.bodyLength == new.bodyLength:
        if old.timestamp == new.timestamp:
            return 0xc0

        return 0x80

    return 0x40

########NEW FILE########
__FILENAME__ = version
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
"""

MAX_VERSION = 31
RTMP = 0x03

implementations = {
    RTMP: 'rtmp'
}


def get(version, default=None):
    return implementations.get(version, default)

########NEW FILE########
__FILENAME__ = rpc
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
API for handling RTMP RPC calls.
"""

from zope.interface import implements
from twisted.python import failure, log
from twisted.internet import defer

from rtmpy import message, exc, status



__all__ = [
    'expose',
    'CommandResult',
    'AbstractCallHandler',
]


#: The id for an RPC call that does not require or expect a response.
NO_RESULT = 0

#: The name of the response for a successful RPC call
RESPONSE_RESULT = '_result'
#: The name of the response for an RPC call that did not succeed.
RESPONSE_ERROR = '_error'



class RemoteCallFailed(failure.Failure):
    """
    A specific failure type when an RPC returns an error response.
    """



class CommandResult(object):
    """
    This is an RPC result object that contains the actual response to the RPC
    call and a command object that gets encoded as part of the RTMP message.
    """


    def __init__(self, result, command):
        self.result = result
        self.command = command



class ResultWithCallback(object):
    """
    An RPC result object what will fire callback once the result has been sent.
    """


    def __init__(self, result, callback):
        self.result = result
        self.callback = callback


    def __cmp__(self, other):
        return cmp(self.result, other)



def expose(func):
    """
    A decorator that provides an easy way to expose methods that the peer can
    'call' via RTMP C{invoke} or C{notify} messages.

    Example usage::

        class SomeClass:
            @expose
            def someRemoteMethod(self, foo, bar):
                pass

            @expose('foo-bar')
            def anotherExposedMethod(self, *args):
                pass

    If expose is called with no args, the function name is used.
    """
    import sys

    def add_meta(locals, exposed_name, func_name=None):
        methods = locals.setdefault('__exposed__', {})

        methods[exposed_name] = func_name or exposed_name


    if callable(func):
        frame = sys._getframe(1)
        add_meta(frame.f_locals, func.__name__)

        return func


    def decorator(f):
        frame = sys._getframe(1)
        add_meta(frame.f_locals, func, f.__name__)

        return f

    return decorator



def after(cb):
    """
    Used as a decorator around a function that will return a result to the RPC
    mechanism.

    Once the result has been dispatched to the client, C{cb} will be fired.
    """
    def wrapped(func):
        def wrapper(*args, **kwargs):
            result = func(*args, **kwargs)

            return ResultWithCallback(result, cb)

        return wrapper

    return wrapped


def getExposedMethods(cls):
    """
    Returns a C{dict} of C{exposed name} to C{class method name} for the given
    class object.

    The results of this function are stored on the class in the
    C{__exposed_mro__} slot.

    The class mro is used to descend into the class hierarchy.
    """
    methods = cls.__dict__.get('__exposed_mro__', None)

    if methods is not None:
        return methods

    import inspect

    ret = {}

    for i in inspect.getmro(cls):
        methods = i.__dict__.get('__exposed__', None)

        if methods is not None:
            ret.update(methods)

    cls.__exposed_mro__ = ret

    return ret



def callExposedMethod(obj, name, *args, **kwargs):
    """
    Calls an exposed methood on C{obj}. If the method is not exposed,
    L{exc.CallFailed} will be raised.

    @return: The result of the called method.
    """
    cls = obj.__class__

    methods = getExposedMethods(cls)

    try:
        methodName = methods[name]
        method = getattr(obj, methodName)
    except Exception, e:
        if isinstance(e, AttributeError):
            log.err("'%s' is exposed but %r does not exist on %r " % (
                name, methodName, obj))

        raise exc.CallFailed("Method not found (%s)" % (name,))

    return method(*args, **kwargs)



class BaseCallHandler(object):
    """
    Provides the ability to initiate, track and finish RPC calls. Each RPC call
    is given a unique id.

    Once a call is I{finished}, it is forgotten about. Call ids cannot be
    reused.

    @ivar strict: Whether response/requests should be handled strictly. This is
        focussed around the callId of the request/response rpc.
    @ivar _lastCallId: The value of the last initiated RPC call.
    @type _lastCallId: C{int}
    @ivar _activeCalls: A C{dict} of callId -> context. An active call has been
        I{initiated} but not yet I{finished}.
    """


    def __init__(self, strict=True):
        self._lastCallId = 0
        self._activeCalls = {}

        self.strict = strict


    def isCallActive(self, callId):
        """
        Whether the C{callId} is a valid identifier for a call awaiting a
        result.
        """
        return callId in self._activeCalls


    def getNextCallId(self):
        """
        Returns the next call id that will be returned by L{initiateCall}.

        This method is useful for unit testing.
        """
        return self._lastCallId + 1


    def getCallContext(self, callId):
        """
        Returns the context stored when L{initiateCall} was executed.

        If no active call is found, C{None} will be returned in its place.

        @param callId: The call id returned by the corresponding call to
            L{initiateCall}.
        @rtype: C{tuple} or C{None} if the call is not active.
        @note: Useful for unit testing.
        """
        return self._activeCalls.get(callId, None)


    def initiateCall(self, *args, **kwargs):
        """
        Starts an RPC call and stores any context for the call for later
        retrieval. The call will remain I{active} until L{finishCall} is called
        with the same C{callId}.

        @param args: The context to be stored whilst the call is active.
        @return: A id that uniquely identifies this call.
        @rtype: C{int}
        """
        callId = kwargs.get('callId', None)

        if callId == NO_RESULT:
            return callId

        if callId is None:
            callId = self._lastCallId = self.getNextCallId()
        elif self.isCallActive(callId):
            raise exc.CallFailed(
                'Unable to initiate an already active call %r' % (callId,))

        self._activeCalls[callId] = args

        return callId


    def finishCall(self, callId):
        """
        Called to finish an active RPC call. The RPC call completed successfully
        (with some sort of response).

        @param callId: The call id returned by the corresponding call to
            L{initiateCall} that uniquely identifies the call.
        @return: The context with which this call was initiated or C{None} if no
            active call could be found.
        """
        return self._activeCalls.pop(callId, None)


    def discardCall(self, callId):
        """
        Called to discard an active RPC call. The RPC call was not completed
        successfully.

        The semantics of this method is different to L{finishCall}, it is useful
        for clearing up any active calls that failed for some arbitrary reason.

        @param callId: The call id returned by the corresponding call to
            L{initiateCall} that uniquely identifies the call.
        @return: The context with which this call was initiated or C{None} if no
            active call could be found.
        """
        return self._activeCalls.pop(callId, None)



class AbstractCallHandler(BaseCallHandler):
    """
    Provides an API to make RPC calls and handle the response.
    """

    implements(message.IMessageSender)


    # IMessageSender
    def sendMessage(self, msg, whenDone=None):
        """
        Sends a message. Must be implemented by subclasses.

        @param msg: L{message.IMessage}
        """
        raise NotImplementedError


    def call(self, name, *args, **kwargs):
        """
        Builds and sends an RPC call to the receiving endpoint.

        By default, this is a B{fire-and-forget} method, no result is expected
        or will be returned.

        If C{notify=True} is supplied, a L{defer.Deferred} is returned that
        waits for a result. If an error notification is received then the
        C{errback} will be fired.

        @param name: The name of the method to invoke on the receiving endpoint.
        @type name: C{str}
        @param args: The list of arguments to be invoked.
        @param kwargs['command']: The command arg to be sent as part of the RPC
            call. This should only be used in advanced cases and should
            generally be left alone unless you know what you're doing.
        @param kwargs['notify']: Return a L{defer.Deferred} which will hold the
            result of the call.
        @return: By default, C{None} but if C{notify=True} is supplied, a
            L{defer.Deferred} that will hold the result of the call.
        """
        command = kwargs.get('command', None)
        notify = kwargs.get('notify', False)

        if not notify:
            msg = message.Invoke(name, NO_RESULT, command, *args)

            self.sendMessage(msg)

            return

        d = defer.Deferred()
        callId = self.initiateCall(d, name, args, command)
        m = message.Invoke(name, callId, command, *args)

        try:
            self.sendMessage(m)
        except:
            self.discardCall(callId)

            raise

        return d


    def handleResponse(self, name, callId, result, **kwargs):
        """
        Handles the response to a previously initiated RPC call.

        @param name: The name of the response.
        @type name: C{str}
        @param callId: The tracking identifier for the called method.
        @type callId: C{int}
        @param result: The arguments supplied with the response.
        @return: C{None}
        """
        command = kwargs.get('command', None)
        callContext = self.finishCall(callId)

        if callContext is None:
            if callId == NO_RESULT:
                log.msg('Attempted to handle an RPC response when one was not '
                    'expected.')
                log.msg('Response context was %r%r' % (name, result))
            else:
                log.msg('Unknown RPC callId %r for %r with result %r' % (
                    callId, name, result))

            return

        d, originalName, originalArgs, originalCommand = callContext

        if command is not None:
            log.msg('Received command of %r with result %r' % (command, result))
            log.msg('In response to %r%r' % (originalName, originalArgs))

        # handle the response
        if name == RESPONSE_RESULT:
            d.callback(result)
        elif name == RESPONSE_ERROR:
            d.errback(RemoteCallFailed(result))
        else:
            log.msg('Unknown response type %r' % (name,))
            log.msg('Result = %r' % (result,))
            log.msg('Original call was %r%r with command %r' % (
                originalName, originalArgs, originalCommand))

        return d


    def callReceived(self, name, callId, *args):
        """
        Called when an RPC request as been made. Determines which locally
        exposed method to call and then returns a L{defer.Deferred} which
        handles the result.

        RPC methods can return a L{CommandResult} which will supply the command
        arg to the message.

        @param name: The name of the exposed method to be called.
        @type name: C{str}
        @param callId: The callId for the RPC request.
        @type callId: C{int}
        @param args: The args to be called on the exposed method.
        @return: A L{defer.Deferred} containing the result of the call.
        """
        def cb(result):
            if callId == NO_RESULT:
                return result

            self.finishCall(callId)
            command = None
            whenDone = None

            if isinstance(result, CommandResult):
                command = result.command
                result = result.result

            if isinstance(result, ResultWithCallback):
                whenDone = result.callback
                result = result.result

            msg = message.Invoke(RESPONSE_RESULT, callId, command, result)

            self.sendMessage(msg, whenDone=whenDone)

            return result


        def eb(fail):
            if callId == NO_RESULT:
                return fail

            self.finishCall(callId)

            whenDone = None

            if isinstance(fail, ResultWithCallback):
                whenDone = fail.callback
                fail = fail.result

            error = status.fromFailure(fail, exc.CallFailed)
            msg = message.Invoke(RESPONSE_ERROR, callId, None, error)

            self.sendMessage(msg, whenDone=whenDone)

            return fail


        try:
            self.initiateCall(name, callId=callId, *args)
        except:
            return defer.fail().addErrback(eb)

        d = self.callExposedMethod(name, *args)

        d.addCallbacks(cb, eb)

        return d


    def callExposedMethod(self, name, *args):
        """
        Returns a L{defer.Deferred} that will hold the result of the called
        method.

        This api allows subclasses to hook into the calling process.

        @param name: The name of the method to call
        @param args: The supplied args from the invoke/notify call.
        """
        return defer.maybeDeferred(callExposedMethod, self, name, *args)

########NEW FILE########
__FILENAME__ = parse_dump
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Parses RTMP dumps from Wireshark - converted to c array format.

@since: 0.1.1
"""

from pyamf.util import BufferedByteStream
from rtmpy.protocol.rtmp import codec
from rtmpy import message


__all__ = ['parse_dump', 'XMLObserver']



class MissingDataError(Exception):
    """
    Raised if the dump file contains [xxxx bytes missing in capture file]
    """



def parse_dump(f, observer):
    """
    Reads a pre-recorded RTMP stream (in c array format) from C{f} and sends
    the messages to C{observer}.

    C{observer} must implement C{messageStart}, C{messageReceived} and
    C{messageComplete}. See L{XMLObserver} as an example.
    """
    recv = RTMPEndpoint('server', observer)
    send = RTMPEndpoint('client', observer)

    for label, data in read_dump(f):
        endpoint = None

        if label == 'recv':
            endpoint = recv
        elif label == 'send':
            endpoint = send

        if not endpoint:
            continue

        if data.startswith('[') and data.endswith('bytes missing in capture file]'):
            raise MissingDataError

        endpoint.dataReceived(data)

        [y for y in endpoint]



def read_dump(f):
    """
    Takes an open file object that reads c array formatted text and returns a
    generator that will return tuples containing the label for the endpoint
    (we assume the first block is from the sender, but the labelling is
    arbitrary) and the bytes sent.
    """
    to = 'send'
    buf = ''

    while True:
        line = f.readline()

        if not line:
            raise StopIteration

        line = clean_line(line)

        if line == '':
            continue

        if line.endswith('{'):
            # parse a "char peer1_188[] = {" line
            ch = line[9]
            if ch == '0':
                to = 'send'
            else:
                to = 'recv'

            buf = ''
        elif line.endswith('};'):
            buf += line[:-2]

            yield (to, parse_bytes(buf.strip()))
        else:
            buf += line



def clean_line(l):
    l = l.replace('\r\n', '')
    l = l.replace('\n', '')
    l = l.strip()

    return l



def parse_bytes(buf):
    # this could be *a lot* faster ..
    buf = buf.replace(', ', '')
    buf = buf.replace(',', '')
    buf = buf.replace('0x', 'x')

    s = ''

    for x in buf[1:].split('x'):
        s += chr(int(x, 16))

    return s



class Message(object):
    """
    An RTMP message that has a type and context.
    """

    def __init__(self, __type, **kwargs):
        self.type = __type
        self.context = kwargs



# A packet is the raw form of a Message
Packet = Message



class Stream(object):
    """
    An RTMP stream that recieves messages. Pushes all messages to the observer
    """

    def __init__(self, observer):
        self.observer = observer

    def onInvoke(self, name, id_, args, timestamp):
        m = Message('invoke', name=name, id=id_, args=args)

        self.observer.messageReceived(m)

    def onNotify(self, name, args, timestamp):
        m = Message('notify', name=name, args=args)

        self.observer.messageReceived(m)

    def onAudioData(self, data, timestamp):
        m = Message('audio', length=len(data), timestamp=timestamp)

        self.observer.messageReceived(m)

    def onVideoData(self, data, timestamp):
        m = Message('video', length=len(data), timestamp=timestamp)

        self.observer.messageReceived(m)

    def onControlMessage(self, msg, timestamp):
        m = Message('control', **msg.__dict__)

        self.observer.messageReceived(m)

    def onDownstreamBandwidth(self, bw, timestamp):
        m = Message('down_bandwidth', value=bw)

        self.observer.messageReceived(m)

    def onUpstreamBandwidth(self, bw, extra, timestamp):
        m = Message('up_bandwidth', value=bw, extra=extra)

        self.observer.messageReceived(m)

    def onBytesRead(self, value, timestamp):
        m = Message('bytes_read', value=value)

        self.observer.messageReceived(m)


class ControlStream(Stream):
    """
    A specialised stream that handles the most basic RTMP command message/s.

    In this case all we need to look out for is the frame size.
    """

    def __init__(self, observer, decoder):
        Stream.__init__(self, observer)

        self.decoder = decoder

    def onFrameSize(self, size, timestamp):
        m = Message('frame_size', size=size)

        self.observer.messageReceived(m)

        self.decoder.setFrameSize(size)



class StreamFactory(object):
    """
    Builds and manages individual RTMP streams and dispatches decoded messages
    to the stream accordingly.
    """

    def __init__(self, type, observer):
        self.streams = {}
        self.type = type
        self.observer = observer

    def getStream(self, streamId):
        s = self.streams.get(streamId, None)

        if s is not None:
            return s

        if streamId == 0:
            s = ControlStream(self.observer, self.decoder)
        else:
            s = Stream(self.observer)

        s.streamId = streamId

        self.streams[streamId] = s

        return s

    def dispatchMessage(self, stream, datatype, timestamp, data):
        p = Packet(self.type,
            streamId=stream.streamId, datatype=datatype, timestamp=timestamp)

        self.observer.messageStart(p)

        e = message.classByType(datatype)()

        e.decode(BufferedByteStream(data))

        e.dispatch(stream, timestamp)

        self.observer.messageComplete(p)

    def bytesInterval(self, bytes):
        pass



class RTMPEndpoint(object):
    """
    Represents one side of the TCP transmission. Handles the handshake and
    pushes all data to the RTMP decoder.
    """

    handshake_size = 1536 * 2 + 1

    def __init__(self, label, observer):
        self.label = label
        self.observer = observer

        self.factory = StreamFactory(self.label, self.observer)
        self.decoder = codec.Decoder(self.factory, self.factory)

        self.factory.decoder = self.decoder

        self.handshake = False
        self.buffer = ''

    def dataReceived(self, data):
        """
        """
        if not self.handshake:
            self.buffer += data

            if len(self.buffer) >= self.handshake_size:
                self.handshake = True

                data = self.buffer[self.handshake_size:]
                del self.buffer

        if self.handshake:
            self.decoder.send(data)

    def __iter__(self):
        return self.decoder



class XMLObserver(object):
    """
    An RTMP observer that spits out an XML stream to a file object.
    """

    tag_types = (basestring, int, long)
    noisy = False

    def __init__(self, file):
        self.file = file

    def _to_xml(self, dict, shorten=False):
        s = ''

        as_tags = []

        for k, n in dict.iteritems():
            if not isinstance(n, self.tag_types):
                as_tags.append([k, n])

                continue

            s += ' %s="%s"' % (k, str(n))

        if not as_tags:
            if shorten:
                s += '/>'
            else:
                s += '>'
        else:
            s += '>\n'

            for k, v in as_tags:
                s += '  <%s>%r</%s>\n' % (k, v, k)

        return s

    def messageStart(self, packet):
        xml = '<message from="%s"%s' % (
            packet.type, self._to_xml(packet.context))

        self.file.write(xml + '\n')

    def messageReceived(self, message):
        xml = ' <%s%s' % (message.type, self._to_xml(message.context, True))

        if not xml.endswith('/>'):
            xml += ' </%s>' % (message.type,)

        xml += '\n'

        self.file.write(xml)

    def messageComplete(self, packet):
        self.file.write('</message>\n')


def run():
    import sys

    observer = XMLObserver(sys.stdout)

    f = open(sys.argv[1], 'rb')

    try:
        parse_dump(f, observer)
    except MissingDataError:
        print('Dump file is corrupt - missing data?')
        raise SystemExit(1)
    finally:
        f.close()

########NEW FILE########
__FILENAME__ = server
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Server implementation.
"""
import urlparse

from zope.interface import Interface, Attribute, implements
from twisted.internet import protocol, defer
from twisted.python import failure, log
import pyamf

from rtmpy import util, exc, versions
from rtmpy import message, rpc, status, core
from rtmpy.protocol import rtmp, handshake, version
from rtmpy.status import codes


class IApplication(Interface):
    """
    An application provides business logic for connected clients and streams.
    """

    clients = Attribute("A list of clients connected to this application.")
    name = Attribute("The name of the application instance.")
    factory = Attribute("The Factory instance that this application is"
        "attached to.")
    streams = Attribute("A collection of streams that this application is "
        "currently publishing")

    def startup():
        """
        Called when the server loads the application instance. Can return a
        deferred that signals that the application has fully initialized.
        """

    def shutdown():
        """
        Called when the application is unloaded. Can return a deferred that
        signals that the application has completely shutdown. Use this to
        close database connections etc.
        """

    def rejectConnection(client, reason):
        """
        Rejects the connection from the client, C{reason} being a
        L{failure.Failure} object or a string. Once the client has been
        rejected, the connection to the client must be closed.
        """

    def acceptConnection(client):
        """
        Called when the client connection request has been accepted by this
        application.
        """

    def disconnect(client, reason=None):
        """
        Disconnects a client from the application. Returns a deferred that is
        called when the disconnection was successful.
        """

    def buildClient(protocol, params, *args):
        """
        Returns a client object linked to the protocol object.

        @param params: The connection parameters sent from the client, this
            includes items such as the connection url, and user agent
        @type params: C{dict}
        @param args: The client supplied arguments to NetConnection.connect()
        """

    # events

    def onAppStart():
        """
        Called when the application has been fully loaded by the server and is
        ready to start accepting connections.
        """

    def onAppStop(reason):
        """
        @todo - implement this feature
        """

    def onConnect(client, *args):
        """
        Called when the peer connects to an application (NetConnection.connect).

        Return a C{True}/C{False} value to accept/reject the connection request.
        Alternatively return a L{defer.Deferred} to put the request in a pending
        state.

        If C{True} is (eventually) returned, L{acceptConnection} is called,
        otherwise L{rejectConnection}.

        @param client: The client object built by L{buildClient}
        @param args: The client supplied arguments to NetConnection.connect()
        """

    def onConnectAccept(client, *args):
        """
        Called when the peer has been successfully connected to this application.

        @param client: The client object built by L{buildClient}
        @param args: The client supplied arguments to NetConnection.connect()
        """

    def onConnectReject(client, reason, *args):
        """
        Called when the application has rejected the peers connection attempt.

        @param client: The client object built by L{buildClient}
        @param args: The client supplied arguments to NetConnection.connect()
        """

    def onDisconnect(client):
        """
        Called when a client has been disconnected from the application.
        """

    def onPublish(client, stream):
        """
        Called when the stream is publishing a video/audio stream.

        @param client: The client linked to the stream.
        @param stream: The L{NetStream} making the publish request.
        """


class IPublishingStream(Interface):
    """
    The name should be enough :)
    """

    def started(self):
        """
        Publishing has now started (or resumed).
        """

    def stopped(self):
        """
        Publishing has been stopped/paused.

        @todo: Distinguish between a paused/starved stream and a stream that has
            gone away.
        """

    def videoDataReceived(data, timestamp):
        """
        A video packet has been received from the publishing stream.

        @param data: The raw video data.
        @type data: C{str}
        @param timestamp: The timestamp at which this data was received.
        """

    def audioDataReceived(data, timestamp):
        """
        An audio packet has been received from the publishing stream.

        @param data: The raw audio data.
        @type data: C{str}
        @param timestamp: The timestamp at which this data was received.
        """

    def onMetaData(data):
        """
        The meta data for the a/v stream has been updated.
        """


class Client(object):
    """
    A very basic client object that relates an application to a connected peer.
    Quite what to do with it right now is anyone's guess ..

    @param nc: The L{ServerProtocol} instance.
    @param id: The application provided unique id for this client.
    """

    def __init__(self, nc):
        self.nc = nc
        self.id = None

    def call(self, name, *args, **kwargs):
        return self.nc.call(name, *args, **kwargs)



class NetStream(core.NetStream):
    """
    A server side NetStream. Knows nothing of L{IApplication}s but interfaces
    directly with the L{ServerProtocol} (which does). A NetStream is dumb and
    defers all logic to the L{NetConnection<ServerProtocol>}.

    @param state: The state of the NetStream. Right now the only valid values
        are C{None} and C{'publishing'}.
    @param name: The name of the published stream. Use this to look up the
        stream in the application.
    @param publisher: When published, this is set to the instance that will
        receive the audio/video/meta data events from the peer. See
        L{StreamPublisher} for now.
    @type publisher: L{IPublishingStream}
    """

    def __init__(self, nc, streamId):
        core.NetStream.__init__(self, nc, streamId)

        self.state = None
        self.name = None
        self.publisher = None

    def publishingStarted(self, publisher, name):
        """
        Called when this NetStream has started publishing data from the
        connected peer.
        """
        self.publisher = publisher
        self.name = name
        self.state = 'publishing'

    @rpc.expose
    def receiveAudio(self, audio):
        """
        """

    @rpc.expose
    def receiveVideo(self, video):
        """
        """

    @rpc.expose
    def publish(self, name, type_='live'):
        """
        Called by the peer to start pushing video/audio data.

        @param name: The name of the stream to publish.
        @param type_: The type of stream to be published.
        @see: possible values for U{type_<http://www.adobe.com/livedocs/
            flashmediaserver/3.0/hpdocs/00000349.html>}
        """
        d = defer.maybeDeferred(self.nc.publishStream, self, name, type_)

        def send_status(result):
            s = None

            if isinstance(result, failure.Failure):
                code = getattr(result.value, 'code', 'NetConnection.Call.Failed')
                description = util.getFailureMessage(result) or 'Internal Server Error'

                s = status.error(code, description)
            else:
                s = status.status('NetStream.Publish.Start',
                    description='%s is now published.' % (name,),
                    clientid=self.client.id)

            self.sendStatus(s)

            return result

        d.addBoth(send_status)

        return d

    @rpc.expose
    def closeStream(self):
        """
        Called when the stream is closing.
        """
        d = defer.succeed(None)

        if self.state == 'publishing':
            d = defer.maybeDeferred(self.nc.unpublishStream, self, self.name)

            def send_status(res):
                self.sendStatus(status.status('NetStream.Unpublish.Success',
                    description='%s is now unpublished.' % (self.name,),
                    clientid=self.nc.client.id))

                return res

            d.addBoth(send_status)

        def clear_state(res):
            self.state = None

            return res

        d.addBoth(clear_state)

        return d

    def unpublish(self):
        """
        Called when the producer stream has gone away. Perform clean up here.
        """
        # todo inform the nc that the stream went away
        self.sendStatus('NetStream.Play.UnpublishNotify')

    def onVideoData(self, data, timestamp):
        """
        Called when a video packet has been received from the peer.

        Pushes the message on to the publisher.

        @param data: The raw video data.
        @type data: C{str}
        @param timestamp: The timestamp at which this message was received.
        """
        if self.publisher:
            self.publisher.videoDataReceived(data, timestamp)

    def onAudioData(self, data, timestamp):
        """
        Called when an audio packet has been received from the peer.

        Pushes the message on to the publisher.

        @param data: The raw audio data.
        @type data: C{str}
        @param timestamp: The timestamp at which this message was received.
        """
        if self.publisher:
            self.publisher.audioDataReceived(data, timestamp)

    @rpc.expose('@setDataFrame')
    def setDataFrame(self, name, meta):
        """
        Called by the peer to set the 'data frame'? Not quite sure what this is
        all about but it contains any meta data updates for the a/v.

        We hand this responsibility to the publisher.

        @param name: This appears to be the name of the event to call. It is
            always 'onMetaData'.
        @param meta: The updated meta data for the stream.
        """
        func = getattr(self.publisher, name, None)

        if func and name == 'onMetaData':
            func(meta)


    @rpc.expose('@clearDataFrame')
    def clearDataFrame(self, name):
        """
        Called by the peer to clear the metadata from a live stream.

        We hand this responsibility to the publisher.

        @param name: This appears to be the name of the event to call. It is
            always 'onMetaData'.
        """
        func = getattr(self.publisher, name, None)

        if func and name == 'onMetaData':
            func(dict())


    @rpc.expose
    def play(self, name, *args):
        d = defer.maybeDeferred(self.nc.playStream, name, self, *args)

        def cb(res):
            """
            The stream has started playing
            """
            self._audioChannel = self.nc.getStreamingChannel(self)
            self._audioChannel.setType(message.AUDIO_DATA)

            self._videoChannel = self.nc.getStreamingChannel(self)
            self._videoChannel.setType(message.VIDEO_DATA)

            self.state = 'playing'

            # wtf
            self.sendMessage(message.ControlMessage(4, 1))
            self.sendMessage(message.ControlMessage(0, 1))

            self.sendStatus('NetStream.Play.Reset',
                description='Playing and resetting %s' % (name,),
                clientid=self.nc.clientId)

            self.sendStatus('NetStream.Play.Start',
                description='Started playing %s' % (name,),
                clientid=self.nc.clientId)

            self.nc.call('onStatus', {'code': 'NetStream.Data.Start'})

            return res

        def eb(fail):
            code = getattr(fail.value, 'code', 'NetStream.Play.Failed')
            description = util.getFailureMessage(fail) or 'Internal Server Error'

            self.sendStatus(status.error(code, description))

            return fail

        d.addErrback(eb)
        d.addCallback(cb)

        self._firstPacketReceived = False

        return d

    def onMetaData(self, data):
        """
        """
        self.call('onMetaData', data)

    def videoDataReceived(self, data, timestamp):
        if not self._firstPacketReceived:
            # set the framesize
            self.nc.protocol.setFrameSize(len(data))
            self._firstPacketReceived = True

        self._videoChannel.sendData(data, timestamp)

    def audioDataReceived(self, data, timestamp):
        self._audioChannel.sendData(data, timestamp)



class NetConnection(core.NetConnection):
    """
    Server side NetConnection implementation.
    """

    objectEncoding = pyamf.AMF0

    def __init__(self, protocol):
        core.NetConnection.__init__(self, protocol)

        self.connected = False
        self.application = None
        self.clientId = None


    def buildStream(self, streamId):
        """
        """
        return NetStream(self, streamId)


    def publishStream(self, stream, streamName, type_):
        """
        Called when a L{NetStream} wants to publish a stream through this
        C{NetConnection}.

        @param stream: The L{NetStream} instance requesting the publication.
        @param streamName: The name of the stream to be published.
        @param type_: Not quite sure of the significance of this yet - valid
            values appear to be 'live', 'append', 'record'.
        """
        streamName = util.ParamedString(streamName)

        if not self.connected:
            raise exc.ConnectError('Cannot publish stream - not connected')

        d = defer.maybeDeferred(self.application.publishStream,
            self.client, stream, streamName, type_)

        def cb(publisher):
            """
            Called when the application has published the stream.

            @param publisher: L{StreamPublisher}
            """
            stream.publishingStarted(publisher, streamName)
            publisher.start()
            self.application.onPublish(self.client, stream)

            return publisher

        d.addCallback(cb)

        return d

    def unpublishStream(self, stream, streamName):
        """
        The C{stream} is unpublishing itself.

        @param stream: The stream that has unpublished itself.
        @type stream: L{NetStream}
        @param streamName: The name of the stream being unpublished. Not used.
        """
        self.application.unpublishStream(streamName, stream)

        try:
            self.application.onUnpublish(self.client, stream)
        except Exception:
            log.err()


    @rpc.expose
    def releaseStream(self, name):
        """
        Called when the stream is released. Not sure about this one.
        """


    def closeStream(self):
        """
        Called when the stream is asked to close itself.

        Since this class is considered the B{NetConnection} equivalent, we
        propagate the event to the attached application (if one exists)
        """
        if self.application:
            self.application._disconnect(self.client)


    def playStream(self, name, subscriber, *args):
        """
        """
        d = defer.Deferred()

        def whenPublished(publisher):
            publisher.addSubscriber(subscriber)

            return publisher

        self.application.whenPublished(name, d.callback)

        d.addCallback(whenPublished)

        return d


    def callExposedMethod(self, name, *args):
        """
        Used to match a callable based on the supplied name when a notify or
        invoke is encountered. Returns C{None} if not found.

        If no match is found from the superclass, the C{client} and then the
        C{application} are checked in that order.

        All methods on a client/application is considered B{public} and
        accessible by the peer.

        @see: L{rtmp.RTMPProtocol.getInvokableTarget}
        """
        # all client methods are publicly accessible
        client = getattr(self, 'client', None)

        if client:
            target = util.get_callable_target(client, name)

            if target:
                return defer.maybeDeferred(target, *args)

        return core.NetConnection.callExposedMethod(self, name, *args)


    @rpc.expose('connect')
    def onConnect(self, params, *args):
        """
        Connects this protocol instance to an application. The application has
        the power to reject the connection (see L{Application.rejectConnection})

        Will return a L{defer.Deferred} that will contain the result of the
        connection request. The return is paused until the peer has sent its
        bandwidth negotiation packets. See L{onDownstreamBandwidth}.

        @param params: The connection parameters sent from the client, this
            includes items such as the connection url, and user agent
        @type params: C{dict}
        @param args: The client supplied arguments to NetConnection.connect()
        """
        def connection_accepted(res):
            """
            Called when the application has accepted the connection
            (in principle)
            """
            oe = params.pop('objectEncoding', self.objectEncoding)

            self.objectEncoding = oe

            f = self.protocol.factory

            # begin negotiating bandwidth
            self.sendMessage(message.DownstreamBandwidth(f.downstreamBandwidth))
            self.sendMessage(message.UpstreamBandwidth(f.upstreamBandwidth, 2))

            return res

        def return_success(res):
            self.connected = True
            del self._pendingConnection

            result = status.status('NetConnection.Connect.Success',
                description='Connection succeeded.',
                objectEncoding=self.objectEncoding)

            self.sendMessage(message.ControlMessage(0, 0))

            return rpc.CommandResult(result,
                # what are these values?
                {'mode': 1, 'capabilities': 31, 'fmsVer': 'FMS/3,5,1,516'})

        def lose_connection():
            self.protocol.transport.loseConnection()


        @rpc.after(lose_connection)
        def eb(fail):
            """
            Called when an error occurred when asking the application to
            validate the connection request.
            """
            if self.application and self.client:
                self.application.onConnectReject(self.client, fail, *args)

            return status.fromFailure(fail, codes.NC_CONNECT_FAILED,
                objectEncoding=self.objectEncoding)


        def chain_errback(f):
            self._pendingConnection.errback(f)

        self._pendingConnection = defer.Deferred()

        self._pendingConnection.addCallbacks(return_success, eb)

        d = defer.maybeDeferred(self._onConnect, params, *args)

        d.addCallback(connection_accepted)
        d.addErrback(chain_errback)

        # todo: timeout for connection
        return self._pendingConnection

    def _onConnect(self, params, *args):
        """
        The business logic of connecting to the application.

        @param params: The connection parameters sent from the client, this
            includes items such as the connection url, and user agent
        @type params: C{dict}

        @param args: arguments from RTMP connect packet
        """
        if self.application:
            # This protocol has already successfully completed a connection
            # request.
            raise exc.ConnectFailed('Already connected.')

        self.application = self.protocol.factory.getApplicationWithDefault(params, *args)

        self.client = self.application.buildClient(self, params, *args)

        def cb(res):
            """
            Called with the result of the connection attempt, either C{True} or
            C{False}.
            """
            if res is False:
                raise exc.ConnectRejected('Authorization is required')

            self.application.acceptConnection(self.client)
            self.application.onConnectAccept(self.client, *args)

        d = defer.maybeDeferred(self.application.onConnect, self.client, *args)

        d.addCallback(cb)

        return d

    def sendMessage(self, msg, stream=None, whenDone=None):
        """
        """
        self.protocol.sendMessage(msg, stream or self, whenDone=whenDone)


    def getStreamingChannel(self, stream):
        return self.protocol.getStreamingChannel(stream)



class ServerProtocol(rtmp.RTMPProtocol):
    """
    Server side RTMP protocol implementation. Handles connection and stream
    management. Provides a proxy between streams and the associated application.
    """

    netconnection = NetConnection


    def buildStreamManager(self):
        return self.nc

    def versionSuccess(self):
        self.transport.write('\x03')

        rtmp.RTMPProtocol.versionSuccess(self)

    def startStreaming(self):
        """
        """
        self.nc = self.netconnection(self)

        rtmp.RTMPProtocol.startStreaming(self)


    def onConnect(self, params, *args):
        return self.nc.onConnect(params, *args)

    def onDownstreamBandwidth(self, interval, timestamp):
        """
        """
        rtmp.RTMPProtocol.onDownstreamBandwidth(self, interval, timestamp)

        if hasattr(self.nc, '_pendingConnection'):
            if not self.nc._pendingConnection.called:
                self.nc._pendingConnection.callback(None)


    def closeStream(self):
        """
        Called when the stream is asked to close itself.
        """
        self.nc.closeStream()


    def onInvoke(self,name, callId, args, timestamp):
        """
        """
        self.nc.onInvoke(name, callId, args, timestamp)


    def onNotify(self, name, args, timestamp):
        """
        """
        self.nc.onNotify(name, args, timestamp)


    def onControlMessage(self, *args):
        """
        """


    def onBytesRead(self, *args):
        """
        """



class StreamPublisher(object):
    """
    Linked to a L{NetStream} when it makes a publish request. Manages a list of
    subscribers to the stream and propagates the events when the stream produces
    them.

    @ivar stream: The publishing L{NetStream}
    @ivar client: The linked L{Client} object. Not used right now.
    @ivar subscribers: A list of subscribers that are listening to the stream.
    @ivar
    """

    implements(IPublishingStream)

    def __init__(self, stream, client):
        self.stream = stream
        self.client = client

        self.subscribers = {}
        self.meta = {}
        self.timestamp = self.baseTimestamp = 0

    def _updateTimestamp(self, timestamp):
        """
        """
        if timestamp == 0:
            self.baseTimestamp = self.timestamp

            return self.timestamp

        self.timestamp = self.baseTimestamp + timestamp

        return self.timestamp

    def addSubscriber(self, subscriber):
        """
        Adds a subscriber to this publisher.
        """
        self.subscribers[subscriber] = {
            'timestamp': self.timestamp
        }

        if self.meta:
            subscriber.onMetaData(self.meta)

    def removeSubscriber(self, subscriber):
        """
        Removes the subscriber from this publisher.
        """
        self.subscribers.pop(subscriber)

    # events called by the stream

    def videoDataReceived(self, data, timestamp):
        """
        A video packet has been received from the publishing stream.

        @param data: The raw video data.
        @type data: C{str}
        @param timestamp: The timestamp at which this data was received.
        """
        timestamp = self._updateTimestamp(timestamp)

        to_remove = []

        for subscriber, context in self.subscribers.iteritems():
            relTimestamp = max(0, timestamp - context['timestamp'])

            try:
                subscriber.videoDataReceived(data, relTimestamp)
            except:
                log.err()
                to_remove.append(subscriber)

        if to_remove:
            for subscriber in to_remove:
                self.removeSubscriber(subscriber)

    def audioDataReceived(self, data, timestamp):
        """
        An audio packet has been received from the publishing stream.

        @param data: The raw audio data.
        @type data: C{str}
        @param timestamp: The timestamp at which this data was received.
        """
        timestamp = self._updateTimestamp(timestamp)
        to_remove = []

        for subscriber, context in self.subscribers.iteritems():
            try:
                subscriber.audioDataReceived(data, timestamp - context['timestamp'])
            except:
                log.err()
                to_remove.append(subscriber)

        if to_remove:
            for subscriber in to_remove:
                self.removeSubscriber(subscriber)

    def onMetaData(self, data):
        """
        The meta data for the a/v stream has been updated.
        """
        self.meta.update(data)

        for a in self.subscribers:
            a.onMetaData(data)

    def start(self):
        pass

    def stop(self):
        pass

    def unpublish(self):
        for a in self.subscribers:
            a.unpublish()

        self.subscribers = {}


class Application(object):
    """
    The business logic behind
    """

    implements(IApplication)

    client = Client

    def __init__(self):
        self.clients = {}
        self.streams = {}
        self._streamingClients = {}
        self._pendingPublishedCallbacks = {}


    def startup(self):
        """
        Called when the application is starting up.
        """


    def shutdown(self):
        """
        Called when the application is closed.
        """


    def getStreamByName(self, name):
        """
        """
        return self.streams[name]


    def acceptConnection(self, client):
        """
        Called when this application has accepted the client connection.
        """
        self.clients[client.id] = client

    def disconnect(self, client):
        """
        Disconnects the client from the server.
        """
        self._disconnect(client)

        client.nc.protocol.transport.loseConnection()


    def _disconnect(self, client):
        """
        Removes the C{client} from this application.
        """
        publisher = self._streamingClients.pop(client, None)

        if publisher:
            name = publisher.stream.name

            try:
                self.unpublishStream(publisher, name)
            except exc.BadNameError:
                pass
            except:
                log.err()

            self.streams.pop(name, None)

        c = self.clients.pop(client.id, None)

        if c is None:
            return

        try:
            self.onDisconnect(client)
        except Exception:
            log.err()


    def buildClient(self, protocol, params, *args):
        """
        Create an instance of a subclass of L{Client}. Override this method to
        alter how L{Client} instances are created.

        @param protocol: The L{rtmp.ServerProtocol} instance.
        @param params: The connection parameters sent from the client, this
            includes items such as the connection url, and user agent
        @type params: C{dict}
        @param args: The client supplied arguments to NetConnection.connect()
        """
        c = self.client(protocol)
        c.id = util.generateBytes(9, readable=True)

        # Inject properties into the client object
        # TODO: Evaluate if these should be defined with @property in the
        #  Client class itself.
        c.application = self

        try:
            c.ip = c.nc.transport.getPeer().host
        except AttributeError:
            c.ip = None

        tcUrl = params.get('tcUrl', '')
        c.protocol = urlparse.urlparse(tcUrl)[0]
        if c.protocol == '':
            c.protocol = None

        c.pageUrl = params.get('pageUrl', None)
        c.uri = params.get('tcUrl', None)
        c.agent = params.get('flashVer', None)

        return c


    def whenPublished(self, name, cb):
        """
        Will call C{cb} when a stream has been published under C{name}

        C{cb} will be called with one argument, the stream object itself.
        """
        if not callable(cb):
            raise TypeError('cb must be callable for whenPublished')

        try:
            publisher = self.streams[name]
        except KeyError:
            cbs = self._pendingPublishedCallbacks.setdefault(name, [])

            cbs.append(cb)

            return

        try:
            cb(publisher)
        except:
            log.err()


    def _runCallbacksForPublishedStream(self, name, stream):
        """
        Iterates over the list of callables to be executed when a stream named
        C{name} is successfully published.
        """
        try:
            cbs = self._pendingPublishedCallbacks[name]
        except KeyError:
            return

        for cb in cbs:
            try:
                cb(stream)
            except:
                log.err()

        del self._pendingPublishedCallbacks[name]


    def publishStream(self, client, requestor, name, type_='live'):
        """
        The C{stream} is requesting to publish an audio/video stream under the
        name C{name}. Reject the publish request by raising an exception.

        @param client: The L{Client} requesting the publishing the stream.
        @param stream: The L{NetStream} that will receive the a/v data.
        @param name: The name of the stream that will be published.
        @param type_: Ignored for now.
        """
        stream = self.streams.get(name, None)

        if stream is None:
            # brand new publish
            stream = self.streams[name] = StreamPublisher(requestor, client)
            self._streamingClients[client] = stream

        if client.id != stream.client.id:
            raise exc.BadNameError("'%s' is already used" % (name,))

        self._runCallbacksForPublishedStream(name, stream)

        return stream


    def unpublishStream(self, name, stream):
        try:
            source = self.streams[name]
        except KeyError:
            raise exc.BadNameError("Unknown stream '%s'" % (name,))

        if source.client.id != stream.client.id:
            raise exc.BadNameError('Unable to unpublish stream')

        try:
            source.unpublish()
        except:
            log.err()

        del self.streams[name]


    def addSubscriber(self, stream, subscriber):
        """
        Adds a subscriber to a stream.

        @type stream: L{NetStream}
        @type subscriber: L{IPublishingStream}
        """
        self.streams[stream.name].addSubscriber(subscriber)

    def removeSubscriber(self, stream, subscriber):
        """
        Removes a subscriber from a stream.

        @type stream: L{NetStream}
        @type subscriber: L{IPublishingStream}
        """
        self.streams[stream.name].removeSubscriber(subscriber)

    def onAppStart(self):
        """
        Called when the application is ready to connect clients
        """

    def onConnect(self, client, *args):
        """
        Called when a connection request is made to this application. Must
        return a C{bool} (or a L{defer.Deferred} returning a C{bool}) which
        determines the result of the connection request.

        If C{False} is returned (or an exception raised) then the connection is
        rejected. The default is to accept the connection.

        @param client: The client requesting the connection.
        @type client: An instance of L{client_class}.
        """

    def onConnectAccept(self, client, *args):
        """
        Called when the peer has successfully been connected to this
        application.

        @param client: The L{Client} object representing the peer.
        @param kwargs: A dict of name/value pairs that were sent with the
            connect request.
        """

    def onConnectReject(self, client, reason, *args):
        """
        Called when a connection request has been rejected.

        @param client: The L{Client} object representing the peer.
        @param reason: A L{failure.Failure} object representing the reason why
            the client was rejected.
        @param args: The client supplied arguments to NetConnection.connect()
        """

    def onPublish(self, client, stream):
        """
        Called when a client attempts to publish to a stream.
        """

    def onUnpublish(self, client, stream):
        """
        Called when a client unpublishes a stream.
        """

    def onDisconnect(self, client):
        """
        Called when a client disconnects.
        """


class ServerFactory(protocol.ServerFactory):
    """
    RTMP server protocol factory.

    Maintains a collection of applications that RTMP peers connect and
    interact with.

    @ivar applications: A collection of active applications.
    @type applications: C{dict} of C{name} -> L{IApplication}
    @ivar _pendingApplications: A collection of applications that are pending
        activation.
    @type _pendingApplications: C{dict} of C{name} -> L{IApplication}
    """

    protocol = ServerProtocol
    handshake = handshake.ServerNegotiator

    upstreamBandwidth = 2500000L
    downstreamBandwidth = 2500000L
    fmsVer = versions.FMS_MIN_H264

    def __init__(self, applications=None):
        self.applications = {}
        self._pendingApplications = {}

        if applications:
            for name, app in applications.items():
                self.registerApplication(name, app)


    def buildHandshakeNegotiator(self, observer, output):
        """
        Returns a negotiator capable of handling server side handshakes.
        """
        return self.handshake(observer, output)


    def getApplicationWithDefault(self, params, *args):
        """
        Checks if an application exists within the static table. If an
        application cannot be found there, getApplication is called.

        @param args: arguments from RTMP connect packet
        """
        try:
            appName = params['app']
        except KeyError:
            raise exc.ConnectFailed("Bad connect packet (missing 'app' key)")

        if appName in self.applications:
            return self.applications[appName]

        app = self.getApplication(params, *args)

        if app is None:
            raise exc.InvalidApplication("Unknown application '%s'" % (appName,))

        return app

    def getApplication(self, params, *args):
        """
        Returns the active L{IApplication} instance related to C{args}. If
        there is no active application, C{None} is returned.

        @param args: arguments from RTMP connect packet
        """
        return None


    def registerApplication(self, name, app):
        """
        Registers the application to this factory instance. Returns a deferred
        which will signal the completion of the registration process.

        @param name: The name of the application. This is the name that the
            player will use when connecting to this server. An example::

            RTMP uri: http://appserver.mydomain.com/webApp; name: webApp.

        @param app: The L{IApplication} object that will interact with the
            RTMP clients.
        @return: A deferred signalling the completion of the registration
            process.
        """
        if name in self._pendingApplications or name in self.applications:
            raise exc.InvalidApplication(
                '%r is already a registered application' % (name,))

        self._pendingApplications[name] = app

        d = defer.maybeDeferred(app.startup)

        def cleanup_pending(r):
            try:
                del self._pendingApplications[name]
            except KeyError:
                raise exc.InvalidApplication('Pending application %r not found '
                    '(already unregistered?)' % (name,))

            return r

        def attach_application(res):
            self.applications[name] = app
            app.factory = self
            app.name = name

            app.onAppStart()

            return res

        d.addBoth(cleanup_pending).addCallback(attach_application)

        return d

    def unregisterApplication(self, name):
        """
        Unregisters and removes the named application from this factory. Any
        subsequent connect attempts to the C{name} will be met with an error.

        @return: A L{defer.Deferred} when the process is complete. The result
            will be the application instance that was successfully unregistered.
        """
        app = self._pendingApplications.pop(name, None)

        if app is not None:
            return defer.succeed(app)

        try:
            app = self.applications[name]
        except KeyError:
            raise exc.InvalidApplication("Unknown application '%s'" % (name,))

        # TODO: run through the attached clients and signal the app shutdown.
        d = defer.maybeDeferred(app.shutdown)

        def cb(res):
            app = self.applications.pop(name)
            app.factory = None
            app.name = None

            return app

        d.addBoth(cb)

        return d

########NEW FILE########
__FILENAME__ = codes
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.


"""
A comprehensive list of all known status codes and what they mean. In rough
alphabetical order.
"""


## Application ##

#: This information object is passed to the onAppStop event handler when
#: the application instance is about to be destroyed by the server.
APP_GC = "Application.GC"

#: The Python interpreter is low on runtime memory. This provides an
#: opportunity for the application instance to free some resources or take
#: suitable action. If the application instance runs out of memory, it is
#: unloaded and all users are disconnected. In this state, the server will not
#: invoke the Application.onDisconnect event handler or the
#: Application.onAppStop event handler.
APP_RESOURCE_LOWMEMORY = "Application.Resource.LowMemory"

#: The Python interpreter has encountered a runtime error.
APP_SCRIPT_ERROR = "Application.Script.Error"

#: The Python interpreter has encountered a runtime warning.
APP_SCRIPT_WARNING = "Application.Script.Warning"

#: This information object is passed to the onAppStop handler when the
#: application is being shut down.
APP_SHUTDOWN = "Application.Shutdown"


## NetConnection ##

#: The URI specified in the NetConnection.connect method did not specify 'rtmp'
#: as the protocol. 'rtmp' must be specified when connecting to an RTMP server.
#: Either not supported version of AMF was used (3 when only 0 is supported).
NC_CALL_BADVERSION = "NetConnection.Call.BadVersion"

#: The NetConnection.call method was not able to invoke the server-side method
#: or command.
NC_CALL_FAILED = "NetConnection.Call.Failed"

#: The application has been shut down (for example, if the application is out
#: of memory resources and must shut down to prevent the server from crashing)
#: or the server has shut down.
NC_CONNECT_APPSHUTDOWN = "NetConnection.Connect.AppShutdown"

#: The connection was closed successfully.
NC_CONNECT_CLOSED = "NetConnection.Connect.Closed"

#: The connection attempt failed.
NC_CONNECT_FAILED = "NetConnection.Connect.Failed"

#: The application name specified during connect is invalid.
NC_CONNECT_INVALID_APPLICATION = "NetConnection.Connect.InvalidApp"

#: The client does not have permission to connect to the application, the
#: application expected different parameters from those that were passed,
#: or the application name specified during the connection attempt was not
#: found on the server.
NC_CONNECT_REJECTED = "NetConnection.Connect.Rejected"

#: The connection attempt succeeded.
NC_CONNECT_SUCCESS = "NetConnection.Connect.Success"


## NetStream ##

#: A recorded stream failed to delete.
NS_CLEAR_FAILED = "NetStream.Clear.Failed"

# A recorded stream was deleted successfully.
NS_CLEAR_SUCCESS = "NetStream.Clear.Success"

#: An attempt to use a Stream method (at client-side) failed.
NS_FAILED = "NetStream.Failed"

#: Invalid arguments were passed to a NetStream method.
NS_INVALID_ARGUMENT = "NetStream.InvalidArg"

#: Playlist playback is complete.
NS_PLAY_COMPLETE = "NetStream.Play.Complete"

#: An attempt to play back a stream failed.
NS_PLAY_FAILED = "NetStream.Play.Failed"

#: Data is playing behind the normal speed.
NS_PLAY_INSUFFICIENT_BW = "NetStream.Play.InsufficientBW"

#: Playback was started.
NS_PLAY_START = "NetStream.Play.Start"

#: An attempt was made to play a stream that does not exist.
NS_PLAY_STREAMNOTFOUND = "NetStream.Play.StreamNotFound"

#: Playback was stopped.
NS_PLAY_STOP = "NetStream.Play.Stop"

#: A playlist was reset.
NS_PLAY_RESET = "NetStream.Play.Reset"

#: The initial publish to a stream was successful. This message is sent to
#: all subscribers.
NS_PLAY_PUBLISHNOTIFY = "NetStream.Play.PublishNotify"

#: An unpublish from a stream was successful. This message is sent to all
#: subscribers.
NS_PLAY_UNPUBLISHNOTIFY = "NetStream.Play.UnpublishNotify"

#: Playlist playback switched from one stream to another.
NS_PLAY_SWITCH = "NetStream.Play.Switch"

#: Flash Player detected an invalid file structure and will not try to
#: play this type of file.
NS_PLAY_FILESTRUCTUREINVALID = "NetStream.Play.FileStructureInvalid"

#: Flash Player did not detect any supported tracks (video, audio or data)
#: and will not try to play the file.
NS_PLAY_NOSUPPORTEDTRACKFOUND = "NetStream.Play.NoSupportedTrackFound"

#: An attempt was made to publish a stream that is already being published
#: by someone else.
NS_PUBLISH_BADNAME = "NetStream.Publish.BadName"

#: An attempt to publish was successful.
NS_PUBLISH_START = "NetStream.Publish.Start"

#: An attempt was made to record a read-only stream.
NS_RECORD_NOACCESS = "NetStream.Record.NoAccess"

#: An attempt to record a stream failed.
NS_RECORD_FAILED = "NetStream.Record.Failed"

#: Recording was started.
NS_RECORD_START = "NetStream.Record.Start"

#: Recording was stopped.
NS_RECORD_STOP = "NetStream.Record.Stop"

#: An attempt to unpublish was successful.
NS_UNPUBLISHED_SUCCESS = "NetStream.Unpublish.Success"

#: The subscriber has used the seek command to move to a particular
#: location in the recorded stream.
NS_SEEK_NOTIFY = "NetStream.Seek.Notify"

#: The stream doesn't support seeking.
NS_SEEK_FAILED = "NetStream.Seek.Failed"

#: The subscriber has used the seek command to move to a particular
#: location in the recorded stream.
NS_PAUSE_NOTIFY = "NetStream.Pause.Notify"

#: Publishing has stopped.
NS_UNPAUSE_NOTIFY = "NetStream.Unpause.Notify"

#: Unknown
NS_DATA_START = "NetStream.Data.Start"


## SharedObject ##

#: Read access to a shared object was denied.
SO_NO_READ_ACCESS = "SharedObject.NoReadAccess"

#: Write access to a shared object was denied.
SO_NO_WRITE_ACCESS = "SharedObject.NoWriteAccess"

#: The creation of a shared object was denied.
SO_CREATION_FAILED = "SharedObject.ObjectCreationFailed"

#: The persistence parameter passed to SharedObject.getRemote() is
#: different from the one used when the shared object was created.
SO_PERSISTENCE_MISMATCH = "SharedObject.BadPersistence"

########NEW FILE########
__FILENAME__ = test_decoder
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Decoding tests for L{rtmpy.rtmp.codec}.
"""

from twisted.trial import unittest

from pyamf.util import BufferedByteStream

from rtmpy.protocol.rtmp import codec, header


class MockChannel(object):
    """
    Pretend to be a channel
    """

    def setFrameSize(self, size):
        self.frameSize = size


class ChannelMeta(object):
    """
    Implements L{codec.IChannelMeta}
    """

    datatype = None
    channelId = None
    timestamp = None
    streamId = None

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)


class MockFrameReader(object):
    """
    Pretend to act like a L{codec.FrameReader}
    """

    @classmethod
    def __init__(cls, self, stream=None, bytesInterval=None):
        self.stream = stream
        self.bytesInterval = bytesInterval
        self.bytes = 0
        self._nextInterval = bytesInterval

    @classmethod
    def readFrame(cls, self):
        return self.events.pop(0)


class MockChannelDemuxer(MockFrameReader):
    """
    Pretend to act like a L{codec.ChannelDemuxer}
    """


class MockStreamFactory(object):
    def __init__(self, test):
        self.test = test

    def getStream(self, *args):
        return self.test.getStream(*args)


class DispatchTester(object):
    """
    """

    def __init__(self, test):
        self.test = test
        self.messages = []
        self.intervals = []

    def dispatchMessage(self, *args):
        fod = getattr(self.test, 'failOnDispatch', False)

        if fod:
            raise AssertionError('Message dispatched %r' % (args,))

        self.messages.append(args)

    def bytesInterval(self, bytes):
        self.intervals.append(bytes)


class MockStream(object):
    """
    """

    timestamp = 0


class FrameReaderTestCase(unittest.TestCase):
    """
    Tests for L{codec.FrameReader}
    """

    def setUp(self):
        self.reader = codec.FrameReader()
        self.channels = self.reader.channels
        self.stream = self.reader.stream

    def test_init(self):
        self.assertEqual(self.reader.frameSize, 128)
        self.assertEqual(self.reader.channels, {})
        self.assertEqual(self.reader.stream.getvalue(), '')

    def test_set_frame_size(self):
        self.reader.setFrameSize(500)

        self.assertEqual(self.reader.frameSize, 500)

    def test_channel_frame_size(self):
        c = self.channels[1] = MockChannel()

        self.reader.setFrameSize(500)

        self.assertEqual(c.frameSize, 500)

    def test_reset(self):
        full = header.Header(3, datatype=2, bodyLength=2, streamId=1, timestamp=10)

        header.encode(self.stream, full)
        self.stream.write('a' * 2)

        self.stream.seek(0)

        self.reader.readFrame()
        channel = self.channels[3]

        self.assertEqual(channel.bytes, 0)

    def test_send(self):
        self.assertEqual(self.stream.getvalue(), '')

        self.reader.send('foo')

        self.assertEqual(self.stream.getvalue(), 'foo')

    def test_eof(self):
        self.assertTrue(self.stream.at_eof())
        self.assertRaises(IOError, self.reader.readFrame)

    def test_ioerror_seek(self):
        self.stream.append('foo')
        self.stream.seek(1)

        self.assertEqual(self.stream.tell(), 1)
        self.assertRaises(IOError, self.reader.readFrame)

        self.assertEqual(self.stream.tell(), 1)

    def test_simple(self):
        """
        Do a sanity check for a simple 4 frame 1 channel rtmp stream.
        """
        def check_meta(meta, timestamp=10):
            self.assertEqual(meta.channelId, 3)
            self.assertEqual(meta.streamId, 1)
            self.assertEqual(meta.datatype, 2)
            self.assertEqual(meta.bodyLength, 500)
            self.assertEqual(meta.timestamp, timestamp)

        size = self.reader.frameSize

        full = header.Header(3, datatype=2, bodyLength=500, streamId=1, timestamp=10)

        header.encode(self.stream, full)
        self.stream.write('a' * size)

        header.encode(self.stream, full, full)
        self.stream.write('b' * size)

        header.encode(self.stream, full, full)
        self.stream.write('c' * size)

        header.encode(self.stream, full, full)
        self.stream.write('d' * (size - 12))

        self.stream.seek(0)
        bytes, complete, meta = self.reader.readFrame()

        self.assertEqual(bytes, 'a' * self.reader.frameSize)
        self.assertFalse(complete)
        check_meta(meta)

        bytes, complete, meta = self.reader.readFrame()

        self.assertEqual(bytes, 'b' * self.reader.frameSize)
        self.assertFalse(complete)
        check_meta(meta, 10)

        bytes, complete, meta = self.reader.readFrame()

        self.assertEqual(bytes, 'c' * self.reader.frameSize)
        self.assertFalse(complete)
        check_meta(meta, 10)

        bytes, complete, meta = self.reader.readFrame()

        self.assertEqual(bytes, 'd' * (size - 12))
        self.assertTrue(complete)
        check_meta(meta, 10)

        self.assertRaises(IOError, self.reader.readFrame)


    def test_reassign(self):
        """
        Ensure that when a channel is complete it can be repurposed via a relative
        header.
        """
        full_header = header.Header(52, datatype=2, timestamp=55,
            bodyLength=256, streamId=4)

        # only change the bodyLength and timestamp
        relative_header = header.Header(52, datatype=2, streamId=4,
            bodyLength=256, timestamp=45)

        header.encode(self.stream, full_header)
        self.stream.write('a' * self.reader.frameSize)
        header.encode(self.stream, relative_header, full_header)
        self.stream.write('b' * self.reader.frameSize)

        self.stream.seek(0)

        bytes, complete, meta = self.reader.readFrame()

        self.assertEqual(bytes, 'a' * 128)
        self.assertFalse(complete)
        self.assertEqual(meta.timestamp, 55)

        bytes, complete, meta = self.reader.readFrame()

        self.assertEqual(bytes, 'b' * 128)
        self.assertTrue(complete)
        self.assertEqual(meta.timestamp, 100)


class DeMuxerTestCase(unittest.TestCase):
    """
    Tests for L{codec.DeMuxer}
    """

    def setUp(self):
        self.patch(codec, 'FrameReader', MockFrameReader)

        self.demuxer = codec.ChannelDemuxer()

    def add_events(self, *events):
        if not hasattr(self.demuxer, 'events'):
            self.demuxer.events = []

        self.demuxer.events.extend(events)

    def test_create(self):
        self.assertEqual(self.demuxer.bucket, {})

    def test_iterate(self):
        meta = ChannelMeta(channelId=1)

        self.add_events(
            ('foo', False, meta), ('bar', False, meta), ('baz', True, meta))

        self.assertEqual(self.demuxer.readFrame(), (None, None))
        self.assertEqual(self.demuxer.bucket, {1: 'foo'})

        self.assertEqual(self.demuxer.readFrame(), (None, None))
        self.assertEqual(self.demuxer.bucket, {1: 'foobar'})

        self.assertEqual(self.demuxer.readFrame(), ('foobarbaz', meta))
        self.assertEqual(self.demuxer.bucket, {})


        
class DecoderTestCase(unittest.TestCase):
    """
    Tests for L{codec.Decoder}
    """

    def setUp(self):
        self.patch(codec, 'ChannelDemuxer', MockChannelDemuxer)

        self.dispatcher = DispatchTester(self)
        self.stream_factory = MockStreamFactory(self)
        self.decoder = codec.Decoder(self.dispatcher, self.stream_factory,
            stream=BufferedByteStream())

        self.expected_streams = None
        self.streams = {}

    def add_events(self, *events):
        if not hasattr(self.decoder, 'events'):
            self.decoder.events = []

        self.decoder.events.extend(events)

    def getStream(self, streamId):
        if self.expected_streams:
            expected = self.expected_streams.pop(0)

            self.assertEqual(expected, streamId)

        try:
            return self.streams[streamId]
        except KeyError:
            s = self.streams[streamId] = MockStream()

            return s

    def test_create(self):
        self.assertIdentical(self.decoder.stream_factory, self.stream_factory)
        self.assertIdentical(self.decoder.dispatcher, self.dispatcher)

    def test_fail_on_dispatch(self):
        m = ChannelMeta(streamId=2, timestamp=0)
        self.add_events(('foo', m))
        self.expected_streams = [2]

        self.failOnDispatch = True

        self.assertRaises(AssertionError, self.decoder.next)

    def test_do_nothing(self):
        self.add_events((None, ChannelMeta(timestamp=0)))
        self.failOnDispatch = True

        self.assertEqual(self.decoder.next(), None)

    def test_simple(self):
        meta = ChannelMeta(streamId=2, timestamp=3, datatype='bar')

        self.add_events(('foo', meta))

        self.assertEqual(self.decoder.next(), None)
        self.assertEquals(len(self.dispatcher.messages), 1)

        stream, datatype, timestamp, data = self.dispatcher.messages[0]

        self.assertIdentical(stream, self.streams[2])
        self.assertEqual(datatype, 'bar')
        self.assertEqual(timestamp, 3)
        self.assertEqual(data, 'foo')

    def test_incrementing_timestamp(self):
        t1 = ChannelMeta(streamId=2, timestamp=2)
        t2 = ChannelMeta(streamId=2, timestamp=3)

        self.add_events(('foo', t1), ('foo', t2))

        self.assertEqual(self.decoder.next(), None)
        self.assertEqual(self.decoder.next(), None)

        self.assertEqual(t1.timestamp, 2)
        self.assertEqual(t2.timestamp, 3)


class BytesIntervalTestCase(unittest.TestCase):
    """
    Tests to ensure that the dispatcher receives the correct notification
    when a specified number of bytes has been read.
    """

    def setUp(self):
        self.dispatcher = DispatchTester(self)
        self.stream_factory = MockStreamFactory(self)
        self.decoder = codec.Decoder(self.dispatcher, self.stream_factory)

    def getStream(self, streamId):
        return MockStream()

    def test_interval(self):
        self.assertEqual(self.decoder.bytes, 0)
        self.decoder.setBytesInterval(8)

        self.decoder.send('\x03\x00\x00\x00\x00\x00\x00\r\x00\x00\x00\x00')

        self.decoder.next()
        self.assertEqual(self.decoder.bytes, 12)
        self.assertEqual(self.dispatcher.intervals, [12])


########NEW FILE########
__FILENAME__ = test_encoder
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Encoding tests for L{rtmpy.protocol.rtmp.codec}.
"""

import unittest

from pyamf.util import BufferedByteStream

from rtmpy.protocol.rtmp import codec
from rtmpy import message


class BaseTestCase(unittest.TestCase):
    """
    Base functionality for other unit tests.
    """

    def setUp(self):
        self.output = BufferedByteStream()
        self.encoder = codec.Encoder(self.output)


class EncoderTestCase(BaseTestCase):
    """
    Tests for basic RTMP encoding.
    """

    def test_emtpy(self):
        self.assertRaises(StopIteration, self.encoder.next)

    def test_full(self):
        """
        Ensure that messages are queued when all channels are busy
        """
        self.encoder.channelsInUse = codec.MAX_CHANNELS

        self.encoder.send('bar', 12, 2, 3)

        self.assertEqual(self.encoder.pending, [('bar', 12, 2, 3, None)])

        self.encoder.channelsInUse -= 1
        self.encoder.next()

        self.assertEqual(self.encoder.pending, [])


class AquireChannelTestCase(BaseTestCase):
    """
    Tests for L{codec.Encoder.acquireChannel}
    """

    def test_simple(self):
        self.assertEqual(self.encoder.channelsInUse, 0)

        c = self.encoder.acquireChannel()

        self.assertTrue(isinstance(c, codec.ProducingChannel))

        self.assertEqual(c.channelId, 1)
        self.assertEqual(c.header, None)

        self.assertEqual(self.encoder.channelsInUse, 1)

    def test_overflow(self):
        """
        Attempt to acquire MAX_CHANNELS + 1 channels.
        """

        self.encoder.channelsInUse = codec.MAX_CHANNELS - 1
        self.assertNotEqual(self.encoder.acquireChannel(), None)

        self.assertEqual(self.encoder.channelsInUse, codec.MAX_CHANNELS)
        self.assertEqual(self.encoder.acquireChannel(), None)


class ReleaseChannelTestCase(BaseTestCase):
    """
    Tests for L{codec.Encoder.releaseChannel}
    """

    def test_not_aquired(self):
        self.assertRaises(codec.EncodeError, self.encoder.releaseChannel, 3)

    def test_aquired(self):
        c = self.encoder.acquireChannel()

        self.assertEqual(self.encoder.channelsInUse, 1)

        self.encoder.releaseChannel(c.channelId)

        self.assertEqual(self.encoder.channelsInUse, 0)


class WritingTestCase(BaseTestCase):
    """
    Tests for writing RTMP frames.
    """

    def test_less_than_frame(self):
        self.encoder.send('foobar', 10, 1, 0)

        self.encoder.next()

        self.assertEqual(self.output.getvalue(),
            '\x03\x00\x00\x00\x00\x00\x06\n\x01\x00\x00\x00foobar')

        self.assertRaises(StopIteration, self.encoder.next)

    def test_multiple_frames(self):
        # 3 and a bit frames at 128 bytes per frame
        self.encoder.send('a' * (128 * 3 + 50), 10, 1, 0)

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(12),
            '\x03\x00\x00\x00\x00\x01\xb2\n\x01\x00\x00\x00')
        self.assertEqual(self.output.read(), 'a' * 128)
        self.assertTrue(self.output.at_eof())

        self.output.consume()

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(1), '\xc3')
        self.assertEqual(self.output.read(), 'a' * 128)
        self.assertTrue(self.output.at_eof())

        self.output.consume()

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(1), '\xc3')
        self.assertEqual(self.output.read(), 'a' * 128)
        self.assertTrue(self.output.at_eof())

        self.output.consume()

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(1), '\xc3')
        self.assertEqual(self.output.read(), 'a' * 50)
        self.assertTrue(self.output.at_eof())

        self.assertRaises(StopIteration, self.encoder.next)

    def test_interleave(self):
        # dispatch two messages
        self.encoder.send('a' * (128 + 1), 15, 7, 0)
        self.encoder.send('b' * (128 + 50), 8, 0xfffe, 0)

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(12),
            '\x03\x00\x00\x00\x00\x00\x81\x0f\x07\x00\x00\x00')
        self.assertEqual(self.output.read(128), 'a' * 128)
        self.assertEqual(self.output.read(12),
            '\x04\x00\x00\x00\x00\x00\xb2\x08\xfe\xff\x00\x00')
        self.assertEqual(self.output.read(128), 'b' * 128)
        self.assertTrue(self.output.at_eof())
        self.output.consume()

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(1), '\xc3')
        self.assertEqual(self.output.read(1), 'a')
        self.assertEqual(self.output.read(1), '\xc4')
        self.assertEqual(self.output.read(50), 'b' * 50)
        self.assertTrue(self.output.at_eof())

    def test_reappropriate_channel(self):
        self.encoder.send('a' * 2, 8, 5, 0)

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(12),
            '\x03\x00\x00\x00\x00\x00\x02\x08\x05\x00\x00\x00')
        self.assertEqual(self.output.read(2), 'a' * 2)

        self.assertTrue(self.output.at_eof())
        self.output.consume()

        self.encoder.send('b' * 2, 9, 7, 0)

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(12),
            '\x03\x00\x00\x00\x00\x00\x02\x09\x07\x00\x00\x00')
        self.assertEqual(self.output.read(2), 'b' * 2)

        self.assertTrue(self.output.at_eof())


class TimestampTestCase(BaseTestCase):
    """
    Tests to check for relative or absolute timestamps are encoded properly
    """

    def test_simple(self):
        # data, datatype, timestamp
        self.encoder.send('', 13, 0, 0)

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(12),
            '\x03\x00\x00\x00\x00\x00\x00\r\x00\x00\x00\x00')

        self.output.truncate()
        self.encoder.send('', 7, 0, 15)

        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(),
            '\x03\x00\x00\x0f\x00\x00\x00\x07\x00\x00\x00\x00')
        self.output.truncate()

        self.encoder.send('', 7, 0, 15)
        self.encoder.next()

        self.output.seek(0)
        self.assertEqual(self.output.read(),
            '\x03\x00\x00\x00\x00\x00\x00\x07\x00\x00\x00\x00')
        self.output.truncate()


class CommandTypeTestCase(BaseTestCase):
    """
    Tests for encoding command types. These types should only be encoded on
    channel id of 2.

    @see: L{message.is_command_type}
    @note: The lack of C{next} calls in the tests. The control messages are
        immediately encoded.
    """

    def test_framesize(self):
        self.assertEqual(self.output.getvalue(), '')
        self.encoder.send('foo', message.FRAME_SIZE, 0, 10)
        self.assertEqual(self.output.getvalue(),
            '\x02\x00\x00\n\x00\x00\x03\x01\x00\x00\x00\x00foo')

    def test_bytes_read(self):
        self.assertEqual(self.output.getvalue(), '')
        self.encoder.send('bar', message.BYTES_READ, 0, 8)
        self.assertEqual(self.output.getvalue(),
            '\x02\x00\x00\x08\x00\x00\x03\x03\x00\x00\x00\x00bar')

    def test_control(self):
        self.assertEqual(self.output.getvalue(), '')
        self.encoder.send('spam', message.CONTROL, 0, 432)
        self.assertEqual(self.output.getvalue(),
            '\x02\x00\x01\xb0\x00\x00\x04\x04\x00\x00\x00\x00spam')

    def test_dsbw(self):
        self.assertEqual(self.output.getvalue(), '')
        self.encoder.send('eggs', message.DOWNSTREAM_BANDWIDTH, 0, 21)
        self.assertEqual(self.output.getvalue(),
            '\x02\x00\x00\x15\x00\x00\x04\x05\x00\x00\x00\x00eggs')

    def test_usbw(self):
        self.assertEqual(self.output.getvalue(), '')
        self.encoder.send('eggs', message.DOWNSTREAM_BANDWIDTH, 0, 21)
        self.assertEqual(self.output.getvalue(),
            '\x02\x00\x00\x15\x00\x00\x04\x05\x00\x00\x00\x00eggs')

    def test_other(self):
        self.assertEqual(self.output.getvalue(), '')
        self.encoder.send('eggs', message.INVOKE, 0, 21)
        self.assertEqual(self.output.getvalue(), '')

########NEW FILE########
__FILENAME__ = test_handshake
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Tests for L{rtmpy.protocol.handshake}.
"""

import unittest

from rtmpy.protocol import handshake
from rtmpy.util import BufferedByteStream


class HandshakeObserver(object):
    """
    Provides a link from the negotiator to the test case.
    """

    failure = None

    def __init__(self, test):
        self.buffer = BufferedByteStream()
        self.test = test

        self.test.succeeded = False

    def write(self, data):
        self.buffer.write(data)

    def handshakeSuccess(self, data):
        self.test.succeeded = True


class BaseTestCase(unittest.TestCase):
    """
    Sets up a negotiator and buffer (which will contain all the output from the
    negotiator).
    """

    negotiator_class = None
    uptime = 0
    version = 0

    def setUp(self):
        self.succeeded = False
        self.observer = HandshakeObserver(self)
        self.buffer = self.observer.buffer
        self.negotiator = self.negotiator_class(self.observer, self.buffer)


class ClientNegotiator(handshake.ClientNegotiator):
    """
    A pretend implementation of a client negotiator.
    """

    protocolVersion = 0x03

    def buildSynPayload(self, packet):
        packet.payload = 's' * (1536 - 8)

    def buildAckPayload(self, packet):
        packet.payload = 'a' * (1536 - 8)



class ClientNegotiatorTestCase(BaseTestCase):
    """
    Base class for testing L{handshake.ClientNegotiator}
    """

    negotiator_class = ClientNegotiator


class ClientSynTestCase(ClientNegotiatorTestCase):
    """
    High level tests for client syn handshake testing
    """

    def test_not_started(self):
        self.assertFalse(self.negotiator.started)
        self.assertRaises(handshake.HandshakeError,
            self.negotiator.dataReceived, ' ')

        #self.assertEqual(str(e), 'Data was received, but negotiator was not started')
        self.assertFalse(self.succeeded)

    def test_restart(self):
        self.negotiator.start(self.uptime, self.version)

        self.assertRaises(handshake.HandshakeError, self.negotiator.start,
            self.uptime, self.version)

        self.assertFalse(self.succeeded)

    def test_initiate(self):
        self.uptime = 1234
        self.version = 5678

        self.negotiator.start(self.uptime, self.version)

        self.assertEqual(self.negotiator.protocolVersion, 3)

        self.buffer.seek(0)

        # protocol version
        self.assertEqual(self.buffer.remaining(), 1536)

        self.assertEqual(self.buffer.read_ulong(), self.uptime)
        self.assertEqual(self.buffer.read_ulong(), self.version)


class ClientPeerSynTestCase(ClientNegotiatorTestCase):
    """
    Tests for when then client ack has been sent.
    """

    def setUp(self):
        ClientNegotiatorTestCase.setUp(self)

        self.negotiator.start(self.uptime, self.version)

        self.syn = self.negotiator.my_syn
        self.buffer.truncate()

    def send_peer_syn(self):
        self.negotiator.dataReceived('\xff' * 1536)

    def test_flood(self):
        self.assertRaises(handshake.HandshakeError,
            self.negotiator.dataReceived, ' ' * (1536 * 2 + 1))

        #self.assertEqual(str(e), 'Unexpected trailing data after peer ack')
        self.assertFalse(self.succeeded)

    def test_peer_syn_only(self):
        self.send_peer_syn()

        # make sure the client is still waiting
        self.assertEqual(self.buffer.getvalue(), '')
        self.assertFalse(self.succeeded)

    def test_peer_ack_uptime_failure(self):
        self.assertEqual(self.uptime, 0)

        self.send_peer_syn()

        self.negotiator.dataReceived('\x00\x00\x00\x01') # the equivalent to 1
        self.assertRaises(handshake.VerificationError,
            self.negotiator.dataReceived, '\xff' * (1536 - 4))

        #self.assertEqual(str(e), 'Received uptime is not the same')
        self.assertFalse(self.succeeded)

    def test_peer_ack_payload_failure(self):
        self.send_peer_syn()

        bad_payload = '\xff' * (1536 - 8)

        self.assertNotEqual(self.syn.payload, bad_payload)

        self.syn.encode(self.buffer)
        self.buffer.seek(0)

        self.negotiator.dataReceived(self.buffer.read(8))
        self.assertRaises(handshake.VerificationError,
            self.negotiator.dataReceived, bad_payload)

        #self.assertEqual(str(e), 'Received payload is not the same')
        #self.assertFalse(self.succeeded)

    def test_ack(self):
        self.send_peer_syn()

        self.syn.encode(self.buffer)
        self.buffer.seek(0)

        peer_ack = self.buffer.getvalue()
        self.buffer.truncate()

        self.negotiator.dataReceived(peer_ack)

        ack = self.negotiator.my_ack

        # client sends server ack
        self.assertEqual(len(self.buffer), 1536)
        self.buffer.seek(0)

        self.assertEqual(self.buffer.read(4), '\xff' * 4)
        self.assertEqual(self.buffer.read_ulong(), ack.version)

        self.assertEquals(self.buffer.read(), ack.payload)

        self.assertTrue(self.succeeded)


class ServerNegotiator(handshake.ServerNegotiator):
    """
    A pretend implementation of a server negotiator.
    """

    def buildSynPayload(self, packet):
        packet.payload = 's' * (1536 - 8)

    def buildAckPayload(self, packet):
        packet.payload = 'a' * (1536 - 8)


class ServerNegotiatorTestCase(BaseTestCase):
    """
    Base class for testing L{handshake.PeerNegotiator}
    """

    negotiator_class = ServerNegotiator

    def receive_client_syn(self):
        # uptime
        self.negotiator.dataReceived('\x00\x00\x00\x01')
        # version
        self.negotiator.dataReceived('\x01\x02\x03\x04')

        # payload
        self.negotiator.dataReceived('\xff' * (1536 - 8))


class ServerStartTestCase(ServerNegotiatorTestCase):
    """
    """

    def test_not_started(self):
        self.assertFalse(self.negotiator.started)
        self.assertRaises(handshake.HandshakeError,
            self.negotiator.dataReceived, ' ')

        self.assertFalse(self.succeeded)

    def test_restart(self):
        self.negotiator.start(self.uptime, self.version)

        self.assertRaises(handshake.HandshakeError, self.negotiator.start,
            self.uptime, self.version)

        self.assertFalse(self.succeeded)

    def test_initiate(self):
        self.uptime = 1234
        self.version = 5678

        self.negotiator.start(self.uptime, self.version)
        self.buffer.seek(0)

        self.assertEqual(self.buffer.remaining(), 1536)

        self.assertEqual(self.buffer.read_ulong(), self.uptime)
        self.assertEqual(self.buffer.read_ulong(), self.version)
        self.assertEqual(self.buffer.read(), 's' * (1536 - 8))


class ServerSynTestCase(ServerNegotiatorTestCase):
    """
    Tests for sending the server syn.
    """

    def setUp(self):
        ServerNegotiatorTestCase.setUp(self)

        self.negotiator.start(self.uptime, self.version)

        self.buffer.truncate()

    def test_receive_client_syn(self):
        self.assertEqual(self.buffer.getvalue(), '')

        self.receive_client_syn()

        self.assertEqual(len(self.buffer), 1536)

        self.buffer.seek(0)

        self.assertEqual(
            self.buffer.read_ulong(), self.negotiator.peer_syn.uptime)
        self.assertEqual(
            self.buffer.read_ulong(), self.negotiator.my_ack.version)

        self.assertEqual(self.buffer.read(), self.negotiator.my_ack.payload)
        self.assertFalse(self.succeeded)


class ServerClientAckTestCase(ServerNegotiatorTestCase):
    """
    Tests for client ack verification
    """

    def setUp(self):
        ServerNegotiatorTestCase.setUp(self)

        self.negotiator.start(self.uptime, self.version)

        self.buffer.truncate()

    def test_waiting(self):
        self.receive_client_syn()
        # make sure the client is still waiting
        self.assertFalse(self.succeeded)

    def test_peer_ack_uptime_failure(self):
        self.assertEqual(self.uptime, 0)

        self.receive_client_syn()
        self.buffer.truncate()

        self.negotiator.dataReceived('\x00\x00\x00\x01') # the equivalent to 1
        self.assertRaises(handshake.VerificationError,
            self.negotiator.dataReceived, '\xff' * (1536 - 4))

        #self.assertEqual(str(e), 'Received uptime is not the same')
        self.assertFalse(self.succeeded)

    def test_peer_ack_payload_failure(self):
        self.receive_client_syn()
        self.buffer.truncate()

        s = self.negotiator.my_syn

        self.buffer.write_ulong(s.uptime)
        self.buffer.write('\xff' * (1536 - 4))

        bad_payload = self.buffer.getvalue()
        self.buffer.truncate()

        self.assertRaises(handshake.VerificationError,
            self.negotiator.dataReceived, bad_payload)

        #self.assertEqual(str(e), 'Received payload does not match')
        self.assertFalse(self.succeeded)

    def test_ack(self):
        self.receive_client_syn()
        self.buffer.truncate()

        s = self.negotiator.my_syn

        s.encode(self.buffer)
        payload = self.buffer.getvalue()
        self.buffer.truncate()

        self.negotiator.dataReceived(payload)
        self.assertTrue(self.succeeded)

########NEW FILE########
__FILENAME__ = test_header
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Tests for L{rtmpy.rtmp.codec.header}.
"""

import unittest

from rtmpy.protocol.rtmp import header
from rtmpy import util


class HeaderTestCase(unittest.TestCase):
    """
    Tests for L{rtmp.Header}
    """

    def test_init(self):
        h = header.Header(3)

        expected_attrs = {
            'channelId': 3,
            'timestamp': -1,
            'datatype': -1,
            'bodyLength': -1,
            'streamId':-1
        }

        for k, v in expected_attrs.items():
            self.assertEqual(getattr(h, k), v)

    def test_kwargs(self):
        d = {
            'channelId': 1,
            'timestamp': 50,
            'datatype': 20,
            'bodyLength': 2000,
            'streamId': 98,
        }

        h = header.Header(**d)

        for k, v in d.items():
            self.assertEqual(getattr(h, k), v)

    def test_repr(self):
        h = header.Header(3)

        self.assertEquals(repr(h), '<rtmpy.protocol.rtmp.header.Header '
            'streamId=None datatype=None timestamp=None bodyLength=None '
            'channelId=3 full=False continuation=False at 0x%x>' % (id(h),))

        d = {
            'channelId': 1,
            'timestamp': 50,
            'datatype': 20,
            'bodyLength': 2000,
            'streamId': 98,
        }

        h = header.Header(**d)

        self.assertEquals(repr(h), '<rtmpy.protocol.rtmp.header.Header '
            'streamId=98 datatype=20 timestamp=50 bodyLength=2000 channelId=1 '
            'full=False continuation=False at 0x%x>' % (id(h),))


class EncodeTestCase(unittest.TestCase):
    """
    Tests for L{header.encode}
    """

    def setUp(self):
        self.stream = util.BufferedByteStream()

        self.reset()

    def reset(self):
        self.old = header.Header(0, 3, 4, 5, 6)
        self.new = header.Header(0, 3, 4, 5, 6)

    def assertEncoded(self, bytes):
        self.stream.seek(0, 2)
        self.stream.truncate()
        header.encode(self.stream, self.new, self.old)

        self.assertEqual(self.stream.getvalue(), bytes)

    def test_size1(self):
        self.assertEncoded('\xc2')

        self.old.channelId = self.new.channelId = 19
        self.assertEncoded('\xd5')

    def test_size4(self):
        self.new.timestamp = 10

        self.assertEncoded('\x82\x00\x00\n')

    def test_size8(self):
        self.new.bodyLength = 150
        self.assertEncoded('B\x00\x00\x03\x00\x00\x96\x04')

        self.reset()

        self.new.datatype = 7
        self.assertEncoded('B\x00\x00\x03\x00\x00\x05\x07')

        # combo
        self.reset()
        self.new.bodyLength = 150
        self.new.datatype = 7
        self.assertEncoded('B\x00\x00\x03\x00\x00\x96\x07')

    def test_size12(self):
        self.new.streamId = 15
        self.assertEncoded('\x02\x00\x00\x03\x00\x00\x05\x04\x0f\x00\x00\x00')

    def test_extended_timestamp(self):
        self.new.timestamp = 0x1000000

        self.assertEncoded('\x82\xff\xff\xff\x01\x00\x00\x00')

    def test_extended_channelid(self):
        self.old = self.new
        h = self.new

        h.channelId = 1
        self.assertEncoded('\xc3')

        h.channelId = 61
        self.assertEncoded('\xff')

        h.channelId = 62
        self.assertEncoded('\xc0\x00')

        h.channelId = 63
        self.assertEncoded('\xc0\x01')

        h.channelId = 317
        self.assertEncoded('\xc0\xff')

        h.channelId = 318
        self.assertEncoded('\xc1\x00\x01')

        h.channelId = 65597
        self.assertEncoded('\xc1\xff\xff')


class DecodeTestCase(unittest.TestCase):
    """
    Tests for L{header.decode}
    """

    def _decode(self, s):
        stream = util.BufferedByteStream(s)

        return header.decode(stream)

    def test_decodeSize1(self):
        h = self._decode('\xc3')

        self.assertEquals(h.channelId, 1)
        self.assertEquals(h.timestamp, -1)
        self.assertEquals(h.bodyLength, -1)
        self.assertEquals(h.datatype, -1)
        self.assertEquals(h.streamId, -1)

        h = self._decode('\xd5')

        self.assertEquals(h.channelId, 19)
        self.assertEquals(h.timestamp, -1)
        self.assertEquals(h.bodyLength, -1)
        self.assertEquals(h.datatype, -1)
        self.assertEquals(h.streamId, -1)

    def test_decodeSize4(self):
        h = self._decode('\x95\x03\x92\xfa')

        self.assertEquals(h.channelId, 19)
        self.assertEquals(h.timestamp, 234234)
        self.assertEquals(h.bodyLength, -1)
        self.assertEquals(h.datatype, -1)
        self.assertEquals(h.streamId, -1)

    def test_decodeSize8(self):
        h = self._decode('U\x03\x92\xfa\x00z\n\x03')

        self.assertEquals(h.channelId, 19)
        self.assertEquals(h.timestamp, 234234)
        self.assertEquals(h.bodyLength, 31242)
        self.assertEquals(h.datatype, 3)
        self.assertEquals(h.streamId, -1)

    def test_decodeSize12(self):
        h = self._decode('\x15\x03\x92\xfa\x00z\n\x03-\x00\x00\x00')

        self.assertEquals(h.channelId, 19)
        self.assertEquals(h.timestamp, 234234)
        self.assertEquals(h.bodyLength, 31242)
        self.assertEquals(h.datatype, 3)
        self.assertEquals(h.streamId, 45)

    def test_extended_timestamp(self):
        h = self._decode('\xa2\xff\xff\xff\x01\x00\x00\x00')

        self.assertEquals(h.channelId, 32)
        self.assertEquals(h.timestamp, 0x1000000)
        self.assertEquals(h.bodyLength, -1)
        self.assertEquals(h.datatype, -1)
        self.assertEquals(h.streamId, -1)

        h = self._decode('b\xff\xff\xff\x00z\n\x03\x01\x00\x00\x00')

        self.assertEquals(h.channelId, 32)
        self.assertEquals(h.timestamp, 0x1000000)
        self.assertEquals(h.bodyLength, 31242)
        self.assertEquals(h.datatype, 3)
        self.assertEquals(h.streamId, -1)

        h = self._decode(
            '"\xff\xff\xff\x00z\n\x03-\x00\x00\x00\x01\x00\x00\x00')

        self.assertEquals(h.channelId, 32)
        self.assertEquals(h.timestamp, 0x1000000)
        self.assertEquals(h.bodyLength, 31242)
        self.assertEquals(h.datatype, 3)
        self.assertEquals(h.streamId, 45)

    def test_extended_channelid(self):
        h = self._decode('\xc3')
        self.assertEqual(h.channelId, 1)

        h = self._decode('\xff')
        self.assertEqual(h.channelId, 61)

        h = self._decode('\xc0\x00')
        self.assertEqual(h.channelId, 62)

        h = self._decode('\xc0\xff')
        self.assertEqual(h.channelId, 317)

        h = self._decode('\xc1\x00\x00')
        self.assertEqual(h.channelId, 62)

        h = self._decode('\xc1\x01\x00')
        self.assertEqual(h.channelId, 63)

        h = self._decode('\xc1\xff\x00')
        self.assertEqual(h.channelId, 317)

        h = self._decode('\xc1\x00\x01')
        self.assertEqual(h.channelId, 318)

        h = self._decode('\xc1\xff\xff')
        self.assertEqual(h.channelId, 65597)


class MergeTestCase(unittest.TestCase):
    """
    Tests for L{header.merge}
    """

    def setUp(self):
        self.absolute = header.Header(3, timestamp=1000,
            bodyLength=2000, datatype=3, streamId=243)

    def merge(self, **kwargs):
        """
        Generates a relative header and with the same channelId on each call.
        """
        import copy

        h = copy.copy(self.absolute)

        for k, v in kwargs.items():
            setattr(h, k, v)

        return header.merge(self.absolute, h)

    def test_different_channels(self):
        self.assertRaises(header.HeaderError, self.merge, channelId=4)

    def test_timestamp(self):
        h = self.merge(timestamp=-1)

        self.assertEqual(h.timestamp, 1000)

        h = self.merge(timestamp=999)
        self.assertEqual(h.timestamp, 999)

    def test_datatype(self):
        h = self.merge(datatype=-1)

        self.assertEqual(h.datatype, 3)

        h = self.merge(datatype=4)
        self.assertEqual(h.datatype, 4)

    def test_bodyLength(self):
        h = self.merge(bodyLength=-1)

        self.assertEqual(h.bodyLength, 2000)

        h = self.merge(bodyLength=1500)
        self.assertEqual(h.bodyLength, 1500)

    def test_streamId(self):
        h = self.merge(streamId=-1)

        self.assertEqual(h.streamId, 243)

        h = self.merge(streamId=15)
        self.assertEqual(h.streamId, 15)

########NEW FILE########
__FILENAME__ = test_protocol
# -*- coding: utf-8 -*-
#
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Tests for L{rtmpy.protocol.rtmp}
"""

from twisted.trial import unittest
from twisted.internet import error, defer, reactor
from twisted.test.proto_helpers import StringTransportWithDisconnection

from rtmpy.protocol import rtmp
from rtmpy import message, core, exc, util


class MockHandshakeNegotiator(object):
    """
    """

    def __init__(self, test, protocol):
        self.test = test
        self.protocol = protocol
        self.started = False

        self.data = None

    def start(self, uptime, version):
        self.started = True

    def dataReceived(self, data):
        if self.data is None:
            self.data = data
        else:
            self.data += data


class MockFactory(object):
    """
    """

    def __init__(self, test, protocol):
        self.test = test
        self.protocol = protocol

    def buildHandshakeNegotiator(self, protocol, output):
        self.test.assertIdentical(protocol, self.protocol)

        return self.test.handshaker


class MockApplication(object):
    """
    """

    def __init__(self, test, protocol):
        self.test = test
        self.protocol = protocol

    def clientDisconnected(self, client, reason):
        self.test.assertIdentical(client, self.protocol)



class SimpleProtocol(rtmp.RTMPProtocol, core.StreamManager):
    """
    A simple RTMP protocol that returns empty streams.
    """

    def buildStreamManager(self):
        return self


    def getControlStream(self):
        return self


    def closeStream(self):
        pass


    def buildStream(self, streamId):
        return core.NetStream(self, streamId)


class ProtocolTestCase(unittest.TestCase):
    """
    """

    def setUp(self):
        self.protocol = SimpleProtocol()
        self.handshaker = MockHandshakeNegotiator(self, self.protocol)
        self.transport = self.protocol.transport = StringTransportWithDisconnection()
        self.transport.protocol = self.protocol

    def connect(self):
        self.protocol.factory = MockFactory(self, self.protocol)
        self.protocol.connectionMade()
        self.protocol.versionSuccess()


class StateTest(ProtocolTestCase):
    """
    Test protocol state between not connected/handshaking/streaming/disconnected
    """

    def test_not_connected(self):
        self.assertEqual(self.protocol.state, None)

    def test_connect(self):
        self.connect()

        self.assertEqual(self.protocol.state, 'handshake')
        self.assertTrue(self.handshaker.started)

        self.assertIdentical(self.protocol.handshaker, self.handshaker)

    def test_stream(self):
        self.connect()
        self.protocol.handshakeSuccess('')

        self.assertEqual(self.protocol.state, 'stream')
        self.assertFalse(hasattr(self.protocol, 'handshaker'))

        m = self.protocol.streamManager
        self.assertEqual(m.streams, {0: m})


class ConnectionLostTestCase(ProtocolTestCase):
    """
    Tests for losing connection at various states of the protocol
    """

    def setUp(self):
        ProtocolTestCase.setUp(self)

        self.connect()

    def test_handshake(self):
        self.protocol.connectionLost(error.ConnectionDone())

        self.assertFalse(hasattr(self.protocol, 'handshaker'))

    def test_stream(self):
        self.protocol.handshakeSuccess('')

        self.protocol.connectionLost(error.ConnectionDone())

        self.assertFalse(hasattr(self.protocol, 'decoder'))
        self.assertFalse(hasattr(self.protocol, 'encoder'))

    def test_decode_task(self):
        self.protocol.handshakeSuccess('')
        self.protocol.startDecoding()

        self.assertTrue(hasattr(self.protocol, 'decoder_task'))
        self.protocol.connectionLost(error.ConnectionDone())
        self.assertFalse(hasattr(self.protocol, 'decoder_task'))

    def test_encode_task(self):
        self.protocol.handshakeSuccess('')
        self.protocol.startEncoding()

        self.assertTrue(hasattr(self.protocol, 'encoder_task'))
        self.protocol.connectionLost(error.ConnectionDone())
        self.assertFalse(hasattr(self.protocol, 'encoder_task'))

    def test_inform_application(self):
        self.protocol.handshakeSuccess('')
        self.protocol.application = MockApplication(self, self.protocol)

        self.protocol.connectionLost(error.ConnectionDone())



class TestRuntimeError(RuntimeError):
    pass



class CooperateTestCase(ProtocolTestCase):
    """
    Tests for encoding/decoding cooperation
    """

    def setUp(self):
        ProtocolTestCase.setUp(self)

        self.connect()
        self.protocol.handshakeSuccess('')

    def test_fail_decode(self):
        """
        If something goes wrong whilst decoding, ensure that protocol disconnects
        """
        def boom(*args):
            raise TestRuntimeError

        self.patch(self.protocol.decoder, 'next', boom)

        def eb(f):
            f.trap(TestRuntimeError)

            self.assertFalse(self.transport.connected)
            self.flushLoggedErrors(TestRuntimeError)

        d = self.protocol.startDecoding().addErrback(eb)

        return d

    def test_fail_encode(self):
        def boom(*args):
            raise TestRuntimeError

        self.patch(self.protocol.encoder, 'next', boom)

        def eb(f):
            f.trap(TestRuntimeError)

            self.assertFalse(self.transport.connected)
            self.flushLoggedErrors(TestRuntimeError)

        d = self.protocol.startEncoding().addErrback(eb)

        return d

    def test_resume_decode(self):
        d = self.protocol.startDecoding()

        def resume(res):
            self.assertTrue(self.transport.connected)
            return self.protocol.startDecoding()

        d.addCallback(resume)

        return d


class DataReceivedTestCase(ProtocolTestCase):
    """
    """

    def test_handshake(self):
        self.connect()
        self.assertEqual(self.protocol.state, 'handshake')

        self.protocol.dataReceived('woot')
        self.assertEqual(self.handshaker.data, 'woot')

        self.protocol.dataReceived('slartybartfarst')
        self.assertEqual(self.handshaker.data, 'wootslartybartfarst')

    def test_stream(self):
        self.connect()
        self.protocol.handshakeSuccess('')

        decoder = self.protocol.decoder

        self.assertEqual(self.protocol.decoder_task, None)
        self.protocol.dataReceived('woot')
        self.assertNotEqual(self.protocol.decoder_task, None)

        self.assertEqual(decoder.stream.getvalue(), 'woot')

        self.protocol.decoder_task.addErrback(lambda x: None)



class BasicResponseTestCase(ProtocolTestCase):
    """
    Some RTMP messages are really low level. Test them.
    """

    def setUp(self):
        ProtocolTestCase.setUp(self)

        self.factory = MockFactory(self, self.protocol)
        self.protocol.factory = self.factory

        self.protocol.connectionMade()
        self.protocol.versionSuccess()
        self.protocol.handshakeSuccess('')

        self.decoder = self.protocol.decoder

        self.messages = []

        def send_message(*args, **kwargs):
            args = list(args)
            stream = kwargs.get('stream', None)

            if stream:
                args.append(stream)

            self.messages.append(args)

        self.patch(self.protocol, 'sendMessage', send_message)

        m = self.protocol.streamManager

        self.stream = m.buildStream(1)

    def test_send_bytes_read(self):
        """
        Tests to ensure that the bytes read keep alive packet is dispatched
        correctly.
        """
        self.decoder.setBytesInterval(8)
        self.decoder.send('\x03\x00\x00\x00\x00\x00\x04\x01\x00\x00\x00\x00'
            '\x00\x00\x00\x32')

        self.decoder.next()

        self.assertEqual(len(self.messages), 1)

        msg, stream, = self.messages[0]

        self.assertIdentical(stream, self.protocol)
        self.assertIsInstance(msg, message.BytesRead)
        self.assertEqual(msg.bytes, 16)

    def test_frame_size(self):
        """
        When a L{message.FrameSize} message is received, ensure that the decoder
        is updated correctly.
        """
        self.decoder.send('\x03\x00\x00\x00\x00\x00\x04\x01\x00\x00\x00\x00'
            '\x00\x00\x00\x32')

        self.assertNotEqual(self.decoder.frameSize, 50)

        [x for x in self.decoder]

        self.assertEqual(self.decoder.frameSize, 50)
        self.assertEqual(self.messages, [])



class InvokableStream(core.NetStream):
    """
    Be able to control the targets easily.
    """

    targets = {}

    def callExposedMethod(self, name, *args):
        target = self.targets.get(name, None)

        if target is None:
            return core.NetStream.callExposedMethod(self, name, *args)

        return defer.maybeDeferred(target, *args)


class InvokingTestCase(ProtocolTestCase):
    """
    """

    def setUp(self):
        ProtocolTestCase.setUp(self)

        self.factory = MockFactory(self, self.protocol)
        self.protocol.factory = self.factory

        self.protocol.connectionMade()
        self.protocol.versionSuccess()
        self.protocol.handshakeSuccess('')

        self.decoder = self.protocol.decoder

        self.messages = []

        def send_message(*args, **kwargs):
            args = list(args) + [kwargs.get('stream', None)]
            self.messages.append(args)

        self.patch(self.protocol, 'sendMessage', send_message)

        self.targets = {}
        self.stream = InvokableStream(self.protocol, 3)
        self.stream.targets = self.targets


    def test_missing_target(self):
        """
        Invoke a method that does not exist with no response expected.
        """
        self.assertEqual(self.stream.targets.get('foo', None), None)

        d = self.stream.onInvoke('foo', 0, [], 0)

        self.assertIsInstance(d, defer.Deferred)

        def cb(res):
            self.fail('errback should be called')

        def eb(fail):
            fail.trap(exc.CallFailed)

            self.assertEqual(util.getFailureMessage(fail),
                "Method not found (foo)")

        def check_messages(res):
            self.assertEqual(self.messages, [])

        d.addCallbacks(cb, eb).addCallback(check_messages)

        return d
    
    def test_missing_target_unicode(self):
        """
        Invoke a method that does not exist with no response expected.
        """
        d = self.stream.onInvoke('', 0, [], 0)

        self.assertIsInstance(d, defer.Deferred)

        def cb(res):
            self.fail('errback should be called')

        def eb(fail):
            fail.trap(exc.CallFailed)

            self.assertEqual(util.getFailureMessage(fail),
                "Method not found ()")

        def check_messages(res):
            self.assertEqual(self.messages, [])

        d.addCallbacks(cb, eb).addCallback(check_messages)

        return d

    def test_missing_target_response(self):
        """
        Invoke a method that does not exist with a response expected.
        """
        self.assertEqual(self.stream.targets.get('foo', None), None)

        d = self.stream.onInvoke('foo', 2, [], 0)

        self.assertIsInstance(d, defer.Deferred)

        def cb(res):
            self.fail('errback should be called')

        def eb(fail):
            fail.trap(exc.CallFailed)

            self.assertEqual(util.getFailureMessage(fail),
                "Method not found (foo)")

        def check_messages(res):
            msg, stream = self.messages.pop(0)

            self.assertEqual(self.messages, [])

            self.assertIdentical(stream, self.stream)

            self.assertIsInstance(msg, message.Invoke)
            self.assertEqual(msg.id, 2)
            self.assertEqual(msg.name, '_error')
            self.assertEqual(msg.argv, [None, {
                'code': 'NetConnection.Call.Failed',
                'description': "Method not found (foo)",
                'level': 'error'}])

        d.addCallbacks(cb, eb).addCallback(check_messages)

        return d
    
    def test_missing_target_response_unicode(self):
        """
        Invoke a method that does not exist with a response expected.
        """
        d = self.stream.onInvoke('', 2, [], 0)

        self.assertIsInstance(d, defer.Deferred)

        def cb(res):
            self.fail('errback should be called')

        def eb(fail):
            fail.trap(exc.CallFailed)

            self.assertEqual(util.getFailureMessage(fail),
                "Method not found ()")

        def check_messages(res):
            msg, stream = self.messages.pop(0)

            self.assertEqual(self.messages, [])

            self.assertIdentical(stream, self.stream)

            self.assertIsInstance(msg, message.Invoke)
            self.assertEqual(msg.id, 2)
            self.assertEqual(msg.name, '_error')
            self.assertEqual(msg.argv, [None, {
                'code': 'NetConnection.Call.Failed',
                'description': "Method not found ()",
                'level': 'error'}])

        d.addCallbacks(cb, eb).addCallback(check_messages)

        return d

    def test_success_response(self):
        """
        Test a successful invocation with a response.
        """
        def func():
            return 'bar'

        self.targets['foo'] = func

        d = self.stream.onInvoke('foo', 2, [], 0)
        self.assertIsInstance(d, defer.Deferred)

        def check_messages(res):
            msg, stream = self.messages.pop(0)

            self.assertEqual(self.messages, [])

            self.assertIdentical(stream, self.stream)

            self.assertIsInstance(msg, message.Invoke)
            self.assertEqual(msg.id, 2)
            self.assertEqual(msg.name, '_result')
            self.assertEqual(msg.argv, [None, 'bar'])

        d.addCallback(check_messages)

        return d
    
    def test_success_response_unicode(self):
        """
        Test a successful invocation with a response.
        """
        def func():
            return ''

        self.targets[''] = func

        d = self.stream.onInvoke('', 2, [], 0)
        self.assertIsInstance(d, defer.Deferred)

        def check_messages(res):
            msg, stream = self.messages.pop(0)

            self.assertEqual(self.messages, [])

            self.assertIdentical(stream, self.stream)

            self.assertIsInstance(msg, message.Invoke)
            self.assertEqual(msg.id, 2)
            self.assertEqual(msg.name, '_result')
            self.assertEqual(msg.argv, [None, ''])

        d.addCallback(check_messages)

        return d

    def test_failure_response(self):
        """
        Test a successful invocation but that raises an error.
        """
        def func():
            raise RuntimeError('spam and eggs please')

        self.targets['foo'] = func

        d = self.stream.onInvoke('foo', 2, [], 0)
        self.assertIsInstance(d, defer.Deferred)

        def eb(fail):
            fail.trap(RuntimeError)

        def check_messages(res):
            msg, stream = self.messages.pop(0)

            self.assertEqual(self.messages, [])

            self.assertIdentical(stream, self.stream)

            self.assertIsInstance(msg, message.Invoke)
            self.assertEqual(msg.id, 2)
            self.assertEqual(msg.name, '_error')
            self.assertEqual(msg.argv, [None, {
                'code': 'NetConnection.Call.Failed',
                'description': 'spam and eggs please',
                'level': 'error'}])

        d.addErrback(eb).addCallback(check_messages)

        return d
    
    def test_failure_response_unicode(self):
        """
        Test a successful invocation but that raises an error.
        """
        def func():
            raise RuntimeError('  ')

        self.targets[''] = func

        d = self.stream.onInvoke('', 2, [], 0)
        self.assertIsInstance(d, defer.Deferred)

        def eb(fail):
            fail.trap(RuntimeError)

        def check_messages(res):
            msg, stream = self.messages.pop(0)

            self.assertEqual(self.messages, [])

            self.assertIdentical(stream, self.stream)

            self.assertIsInstance(msg, message.Invoke)
            self.assertEqual(msg.id, 2)
            self.assertEqual(msg.name, '_error')
            self.assertEqual(msg.argv, [None, {
                'code': 'NetConnection.Call.Failed',
                'description': '  ',
                'level': 'error'}])

        d.addErrback(eb).addCallback(check_messages)

        return d

    def test_args(self):
        """
        Pass args to the target
        """
        def func(a, b, c):
            self.assertEqual(a, 'foo')
            self.assertEqual(b, 'bar')
            self.assertEqual(c, 'baz')

        self.targets['foo'] = func

        d = self.stream.onInvoke('foo', 2, ['foo', 'bar', 'baz'], 0)
        self.assertIsInstance(d, defer.Deferred)

        def check_messages(res):
            self.assertNotEqual(self.messages, [])

        d.addCallback(check_messages)

        return d

    def test_deferred(self):
        """
        Await the response of a deferred
        """
        wait_ok = defer.Deferred()
        my_deferred = defer.Deferred()

        def check_messages(res):
            msg, stream = self.messages.pop(0)

            self.assertEqual(self.messages, [])

            self.assertIdentical(stream, self.stream)

            self.assertIsInstance(msg, message.Invoke)
            self.assertEqual(msg.id, 2)
            self.assertEqual(msg.name, '_result')
            self.assertEqual(msg.argv, [None, 'foo'])

        def wrap_ok(res):
            try:
                check_messages(res)
            except:
                wait_ok.errback()
            else:
                wait_ok.callback(res)

        def func():
            def join():
                my_deferred.callback('foo')
                reactor.callLater(0, my_deferred.addCallback, wrap_ok)

            reactor.callLater(0, join)

            return my_deferred

        self.targets['foo'] = func

        d = self.stream.onInvoke('foo', 2, [], 0)
        self.assertIsInstance(d, defer.Deferred)

        return wait_ok

########NEW FILE########
__FILENAME__ = test_core
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Tests for L{rtmpy.core}
"""

from twisted.trial import unittest

from rtmpy import core, message, status



class SimpleStream(object):
    """
    @ivar closed: Set to C{True} when L{closeStream} is called.
    """

    closed = False

    def closeStream(self):
        self.closed = True



class SimpleStreamManager(core.StreamManager):
    """
    L{core.BaseStreamManager} requires that subclasses implement L{buildStream}
    """

    builtStreams = 0
    streamClass = SimpleStream


    def getControlStream(self):
        """
        Gets the control stream for the manager
        """
        return self


    def buildStream(self, streamId):
        """
        Build and return a L{SimpleStream} that has the streamId associated.
        """
        s = self.streamClass()

        s.streamId = streamId

        self.builtStreams += 1

        return s


    def closeStream(self):
        """
        We need this since we are the control stream.
        """



class TestRuntimeError(RuntimeError):
    """
    An exception class specifically used for testing error handling.
    """



class ErrorClosingStream(object):
    """
    Throws an error if L{closeStream} is called.
    """

    def closeStream(self):
        raise TestRuntimeError



class StreamManagerTestCase(unittest.TestCase):
    """
    Tests for L{core.BaseStreamManager}
    """


    def buildManager(self, cls=SimpleStreamManager):
        return cls()


    def test_get_stream_0(self):
        """
        streamID of 0 is special. It should return the manager.
        """
        m = self.buildManager()

        self.assertIdentical(m, m.getStream(0))


    def test_get_unknown(self):
        """
        Ensure that a call to L{getStream} for an non-existent stream will cause
        an error.
        """
        m = self.buildManager()

        self.assertEqual(m.builtStreams, 0)
        self.assertRaises(KeyError, m.getStream, 1)
        self.assertEqual(m.builtStreams, 0)


    def test_create(self):
        """
        Check basic stream creation
        """
        m = self.buildManager()

        streamId = m.createStream()

        self.assertEqual(m.builtStreams, 1)
        self.assertEqual(streamId, 1)


    def test_get_cache(self):
        """
        Getting the same stream id in succession should return the same stream
        instance.
        """
        m = self.buildManager()

        streamId = m.createStream()
        s = m.getStream(streamId)

        self.assertIdentical(s, m.getStream(streamId))


    def test_delete_stream_0(self):
        """
        Attempts to delete stream 0 should be ignored.
        """
        m = self.buildManager()

        m.deleteStream(0)
        self.assertIdentical(m, m.getStream(0))


    def test_delete_unknown(self):
        """
        Attempt to delete a stream that has not been created.
        """
        m = self.buildManager()

        self.assertRaises(KeyError, m.getStream, 1)
        m.deleteStream(1)


    def test_delete(self):
        """
        Deleting a stream should make that stream unavailable via the manager
        and call C{deleteStream} on the deleted stream.
        """
        m = self.buildManager()

        streamId = m.createStream()
        s = m.getStream(streamId)

        m.deleteStream(streamId)

        self.assertTrue(s.closed)
        self.assertRaises(KeyError, m.getStream, streamId)


    def test_deleted_id_reuse(self):
        """
        The manager should be aggressive its reuse of streamIds from recently
        deleted streams.
        """
        m = self.buildManager()

        [m.createStream() for i in xrange(50)]
        ids_to_delete = [23, 14, 46, 2]

        for streamId in ids_to_delete:
            m.deleteStream(streamId)

        created_stream_ids = [m.createStream() for i in xrange(len(ids_to_delete))]

        self.assertEqual(created_stream_ids, ids_to_delete)


    def test_close_all(self):
        """
        A close all operation should result with an empty manager, with all the
        streams having their C{closeStream} method called.
        """
        m = self.buildManager()
        n = 10

        # create a bunch of streams
        [m.createStream() for i in xrange(n)]
        self.assertEqual(m.builtStreams, n)

        streams = [m.getStream(i) for i in xrange(1, n + 1)]

        m.closeAllStreams()

        for stream in streams:
            self.assertTrue(stream.closed)
            self.assertRaises(KeyError, m.getStream, stream.streamId)

        self.assertEqual(m.getNextAvailableStreamId(), 1)


    def test_close_all_error(self):
        """
        Calling closeAllStreams should result in the correct state of the
        manager, even if an exception is raised whilst closing an individual
        stream.
        """
        m = self.buildManager()
        m.streamClass = ErrorClosingStream

        n = 10

        # create a bunch of streams
        [m.createStream() for i in xrange(n)]

        m.closeAllStreams()

        self.flushLoggedErrors(TestRuntimeError)

        self.assertEqual(m.streams, {0: m})
        self.assertEqual(m.getNextAvailableStreamId(), 1)



class StreamTimestampTestCase(unittest.TestCase):
    """
    Test stream timestamp operations.
    """


    def setUp(self):
        self.stream = core.BaseStream(None)


    def test_default(self):
        """
        Test simple construction and initial values.
        """
        self.assertEqual(self.stream.timestamp, 0)


    def test_absolute(self):
        """
        Set the timestamp in an absolute fashion.
        """
        s = self.stream
        self.assertEqual(s.timestamp, 0)

        s.setTimestamp(345678, False)
        self.assertEqual(s.timestamp, 345678)

        s.setTimestamp(2, False)
        self.assertEqual(s.timestamp, 2)


    def test_relative(self):
        """
        Set the timestamp in an relative fashion.
        """
        s = self.stream
        self.assertEqual(s.timestamp, 0)

        s.setTimestamp(123)
        self.assertEqual(s.timestamp, 123)

        s.setTimestamp(50, True)
        self.assertEqual(s.timestamp, 173)

        s.setTimestamp(-10, True)
        self.assertEqual(s.timestamp, 163)

        s.setTimestamp(5)
        self.assertEqual(s.timestamp, 168)



class MessageSendingStream(core.BaseStream):
    """
    A simple stream that stores the messages that that is sent through it
    """

    def __init__(self, streamId):
        core.BaseStream.__init__(self, streamId)

        self.messages = []


    def sendMessage(self, msg, whenDone=None):
        self.messages.append(msg)



class SendStatusTestCase(unittest.TestCase):
    """
    Tests for L{core.BaseStream.sendMessage}
    """

    def setUp(self):
        self.stream = MessageSendingStream(None)
        self.messages = self.stream.messages


    def checkMessage(self, msg, **kwargs):
        """
        Ensures that the supplied msg is formatted as a onStatus invoke.

        @param msg: The L{message.IMessage} to check.
        @param kwargs: Optional parameters to check. Valid keys are 'command',
            'level, 'code', 'description' and 'extra'.
        """
        sentinel = object()

        def check(a, b):
            c = kwargs.pop(b, sentinel)

            if c is sentinel:
                return

            self.assertEqual(a, c)

        self.assertTrue(message.typeByClass(msg), message.Invoke)

        self.assertEqual(msg.name, 'onStatus')
        self.assertEqual(msg.id, 0)

        cmd, s = msg.argv

        check(cmd, 'command')
        check(s.level, 'level')
        check(s.code, 'code')
        check(s.description, 'description')
        check(s.getExtraContext(), 'extra')

        # sanity check
        self.assertEqual(kwargs, {}, msg='improper use of checkMessage')


    def test_simple_string(self):
        """
        Supplying only code as a string to L{sendStatus} should yield a status
        message.
        """
        self.stream.sendStatus('foobar')

        msg = self.messages.pop()

        self.assertEqual(self.messages, [])

        self.checkMessage(msg, code='foobar')


    def test_status(self):
        """
        Sending a L{status.IStatus} should succeed.
        """
        s = status.error('AnErrorOccurred', 'This is a description', foo='bar')
        self.stream.sendStatus(s)

        msg = self.messages.pop()

        self.assertEqual(self.messages, [])

        self.checkMessage(msg, level='error', code='AnErrorOccurred',
            description='This is a description', extra={'foo': 'bar'})


    def test_command(self):
        """
        Sending a command arg with sendStatus should set the command var on the
        invoke message.
        """
        self.stream.sendStatus(None, command='blarg')

        msg = self.messages.pop()

        self.assertEqual(self.messages, [])

        self.checkMessage(msg, command='blarg')


    def test_extra(self):
        """
        Sending a code and description should allow extra key/value pairs to be
        set on the status object.
        """
        self.stream.sendStatus(None, None, spam='eggs', blarg='blaggity')

        msg = self.messages.pop()

        self.assertEqual(self.messages, [])

        self.checkMessage(msg, extra={'blarg': 'blaggity', 'spam': 'eggs'})



class NetConnectionTestCase(unittest.TestCase):
    """
    Tests for L{core.NetConnection}
    """

    def test_create(self):
        """
        Ensure we can actually create L{core.NetConnection} objects and check
        some defaults.
        """
        nc = core.NetConnection(None)

        self.assertEqual(nc.streamId, 0)
        self.assertEqual(nc.client, None)


    def test_control_stream(self):
        """
        Ensure that the control stream for L{core.NetConnection} is itself.
        """
        o = object()
        nc = core.NetConnection(o)

        self.assertIdentical(nc.getControlStream(), o)



class NetStreamTestCase(unittest.TestCase):
    """
    Tests for L{core.NetStream}
    """

    def setUp(self):
        self.nc = core.NetConnection(None)


    def test_create(self):
        """
        Ensure we can actually create L{core.NetStream} objects and check
        some defaults.
        """
        s = core.NetStream(self.nc, 2)

        self.assertEqual(s.streamId, 2)
        self.assertEqual(s.timestamp, 0)


    def test_client(self):
        """
        The client property on L{core.NetStream} should be identical to that of
        its C{NetConnection}.
        """
        client = object()
        self.nc.client = client

        s = core.NetStream(self.nc, None)

        self.assertIdentical(s.client, client)


    def test_close(self):
        """
        Ensure that we can close the stream.
        """
        s = core.NetStream(self.nc, None)

        s.closeStream()

########NEW FILE########
__FILENAME__ = test_message
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Tests for L{rtmpy.protocol.rtmp.message}.
"""

import unittest
from pyamf.util import BufferedByteStream

from rtmpy.protocol.rtmp import message


class MockMessageListener(object):
    """
    """

    def __init__(self):
        self.calls = []

    def onInvoke(self, *args, **kwargs):
        self.calls.append(('invoke', args, kwargs))

    def onNotify(self, *args, **kwargs):
        self.calls.append(('notify', args, kwargs))

    def onFrameSize(self, *args, **kwargs):
        self.calls.append(('frame-size', args, kwargs))

    def onBytesRead(self, *args, **kwargs):
        self.calls.append(('bytes-read', args, kwargs))

    def onControlMessage(self, *args, **kwargs):
        self.calls.append(('control', args, kwargs))

    def onDownstreamBandwidth(self, *args, **kwargs):
        self.calls.append(('bw-down', args, kwargs))

    def onUpstreamBandwidth(self, *args, **kwargs):
        self.calls.append(('bw-up', args, kwargs))

    def onAudioData(self, *args, **kwargs):
        self.calls.append(('audio', args, kwargs))

    def onVideoData(self, *args, **kwargs):
        self.calls.append(('video', args, kwargs))


class BaseTestCase(unittest.TestCase):
    """
    """

    def setUp(self):
        self.buffer = BufferedByteStream()
        self.listener = MockMessageListener()


class MessageTestCase(unittest.TestCase):
    """
    Tests for L{message.Message}
    """

    def test_interface(self):
        x = message.Message()

        self.assertTrue(message.IMessage.providedBy(x))

        self.assertRaises(NotImplementedError, x.encode, None)
        self.assertRaises(NotImplementedError, x.decode, None)
        self.assertRaises(NotImplementedError, x.dispatch, None, None)

    def test_repr(self):
        x = message.Message()
        x.foo = 'bar'

        self.assertEqual(repr(x),
            "<rtmpy.message.Message foo='bar' at 0x%x>" % id(x))


class FrameSizeTestCase(BaseTestCase):
    """
    Tests for L{message.FrameSize}
    """

    def test_create(self):
        x = message.FrameSize()
        self.assertEquals(x.__dict__, {'size': None})

        x = message.FrameSize(10)
        self.assertEquals(x.__dict__, {'size': 10})

        x = message.FrameSize(size=20)
        self.assertEquals(x.__dict__, {'size': 20})

    def test_raw_encode(self):
        # test default encode
        x = message.FrameSize()
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), 'Frame size not set')

        # test non-int encode
        x = message.FrameSize(size='foo.bar')
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), 'Frame size wrong type '
        #    '(expected int, got <type \'str\'>)')

        x = message.FrameSize(size=50)
        e = x.encode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(self.buffer.getvalue(), '\x00\x00\x00\x32')

    def test_decode(self):
        x = message.FrameSize()

        self.assertEquals(x.size, None)
        self.buffer.write('\x00\x00\x00\x32')
        self.buffer.seek(0)

        e = x.decode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(x.size, 50)

    def test_dispatch(self):
        x = message.FrameSize(5678)

        x.dispatch(self.listener, 54)

        self.assertEquals(self.listener.calls, [('frame-size', (5678, 54), {})])


class ControlMessageTestCase(BaseTestCase):
    """
    Tests for L{message.ControlMessage}
    """

    def test_create(self):
        x = message.ControlMessage()
        self.assertEquals(x.__dict__, {
            'type': None,
            'value1': 0,
            'value2': None,
            'value3': None
        })

        x = message.ControlMessage(9, 123, 456, 789)
        self.assertEquals(x.__dict__, {
            'type': 9,
            'value1': 123,
            'value2': 456,
            'value3': 789
        })

        x = message.ControlMessage(type=0, value1=123, value3=789, value2=456)
        self.assertEquals(x.__dict__, {
            'type': 0,
            'value1': 123,
            'value2': 456,
            'value3': 789
        })

    def test_encode(self):
        x = message.ControlMessage()
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), 'Type not set')

        # test types ..
        x = message.ControlMessage(type='3')
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), "TypeError encoding type "
        #    "(expected int, got <type 'str'>)")

        x = message.ControlMessage(type=3, value1=None)
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), "TypeError encoding value1 "
        #    "(expected int, got <type 'NoneType'>)")

        x = message.ControlMessage(type=3, value1=10, value2=object())
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), "TypeError encoding value2 "
        #    "(expected int, got <type 'object'>)")

        x = message.ControlMessage(type=3, value1=10, value2=7, value3='foo')
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), "TypeError encoding value3 "
        #    "(expected int, got <type 'str'>)")

        self.buffer.truncate(0)
        x = message.ControlMessage(2)
        e = x.encode(self.buffer)
        #self.assertEquals(self.buffer.getvalue(),
        #    '\x00\x02\x00\x00\x00\x00\xff\xff\xff\xff\xff\xff\xff\xff')

        self.buffer.truncate(0)
        x = message.ControlMessage(type=0, value1=123, value3=789, value2=456)
        e = x.encode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(self.buffer.getvalue(),
            '\x00\x00\x00\x00\x00{\x00\x00\x01\xc8\x00\x00\x03\x15')

    def test_decode(self):
        x = message.ControlMessage()

        self.assertEquals(x.__dict__, {
            'type': None,
            'value1': 0,
            'value2': None,
            'value3': None
        })

        self.buffer.write('\x00\x00\x00\x00\x00{\x00\x00\x01\xc8\x00\x00\x03\x15')
        self.buffer.seek(0)

        e = x.decode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(x.type, 0)
        self.assertEquals(x.value1, 123)
        self.assertEquals(x.value2, 456)
        self.assertEquals(x.value3, 789)

    def test_dispatch(self):
        x = message.ControlMessage()

        x.dispatch(self.listener, 54)

        self.assertEquals(self.listener.calls, [('control', (x, 54), {})])


class NotifyTestCase(BaseTestCase):
    """
    Tests for L{message.Notify}
    """

    def test_create(self):
        e = message.Notify()
        self.assertEquals(e.__dict__, {'name': None, 'argv': []})

        e = message.Notify('foo', {'baz': 'gak', 'spam': 'eggs'}, 'yar')
        self.assertEquals(e.__dict__, {'name': 'foo',
            'argv': [{'baz': 'gak', 'spam': 'eggs'}, 'yar']})

    def test_encode(self):
        e = message.Notify('_result', 2, {'foo': 'bar', 'baz': 'gak'})

        e.encode(self.buffer)

        self.assertEqual(self.buffer.getvalue(), '\x02\x00\x07_result\x00@\x00'
            '\x00\x00\x00\x00\x00\x00\x03\x00\x03foo\x02\x00\x03bar\x00\x03baz'
            '\x02\x00\x03gak\x00\x00\t')

    def test_decode_simple(self):
        e = message.Notify()

        self.buffer.append('\x05\x03\x00\x00\t')
        e.decode(self.buffer)

        self.assertEquals(e.name, None)
        self.assertEquals(e.argv, [{}])


    def test_decode(self):
        e = message.Notify()

        self.buffer.append('\x02\x00\x07_result\x03\x00\x03foo\x02\x00\x03bar'
            '\x00\x03baz\x02\x00\x03gak\x00\x00\t')

        e.decode(self.buffer)

        self.assertEquals(e.name, '_result')
        self.assertEquals(e.argv, [{'foo': 'bar', 'baz': 'gak'}])

    def test_dispatch(self):
        x = message.Notify('foo')

        x.dispatch(self.listener, 54)
        self.assertEquals(self.listener.calls, [('notify', ('foo', [], 54), {})])


class InvokeTestCase(BaseTestCase):
    """
    Tests for L{message.Invoke}
    """

    def test_create(self):
        e = message.Invoke()
        self.assertEquals(e.__dict__, {'name': None, 'id': None, 'argv': []})

        e = message.Invoke('foo', 'bar', {'baz': 'gak', 'spam': 'eggs'}, 'yar')
        self.assertEquals(e.__dict__, {'name': 'foo', 'id': 'bar',
            'argv': [{'baz': 'gak', 'spam': 'eggs'}, 'yar']})

    def test_encode(self):
        e = message.Invoke('_result', 2, {'foo': 'bar', 'baz': 'gak'})

        e.encode(self.buffer)

        self.assertEqual(self.buffer.getvalue(), '\x02\x00\x07_result\x00@\x00'
            '\x00\x00\x00\x00\x00\x00\x03\x00\x03foo\x02\x00\x03bar\x00\x03baz'
            '\x02\x00\x03gak\x00\x00\t')

    def test_decode_simple(self):
        e = message.Invoke()

        self.buffer.append('\x05\x05\x03\x00\x00\t')
        e.decode(self.buffer)

        self.assertEquals(e.name, None)
        self.assertEquals(e.id, None)
        self.assertEquals(e.argv, [{}])


    def test_decode(self):
        e = message.Invoke()

        self.buffer.append('\x02\x00\x07_result\x00@\x00\x00\x00\x00\x00\x00'
            '\x00\x03\x00\x03foo\x02\x00\x03bar\x00\x03baz\x02\x00\x03gak\x00'
            '\x00\t')

        e.decode(self.buffer)

        self.assertEquals(e.name, '_result')
        self.assertEquals(e.id, 2)
        self.assertEquals(e.argv, [{'foo': 'bar', 'baz': 'gak'}])

    def test_dispatch(self):
        x = message.Invoke()

        x.dispatch(self.listener, 54)
        self.assertEquals(self.listener.calls,
            [('invoke', (None, None, [], 54), {})])


class BytesReadTestCase(BaseTestCase):
    """
    Tests for L{message.BytesRead}
    """

    def test_create(self):
        x = message.BytesRead()
        self.assertEquals(x.__dict__, {'bytes': None})

        x = message.BytesRead(10)
        self.assertEquals(x.__dict__, {'bytes': 10})

        x = message.BytesRead(bytes=20)
        self.assertEquals(x.__dict__, {'bytes': 20})


    def test_encode(self):
        # test default encode
        x = message.BytesRead()
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), 'Bytes read not set')

        # test non-int encode
        x = message.BytesRead(bytes='foo.bar')
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), 'Bytes read wrong type '
        #    '(expected int, got <type \'str\'>)')

        x = message.BytesRead(bytes=50)
        e = x.encode(self.buffer)

        self.assertEquals(e, None)

        self.assertEquals(self.buffer.getvalue(), '\x00\x00\x00\x32')


    def test_4GB_threshold(self):
        """
        Test wrapping when encoding byte values > 4GB.

        @see: #54
        """
        x = message.BytesRead(bytes=message.BytesRead.FOUR_GB_THRESHOLD)

        x.encode(self.buffer)

        self.assertEqual(self.buffer.getvalue(), '\x00\x00\x00\x00')


    def test_decode(self):
        x = message.BytesRead()

        self.assertEquals(x.bytes, None)
        self.buffer.write('\x00\x00\x00\x32')
        self.buffer.seek(0)

        e = x.decode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(x.bytes, 50)

    def test_dispatch(self):
        x = message.BytesRead(90)

        x.dispatch(self.listener, 54)

        self.assertEquals(self.listener.calls, [('bytes-read', (90, 54), {})])


class DownstreamBandwidthTestCase(BaseTestCase):
    """
    Tests for L{message.DownstreamBandwidth}
    """

    def test_create(self):
        x = message.DownstreamBandwidth()
        self.assertEquals(x.__dict__, {'bandwidth': None})

        x = message.DownstreamBandwidth(10)
        self.assertEquals(x.__dict__, {'bandwidth': 10})

        x = message.DownstreamBandwidth(bandwidth=20)
        self.assertEquals(x.__dict__, {'bandwidth': 20})

    def test_encode(self):
        # test default encode
        x = message.DownstreamBandwidth()
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), 'Downstream bandwidth not set')

        # test non-int encode
        x = message.DownstreamBandwidth(bandwidth='foo.bar')
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), "TypeError for downstream bandwidth "
        #    "(expected int, got <type 'str'>)")

        x = message.DownstreamBandwidth(bandwidth=50)
        e = x.encode(self.buffer)

        self.assertEquals(e, None)

        self.assertEquals(self.buffer.getvalue(), '\x00\x00\x00\x32')

    def test_decode(self):
        x = message.DownstreamBandwidth()

        self.assertEquals(x.bandwidth, None)
        self.buffer.write('\x00\x00\x00\x32')
        self.buffer.seek(0)

        e = x.decode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(x.bandwidth, 50)

    def test_dispatch(self):
        x = message.DownstreamBandwidth('foo')

        x.dispatch(self.listener, 54)

        self.assertEquals(self.listener.calls, [('bw-down', ('foo', 54), {})])


class UpstreamBandwidthTestCase(BaseTestCase):
    """
    Tests for L{message.UpstreamBandwidth}
    """

    def test_create(self):
        x = message.UpstreamBandwidth()
        self.assertEquals(x.__dict__, {'bandwidth': None, 'extra': None})

        x = message.UpstreamBandwidth(10, 32)
        self.assertEquals(x.__dict__, {'bandwidth': 10, 'extra': 32})

        x = message.UpstreamBandwidth(bandwidth=20, extra=233)
        self.assertEquals(x.__dict__, {'bandwidth': 20, 'extra': 233})

    def test_encode(self):
        # test default encode
        x = message.UpstreamBandwidth()
        self.assertRaises(message.EncodeError, x.encode, self.buffer)
        self.buffer.truncate(0)

        x = message.UpstreamBandwidth(bandwidth='234')
        self.assertRaises(message.EncodeError, x.encode, self.buffer)
        self.buffer.truncate(0)

        # test non-int encode
        x = message.UpstreamBandwidth(bandwidth='foo.bar', extra=234)
        self.assertRaises(message.EncodeError, x.encode, self.buffer)
        self.buffer.truncate(0)

        # test non-int encode
        x = message.UpstreamBandwidth(bandwidth=1200, extra='asdfas')
        self.assertRaises(message.EncodeError, x.encode, self.buffer)
        self.buffer.truncate(0)

        x = message.UpstreamBandwidth(bandwidth=50, extra=12)
        x.encode(self.buffer)

        self.assertEquals(self.buffer.getvalue(), '\x00\x00\x00\x32\x0C')

    def test_decode(self):
        x = message.UpstreamBandwidth()

        self.assertEquals(x.bandwidth, None)
        self.buffer.write('\x00\x00\x00\x32\x0C')
        self.buffer.seek(0)

        e = x.decode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(x.bandwidth, 50)
        self.assertEquals(x.extra, 12)

    def test_dispatch(self):
        x = message.UpstreamBandwidth('foo', 'bar')

        x.dispatch(self.listener, 54)
        self.assertEquals(self.listener.calls, [('bw-up', ('foo', 'bar', 54), {})])


class AudioDataTestCase(BaseTestCase):
    """
    Tests for L{message.AudioData}
    """

    def test_create(self):
        x = message.AudioData()
        self.assertEquals(x.__dict__, {'data': None})

        x = message.AudioData(10)
        self.assertEquals(x.__dict__, {'data': 10})

        x = message.AudioData(data=20)
        self.assertEquals(x.__dict__, {'data': 20})

    def test_encode(self):
        # test default encode
        x = message.AudioData()
        self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), 'No data set')

        # test non-str encode
        x = message.AudioData(data=20)
        self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), "TypeError: data "
        #    "(expected str, got <type 'int'>)")

        x = message.AudioData(data='foo.bar')
        e = x.encode(self.buffer)

        self.assertEquals(e, None)

        self.assertEquals(self.buffer.getvalue(), 'foo.bar')

    def test_decode(self):
        x = message.AudioData()

        self.assertEquals(x.data, None)
        self.buffer.write('foo.bar')
        self.buffer.seek(0)

        e = x.decode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(x.data, 'foo.bar')

    def test_dispatch(self):
        x = message.AudioData('foo')

        x.dispatch(self.listener, 54)

        self.assertEquals(self.listener.calls, [('audio', ('foo', 54), {})])


class VideoDataTestCase(BaseTestCase):
    """
    Tests for L{message.VideoData}
    """

    def test_create(self):
        x = message.VideoData()
        self.assertEquals(x.__dict__, {'data': None})

        x = message.VideoData(10)
        self.assertEquals(x.__dict__, {'data': 10})

        x = message.VideoData(data=20)
        self.assertEquals(x.__dict__, {'data': 20})

    def test_encode(self):
        # test default encode
        x = message.VideoData()
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), 'No data set')

        # test non-str encode
        x = message.VideoData(data=20)
        e = self.assertRaises(message.EncodeError, x.encode, self.buffer)
        #self.assertEquals(str(e), "TypeError: data "
        #    "(expected str, got <type 'int'>)")

        x = message.VideoData(data='foo.bar')
        e = x.encode(self.buffer)

        self.assertEquals(e, None)

        self.assertEquals(self.buffer.getvalue(), 'foo.bar')

    def test_raw_decode(self):
        x = message.VideoData()

        self.assertEquals(x.data, None)
        self.buffer.write('foo.bar')
        self.buffer.seek(0)

        e = x.decode(self.buffer)

        self.assertEquals(e, None)
        self.assertEquals(x.data, 'foo.bar')

    def test_dispatch(self):
        x = message.VideoData('foo')

        x.dispatch(self.listener, 54)

        self.assertEquals(self.listener.calls, [('video', ('foo', 54), {})])


class HelperTestCase(unittest.TestCase):
    def test_type_class(self):
        for k, v in message.TYPE_MAP.iteritems():
            self.assertEquals(message.classByType(k), v)

        self.assertFalse('foo' in message.TYPE_MAP.keys())
        self.assertRaises(message.UnknownType, message.classByType, 'foo')

########NEW FILE########
__FILENAME__ = test_rpc
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Tests for L{rtmpy.rpc}.
"""


from twisted.trial import unittest
from twisted.internet import defer

from rtmpy import rpc, message, exc



class ExposingTestCase(unittest.TestCase):
    """
    Tests for L{rpc.expose}.
    """


    def assertExposed(self, class_func, msg=None):
        cls = class_func.im_class
        name = class_func.__name__

        exposed_methods = rpc.getExposedMethods(cls)

        assert name in exposed_methods, \
            msg or '%r is not an exposed method on %r' % (name, cls)


    def assertExposedAs(self, class_func, as_, msg=None):
        cls = class_func.im_class
        name = class_func.__name__

        exposed_methods = rpc.getExposedMethods(cls)

        assert exposed_methods.get(as_, None) == name, \
            msg or '%r is not an exposed method on %r' % (name, cls)


    def assertNotExposed(self, class_func, msg=None):
        try:
            self.assertExposed(class_func)
        except AssertionError:
            pass
        else:
            cls = class_func.im_class
            name = class_func.__name__

            raise AssertionError(
                msg or '%r IS an exposed method on %r' % (name, cls))


    def test_simple(self):
        """
        Exposing methods on classes should return sane values for
        L{rpc.getExposedMethods}
        """
        class SomeClass(object):
            @rpc.expose
            def foo(self):
                pass


            @rpc.expose('me')
            def bar(self):
                pass


            def not_exposed(self):
                pass

        self.assertEqual(rpc.getExposedMethods(SomeClass),
            {'me': 'bar', 'foo': 'foo'})

        self.assertExposed(SomeClass.foo)
        self.assertNotExposed(SomeClass.not_exposed)
        self.assertExposedAs(SomeClass.bar, 'me')
        self.assertExposedAs(SomeClass.foo, 'foo')


    def test_deep(self):
        """
        As with L{test_simple} but a complex class hierarchy.
        """
        class A(object):
            @rpc.expose
            def anon(self):
                pass

            def nope(self):
                pass

        class B(A):
            @rpc.expose('bar')
            def named(self):
                pass


        self.assertEqual(rpc.getExposedMethods(A), {'anon': 'anon'})
        self.assertEqual(rpc.getExposedMethods(B),
            {'anon': 'anon', 'bar': 'named'})

        self.assertExposedAs(A.anon, 'anon')
        self.assertExposedAs(B.anon, 'anon')
        self.assertNotExposed(A.nope)
        self.assertNotExposed(B.nope)
        self.assertExposedAs(B.named, 'bar')


class CallHandlerTestCase(unittest.TestCase):
    """
    Tests for L{rpc.BaseCallHandler}.
    """

    def setUp(self):
        self.handler = rpc.BaseCallHandler()


    def test_initiate(self):
        """
        Initiating a call should store the context that was passed to the call
        and return a unique, incrementing id.
        """
        h = self.handler
        c = ('foo', ['bar', 'baz'], {})

        self.assertEqual(h.getNextCallId(), 1)
        self.assertEqual(h.getCallContext(1), None)

        self.assertEqual(h.initiateCall(*c), 1)
        self.assertEqual(h.getCallContext(1), c)

        self.assertEqual(h.getNextCallId(), 2)
        self.assertEqual(h.getCallContext(2), None)


    def test_active(self):
        """
        Ensure that L{rpc.BaseCallHandler.isCallActive} returns some sane
        results.
        """
        h = self.handler

        self.assertEqual(h.getNextCallId(), 1)

        self.assertFalse(h.isCallActive(1))

        callId = h.initiateCall()

        self.assertTrue(h.isCallActive(callId))


    def test_finish_non_active(self):
        """
        Finishing a call that is not active should result in no state change
        and C{None} should be returned.
        """
        h = self.handler
        hsh = hash(h)

        self.assertFalse(h.isCallActive(1))

        self.assertEqual(h.finishCall(1), None)
        self.assertEqual(hsh, hash(h))


    def test_finish_active_call(self):
        """
        Finishing an active call should return the original context supplied to
        C{initiateCall} and the call should no longer be active.
        """
        h = self.handler
        c = ('foo', ['bar', 'baz'], {})

        callId = h.initiateCall(*c)

        self.assertEqual(h.finishCall(callId), c)
        self.assertFalse(h.isCallActive(callId))


    def test_discard_non_active(self):
        """
        Discarding a call that is not active should result in no state change
        and C{None} should be returned.
        """
        h = self.handler
        hsh = hash(h)

        self.assertFalse(h.isCallActive(1))

        self.assertEqual(h.discardCall(1), None)
        self.assertEqual(hsh, hash(h))


    def test_discard_active_call(self):
        """
        Discarding an active call should return the original context supplied to
        C{initiateCall} and the call should no longer be active.
        """
        h = self.handler
        c = ('foo', ['bar', 'baz'], {})

        callId = h.initiateCall(*c)

        self.assertEqual(h.discardCall(callId), c)
        self.assertFalse(h.isCallActive(callId))


    def test_initiate_already_active(self):
        """
        Initiating a call with an already active callId should raise an
        L{exc.CallFailed} error.
        """
        h = self.handler

        callId = h.initiateCall()

        self.assertRaises(exc.CallFailed, h.initiateCall, callId=callId)



class AbstractCallHandlerTestCase(unittest.TestCase):
    """
    Tests for L{rpc.AbstractCallHandler}
    """


    def test_interface(self):
        """
        Check defined interfaces.
        """
        self.assertTrue(
            message.IMessageSender.implementedBy(rpc.AbstractCallHandler))


    def test_send_message(self):
        """
        Abstract methods should raise C{NotImplementedError}.
        """
        a = rpc.AbstractCallHandler()

        self.assertRaises(NotImplementedError, a.sendMessage, None)



class SimpleInitiator(rpc.AbstractCallHandler):
    """
    An implementation of L{rpc.AbstractCallInitiator} that stores any messages
    were sent for later inspection.

    @messages
    """

    def __init__(self):
        super(rpc.AbstractCallHandler, self).__init__()

        self.messages = []


    def sendMessage(self, msg):
        """
        Keeps track of any messages that were 'sent'.
        """
        self.messages.append(msg)



class CallTestCase(unittest.TestCase):
    """
    Tests for L{rpc.AbstractCallInitiator.call}
    """


    def setUp(self):
        self.invoker = SimpleInitiator()
        self.messages = self.invoker.messages


    def test_call_message(self):
        """
        Check the context of the message sent when L{callWithoutResult} is
        executed.
        """
        i = self.invoker
        m = self.messages

        ret = i.call('remote_method', 1, 2, 3, 'foo')
        self.assertEqual(ret, None)

        self.assertEqual(len(m), 1)
        msg = m.pop()

        self.assertEqual(message.typeByClass(msg), message.INVOKE)
        self.assertEqual(msg.id, 0)
        self.assertEqual(msg.name, 'remote_method')
        self.assertEqual(msg.argv, [None, 1, 2, 3, 'foo'])


    def test_call_command(self):
        """
        Ensure L{execute} accepts a C{command} kwarg and that it is
        set on the message appropriately.
        """
        cmd = {'foo': 'bar'}
        i, m = self.invoker, self.messages

        ret = i.call('remote_method', command=cmd)
        self.assertEqual(ret, None)

        self.assertEqual(len(m), 1)
        msg = m.pop()

        self.assertEqual(message.typeByClass(msg), message.INVOKE)
        self.assertEqual(msg.id, 0)
        self.assertEqual(msg.name, 'remote_method')
        self.assertEqual(msg.argv, [cmd])


    def test_call_tracking(self):
        """
        Any call to L{execute} should not be considered 'active'.
        """
        i = self.invoker

        i.call('foo')

        self.assertFalse(i.isCallActive(0))



class CallWithNotifTestCase(unittest.TestCase):
    """
    Tests for L{rpc.AbstractCallHandler.call} with C{notify=True} supplied.
    """


    def setUp(self):
        self.invoker = SimpleInitiator()
        self.messages = self.invoker.messages


    def test_call(self):
        """
        Check the context of the message sent when L{call} is
        executed.
        """
        i = self.invoker
        m = self.messages

        d = i.call('remote_method', 1, 2, 3, 'foo', notify=True)

        self.assertTrue(isinstance(d, defer.Deferred))
        self.assertEqual(len(m), 1)
        msg = m.pop()

        self.assertEqual(message.typeByClass(msg), message.INVOKE)
        self.assertEqual(msg.id, 1)
        self.assertEqual(msg.name, 'remote_method')
        self.assertEqual(msg.argv, [None, 1, 2, 3, 'foo'])

        callContext = i.getCallContext(msg.id)

        self.assertEqual(callContext,
            (d, 'remote_method', (1, 2, 3, 'foo'), None))


    def test_command(self):
        """
        Ensure L{call} accepts a C{command} kwarg and that it
        is set on the sent message appropriately.
        """
        cmd = {'foo': 'bar'}
        i, m = self.invoker, self.messages

        d = i.call('remote_method', command=cmd, notify=True)

        self.assertTrue(isinstance(d, defer.Deferred))
        self.assertEqual(len(m), 1)
        msg = m.pop()

        self.assertEqual(message.typeByClass(msg), message.INVOKE)
        self.assertEqual(msg.id, 1)
        self.assertEqual(msg.name, 'remote_method')
        self.assertEqual(msg.argv, [cmd])

        callContext = i.getCallContext(msg.id)

        self.assertEqual(callContext,
            (d, 'remote_method', (), cmd))


    def test_send_failure(self):
        """
        Ensure correct state when sending a message blows up.
        """
        class TestRuntimeError(RuntimeError):
            """
            """

        def sendBadMessage(msg):
            self.msg = msg

            raise TestRuntimeError(msg)

        i = self.invoker

        self.patch(i, 'sendMessage', sendBadMessage)

        self.assertRaises(TestRuntimeError, i.call,
            'remote_method', notify=True)

        self.assertFalse(i.isCallActive(self.msg.id))



class CallResponseTestCase(unittest.TestCase):
    """
    Tests the response to an RPC call.
    """


    def setUp(self):
        self.invoker = SimpleInitiator()
        self.messages = self.invoker.messages


    def sendResponse(self, responseType, callId, *args, **kwargs):
        """
        Build an RPC response.

        @param responseType: Either C{_result} or C{_error}.
        @param callId: The id of the response.
        @param args: The args to supply as part of the response.
        """
        self.invoker.handleResponse(responseType, callId, args, **kwargs)


    def makeCall(self, name, *args, **kwargs):
        """
        """
        kwargs.setdefault('notify', True)

        return self.invoker.call(name, *args, **kwargs)


    def test_unknown_call_id(self):
        """
        Send a response to a non existant RPC call.
        """
        i = self.invoker

        self.assertFalse(i.isCallActive(0))
        self.sendResponse(None, 0)

        self.assertFalse(i.isCallActive(2))
        self.sendResponse(None, 2)


    def test_success_result(self):
        """
        Ensure that the deferred handed back in L{call} has its
        callback called if a success response is received for the corresponding
        call id.

        The callback should contain the args of the response
        """
        d = self.makeCall('some_remote_method')
        self.executed = False

        def cb(args):
            self.executed = True

            self.assertEqual(args, ('foo', 'bar'))

        d.addCallback(cb)

        self.sendResponse('_result', 1, 'foo', 'bar')

        self.assertTrue(self.executed)
        self.assertFalse(self.invoker.isCallActive(2))


    def test_error_result(self):
        """
        Ensure that the deferred handed back in L{call} has its
        errback called if an error response is received for the corresponding
        call id.

        """
        d = self.makeCall('some_remote_method')
        self.executed = False

        def eb(fail):
            self.executed = True

            self.assertIsInstance(fail, rpc.RemoteCallFailed)
            self.assertEqual(fail.value, ('foo', 'bar'))


        d.addCallback(lambda _: self.fail('Callback called'))
        d.addErrback(eb)

        self.sendResponse('_error', 1, 'foo', 'bar')

        self.assertTrue(self.executed)
        self.assertFalse(self.invoker.isCallActive(2))


    def test_command(self):
        """
        Ensure that a command kwarg is acceptable by L{handleResponse}.
        """
        d = self.makeCall('some_remote_method')
        self.executed = False

        def cb(res):
            self.executed = True


        d.addCallback(cb)

        self.sendResponse('_result', 1, 'foo', 'bar', command={'foo': 'bar'})

        self.assertTrue(self.executed)
        self.assertFalse(self.invoker.isCallActive(2))


    def test_unknown_response(self):
        """
        Ensure that the deferred is not called if the response name is not
        recognised.
        """
        d = self.makeCall('some_remote_method')

        d.addBoth(lambda: self.fail('deferred executed!'))

        self.sendResponse('foo', 2, 'some result')

        self.assertFalse(self.invoker.isCallActive(2))



class CallingExposedMethodTestCase(unittest.TestCase):
    """
    Tests for L{rpc.callExposedMethod}
    """

    class Foo(object):
        expectedArgs = None
        expectedReturn = None

        def __init__(self, test):
            self.test = test


        @rpc.expose
        def exposed(self, *args):
            self.test.assertEqual(args, self.expectedArgs)

            return self.expectedReturn


        @rpc.expose('named')
        def exposed_named(self, *args):
            self.test.assertEqual(args, self.expectedArgs)

            return self.expectedReturn


        def not_exposed(self, *args):
            self.test.assertEqual(args, self.expectedArgs)

            return self.expectedReturn


        @rpc.expose
        def deleted_func(self):
            pass


    del Foo.deleted_func


    def setUp(self):
        self.instance = self.Foo(self)


    def call(self, name, expectedArgs, expectedReturn):
        self.instance.expectedArgs = expectedArgs
        self.instance.expectedReturn = expectedReturn

        self.assertEqual(rpc.callExposedMethod(
            self.instance, name, *expectedArgs), expectedReturn)


    def test_exposed_unnamed(self):
        """
        Test unnamed.
        """
        self.call('exposed', (1, 2, 3), 'foo')


    def test_exposed_named(self):
        """
        Test named exposed function for args and return.
        """
        self.call('named', (1, 2, 3), 'foo')
        e = self.assertRaises(exc.CallFailed,
            self.call, 'exposed_named', (1, 2, 3), 'foo')

        self.assertEqual(str(e), "Method not found (exposed_named)")


    def test_not_exposed(self):
        """
        Ensure that calling an unexposed method results in a L{exc.CallFailed}
        exception.
        """
        e = self.assertRaises(exc.CallFailed,
            self.call, 'not_exposed', (), None)

        self.assertEqual(str(e), "Method not found (not_exposed)")


    def test_deleted_func(self):
        """
        Deleting a pre-exposed function should raise an error when calling
        that exposed method.
        """
        e = self.assertRaises(exc.CallFailed,
            self.call, 'deleted_func', (), None)

        self.assertEqual(str(e), "Method not found (deleted_func)")



class TestRuntimeError(RuntimeError):
    """
    A RuntimeError specific to this test suite.
    """



class SimpleFacilitator(rpc.AbstractCallHandler):
    """
    An implementation of L{rpc.AbstractCallHandler} that stores any messages
    were sent for later inspection.

    Exposes a number of simple methods.
    """

    def __init__(self, test):
        super(rpc.AbstractCallHandler, self).__init__()

        self.test = test
        self.messages = []


    def sendMessage(self, msg, whenDone=None):
        """
        Keeps track of any messages that were 'sent'.
        """
        self.messages.append(msg)


    @rpc.expose
    def exposed(self, *args):
        assert args, (1, 2, 3)
        self.test.executed = True


    @rpc.expose('named')
    def exposed_named(self, *args):
        assert args, (1, 2, 3)
        self.test.executed = True


    def not_exposed(self):
        pass


    @rpc.expose
    def known_return(self):
        self.test.executed = True

        return 'foo'


    @rpc.expose
    def known_failure(self):
        self.test.executed = True

        raise TestRuntimeError('This is my BOOOM stick!!')


    @rpc.expose
    def command_result(self):
        return rpc.CommandResult('foo', {'one': 'two'})



class CallReceiverTestCase(unittest.TestCase):
    """
    Tests receiving an RPC call.
    """


    def setUp(self):
        self.receiver = SimpleFacilitator(self)
        self.messages = self.receiver.messages
        self.executed = False

    def makeCall(self, name, *args, **kwargs):
        """
        Makes an RPC call on L{self.receiver}
        """
        return self.receiver.callReceived(
            name, self.receiver.getNextCallId(), *args, **kwargs)


    @defer.inlineCallbacks
    def test_already_active(self):
        """
        If an RPC request with the same callId is made whilst the first request
        is still 'active', an error should be thrown.
        """
        callId = self.receiver.getNextCallId()

        self.receiver.initiateCall(callId=callId)

        try:
            yield self.makeCall('foo', callId)
        except exc.CallFailed, e:
            pass
        else:
            self.fail('exc.CallFailed not raised')

        self.assertEqual(str(e), 'Unable to initiate an already active call 1')
        m = self.messages
        self.assertEqual(len(m), 1)

        msg = self.messages.pop()

        self.assertTrue(message.typeByClass(msg), message.Invoke)
        self.assertEqual(msg.name, '_error')
        self.assertEqual(msg.argv, [None, {
            'code': 'NetConnection.Call.Failed',
            'description': 'Unable to initiate an already active call 1',
            'level': 'error'
        }])
        self.assertEqual(msg.id, callId)


    @defer.inlineCallbacks
    def test_call_exposed(self):
        """
        Call an exposed method on the faciliator.
        """
        ret = yield self.receiver.callExposedMethod('exposed', 1, 2, 3)

        self.assertEqual(ret, None)
        self.assertTrue(self.executed)


    @defer.inlineCallbacks
    def test_call_exposed_named(self):
        """
        Call a named exposed method on the faciliator.
        """
        ret = yield self.receiver.callExposedMethod('named', 1, 2, 3)

        self.assertEqual(ret, None)
        self.assertTrue(self.executed)


    @defer.inlineCallbacks
    def test_call_known_result(self):
        """
        Call an exposed method with a known result
        """
        ret = yield self.receiver.callExposedMethod('known_return')

        self.assertEqual(ret, 'foo')
        self.assertTrue(self.executed)


    @defer.inlineCallbacks
    def test_successful_call(self):
        """
        Test a successful RPC call.
        """
        ret = yield self.makeCall('known_return')

        self.assertEqual(ret, 'foo')

        m = self.messages
        self.assertEqual(len(m), 1)

        msg = self.messages.pop()

        self.assertTrue(message.typeByClass(msg), message.Invoke)
        self.assertEqual(msg.name, '_result')
        self.assertEqual(msg.argv, [None, 'foo'])
        self.assertEqual(msg.id, 1)


    @defer.inlineCallbacks
    def test_failure_call(self):
        """
        Test an RPC call that raises an exception.
        """
        try:
            yield self.makeCall('known_failure')
        except TestRuntimeError, e:
            self.assertEqual(str(e), 'This is my BOOOM stick!!')
        else:
            self.fail('TestRuntimeError not raised.')

        m = self.messages
        self.assertEqual(len(m), 1)

        msg = self.messages.pop()

        self.assertTrue(message.typeByClass(msg), message.Invoke)
        self.assertEqual(msg.name, '_error')
        self.assertEqual(msg.argv, [None, {
            'code': 'NetConnection.Call.Failed',
            'description': 'This is my BOOOM stick!!',
            'level': 'error'
        }])
        self.assertEqual(msg.id, 1)


    @defer.inlineCallbacks
    def test_command_callback(self):
        """
        Test a command result and the message that is generated.
        """
        ret = yield self.makeCall('command_result')

        self.assertEqual(ret, 'foo')

        m = self.messages
        self.assertEqual(len(m), 1)

        msg = self.messages.pop()

        self.assertTrue(message.typeByClass(msg), message.Invoke)
        self.assertEqual(msg.name, '_result')
        self.assertEqual(msg.argv, [{'one': 'two'}, 'foo'])
        self.assertEqual(msg.id, 1)

########NEW FILE########
__FILENAME__ = test_server
# -*- coding: utf-8 -*-
#
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
"""

from twisted.trial import unittest
from twisted.internet import defer, reactor, protocol
from twisted.test.proto_helpers import StringTransportWithDisconnection, StringIOWithoutClosing

from rtmpy import server, exc, rpc, util
from rtmpy.protocol.rtmp import message



class SimpleApplication(object):
    """
    An L{server.IApplication} that returns a deferred for all that it can.
    """

    factory = None
    name = None
    client = None

    ret = None
    reject = False

    def __init__(self):
        self.events = []

    def _add_event(self, name, args, kwargs):
        self.events.append((name, args, kwargs))

    def startup(self, *args, **kwargs):
        self._add_event('startup', args, kwargs)

        return self.ret

    def shutdown(self, *args, **kwargs):
        self._add_event('shutdown', args, kwargs)

        return self.ret

    def buildClient(self, *args, **kwargs):
        self._add_event('build-client', args, kwargs)

        return self.client

    def onConnect(self, *args, **kwargs):
        self._add_event('on-connect', args, kwargs)

        return not self.reject

    def onConnectAccept(self, *args, **kwargs):
        self._add_event('on-connect-accept', args, kwargs)

    def onConnectReject(self, *args, **kwargs):
        self._add_event('on-connect-reject', args, kwargs)

    def acceptConnection(self, *args, **kwargs):
        self._add_event('accept-connection', args, kwargs)

    def onAppStart(self, *args, **kwargs):
        self._add_event('on-app-start', args, kwargs)


class MockProtocol(object):
    """
    A mock protocol used to test protocol.transport.getPeer() requests
    """
    class Transport(object):

        def __init__(self, good=True):
            if good:
                self._peer = self.GoodPeer()
            else:
                self._peer = self.BadPeer()

        class GoodPeer(object):
            host = "127.0.0.1"

        class BadPeer(object):
            pass

        def getPeer(self):
            return self._peer

    def __init__(self, good=True):
        self.transport = self.Transport(good)





class ApplicationRegisteringTestCase(unittest.TestCase):
    """
    Tests for L{server.ServerFactory.registerApplication}
    """

    def setUp(self):
        self.factory = server.ServerFactory()
        self.app = SimpleApplication()

    def test_create(self):
        """
        Test initial args for L{server.ServerFactory}
        """
        self.factory = server.ServerFactory({'foo': self.app})

        self.assertEqual(self.factory.applications, {'foo': self.app})

        d = self.app.ret = defer.Deferred()

        self.factory = server.ServerFactory({'foo': self.app})

        self.assertEqual(self.factory.applications, {})

        def cb(res):
            self.assertEqual(self.factory.applications, {'foo': self.app})

        reactor.callLater(0, d.callback, None)

    def test_create_unicode(self):
        """
        Test initial args for L{server.ServerFactory}
        """
        self.factory = server.ServerFactory({'': self.app})

        self.assertEqual(self.factory.applications, {'': self.app})

        d = self.app.ret = defer.Deferred()

        self.factory = server.ServerFactory({'': self.app})

        self.assertEqual(self.factory.applications, {})

        def cb(res):
            self.assertEqual(self.factory.applications, {'': self.app})

        reactor.callLater(0, d.callback, None)

    def test_invalid_pending(self):
        """
        Pending applications cannot be registered twice.
        """
        self.factory._pendingApplications['foo'] = None

        self.assertRaises(exc.InvalidApplication,
            self.factory.registerApplication, 'foo', None)

    def test_invalid_active(self):
        """
        Active applications cannot be registered twice.
        """
        self.factory.applications['foo'] = None

        self.assertRaises(exc.InvalidApplication,
            self.factory.registerApplication, 'foo', None)

    def test_deferred_startup(self):
        """
        Registering an application can be paused whilst the app is startup is
        called.
        """
        d = self.app.ret = defer.Deferred()
        ret = self.factory.registerApplication('foo', self.app)

        self.assertIsInstance(ret, defer.Deferred)
        self.assertEqual(self.app.factory, None)
        self.assertEqual(self.app.name, None)
        self.assertTrue('foo' in self.factory._pendingApplications)
        self.assertFalse('foo' in self.factory.applications)

        def cb(res):
            self.assertEqual(res, None)

            self.assertIdentical(self.app.factory, self.factory)
            self.assertEqual(self.app.name, 'foo')
            self.assertFalse('foo' in self.factory._pendingApplications)
            self.assertTrue('foo' in self.factory.applications)

        ret.addCallback(cb)

        reactor.callLater(0, d.callback, None)

        return ret

    def test_failed_deferred(self):
        """
        An error in app.startup should stop the registering process
        """
        def blowup():
            raise RuntimeError

        self.patch(self.app, 'startup', blowup)

        ret = self.factory.registerApplication('foo', self.app)

        self.assertIsInstance(ret, defer.Deferred)

        def eb(fail):
            fail.trap(RuntimeError)

            self.assertEqual(self.app.factory, None)
            self.assertEqual(self.app.name, None)
            self.assertFalse('foo' in self.factory._pendingApplications)
            self.assertFalse('foo' in self.factory.applications)

        ret.addErrback(eb)

        return ret


class ApplicationUnregisteringTestCase(unittest.TestCase):
    """
    Tests for L{server.ServerFactory.unregisterApplication}
    """

    def setUp(self):
        self.factory = server.ServerFactory()
        self.app = SimpleApplication()

    def test_not_registered(self):
        """
        Unregistering an unknown app should error.
        """
        self.assertRaises(exc.InvalidApplication,
            self.factory.unregisterApplication, 'foo')

    def test_unregister_pending(self):
        """
        Unregistering a pending application should immediately succeed.
        """
        # this never gets its callback fired, meaning that after registering
        # the application, it is considered pending.
        self.app.ret = defer.Deferred()

        self.factory.registerApplication('foo', self.app)

        self.assertTrue('foo' in self.factory._pendingApplications)

        d = self.factory.unregisterApplication('foo')

        def cb(res):
            self.assertIdentical(res, self.app)

        d.addCallback(cb)

        return d

    def test_simple_unregister(self):
        """
        app.shutdown doesn't need to return a deferred
        """
        self.factory.registerApplication('foo', self.app)

        ret = self.factory.unregisterApplication('foo')

        self.assertIsInstance(ret, defer.Deferred)

        def cb(res):
            self.assertIdentical(res, self.app)

            self.assertEqual(self.app.factory, None)
            self.assertEqual(self.app.name, None)
            self.assertFalse('foo' in self.factory._pendingApplications)
            self.assertFalse('foo' in self.factory.applications)

        ret.addCallback(cb)

        return ret

    def test_deferred(self):
        """
        app.shutdown can return a deferred
        """
        self.factory.registerApplication('foo', self.app)
        d = self.app.ret = defer.Deferred()

        ret = self.factory.unregisterApplication('foo')

        self.assertIsInstance(ret, defer.Deferred)

        def cb(res):
            self.assertIdentical(res, self.app)

            self.assertEqual(self.app.factory, None)
            self.assertEqual(self.app.name, None)
            self.assertFalse('foo' in self.factory._pendingApplications)
            self.assertFalse('foo' in self.factory.applications)

        ret.addCallback(cb)

        reactor.callLater(0, d.callback, None)

        return ret

    def test_deferred_failure(self):
        """
        Removing the app from the factory should not fail due to app.shutdown
        erroring.
        """
        self.factory.registerApplication('foo', self.app)

        d = self.app.ret = defer.Deferred()

        def boom(res):
            self.executed = True

            raise RuntimeError

        d.addCallback(boom)

        ret = self.factory.unregisterApplication('foo')

        self.assertIsInstance(ret, defer.Deferred)

        def cb(res):
            self.assertIdentical(res, self.app)
            self.assertTrue(self.executed)

            self.assertEqual(self.app.factory, None)
            self.assertEqual(self.app.name, None)
            self.assertFalse('foo' in self.factory._pendingApplications)
            self.assertFalse('foo' in self.factory.applications)

        ret.addCallback(cb)

        reactor.callLater(0, d.callback, None)

        return ret


class ServerFactoryTestCase(unittest.TestCase):
    """
    """

    def setUp(self):
        self.factory = server.ServerFactory()
        self.protocol = self.factory.buildProtocol(None)
        self.transport = StringTransportWithDisconnection()
        self.nc = server.NetConnection(self.protocol)

        self.protocol.makeConnection(self.transport)
        self.transport.protocol = self.protocol
        self.protocol.versionReceived(3)
        self.protocol.handshakeSuccess('')

        self.manager = self.protocol.streamManager

    def connect(self, app, protocol):
        client = app.buildClient(self.nc, {'app': 'foo'})

        app.acceptConnection(client)

        protocol.nc.connected = True
        protocol.nc.client = client
        protocol.nc.application = app

        return client

    def createStream(self, manager):
        """
        Returns the L{server.NetStream} as created by the protocol
        """
        return manager.getStream(manager.createStream())


class ServerFactoryDisconnectedTestCase(unittest.TestCase):
    """
    """

    def setUp(self):
        self.factory = server.ServerFactory()
        self.protocol = self.factory.buildProtocol(None)
        self.transport = StringTransportWithDisconnection()
        self.nc = server.NetConnection(self.protocol)

        self.protocol.connectionMade()
        self.transport.protocol = self.protocol
        self.protocol.transport = self.transport
        self.protocol.versionReceived(3)
        self.protocol.handshakeSuccess('')

        self.manager = self.protocol.streamManager

    def connect(self, app, protocol):
        client = app.buildClient(self.nc, {'app': 'foo'})

        app.acceptConnection(client)

        protocol.nc.connected = True
        protocol.nc.client = client
        protocol.nc.application = app

        return client

    def createStream(self, manager):
        """
        Returns the L{server.NetStream} as created by the protocol
        """
        return manager.getStream(manager.createStream())


class ConnectingTestCase(unittest.TestCase):
    """
    Tests all facets of connecting to an RTMP server.
    """

    def setUp(self):
        self.file = StringIOWithoutClosing()
        self.transport = protocol.FileWrapper(self.file)

        self.factory = server.ServerFactory()
        self.protocol = self.factory.buildProtocol(None)

        self.protocol.factory = self.factory

        self.protocol.transport = self.transport
        self.protocol.connectionMade()
        self.protocol.versionSuccess()
        self.protocol.handshakeSuccess('')

        self.messages = []

        def send_message(*args):
            self.messages.append(args)

        self.patch(self.protocol.nc, 'sendMessage', send_message)

        self.control = self.protocol.controlStream


    def assertStatus(self, code=None, description=None, level='status'):
        """
        Ensures that a status message has been sent.
        """
        stream, msg = self.messages.pop(0)

        self.assertEqual(self.messages, [])

        self.assertIdentical(stream, self.control)

        self.assertIsInstance(msg, message.Invoke)
        self.assertEqual(msg.name, 'onStatus')

        _, args = msg.argv

        self.assertEqual(_, None)

        if code is not None:
            self.assertEqual(args['code'], code)

        if description is not None:
            self.assertEqual(args['description'], description)

        self.assertEqual(args['level'], level)


    def assertErrorStatus(self, code=None, description=None):
        """
        Ensures that a status message has been sent.
        """
        if code is None:
            code = 'NetConnection.Connect.Failed'

        if description is None:
            description = 'Internal Server Error'

        self.assertStatus(code, description, 'error')


    def assertMessage(self, msg, type_, **state):
        """
        Ensure that the msg is of a particular type and state
        """
        self.assertEqual(message.typeByClass(msg), type_)

        d = msg.__dict__

        for k, v in state.copy().iteritems():
            self.assertEqual(v, d[k])
            del state[k]

        self.assertEqual(state, {})

    def connect(self, params, *args):
        return self.control.onConnect(params, *args)

    def test_invoke(self):
        """
        Make sure that invoking connect call self.protocol.onConnect
        """
        my_args = {'foo': 'bar'}
        self.executed = False

        def connect(args):
            self.executed = True
            self.assertEqual(args, my_args)

        self.patch(self.control, 'onConnect', connect)

        d = self.control.onInvoke('connect', 0, [my_args], 0)

        return d

    def test_missing_app_key(self):
        """
        RTMP connect packets contain {'app': 'name_of_app'}.
        """
        d = self.connect({})

        def cb(res):
            self.assertEqual(res, {
                'code': 'NetConnection.Connect.Failed',
                'description': "Bad connect packet (missing 'app' key)",
                'level': 'error',
                'objectEncoding': 0
            })

        d.addCallback(cb)

        return d

    def test_random_failure(self):
        """
        If something random goes wrong, make sure the status is correctly set.
        """
        def bork(*args):
            raise EnvironmentError('woot')

        self.patch(self.protocol.nc, '_onConnect', bork)

        d = self.connect({})

        def cb(res):
            self.assertEqual(res, {
                'code': 'NetConnection.Connect.Failed',
                'description': 'woot',
                'level': 'error',
                'objectEncoding': 0
            })


        d.addCallback(cb)

        return d

    def test_random_failure_unicode(self):
        """
        If something random goes wrong, make sure the status is correctly set.
        """
        def bork(*args):
            raise EnvironmentError('')

        self.patch(self.protocol.nc, '_onConnect', bork)

        d = self.connect({})

        def cb(res):
            self.assertEqual(res, {
                'code': 'NetConnection.Connect.Failed',
                'description': '',
                'level': 'error',
                'objectEncoding': 0
            })


        d.addCallback(cb)

        return d

    def test_unknown_application(self):
        self.assertEqual(self.factory.getApplication('what'), None)

        d = self.connect({'app': 'what'})

        def cb(res):
            self.assertEqual(res, {
                'code': 'NetConnection.Connect.InvalidApp',
                'description': "Unknown application 'what'",
                'level': 'error',
                'objectEncoding': 0
            })

        d.addCallback(cb)

        return d

    def test_unknown_application_unicode(self):
        self.assertEqual(self.factory.getApplication('what'), None)

        d = self.connect({'app': ''})

        def cb(res):
            self.assertEqual(res, {
                'code': 'NetConnection.Connect.InvalidApp',
                'description': "Unknown application ''",
                'level': 'error',
                'objectEncoding': 0
            })

        d.addCallback(cb)

        return d

    def test_success(self):
        """
        Ensure a successful connection to application
        """
        self.factory.applications['what'] = SimpleApplication()

        d = self.connect({'app': 'what'})

        def check_status(res):
            self.assertIsInstance(res, rpc.CommandResult)
            self.assertEqual(res.command, {
                'capabilities': 31, 'fmsVer': 'FMS/3,5,1,516', 'mode': 1})
            self.assertEqual(res.result, {
                'code': 'NetConnection.Connect.Success',
                'objectEncoding': 0,
                'description': 'Connection succeeded.',
                'level': 'status'
            })

            msg, = self.messages.pop(0)

            self.assertMessage(msg, message.DOWNSTREAM_BANDWIDTH,
                bandwidth=2500000L)

            msg, = self.messages.pop(0)

            self.assertMessage(msg, message.UPSTREAM_BANDWIDTH,
                bandwidth=2500000L, extra=2)

            msg, = self.messages.pop(0)

            self.assertMessage(msg, message.CONTROL,
                type=0, value1=0)

            self.assertEqual(self.messages, [])

        d.addCallback(check_status)

        self.protocol.onDownstreamBandwidth(2000, 2)

        return d

    def test_connect_args(self):
        """
        Ensure a successful connection to application with optional user
        arguments being passed.

        The arguments should be available to various application methods
        such as onConnect, buildClient, etc.
        """
        a = self.factory.applications['what'] = SimpleApplication()
        a.client = object()

        client_params = {'app': 'what'} # Connect packet parameters
        client_args = ("foo", "bar") # Arguments passed to NC.connect()

        d = self.connect(client_params, *client_args)

        def check_status(res):
            name, args, kwargs = a.events.pop()
            self.assertEqual(name, 'on-connect-accept')

            name, args, kwargs = a.events.pop()
            self.assertEqual(name, 'accept-connection')

            name, args, kwargs = a.events.pop()
            self.assertEqual(name, 'on-connect')
            self.assertIdentical(args[0], a.client)
            self.assertEqual(args[1:], client_args)
            self.assertEqual(len(args), 3)
            self.assertEqual(kwargs, {})

            name, args, kwargs = a.events.pop()
            self.assertEqual(name, 'build-client')
            self.assertIdentical(args[0], self.protocol.nc)
            self.assertEqual(args[1], client_params)
            self.assertEqual(args[2:], client_args)
            self.assertEqual(len(args), 4)

        d.addCallback(check_status)

        self.protocol.onDownstreamBandwidth(2000, 2)

        return d

    def test_dynamic_app_success(self):
        """
        Ensure a successful connection
        """
        def getApplication(args):
            return SimpleApplication()

        self.patch(self.factory, "getApplication", getApplication)

        d = self.connect({'app': 'what'})

        def check_status(res):
            self.assertIsInstance(res, rpc.CommandResult)
            self.assertEqual(res.command, {
                'capabilities': 31, 'fmsVer': 'FMS/3,5,1,516', 'mode': 1})
            self.assertEqual(res.result, {
                'code': 'NetConnection.Connect.Success',
                'objectEncoding': 0,
                'description': 'Connection succeeded.',
                'level': 'status'
            })

            msg, = self.messages.pop(0)

            self.assertMessage(msg, message.DOWNSTREAM_BANDWIDTH,
                bandwidth=2500000L)

            msg, = self.messages.pop(0)

            self.assertMessage(msg, message.UPSTREAM_BANDWIDTH,
                bandwidth=2500000L, extra=2)

            msg, = self.messages.pop(0)

            self.assertMessage(msg, message.CONTROL,
                type=0, value1=0)

            self.assertEqual(self.messages, [])

        d.addCallback(check_status)

        self.protocol.onDownstreamBandwidth(2000, 2)

        return d

    def test_reject(self):
        """
        Test the connection being rejected
        """
        a = self.factory.applications['what'] = SimpleApplication()
        a.reject = True
        a.client = object()

        d = self.connect({'app': 'what'})

        def check_status(res):
            self.assertEqual(res, {
                'code': 'NetConnection.Connect.Rejected',
                'level': 'error',
                'description': 'Authorization is required',
                'objectEncoding': 0
            })

            self.assertEqual(self.messages, [])

            name, args, kwargs = a.events.pop()

            self.assertEqual(name, 'on-connect-reject')
            self.assertIdentical(args[0], a.client)
            self.assertEqual(len(args), 2)
            self.assertEqual(kwargs, {})

        d.addCallback(check_status)

        return d

    def test_reject_with_args(self):
        """
        Test that the arguments passed to NetConnection.connect() are passed
        to onConnectReject
        """
        a = self.factory.applications['what'] = SimpleApplication()
        a.reject = True
        a.client = object()

        client_params = {'app': 'what'} # Connect packet parameters
        client_args = ("foo", "bar") # Arguments passed to NC.connect()

        d = self.connect(client_params, *client_args)

        def check_status(res):
            name, args, kwargs = a.events.pop()

            self.assertEqual(name, 'on-connect-reject')
            self.assertIdentical(args[0], a.client)
            self.assertEqual(args[2:], client_args)
            self.assertEqual(len(args), 4)
            self.assertEqual(kwargs, {})

        d.addCallback(check_status)

        return d

    def test_client_properties(self):
        """
        Ensure that buildClient properly populates Client properties
        """
        a = server.Application()
        p = MockProtocol(True)

        client_params = {
            'flashVer': 'MAC 10,2,154,13', 'app': 'what',
            'pageUrl': 'http://foo.com/page',
            'tcUrl': 'rtmp://localhost/live'
            }

        c = a.buildClient(p, client_params)

        self.assertIdentical(c.nc, p)
        self.assertIdentical(c.application, a)
        self.assertEquals(c.ip, '127.0.0.1')
        self.assertEquals(c.agent, 'MAC 10,2,154,13')
        self.assertEquals(c.pageUrl, 'http://foo.com/page')
        self.assertEquals(c.uri, 'rtmp://localhost/live')
        self.assertEquals(c.protocol, 'rtmp')

        return

    def test_missing_client_properties(self):
        """
        Ensure that buildClient properly handles missing properties
        """
        a = server.Application()
        p = MockProtocol(False)

        client_params = {'app': 'what'}

        c = a.buildClient(p, client_params)

        self.assertIdentical(c.nc, p)
        self.assertIdentical(c.application, a)
        self.assertEquals(c.ip, None)
        self.assertEquals(c.agent, None)
        self.assertEquals(c.pageUrl, None)
        self.assertEquals(c.uri, None)
        self.assertEquals(c.protocol, None)

        return


class TestRuntimeError(RuntimeError):
    pass


class ApplicationInterfaceTestCase(ServerFactoryTestCase):
    """
    Tests for L{server.ServerProtocol} implementing the L{server.IApplication}
    interface correctly.
    """

    def setUp(self):
        ServerFactoryTestCase.setUp(self)

        self.app = server.Application()
        self.client = self.app.buildClient(self.nc, {'app': 'foo'})
        self.app.acceptConnection(self.client)

        return self.factory.registerApplication('foo', self.app)

    def test_onDisconnect(self):
        """
        Ensure that C{onDisconnect} is called when calling C{app.disconnect}
        """
        self.executed = False

        def foo(client):
            self.assertIdentical(self.client, client)
            self.executed = True

        self.app.onDisconnect = foo

        self.app.disconnect(self.client)

        self.assertTrue(self.executed)

    def test_onDisconnect_error(self):
        """
        Ensure that if onDisconnect raises an error, that execution continues
        smoothly.
        """
        self.executed = False

        def foo(client):
            self.executed = True

            raise TestRuntimeError('Die!!')

        self.app.onDisconnect = foo

        self.app.disconnect(self.client)

        self.assertTrue(self.executed)
        self.flushLoggedErrors(TestRuntimeError)


class ClientInterfaceTestCase(unittest.TestCase):
    """
    Tests for L{server.Client} implementing the L{server.IClient}
    interface correctly.
    """

    def setUp(self):
        self.client = server.Client(None)


    def test_client_call(self):
        """
        Ensure that invoking call on a client passes all proper arguments
        """

        class MockNetConnection(object):
            """
            Mock NetConnection object to test Client APIs
            """

            def __init__(self):
                self.events = []

            def _add_event(self, args, kwargs):
                self.events.append((args, kwargs))

            def call(self, *args, **kwargs):
                self._add_event(args, kwargs)

        nc = self.client.nc = MockNetConnection()

        self.client.call("method_name", 1, "string", kw="Hello")

        args, kwargs = nc.events.pop()
        self.assertEqual(args, ('method_name', 1, 'string'))
        self.assertEqual(kwargs, {'kw': 'Hello'})


class PublishingTestCase(ServerFactoryTestCase):
    """
    Tests for all facets of publishing a stream
    """

    def setUp(self):
        ServerFactoryTestCase.setUp(self)

        self.stream_status = {}

        self.app = server.Application()

        return self.factory.registerApplication('foo', self.app)


    def createStream(self):
        """
        Returns the L{server.NetStream} as created by the protocol
        """
        stream = self.manager.getStream(self.manager.createStream())

        def capture_status(s):
            self.stream_status[stream] = s

        stream.sendStatus = capture_status

        return stream


    def assertStatus(self, stream, s):
        self.assertEqual(self.stream_status[stream], s)


    def test_publish(self):
        """
        Test app, client and protocol state on a successful first time publish
        """
        self.client = self.connect(self.app, self.protocol)

        s = self.createStream()

        d = s.publish('foo')

        def cb(result):
            # app
            self.assertIdentical(result, self.app.streams['foo'])

            # stream
            self.assertIdentical(s.publisher, result)
            self.assertEqual(s.state, 'publishing')

            # result
            self.assertIdentical(result.stream, s)
            self.assertIdentical(result.client, self.client)
            self.assertEqual(result.subscribers, {})
            self.assertEqual(result.timestamp, 0)

            # rtmp status
            self.assertStatus(s, {
                'code': 'NetStream.Publish.Start',
                'description': 'foo is now published.',
                'clientid': self.client.id,
                'level': 'status'
            })


        return d.addCallback(cb)




    def test_kill_connection_after_successful_publish(self):
        """
        After a successful publish, the peer disconnects rudely. Check app state
        """
        self.client = self.connect(self.app, self.protocol)
        s = self.createStream()

        d = s.publish('foo')

        def kill_connection(result):
            self.transport.loseConnection()

            self.assertEqual(self.app.streams, {})
            self.assertEqual(self.app.clients, {})

            self.assertStatus(s, {
                'code': 'NetStream.Unpublish.Success',
                'description': u'foo is now unpublished.',
                'clientid': self.client.id,
                'level': 'status'
            })

        d.addCallback(kill_connection)

        return d


class PublishingDisconnectedTestCase(ServerFactoryDisconnectedTestCase):
    """
    Tests for publishing a stream when the transport is disconnected
    """

    def setUp(self):
        ServerFactoryDisconnectedTestCase.setUp(self)

        self.stream_status = {}

        self.app = server.Application()

        return self.factory.registerApplication('foo', self.app)


    def createStream(self):
        """
        Returns the L{server.NetStream} as created by the protocol
        """
        stream = self.manager.getStream(self.manager.createStream())

        def capture_status(s):
            self.stream_status[stream] = s

        stream.sendStatus = capture_status

        return stream


    def assertStatus(self, stream, s):
        self.assertEqual(self.stream_status[stream], s)


    def test_not_connected(self):
        """
        Test publish with a disconnected transport
        """
        s = self.createStream()

        self.assertFalse(self.protocol.connected)

        d = s.publish('foo')

        def eb(f):
            f.trap(exc.ConnectError)

            self.assertEqual(f.getErrorMessage(), 'Cannot publish stream - not connected')

            self.assertStatus(s, {
                'code': 'NetConnection.Call.Failed',
                'description': 'Cannot publish stream - not connected',
                'level': 'error'
            })

        return d.addErrback(eb)


class PlayTestCase(ServerFactoryTestCase):
    """
    Tests for L{NetStream.play}
    """


    def setUp(self):
        ServerFactoryTestCase.setUp(self)

        self.app = server.Application()

        return self.factory.registerApplication('foo', self.app)


    def test_pending(self):
        """
        Test if the stream does not exist, the play command is put in a
        suspended state, until a stream with the right name is published.
        """
        client = self.connect(self.app, self.protocol)
        m = self.protocol.streamManager

        s = self.createStream(m)

        self.assertFalse('foo' in self.app.streams)

        d = s.play('foo')

        self.assertFalse(d.called)

        res = self.app.publishStream(client, s, 'foo')

        self.assertTrue('foo' in self.app.streams)
        self.assertTrue(s in res.subscribers)


    def test_existing(self):
        """
        Test if the stream does already exist, the play command is immediately
        completed.
        """
        client = self.connect(self.app, self.protocol)

        s = self.createStream(self.protocol.streamManager)

        self.assertFalse('foo' in self.app.streams)

        self.app.publishStream(client, s, 'foo')

        d = s.play('foo')

        self.assertTrue(d.called)

        def cb(res):
            self.assertTrue(s in res.subscribers)

        d.addCallback(cb)

        return d



class Publisher(object):
    """
    A value object that acts like a publisher.
    """

    meta_data = None


    def onMetaData(self, data):
        self.meta_data = data



class SendTestCase(ServerFactoryTestCase):
    """
    Tests for L{server.NetStream.send}
    """

    def setUp(self):
        ServerFactoryTestCase.setUp(self)

        self.app = server.Application()

        d = self.factory.registerApplication('foo', self.app)

        def cb(res):
            self.client = self.connect(self.app, self.protocol)
            m = self.protocol.streamManager

            self.stream = self.createStream(m)
            self.publisher = Publisher()
            self.stream.publishingStarted(self.publisher, 'spammy')

            return res

        d.addCallback(cb)

        return d


    def sendMessage(self, msg, stream=None, timestamp=None):
        """
        Dispatches an RTMP message to the protocol. Useful for mocking 'real'
        RTMP calls.
        """
        if stream is None:
            stream = self.protocol

        msg.dispatch(stream, timestamp or 0)


    def setMetaData(self, data):
        """
        Dispatches an RTMP message to call L{NetStream.setDataFrame}.
        """
        m = message.Notify('@setDataFrame', 'onMetaData', data)

        self.sendMessage(m, self.stream)


    def clearMetaData(self):
        """
        Dispatches an RTMP message to call L{NetStream.clearDataFrame}.
        """
        m = message.Notify('@clearDataFrame', 'onMetaData')

        self.sendMessage(m, self.stream)

        self.assertEqual(self.publisher.meta_data, {})


    def assertMetaData(self, data):
        """
        Short cut to check that the meta data
        """
        self.assertEqual(self.publisher.meta_data, data)


    def test_set_data_frame(self):
        """
        An RTMP message setting the meta data must call
        L{ServerProtocol.setDataFrame} accordingly, which in turn must call
        L{stream.publisher.onMetaData}.
        """
        self.setMetaData({})

        self.setMetaData({'foo': 'bar'})
        self.assertMetaData({'foo': 'bar'})

        self.setMetaData({'foo': 'baz'})
        self.assertMetaData({'foo': 'baz'})

        self.setMetaData({'gak': 'baz'})
        self.assertMetaData({'gak': 'baz'})


    def test_clear_data_frame(self):
        """
        An RTMP message setting the meta data must call
        L{ServerProtocol.clearDataFrame} accordingly, which in turn must call
        L{stream.publisher.onMetaData} with the appropriate args.
        """
        self.setMetaData({'gak': 'baz'})

        self.clearMetaData()
        self.assertMetaData({})

########NEW FILE########
__FILENAME__ = test_status
"""
Tests for L{rtmpy.core.status}
"""

from twisted.trial import unittest

from rtmpy.core import status



class StatusHelperTestCase(unittest.TestCase):
    """
    Tests for L{status.status}
    """


    def test_interface(self):
        """
        Ensure that the returned status object implements the correct interface.
        """
        s = status.status(None, None)

        self.assertTrue(status.IStatus.providedBy(s))


    def test_return(self):
        """
        Check the attribute allocation.
        """
        s = status.status('foo', 'bar', spam='eggs', gak=[1, 2, 3])

        # core attributes
        self.assertEqual(s.level, 'status')
        self.assertEqual(s.code, 'foo')
        self.assertEqual(s.description, 'bar')

        # extra context
        self.assertEqual(s.spam, 'eggs')
        self.assertEqual(s.gak, [1, 2, 3])



class ErrorHelperTestCase(unittest.TestCase):
    """
    Tests for L{status.error}
    """

    def test_interface(self):
        """
        Ensure that the returned status object implements the correct interface.
        """
        s = status.error(None, None)

        self.assertTrue(status.IStatus.providedBy(s))


    def test_return(self):
        """
        Check the attribute allocation.
        """
        s = status.error('foo', 'bar', spam='eggs', gak=[1, 2, 3])

        # core attributes
        self.assertEqual(s.level, 'error')
        self.assertEqual(s.code, 'foo')
        self.assertEqual(s.description, 'bar')

        # extra context
        self.assertEqual(s.spam, 'eggs')
        self.assertEqual(s.gak, [1, 2, 3])



class StatusTestCase(unittest.TestCase):
    """
    Tests for L{status.Status}
    """


    def test_interface(self):
        """
        Ensure that the correct interface is implemented.
        """
        self.assertTrue(status.IStatus.implementedBy(status.Status))

        s = status.Status(None, None, None)

        self.assertTrue(status.IStatus.providedBy(s))


    def test_create(self):
        """
        Test attribute allocation.
        """
        s = status.Status('foo', 'bar', 'baz', spam='eggs')

        self.assertEqual(s.level, 'foo')
        self.assertEqual(s.code, 'bar')
        self.assertEqual(s.description, 'baz')

        self.assertEqual(s.spam, 'eggs')


    def test_unicode(self):
        """
        Ensure that unicode is handled correctly.
        """
        s = status.Status(None, 'bar', 'baz')

        self.assertEqual(unicode(s), 'bar: baz')

    def test_equality(self):
        """
        Its all in the name.
        """
        s = status.Status('foo', 'bar', 'baz')

        # simple scalar checks
        self.assertNotEqual(s, 1)
        self.assertNotEqual(s, None)
        self.assertNotEqual(s, 'foo')

        ref_dict = {
            'level': 'foo',
            'code': 'bar',
            'description': 'baz'
        }

        self.assertEqual(s, ref_dict)


    def test_extra(self):
        """
        Test L{Status.getExtraContext}.
        """
        s = status.Status('foo', 'bar', 'baz', spam='eggs', extra='context')

        self.assertEqual(s.getExtraContext(), {
            'spam': 'eggs',
            'extra': 'context'
        })


    def test_repr(self):
        """
        Test for C{repr(status.Status)}.
        """
        s = status.Status('foo', 'bar', 'baz', spam='eggs', extra='context')

        self.assertEqual(repr(s), ("<rtmpy.status.Status level='foo', "
            "code='bar', description='baz', extra={'spam': 'eggs', 'extra': "
            "'context'} at 0x%x>" % (id(s),)))



class AMFEncodingTestCase(unittest.TestCase):
    """
    Tests to ensure that AMF encoding works smoothly.
    """


    def setUp(self):
        import pyamf

        try:
            pyamf.get_class_alias(status.Status)
        except pyamf.UnknownClassAlias:
            self._old_alias = None
        else:
            raise RuntimeError(
                'Unexpected status.Status class registered in PyAMF')

        self.alias = pyamf.register_class(status.Status)


    def tearDown(self):
        import pyamf

        pyamf.unregister_class(status.Status)

        if self._old_alias:
            pyamf.register_class(self._old_alias)


    def test_static_attributes(self):
        """
        Ensure that the core attributes will be encoded in order correctly.
        """
        self.alias.compile()

        self.assertEqual(
            self.alias.static_attrs, ['level', 'code', 'description'])


    def test_amf0(self):
        """
        Test encoding in AMF0.
        """
        import pyamf

        ref_dict = {
            'level': 'alevel',
            'code': 'Some.Code.Here',
            'description': 'Look mom, no hands!'
        }

        s = status.Status(
            ref_dict['level'],
            ref_dict['code'],
            ref_dict['description'])

        blob = pyamf.encode(s, encoding=pyamf.AMF0)

        decoded_status = pyamf.decode(blob, encoding=pyamf.AMF0).next()

        self.assertEqual(decoded_status, s)


    def test_amf3(self):
        """
        Test encoding in AMF3.
        """
        import pyamf

        ref_dict = {
            'level': 'alevel',
            'code': 'Some.Code.Here',
            'description': 'Look mom, no hands!'
        }

        s = status.Status(
            ref_dict['level'],
            ref_dict['code'],
            ref_dict['description'])

        blob = pyamf.encode(s, encoding=pyamf.AMF3)

        decoded_status = pyamf.decode(blob, encoding=pyamf.AMF3).next()

        self.assertEqual(decoded_status, s)



class TestRuntimeError(RuntimeError):
    """
    """



class FromFailureTestCase(unittest.TestCase):
    """
    Tests for L{status.fromFailure}
    """


    def buildFailure(self, exc_type, msg):
        try:
            raise exc_type(msg)
        except exc_type:
            from twisted.python import failure

            return failure.Failure()


    def test_status(self):
        """
        Ensure that L{statust.fromFailure} works as expected
        """
        f = self.buildFailure(TestRuntimeError, 'foo bar')

        s = status.fromFailure(f)

        self.assertTrue(status.IStatus.providedBy(s))
        self.assertEqual(s.level, 'error')
        self.assertEqual(s.code, None)
        self.assertEqual(s.description, 'foo bar')


    def test_default_code(self):
        """
        L{status.fromFailure} looks for a C{code} attribute on the exception
        instance contained in the failure. If one is not present, supplying a
        default code is allowed.
        """
        f = self.buildFailure(RuntimeError, 'spam eggs')

        self.assertFalse(hasattr(f.value, 'code'))

        s = status.fromFailure(f, 'default code')

        self.assertTrue(status.IStatus.providedBy(s))
        self.assertEqual(s.level, 'error')
        self.assertEqual(s.code, 'default code')
        self.assertEqual(s.description, 'spam eggs')

########NEW FILE########
__FILENAME__ = test_util
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Tests for L{rtmpy.util}
"""

import __builtin__
import sys
import warnings

from twisted.trial import unittest

from rtmpy import util


class UptimeTestCase(unittest.TestCase):
    def setUp(self):
        util.boottime = None


class LinuxUptimeTestCase(UptimeTestCase):
    def setUp(self):
        UptimeTestCase.setUp(self)

        self.orig_open = __builtin__.open

    def tearDown(self):
        __builtin__.open = self.orig_open

    def test_error_open(self):
        def open_error(path, mode=None):
            raise IOError

        __builtin__.open = open_error
        self.assertEquals(util.uptime_linux(), 0)

    def test_bad_content(self):
        def open_error(path, mode=None):
            class BadContentFileObject:
                read = lambda _: '123.bar'
                close = lambda _: None
                readlines = lambda _: []

            return BadContentFileObject()

        __builtin__.open = open_error

        self.assertEquals(util.uptime_linux(), 0)

    def test_okay(self):
        self.assertNotEquals(util.uptime_linux(), 0)


class Win32UptimeTestCase(UptimeTestCase):
    def test_okay(self):
        self.assertNotEquals(util.uptime_win32(), 0)


class DarwinUptimeTestCase(UptimeTestCase):
    def test_okay(self):
        self.assertNotEquals(util.uptime_darwin(), 0)


class UnknownPlatformUptimeTestCase(unittest.TestCase):
    def setUp(self):
        self.platform = sys.platform
        sys.platform = ''
        util.boottime = None

    def tearDown(self):
        sys.platform = self.platform

    def test_warning(self):
        warnings.filterwarnings('error', category=RuntimeWarning)
        self.assertRaises(RuntimeWarning, util.uptime)

        warnings.filterwarnings('ignore', category=RuntimeWarning)
        util.uptime()

        self.assertNotEquals(util.boottime, None)


class ParamedStringTestCase(unittest.TestCase):
    """
    Tests for L{util.ParamedString}
    """

    def test_create(self):
        """
        Simple creation.
        """
        x = util.ParamedString('foobar')

        self.assertEqual(x, 'foobar')

    def test_params(self):
        """
        """
        x = util.ParamedString('foobar?foo=foo&bar=bar&bar=baz')

        self.assertEqual(x, 'foobar')
        self.assertEqual(x.foo, 'foo')
        self.assertEqual(x.bar, ['bar', 'baz'])

        self.assertRaises(AttributeError, getattr, x, 'baz')



class GetCallableTargetTestCase(unittest.TestCase):
    """
    Tests for L{util.get_callable_target}
    """

    def setUp(self):
        class TestObject(object):
            not_callable = False

            def callable(self):
                pass

        self.object = TestObject()


    def test_no_attr(self):
        """
        Should return C{None} if no attribute exists
        """
        self.assertFalse(hasattr(self.object, 'foo'))
        self.assertIdentical(None, util.get_callable_target(self.object, 'foo'))


    def test_not_callable(self):
        """
        Should return C{None} if attribute exists but not callable.
        """
        self.assertTrue(hasattr(self.object, 'not_callable'))
        self.assertFalse(hasattr(self.object.not_callable, '__call__'))

        self.assertIdentical(None, util.get_callable_target(self.object,
            'not_callable'))


    def test_callable(self):
        """
        Should return a callable if the attribute exists and is callable.
        """
        self.assertTrue(hasattr(self.object, 'callable'))
        self.assertTrue(hasattr(self.object.callable, '__call__'))

        c = util.get_callable_target(self.object, 'callable')

        self.assertNotIdentical(None, c)
        self.assertTrue(c, '__call__')


if not sys.platform.startswith('linux'):
    LinuxUptimeTestCase.skip = 'Tested platform is not linux'

if not sys.platform.startswith('win32'):
    Win32UptimeTestCase.skip = 'Tested platform is not win32'

if not sys.platform.startswith('darwin'):
    DarwinUptimeTestCase.skip = 'Tested platform is not darwin'

UnknownPlatformUptimeTestCase = None
DarwinUptimeTestCase = None
########NEW FILE########
__FILENAME__ = test_versions
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Tests for L{rtmpy.versions}.
"""

from twisted.trial import unittest

from rtmpy.versions import Version, FLASH_MIN_H264, FMS_MIN_H264


class VersionTestCase(unittest.TestCase):
    """
    Tests for L{rtmpy.versions.Version}
    """

    def test_repr(self):
        v = Version('10,0,12,36')

        self.assertEquals(repr(v), 'rtmpy.versions.Version(10,0,12,36) ' \
            'at 0x%x' % (id(v),))

    def test_str(self):
        v = Version('10,0,12,36')

        self.assertEquals(str(v), '10,0,12,36')

    def test_init(self):
        e = self.assertRaises(ValueError, Version)
        self.assertEquals(str(e), 'Expected 4 parts for version (got:0)')

        # too many args
        e = self.assertRaises(ValueError, Version, 1, 2, 3, 4, 5)
        self.assertEquals(str(e), 'Expected 4 parts for version (got:5)')

        # single string
        v = Version('10,0,12,36')
        self.assertEquals(v.parts, [10, 0, 12, 36])

        # single int
        v = Version(0x0a000c24)
        self.assertEquals(v.parts, [10, 0, 12, 36])

    def test_values(self):
        e = self.assertRaises(ValueError, Version, '10')
        self.assertEquals(str(e), 'Expected 4 parts for version (got:1)')

        e = self.assertRaises(ValueError, Version, '10,12,14,15,15')
        self.assertEquals(str(e), 'Expected 4 parts for version (got:5)')

        e = self.assertRaises(ValueError, Version, 'aa,bb,cc,dd,ee')
        self.assertEquals(str(e),
            "invalid literal for int() with base 10: 'aa'")

        e = self.assertRaises(ValueError, Version, '10,13,14,-1')
        self.assertEquals(str(e), 'Invalid version number (received:-1)')

        e = self.assertRaises(ValueError, Version, '257,13,14,0')
        self.assertEquals(str(e), 'Invalid version number (received:257)')

        # as above but now with ints
        e = self.assertRaises(ValueError, Version, 10, 12)
        self.assertEquals(str(e), 'Expected 4 parts for version (got:2)')

        e = self.assertRaises(ValueError, Version, 10, 12, 14, 15, 15)
        self.assertEquals(str(e), 'Expected 4 parts for version (got:5)')

        e = self.assertRaises(ValueError, Version, 10, 13, 14, -1)
        self.assertEquals(str(e), 'Invalid version number (received:-1)')

        e = self.assertRaises(ValueError, Version, 257, 13, 14, 0)
        self.assertEquals(str(e), 'Invalid version number (received:257)')

        e = self.assertRaises(ValueError, Version, 0x100000000)
        self.assertEquals(str(e),
            'positive int up to 0xffffffff expected (i:4294967296)')

    def test_delete_int(self):
        v = Version('10,0,12,36')
        self.assertFalse(hasattr(v, '_int'))

        v._int = 'foo'
        v._buildParts('10', '0', '12', '36')
        self.assertFalse(hasattr(v, '_int'))

        v = Version(0x0a000c24)
        self.assertTrue(hasattr(v, '_int'))

    def test_int(self):
        v = Version('10,0,12,36')

        self.assertFalse(hasattr(v, '_int'))
        self.assertEquals(int(v), 0x0a000c24)
        self.assertTrue(hasattr(v, '_int'))
        self.assertEquals(v._int, 0x0a000c24)

        v._int = 92
        self.assertEquals(int(v), 92)

    def test_cmp(self):
        va = Version(0, 1, 0, 0)
        vb = Version(0, 0, 1, 0)

        # Version instance comparisons
        self.failUnless(va > vb)
        self.failUnless(vb < va)
        self.failUnless(va >= vb)
        self.failUnless(vb <= va)
        self.failUnless(va != vb)
        self.failUnless(vb == Version(0, 0, 1, 0))
        self.failUnless(vb == vb)

        self.failIf(va < vb)
        self.failIf(vb > va)
        self.failIf(va <= vb)
        self.failIf(vb >= va)
        self.failIf(va == vb)
        self.failIf(vb != Version(0, 0, 1, 0))
        self.failIf(vb != vb)

        # int comparisons
        self.failUnless(va == 0x010000)
        self.failUnless(vb == 0x0100)

        self.failIf(va != 0x010000)
        self.failIf(va < 0x010000)
        self.failIf(va > 0x010000)
        self.failIf(vb != 0x0100)
        self.failIf(vb < 0x0100)
        self.failIf(vb > 0x0100)

        # string comparisons
        self.failUnless(va == '0,1,0,0')
        self.failUnless(vb == '0,0,1,0')

        self.failIf(va != '0,1,0,0')
        self.failIf(va < '0,1,0,0')
        self.failIf(va > '0,1,0,0')
        self.failIf(vb != '0,0,1,0')
        self.failIf(vb < '0,0,1,0')
        self.failIf(vb > '0,0,1,0')

    def test_h264_version(self):
        self.assertTrue(isinstance(FLASH_MIN_H264, Version))
        self.assertEquals(FLASH_MIN_H264, '9,0,115,0')

        self.assertTrue(isinstance(FMS_MIN_H264, Version))
        self.assertEquals(FMS_MIN_H264, '3,0,1,1')

########NEW FILE########
__FILENAME__ = util
# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Utility classes for testing.
"""

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

from twisted.internet import error


class StringTransport:
    disconnecting = 0

    hostAddr = None
    peerAddr = None

    def __init__(self, hostAddress=None, peerAddress=None):
        self.clear()
        if hostAddress is not None:
            self.hostAddr = hostAddress
        if peerAddress is not None:
            self.peerAddr = peerAddress
        self.connected = True

    def clear(self):
        self.io = StringIO()

    def value(self):
        return self.io.getvalue()

    def write(self, data):
        if isinstance(data, unicode): # no, really, I mean it
            raise TypeError("Data must not be unicode")
        self.io.write(data)

    def writeSequence(self, data):
        self.io.write(''.join(data))

    def loseConnection(self):
        pass

    def getPeer(self):
        if self.peerAddr is None:
            return ('StringIO', repr(self.io))
        return self.peerAddr

    def getHost(self):
        if self.hostAddr is None:
            return ('StringIO', repr(self.io))
        return self.hostAddr


class StringTransportWithDisconnection(StringTransport):
    def loseConnection(self):
        if self.connected:
            self.connected = False
            self.protocol.connectionLost(error.ConnectionDone("Bye."))


class DummyDelayedCall:
    cancelled = False

    def cancel(self):
        self.cancelled = True
    
########NEW FILE########
__FILENAME__ = util
# -*- test-case-name: rtmpy.tests.test_util -*-

# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
RTMPy Utilities.

@since: 0.1
"""

import os.path
import sys
import time
import random
from urlparse import urlparse

try:
    from urlparse import parse_qs
except ImportError:
    # support for Python2.4
    from cgi import parse_qs

from pyamf.util import BufferedByteStream



class ParamedString(unicode):
    """
    Names of streams can have url query strings attached as additional
    parameters.

    An example::

        >>> q = ParamedString('foobar?spam=eggs&multi=baz&multi=gak')
        >>> q == 'foobar'
        True
        >>> q.spam
        'eggs'
        >>> q.multi
        ['baz', 'gak']
    """


    def __new__(cls, name):
        result = urlparse(name)

        x = unicode.__new__(cls, result[2])

        x._set_query(result[4])

        return x


    def _set_query(self, qs):
        unicode.__setattr__(self, '_query', parse_qs(qs))


    def __getattr__(self, name):
        try:
            value = self._query[name]
        except KeyError:
            raise AttributeError('Unknown attribute %r' % (name,))

        if len(value) == 1:
            return value[0]

        return value


    def __setattr__(self, name, value):
        self._query[name] = value


#: The number of milliseconds since the epoch.
boottime = None

def uptime_win32():
    """
    Returns the number of seconds between the epoch and when the Windows system
    was booted.

    @rtype: C{float}
    """
    import win32api

    return float(time.time()) - float(win32api.GetTickCount() / 1000)

def uptime_linux():
    """
    Returns the number of seconds between the epoch and when the Linux system
    was booted.

    @rtype: C{float}
    """
    import re

    try:
        fp = open('%s%s' % (os.path.sep, os.path.join('proc', 'uptime')))
    except IOError:
        return 0

    buffer = fp.read()
    fp.close()

    match = re.compile('^([0-9]+\.[0-9]{2})').match(buffer, 0)

    if match is None:
        return 0

    if len(match.groups()) < 1:
        return 0

    return float(time.time()) - float(match.groups()[0])

def uptime_darwin():
    """
    Returns the number of seconds between the epoch and when the Darwin system
    (Mac OSX) was booted.

    @rtype: C{float}
    """
    from twisted.internet import protocol, defer
    from twisted.python import failure, procutils

    try:
        command = procutils.which('sysctl')[0]
    except IndexError:
        return 0

    buffer = ''

    class _BackRelay(protocol.ProcessProtocol):
        def __init__(self, deferred):
            self.deferred = deferred
            self.s = BufferedByteStream()

        def errReceived(self, text):
            self.deferred.errback(failure.Failure(IOError()))
            self.deferred = None
            self.transport.loseConnection()

        def outReceived(self, text):
            self.s.write(text)

        def processEnded(self, reason):
            if self.deferred is not None:
                result = self.s.getvalue()
                self.deferred.callback(result)

    def getProcessOutput(executable, args=(), env={}, path='.'):
        from twisted.internet import reactor

        d = defer.Deferred()
        p = _BackRelay(d)

        reactor.spawnProcess(p, executable, args, env, path)

        return d

    def get_uptime():
        d = getProcessOutput(command, ('-nb', 'kern.boottime'))
        d.addErrback(lambda f: '')

        result = defer.waitForDeferred(d)
        yield result

        result.getResult()

    get_uptime = defer.deferredGenerator(get_uptime)

    get_uptime()

    import re

    match = re.compile('^([0-9]+)').match(buffer, 0)

    if match is None:
        return 0

    return float(time.time()) - float(buffer.strip())

def uptime():
    """
    Returns the number of milliseconds since the system was booted. This is
    system dependant, currently supported are Windows, Linux and Darwin.

    If a value cannot be calculated, a default value of when this function was
    first called is returned.

    @rtype: C{int}
    """
    return 0
    global boottime

    now = int(time.time() * 1000)

    if boottime is None:
        return now - boottime

    boottime = 100000

    if sys.platform.startswith('linux'):
        up_func = uptime_linux
    elif sys.platform.startswith('win'):
        up_func = uptime_win32
    elif sys.platform.startswith('darwin'):
        up_func = uptime_darwin
    else:
        import warnings

        warnings.warn("Could not find a platform specific uptime " \
            "function for '%s'" % sys.platform, RuntimeWarning)

        up_func = lambda: 0

    boottime = int(up_func() * 1000)

    if boottime == 0:
        boottime = now

    return now - boottime


def generateBytes(length, readable=False):
    """
    Generates a string of C{length} bytes of pseudo-random data. Used for
    filling in the gaps in unknown sections of the handshake.

    This function is going to to called a lot and is ripe for moving into C.

    @param length: The number of bytes to generate.
    @type length: C{int}
    @return: A random string of bytes, length C{length}.
    @rtype: C{str}
    @raise TypeError: C{int} expected for C{length}.
    """
    # FIXME: sloooow
    if not isinstance(length, (int, long)):
        raise TypeError('int expected for length (got:%s)' % (type(length),))

    bytes = ''

    i, j = 0, 0xff

    if readable:
        i, j = 0x41, 0x7a

    for x in xrange(0, length):
        bytes += chr(random.randint(i, j))

    return bytes


def get_callable_target(obj, name):
    """
    Returns a callable object based on the attribute of C{obj}.
    """
    target = getattr(obj, name, None)

    if target and hasattr(target, '__call__'):
        return target



def add_to_class(f, depth=1):
    """
    A decorator that allows you to access the class locals at parse time. Simple
    syntactic sugar, adds declarative style meta data to a class.

    This code is mostly ripped from zope.interface.

    Example usage::

        >>> @add_to_class
        >>> def is_awesome(locals, b):
        ...     locals['__is_awesome__'] = b
        ...
        >>> class MyClass:
        ...     is_awesome(True)
        ...
        >>> print MyClass.__is_awesome__
        True
    """
    def wrap(*args, **kwargs):
        frame = sys._getframe(depth)
        locals = frame.f_locals

        # Try to make sure we were called from a class def.
        if locals is frame.f_globals or '__module__' not in locals:
            raise TypeError(f + " can be used only from a class definition.")

        f(locals, *args, **kwargs)

    wrap.func_name = f.func_name
    wrap.__doc__ = f.__doc__

    return wrap

    

def getFailureMessage(failure):
    """
    Takes a L{twisted.python.failure.Failure} and returns the error message

    Replaces L{Failure.getErrorMessage} since it currently cannot handle
    unicode properly.
    """
    value = getattr(failure.value, "value", None)

    if not value:
        try:
            value = failure.value.args[0]
        except IndexError:
            value = ""

    return value
########NEW FILE########
__FILENAME__ = versions
# -*- test-case-name: rtmpy.tests.test_versions -*-

# Copyright the RTMPy Project
#
# RTMPy is free software: you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation, either version 2.1 of the License, or (at your option)
# any later version.
#
# RTMPy is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License along
# with RTMPy.  If not, see <http://www.gnu.org/licenses/>.

"""
Versions for products.

@see: L{Version}
@since: 0.1
"""


class Version(object):
    """
    Represents a version number, e.g. C{10,0,12,36}.
    """

    def __init__(self, *args):
        if len(args) == 1:
            if isinstance(args[0], (int, long)):
                self._fromInt(args[0])

                return
            elif isinstance(args[0], basestring):
                # maybe a regex here?
                self._buildParts(*args[0].split(','))

                return

        self._buildParts(*args)

    def _fromInt(self, i):
        self.parts = []

        if i > 0xffffffff or i < 0:
            raise ValueError('positive int up to 0xffffffff expected ' \
                '(i:%d)' % (i,))

        for x in xrange(0, 4):
            self.parts.append((i >> (24 - (x * 8))) & 0xff)

        self._int = i

    def _buildParts(self, *args):
        self.parts = []

        for a in args:
            a = int(a)

            if a < 0 or a > 256:
                raise ValueError('Invalid version number (received:%r)' % a)

            self.parts.append(a)

        if len(self.parts) != 4:
            raise ValueError('Expected 4 parts for version (got:%d)' % (
                len(self.parts),))

        if hasattr(self, '_int'):
            delattr(self, '_int')

    def __int__(self):
        """
        Returns a 4 byte integer representing the version.
        """
        if hasattr(self, '_int'):
            return self._int

        self._int = 0

        for x in xrange(0, 4):
            self._int += self.parts[x] << (24 - (x * 8))

        return self._int

    def __str__(self):
        return ','.join([str(x) for x in self.parts])

    def __repr__(self):
        return '%s.%s(%s) at 0x%x' % (
            self.__class__.__module__,
            self.__class__.__name__,
            str(self),
            id(self))

    def __cmp__(self, other):
        if isinstance(other, (int, long)):
            return cmp(int(self), other)

        if isinstance(other, Version):
            return cmp(self.parts, other.parts)

        if isinstance(other, basestring):
            return cmp(str(self), other)


#: Minimum version of the Adobe Flash Player that supports H.264 streaming
FLASH_MIN_H264 = Version('9,0,115,0')

#: Minimum version of Adobe Flash Media Server that supports H.264 streaming
FMS_MIN_H264 = Version('3,0,1,1')

########NEW FILE########
